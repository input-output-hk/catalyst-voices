// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.5.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `derive_xprv_helper`, `mnemonic_to_xprv_helper`, `sign_data_helper`, `verify_signature_xprv_helper`, `verify_signature_xpub_helper`, `xpublic_key_helper`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `from`, `from`

/// Generate a new extended private key (`XPrv`) from a mnemonic and passphrase.
/// Note that this function only works with BIP-0039 mnemonics.
/// For more information: Cardano Icarus master node derivation
/// <https://github.com/satoshilabs/slips/blob/master/slip-0023.md>
///
/// # Arguments
///
/// - `mnemonic`: A string representing the mnemonic.
/// - `passphrase`: An optional string representing the passphrase (aka. password).
///
/// # Returns
///
/// Returns a bytes of extended private key as a `Result`.
///
/// # Errors
///
/// Returns an error if the mnemonic is invalid.
Future<Bip32Ed25519XPrivateKey> mnemonicToXprv(
        {required String mnemonic, String? passphrase}) =>
    RustLib.instance.api.crateApiKeyDerivationMnemonicToXprv(
        mnemonic: mnemonic, passphrase: passphrase);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bip32Ed25519Signature>>
abstract class Bip32Ed25519Signature implements RustOpaqueInterface {
  /// Get the inner bytes.
  U8Array64 get inner;

  /// Create a new `Bip32Ed25519Signature` from the given bytes.
  factory Bip32Ed25519Signature({required U8Array64 sigBytes}) =>
      RustLib.instance.api
          .crateApiKeyDerivationBip32Ed25519SignatureNew(sigBytes: sigBytes);

  /// Convert to a hex string.
  String toHex();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bip32Ed25519XPrivateKey>>
abstract class Bip32Ed25519XPrivateKey implements RustOpaqueInterface {
  /// Derive a new extended private key from the given extended private key.
  /// - V2 derivation scheme is used as it is mention in [SLIP-0023](https://github.com/satoshilabs/slips/blob/master/slip-0023.md).
  /// - More information about child key derivation can be found in [BIP32-Ed25519](https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf).
  ///
  /// # Arguments
  ///
  /// - `xprv_bytes`: An extended private key bytes of type `Bip32Ed25519XPrivateKey`.
  /// - `path`: Derivation path. eg. m/0/2'/3 where ' represents hardened derivation.
  ///
  /// # Returns
  ///
  /// Returns a bytes of extended private key as a `Result`.
  ///
  /// # Errors
  ///
  /// Returns an error if the derivation path is invalid.
  Future<Bip32Ed25519XPrivateKey> deriveXprv({required String path});

  /// Drop the extended private key.
  void drop();

  /// Extract the chain code from the extended private key.
  /// The chain code is the last 32 bytes of the extended private key.
  ///
  /// # Returns
  ///
  /// Returns a 32 length bytes representing the chain code.
  U8Array32 get chainCode;

  /// Extract the extended secret key from the extended private key.
  /// The extended secret key is the first 64 bytes of the extended private key.
  ///
  /// # Returns
  ///
  /// Returns a 64 length bytes representing the extended secret key.
  U8Array64 get extendedSecretKey;

  /// Get the inner bytes.
  U8Array96 get inner;

  /// Create a new `Bip32Ed25519XPrivateKey` from the given bytes.
  factory Bip32Ed25519XPrivateKey({required U8Array96 xprvBytes}) => RustLib
      .instance.api
      .crateApiKeyDerivationBip32Ed25519XPrivateKeyNew(xprvBytes: xprvBytes);

  /// Sign the given data with the given extended private key.
  ///
  /// # Arguments
  ///
  /// - `data`: The data to sign.
  ///
  /// # Returns
  /// Returns a 64 length bytes `Bip32Ed25519Signature` representing the signature.
  ///
  /// # Errors
  ///
  /// Returns an error if the extended private key is invalid.
  Future<Bip32Ed25519Signature> signData({required List<int> data});

  /// Convert to a hex string.
  String toHex();

  /// Verify the signature on the given data using extended private key.
  ///
  /// # Arguments
  ///
  /// - `data`: The data to sign.
  /// - `signature`: The signature to check.
  ///
  /// # Returns
  /// Returns a boolean value indicating if the signature match the sign data
  /// True if the signature is valid and match the sign data, false otherwise.
  ///
  /// # Errors
  ///
  /// Returns an error if the extended private key or signature is invalid.
  Future<bool> verifySignature(
      {required List<int> data, required Bip32Ed25519Signature signature});

  /// Get extended public key from the given extended private key.
  ///
  /// # Returns
  ///
  /// Returns a 64 length bytes `Bip32Ed25519XPublicKey` representing the extended
  /// public key.
  ///
  /// # Errors
  ///
  /// Returns an error if the extended private key is invalid.
  Future<Bip32Ed25519XPublicKey> xpublicKey();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bip32Ed25519XPublicKey>>
abstract class Bip32Ed25519XPublicKey implements RustOpaqueInterface {
  /// Extract the chain code from the extended public key.
  /// The chain code is the last 32 bytes of the extended public key.
  ///
  /// # Returns
  ///
  /// Returns a 32 length bytes representing the chain code.
  U8Array32 get chainCode;

  /// Get the inner bytes.
  U8Array64 get inner;

  /// Extract the public key from the extended public key.
  /// The public key is the first 32 bytes of the extended public key.
  ///
  /// # Returns
  ///
  /// Returns a 32 length bytes representing the public key.
  U8Array32 get publicKey;

  /// Create a new `Bip32Ed25519XPublicKey` from the given bytes.
  factory Bip32Ed25519XPublicKey({required U8Array64 xpubBytes}) =>
      RustLib.instance.api
          .crateApiKeyDerivationBip32Ed25519XPublicKeyNew(xpubBytes: xpubBytes);

  /// Convert to a hex string.
  String toHex();

  /// Verify the signature on the given data using extended public key.
  ///
  /// # Arguments
  ///
  /// - `data`: The data to sign.
  /// - `signature`: The signature to check.
  ///
  /// # Returns
  /// Returns a boolean value indicating if the signature match the sign data
  /// True if the signature is valid and match the sign data, false otherwise.
  ///
  /// # Errors
  ///
  /// Returns an error if the extended public key or signature is invalid.
  Future<bool> verifySignature(
      {required List<int> data, required Bip32Ed25519Signature signature});
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array32(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array32.init() : this(Uint8List(arraySize));
}

class U8Array64 extends NonGrowableListView<int> {
  static const arraySize = 64;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array64(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array64.init() : this(Uint8List(arraySize));
}

class U8Array96 extends NonGrowableListView<int> {
  static const arraySize = 96;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array96(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array96.init() : this(Uint8List(arraySize));
}
