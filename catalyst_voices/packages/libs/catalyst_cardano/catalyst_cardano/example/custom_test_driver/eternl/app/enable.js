var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const global$1 = globalThis || void 0 || self;
/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove$1 = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn$2 = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isRegExp$1 = (val) => toTypeString$1(val) === "[object RegExp]";
const isFunction$1 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$4 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$4(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = (value2) => objectToString$1.call(value2);
const toRawType = (value2) => {
  return toTypeString$1(value2).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize$1(str)}` : ``;
    return s;
  }
);
const hasChanged = (value2, oldValue) => !Object.is(value2, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value2, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value: value2
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$2(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global$1 !== "undefined" ? global$1 : {});
};
function normalizeStyle(value2) {
  if (isArray$1(value2)) {
    const res = {};
    for (let i = 0; i < value2.length; i++) {
      const item = value2[i];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$2(value2) || isObject$4(value2)) {
    return value2;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value2) {
  let res = "";
  if (isString$2(value2)) {
    res = value2;
  } else if (isArray$1(value2)) {
    for (let i = 0; i < value2.length; i++) {
      const normalized = normalizeClass(value2[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$4(value2)) {
    for (const name2 in value2) {
      if (value2[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value2) {
  return !!value2 || value2 === "";
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString$1 = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$1(val) || isObject$4(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$4(val) && !isArray$1(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v2, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v2) ? `Symbol(${(_a = v2.description) != null ? _a : i})` : v2
  );
};
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= ~64;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= ~2;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= ~1;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      e = next;
    }
  }
  let error2;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error2) error2 = err;
        }
      }
      e = next;
    }
  }
  if (error2) throw error2;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= ~16;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  const dep = computed2.dep;
  computed2.flags |= 2;
  if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
    computed2.flags &= ~2;
    return;
  }
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value2 = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value2, computed2._value)) {
      computed2._value = value2;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= ~2;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= ~4;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target2, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target2);
    if (!depsMap) {
      targetMap.set(target2, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger$1(target2, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target2);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run2 = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run2);
  } else {
    const targetIsArray = isArray$1(target2);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run2(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run2(depsMap.get(key));
      }
      if (isArrayIndex) {
        run2(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run2(depsMap.get(ITERATE_KEY));
            if (isMap(target2)) {
              run2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run2(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run2(depsMap.get(ITERATE_KEY));
            if (isMap(target2)) {
              run2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target2)) {
            run2(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray$1(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value2) => {
      value2[1] = toReactive(value2[1]);
      return value2;
    });
  },
  every(fn, thisArg) {
    return apply$2(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply$2(this, "filter", fn, thisArg, (v2) => v2.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply$2(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply$2(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply$2(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply$2(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply$2(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply$2(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply$2(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply$2(self2, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self2);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self2, method, fn, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self2);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty$1(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target2, key, receiver) {
    if (key === "__v_skip") return target2["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target2) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target2) === Object.getPrototypeOf(receiver)) {
        return target2;
      }
      return;
    }
    const targetIsArray = isArray$1(target2);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(
      target2,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target2) ? target2 : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target2, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$4(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target2, key, value2, receiver) {
    let oldValue = target2[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value2) && !isReadonly(value2)) {
        oldValue = toRaw(oldValue);
        value2 = toRaw(value2);
      }
      if (!isArray$1(target2) && isRef(oldValue) && !isRef(value2)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value2;
          return true;
        }
      }
    }
    const hadKey = isArray$1(target2) && isIntegerKey(key) ? Number(key) < target2.length : hasOwn$2(target2, key);
    const result = Reflect.set(
      target2,
      key,
      value2,
      isRef(target2) ? target2 : receiver
    );
    if (target2 === toRaw(receiver)) {
      if (!hadKey) {
        trigger$1(target2, "add", key, value2);
      } else if (hasChanged(value2, oldValue)) {
        trigger$1(target2, "set", key, value2);
      }
    }
    return result;
  }
  deleteProperty(target2, key) {
    const hadKey = hasOwn$2(target2, key);
    target2[key];
    const result = Reflect.deleteProperty(target2, key);
    if (result && hadKey) {
      trigger$1(target2, "delete", key, void 0);
    }
    return result;
  }
  has(target2, key) {
    const result = Reflect.has(target2, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target2, "has", key);
    }
    return result;
  }
  ownKeys(target2) {
    track(
      target2,
      "iterate",
      isArray$1(target2) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target2);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target2, key) {
    return true;
  }
  deleteProperty(target2, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value2) => value2;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target2 = this["__v_raw"];
    const rawTarget = toRaw(target2);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target2[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value: value2, done } = innerIterator.next();
        return done ? { value: value2, done } : {
          value: isPair ? [wrap(value2[0]), wrap(value2[1])] : wrap(value2),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target2 = this["__v_raw"];
      const rawTarget = toRaw(target2);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target2.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target2.get(rawKey));
      } else if (target2 !== rawTarget) {
        target2.get(key);
      }
    },
    get size() {
      const target2 = this["__v_raw"];
      !readonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
      return Reflect.get(target2, "size", target2);
    },
    has(key) {
      const target2 = this["__v_raw"];
      const rawTarget = toRaw(target2);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target2.has(key) : target2.has(key) || target2.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target2 = observed["__v_raw"];
      const rawTarget = toRaw(target2);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target2.forEach((value2, key) => {
        return callback.call(thisArg, wrap(value2), wrap(key), observed);
      });
    }
  };
  extend$1(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value2) {
        if (!shallow && !isShallow(value2) && !isReadonly(value2)) {
          value2 = toRaw(value2);
        }
        const target2 = toRaw(this);
        const proto = getProto(target2);
        const hadKey = proto.has.call(target2, value2);
        if (!hadKey) {
          target2.add(value2);
          trigger$1(target2, "add", value2, value2);
        }
        return this;
      },
      set(key, value2) {
        if (!shallow && !isShallow(value2) && !isReadonly(value2)) {
          value2 = toRaw(value2);
        }
        const target2 = toRaw(this);
        const { has: has2, get: get2 } = getProto(target2);
        let hadKey = has2.call(target2, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target2, key);
        }
        const oldValue = get2.call(target2, key);
        target2.set(key, value2);
        if (!hadKey) {
          trigger$1(target2, "add", key, value2);
        } else if (hasChanged(value2, oldValue)) {
          trigger$1(target2, "set", key, value2);
        }
        return this;
      },
      delete(key) {
        const target2 = toRaw(this);
        const { has: has2, get: get2 } = getProto(target2);
        let hadKey = has2.call(target2, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target2, key);
        }
        get2 ? get2.call(target2, key) : void 0;
        const result = target2.delete(key);
        if (hadKey) {
          trigger$1(target2, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target2 = toRaw(this);
        const hadItems = target2.size !== 0;
        const result = target2.clear();
        if (hadItems) {
          trigger$1(
            target2,
            "clear",
            void 0,
            void 0
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target2, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target2;
    }
    return Reflect.get(
      hasOwn$2(instrumentations, key) && key in target2 ? instrumentations : target2,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value2) {
  return value2["__v_skip"] || !Object.isExtensible(value2) ? 0 : targetTypeMap(toRawType(value2));
}
function reactive(target2) {
  if (isReadonly(target2)) {
    return target2;
  }
  return createReactiveObject(
    target2,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target2) {
  return createReactiveObject(
    target2,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target2) {
  return createReactiveObject(
    target2,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target2) {
  return createReactiveObject(
    target2,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$4(target2)) {
    return target2;
  }
  if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
    return target2;
  }
  const existingProxy = proxyMap.get(target2);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target2);
  if (targetType === 0) {
    return target2;
  }
  const proxy = new Proxy(
    target2,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target2, proxy);
  return proxy;
}
function isReactive(value2) {
  if (isReadonly(value2)) {
    return isReactive(value2["__v_raw"]);
  }
  return !!(value2 && value2["__v_isReactive"]);
}
function isReadonly(value2) {
  return !!(value2 && value2["__v_isReadonly"]);
}
function isShallow(value2) {
  return !!(value2 && value2["__v_isShallow"]);
}
function isProxy(value2) {
  return value2 ? !!value2["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value2) {
  if (!hasOwn$2(value2, "__v_skip") && Object.isExtensible(value2)) {
    def(value2, "__v_skip", true);
  }
  return value2;
}
const toReactive = (value2) => isObject$4(value2) ? reactive(value2) : value2;
const toReadonly = (value2) => isObject$4(value2) ? readonly(value2) : value2;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value2) {
  return createRef(value2, false);
}
function shallowRef(value2) {
  return createRef(value2, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value2, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value2 : toRaw(value2);
    this._value = isShallow2 ? value2 : toReactive(value2);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target2, key, receiver) => key === "__v_raw" ? target2 : unref(Reflect.get(target2, key, receiver)),
  set: (target2, key, value2, receiver) => {
    const oldValue = target2[key];
    if (isRef(oldValue) && !isRef(value2)) {
      oldValue.value = value2;
      return true;
    } else {
      return Reflect.set(target2, key, value2, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction$1(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$1(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove$1(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
          oldValue = newValue;
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value2, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$4(value2) || value2["__v_skip"]) {
    return value2;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value2)) {
    return value2;
  }
  seen.add(value2);
  depth--;
  if (isRef(value2)) {
    traverse(value2.value, depth, seen);
  } else if (isArray$1(value2)) {
    for (let i = 0; i < value2.length; i++) {
      traverse(value2[i], depth, seen);
    }
  } else if (isSet(value2) || isMap(value2)) {
    value2.forEach((v2) => {
      traverse(v2, depth, seen);
    });
  } else if (isPlainObject$2(value2)) {
    for (const key in value2) {
      traverse(value2[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value2)) {
      if (Object.prototype.propertyIsEnumerable.call(value2, key)) {
        traverse(value2[key], depth, seen);
      }
    }
  }
  return value2;
}
/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack$1 = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack$1[stack$1.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open2 = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open2, ...formatProps(vnode.props), close] : [open2 + close];
}
function formatProps(props4) {
  const res = [];
  const keys = Object.keys(props4);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props4[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value2, raw) {
  if (isString$2(value2)) {
    value2 = JSON.stringify(value2);
    return raw ? value2 : [`${key}=${value2}`];
  } else if (typeof value2 === "number" || typeof value2 === "boolean" || value2 == null) {
    return raw ? value2 : [`${key}=${value2}`];
  } else if (isRef(value2)) {
    value2 = formatProp(key, toRaw(value2.value), true);
    return raw ? value2 : [`${key}=Ref<`, value2, `>`];
  } else if (isFunction$1(value2)) {
    return [`${key}=fn${value2.name ? `<${value2.name}>` : ``}`];
  } else {
    value2 = toRaw(value2);
    return raw ? value2 : [`${key}=`, value2];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray$1(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue$1 = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id3) {
  let start = flushIndex + 1;
  let end = queue$1.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue$1[middle];
    const middleJobId = getId$1(middleJob);
    if (middleJobId < id3 || middleJobId === id3 && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId$1(job);
    const lastJob = queue$1[queue$1.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId$1(lastJob)) {
      queue$1.push(job);
    } else {
      queue$1.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  for (; i < queue$1.length; i++) {
    const cb = queue$1[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue$1.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= ~1;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId$1(a) - getId$1(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= ~1;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId$1 = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job) {
        job.flags &= ~1;
      }
    }
    flushIndex = -1;
    queue$1.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue$1.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value2, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value2);
      }
      bindings.push({
        dir,
        instance,
        value: value2,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props4) => props4 && (props4.disabled || props4.disabled === "");
const isTeleportDeferred = (props4) => props4 && (props4.defer || props4.defer === "");
const isTargetSVG = (target2) => typeof SVGElement !== "undefined" && target2 instanceof SVGElement;
const isTargetMathML = (target2) => typeof MathMLElement === "function" && target2 instanceof MathMLElement;
const resolveTarget = (props4, select) => {
  const targetSelector = props4 && props4.to;
  if (isString$2(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target2 = select(targetSelector);
      return target2;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          if (parentComponent && parentComponent.isCE) {
            parentComponent.ce._teleportTarget = container2;
          }
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target2 = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target2, n2, createText, insert);
        if (target2) {
          if (namespace !== "svg" && isTargetSVG(target2)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target2)) {
            namespace = "mathml";
          }
          if (!disabled) {
            mount(target2, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        queuePostRenderEffect(() => {
          mountToTarget();
          n2.el.__isMounted = true;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
          delete n1.el.__isMounted;
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target2 = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target2;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target2)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target2)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target2,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target: target2,
      props: props4
    } = vnode;
    if (target2) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props4);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props: props4 } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props4)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  const target2 = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target2) {
    const disabled = isTeleportDisabled(vnode.props);
    const targetNode = target2._lpa || target2.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetStart = targetNode;
        vnode.targetAnchor = targetNode && nextSibling(targetNode);
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target2._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target2, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target2,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target2, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target2) {
    insert(targetStart, target2);
    insert(targetAnchor, target2);
  }
  return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props4, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props4);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props4, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props4;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$1(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props4,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$1(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$1(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$1(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value2 = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn$2(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value2, refs]);
  } else {
    const _isString = isString$2(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$1(existing) && remove$1(existing, refValue);
          } else {
            if (!isArray$1(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value2;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value2;
          }
        } else if (_isRef) {
          ref3.value = value2;
          if (rawRef.k) refs[rawRef.k] = value2;
        } else ;
      };
      if (value2) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
getGlobalThis$1().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis$1().cancelIdleCallback || ((id3) => clearTimeout(id3));
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props4, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache2 = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache2.forEach((vnode, key) => {
        const name2 = getComponentName(vnode.type);
        if (name2 && !filter(name2)) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache2.get(key);
      if (cached && (!current || !isSameVNodeType(cached, current))) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache2.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props4.include, props4.exclude],
      ([include, exclude]) => {
        include && pruneCache((name2) => matches(include, name2));
        exclude && pruneCache((name2) => !matches(exclude, name2));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache2.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return current = null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode$1(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      if (vnode.type === Comment) {
        current = null;
        return vnode;
      }
      const comp = vnode.type;
      const name2 = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props4;
      if (include && (!name2 || !matches(include, name2)) || exclude && name2 && matches(exclude, name2)) {
        vnode.shapeFlag &= ~256;
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache2.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name2) {
  if (isArray$1(pattern)) {
    return pattern.some((p2) => matches(p2, name2));
  } else if (isString$2(pattern)) {
    return pattern.split(",").includes(name2);
  } else if (isRegExp$1(pattern)) {
    pattern.lastIndex = 0;
    return pattern.test(name2);
  }
  return false;
}
function onActivated(hook, target2) {
  registerKeepAliveHook(hook, "a", target2);
}
function onDeactivated(hook, target2) {
  registerKeepAliveHook(hook, "da", target2);
}
function registerKeepAliveHook(hook, type, target2 = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target2;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target2);
  if (target2) {
    let current = target2.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target2, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target2, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove$1(keepAliveRoot[type], injected);
  }, target2);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target2 = currentInstance, prepend = false) {
  if (target2) {
    const hooks = target2[type] || (target2[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target2);
      const res = callWithAsyncErrorHandling(hook, target2, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target2 = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target2);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target2 = currentInstance) {
  injectHook("ec", hook, target2);
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2;
  const sourceIsArray = isArray$1(source);
  if (sourceIsArray || isString$2(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? toReactive(source[i]) : source[i],
        i,
        void 0,
        cached
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached);
    }
  } else if (isObject$4(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function renderSlot(slots, name2, props4 = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props4, fallback)],
      64
    );
  }
  let slot = slots[name2];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props4));
  const slotKey = props4.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name2}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || [],
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$2(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props: props4, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props4[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn$2(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$2(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props4[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$2(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value2) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value2;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn$2(data, key)) {
      data[key] = value2;
      return true;
    } else if (hasOwn$2(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value2;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$2(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$2(normalizedProps, key) || hasOwn$2(ctx, key) || hasOwn$2(publicPropertiesMap, key) || hasOwn$2(appContext.config.globalProperties, key);
  },
  defineProperty(target2, key, descriptor) {
    if (descriptor.get != null) {
      target2._.accessCache[key] = 0;
    } else if (hasOwn$2(descriptor, "value")) {
      this.set(target2, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target2, key, descriptor);
  }
};
function normalizePropsOrEmits(props4) {
  return isArray$1(props4) ? props4.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props4;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components: components2,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$4(data)) ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v2) => c.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components2) instance.components = components2;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$4(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$2(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction$1(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$4(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$4(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions(to, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$1(to) && isArray$1(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$4(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name2, component) {
        if (!component) {
          return context.components[name2];
        }
        context.components[name2] = component;
        return app2;
      },
      directive(name2, directive) {
        if (!directive) {
          return context.directives[name2];
        }
        context.directives[name2] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app2._instance,
            16
          );
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value2) {
        context.provides[key] = value2;
        return app2;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value2) {
  if (!currentInstance) ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value2;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props4 = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props4, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props4)) {
      props4[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props4 : shallowReactive(props4);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props4;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props: props4,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props4);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value2 = rawProps[key];
        if (options) {
          if (hasOwn$2(attrs, key)) {
            if (value2 !== attrs[key]) {
              attrs[key] = value2;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props4[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value2,
              instance,
              false
            );
          }
        } else {
          if (value2 !== attrs[key]) {
            attrs[key] = value2;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props4, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$2(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$2(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props4[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props4[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$2(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger$1(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props4, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value2 = rawProps[key];
      let camelKey;
      if (options && hasOwn$2(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props4[camelKey] = value2;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value2;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value2 !== attrs[key]) {
          attrs[key] = value2;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props4);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props4[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$2(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props4, key, value2, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$2(opt, "default");
    if (hasDefault && value2 === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value2 = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value2 = propsDefaults[key] = defaultValue.call(
            null,
            props4
          );
          reset();
        }
      } else {
        value2 = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value2);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value2 = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value2 === "" || value2 === hyphenate(key))) {
        value2 = true;
      }
    }
  }
  return value2;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props4, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props4);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend$1({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray$1(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction$1(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction$1(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn$2(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$4(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value2) => isArray$1(value2) ? value2.map(normalizeVNode) : [normalizeVNode(value2)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value2 = rawSlots[key];
    if (isFunction$1(value2)) {
      slots[key] = normalizeSlot(key, value2, ctx);
    } else if (value2 != null) {
      const normalized = normalizeSlotValue(value2);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || key !== "_") {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target2 = getGlobalThis$1();
  target2.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props: props4, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props4 && props4.is,
      props4
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props4) {
      for (const key in props4) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props4[key], namespace, parentComponent);
        }
      }
      if ("value" in props4) {
        hostPatchProp(el, "value", null, props4.value, namespace);
      }
      if (vnodeHook = props4.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props4 && props4.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props: props4 } = initialVNode;
        const { bm, m: m2, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props4 && props4.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode && type.__asyncHydrate) {
            type.__asyncHydrate(
              el,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props4 && props4.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update6 = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update6();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props: props4,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props4 && props4.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props4 && props4.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m: m2, a } = instance;
    invalidateMount(m2);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props: props4 }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props4 && props4.encoding && props4.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= ~32;
    job.flags &= ~4;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$1(ch1) && isArray$1(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v2, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v2 = result.length - 1;
      while (u < v2) {
        c = u + v2 >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v2 = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v2 = result[u - 1];
  while (u-- > 0) {
    result[u] = v2;
    v2 = p2[v2];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend$1({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value2, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value2)) {
    cb = value2;
  } else {
    cb = value2.handler;
    options = value2;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
const getModelModifiers = (props4, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props4.modelModifiers : props4[`${modelName}Modifiers`] || props4[`${camelize(modelName)}Modifiers`] || props4[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props4 = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props4, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props4[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props4[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props4[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props4[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$4(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$2(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$2(options, hyphenate(key)) || hasOwn$2(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props: props4,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target2, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target2, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props4) : props4,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          false ? shallowReadonly(props4) : props4,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          false ? shallowReadonly(props4) : props4,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props4) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props4)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits3 = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits3);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits3, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits3);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$1(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value2, inVOnce = false) {
  isBlockTreeEnabled += value2;
  if (value2 < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props4, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props4,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props4, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props4,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode$1(value2) {
  return value2 ? value2.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$2(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props4 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props: props4,
    key: props4 && normalizeKey(props4),
    ref: props4 && normalizeRef(props4),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$2(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props4 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode$1(type)) {
    const cloned = cloneVNode(
      type,
      props4,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props4) {
    props4 = guardReactiveProps(props4);
    let { class: klass, style } = props4;
    if (klass && !isString$2(klass)) {
      props4.class = normalizeClass(klass);
    }
    if (isObject$4(style)) {
      if (isProxy(style) && !isArray$1(style)) {
        style = extend$1({}, style);
      }
      props4.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$4(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props4,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props4) {
  if (!props4) return null;
  return isProxy(props4) || isInternalObject(props4) ? extend$1({}, props4) : props4;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props: props4, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props4 || {}, extraProps) : props4;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$1(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode$1(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$1(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$2 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$2++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis$1();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1) setters.forEach((set2) => set2(v2));
      else setters[0](v2);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => currentInstance = v2
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => isInSSRComponentSetup = v2
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props: props4, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props4, isStateful, isSSR);
  initSlots(instance, children, optimized);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise$1(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$4(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target2, key) {
    track(target2, "get", "");
    return target2[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target2, key) {
        if (key in target2) {
          return target2[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target2, key) {
        return key in target2 || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name2 = getComponentName(Component);
  if (!name2 && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name2 = match[1];
    }
  }
  if (!name2 && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name2 = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value2) {
  return isFunction$1(value2) && "__vccOpts" in value2;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$4(propsOrChildren) && !isArray$1(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode$1(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version = "3.5.13";
/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props4) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props4 && props4.multiple != null) {
      el.setAttribute("multiple", props4.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id3) {
    el.setAttribute(id3, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props4, { slots }) => h(BaseTransition, resolveTransitionProps(props4), slots)
);
const callHook = (hook, args = []) => {
  if (isArray$1(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name: name2 = "v",
    type,
    duration: duration2,
    enterFromClass = `${name2}-enter-from`,
    enterActiveClass = `${name2}-enter-active`,
    enterToClass = `${name2}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name2}-leave-from`,
    leaveActiveClass = `${name2}-leave-active`,
    leaveToClass = `${name2}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration2);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration2) {
  if (duration2 == null) {
    return null;
  } else if (isObject$4(duration2)) {
    return [NumberOf(duration2.enter), NumberOf(duration2.leave)];
  } else {
    const n = NumberOf(duration2);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id3 = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id3 === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout: timeout2, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout2 + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout2 = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout2 = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout2 = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout2 = Math.max(transitionTimeout, animationTimeout);
    type = timeout2 > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout: timeout2,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value2, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value2 = (value2 ? [value2, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value2 == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value2);
  } else {
    el.className = value2;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value: value2 }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value2) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value2);
    }
  },
  mounted(el, { value: value2 }, { transition }) {
    if (transition && value2) {
      transition.enter(el);
    }
  },
  updated(el, { value: value2, oldValue }, { transition }) {
    if (!value2 === !oldValue) return;
    if (transition) {
      if (value2) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value2);
    }
  },
  beforeUnmount(el, { value: value2 }) {
    setDisplay(el, value2);
  }
};
function setDisplay(el, value2) {
  el.style.display = value2 ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value2;
}
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$2(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$2(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name2, val) {
  if (isArray$1(val)) {
    val.forEach((v2) => setStyle(style, name2, v2));
  } else {
    if (val == null) val = "";
    if (name2.startsWith("--")) {
      style.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style, name2);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes$1 = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name2 = camelize(rawName);
  if (name2 !== "filter" && name2 in style) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize$1(name2);
  for (let i = 0; i < prefixes$1.length; i++) {
    const prefixed = prefixes$1[i] + name2;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value2, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value2 == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value2);
    }
  } else {
    if (value2 == null || isBoolean2 && !includeBooleanAttr(value2)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean2 ? "" : isSymbol(value2) ? String(value2) : value2
      );
    }
  }
}
function patchDOMProp(el, key, value2, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value2 != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value2) : value2;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value2 == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value2);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value2 == null) {
      el.removeAttribute(key);
    }
    el._value = value2;
    return;
  }
  let needRemove = false;
  if (value2 === "" || value2 == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value2 = includeBooleanAttr(value2);
    } else if (value2 == null && type === "string") {
      value2 = "";
      needRemove = true;
    } else if (type === "number") {
      value2 = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value2;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener$1(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener$1(el, name2, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name2, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options;
  if (optionsModifierRE.test(name2)) {
    options = {};
    let m2;
    while (m2 = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name2[2] === ":" ? name2.slice(3) : hyphenate(name2.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value2) {
  if (isArray$1(value2)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value2.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value2;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString$2(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value2, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$1(value2)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$2(value2)) {
    return false;
  }
  return key in el;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn, modifiers) => {
  const cache2 = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app2._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
/*!
  * shared v9.14.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name2, shareable = false) => !shareable ? Symbol(name2) : Symbol.for(name2);
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber$1 = (val) => typeof val === "number" && isFinite(val);
const isDate$1 = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject$1(val) && Object.keys(val).length === 0;
const assign$1 = Object.assign;
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global$1 !== "undefined" ? global$1 : {});
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn$1(obj, key) {
  return hasOwnProperty.call(obj, key);
}
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$3 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$3(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value2) => objectToString.call(value2);
const isPlainObject$1 = (val) => {
  if (!isObject$3(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject$1(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join$1(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
function incrementer(code2) {
  let current = code2;
  return () => ++current;
}
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const isNotObjectOrIsArray = (val) => !isObject$3(val) || isArray(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack2 = [{ src, des }];
  while (stack2.length) {
    const { src: src2, des: des2 } = stack2.pop();
    Object.keys(src2).forEach((key) => {
      if (isObject$3(src2[key]) && !isObject$3(des2[key])) {
        des2[key] = Array.isArray(src2[key]) ? [] : {};
      }
      if (isNotObjectOrIsArray(des2[key]) || isNotObjectOrIsArray(src2[key])) {
        des2[key] = src2[key];
      } else {
        stack2.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}
/*!
  * message-compiler v9.14.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function createPosition(line, column, offset2) {
  return { line, column, offset: offset2 };
}
function createLocation(start, end, source) {
  const loc = { start, end };
  return loc;
}
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$1(message2, ...args) {
  if (args.length === 1 && isObject$2(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message2.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
const assign = Object.assign;
const isString = (val) => typeof val === "string";
const isObject$2 = (val) => val !== null && typeof val === "object";
function join(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
const CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
const warnMessages = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code2, loc, ...args) {
  const msg = format$1(warnMessages[code2], ...args || []);
  const message2 = { message: String(msg), code: code2 };
  if (loc) {
    message2.location = loc;
  }
  return message2;
}
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
const errorMessages = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc, options = {}) {
  const { domain, messages: messages2, args } = options;
  const msg = format$1((messages2 || errorMessages)[code2] || "", ...args || []);
  const error2 = new SyntaxError(String(msg));
  error2.code = code2;
  if (loc) {
    error2.location = loc;
  }
  error2.domain = domain;
  return error2;
}
function defaultOnError(error2) {
  throw error2;
}
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
  const isLF = (index2) => _buf[index2] === CHAR_LF;
  const isPS = (index2) => _buf[index2] === CHAR_PS;
  const isLS = (index2) => _buf[index2] === CHAR_LS;
  const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
  const index = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset2) => isCRLF(offset2) || isPS(offset2) || isLS(offset2) ? CHAR_LF : _buf[offset2];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset2 = 0) {
    _peekOffset = offset2;
  }
  function skipToPeek() {
    const target2 = _index + _peekOffset;
    while (target2 !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options = {}) {
  const location2 = options.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options;
  function emitError(code2, pos, offset2, ...args) {
    const ctx = context();
    pos.column += offset2;
    pos.offset += offset2;
    if (onError) {
      const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type, value2) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token2 = { type };
    if (location2) {
      token2.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value2 != null) {
      token2.value = value2;
    }
    return token2;
  }
  const getEndToken = (context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf2 = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf2 += scnr.currentPeek();
      scnr.peek();
    }
    return buf2;
  }
  function skipSpaces(scnr) {
    const buf2 = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf2;
  }
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95;
  }
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn = () => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        return isTextStart(scnr, false);
      }
    };
    const ret = fn();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset = true) {
    const fn = (hasSpace = false, prev = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  function isIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36;
  }
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  function isNamedIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36 || // $
    cc === 45;
  }
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  function isDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  function isHexDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57 || // 0-9
    cc >= 65 && cc <= 70 || // A-F
    cc >= 97 && cc <= 102;
  }
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();
    if (ch !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf2 = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf2 += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf2 += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf2 += ch;
          scnr.next();
        }
      } else {
        buf2 += ch;
        scnr.next();
      }
    }
    return buf2;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name2 = "";
    while (ch = takeNamedIdentifierChar(scnr)) {
      name2 += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name2;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value2 = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value2 += `-${getDigits(scnr)}`;
    } else {
      value2 += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value2;
  }
  function isLiteral2(ch) {
    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    while (ch = takeChar(scnr, isLiteral2)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i = 0; i < digits; i++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  function isInvalidIdentifier(ch) {
    return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    while (ch = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch = "";
    let name2 = "";
    while (ch = takeIdentifierChar(scnr)) {
      name2 += ch;
    }
    return name2;
  }
  function readLinkedRefer(scnr) {
    const fn = (buf2) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf2;
      } else if (ch === CHAR_SP) {
        return buf2;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf2 += ch;
        scnr.next();
        return fn(buf2);
      } else {
        buf2 += ch;
        scnr.next();
        return fn(buf2);
      }
    };
    return fn("");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token2 = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token2 = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token2;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token2 = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token2;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token2 = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token2;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token2 = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token2;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token2 = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token2;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token2 = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token2;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token2 = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token2;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token2 = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token2.value);
          skipSpaces(scnr);
          return token2;
        }
        break;
      }
    }
    return token2;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token2 = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token2 = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token2;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token2 = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token2;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token2;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token2 = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token2 = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token2;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token2;
  }
  function nextToken() {
    const { currentType, offset: offset2, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset2;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "";
    }
  }
}
function createParser(options = {}) {
  const location2 = options.location !== false;
  const { onError, onWarn } = options;
  function emitError(tokenzer, code2, start, offset2, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset2;
    end.column += offset2;
    if (onError) {
      const loc = location2 ? createLocation(start, end) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  function emitWarn(tokenzer, code2, start, offset2, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset2;
    end.column += offset2;
    if (onWarn) {
      const loc = location2 ? createLocation(start, end) : null;
      onWarn(createCompileWarn(code2, loc, args));
    }
  }
  function startNode(type, offset2, loc) {
    const node = { type };
    if (location2) {
      node.start = offset2;
      node.end = offset2;
      node.loc = { start: loc, end: loc };
    }
    return node;
  }
  function endNode(node, offset2, pos, type) {
    if (location2) {
      node.end = offset2;
      if (node.loc) {
        node.loc.end = pos;
      }
    }
  }
  function parseText(tokenizer, value2) {
    const context = tokenizer.context();
    const node = startNode(3, context.offset, context.startLoc);
    node.value = value2;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseList(tokenizer, index) {
    const context = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context;
    const node = startNode(5, offset2, loc);
    node.index = parseInt(index, 10);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseNamed(tokenizer, key, modulo) {
    const context = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context;
    const node = startNode(4, offset2, loc);
    node.key = key;
    if (modulo === true) {
      node.modulo = true;
    }
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLiteral(tokenizer, value2) {
    const context = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context;
    const node = startNode(9, offset2, loc);
    node.value = value2.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinkedModifier(tokenizer) {
    const token2 = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context;
    const node = startNode(8, offset2, loc);
    if (token2.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = "";
      endNode(node, offset2, loc);
      return {
        nextConsumeToken: token2,
        node
      };
    }
    if (token2.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
    }
    node.value = token2.value || "";
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node
    };
  }
  function parseLinkedKey(tokenizer, value2) {
    const context = tokenizer.context();
    const node = startNode(7, context.offset, context.startLoc);
    node.value = value2;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token2 = tokenizer.nextToken();
    if (token2.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token2 = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token2.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
    }
    token2 = tokenizer.nextToken();
    if (token2.type === 2) {
      token2 = tokenizer.nextToken();
    }
    switch (token2.type) {
      case 11:
        if (token2.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token2.value || "");
        break;
      case 5:
        if (token2.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseNamed(tokenizer, token2.value || "");
        break;
      case 6:
        if (token2.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseList(tokenizer, token2.value || "");
        break;
      case 7:
        if (token2.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseLiteral(tokenizer, token2.value || "");
        break;
      default: {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token2,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node = startNode(2, startOffset, startLoc);
    node.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token2 = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token2.type) {
        case 0:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node.items.push(parseText(tokenizer, token2.value || ""));
          break;
        case 6:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node.items.push(parseList(tokenizer, token2.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node.items.push(parseNamed(tokenizer, token2.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token2));
            modulo = null;
          }
          break;
        case 7:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node.items.push(parseLiteral(tokenizer, token2.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }
  function parsePlural(tokenizer, offset2, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1, offset2, loc);
    node.cases = [];
    node.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset: offset2, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset2, startLoc, msgNode);
    }
  }
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign({}, options));
    const context = tokenizer.context();
    const node = startNode(0, context.offset, context.startLoc);
    if (location2 && node.loc) {
      node.loc.source = source;
    }
    node.body = parseResource(tokenizer);
    if (options.onCacheKey) {
      node.cacheKey = options.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  return { parse: parse2 };
}
function getTokenCaption(token2) {
  if (token2.type === 14) {
    return "EOF";
  }
  const name2 = (token2.value || "").replace(/\r?\n/gu, "\\n");
  return name2.length > 10 ? name2.slice(0, 9) + "" : name2;
}
function createTransformer(ast, options = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = () => _context;
  const helper = (name2) => {
    _context.helpers.add(name2);
    return name2;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer);
  }
}
function traverseNode(node, transformer) {
  switch (node.type) {
    case 1:
      traverseNodes(node.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node.items, transformer);
      break;
    case 6: {
      const linked = node;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform(ast, options = {}) {
  const transformer = createTransformer(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c) => optimizeMessageNode(c));
  }
  return ast;
}
function optimizeMessageNode(message2) {
  if (message2.items.length === 1) {
    const item = message2.items[0];
    if (item.type === 3 || item.type === 9) {
      message2.static = item.value;
      delete item.value;
    }
  } else {
    const values = [];
    for (let i = 0; i < message2.items.length; i++) {
      const item = message2.items[i];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values.push(item.value);
    }
    if (values.length === message2.items.length) {
      message2.static = join(values);
      for (let i = 0; i < message2.items.length; i++) {
        const item = message2.items[i];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
const ERROR_DOMAIN$1 = "minifier";
function minify(node) {
  node.t = node.type;
  switch (node.type) {
    case 0: {
      const resource = node;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node;
      const cases = plural.cases;
      for (let i = 0; i < cases.length; i++) {
        minify(cases[i]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message2 = node;
      const items = message2.items;
      for (let i = 0; i < items.length; i++) {
        minify(items[i]);
      }
      message2.i = items;
      delete message2.items;
      if (message2.static) {
        message2.s = message2.static;
        delete message2.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node;
      named.k = named.key;
      delete named.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node.type]
      });
    }
  }
  delete node.type;
}
const ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
  const location2 = options.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location2 && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = () => _context;
  function push(code2, node) {
    _context.code += code2;
  }
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node.key);
  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node.items.length;
  for (let i = 0; i < length; i++) {
    generateNode(generator, node.items[i]);
    if (i === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node) {
  const { helper, needIndent } = generator;
  if (node.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node.cases.length;
    for (let i = 0; i < length; i++) {
      generateNode(generator, node.cases[i]);
      if (i === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node) {
  const { helper } = generator;
  switch (node.type) {
    case 0:
      generateResource(generator, node);
      break;
    case 1:
      generatePluralNode(generator, node);
      break;
    case 2:
      generateMessageNode(generator, node);
      break;
    case 6:
      generateLinkedNode(generator, node);
      break;
    case 8:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 7:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node.index}))`, node);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;
    case 9:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 3:
      generator.push(JSON.stringify(node.value), node);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node.type]
      });
    }
  }
}
const generate = (ast, options = {}) => {
  const mode = isString(options.mode) ? options.mode : "normal";
  const filename = isString(options.filename) ? options.filename : "message.intl";
  const sourceMap = !!options.sourceMap;
  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code: code2, map } = generator.context();
  return {
    ast,
    code: code2,
    map: map ? map.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile$1(source, options = {}) {
  const assignedOptions = assign({}, options);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser = createParser(assignedOptions);
  const ast = parser.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
/*!
  * core-base v9.14.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
  const keys = [];
  let index = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index++;
    c = path[index];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$3(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$3(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const val = last[hit[i]];
    if (val === void 0) {
      return null;
    }
    if (isFunction(last)) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$1(values);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index = isNumber$1(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber$1(options.named.count) || isNumber$1(options.named.n)) ? isNumber$1(options.named.count) ? options.named.count : isNumber$1(options.named.n) ? options.named.n : index : index;
}
function normalizeNamed(pluralIndex, props4) {
  if (!props4.count) {
    props4.count = pluralIndex;
  }
  if (!props4.n) {
    props4.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$3(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$3(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages2) => {
    return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index) => _list[index];
  const _named = options.named || {};
  isNumber$1(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message2(key) {
    const msg = isFunction(options.messages) ? options.messages(key) : isObject$3(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name2) => options.modifiers ? options.modifiers[name2] : DEFAULT_MODIFIER;
  const normalize = isPlainObject$1(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject$1(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject$1(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$3(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$1(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message2(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message2,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$1({}, _list, _named)
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n2, version2, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: i18n2,
    version: version2,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  NOT_FOUND_KEY: code$1$1,
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const code$3 = CompileErrorCodes.__EXTEND_POINT__;
const inc$3 = incrementer(code$3);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$3,
  // 17
  INVALID_DATE_ARGUMENT: inc$3(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$3(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$3(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$3(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$3(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$3(),
  // 23
  __EXTEND_POINT__: inc$3()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
function getLocale$1(context, options) {
  return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
let _resolveLocale;
function resolveLocale(locale) {
  if (isString$1(locale)) {
    return locale;
  } else {
    if (isFunction(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve = locale();
        if (isPromise(resolve)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray(fallback) ? fallback : isObject$3(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString$1(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults2 = isArray(fallback) || !isPlainObject$1(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString$1(defaults2) ? [defaults2] : defaults2;
    if (isArray(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale = block[i];
    if (isString$1(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target2 = tokens.join("-");
    follow = appendItemToChain(chain, target2, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target2, blocks) {
  let follow = false;
  if (!chain.includes(target2)) {
    follow = true;
    if (target2) {
      follow = target2[target2.length - 1] !== "!";
      const locale = target2.replace(/!/g, "");
      chain.push(locale);
      if ((isArray(blocks) || isPlainObject$1(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const VERSION$1 = "9.14.1";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString$1(val) ? val.toUpperCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString$1(val) ? val.toLowerCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString$1(val) ? capitalize(val) : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
  const version2 = isString$1(options.version) ? options.version : VERSION$1;
  const locale = isString$1(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
  const messages2 = isPlainObject$1(options.messages) ? options.messages : { [_locale]: {} };
  const datetimeFormats = isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale]: {} };
  const numberFormats = isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale]: {} };
  const modifiers = assign$1({}, options.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || {};
  const missing = isFunction(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject$1(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$3(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject$3(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$3(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$3(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale,
    fallbackLocale,
    messages: messages2,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString$1(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
function isAlmostSameLocale(locale, compareLocale) {
  if (locale === compareLocale)
    return false;
  return locale.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index = locales.indexOf(targetLocale);
  if (index === -1) {
    return false;
  }
  for (let i = index + 1; i < locales.length; i++) {
    if (isAlmostSameLocale(targetLocale, locales[i])) {
      return true;
    }
  }
  return false;
}
function format(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = ast.b || ast.body;
  if ((body.t || body.type) === 1) {
    const plural = body;
    const cases = plural.c || plural.cases;
    return ctx.plural(cases.reduce((messages2, c) => [
      ...messages2,
      formatMessageParts(ctx, c)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node) {
  const _static = node.s || node.static;
  if (_static) {
    return ctx.type === "text" ? _static : ctx.normalize([_static]);
  } else {
    const messages2 = (node.i || node.items).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
    return ctx.normalize(messages2);
  }
}
function formatMessagePart(ctx, node) {
  const type = node.t || node.type;
  switch (type) {
    case 3: {
      const text = node;
      return text.v || text.value;
    }
    case 9: {
      const literal = node;
      return literal.v || literal.value;
    }
    case 4: {
      const named = node;
      return ctx.interpolate(ctx.named(named.k || named.key));
    }
    case 5: {
      const list = node;
      return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
    }
    case 6: {
      const linked = node;
      const modifier = linked.m || linked.modifier;
      return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      const linkedKey = node;
      return linkedKey.v || linkedKey.value;
    }
    case 8: {
      const linkedModifier = node;
      return linkedModifier.v || linkedModifier.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${type}`);
  }
}
const defaultOnCacheKey = (message2) => message2;
let compileCache = /* @__PURE__ */ Object.create(null);
const isMessageAST = (val) => isObject$3(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
function baseCompile(message2, options = {}) {
  let detectError = false;
  const onError = options.onError || defaultOnError;
  options.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message2, options), detectError };
}
function compile(message2, context) {
  if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$1(message2)) {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message2);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message2, {
      ...context,
      location: false,
      jit: true
    });
    const msg = format(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    const cacheKey = message2.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format(message2);
    } else {
      return format(message2);
    }
  }
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction(val);
function translate$1(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString$1(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = getLocale$1(context, options);
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message2] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages2[locale] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message2, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$1({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray(options.list)) {
    options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
  } else if (isObject$3(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString$1(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message2 = {};
  let targetLocale;
  let format2 = null;
  const type = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    message2 = messages2[targetLocale] || {};
    if ((format2 = resolveValue2(message2, key)) === null) {
      format2 = message2[key];
    }
    if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
  }
  return [format2, targetLocale, message2];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format2;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = {};
  if (!isString$1(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber$1(arg2)) {
    options.plural = arg2;
  } else if (isString$1(arg2)) {
    options.default = arg2;
  } else if (isPlainObject$1(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray(arg2)) {
    options.list = arg2;
  }
  if (isNumber$1(arg3)) {
    options.plural = arg3;
  } else if (isString$1(arg3)) {
    options.default = arg3;
  } else if (isPlainObject$1(arg3)) {
    assign$1(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getMessageContextOptions(context, locale, message2, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message2, key);
    if (val == null && fallbackContext) {
      const [, , message22] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message22, key);
    }
    if (isString$1(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber$1(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key, value2, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale$1(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value2);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject$1(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject$1(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id3 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id3 = `${id3}__${JSON.stringify(overrides)}`;
  }
  let formatter2 = __datetimeFormatters.get(id3);
  if (!formatter2) {
    formatter2 = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
    __datetimeFormatters.set(id3, formatter2);
  }
  return !part ? formatter2.format(value2) : formatter2.formatToParts(value2);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  let value2;
  if (isString$1(arg1)) {
    const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
    value2 = new Date(dateTime);
    try {
      value2.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate$1(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value2 = arg1;
  } else if (isNumber$1(arg1)) {
    value2 = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject$1(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject$1(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject$1(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value2, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id3 = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id3)) {
      continue;
    }
    context.__datetimeFormatters.delete(id3);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key, value2, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale$1(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value2);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject$1(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject$1(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id3 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id3 = `${id3}__${JSON.stringify(overrides)}`;
  }
  let formatter2 = __numberFormatters.get(id3);
  if (!formatter2) {
    formatter2 = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
    __numberFormatters.set(id3, formatter2);
  }
  return !part ? formatter2.format(value2) : formatter2.formatToParts(value2);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  if (!isNumber$1(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value2 = arg1;
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject$1(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject$1(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject$1(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value2, options, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id3 = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id3)) {
      continue;
    }
    context.__numberFormatters.delete(id3);
  }
}
{
  initFeatureFlags$1();
}
/*!
  * vue-i18n v9.14.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.14.1";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
({
  FALLBACK_TO_ROOT: code$1,
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
});
const code$2 = CoreErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code$2,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc$2(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc$2(),
  // 26
  NOT_INSTALLED: inc$2(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc$2(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc$2(),
  // 29
  INVALID_VALUE: inc$2(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc$2(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc$2(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc$2(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc$2(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc$2(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc$2(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc$2(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc$2()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject$3(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn$1(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$3(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = {};
        }
        if (!isObject$3(currentObj[subKeys[i]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject$3(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages: messages2, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject$1(messages2) ? messages2 : isArray(__i18n) ? {} : { [locale]: {} };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || {};
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$1(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn$1(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages2 = isObject$3(options.messages) ? options.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages2 = getLocaleMessages(gl.locale.value, {
      messages: messages2,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages2);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages2[locale]);
    });
  }
  {
    if (isObject$3(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$3(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || void 0, type);
  };
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  const flatJson = options.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options.translateExistCompatible;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = _ref(isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject$1(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject$1(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject$1(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages2 = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber$1(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate$1, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString$1(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$3(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t(...[arg1, arg2, assign$1({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function normalize(values) {
    return values.map((val) => isString$1(val) || isNumber$1(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate$1, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$1(locale2) ? locale2 : _locale.value;
      const message2 = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message2, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$1(resolved) : resolved != null;
    }, () => [key], "translate exists", (root) => {
      return Reflect.apply(root.te, root, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages22 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages22 = messageValue;
        break;
      }
    }
    return messages22;
  }
  function tm(key) {
    const messages22 = resolveMessages(key);
    return messages22 != null ? messages22 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message2) {
    if (flatJson) {
      const _message = { [locale2]: message2 };
      for (const key in _message) {
        if (hasOwn$1(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message2 = _message[locale2];
    }
    _messages.value[locale2] = message2;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message2) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message2 };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn$1(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message2 = _message[locale2];
    deepCopy(message2, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign$1(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign$1(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages: messages2,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
function convertComposerOptions(options) {
  const locale = isString$1(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction(options.missing) ? options.missing : void 0;
  const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject$1(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
  const warnHtmlMessage = isString$1(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean(options.sync) ? options.sync : true;
  let messages2 = options.messages;
  if (isPlainObject$1(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages2 = locales.reduce((messages22, locale2) => {
      const message2 = messages22[locale2] || (messages22[locale2] = {});
      assign$1(message2, sharedMessages[locale2]);
      return messages22;
    }, messages2 || {});
  }
  const { __i18n, __root, __injectWithOption } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  const translateExistCompatible = options.translateExistCompatible;
  return {
    locale,
    fallbackLocale,
    messages: messages2,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options));
    const { __extender } = options;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject$1(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject$1(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isNumber$1(arg2)) {
          options2.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject$1(arg2)) {
          named = arg2;
        }
        if (isString$1(arg3)) {
          options2.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject$1(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message2) {
        composer.setLocaleMessage(locale, message2);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message2) {
        composer.mergeLocaleMessage(locale, message2);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format2) {
        composer.setDateTimeFormat(locale, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format2) {
        composer.mergeDateTimeFormat(locale, format2);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format2) {
        composer.setNumberFormat(locale, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format2) {
        composer.mergeNumberFormat(locale, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    return vueI18n;
  }
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$1({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber$1(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props4, context) {
    const { slots, attrs } = context;
    const i18n2 = props4.i18n || useI18n({
      useScope: props4.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options = {};
      if (props4.locale) {
        options.locale = props4.locale;
      }
      if (props4.plural !== void 0) {
        options.plural = isString$1(props4.plural) ? +props4.plural : props4.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n2[TranslateVNodeSymbol](props4.keypath, arg, options);
      const assignedAttrs = assign$1({}, attrs);
      const tag = isString$1(props4.tag) || isObject$3(props4.tag) ? props4.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
function isVNode(target2) {
  return isArray(target2) && !isString$1(target2[0]);
}
function renderFormatter(props4, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = {};
    if (props4.locale) {
      options.locale = props4.locale;
    }
    if (isString$1(props4.format)) {
      options.key = props4.format;
    } else if (isObject$3(props4.format)) {
      if (isString$1(props4.format.key)) {
        options.key = props4.format.key;
      }
      overrides = Object.keys(props4.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign$1({}, options2, { [prop]: props4.format[prop] }) : options2;
      }, {});
    }
    const parts = partFormatter(...[props4.value, options, overrides]);
    let children = [options.key];
    if (isArray(parts)) {
      children = parts.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }
        return node;
      });
    } else if (isString$1(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign$1({}, attrs);
    const tag = isString$1(props4.tag) || isObject$3(props4.tag) ? props4.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$1({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props4, context) {
    const i18n2 = props4.i18n || useI18n({
      useScope: props4.scope,
      __useComponent: true
    });
    return renderFormatter(props4, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$1({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props4, context) {
    const i18n2 = props4.i18n || useI18n({
      useScope: props4.scope,
      __useComponent: true
    });
    return renderFormatter(props4, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n2, instance) {
  const i18nInternal = i18n2;
  if (i18n2.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n2.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
  }
}
function vTDirective(i18n2) {
  const _process = (binding) => {
    const { instance, modifiers, value: value2 } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n2, instance.$);
    const parsedValue = parseValue$1(value2);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n2.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update6 = (el, { value: value2 }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue$1(value2);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update6,
    getSSRProps
  };
}
function parseValue$1(value2) {
  if (isString$1(value2)) {
    return { path: value2 };
  } else if (isPlainObject$1(value2)) {
    if (!("path" in value2)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value2;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value2) {
  const { path, locale, args, choice, plural } = value2;
  const options = {};
  const named = args || {};
  if (isString$1(locale)) {
    options.locale = locale;
  }
  if (isNumber$1(choice)) {
    options.plural = choice;
  }
  if (isNumber$1(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply$1(app2, i18n2, ...options) {
  const pluginOptions = isPlainObject$1(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name2) => app2.component(name2, Translation));
    [NumberFormat.name, "I18nN"].forEach((name2) => app2.component(name2, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name2) => app2.component(name2, DatetimeFormat));
  }
  {
    app2.directive("t", vTDirective(i18n2));
  }
}
function defineMixin(vuei18n, composer, i18n2) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options = this.$options;
      if (options.i18n) {
        const optionsI18n = options.i18n;
        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n2.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __extender: i18n2.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale) => this.$i18n.te(key, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n2.__setInstance(instance, this.$i18n);
    },
    mounted() {
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n2.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
function mergeToGlobal(g, options) {
  g.locale = options.locale || g.locale;
  g.fallbackLocale = options.fallbackLocale || g.fallbackLocale;
  g.missing = options.missing || g.missing;
  g.silentTranslationWarn = options.silentTranslationWarn || g.silentFallbackWarn;
  g.silentFallbackWarn = options.silentFallbackWarn || g.silentFallbackWarn;
  g.formatFallbackMessages = options.formatFallbackMessages || g.formatFallbackMessages;
  g.postTranslation = options.postTranslation || g.postTranslation;
  g.warnHtmlInMessage = options.warnHtmlInMessage || g.warnHtmlInMessage;
  g.escapeParameterHtml = options.escapeParameterHtml || g.escapeParameterHtml;
  g.sync = options.sync || g.sync;
  g.__composer[SetPluralRulesSymbol](options.pluralizationRules || g.pluralizationRules);
  const messages2 = getLocaleMessages(g.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages2).forEach((locale) => g.mergeLocaleMessage(locale, messages2[locale]));
  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach((locale) => g.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }
  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach((locale) => g.mergeNumberFormat(locale, options.numberFormats[locale]));
  }
  return g;
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n2 = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app2, ...options2) {
        app2.__VUE_I18N_SYMBOL__ = symbol;
        app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
        if (isPlainObject$1(options2[0])) {
          const opts = options2[0];
          i18n2.__composerExtend = opts.__composerExtend;
          i18n2.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply$1(app2, i18n2, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app2.mixin(defineMixin(__global, __global.__composer, i18n2));
        }
        const unmountApp = app2.unmount;
        app2.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n2.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n2 = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n2);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n2.mode === "legacy" && !options.__useComponent) {
      if (!i18n2.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n2, instance, options.__useComponent);
    if (composer2 == null) {
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n2;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign$1({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n2) {
  return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
function getComposer(i18n2, target2, useComponent = false) {
  let composer = null;
  const root = target2.root;
  let current = getParentComponentInstance(target2, useComponent);
  while (current != null) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target2, useComponent = false) {
  if (target2 == null) {
    return null;
  }
  {
    return !useComponent ? target2.parent : target2.vnode.ctx || target2.parent;
  }
}
function setupLifeCycle(i18n2, target2, composer) {
  {
    onMounted(() => {
    }, target2);
    onUnmounted(() => {
      const _composer = composer;
      i18n2.__deleteInstance(target2);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target2);
  }
}
function useI18nForLegacy(instance, scope, root, options = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString$1(options.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const _fallbackFormat = !!options.fallbackFormat;
  const _missing = isFunction(options.missing) ? options.missing : null;
  const _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const _escapeParameter = !!options.escapeParameter;
  const _modifiers = isLocalScope ? root.modifiers : isPlainObject$1(options.modifiers) ? options.modifiers : {};
  const _pluralRules = options.pluralRules || isLocalScope && root.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages2 = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }
  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }
  function t(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te(key, locale2) {
    return _composer.value ? _composer.value.te(key, locale2) : false;
  }
  function getLocaleMessage(locale2) {
    return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
  }
  function setLocaleMessage(locale2, message2) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale2, message2);
      _messages.value[locale2] = message2;
    }
  }
  function mergeLocaleMessage(locale2, message2) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale2, message2);
    }
  }
  function getDateTimeFormat(locale2) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
  }
  function setDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale2, format2);
      _datetimeFormats.value[locale2] = format2;
    }
  }
  function mergeDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale2, format2);
    }
  }
  function getNumberFormat(locale2) {
    return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
  }
  function setNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale2, format2);
      _numberFormats.value[locale2] = format2;
    }
  }
  function mergeNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale2, format2);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale,
    fallbackLocale,
    messages: messages2,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale2) => {
      composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale2) => {
      composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
    });
    Object.keys(_numberFormats.value).forEach((locale2) => {
      composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
  const i18n2 = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n2, prop, wrap);
  });
  app2.config.globalProperties.$i18n = i18n2;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app2.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app2.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
{
  registerMessageCompiler(compile);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target2 = getGlobalThis();
  target2.__INTLIFY__ = true;
  setDevToolsHook(target2.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
var AppType = /* @__PURE__ */ ((AppType2) => {
  AppType2["unknown"] = "0";
  AppType2["spa"] = "1";
  AppType2["pwa"] = "2";
  AppType2["bex"] = "3";
  AppType2["capacitor"] = "4";
  AppType2["electron"] = "5";
  return AppType2;
})(AppType || {});
var AppMode = /* @__PURE__ */ ((AppMode2) => {
  AppMode2["normal"] = "normal";
  AppMode2["bg"] = "bg";
  AppMode2["offscreen"] = "offscreen";
  AppMode2["enable"] = "enable";
  AppMode2["signTx"] = "signTx";
  AppMode2["signData"] = "signData";
  return AppMode2;
})(AppMode || {});
var Platform$1 = /* @__PURE__ */ ((Platform2) => {
  Platform2["unknown"] = "0";
  Platform2["web"] = "1";
  Platform2["ios"] = "2";
  Platform2["android"] = "3";
  Platform2["windows"] = "4";
  Platform2["mac"] = "5";
  Platform2["linux"] = "6";
  return Platform2;
})(Platform$1 || {});
var Environment = /* @__PURE__ */ ((Environment2) => {
  Environment2["unknown"] = "unknown";
  Environment2["production"] = "production";
  Environment2["development"] = "development";
  return Environment2;
})(Environment || {});
const checkAppType = (type) => {
  let res = AppType.unknown;
  switch (type) {
    case "spa":
      res = AppType.spa;
      break;
    case "pwa":
      res = AppType.pwa;
      break;
    case "bex":
      res = AppType.bex;
      break;
    case "capacitor":
      res = AppType.capacitor;
      break;
    case "electron":
      res = AppType.electron;
      break;
  }
  return res;
};
const checkPlatform = (platform) => {
  let res = Platform$1.unknown;
  switch (platform) {
    case "web":
      res = Platform$1.web;
      break;
    case "ios":
      res = Platform$1.ios;
      break;
    case "android":
      res = Platform$1.android;
      break;
    case "windows":
      res = Platform$1.windows;
      break;
    case "mac":
      res = Platform$1.mac;
      break;
    case "linux":
      res = Platform$1.linux;
      break;
  }
  return res;
};
const checkEnvironment = (environment) => {
  switch (environment) {
    case Environment.unknown:
    case Environment.production:
    case Environment.development:
      return environment;
  }
  return Environment.unknown;
};
const checkAppMode = (mode) => {
  switch (mode) {
    case AppMode.normal:
    case AppMode.bg:
    case AppMode.enable:
    case AppMode.signTx:
    case AppMode.signData:
      return mode;
  }
  return AppMode.normal;
};
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset2 + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset2 + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value2, offset2, isLE, mLen, nBytes) {
  var e, m2, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value2 += rt / c;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value2 * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf2 = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value2, encodingOrOffset, length) {
    if (typeof value2 === "string") {
      return fromString(value2, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value2)) {
      return fromArrayView(value2);
    }
    if (value2 == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    if (isInstance(value2, GlobalArrayBuffer) || value2 && isInstance(value2.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value2, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value2, GlobalSharedArrayBuffer) || value2 && isInstance(value2.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value2, encodingOrOffset, length);
    }
    if (typeof value2 === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value2.valueOf && value2.valueOf();
    if (valueOf != null && valueOf !== value2) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value2);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
    );
  }
  Buffer2.from = function(value2, encodingOrOffset, length) {
    return from(value2, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer2, GlobalUint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf2 = createBuffer(length);
    const actual = buf2.write(string, encoding);
    if (actual !== length) {
      buf2 = buf2.slice(0, actual);
    }
    return buf2;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf2 = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf2[i] = array[i] & 255;
    }
    return buf2;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf2;
    if (byteOffset === void 0 && length === void 0) {
      buf2 = new GlobalUint8Array(array);
    } else if (length === void 0) {
      buf2 = new GlobalUint8Array(array, byteOffset);
    } else {
      buf2 = new GlobalUint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf2 = createBuffer(len);
      if (buf2.length === 0) {
        return buf2;
      }
      obj.copy(buf2, 0, 0, len);
      return buf2;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, GlobalUint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, GlobalUint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf2 = list[i];
      if (isInstance(buf2, GlobalUint8Array)) {
        if (pos + buf2.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf2)) buf2 = Buffer2.from(buf2);
          buf2.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf2,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf2.copy(buffer2, pos);
      }
      pos += buf2.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap2(b, n, m2) {
    const i = b[n];
    b[n] = b[m2];
    b[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap2(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap2(this, i, i + 3);
      swap2(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap2(this, i, i + 7);
      swap2(this, i + 1, i + 6);
      swap2(this, i + 2, i + 5);
      swap2(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target2, start, end, thisStart, thisEnd) {
    if (isInstance(target2, GlobalUint8Array)) {
      target2 = Buffer2.from(target2, target2.offset, target2.byteLength);
    }
    if (!Buffer2.isBuffer(target2)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target2
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target2 ? target2.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target2.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target2) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target2.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf2, i2) {
      if (indexSize === 1) {
        return buf2[i2];
      } else {
        return buf2.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read2(arr, i + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf2, string, offset2, length) {
    offset2 = Number(offset2) || 0;
    const remaining = buf2.length - offset2;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf2[offset2 + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf2, string, offset2, length) {
    return blitBuffer(utf8ToBytes(string, buf2.length - offset2), buf2, offset2, length);
  }
  function asciiWrite(buf2, string, offset2, length) {
    return blitBuffer(asciiToBytes(string), buf2, offset2, length);
  }
  function base64Write(buf2, string, offset2, length) {
    return blitBuffer(base64ToBytes(string), buf2, offset2, length);
  }
  function ucs2Write(buf2, string, offset2, length) {
    return blitBuffer(utf16leToBytes(string, buf2.length - offset2), buf2, offset2, length);
  }
  Buffer2.prototype.write = function write(string, offset2, length, encoding) {
    if (offset2 === void 0) {
      encoding = "utf8";
      length = this.length;
      offset2 = 0;
    } else if (length === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      length = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset2;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset2, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset2, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset2, length);
        case "base64":
          return base64Write(this, string, offset2, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset2, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf2, start, end) {
    if (start === 0 && end === buf2.length) {
      return base64.fromByteArray(buf2);
    } else {
      return base64.fromByteArray(buf2.slice(start, end));
    }
  }
  function utf8Slice(buf2, start, end) {
    end = Math.min(buf2.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf2[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[i + 1];
            thirdByte = buf2[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[i + 1];
            thirdByte = buf2[i + 2];
            fourthByte = buf2[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf2, start, end) {
    let ret = "";
    end = Math.min(buf2.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf2[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf2, start, end) {
    let ret = "";
    end = Math.min(buf2.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf2[i]);
    }
    return ret;
  }
  function hexSlice(buf2, start, end) {
    const len = buf2.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf2[i]];
    }
    return out;
  }
  function utf16leSlice(buf2, start, end) {
    const bytes = buf2.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length) {
    if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
    if (offset2 + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    let val = this[offset2 + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset2 + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
    const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset2 + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset2 + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128)) return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    const val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    const val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf2, value2, offset2, ext, max, min) {
    if (!Buffer2.isBuffer(buf2)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value2 > max || value2 < min) throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf2.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset2, byteLength3, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset2, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset2] = value2 & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset2 + i] = value2 / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset2, byteLength3, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset2, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset2 + i] = value2 & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset2 + i] = value2 / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 1, 255, 0);
    this[offset2] = value2 & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
    return offset2 + 4;
  };
  function wrtBigUInt64LE(buf2, value2, offset2, min, max) {
    checkIntBI(value2, min, max, buf2, offset2, 7);
    let lo = Number(value2 & BigInt(4294967295));
    buf2[offset2++] = lo;
    lo = lo >> 8;
    buf2[offset2++] = lo;
    lo = lo >> 8;
    buf2[offset2++] = lo;
    lo = lo >> 8;
    buf2[offset2++] = lo;
    let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
    buf2[offset2++] = hi;
    hi = hi >> 8;
    buf2[offset2++] = hi;
    hi = hi >> 8;
    buf2[offset2++] = hi;
    hi = hi >> 8;
    buf2[offset2++] = hi;
    return offset2;
  }
  function wrtBigUInt64BE(buf2, value2, offset2, min, max) {
    checkIntBI(value2, min, max, buf2, offset2, 7);
    let lo = Number(value2 & BigInt(4294967295));
    buf2[offset2 + 7] = lo;
    lo = lo >> 8;
    buf2[offset2 + 6] = lo;
    lo = lo >> 8;
    buf2[offset2 + 5] = lo;
    lo = lo >> 8;
    buf2[offset2 + 4] = lo;
    let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
    buf2[offset2 + 3] = hi;
    hi = hi >> 8;
    buf2[offset2 + 2] = hi;
    hi = hi >> 8;
    buf2[offset2 + 1] = hi;
    hi = hi >> 8;
    buf2[offset2] = hi;
    return offset2 + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset2 = 0) {
    return wrtBigUInt64LE(this, value2, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset2 = 0) {
    return wrtBigUInt64BE(this, value2, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset2, byteLength3, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset2, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset2] = value2 & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value2 / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset2, byteLength3, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset2, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset2 + i] = value2 & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value2 / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 1, 127, -128);
    if (value2 < 0) value2 = 255 + value2 + 1;
    this[offset2] = value2 & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
    return offset2 + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
    if (value2 < 0) value2 = 4294967295 + value2 + 1;
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset2 = 0) {
    return wrtBigUInt64LE(this, value2, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset2 = 0) {
    return wrtBigUInt64BE(this, value2, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf2, value2, offset2, ext, max, min) {
    if (offset2 + ext > buf2.length) throw new RangeError("Index out of range");
    if (offset2 < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf2, value2, offset2, littleEndian, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value2, offset2, 4);
    }
    ieee754$1.write(buf2, value2, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset2, noAssert) {
    return writeFloat(this, value2, offset2, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset2, noAssert) {
    return writeFloat(this, value2, offset2, false, noAssert);
  };
  function writeDouble(buf2, value2, offset2, littleEndian, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value2, offset2, 8);
    }
    ieee754$1.write(buf2, value2, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset2, noAssert) {
    return writeDouble(this, value2, offset2, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset2, noAssert) {
    return writeDouble(this, value2, offset2, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target2, targetStart, start, end) {
    if (!Buffer2.isBuffer(target2)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target2.length) targetStart = target2.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target2.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target2.length - targetStart < end - start) {
      end = target2.length - targetStart + start;
    }
    const len = end - start;
    if (this === target2 && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target2,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value2) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: value2,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf2, offset2, byteLength3) {
    validateNumber(offset2, "offset");
    if (buf2[offset2] === void 0 || buf2[offset2 + byteLength3] === void 0) {
      boundsError(offset2, buf2.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value2, min, max, buf2, offset2, byteLength3) {
    if (value2 > max || value2 < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value2);
    }
    checkBounds(buf2, offset2, byteLength3);
  }
  function validateNumber(value2, name2) {
    if (typeof value2 !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value2);
    }
  }
  function boundsError(value2, length, type) {
    if (Math.floor(value2) !== value2) {
      validateNumber(value2, type);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value2);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value2
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units2) {
    units2 = units2 || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units2 -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units2 -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units2 -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units2 -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units2) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units2 -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset2, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset2 >= dst.length || i >= src.length) break;
      dst[i + offset2] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const Buffer$1 = buffer.Buffer;
const byteaToHex = (bytea) => bytea.startsWith("\\x") ? bytea.substring(2) : bytea;
const toHexBuffer = (hex2) => Buffer$1.from(byteaToHex(hex2), "hex");
const error$1 = (msg, ...args) => {
  console.error(msg, ...args);
};
const isBetaApp = () => _appInfo.isBeta;
const setAppMode = (mode) => {
  _appInfo.appMode = mode;
  if (typeof window !== "undefined") {
    window.appMode = mode;
  }
};
var INetworkFeature = /* @__PURE__ */ ((INetworkFeature2) => {
  INetworkFeature2[INetworkFeature2["NONE"] = 0] = "NONE";
  INetworkFeature2[INetworkFeature2["STAKING"] = 1] = "STAKING";
  INetworkFeature2[INetworkFeature2["SWAP"] = 2] = "SWAP";
  INetworkFeature2[INetworkFeature2["CATALYST"] = 4] = "CATALYST";
  INetworkFeature2[INetworkFeature2["GOVERNANCE"] = 8] = "GOVERNANCE";
  INetworkFeature2[INetworkFeature2["DAPP_BROWSER"] = 16] = "DAPP_BROWSER";
  INetworkFeature2[INetworkFeature2["REPORTING"] = 32] = "REPORTING";
  INetworkFeature2[INetworkFeature2["CREATE_SWAP"] = 64] = "CREATE_SWAP";
  INetworkFeature2[INetworkFeature2["ALL"] = 127] = "ALL";
  return INetworkFeature2;
})(INetworkFeature || {});
const networkIdList = ["mainnet", "preprod", "preview", "guild", "sancho", "afvt", "afpt", "afvm", "afpm"];
const networkFeaturesMap = networkIdList.reduce((o, n) => {
  o[n] = INetworkFeature.NONE;
  return o;
}, {});
networkFeaturesMap["mainnet"] = INetworkFeature.ALL;
networkFeaturesMap["guild"] = INetworkFeature.STAKING;
networkFeaturesMap["sancho"] = INetworkFeature.STAKING | INetworkFeature.DAPP_BROWSER | INetworkFeature.GOVERNANCE;
networkFeaturesMap["preprod"] = INetworkFeature.STAKING | INetworkFeature.DAPP_BROWSER | INetworkFeature.GOVERNANCE | INetworkFeature.SWAP | INetworkFeature.CREATE_SWAP | INetworkFeature.CATALYST;
networkFeaturesMap["preview"] = INetworkFeature.STAKING | INetworkFeature.DAPP_BROWSER | INetworkFeature.GOVERNANCE;
networkFeaturesMap["afpt"] = INetworkFeature.STAKING;
networkFeaturesMap["afpm"] = INetworkFeature.STAKING;
networkFeaturesMap["afvt"] = INetworkFeature.DAPP_BROWSER;
networkFeaturesMap["afvm"] = INetworkFeature.DAPP_BROWSER;
const getNetworkId$1 = (id3) => {
  switch (id3) {
    case "mainnet":
      return 1;
    case "guild":
      return 0;
    case "sancho":
      return 0;
    case "preprod":
      return 0;
    case "preview":
      return 0;
    case "afvt":
      return 2;
    case "afvm":
      return 3;
    case "afpt":
      return 0;
    case "afpm":
      return 1;
  }
  throw new Error("Error: INetwork.getNetworkId: unknown network: " + id3);
};
const isTestnetNetwork = (networkId2) => getNetworkId$1(networkId2) === 0 || getNetworkId$1(networkId2) === 2;
const isCustomNetwork = (networkId2) => !isTestnetNetwork(networkId2) && networkId2 !== "mainnet";
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
const toString$1 = Object.prototype.toString;
const isObject$1 = (val) => toString$1.call(val) === "[object Object]";
const noop$1 = () => {
};
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter = (invoke2) => {
  return invoke2();
};
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function getLifeCycleTarget(target2) {
  return getCurrentInstance();
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter,
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
  const stop2 = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop: stop2, pause, resume, isActive };
}
function tryOnMounted(fn, sync = true, target2) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target2);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
const defaultWindow = isClient ? window : void 0;
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function useEventListener(...args) {
  let target2;
  let events2;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events2, listeners, options] = args;
    target2 = defaultWindow;
  } else {
    [target2, events2, listeners, options] = args;
  }
  if (!target2)
    return noop$1;
  if (!Array.isArray(events2))
    events2 = [events2];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target2), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$1(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events2.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop2);
  return stop2;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global$1 !== "undefined" ? global$1 : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers$1 = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function getSSRHandler(key, fallback) {
  return handlers$1[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2))
  },
  date: {
    read: (v2) => new Date(v2),
    write: (v2) => v2.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage3, options = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    },
    initOnMounted
  } = options;
  const data = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
  if (!storage3) {
    try {
      storage3 = getSSRHandler("getDefaultStorage", () => {
        var _a2;
        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage3)
    return data;
  const rawInit = toValue(defaults2);
  const type = guessSerializerType(rawInit);
  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
    data,
    () => write(data.value),
    { flush, deep, eventFilter }
  );
  if (window2 && listenToStorageChanges) {
    tryOnMounted(() => {
      if (storage3 instanceof Storage)
        useEventListener(window2, "storage", update6);
      else
        useEventListener(window2, customStorageEventName, updateFromCustomEvent);
      if (initOnMounted)
        update6();
    });
  }
  if (!initOnMounted)
    update6();
  function dispatchWriteEvent(oldValue, newValue) {
    if (window2) {
      const payload = {
        key,
        oldValue,
        newValue,
        storageArea: storage3
      };
      window2.dispatchEvent(storage3 instanceof Storage ? new StorageEvent("storage", payload) : new CustomEvent(customStorageEventName, {
        detail: payload
      }));
    }
  }
  function write(v2) {
    try {
      const oldValue = storage3.getItem(key);
      if (v2 == null) {
        dispatchWriteEvent(oldValue, null);
        storage3.removeItem(key);
      } else {
        const serialized = serializer.write(v2);
        if (oldValue !== serialized) {
          storage3.setItem(key, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  function read2(event) {
    const rawValue = event ? event.newValue : storage3.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null)
        storage3.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value2 = serializer.read(rawValue);
      if (typeof mergeDefaults === "function")
        return mergeDefaults(value2, rawInit);
      else if (type === "object" && !Array.isArray(value2))
        return { ...rawInit, ...value2 };
      return value2;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  function update6(event) {
    if (event && event.storageArea !== storage3)
      return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
        data.value = read2(event);
    } catch (e) {
      onError(e);
    } finally {
      if (event)
        nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
  function updateFromCustomEvent(event) {
    update6(event.detail);
  }
  return data;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
const refMap = {};
const getRef = (key, value2) => {
  let ref2 = refMap[key];
  if (!ref2) {
    ref2 = useLocalStorage(key, value2 ?? "", {
      deep: false,
      listenToStorageChanges: true,
      writeDefaults: true,
      mergeDefaults: false,
      shallow: false,
      onError: (error2) => {
        console.error("useLocalStorage: getRef:", error2);
      }
    });
    refMap[key] = ref2;
  }
  return ref2;
};
const getObjRef = (key, obj) => {
  let ref2 = refMap[key];
  if (!ref2) {
    let data = obj;
    try {
      data = JSON.parse(obj);
    } catch (err) {
      data = obj;
    }
    ref2 = useLocalStorage(key, data, {
      deep: true,
      listenToStorageChanges: true,
      writeDefaults: true,
      mergeDefaults: false,
      shallow: false,
      onError: (error2) => {
        console.error("useLocalStorage: getObjRef", error2, key, data);
        forceSetLS(key, data);
      }
    });
    refMap[key] = ref2;
  }
  return ref2;
};
const forceSetLS = (key, value2) => {
  if (typeof window !== "undefined") {
    try {
      window.localStorage.setItem(key, typeof value2 !== "string" ? JSON.stringify(value2) : value2);
    } catch (error2) {
      console.error("useLocalStorage: forceSetLS", error2, key, value2);
    }
  }
};
const getNetworkId = () => getRef("networkId", "mainnet");
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const signalKeyMap = {};
const dispatchSignalSync = (signal, ...args) => {
  performance.now();
  const signalKey = getSignalKeyMap(signal);
  const keyList = Object.keys(signalKey);
  let lastResult = null;
  for (const key of keyList) {
    performance.now();
    const cb = signalKey[key];
    if (!!cb) {
      lastResult = cb(...args);
    }
  }
  return lastResult;
};
const addSignalListener = (signal, key, cb, _doLog = true) => {
  const signalKey = getSignalKeyMap(signal);
  const isSet2 = !!signalKey[key];
  signalKey[key] = cb;
  if (!isSet2) {
    if (signal.startsWith("onInterval")) {
      dispatchSignalSync(signal + "_add", key);
    }
  }
};
const getSignalKeyMap = (signal) => {
  let signalKey = signalKeyMap[signal];
  if (!signalKey) {
    signalKey = {};
    signalKeyMap[signal] = signalKey;
  }
  return signalKey;
};
const onNetworkIdUpdated = "onNetworkIdUpdated";
const _networkId = getNetworkId();
watch(_networkId, (newValue, oldValue) => {
  if (oldValue !== newValue) {
    dispatchSignalSync(onNetworkIdUpdated);
  }
});
const networkId = computed(() => _networkId.value);
computed(() => isTestnetNetwork(networkId.value));
computed(() => isCustomNetwork(networkId.value));
let _apiURL = null;
const setApiURL = (url) => {
  try {
    const _url = new URL(url).toString();
    _apiURL = _url.substring(0, _url.length - 1);
  } catch (err) {
    error$1("setApiURL", err);
  }
};
const _appInfo = {
  appType: AppType.unknown,
  appMode: AppMode.normal,
  platform: Platform$1.unknown,
  environment: Environment.unknown,
  token: "",
  pen: "",
  dappOrigin: "",
  isWorker: false,
  isStaging: false,
  isBeta: false,
  addApex: false,
  isMobileApp: false,
  isIosApp: false,
  isAndroidApp: false,
  hasWebUSB: false,
  useCoolify: false,
  doRestrictFeatures: true
};
const initAppInfo = (params) => {
  var _a;
  _appInfo.appType = checkAppType(params.TYPE);
  _appInfo.appMode = checkAppMode(params.APP_MODE);
  _appInfo.platform = checkPlatform(params.PLATFORM);
  _appInfo.environment = checkEnvironment(params.ENVIRONMENT);
  _appInfo.token = params.TOKEN;
  _appInfo.pen = params.PEN;
  _appInfo.isStaging = params.IS_STAGING === "yes";
  _appInfo.isBeta = params.IS_BETA === "yes";
  _appInfo.addApex = params.ADD_APEX === "yes";
  _appInfo.useCoolify = params.USE_COOLIFY === "yes";
  _appInfo.isMobileApp = _appInfo.appType === AppType.capacitor;
  _appInfo.isIosApp = _appInfo.isMobileApp && _appInfo.platform === Platform$1.ios;
  _appInfo.isAndroidApp = _appInfo.isMobileApp && _appInfo.platform === Platform$1.android;
  _appInfo.hasWebUSB = "usb" in navigator;
  const apiURLStaging = params.HOST_API_STAGING;
  const hostName = ((_a = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _a.hostname) ?? "";
  let apiURL = params.HOST_API;
  if (_appInfo.environment === Environment.production && (_appInfo.appType === AppType.spa || _appInfo.appType === AppType.pwa) && !hostName.toLowerCase().includes("local") && !apiURL) {
    apiURL = "https://api." + hostName;
  } else if (_appInfo.isStaging && (apiURLStaging == null ? void 0 : apiURLStaging.length) > 0) {
    apiURL = apiURLStaging;
  }
  _appInfo.doRestrictFeatures = _appInfo.environment === Environment.production && (apiURL.includes("ccwallet.io") || apiURL.includes("ccvault.io") || apiURL.includes("localhost"));
  setApiURL(apiURL);
};
initAppInfo({
  HOST_API: "https://api.eternl.io",
  HOST_API_STAGING: "https://api.staging.eternl.io",
  USE_COOLIFY: "yes",
  TOKEN: "#!l4n56cGPHoHM3Z@xiT&CV8",
  ENVIRONMENT: "production",
  TYPE: "bex",
  APP_MODE: void 0,
  PEN: "k%%2Gb6^!m8iMIvwlnS2xpWC",
  PLATFORM: "web",
  IS_STAGING: "no",
  IS_BETA: "no",
  ADD_APEX: "yes"
});
const _imports_0$1 = "/images/eternl-guard-512.png";
const getDappWalletId = (networkId2) => getRef("dappWalledId_" + networkId2);
const getDappAccountId = (networkId2) => getRef("dappAccountId_" + networkId2);
const _walletId = ref(getDappWalletId(networkId.value).value);
const _accountId = ref(getDappAccountId(networkId.value).value);
computed(() => _walletId.value);
const dappAccountId = computed(() => _accountId.value);
let _watcherStopWalletId = null;
let _watcherStopAccountId = null;
const setupWatchers = (networkId2) => {
  if (_watcherStopWalletId) {
    _watcherStopWalletId();
    _watcherStopWalletId = null;
  }
  if (_watcherStopAccountId) {
    _watcherStopAccountId();
    _watcherStopAccountId = null;
  }
  const refWalletId = getDappWalletId(networkId2);
  const refAccountId = getDappAccountId(networkId2);
  _watcherStopWalletId = watch(refWalletId, (value2) => {
    if (value2 === _walletId.value) {
      return;
    }
    _walletId.value = value2;
  }, { immediate: true });
  _watcherStopAccountId = watch(refAccountId, (value2) => {
    if (value2 === _accountId.value) {
      return;
    }
    _accountId.value = value2;
  }, { immediate: true });
};
watch(networkId, setupWatchers, { immediate: true });
const init = () => {
  setupWatchers(networkId.value);
};
init();
var ApiChannel = /* @__PURE__ */ ((ApiChannel2) => {
  ApiChannel2["domToCS"] = "eternl-dom-to-cs";
  ApiChannel2["csToDom"] = "eternl-cs-to-dom";
  ApiChannel2["csToBg"] = "eternl-cs-to-bg";
  ApiChannel2["bgToCs"] = "eternl-bg-to-cs";
  ApiChannel2["bgToEnable"] = "eternl-bg-to-enable";
  ApiChannel2["enableToBg"] = "eternl-enable-to-bg";
  ApiChannel2["bgToSignTx"] = "eternl-bg-to-sign-tx";
  ApiChannel2["signTxToBg"] = "eternl-sign-tx-to-bg";
  ApiChannel2["bgToSignData"] = "eternl-bg-to-sign-data";
  ApiChannel2["signDataToBg"] = "eternl-sign-data-to-bg";
  ApiChannel2["bgToSync"] = "eternl-bg-to-sync";
  ApiChannel2["syncToBg"] = "eternl-sync-to-bg";
  return ApiChannel2;
})(ApiChannel || {});
const getConnectedOriginsMap = () => getObjRef("connectedOrigins", {});
const onDappAccountIdSet = "onDappAccountIdSet";
const storeId = "connectedOrigins";
const accountOriginMap = {};
const addConnectedOrigin = (origin, extensions) => {
  if (origin) {
    const originMapRef = getConnectedOriginsMap();
    const originMap = originMapRef.value;
    const grantExtensionList = extensions;
    const originExtensionList = originMap[origin] ?? [];
    for (const extension of grantExtensionList) {
      if (!originExtensionList.some((e) => e.cip === extension.cip)) {
        originExtensionList.push(extension);
      }
    }
    originMap[origin] = originExtensionList;
    originMapRef.value = originMap;
  }
};
const resetOriginEnabledAccountMap = (dappAccountId2) => {
  for (let origin in accountOriginMap) {
    console.warn(`resetOriginEnabledAccountMap: changed: origin=${accountOriginMap[origin]} new=${dappAccountId2}`);
    if (accountOriginMap[origin] !== dappAccountId2 || dappAccountId2 === "") {
      accountOriginMap[origin] = null;
    }
  }
};
addSignalListener(onDappAccountIdSet, storeId, (dappWalletId = "", dappAccountId2 = "", changed = false) => {
  if (changed) {
    resetOriginEnabledAccountMap(dappAccountId2);
  }
});
var ApiErrorCode = /* @__PURE__ */ ((ApiErrorCode2) => {
  ApiErrorCode2[ApiErrorCode2["InvalidRequest"] = -1] = "InvalidRequest";
  ApiErrorCode2[ApiErrorCode2["InternalError"] = -2] = "InternalError";
  ApiErrorCode2[ApiErrorCode2["Refused"] = -3] = "Refused";
  ApiErrorCode2[ApiErrorCode2["AccountChange"] = -4] = "AccountChange";
  return ApiErrorCode2;
})(ApiErrorCode || {});
const errorConnectionRefused = () => ({ success: false, error: { code: ApiErrorCode.Refused, info: "user canceled connection" } });
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var dexie_min = { exports: {} };
(function(module, exports2) {
  (function(e, t) {
    module.exports = t();
  })(commonjsGlobal, function() {
    var s = function(e2, t2) {
      return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
        e3.__proto__ = t3;
      } || function(e3, t3) {
        for (var n2 in t3) Object.prototype.hasOwnProperty.call(t3, n2) && (e3[n2] = t3[n2]);
      })(e2, t2);
    };
    var _ = function() {
      return (_ = Object.assign || function(e2) {
        for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++) for (var i2 in t2 = arguments[n2]) Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
        return e2;
      }).apply(this, arguments);
    };
    function i(e2, t2, n2) {
      for (var r2, i2 = 0, o2 = t2.length; i2 < o2; i2++) !r2 && i2 in t2 || ((r2 = r2 || Array.prototype.slice.call(t2, 0, i2))[i2] = t2[i2]);
      return e2.concat(r2 || Array.prototype.slice.call(t2));
    }
    var f = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : commonjsGlobal, x = Object.keys, k = Array.isArray;
    function a(t2, n2) {
      return "object" != typeof n2 || x(n2).forEach(function(e2) {
        t2[e2] = n2[e2];
      }), t2;
    }
    "undefined" == typeof Promise || f.Promise || (f.Promise = Promise);
    var c = Object.getPrototypeOf, n = {}.hasOwnProperty;
    function m2(e2, t2) {
      return n.call(e2, t2);
    }
    function r(t2, n2) {
      "function" == typeof n2 && (n2 = n2(c(t2))), ("undefined" == typeof Reflect ? x : Reflect.ownKeys)(n2).forEach(function(e2) {
        l(t2, e2, n2[e2]);
      });
    }
    var u = Object.defineProperty;
    function l(e2, t2, n2, r2) {
      u(e2, t2, a(n2 && m2(n2, "get") && "function" == typeof n2.get ? { get: n2.get, set: n2.set, configurable: true } : { value: n2, configurable: true, writable: true }, r2));
    }
    function o(t2) {
      return { from: function(e2) {
        return t2.prototype = Object.create(e2.prototype), l(t2.prototype, "constructor", t2), { extend: r.bind(null, t2.prototype) };
      } };
    }
    var h2 = Object.getOwnPropertyDescriptor;
    var d = [].slice;
    function b(e2, t2, n2) {
      return d.call(e2, t2, n2);
    }
    function p2(e2, t2) {
      return t2(e2);
    }
    function y(e2) {
      if (!e2) throw new Error("Assertion Failed");
    }
    function v2(e2) {
      f.setImmediate ? setImmediate(e2) : setTimeout(e2, 0);
    }
    function O(e2, t2) {
      if ("string" == typeof t2 && m2(e2, t2)) return e2[t2];
      if (!t2) return e2;
      if ("string" != typeof t2) {
        for (var n2 = [], r2 = 0, i2 = t2.length; r2 < i2; ++r2) {
          var o2 = O(e2, t2[r2]);
          n2.push(o2);
        }
        return n2;
      }
      var a2 = t2.indexOf(".");
      if (-1 !== a2) {
        var u2 = e2[t2.substr(0, a2)];
        return null == u2 ? void 0 : O(u2, t2.substr(a2 + 1));
      }
    }
    function P(e2, t2, n2) {
      if (e2 && void 0 !== t2 && !("isFrozen" in Object && Object.isFrozen(e2))) if ("string" != typeof t2 && "length" in t2) {
        y("string" != typeof n2 && "length" in n2);
        for (var r2 = 0, i2 = t2.length; r2 < i2; ++r2) P(e2, t2[r2], n2[r2]);
      } else {
        var o2, a2, u2 = t2.indexOf(".");
        -1 !== u2 ? (o2 = t2.substr(0, u2), "" === (a2 = t2.substr(u2 + 1)) ? void 0 === n2 ? k(e2) && !isNaN(parseInt(o2)) ? e2.splice(o2, 1) : delete e2[o2] : e2[o2] = n2 : P(u2 = !(u2 = e2[o2]) || !m2(e2, o2) ? e2[o2] = {} : u2, a2, n2)) : void 0 === n2 ? k(e2) && !isNaN(parseInt(t2)) ? e2.splice(t2, 1) : delete e2[t2] : e2[t2] = n2;
      }
    }
    function g(e2) {
      var t2, n2 = {};
      for (t2 in e2) m2(e2, t2) && (n2[t2] = e2[t2]);
      return n2;
    }
    var t = [].concat;
    function w(e2) {
      return t.apply([], e2);
    }
    var e = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(w([8, 16, 32, 64].map(function(t2) {
      return ["Int", "Uint", "Float"].map(function(e2) {
        return e2 + t2 + "Array";
      });
    }))).filter(function(e2) {
      return f[e2];
    }), K = new Set(e.map(function(e2) {
      return f[e2];
    }));
    var E = null;
    function S(e2) {
      E = /* @__PURE__ */ new WeakMap();
      e2 = function e3(t2) {
        if (!t2 || "object" != typeof t2) return t2;
        var n2 = E.get(t2);
        if (n2) return n2;
        if (k(t2)) {
          n2 = [], E.set(t2, n2);
          for (var r2 = 0, i2 = t2.length; r2 < i2; ++r2) n2.push(e3(t2[r2]));
        } else if (K.has(t2.constructor)) n2 = t2;
        else {
          var o2, a2 = c(t2);
          for (o2 in n2 = a2 === Object.prototype ? {} : Object.create(a2), E.set(t2, n2), t2) m2(t2, o2) && (n2[o2] = e3(t2[o2]));
        }
        return n2;
      }(e2);
      return E = null, e2;
    }
    var j = {}.toString;
    function A(e2) {
      return j.call(e2).slice(8, -1);
    }
    var C = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator", T = "symbol" == typeof C ? function(e2) {
      var t2;
      return null != e2 && (t2 = e2[C]) && t2.apply(e2);
    } : function() {
      return null;
    };
    function q(e2, t2) {
      t2 = e2.indexOf(t2);
      return 0 <= t2 && e2.splice(t2, 1), 0 <= t2;
    }
    var D = {};
    function I(e2) {
      var t2, n2, r2, i2;
      if (1 === arguments.length) {
        if (k(e2)) return e2.slice();
        if (this === D && "string" == typeof e2) return [e2];
        if (i2 = T(e2)) {
          for (n2 = []; !(r2 = i2.next()).done; ) n2.push(r2.value);
          return n2;
        }
        if (null == e2) return [e2];
        if ("number" != typeof (t2 = e2.length)) return [e2];
        for (n2 = new Array(t2); t2--; ) n2[t2] = e2[t2];
        return n2;
      }
      for (t2 = arguments.length, n2 = new Array(t2); t2--; ) n2[t2] = arguments[t2];
      return n2;
    }
    var B = "undefined" != typeof Symbol ? function(e2) {
      return "AsyncFunction" === e2[Symbol.toStringTag];
    } : function() {
      return false;
    }, R = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], M = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(R), F = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
    function N(e2, t2) {
      this.name = e2, this.message = t2;
    }
    function L(e2, t2) {
      return e2 + ". Errors: " + Object.keys(t2).map(function(e3) {
        return t2[e3].toString();
      }).filter(function(e3, t3, n2) {
        return n2.indexOf(e3) === t3;
      }).join("\n");
    }
    function U(e2, t2, n2, r2) {
      this.failures = t2, this.failedKeys = r2, this.successCount = n2, this.message = L(e2, t2);
    }
    function V(e2, t2) {
      this.name = "BulkError", this.failures = Object.keys(t2).map(function(e3) {
        return t2[e3];
      }), this.failuresByPos = t2, this.message = L(e2, this.failures);
    }
    o(N).from(Error).extend({ toString: function() {
      return this.name + ": " + this.message;
    } }), o(U).from(N), o(V).from(N);
    var z = M.reduce(function(e2, t2) {
      return e2[t2] = t2 + "Error", e2;
    }, {}), W = N, Y = M.reduce(function(e2, n2) {
      var r2 = n2 + "Error";
      function t2(e3, t3) {
        this.name = r2, e3 ? "string" == typeof e3 ? (this.message = "".concat(e3).concat(t3 ? "\n " + t3 : ""), this.inner = t3 || null) : "object" == typeof e3 && (this.message = "".concat(e3.name, " ").concat(e3.message), this.inner = e3) : (this.message = F[n2] || r2, this.inner = null);
      }
      return o(t2).from(W), e2[n2] = t2, e2;
    }, {});
    Y.Syntax = SyntaxError, Y.Type = TypeError, Y.Range = RangeError;
    var $ = R.reduce(function(e2, t2) {
      return e2[t2 + "Error"] = Y[t2], e2;
    }, {});
    var Q = M.reduce(function(e2, t2) {
      return -1 === ["Syntax", "Type", "Range"].indexOf(t2) && (e2[t2 + "Error"] = Y[t2]), e2;
    }, {});
    function G() {
    }
    function X(e2) {
      return e2;
    }
    function H(t2, n2) {
      return null == t2 || t2 === X ? n2 : function(e2) {
        return n2(t2(e2));
      };
    }
    function J(e2, t2) {
      return function() {
        e2.apply(this, arguments), t2.apply(this, arguments);
      };
    }
    function Z(i2, o2) {
      return i2 === G ? o2 : function() {
        var e2 = i2.apply(this, arguments);
        void 0 !== e2 && (arguments[0] = e2);
        var t2 = this.onsuccess, n2 = this.onerror;
        this.onsuccess = null, this.onerror = null;
        var r2 = o2.apply(this, arguments);
        return t2 && (this.onsuccess = this.onsuccess ? J(t2, this.onsuccess) : t2), n2 && (this.onerror = this.onerror ? J(n2, this.onerror) : n2), void 0 !== r2 ? r2 : e2;
      };
    }
    function ee(n2, r2) {
      return n2 === G ? r2 : function() {
        n2.apply(this, arguments);
        var e2 = this.onsuccess, t2 = this.onerror;
        this.onsuccess = this.onerror = null, r2.apply(this, arguments), e2 && (this.onsuccess = this.onsuccess ? J(e2, this.onsuccess) : e2), t2 && (this.onerror = this.onerror ? J(t2, this.onerror) : t2);
      };
    }
    function te(i2, o2) {
      return i2 === G ? o2 : function(e2) {
        var t2 = i2.apply(this, arguments);
        a(e2, t2);
        var n2 = this.onsuccess, r2 = this.onerror;
        this.onsuccess = null, this.onerror = null;
        e2 = o2.apply(this, arguments);
        return n2 && (this.onsuccess = this.onsuccess ? J(n2, this.onsuccess) : n2), r2 && (this.onerror = this.onerror ? J(r2, this.onerror) : r2), void 0 === t2 ? void 0 === e2 ? void 0 : e2 : a(t2, e2);
      };
    }
    function ne(e2, t2) {
      return e2 === G ? t2 : function() {
        return false !== t2.apply(this, arguments) && e2.apply(this, arguments);
      };
    }
    function re(i2, o2) {
      return i2 === G ? o2 : function() {
        var e2 = i2.apply(this, arguments);
        if (e2 && "function" == typeof e2.then) {
          for (var t2 = this, n2 = arguments.length, r2 = new Array(n2); n2--; ) r2[n2] = arguments[n2];
          return e2.then(function() {
            return o2.apply(t2, r2);
          });
        }
        return o2.apply(this, arguments);
      };
    }
    Q.ModifyError = U, Q.DexieError = N, Q.BulkError = V;
    var ie = "undefined" != typeof location && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function oe(e2) {
      ie = e2;
    }
    var ae = {}, ue = 100, e = "undefined" == typeof Promise ? [] : function() {
      var e2 = Promise.resolve();
      if ("undefined" == typeof crypto || !crypto.subtle) return [e2, c(e2), e2];
      var t2 = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
      return [t2, c(t2), e2];
    }(), R = e[0], M = e[1], e = e[2], M = M && M.then, se = R && R.constructor, ce = !!e;
    var le = function(e2, t2) {
      be.push([e2, t2]), he && (queueMicrotask(Se), he = false);
    }, fe = true, he = true, de = [], pe = [], ye = X, ve = { id: "global", global: true, ref: 0, unhandleds: [], onunhandled: G, pgp: false, env: {}, finalize: G }, me = ve, be = [], ge = 0, we = [];
    function _e(e2) {
      if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
      this._listeners = [], this._lib = false;
      var t2 = this._PSD = me;
      if ("function" != typeof e2) {
        if (e2 !== ae) throw new TypeError("Not a function");
        return this._state = arguments[1], this._value = arguments[2], void (false === this._state && Oe(this, this._value));
      }
      this._state = null, this._value = null, ++t2.ref, function t3(r2, e3) {
        try {
          e3(function(n2) {
            if (null === r2._state) {
              if (n2 === r2) throw new TypeError("A promise cannot be resolved with itself.");
              var e4 = r2._lib && je();
              n2 && "function" == typeof n2.then ? t3(r2, function(e5, t4) {
                n2 instanceof _e ? n2._then(e5, t4) : n2.then(e5, t4);
              }) : (r2._state = true, r2._value = n2, Pe(r2)), e4 && Ae();
            }
          }, Oe.bind(null, r2));
        } catch (e4) {
          Oe(r2, e4);
        }
      }(this, e2);
    }
    var xe = { get: function() {
      var u2 = me, t2 = Me;
      function e2(n2, r2) {
        var i2 = this, o2 = !u2.global && (u2 !== me || t2 !== Me), a2 = o2 && !Ue(), e3 = new _e(function(e4, t3) {
          Ke(i2, new ke(Qe(n2, u2, o2, a2), Qe(r2, u2, o2, a2), e4, t3, u2));
        });
        return this._consoleTask && (e3._consoleTask = this._consoleTask), e3;
      }
      return e2.prototype = ae, e2;
    }, set: function(e2) {
      l(this, "then", e2 && e2.prototype === ae ? xe : { get: function() {
        return e2;
      }, set: xe.set });
    } };
    function ke(e2, t2, n2, r2, i2) {
      this.onFulfilled = "function" == typeof e2 ? e2 : null, this.onRejected = "function" == typeof t2 ? t2 : null, this.resolve = n2, this.reject = r2, this.psd = i2;
    }
    function Oe(e2, t2) {
      var n2, r2;
      pe.push(t2), null === e2._state && (n2 = e2._lib && je(), t2 = ye(t2), e2._state = false, e2._value = t2, r2 = e2, de.some(function(e3) {
        return e3._value === r2._value;
      }) || de.push(r2), Pe(e2), n2 && Ae());
    }
    function Pe(e2) {
      var t2 = e2._listeners;
      e2._listeners = [];
      for (var n2 = 0, r2 = t2.length; n2 < r2; ++n2) Ke(e2, t2[n2]);
      var i2 = e2._PSD;
      --i2.ref || i2.finalize(), 0 === ge && (++ge, le(function() {
        0 == --ge && Ce();
      }, []));
    }
    function Ke(e2, t2) {
      if (null !== e2._state) {
        var n2 = e2._state ? t2.onFulfilled : t2.onRejected;
        if (null === n2) return (e2._state ? t2.resolve : t2.reject)(e2._value);
        ++t2.psd.ref, ++ge, le(Ee, [n2, e2, t2]);
      } else e2._listeners.push(t2);
    }
    function Ee(e2, t2, n2) {
      try {
        var r2, i2 = t2._value;
        !t2._state && pe.length && (pe = []), r2 = ie && t2._consoleTask ? t2._consoleTask.run(function() {
          return e2(i2);
        }) : e2(i2), t2._state || -1 !== pe.indexOf(i2) || function(e3) {
          var t3 = de.length;
          for (; t3; ) if (de[--t3]._value === e3._value) return de.splice(t3, 1);
        }(t2), n2.resolve(r2);
      } catch (e3) {
        n2.reject(e3);
      } finally {
        0 == --ge && Ce(), --n2.psd.ref || n2.psd.finalize();
      }
    }
    function Se() {
      $e(ve, function() {
        je() && Ae();
      });
    }
    function je() {
      var e2 = fe;
      return he = fe = false, e2;
    }
    function Ae() {
      var e2, t2, n2;
      do {
        for (; 0 < be.length; ) for (e2 = be, be = [], n2 = e2.length, t2 = 0; t2 < n2; ++t2) {
          var r2 = e2[t2];
          r2[0].apply(null, r2[1]);
        }
      } while (0 < be.length);
      he = fe = true;
    }
    function Ce() {
      var e2 = de;
      de = [], e2.forEach(function(e3) {
        e3._PSD.onunhandled.call(null, e3._value, e3);
      });
      for (var t2 = we.slice(0), n2 = t2.length; n2; ) t2[--n2]();
    }
    function Te(e2) {
      return new _e(ae, false, e2);
    }
    function qe(n2, r2) {
      var i2 = me;
      return function() {
        var e2 = je(), t2 = me;
        try {
          return We(i2, true), n2.apply(this, arguments);
        } catch (e3) {
          r2 && r2(e3);
        } finally {
          We(t2, false), e2 && Ae();
        }
      };
    }
    r(_e.prototype, { then: xe, _then: function(e2, t2) {
      Ke(this, new ke(null, null, e2, t2, me));
    }, catch: function(e2) {
      if (1 === arguments.length) return this.then(null, e2);
      var t2 = e2, n2 = arguments[1];
      return "function" == typeof t2 ? this.then(null, function(e3) {
        return (e3 instanceof t2 ? n2 : Te)(e3);
      }) : this.then(null, function(e3) {
        return (e3 && e3.name === t2 ? n2 : Te)(e3);
      });
    }, finally: function(t2) {
      return this.then(function(e2) {
        return _e.resolve(t2()).then(function() {
          return e2;
        });
      }, function(e2) {
        return _e.resolve(t2()).then(function() {
          return Te(e2);
        });
      });
    }, timeout: function(r2, i2) {
      var o2 = this;
      return r2 < 1 / 0 ? new _e(function(e2, t2) {
        var n2 = setTimeout(function() {
          return t2(new Y.Timeout(i2));
        }, r2);
        o2.then(e2, t2).finally(clearTimeout.bind(null, n2));
      }) : this;
    } }), "undefined" != typeof Symbol && Symbol.toStringTag && l(_e.prototype, Symbol.toStringTag, "Dexie.Promise"), ve.env = Ye(), r(_e, { all: function() {
      var o2 = I.apply(null, arguments).map(Ve);
      return new _e(function(n2, r2) {
        0 === o2.length && n2([]);
        var i2 = o2.length;
        o2.forEach(function(e2, t2) {
          return _e.resolve(e2).then(function(e3) {
            o2[t2] = e3, --i2 || n2(o2);
          }, r2);
        });
      });
    }, resolve: function(n2) {
      return n2 instanceof _e ? n2 : n2 && "function" == typeof n2.then ? new _e(function(e2, t2) {
        n2.then(e2, t2);
      }) : new _e(ae, true, n2);
    }, reject: Te, race: function() {
      var e2 = I.apply(null, arguments).map(Ve);
      return new _e(function(t2, n2) {
        e2.map(function(e3) {
          return _e.resolve(e3).then(t2, n2);
        });
      });
    }, PSD: { get: function() {
      return me;
    }, set: function(e2) {
      return me = e2;
    } }, totalEchoes: { get: function() {
      return Me;
    } }, newPSD: Ne, usePSD: $e, scheduler: { get: function() {
      return le;
    }, set: function(e2) {
      le = e2;
    } }, rejectionMapper: { get: function() {
      return ye;
    }, set: function(e2) {
      ye = e2;
    } }, follow: function(i2, n2) {
      return new _e(function(e2, t2) {
        return Ne(function(n3, r2) {
          var e3 = me;
          e3.unhandleds = [], e3.onunhandled = r2, e3.finalize = J(function() {
            var t3, e4 = this;
            t3 = function() {
              0 === e4.unhandleds.length ? n3() : r2(e4.unhandleds[0]);
            }, we.push(function e5() {
              t3(), we.splice(we.indexOf(e5), 1);
            }), ++ge, le(function() {
              0 == --ge && Ce();
            }, []);
          }, e3.finalize), i2();
        }, n2, e2, t2);
      });
    } }), se && (se.allSettled && l(_e, "allSettled", function() {
      var e2 = I.apply(null, arguments).map(Ve);
      return new _e(function(n2) {
        0 === e2.length && n2([]);
        var r2 = e2.length, i2 = new Array(r2);
        e2.forEach(function(e3, t2) {
          return _e.resolve(e3).then(function(e4) {
            return i2[t2] = { status: "fulfilled", value: e4 };
          }, function(e4) {
            return i2[t2] = { status: "rejected", reason: e4 };
          }).then(function() {
            return --r2 || n2(i2);
          });
        });
      });
    }), se.any && "undefined" != typeof AggregateError && l(_e, "any", function() {
      var e2 = I.apply(null, arguments).map(Ve);
      return new _e(function(n2, r2) {
        0 === e2.length && r2(new AggregateError([]));
        var i2 = e2.length, o2 = new Array(i2);
        e2.forEach(function(e3, t2) {
          return _e.resolve(e3).then(function(e4) {
            return n2(e4);
          }, function(e4) {
            o2[t2] = e4, --i2 || r2(new AggregateError(o2));
          });
        });
      });
    }), se.withResolvers && (_e.withResolvers = se.withResolvers));
    var De = { awaits: 0, echoes: 0, id: 0 }, Ie = 0, Be = [], Re = 0, Me = 0, Fe = 0;
    function Ne(e2, t2, n2, r2) {
      var i2 = me, o2 = Object.create(i2);
      o2.parent = i2, o2.ref = 0, o2.global = false, o2.id = ++Fe, ve.env, o2.env = ce ? { Promise: _e, PromiseProp: { value: _e, configurable: true, writable: true }, all: _e.all, race: _e.race, allSettled: _e.allSettled, any: _e.any, resolve: _e.resolve, reject: _e.reject } : {}, t2 && a(o2, t2), ++i2.ref, o2.finalize = function() {
        --this.parent.ref || this.parent.finalize();
      };
      r2 = $e(o2, e2, n2, r2);
      return 0 === o2.ref && o2.finalize(), r2;
    }
    function Le() {
      return De.id || (De.id = ++Ie), ++De.awaits, De.echoes += ue, De.id;
    }
    function Ue() {
      return !!De.awaits && (0 == --De.awaits && (De.id = 0), De.echoes = De.awaits * ue, true);
    }
    function Ve(e2) {
      return De.echoes && e2 && e2.constructor === se ? (Le(), e2.then(function(e3) {
        return Ue(), e3;
      }, function(e3) {
        return Ue(), Xe(e3);
      })) : e2;
    }
    function ze() {
      var e2 = Be[Be.length - 1];
      Be.pop(), We(e2, false);
    }
    function We(e2, t2) {
      var n2, r2 = me;
      (t2 ? !De.echoes || Re++ && e2 === me : !Re || --Re && e2 === me) || queueMicrotask(t2 ? (function(e3) {
        ++Me, De.echoes && 0 != --De.echoes || (De.echoes = De.awaits = De.id = 0), Be.push(me), We(e3, true);
      }).bind(null, e2) : ze), e2 !== me && (me = e2, r2 === ve && (ve.env = Ye()), ce && (n2 = ve.env.Promise, t2 = e2.env, (r2.global || e2.global) && (Object.defineProperty(f, "Promise", t2.PromiseProp), n2.all = t2.all, n2.race = t2.race, n2.resolve = t2.resolve, n2.reject = t2.reject, t2.allSettled && (n2.allSettled = t2.allSettled), t2.any && (n2.any = t2.any))));
    }
    function Ye() {
      var e2 = f.Promise;
      return ce ? { Promise: e2, PromiseProp: Object.getOwnPropertyDescriptor(f, "Promise"), all: e2.all, race: e2.race, allSettled: e2.allSettled, any: e2.any, resolve: e2.resolve, reject: e2.reject } : {};
    }
    function $e(e2, t2, n2, r2, i2) {
      var o2 = me;
      try {
        return We(e2, true), t2(n2, r2, i2);
      } finally {
        We(o2, false);
      }
    }
    function Qe(t2, n2, r2, i2) {
      return "function" != typeof t2 ? t2 : function() {
        var e2 = me;
        r2 && Le(), We(n2, true);
        try {
          return t2.apply(this, arguments);
        } finally {
          We(e2, false), i2 && queueMicrotask(Ue);
        }
      };
    }
    function Ge(e2) {
      Promise === se && 0 === De.echoes ? 0 === Re ? e2() : enqueueNativeMicroTask(e2) : setTimeout(e2, 0);
    }
    -1 === ("" + M).indexOf("[native code]") && (Le = Ue = G);
    var Xe = _e.reject;
    var He = String.fromCharCode(65535), Je = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Ze = "String expected.", et = [], tt2 = "__dbnames", nt = "readonly", rt = "readwrite";
    function it(e2, t2) {
      return e2 ? t2 ? function() {
        return e2.apply(this, arguments) && t2.apply(this, arguments);
      } : e2 : t2;
    }
    var ot = { type: 3, lower: -1 / 0, lowerOpen: false, upper: [[]], upperOpen: false };
    function at(t2) {
      return "string" != typeof t2 || /\./.test(t2) ? function(e2) {
        return e2;
      } : function(e2) {
        return void 0 === e2[t2] && t2 in e2 && delete (e2 = S(e2))[t2], e2;
      };
    }
    function ut() {
      throw Y.Type();
    }
    function st(e2, t2) {
      try {
        var n2 = ct(e2), r2 = ct(t2);
        if (n2 !== r2) return "Array" === n2 ? 1 : "Array" === r2 ? -1 : "binary" === n2 ? 1 : "binary" === r2 ? -1 : "string" === n2 ? 1 : "string" === r2 ? -1 : "Date" === n2 ? 1 : "Date" !== r2 ? NaN : -1;
        switch (n2) {
          case "number":
          case "Date":
          case "string":
            return t2 < e2 ? 1 : e2 < t2 ? -1 : 0;
          case "binary":
            return function(e3, t3) {
              for (var n3 = e3.length, r3 = t3.length, i2 = n3 < r3 ? n3 : r3, o2 = 0; o2 < i2; ++o2) if (e3[o2] !== t3[o2]) return e3[o2] < t3[o2] ? -1 : 1;
              return n3 === r3 ? 0 : n3 < r3 ? -1 : 1;
            }(lt(e2), lt(t2));
          case "Array":
            return function(e3, t3) {
              for (var n3 = e3.length, r3 = t3.length, i2 = n3 < r3 ? n3 : r3, o2 = 0; o2 < i2; ++o2) {
                var a2 = st(e3[o2], t3[o2]);
                if (0 !== a2) return a2;
              }
              return n3 === r3 ? 0 : n3 < r3 ? -1 : 1;
            }(e2, t2);
        }
      } catch (e3) {
      }
      return NaN;
    }
    function ct(e2) {
      var t2 = typeof e2;
      if ("object" != t2) return t2;
      if (ArrayBuffer.isView(e2)) return "binary";
      e2 = A(e2);
      return "ArrayBuffer" === e2 ? "binary" : e2;
    }
    function lt(e2) {
      return e2 instanceof Uint8Array ? e2 : ArrayBuffer.isView(e2) ? new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength) : new Uint8Array(e2);
    }
    var ft = (ht.prototype._trans = function(e2, r2, t2) {
      var n2 = this._tx || me.trans, i2 = this.name, o2 = ie && "undefined" != typeof console && console.createTask && console.createTask("Dexie: ".concat("readonly" === e2 ? "read" : "write", " ").concat(this.name));
      function a2(e3, t3, n3) {
        if (!n3.schema[i2]) throw new Y.NotFound("Table " + i2 + " not part of transaction");
        return r2(n3.idbtrans, n3);
      }
      var u2 = je();
      try {
        var s2 = n2 && n2.db._novip === this.db._novip ? n2 === me.trans ? n2._promise(e2, a2, t2) : Ne(function() {
          return n2._promise(e2, a2, t2);
        }, { trans: n2, transless: me.transless || me }) : function t3(n3, r3, i3, o3) {
          if (n3.idbdb && (n3._state.openComplete || me.letThrough || n3._vip)) {
            var a3 = n3._createTransaction(r3, i3, n3._dbSchema);
            try {
              a3.create(), n3._state.PR1398_maxLoop = 3;
            } catch (e3) {
              return e3.name === z.InvalidState && n3.isOpen() && 0 < --n3._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), n3.close({ disableAutoOpen: false }), n3.open().then(function() {
                return t3(n3, r3, i3, o3);
              })) : Xe(e3);
            }
            return a3._promise(r3, function(e3, t4) {
              return Ne(function() {
                return me.trans = a3, o3(e3, t4, a3);
              });
            }).then(function(e3) {
              if ("readwrite" === r3) try {
                a3.idbtrans.commit();
              } catch (e4) {
              }
              return "readonly" === r3 ? e3 : a3._completion.then(function() {
                return e3;
              });
            });
          }
          if (n3._state.openComplete) return Xe(new Y.DatabaseClosed(n3._state.dbOpenError));
          if (!n3._state.isBeingOpened) {
            if (!n3._state.autoOpen) return Xe(new Y.DatabaseClosed());
            n3.open().catch(G);
          }
          return n3._state.dbReadyPromise.then(function() {
            return t3(n3, r3, i3, o3);
          });
        }(this.db, e2, [this.name], a2);
        return o2 && (s2._consoleTask = o2, s2 = s2.catch(function(e3) {
          return console.trace(e3), Xe(e3);
        })), s2;
      } finally {
        u2 && Ae();
      }
    }, ht.prototype.get = function(t2, e2) {
      var n2 = this;
      return t2 && t2.constructor === Object ? this.where(t2).first(e2) : null == t2 ? Xe(new Y.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(e3) {
        return n2.core.get({ trans: e3, key: t2 }).then(function(e4) {
          return n2.hook.reading.fire(e4);
        });
      }).then(e2);
    }, ht.prototype.where = function(o2) {
      if ("string" == typeof o2) return new this.db.WhereClause(this, o2);
      if (k(o2)) return new this.db.WhereClause(this, "[".concat(o2.join("+"), "]"));
      var n2 = x(o2);
      if (1 === n2.length) return this.where(n2[0]).equals(o2[n2[0]]);
      var e2 = this.schema.indexes.concat(this.schema.primKey).filter(function(t3) {
        if (t3.compound && n2.every(function(e4) {
          return 0 <= t3.keyPath.indexOf(e4);
        })) {
          for (var e3 = 0; e3 < n2.length; ++e3) if (-1 === n2.indexOf(t3.keyPath[e3])) return false;
          return true;
        }
        return false;
      }).sort(function(e3, t3) {
        return e3.keyPath.length - t3.keyPath.length;
      })[0];
      if (e2 && this.db._maxKey !== He) {
        var t2 = e2.keyPath.slice(0, n2.length);
        return this.where(t2).equals(t2.map(function(e3) {
          return o2[e3];
        }));
      }
      !e2 && ie && console.warn("The query ".concat(JSON.stringify(o2), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n2.join("+"), "]"));
      var a2 = this.schema.idxByName;
      function u2(e3, t3) {
        return 0 === st(e3, t3);
      }
      var r2 = n2.reduce(function(e3, t3) {
        var n3 = e3[0], r3 = e3[1], e3 = a2[t3], i2 = o2[t3];
        return [n3 || e3, n3 || !e3 ? it(r3, e3 && e3.multi ? function(e4) {
          e4 = O(e4, t3);
          return k(e4) && e4.some(function(e5) {
            return u2(i2, e5);
          });
        } : function(e4) {
          return u2(i2, O(e4, t3));
        }) : r3];
      }, [null, null]), t2 = r2[0], r2 = r2[1];
      return t2 ? this.where(t2.name).equals(o2[t2.keyPath]).filter(r2) : e2 ? this.filter(r2) : this.where(n2).equals("");
    }, ht.prototype.filter = function(e2) {
      return this.toCollection().and(e2);
    }, ht.prototype.count = function(e2) {
      return this.toCollection().count(e2);
    }, ht.prototype.offset = function(e2) {
      return this.toCollection().offset(e2);
    }, ht.prototype.limit = function(e2) {
      return this.toCollection().limit(e2);
    }, ht.prototype.each = function(e2) {
      return this.toCollection().each(e2);
    }, ht.prototype.toArray = function(e2) {
      return this.toCollection().toArray(e2);
    }, ht.prototype.toCollection = function() {
      return new this.db.Collection(new this.db.WhereClause(this));
    }, ht.prototype.orderBy = function(e2) {
      return new this.db.Collection(new this.db.WhereClause(this, k(e2) ? "[".concat(e2.join("+"), "]") : e2));
    }, ht.prototype.reverse = function() {
      return this.toCollection().reverse();
    }, ht.prototype.mapToClass = function(r2) {
      var e2, t2 = this.db, n2 = this.name;
      function i2() {
        return null !== e2 && e2.apply(this, arguments) || this;
      }
      (this.schema.mappedClass = r2).prototype instanceof ut && (function(e3, t3) {
        if ("function" != typeof t3 && null !== t3) throw new TypeError("Class extends value " + String(t3) + " is not a constructor or null");
        function n3() {
          this.constructor = e3;
        }
        s(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (n3.prototype = t3.prototype, new n3());
      }(i2, e2 = r2), Object.defineProperty(i2.prototype, "db", { get: function() {
        return t2;
      }, enumerable: false, configurable: true }), i2.prototype.table = function() {
        return n2;
      }, r2 = i2);
      for (var o2 = /* @__PURE__ */ new Set(), a2 = r2.prototype; a2; a2 = c(a2)) Object.getOwnPropertyNames(a2).forEach(function(e3) {
        return o2.add(e3);
      });
      function u2(e3) {
        if (!e3) return e3;
        var t3, n3 = Object.create(r2.prototype);
        for (t3 in e3) if (!o2.has(t3)) try {
          n3[t3] = e3[t3];
        } catch (e4) {
        }
        return n3;
      }
      return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = u2, this.hook("reading", u2), r2;
    }, ht.prototype.defineClass = function() {
      return this.mapToClass(function(e2) {
        a(this, e2);
      });
    }, ht.prototype.add = function(t2, n2) {
      var r2 = this, e2 = this.schema.primKey, i2 = e2.auto, o2 = e2.keyPath, a2 = t2;
      return o2 && i2 && (a2 = at(o2)(t2)), this._trans("readwrite", function(e3) {
        return r2.core.mutate({ trans: e3, type: "add", keys: null != n2 ? [n2] : null, values: [a2] });
      }).then(function(e3) {
        return e3.numFailures ? _e.reject(e3.failures[0]) : e3.lastResult;
      }).then(function(e3) {
        if (o2) try {
          P(t2, o2, e3);
        } catch (e4) {
        }
        return e3;
      });
    }, ht.prototype.update = function(e2, t2) {
      if ("object" != typeof e2 || k(e2)) return this.where(":id").equals(e2).modify(t2);
      e2 = O(e2, this.schema.primKey.keyPath);
      return void 0 === e2 ? Xe(new Y.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e2).modify(t2);
    }, ht.prototype.put = function(t2, n2) {
      var r2 = this, e2 = this.schema.primKey, i2 = e2.auto, o2 = e2.keyPath, a2 = t2;
      return o2 && i2 && (a2 = at(o2)(t2)), this._trans("readwrite", function(e3) {
        return r2.core.mutate({ trans: e3, type: "put", values: [a2], keys: null != n2 ? [n2] : null });
      }).then(function(e3) {
        return e3.numFailures ? _e.reject(e3.failures[0]) : e3.lastResult;
      }).then(function(e3) {
        if (o2) try {
          P(t2, o2, e3);
        } catch (e4) {
        }
        return e3;
      });
    }, ht.prototype.delete = function(t2) {
      var n2 = this;
      return this._trans("readwrite", function(e2) {
        return n2.core.mutate({ trans: e2, type: "delete", keys: [t2] });
      }).then(function(e2) {
        return e2.numFailures ? _e.reject(e2.failures[0]) : void 0;
      });
    }, ht.prototype.clear = function() {
      var t2 = this;
      return this._trans("readwrite", function(e2) {
        return t2.core.mutate({ trans: e2, type: "deleteRange", range: ot });
      }).then(function(e2) {
        return e2.numFailures ? _e.reject(e2.failures[0]) : void 0;
      });
    }, ht.prototype.bulkGet = function(t2) {
      var n2 = this;
      return this._trans("readonly", function(e2) {
        return n2.core.getMany({ keys: t2, trans: e2 }).then(function(e3) {
          return e3.map(function(e4) {
            return n2.hook.reading.fire(e4);
          });
        });
      });
    }, ht.prototype.bulkAdd = function(r2, e2, t2) {
      var o2 = this, a2 = Array.isArray(e2) ? e2 : void 0, u2 = (t2 = t2 || (a2 ? void 0 : e2)) ? t2.allKeys : void 0;
      return this._trans("readwrite", function(e3) {
        var t3 = o2.schema.primKey, n2 = t3.auto, t3 = t3.keyPath;
        if (t3 && a2) throw new Y.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
        if (a2 && a2.length !== r2.length) throw new Y.InvalidArgument("Arguments objects and keys must have the same length");
        var i2 = r2.length, t3 = t3 && n2 ? r2.map(at(t3)) : r2;
        return o2.core.mutate({ trans: e3, type: "add", keys: a2, values: t3, wantResults: u2 }).then(function(e4) {
          var t4 = e4.numFailures, n3 = e4.results, r3 = e4.lastResult, e4 = e4.failures;
          if (0 === t4) return u2 ? n3 : r3;
          throw new V("".concat(o2.name, ".bulkAdd(): ").concat(t4, " of ").concat(i2, " operations failed"), e4);
        });
      });
    }, ht.prototype.bulkPut = function(r2, e2, t2) {
      var o2 = this, a2 = Array.isArray(e2) ? e2 : void 0, u2 = (t2 = t2 || (a2 ? void 0 : e2)) ? t2.allKeys : void 0;
      return this._trans("readwrite", function(e3) {
        var t3 = o2.schema.primKey, n2 = t3.auto, t3 = t3.keyPath;
        if (t3 && a2) throw new Y.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
        if (a2 && a2.length !== r2.length) throw new Y.InvalidArgument("Arguments objects and keys must have the same length");
        var i2 = r2.length, t3 = t3 && n2 ? r2.map(at(t3)) : r2;
        return o2.core.mutate({ trans: e3, type: "put", keys: a2, values: t3, wantResults: u2 }).then(function(e4) {
          var t4 = e4.numFailures, n3 = e4.results, r3 = e4.lastResult, e4 = e4.failures;
          if (0 === t4) return u2 ? n3 : r3;
          throw new V("".concat(o2.name, ".bulkPut(): ").concat(t4, " of ").concat(i2, " operations failed"), e4);
        });
      });
    }, ht.prototype.bulkUpdate = function(t2) {
      var h3 = this, n2 = this.core, r2 = t2.map(function(e2) {
        return e2.key;
      }), i2 = t2.map(function(e2) {
        return e2.changes;
      }), d2 = [];
      return this._trans("readwrite", function(e2) {
        return n2.getMany({ trans: e2, keys: r2, cache: "clone" }).then(function(c2) {
          var l2 = [], f2 = [];
          t2.forEach(function(e3, t3) {
            var n3 = e3.key, r3 = e3.changes, i3 = c2[t3];
            if (i3) {
              for (var o2 = 0, a2 = Object.keys(r3); o2 < a2.length; o2++) {
                var u2 = a2[o2], s3 = r3[u2];
                if (u2 === h3.schema.primKey.keyPath) {
                  if (0 !== st(s3, n3)) throw new Y.Constraint("Cannot update primary key in bulkUpdate()");
                } else P(i3, u2, s3);
              }
              d2.push(t3), l2.push(n3), f2.push(i3);
            }
          });
          var s2 = l2.length;
          return n2.mutate({ trans: e2, type: "put", keys: l2, values: f2, updates: { keys: r2, changeSpecs: i2 } }).then(function(e3) {
            var t3 = e3.numFailures, n3 = e3.failures;
            if (0 === t3) return s2;
            for (var r3 = 0, i3 = Object.keys(n3); r3 < i3.length; r3++) {
              var o2, a2 = i3[r3], u2 = d2[Number(a2)];
              null != u2 && (o2 = n3[a2], delete n3[a2], n3[u2] = o2);
            }
            throw new V("".concat(h3.name, ".bulkUpdate(): ").concat(t3, " of ").concat(s2, " operations failed"), n3);
          });
        });
      });
    }, ht.prototype.bulkDelete = function(t2) {
      var r2 = this, i2 = t2.length;
      return this._trans("readwrite", function(e2) {
        return r2.core.mutate({ trans: e2, type: "delete", keys: t2 });
      }).then(function(e2) {
        var t3 = e2.numFailures, n2 = e2.lastResult, e2 = e2.failures;
        if (0 === t3) return n2;
        throw new V("".concat(r2.name, ".bulkDelete(): ").concat(t3, " of ").concat(i2, " operations failed"), e2);
      });
    }, ht);
    function ht() {
    }
    function dt(i2) {
      function t2(e3, t3) {
        if (t3) {
          for (var n3 = arguments.length, r2 = new Array(n3 - 1); --n3; ) r2[n3 - 1] = arguments[n3];
          return a2[e3].subscribe.apply(null, r2), i2;
        }
        if ("string" == typeof e3) return a2[e3];
      }
      var a2 = {};
      t2.addEventType = u2;
      for (var e2 = 1, n2 = arguments.length; e2 < n2; ++e2) u2(arguments[e2]);
      return t2;
      function u2(e3, n3, r2) {
        if ("object" != typeof e3) {
          var i3;
          n3 = n3 || ne;
          var o2 = { subscribers: [], fire: r2 = r2 || G, subscribe: function(e4) {
            -1 === o2.subscribers.indexOf(e4) && (o2.subscribers.push(e4), o2.fire = n3(o2.fire, e4));
          }, unsubscribe: function(t3) {
            o2.subscribers = o2.subscribers.filter(function(e4) {
              return e4 !== t3;
            }), o2.fire = o2.subscribers.reduce(n3, r2);
          } };
          return a2[e3] = t2[e3] = o2;
        }
        x(i3 = e3).forEach(function(e4) {
          var t3 = i3[e4];
          if (k(t3)) u2(e4, i3[e4][0], i3[e4][1]);
          else {
            if ("asap" !== t3) throw new Y.InvalidArgument("Invalid event config");
            var n4 = u2(e4, X, function() {
              for (var e5 = arguments.length, t4 = new Array(e5); e5--; ) t4[e5] = arguments[e5];
              n4.subscribers.forEach(function(e6) {
                v2(function() {
                  e6.apply(null, t4);
                });
              });
            });
          }
        });
      }
    }
    function pt(e2, t2) {
      return o(t2).from({ prototype: e2 }), t2;
    }
    function yt(e2, t2) {
      return !(e2.filter || e2.algorithm || e2.or) && (t2 ? e2.justLimit : !e2.replayFilter);
    }
    function vt(e2, t2) {
      e2.filter = it(e2.filter, t2);
    }
    function mt(e2, t2, n2) {
      var r2 = e2.replayFilter;
      e2.replayFilter = r2 ? function() {
        return it(r2(), t2());
      } : t2, e2.justLimit = n2 && !r2;
    }
    function bt(e2, t2) {
      if (e2.isPrimKey) return t2.primaryKey;
      var n2 = t2.getIndexByKeyPath(e2.index);
      if (!n2) throw new Y.Schema("KeyPath " + e2.index + " on object store " + t2.name + " is not indexed");
      return n2;
    }
    function gt(e2, t2, n2) {
      var r2 = bt(e2, t2.schema);
      return t2.openCursor({ trans: n2, values: !e2.keysOnly, reverse: "prev" === e2.dir, unique: !!e2.unique, query: { index: r2, range: e2.range } });
    }
    function wt(e2, o2, t2, n2) {
      var a2 = e2.replayFilter ? it(e2.filter, e2.replayFilter()) : e2.filter;
      if (e2.or) {
        var u2 = {}, r2 = function(e3, t3, n3) {
          var r3, i2;
          a2 && !a2(t3, n3, function(e4) {
            return t3.stop(e4);
          }, function(e4) {
            return t3.fail(e4);
          }) || ("[object ArrayBuffer]" === (i2 = "" + (r3 = t3.primaryKey)) && (i2 = "" + new Uint8Array(r3)), m2(u2, i2) || (u2[i2] = true, o2(e3, t3, n3)));
        };
        return Promise.all([e2.or._iterate(r2, t2), _t(gt(e2, n2, t2), e2.algorithm, r2, !e2.keysOnly && e2.valueMapper)]);
      }
      return _t(gt(e2, n2, t2), it(e2.algorithm, a2), o2, !e2.keysOnly && e2.valueMapper);
    }
    function _t(e2, r2, i2, o2) {
      var a2 = qe(o2 ? function(e3, t2, n2) {
        return i2(o2(e3), t2, n2);
      } : i2);
      return e2.then(function(n2) {
        if (n2) return n2.start(function() {
          var t2 = function() {
            return n2.continue();
          };
          r2 && !r2(n2, function(e3) {
            return t2 = e3;
          }, function(e3) {
            n2.stop(e3), t2 = G;
          }, function(e3) {
            n2.fail(e3), t2 = G;
          }) || a2(n2.value, n2, function(e3) {
            return t2 = e3;
          }), t2();
        });
      });
    }
    var e = Symbol(), xt = (kt.prototype.execute = function(e2) {
      if (void 0 !== this.add) {
        var t2 = this.add;
        if (k(t2)) return i(i([], k(e2) ? e2 : [], true), t2).sort();
        if ("number" == typeof t2) return (Number(e2) || 0) + t2;
        if ("bigint" == typeof t2) try {
          return BigInt(e2) + t2;
        } catch (e3) {
          return BigInt(0) + t2;
        }
        throw new TypeError("Invalid term ".concat(t2));
      }
      if (void 0 !== this.remove) {
        var n2 = this.remove;
        if (k(n2)) return k(e2) ? e2.filter(function(e3) {
          return !n2.includes(e3);
        }).sort() : [];
        if ("number" == typeof n2) return Number(e2) - n2;
        if ("bigint" == typeof n2) try {
          return BigInt(e2) - n2;
        } catch (e3) {
          return BigInt(0) - n2;
        }
        throw new TypeError("Invalid subtrahend ".concat(n2));
      }
      t2 = null === (t2 = this.replacePrefix) || void 0 === t2 ? void 0 : t2[0];
      return t2 && "string" == typeof e2 && e2.startsWith(t2) ? this.replacePrefix[1] + e2.substring(t2.length) : e2;
    }, kt);
    function kt(e2) {
      Object.assign(this, e2);
    }
    var Ot = (Pt.prototype._read = function(e2, t2) {
      var n2 = this._ctx;
      return n2.error ? n2.table._trans(null, Xe.bind(null, n2.error)) : n2.table._trans("readonly", e2).then(t2);
    }, Pt.prototype._write = function(e2) {
      var t2 = this._ctx;
      return t2.error ? t2.table._trans(null, Xe.bind(null, t2.error)) : t2.table._trans("readwrite", e2, "locked");
    }, Pt.prototype._addAlgorithm = function(e2) {
      var t2 = this._ctx;
      t2.algorithm = it(t2.algorithm, e2);
    }, Pt.prototype._iterate = function(e2, t2) {
      return wt(this._ctx, e2, t2, this._ctx.table.core);
    }, Pt.prototype.clone = function(e2) {
      var t2 = Object.create(this.constructor.prototype), n2 = Object.create(this._ctx);
      return e2 && a(n2, e2), t2._ctx = n2, t2;
    }, Pt.prototype.raw = function() {
      return this._ctx.valueMapper = null, this;
    }, Pt.prototype.each = function(t2) {
      var n2 = this._ctx;
      return this._read(function(e2) {
        return wt(n2, t2, e2, n2.table.core);
      });
    }, Pt.prototype.count = function(e2) {
      var i2 = this;
      return this._read(function(e3) {
        var t2 = i2._ctx, n2 = t2.table.core;
        if (yt(t2, true)) return n2.count({ trans: e3, query: { index: bt(t2, n2.schema), range: t2.range } }).then(function(e4) {
          return Math.min(e4, t2.limit);
        });
        var r2 = 0;
        return wt(t2, function() {
          return ++r2, false;
        }, e3, n2).then(function() {
          return r2;
        });
      }).then(e2);
    }, Pt.prototype.sortBy = function(e2, t2) {
      var n2 = e2.split(".").reverse(), r2 = n2[0], i2 = n2.length - 1;
      function o2(e3, t3) {
        return t3 ? o2(e3[n2[t3]], t3 - 1) : e3[r2];
      }
      var a2 = "next" === this._ctx.dir ? 1 : -1;
      function u2(e3, t3) {
        return st(o2(e3, i2), o2(t3, i2)) * a2;
      }
      return this.toArray(function(e3) {
        return e3.sort(u2);
      }).then(t2);
    }, Pt.prototype.toArray = function(e2) {
      var o2 = this;
      return this._read(function(e3) {
        var t2 = o2._ctx;
        if ("next" === t2.dir && yt(t2, true) && 0 < t2.limit) {
          var n2 = t2.valueMapper, r2 = bt(t2, t2.table.core.schema);
          return t2.table.core.query({ trans: e3, limit: t2.limit, values: true, query: { index: r2, range: t2.range } }).then(function(e4) {
            e4 = e4.result;
            return n2 ? e4.map(n2) : e4;
          });
        }
        var i2 = [];
        return wt(t2, function(e4) {
          return i2.push(e4);
        }, e3, t2.table.core).then(function() {
          return i2;
        });
      }, e2);
    }, Pt.prototype.offset = function(t2) {
      var e2 = this._ctx;
      return t2 <= 0 || (e2.offset += t2, yt(e2) ? mt(e2, function() {
        var n2 = t2;
        return function(e3, t3) {
          return 0 === n2 || (1 === n2 ? --n2 : t3(function() {
            e3.advance(n2), n2 = 0;
          }), false);
        };
      }) : mt(e2, function() {
        var e3 = t2;
        return function() {
          return --e3 < 0;
        };
      })), this;
    }, Pt.prototype.limit = function(e2) {
      return this._ctx.limit = Math.min(this._ctx.limit, e2), mt(this._ctx, function() {
        var r2 = e2;
        return function(e3, t2, n2) {
          return --r2 <= 0 && t2(n2), 0 <= r2;
        };
      }, true), this;
    }, Pt.prototype.until = function(r2, i2) {
      return vt(this._ctx, function(e2, t2, n2) {
        return !r2(e2.value) || (t2(n2), i2);
      }), this;
    }, Pt.prototype.first = function(e2) {
      return this.limit(1).toArray(function(e3) {
        return e3[0];
      }).then(e2);
    }, Pt.prototype.last = function(e2) {
      return this.reverse().first(e2);
    }, Pt.prototype.filter = function(t2) {
      var e2;
      return vt(this._ctx, function(e3) {
        return t2(e3.value);
      }), (e2 = this._ctx).isMatch = it(e2.isMatch, t2), this;
    }, Pt.prototype.and = function(e2) {
      return this.filter(e2);
    }, Pt.prototype.or = function(e2) {
      return new this.db.WhereClause(this._ctx.table, e2, this);
    }, Pt.prototype.reverse = function() {
      return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
    }, Pt.prototype.desc = function() {
      return this.reverse();
    }, Pt.prototype.eachKey = function(n2) {
      var e2 = this._ctx;
      return e2.keysOnly = !e2.isMatch, this.each(function(e3, t2) {
        n2(t2.key, t2);
      });
    }, Pt.prototype.eachUniqueKey = function(e2) {
      return this._ctx.unique = "unique", this.eachKey(e2);
    }, Pt.prototype.eachPrimaryKey = function(n2) {
      var e2 = this._ctx;
      return e2.keysOnly = !e2.isMatch, this.each(function(e3, t2) {
        n2(t2.primaryKey, t2);
      });
    }, Pt.prototype.keys = function(e2) {
      var t2 = this._ctx;
      t2.keysOnly = !t2.isMatch;
      var n2 = [];
      return this.each(function(e3, t3) {
        n2.push(t3.key);
      }).then(function() {
        return n2;
      }).then(e2);
    }, Pt.prototype.primaryKeys = function(e2) {
      var n2 = this._ctx;
      if ("next" === n2.dir && yt(n2, true) && 0 < n2.limit) return this._read(function(e3) {
        var t2 = bt(n2, n2.table.core.schema);
        return n2.table.core.query({ trans: e3, values: false, limit: n2.limit, query: { index: t2, range: n2.range } });
      }).then(function(e3) {
        return e3.result;
      }).then(e2);
      n2.keysOnly = !n2.isMatch;
      var r2 = [];
      return this.each(function(e3, t2) {
        r2.push(t2.primaryKey);
      }).then(function() {
        return r2;
      }).then(e2);
    }, Pt.prototype.uniqueKeys = function(e2) {
      return this._ctx.unique = "unique", this.keys(e2);
    }, Pt.prototype.firstKey = function(e2) {
      return this.limit(1).keys(function(e3) {
        return e3[0];
      }).then(e2);
    }, Pt.prototype.lastKey = function(e2) {
      return this.reverse().firstKey(e2);
    }, Pt.prototype.distinct = function() {
      var e2 = this._ctx, e2 = e2.index && e2.table.schema.idxByName[e2.index];
      if (!e2 || !e2.multi) return this;
      var n2 = {};
      return vt(this._ctx, function(e3) {
        var t2 = e3.primaryKey.toString(), e3 = m2(n2, t2);
        return n2[t2] = true, !e3;
      }), this;
    }, Pt.prototype.modify = function(w2) {
      var n2 = this, r2 = this._ctx;
      return this._write(function(d2) {
        var a2, u2, p3;
        p3 = "function" == typeof w2 ? w2 : (a2 = x(w2), u2 = a2.length, function(e3) {
          for (var t3 = false, n3 = 0; n3 < u2; ++n3) {
            var r3 = a2[n3], i2 = w2[r3], o2 = O(e3, r3);
            i2 instanceof xt ? (P(e3, r3, i2.execute(o2)), t3 = true) : o2 !== i2 && (P(e3, r3, i2), t3 = true);
          }
          return t3;
        });
        var y2 = r2.table.core, e2 = y2.schema.primaryKey, v3 = e2.outbound, m3 = e2.extractKey, b2 = 200, e2 = n2.db._options.modifyChunkSize;
        e2 && (b2 = "object" == typeof e2 ? e2[y2.name] || e2["*"] || 200 : e2);
        function g2(e3, t3) {
          var n3 = t3.failures, t3 = t3.numFailures;
          c2 += e3 - t3;
          for (var r3 = 0, i2 = x(n3); r3 < i2.length; r3++) {
            var o2 = i2[r3];
            s2.push(n3[o2]);
          }
        }
        var s2 = [], c2 = 0, t2 = [];
        return n2.clone().primaryKeys().then(function(l2) {
          function f2(s3) {
            var c3 = Math.min(b2, l2.length - s3);
            return y2.getMany({ trans: d2, keys: l2.slice(s3, s3 + c3), cache: "immutable" }).then(function(e3) {
              for (var n3 = [], t3 = [], r3 = v3 ? [] : null, i2 = [], o2 = 0; o2 < c3; ++o2) {
                var a3 = e3[o2], u3 = { value: S(a3), primKey: l2[s3 + o2] };
                false !== p3.call(u3, u3.value, u3) && (null == u3.value ? i2.push(l2[s3 + o2]) : v3 || 0 === st(m3(a3), m3(u3.value)) ? (t3.push(u3.value), v3 && r3.push(l2[s3 + o2])) : (i2.push(l2[s3 + o2]), n3.push(u3.value)));
              }
              return Promise.resolve(0 < n3.length && y2.mutate({ trans: d2, type: "add", values: n3 }).then(function(e4) {
                for (var t4 in e4.failures) i2.splice(parseInt(t4), 1);
                g2(n3.length, e4);
              })).then(function() {
                return (0 < t3.length || h3 && "object" == typeof w2) && y2.mutate({ trans: d2, type: "put", keys: r3, values: t3, criteria: h3, changeSpec: "function" != typeof w2 && w2, isAdditionalChunk: 0 < s3 }).then(function(e4) {
                  return g2(t3.length, e4);
                });
              }).then(function() {
                return (0 < i2.length || h3 && w2 === Kt) && y2.mutate({ trans: d2, type: "delete", keys: i2, criteria: h3, isAdditionalChunk: 0 < s3 }).then(function(e4) {
                  return g2(i2.length, e4);
                });
              }).then(function() {
                return l2.length > s3 + c3 && f2(s3 + b2);
              });
            });
          }
          var h3 = yt(r2) && r2.limit === 1 / 0 && ("function" != typeof w2 || w2 === Kt) && { index: r2.index, range: r2.range };
          return f2(0).then(function() {
            if (0 < s2.length) throw new U("Error modifying one or more objects", s2, c2, t2);
            return l2.length;
          });
        });
      });
    }, Pt.prototype.delete = function() {
      var i2 = this._ctx, n2 = i2.range;
      return yt(i2) && (i2.isPrimKey || 3 === n2.type) ? this._write(function(e2) {
        var t2 = i2.table.core.schema.primaryKey, r2 = n2;
        return i2.table.core.count({ trans: e2, query: { index: t2, range: r2 } }).then(function(n3) {
          return i2.table.core.mutate({ trans: e2, type: "deleteRange", range: r2 }).then(function(e3) {
            var t3 = e3.failures;
            e3.lastResult, e3.results;
            e3 = e3.numFailures;
            if (e3) throw new U("Could not delete some values", Object.keys(t3).map(function(e4) {
              return t3[e4];
            }), n3 - e3);
            return n3 - e3;
          });
        });
      }) : this.modify(Kt);
    }, Pt);
    function Pt() {
    }
    var Kt = function(e2, t2) {
      return t2.value = null;
    };
    function Et(e2, t2) {
      return e2 < t2 ? -1 : e2 === t2 ? 0 : 1;
    }
    function St(e2, t2) {
      return t2 < e2 ? -1 : e2 === t2 ? 0 : 1;
    }
    function jt(e2, t2, n2) {
      e2 = e2 instanceof Dt ? new e2.Collection(e2) : e2;
      return e2._ctx.error = new (n2 || TypeError)(t2), e2;
    }
    function At(e2) {
      return new e2.Collection(e2, function() {
        return qt("");
      }).limit(0);
    }
    function Ct(e2, s2, n2, r2) {
      var i2, c2, l2, f2, h3, d2, p3, y2 = n2.length;
      if (!n2.every(function(e3) {
        return "string" == typeof e3;
      })) return jt(e2, Ze);
      function t2(e3) {
        i2 = "next" === e3 ? function(e4) {
          return e4.toUpperCase();
        } : function(e4) {
          return e4.toLowerCase();
        }, c2 = "next" === e3 ? function(e4) {
          return e4.toLowerCase();
        } : function(e4) {
          return e4.toUpperCase();
        }, l2 = "next" === e3 ? Et : St;
        var t3 = n2.map(function(e4) {
          return { lower: c2(e4), upper: i2(e4) };
        }).sort(function(e4, t4) {
          return l2(e4.lower, t4.lower);
        });
        f2 = t3.map(function(e4) {
          return e4.upper;
        }), h3 = t3.map(function(e4) {
          return e4.lower;
        }), p3 = "next" === (d2 = e3) ? "" : r2;
      }
      t2("next");
      e2 = new e2.Collection(e2, function() {
        return Tt(f2[0], h3[y2 - 1] + r2);
      });
      e2._ondirectionchange = function(e3) {
        t2(e3);
      };
      var v3 = 0;
      return e2._addAlgorithm(function(e3, t3, n3) {
        var r3 = e3.key;
        if ("string" != typeof r3) return false;
        var i3 = c2(r3);
        if (s2(i3, h3, v3)) return true;
        for (var o2 = null, a2 = v3; a2 < y2; ++a2) {
          var u2 = function(e4, t4, n4, r4, i4, o3) {
            for (var a3 = Math.min(e4.length, r4.length), u3 = -1, s3 = 0; s3 < a3; ++s3) {
              var c3 = t4[s3];
              if (c3 !== r4[s3]) return i4(e4[s3], n4[s3]) < 0 ? e4.substr(0, s3) + n4[s3] + n4.substr(s3 + 1) : i4(e4[s3], r4[s3]) < 0 ? e4.substr(0, s3) + r4[s3] + n4.substr(s3 + 1) : 0 <= u3 ? e4.substr(0, u3) + t4[u3] + n4.substr(u3 + 1) : null;
              i4(e4[s3], c3) < 0 && (u3 = s3);
            }
            return a3 < r4.length && "next" === o3 ? e4 + n4.substr(e4.length) : a3 < e4.length && "prev" === o3 ? e4.substr(0, n4.length) : u3 < 0 ? null : e4.substr(0, u3) + r4[u3] + n4.substr(u3 + 1);
          }(r3, i3, f2[a2], h3[a2], l2, d2);
          null === u2 && null === o2 ? v3 = a2 + 1 : (null === o2 || 0 < l2(o2, u2)) && (o2 = u2);
        }
        return t3(null !== o2 ? function() {
          e3.continue(o2 + p3);
        } : n3), false;
      }), e2;
    }
    function Tt(e2, t2, n2, r2) {
      return { type: 2, lower: e2, upper: t2, lowerOpen: n2, upperOpen: r2 };
    }
    function qt(e2) {
      return { type: 1, lower: e2, upper: e2 };
    }
    var Dt = (Object.defineProperty(It.prototype, "Collection", { get: function() {
      return this._ctx.table.db.Collection;
    }, enumerable: false, configurable: true }), It.prototype.between = function(e2, t2, n2, r2) {
      n2 = false !== n2, r2 = true === r2;
      try {
        return 0 < this._cmp(e2, t2) || 0 === this._cmp(e2, t2) && (n2 || r2) && (!n2 || !r2) ? At(this) : new this.Collection(this, function() {
          return Tt(e2, t2, !n2, !r2);
        });
      } catch (e3) {
        return jt(this, Je);
      }
    }, It.prototype.equals = function(e2) {
      return null == e2 ? jt(this, Je) : new this.Collection(this, function() {
        return qt(e2);
      });
    }, It.prototype.above = function(e2) {
      return null == e2 ? jt(this, Je) : new this.Collection(this, function() {
        return Tt(e2, void 0, true);
      });
    }, It.prototype.aboveOrEqual = function(e2) {
      return null == e2 ? jt(this, Je) : new this.Collection(this, function() {
        return Tt(e2, void 0, false);
      });
    }, It.prototype.below = function(e2) {
      return null == e2 ? jt(this, Je) : new this.Collection(this, function() {
        return Tt(void 0, e2, false, true);
      });
    }, It.prototype.belowOrEqual = function(e2) {
      return null == e2 ? jt(this, Je) : new this.Collection(this, function() {
        return Tt(void 0, e2);
      });
    }, It.prototype.startsWith = function(e2) {
      return "string" != typeof e2 ? jt(this, Ze) : this.between(e2, e2 + He, true, true);
    }, It.prototype.startsWithIgnoreCase = function(e2) {
      return "" === e2 ? this.startsWith(e2) : Ct(this, function(e3, t2) {
        return 0 === e3.indexOf(t2[0]);
      }, [e2], He);
    }, It.prototype.equalsIgnoreCase = function(e2) {
      return Ct(this, function(e3, t2) {
        return e3 === t2[0];
      }, [e2], "");
    }, It.prototype.anyOfIgnoreCase = function() {
      var e2 = I.apply(D, arguments);
      return 0 === e2.length ? At(this) : Ct(this, function(e3, t2) {
        return -1 !== t2.indexOf(e3);
      }, e2, "");
    }, It.prototype.startsWithAnyOfIgnoreCase = function() {
      var e2 = I.apply(D, arguments);
      return 0 === e2.length ? At(this) : Ct(this, function(t2, e3) {
        return e3.some(function(e4) {
          return 0 === t2.indexOf(e4);
        });
      }, e2, He);
    }, It.prototype.anyOf = function() {
      var t2 = this, i2 = I.apply(D, arguments), o2 = this._cmp;
      try {
        i2.sort(o2);
      } catch (e3) {
        return jt(this, Je);
      }
      if (0 === i2.length) return At(this);
      var e2 = new this.Collection(this, function() {
        return Tt(i2[0], i2[i2.length - 1]);
      });
      e2._ondirectionchange = function(e3) {
        o2 = "next" === e3 ? t2._ascending : t2._descending, i2.sort(o2);
      };
      var a2 = 0;
      return e2._addAlgorithm(function(e3, t3, n2) {
        for (var r2 = e3.key; 0 < o2(r2, i2[a2]); ) if (++a2 === i2.length) return t3(n2), false;
        return 0 === o2(r2, i2[a2]) || (t3(function() {
          e3.continue(i2[a2]);
        }), false);
      }), e2;
    }, It.prototype.notEqual = function(e2) {
      return this.inAnyRange([[-1 / 0, e2], [e2, this.db._maxKey]], { includeLowers: false, includeUppers: false });
    }, It.prototype.noneOf = function() {
      var e2 = I.apply(D, arguments);
      if (0 === e2.length) return new this.Collection(this);
      try {
        e2.sort(this._ascending);
      } catch (e3) {
        return jt(this, Je);
      }
      var t2 = e2.reduce(function(e3, t3) {
        return e3 ? e3.concat([[e3[e3.length - 1][1], t3]]) : [[-1 / 0, t3]];
      }, null);
      return t2.push([e2[e2.length - 1], this.db._maxKey]), this.inAnyRange(t2, { includeLowers: false, includeUppers: false });
    }, It.prototype.inAnyRange = function(e2, t2) {
      var o2 = this, a2 = this._cmp, u2 = this._ascending, n2 = this._descending, s2 = this._min, c2 = this._max;
      if (0 === e2.length) return At(this);
      if (!e2.every(function(e3) {
        return void 0 !== e3[0] && void 0 !== e3[1] && u2(e3[0], e3[1]) <= 0;
      })) return jt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Y.InvalidArgument);
      var r2 = !t2 || false !== t2.includeLowers, i2 = t2 && true === t2.includeUppers;
      var l2, f2 = u2;
      function h3(e3, t3) {
        return f2(e3[0], t3[0]);
      }
      try {
        (l2 = e2.reduce(function(e3, t3) {
          for (var n3 = 0, r3 = e3.length; n3 < r3; ++n3) {
            var i3 = e3[n3];
            if (a2(t3[0], i3[1]) < 0 && 0 < a2(t3[1], i3[0])) {
              i3[0] = s2(i3[0], t3[0]), i3[1] = c2(i3[1], t3[1]);
              break;
            }
          }
          return n3 === r3 && e3.push(t3), e3;
        }, [])).sort(h3);
      } catch (e3) {
        return jt(this, Je);
      }
      var d2 = 0, p3 = i2 ? function(e3) {
        return 0 < u2(e3, l2[d2][1]);
      } : function(e3) {
        return 0 <= u2(e3, l2[d2][1]);
      }, y2 = r2 ? function(e3) {
        return 0 < n2(e3, l2[d2][0]);
      } : function(e3) {
        return 0 <= n2(e3, l2[d2][0]);
      };
      var v3 = p3, e2 = new this.Collection(this, function() {
        return Tt(l2[0][0], l2[l2.length - 1][1], !r2, !i2);
      });
      return e2._ondirectionchange = function(e3) {
        f2 = "next" === e3 ? (v3 = p3, u2) : (v3 = y2, n2), l2.sort(h3);
      }, e2._addAlgorithm(function(e3, t3, n3) {
        for (var r3, i3 = e3.key; v3(i3); ) if (++d2 === l2.length) return t3(n3), false;
        return !p3(r3 = i3) && !y2(r3) || (0 === o2._cmp(i3, l2[d2][1]) || 0 === o2._cmp(i3, l2[d2][0]) || t3(function() {
          f2 === u2 ? e3.continue(l2[d2][0]) : e3.continue(l2[d2][1]);
        }), false);
      }), e2;
    }, It.prototype.startsWithAnyOf = function() {
      var e2 = I.apply(D, arguments);
      return e2.every(function(e3) {
        return "string" == typeof e3;
      }) ? 0 === e2.length ? At(this) : this.inAnyRange(e2.map(function(e3) {
        return [e3, e3 + He];
      })) : jt(this, "startsWithAnyOf() only works with strings");
    }, It);
    function It() {
    }
    function Bt(t2) {
      return qe(function(e2) {
        return Rt(e2), t2(e2.target.error), false;
      });
    }
    function Rt(e2) {
      e2.stopPropagation && e2.stopPropagation(), e2.preventDefault && e2.preventDefault();
    }
    var Mt = "storagemutated", Ft = "x-storagemutated-1", Nt = dt(null, Mt), Lt = (Ut.prototype._lock = function() {
      return y(!me.global), ++this._reculock, 1 !== this._reculock || me.global || (me.lockOwnerFor = this), this;
    }, Ut.prototype._unlock = function() {
      if (y(!me.global), 0 == --this._reculock) for (me.global || (me.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
        var e2 = this._blockedFuncs.shift();
        try {
          $e(e2[1], e2[0]);
        } catch (e3) {
        }
      }
      return this;
    }, Ut.prototype._locked = function() {
      return this._reculock && me.lockOwnerFor !== this;
    }, Ut.prototype.create = function(t2) {
      var n2 = this;
      if (!this.mode) return this;
      var e2 = this.db.idbdb, r2 = this.db._state.dbOpenError;
      if (y(!this.idbtrans), !t2 && !e2) switch (r2 && r2.name) {
        case "DatabaseClosedError":
          throw new Y.DatabaseClosed(r2);
        case "MissingAPIError":
          throw new Y.MissingAPI(r2.message, r2);
        default:
          throw new Y.OpenFailed(r2);
      }
      if (!this.active) throw new Y.TransactionInactive();
      return y(null === this._completion._state), (t2 = this.idbtrans = t2 || (this.db.core || e2).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = qe(function(e3) {
        Rt(e3), n2._reject(t2.error);
      }), t2.onabort = qe(function(e3) {
        Rt(e3), n2.active && n2._reject(new Y.Abort(t2.error)), n2.active = false, n2.on("abort").fire(e3);
      }), t2.oncomplete = qe(function() {
        n2.active = false, n2._resolve(), "mutatedParts" in t2 && Nt.storagemutated.fire(t2.mutatedParts);
      }), this;
    }, Ut.prototype._promise = function(n2, r2, i2) {
      var o2 = this;
      if ("readwrite" === n2 && "readwrite" !== this.mode) return Xe(new Y.ReadOnly("Transaction is readonly"));
      if (!this.active) return Xe(new Y.TransactionInactive());
      if (this._locked()) return new _e(function(e3, t2) {
        o2._blockedFuncs.push([function() {
          o2._promise(n2, r2, i2).then(e3, t2);
        }, me]);
      });
      if (i2) return Ne(function() {
        var e3 = new _e(function(e4, t2) {
          o2._lock();
          var n3 = r2(e4, t2, o2);
          n3 && n3.then && n3.then(e4, t2);
        });
        return e3.finally(function() {
          return o2._unlock();
        }), e3._lib = true, e3;
      });
      var e2 = new _e(function(e3, t2) {
        var n3 = r2(e3, t2, o2);
        n3 && n3.then && n3.then(e3, t2);
      });
      return e2._lib = true, e2;
    }, Ut.prototype._root = function() {
      return this.parent ? this.parent._root() : this;
    }, Ut.prototype.waitFor = function(e2) {
      var t2, r2 = this._root(), i2 = _e.resolve(e2);
      r2._waitingFor ? r2._waitingFor = r2._waitingFor.then(function() {
        return i2;
      }) : (r2._waitingFor = i2, r2._waitingQueue = [], t2 = r2.idbtrans.objectStore(r2.storeNames[0]), function e3() {
        for (++r2._spinCount; r2._waitingQueue.length; ) r2._waitingQueue.shift()();
        r2._waitingFor && (t2.get(-1 / 0).onsuccess = e3);
      }());
      var o2 = r2._waitingFor;
      return new _e(function(t3, n2) {
        i2.then(function(e3) {
          return r2._waitingQueue.push(qe(t3.bind(null, e3)));
        }, function(e3) {
          return r2._waitingQueue.push(qe(n2.bind(null, e3)));
        }).finally(function() {
          r2._waitingFor === o2 && (r2._waitingFor = null);
        });
      });
    }, Ut.prototype.abort = function() {
      this.active && (this.active = false, this.idbtrans && this.idbtrans.abort(), this._reject(new Y.Abort()));
    }, Ut.prototype.table = function(e2) {
      var t2 = this._memoizedTables || (this._memoizedTables = {});
      if (m2(t2, e2)) return t2[e2];
      var n2 = this.schema[e2];
      if (!n2) throw new Y.NotFound("Table " + e2 + " not part of transaction");
      n2 = new this.db.Table(e2, n2, this);
      return n2.core = this.db.core.table(e2), t2[e2] = n2;
    }, Ut);
    function Ut() {
    }
    function Vt(e2, t2, n2, r2, i2, o2, a2) {
      return { name: e2, keyPath: t2, unique: n2, multi: r2, auto: i2, compound: o2, src: (n2 && !a2 ? "&" : "") + (r2 ? "*" : "") + (i2 ? "++" : "") + zt(t2) };
    }
    function zt(e2) {
      return "string" == typeof e2 ? e2 : e2 ? "[" + [].join.call(e2, "+") + "]" : "";
    }
    function Wt(e2, t2, n2) {
      return { name: e2, primKey: t2, indexes: n2, mappedClass: null, idxByName: (r2 = function(e3) {
        return [e3.name, e3];
      }, n2.reduce(function(e3, t3, n3) {
        n3 = r2(t3, n3);
        return n3 && (e3[n3[0]] = n3[1]), e3;
      }, {})) };
      var r2;
    }
    var Yt = function(e2) {
      try {
        return e2.only([[]]), Yt = function() {
          return [[]];
        }, [[]];
      } catch (e3) {
        return Yt = function() {
          return He;
        }, He;
      }
    };
    function $t(t2) {
      return null == t2 ? function() {
      } : "string" == typeof t2 ? 1 === (n2 = t2).split(".").length ? function(e2) {
        return e2[n2];
      } : function(e2) {
        return O(e2, n2);
      } : function(e2) {
        return O(e2, t2);
      };
      var n2;
    }
    function Qt(e2) {
      return [].slice.call(e2);
    }
    var Gt = 0;
    function Xt(e2) {
      return null == e2 ? ":id" : "string" == typeof e2 ? e2 : "[".concat(e2.join("+"), "]");
    }
    function Ht(e2, i2, t2) {
      function _2(e3) {
        if (3 === e3.type) return null;
        if (4 === e3.type) throw new Error("Cannot convert never type to IDBKeyRange");
        var t3 = e3.lower, n3 = e3.upper, r3 = e3.lowerOpen, e3 = e3.upperOpen;
        return void 0 === t3 ? void 0 === n3 ? null : i2.upperBound(n3, !!e3) : void 0 === n3 ? i2.lowerBound(t3, !!r3) : i2.bound(t3, n3, !!r3, !!e3);
      }
      function n2(e3) {
        var h3, w2 = e3.name;
        return { name: w2, schema: e3, mutate: function(e4) {
          var y2 = e4.trans, v3 = e4.type, m3 = e4.keys, b2 = e4.values, g2 = e4.range;
          return new Promise(function(t3, e5) {
            t3 = qe(t3);
            var n3 = y2.objectStore(w2), r3 = null == n3.keyPath, i3 = "put" === v3 || "add" === v3;
            if (!i3 && "delete" !== v3 && "deleteRange" !== v3) throw new Error("Invalid operation type: " + v3);
            var o3, a3 = (m3 || b2 || { length: 1 }).length;
            if (m3 && b2 && m3.length !== b2.length) throw new Error("Given keys array must have same length as given values array.");
            if (0 === a3) return t3({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
            function u3(e6) {
              ++l2, Rt(e6);
            }
            var s3 = [], c3 = [], l2 = 0;
            if ("deleteRange" === v3) {
              if (4 === g2.type) return t3({ numFailures: l2, failures: c3, results: [], lastResult: void 0 });
              3 === g2.type ? s3.push(o3 = n3.clear()) : s3.push(o3 = n3.delete(_2(g2)));
            } else {
              var r3 = i3 ? r3 ? [b2, m3] : [b2, null] : [m3, null], f2 = r3[0], h4 = r3[1];
              if (i3) for (var d2 = 0; d2 < a3; ++d2) s3.push(o3 = h4 && void 0 !== h4[d2] ? n3[v3](f2[d2], h4[d2]) : n3[v3](f2[d2])), o3.onerror = u3;
              else for (d2 = 0; d2 < a3; ++d2) s3.push(o3 = n3[v3](f2[d2])), o3.onerror = u3;
            }
            function p3(e6) {
              e6 = e6.target.result, s3.forEach(function(e7, t4) {
                return null != e7.error && (c3[t4] = e7.error);
              }), t3({ numFailures: l2, failures: c3, results: "delete" === v3 ? m3 : s3.map(function(e7) {
                return e7.result;
              }), lastResult: e6 });
            }
            o3.onerror = function(e6) {
              u3(e6), p3(e6);
            }, o3.onsuccess = p3;
          });
        }, getMany: function(e4) {
          var f2 = e4.trans, h4 = e4.keys;
          return new Promise(function(t3, e5) {
            t3 = qe(t3);
            for (var n3, r3 = f2.objectStore(w2), i3 = h4.length, o3 = new Array(i3), a3 = 0, u3 = 0, s3 = function(e6) {
              e6 = e6.target;
              o3[e6._pos] = e6.result, ++u3 === a3 && t3(o3);
            }, c3 = Bt(e5), l2 = 0; l2 < i3; ++l2) null != h4[l2] && ((n3 = r3.get(h4[l2]))._pos = l2, n3.onsuccess = s3, n3.onerror = c3, ++a3);
            0 === a3 && t3(o3);
          });
        }, get: function(e4) {
          var r3 = e4.trans, i3 = e4.key;
          return new Promise(function(t3, e5) {
            t3 = qe(t3);
            var n3 = r3.objectStore(w2).get(i3);
            n3.onsuccess = function(e6) {
              return t3(e6.target.result);
            }, n3.onerror = Bt(e5);
          });
        }, query: (h3 = s2, function(f2) {
          return new Promise(function(n3, e4) {
            n3 = qe(n3);
            var r3, i3, o3, t3 = f2.trans, a3 = f2.values, u3 = f2.limit, s3 = f2.query, c3 = u3 === 1 / 0 ? void 0 : u3, l2 = s3.index, s3 = s3.range, t3 = t3.objectStore(w2), l2 = l2.isPrimaryKey ? t3 : t3.index(l2.name), s3 = _2(s3);
            if (0 === u3) return n3({ result: [] });
            h3 ? ((c3 = a3 ? l2.getAll(s3, c3) : l2.getAllKeys(s3, c3)).onsuccess = function(e5) {
              return n3({ result: e5.target.result });
            }, c3.onerror = Bt(e4)) : (r3 = 0, i3 = !a3 && "openKeyCursor" in l2 ? l2.openKeyCursor(s3) : l2.openCursor(s3), o3 = [], i3.onsuccess = function(e5) {
              var t4 = i3.result;
              return t4 ? (o3.push(a3 ? t4.value : t4.primaryKey), ++r3 === u3 ? n3({ result: o3 }) : void t4.continue()) : n3({ result: o3 });
            }, i3.onerror = Bt(e4));
          });
        }), openCursor: function(e4) {
          var c3 = e4.trans, o3 = e4.values, a3 = e4.query, u3 = e4.reverse, l2 = e4.unique;
          return new Promise(function(t3, n3) {
            t3 = qe(t3);
            var e5 = a3.index, r3 = a3.range, i3 = c3.objectStore(w2), i3 = e5.isPrimaryKey ? i3 : i3.index(e5.name), e5 = u3 ? l2 ? "prevunique" : "prev" : l2 ? "nextunique" : "next", s3 = !o3 && "openKeyCursor" in i3 ? i3.openKeyCursor(_2(r3), e5) : i3.openCursor(_2(r3), e5);
            s3.onerror = Bt(n3), s3.onsuccess = qe(function(e6) {
              var r4, i4, o4, a4, u4 = s3.result;
              u4 ? (u4.___id = ++Gt, u4.done = false, r4 = u4.continue.bind(u4), i4 = (i4 = u4.continuePrimaryKey) && i4.bind(u4), o4 = u4.advance.bind(u4), a4 = function() {
                throw new Error("Cursor not stopped");
              }, u4.trans = c3, u4.stop = u4.continue = u4.continuePrimaryKey = u4.advance = function() {
                throw new Error("Cursor not started");
              }, u4.fail = qe(n3), u4.next = function() {
                var e7 = this, t4 = 1;
                return this.start(function() {
                  return t4-- ? e7.continue() : e7.stop();
                }).then(function() {
                  return e7;
                });
              }, u4.start = function(e7) {
                function t4() {
                  if (s3.result) try {
                    e7();
                  } catch (e8) {
                    u4.fail(e8);
                  }
                  else u4.done = true, u4.start = function() {
                    throw new Error("Cursor behind last entry");
                  }, u4.stop();
                }
                var n4 = new Promise(function(t5, e8) {
                  t5 = qe(t5), s3.onerror = Bt(e8), u4.fail = e8, u4.stop = function(e9) {
                    u4.stop = u4.continue = u4.continuePrimaryKey = u4.advance = a4, t5(e9);
                  };
                });
                return s3.onsuccess = qe(function(e8) {
                  s3.onsuccess = t4, t4();
                }), u4.continue = r4, u4.continuePrimaryKey = i4, u4.advance = o4, t4(), n4;
              }, t3(u4)) : t3(null);
            }, n3);
          });
        }, count: function(e4) {
          var t3 = e4.query, i3 = e4.trans, o3 = t3.index, a3 = t3.range;
          return new Promise(function(t4, e5) {
            var n3 = i3.objectStore(w2), r3 = o3.isPrimaryKey ? n3 : n3.index(o3.name), n3 = _2(a3), r3 = n3 ? r3.count(n3) : r3.count();
            r3.onsuccess = qe(function(e6) {
              return t4(e6.target.result);
            }), r3.onerror = Bt(e5);
          });
        } };
      }
      var r2, o2, a2, u2 = (o2 = t2, a2 = Qt((r2 = e2).objectStoreNames), { schema: { name: r2.name, tables: a2.map(function(e3) {
        return o2.objectStore(e3);
      }).map(function(t3) {
        var e3 = t3.keyPath, n3 = t3.autoIncrement, r3 = k(e3), i3 = {}, n3 = { name: t3.name, primaryKey: { name: null, isPrimaryKey: true, outbound: null == e3, compound: r3, keyPath: e3, autoIncrement: n3, unique: true, extractKey: $t(e3) }, indexes: Qt(t3.indexNames).map(function(e4) {
          return t3.index(e4);
        }).map(function(e4) {
          var t4 = e4.name, n4 = e4.unique, r4 = e4.multiEntry, e4 = e4.keyPath, r4 = { name: t4, compound: k(e4), keyPath: e4, unique: n4, multiEntry: r4, extractKey: $t(e4) };
          return i3[Xt(e4)] = r4;
        }), getIndexByKeyPath: function(e4) {
          return i3[Xt(e4)];
        } };
        return i3[":id"] = n3.primaryKey, null != e3 && (i3[Xt(e3)] = n3.primaryKey), n3;
      }) }, hasGetAll: 0 < a2.length && "getAll" in o2.objectStore(a2[0]) && !("undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), t2 = u2.schema, s2 = u2.hasGetAll, u2 = t2.tables.map(n2), c2 = {};
      return u2.forEach(function(e3) {
        return c2[e3.name] = e3;
      }), { stack: "dbcore", transaction: e2.transaction.bind(e2), table: function(e3) {
        if (!c2[e3]) throw new Error("Table '".concat(e3, "' not found"));
        return c2[e3];
      }, MIN_KEY: -1 / 0, MAX_KEY: Yt(i2), schema: t2 };
    }
    function Jt(e2, t2, n2, r2) {
      var i2 = n2.IDBKeyRange;
      return n2.indexedDB, { dbcore: (r2 = Ht(t2, i2, r2), e2.dbcore.reduce(function(e3, t3) {
        t3 = t3.create;
        return _(_({}, e3), t3(e3));
      }, r2)) };
    }
    function Zt(n2, e2) {
      var t2 = e2.db, e2 = Jt(n2._middlewares, t2, n2._deps, e2);
      n2.core = e2.dbcore, n2.tables.forEach(function(e3) {
        var t3 = e3.name;
        n2.core.schema.tables.some(function(e4) {
          return e4.name === t3;
        }) && (e3.core = n2.core.table(t3), n2[t3] instanceof n2.Table && (n2[t3].core = e3.core));
      });
    }
    function en(i2, e2, t2, o2) {
      t2.forEach(function(n2) {
        var r2 = o2[n2];
        e2.forEach(function(e3) {
          var t3 = function e4(t4, n3) {
            return h2(t4, n3) || (t4 = c(t4)) && e4(t4, n3);
          }(e3, n2);
          (!t3 || "value" in t3 && void 0 === t3.value) && (e3 === i2.Transaction.prototype || e3 instanceof i2.Transaction ? l(e3, n2, { get: function() {
            return this.table(n2);
          }, set: function(e4) {
            u(this, n2, { value: e4, writable: true, configurable: true, enumerable: true });
          } }) : e3[n2] = new i2.Table(n2, r2));
        });
      });
    }
    function tn(n2, e2) {
      e2.forEach(function(e3) {
        for (var t2 in e3) e3[t2] instanceof n2.Table && delete e3[t2];
      });
    }
    function nn(e2, t2) {
      return e2._cfg.version - t2._cfg.version;
    }
    function rn(n2, r2, i2, e2) {
      var o2 = n2._dbSchema;
      i2.objectStoreNames.contains("$meta") && !o2.$meta && (o2.$meta = Wt("$meta", hn("")[0], []), n2._storeNames.push("$meta"));
      var a2 = n2._createTransaction("readwrite", n2._storeNames, o2);
      a2.create(i2), a2._completion.catch(e2);
      var u2 = a2._reject.bind(a2), s2 = me.transless || me;
      Ne(function() {
        return me.trans = a2, me.transless = s2, 0 !== r2 ? (Zt(n2, i2), t2 = r2, ((e3 = a2).storeNames.includes("$meta") ? e3.table("$meta").get("version").then(function(e4) {
          return null != e4 ? e4 : t2;
        }) : _e.resolve(t2)).then(function(e4) {
          return c2 = e4, l2 = a2, f2 = i2, t3 = [], e4 = (s3 = n2)._versions, h3 = s3._dbSchema = ln(0, s3.idbdb, f2), 0 !== (e4 = e4.filter(function(e5) {
            return e5._cfg.version >= c2;
          })).length ? (e4.forEach(function(u3) {
            t3.push(function() {
              var t4 = h3, e5 = u3._cfg.dbschema;
              fn(s3, t4, f2), fn(s3, e5, f2), h3 = s3._dbSchema = e5;
              var n3 = an(t4, e5);
              n3.add.forEach(function(e6) {
                un(f2, e6[0], e6[1].primKey, e6[1].indexes);
              }), n3.change.forEach(function(e6) {
                if (e6.recreate) throw new Y.Upgrade("Not yet support for changing primary key");
                var t5 = f2.objectStore(e6.name);
                e6.add.forEach(function(e7) {
                  return cn(t5, e7);
                }), e6.change.forEach(function(e7) {
                  t5.deleteIndex(e7.name), cn(t5, e7);
                }), e6.del.forEach(function(e7) {
                  return t5.deleteIndex(e7);
                });
              });
              var r3 = u3._cfg.contentUpgrade;
              if (r3 && u3._cfg.version > c2) {
                Zt(s3, f2), l2._memoizedTables = {};
                var i3 = g(e5);
                n3.del.forEach(function(e6) {
                  i3[e6] = t4[e6];
                }), tn(s3, [s3.Transaction.prototype]), en(s3, [s3.Transaction.prototype], x(i3), i3), l2.schema = i3;
                var o3, a3 = B(r3);
                a3 && Le();
                n3 = _e.follow(function() {
                  var e6;
                  (o3 = r3(l2)) && a3 && (e6 = Ue.bind(null, null), o3.then(e6, e6));
                });
                return o3 && "function" == typeof o3.then ? _e.resolve(o3) : n3.then(function() {
                  return o3;
                });
              }
            }), t3.push(function(e5) {
              var t4, n3, r3 = u3._cfg.dbschema;
              t4 = r3, n3 = e5, [].slice.call(n3.db.objectStoreNames).forEach(function(e6) {
                return null == t4[e6] && n3.db.deleteObjectStore(e6);
              }), tn(s3, [s3.Transaction.prototype]), en(s3, [s3.Transaction.prototype], s3._storeNames, s3._dbSchema), l2.schema = s3._dbSchema;
            }), t3.push(function(e5) {
              s3.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(s3.idbdb.version / 10) === u3._cfg.version ? (s3.idbdb.deleteObjectStore("$meta"), delete s3._dbSchema.$meta, s3._storeNames = s3._storeNames.filter(function(e6) {
                return "$meta" !== e6;
              })) : e5.objectStore("$meta").put(u3._cfg.version, "version"));
            });
          }), function e5() {
            return t3.length ? _e.resolve(t3.shift()(l2.idbtrans)).then(e5) : _e.resolve();
          }().then(function() {
            sn(h3, f2);
          })) : _e.resolve();
          var s3, c2, l2, f2, t3, h3;
        }).catch(u2)) : (x(o2).forEach(function(e4) {
          un(i2, e4, o2[e4].primKey, o2[e4].indexes);
        }), Zt(n2, i2), void _e.follow(function() {
          return n2.on.populate.fire(a2);
        }).catch(u2));
        var e3, t2;
      });
    }
    function on(e2, r2) {
      sn(e2._dbSchema, r2), r2.db.version % 10 != 0 || r2.objectStoreNames.contains("$meta") || r2.db.createObjectStore("$meta").add(Math.ceil(r2.db.version / 10 - 1), "version");
      var t2 = ln(0, e2.idbdb, r2);
      fn(e2, e2._dbSchema, r2);
      for (var n2 = 0, i2 = an(t2, e2._dbSchema).change; n2 < i2.length; n2++) {
        var o2 = function(t3) {
          if (t3.change.length || t3.recreate) return console.warn("Unable to patch indexes of table ".concat(t3.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
          var n3 = r2.objectStore(t3.name);
          t3.add.forEach(function(e3) {
            ie && console.debug("Dexie upgrade patch: Creating missing index ".concat(t3.name, ".").concat(e3.src)), cn(n3, e3);
          });
        }(i2[n2]);
        if ("object" == typeof o2) return o2.value;
      }
    }
    function an(e2, t2) {
      var n2, r2 = { del: [], add: [], change: [] };
      for (n2 in e2) t2[n2] || r2.del.push(n2);
      for (n2 in t2) {
        var i2 = e2[n2], o2 = t2[n2];
        if (i2) {
          var a2 = { name: n2, def: o2, recreate: false, del: [], add: [], change: [] };
          if ("" + (i2.primKey.keyPath || "") != "" + (o2.primKey.keyPath || "") || i2.primKey.auto !== o2.primKey.auto) a2.recreate = true, r2.change.push(a2);
          else {
            var u2 = i2.idxByName, s2 = o2.idxByName, c2 = void 0;
            for (c2 in u2) s2[c2] || a2.del.push(c2);
            for (c2 in s2) {
              var l2 = u2[c2], f2 = s2[c2];
              l2 ? l2.src !== f2.src && a2.change.push(f2) : a2.add.push(f2);
            }
            (0 < a2.del.length || 0 < a2.add.length || 0 < a2.change.length) && r2.change.push(a2);
          }
        } else r2.add.push([n2, o2]);
      }
      return r2;
    }
    function un(e2, t2, n2, r2) {
      var i2 = e2.db.createObjectStore(t2, n2.keyPath ? { keyPath: n2.keyPath, autoIncrement: n2.auto } : { autoIncrement: n2.auto });
      return r2.forEach(function(e3) {
        return cn(i2, e3);
      }), i2;
    }
    function sn(t2, n2) {
      x(t2).forEach(function(e2) {
        n2.db.objectStoreNames.contains(e2) || (ie && console.debug("Dexie: Creating missing table", e2), un(n2, e2, t2[e2].primKey, t2[e2].indexes));
      });
    }
    function cn(e2, t2) {
      e2.createIndex(t2.name, t2.keyPath, { unique: t2.unique, multiEntry: t2.multi });
    }
    function ln(e2, t2, u2) {
      var s2 = {};
      return b(t2.objectStoreNames, 0).forEach(function(e3) {
        for (var t3 = u2.objectStore(e3), n2 = Vt(zt(a2 = t3.keyPath), a2 || "", true, false, !!t3.autoIncrement, a2 && "string" != typeof a2, true), r2 = [], i2 = 0; i2 < t3.indexNames.length; ++i2) {
          var o2 = t3.index(t3.indexNames[i2]), a2 = o2.keyPath, o2 = Vt(o2.name, a2, !!o2.unique, !!o2.multiEntry, false, a2 && "string" != typeof a2, false);
          r2.push(o2);
        }
        s2[e3] = Wt(e3, n2, r2);
      }), s2;
    }
    function fn(e2, t2, n2) {
      for (var r2 = n2.db.objectStoreNames, i2 = 0; i2 < r2.length; ++i2) {
        var o2 = r2[i2], a2 = n2.objectStore(o2);
        e2._hasGetAll = "getAll" in a2;
        for (var u2 = 0; u2 < a2.indexNames.length; ++u2) {
          var s2 = a2.indexNames[u2], c2 = a2.index(s2).keyPath, l2 = "string" == typeof c2 ? c2 : "[" + b(c2).join("+") + "]";
          !t2[o2] || (c2 = t2[o2].idxByName[l2]) && (c2.name = s2, delete t2[o2].idxByName[l2], t2[o2].idxByName[s2] = c2);
        }
      }
      "undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f.WorkerGlobalScope && f instanceof f.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e2._hasGetAll = false);
    }
    function hn(e2) {
      return e2.split(",").map(function(e3, t2) {
        var n2 = (e3 = e3.trim()).replace(/([&*]|\+\+)/g, ""), r2 = /^\[/.test(n2) ? n2.match(/^\[(.*)\]$/)[1].split("+") : n2;
        return Vt(n2, r2 || null, /\&/.test(e3), /\*/.test(e3), /\+\+/.test(e3), k(r2), 0 === t2);
      });
    }
    var dn = (pn.prototype._parseStoresSpec = function(r2, i2) {
      x(r2).forEach(function(e2) {
        if (null !== r2[e2]) {
          var t2 = hn(r2[e2]), n2 = t2.shift();
          if (n2.unique = true, n2.multi) throw new Y.Schema("Primary key cannot be multi-valued");
          t2.forEach(function(e3) {
            if (e3.auto) throw new Y.Schema("Only primary key can be marked as autoIncrement (++)");
            if (!e3.keyPath) throw new Y.Schema("Index must have a name and cannot be an empty string");
          }), i2[e2] = Wt(e2, n2, t2);
        }
      });
    }, pn.prototype.stores = function(e2) {
      var t2 = this.db;
      this._cfg.storesSource = this._cfg.storesSource ? a(this._cfg.storesSource, e2) : e2;
      var e2 = t2._versions, n2 = {}, r2 = {};
      return e2.forEach(function(e3) {
        a(n2, e3._cfg.storesSource), r2 = e3._cfg.dbschema = {}, e3._parseStoresSpec(n2, r2);
      }), t2._dbSchema = r2, tn(t2, [t2._allTables, t2, t2.Transaction.prototype]), en(t2, [t2._allTables, t2, t2.Transaction.prototype, this._cfg.tables], x(r2), r2), t2._storeNames = x(r2), this;
    }, pn.prototype.upgrade = function(e2) {
      return this._cfg.contentUpgrade = re(this._cfg.contentUpgrade || G, e2), this;
    }, pn);
    function pn() {
    }
    function yn(e2, t2) {
      var n2 = e2._dbNamesDB;
      return n2 || (n2 = e2._dbNamesDB = new er(tt2, { addons: [], indexedDB: e2, IDBKeyRange: t2 })).version(1).stores({ dbnames: "name" }), n2.table("dbnames");
    }
    function vn(e2) {
      return e2 && "function" == typeof e2.databases;
    }
    function mn(e2) {
      return Ne(function() {
        return me.letThrough = true, e2();
      });
    }
    function bn(e2) {
      return !("from" in e2);
    }
    var gn = function(e2, t2) {
      if (!this) {
        var n2 = new gn();
        return e2 && "d" in e2 && a(n2, e2), n2;
      }
      a(this, arguments.length ? { d: 1, from: e2, to: 1 < arguments.length ? t2 : e2 } : { d: 0 });
    };
    function wn(e2, t2, n2) {
      var r2 = st(t2, n2);
      if (!isNaN(r2)) {
        if (0 < r2) throw RangeError();
        if (bn(e2)) return a(e2, { from: t2, to: n2, d: 1 });
        var i2 = e2.l, r2 = e2.r;
        if (st(n2, e2.from) < 0) return i2 ? wn(i2, t2, n2) : e2.l = { from: t2, to: n2, d: 1, l: null, r: null }, On(e2);
        if (0 < st(t2, e2.to)) return r2 ? wn(r2, t2, n2) : e2.r = { from: t2, to: n2, d: 1, l: null, r: null }, On(e2);
        st(t2, e2.from) < 0 && (e2.from = t2, e2.l = null, e2.d = r2 ? r2.d + 1 : 1), 0 < st(n2, e2.to) && (e2.to = n2, e2.r = null, e2.d = e2.l ? e2.l.d + 1 : 1);
        n2 = !e2.r;
        i2 && !e2.l && _n(e2, i2), r2 && n2 && _n(e2, r2);
      }
    }
    function _n(e2, t2) {
      bn(t2) || function e3(t3, n2) {
        var r2 = n2.from, i2 = n2.to, o2 = n2.l, n2 = n2.r;
        wn(t3, r2, i2), o2 && e3(t3, o2), n2 && e3(t3, n2);
      }(e2, t2);
    }
    function xn(e2, t2) {
      var n2 = kn(t2), r2 = n2.next();
      if (r2.done) return false;
      for (var i2 = r2.value, o2 = kn(e2), a2 = o2.next(i2.from), u2 = a2.value; !r2.done && !a2.done; ) {
        if (st(u2.from, i2.to) <= 0 && 0 <= st(u2.to, i2.from)) return true;
        st(i2.from, u2.from) < 0 ? i2 = (r2 = n2.next(u2.from)).value : u2 = (a2 = o2.next(i2.from)).value;
      }
      return false;
    }
    function kn(e2) {
      var n2 = bn(e2) ? null : { s: 0, n: e2 };
      return { next: function(e3) {
        for (var t2 = 0 < arguments.length; n2; ) switch (n2.s) {
          case 0:
            if (n2.s = 1, t2) for (; n2.n.l && st(e3, n2.n.from) < 0; ) n2 = { up: n2, n: n2.n.l, s: 1 };
            else for (; n2.n.l; ) n2 = { up: n2, n: n2.n.l, s: 1 };
          case 1:
            if (n2.s = 2, !t2 || st(e3, n2.n.to) <= 0) return { value: n2.n, done: false };
          case 2:
            if (n2.n.r) {
              n2.s = 3, n2 = { up: n2, n: n2.n.r, s: 0 };
              continue;
            }
          case 3:
            n2 = n2.up;
        }
        return { done: true };
      } };
    }
    function On(e2) {
      var t2, n2, r2 = ((null === (t2 = e2.r) || void 0 === t2 ? void 0 : t2.d) || 0) - ((null === (n2 = e2.l) || void 0 === n2 ? void 0 : n2.d) || 0), i2 = 1 < r2 ? "r" : r2 < -1 ? "l" : "";
      i2 && (t2 = "r" == i2 ? "l" : "r", n2 = _({}, e2), r2 = e2[i2], e2.from = r2.from, e2.to = r2.to, e2[i2] = r2[i2], n2[i2] = r2[t2], (e2[t2] = n2).d = Pn(n2)), e2.d = Pn(e2);
    }
    function Pn(e2) {
      var t2 = e2.r, e2 = e2.l;
      return (t2 ? e2 ? Math.max(t2.d, e2.d) : t2.d : e2 ? e2.d : 0) + 1;
    }
    function Kn(t2, n2) {
      return x(n2).forEach(function(e2) {
        t2[e2] ? _n(t2[e2], n2[e2]) : t2[e2] = function e3(t3) {
          var n3, r2, i2 = {};
          for (n3 in t3) m2(t3, n3) && (r2 = t3[n3], i2[n3] = !r2 || "object" != typeof r2 || K.has(r2.constructor) ? r2 : e3(r2));
          return i2;
        }(n2[e2]);
      }), t2;
    }
    function En(t2, n2) {
      return t2.all || n2.all || Object.keys(t2).some(function(e2) {
        return n2[e2] && xn(n2[e2], t2[e2]);
      });
    }
    r(gn.prototype, ((M = { add: function(e2) {
      return _n(this, e2), this;
    }, addKey: function(e2) {
      return wn(this, e2, e2), this;
    }, addKeys: function(e2) {
      var t2 = this;
      return e2.forEach(function(e3) {
        return wn(t2, e3, e3);
      }), this;
    }, hasKey: function(e2) {
      var t2 = kn(this).next(e2).value;
      return t2 && st(t2.from, e2) <= 0 && 0 <= st(t2.to, e2);
    } })[C] = function() {
      return kn(this);
    }, M));
    var Sn = {}, jn = {}, An = false;
    function Cn(e2) {
      Kn(jn, e2), An || (An = true, setTimeout(function() {
        An = false, Tn(jn, !(jn = {}));
      }, 0));
    }
    function Tn(e2, t2) {
      void 0 === t2 && (t2 = false);
      var n2 = /* @__PURE__ */ new Set();
      if (e2.all) for (var r2 = 0, i2 = Object.values(Sn); r2 < i2.length; r2++) qn(a2 = i2[r2], e2, n2, t2);
      else for (var o2 in e2) {
        var a2, u2 = /^idb\:\/\/(.*)\/(.*)\//.exec(o2);
        u2 && (o2 = u2[1], u2 = u2[2], (a2 = Sn["idb://".concat(o2, "/").concat(u2)]) && qn(a2, e2, n2, t2));
      }
      n2.forEach(function(e3) {
        return e3();
      });
    }
    function qn(e2, t2, n2, r2) {
      for (var i2 = [], o2 = 0, a2 = Object.entries(e2.queries.query); o2 < a2.length; o2++) {
        for (var u2 = a2[o2], s2 = u2[0], c2 = [], l2 = 0, f2 = u2[1]; l2 < f2.length; l2++) {
          var h3 = f2[l2];
          En(t2, h3.obsSet) ? h3.subscribers.forEach(function(e3) {
            return n2.add(e3);
          }) : r2 && c2.push(h3);
        }
        r2 && i2.push([s2, c2]);
      }
      if (r2) for (var d2 = 0, p3 = i2; d2 < p3.length; d2++) {
        var y2 = p3[d2], s2 = y2[0], c2 = y2[1];
        e2.queries.query[s2] = c2;
      }
    }
    function Dn(f2) {
      var h3 = f2._state, r2 = f2._deps.indexedDB;
      if (h3.isBeingOpened || f2.idbdb) return h3.dbReadyPromise.then(function() {
        return h3.dbOpenError ? Xe(h3.dbOpenError) : f2;
      });
      h3.isBeingOpened = true, h3.dbOpenError = null, h3.openComplete = false;
      var t2 = h3.openCanceller, d2 = Math.round(10 * f2.verno), p3 = false;
      function e2() {
        if (h3.openCanceller !== t2) throw new Y.DatabaseClosed("db.open() was cancelled");
      }
      function y2() {
        return new _e(function(s2, n3) {
          if (e2(), !r2) throw new Y.MissingAPI();
          var c2 = f2.name, l2 = h3.autoSchema || !d2 ? r2.open(c2) : r2.open(c2, d2);
          if (!l2) throw new Y.MissingAPI();
          l2.onerror = Bt(n3), l2.onblocked = qe(f2._fireOnBlocked), l2.onupgradeneeded = qe(function(e3) {
            var t3;
            v3 = l2.transaction, h3.autoSchema && !f2._options.allowEmptyDB ? (l2.onerror = Rt, v3.abort(), l2.result.close(), (t3 = r2.deleteDatabase(c2)).onsuccess = t3.onerror = qe(function() {
              n3(new Y.NoSuchDatabase("Database ".concat(c2, " doesnt exist")));
            })) : (v3.onerror = Bt(n3), e3 = e3.oldVersion > Math.pow(2, 62) ? 0 : e3.oldVersion, m3 = e3 < 1, f2.idbdb = l2.result, p3 && on(f2, v3), rn(f2, e3 / 10, v3, n3));
          }, n3), l2.onsuccess = qe(function() {
            v3 = null;
            var e3, t3, n4, r3, i3, o2 = f2.idbdb = l2.result, a2 = b(o2.objectStoreNames);
            if (0 < a2.length) try {
              var u2 = o2.transaction(1 === (r3 = a2).length ? r3[0] : r3, "readonly");
              if (h3.autoSchema) t3 = o2, n4 = u2, (e3 = f2).verno = t3.version / 10, n4 = e3._dbSchema = ln(0, t3, n4), e3._storeNames = b(t3.objectStoreNames, 0), en(e3, [e3._allTables], x(n4), n4);
              else if (fn(f2, f2._dbSchema, u2), ((i3 = an(ln(0, (i3 = f2).idbdb, u2), i3._dbSchema)).add.length || i3.change.some(function(e4) {
                return e4.add.length || e4.change.length;
              })) && !p3) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), o2.close(), d2 = o2.version + 1, p3 = true, s2(y2());
              Zt(f2, u2);
            } catch (e4) {
            }
            et.push(f2), o2.onversionchange = qe(function(e4) {
              h3.vcFired = true, f2.on("versionchange").fire(e4);
            }), o2.onclose = qe(function(e4) {
              f2.on("close").fire(e4);
            }), m3 && (i3 = f2._deps, u2 = c2, o2 = i3.indexedDB, i3 = i3.IDBKeyRange, vn(o2) || u2 === tt2 || yn(o2, i3).put({ name: u2 }).catch(G)), s2();
          }, n3);
        }).catch(function(e3) {
          switch (null == e3 ? void 0 : e3.name) {
            case "UnknownError":
              if (0 < h3.PR1398_maxLoop) return h3.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), y2();
              break;
            case "VersionError":
              if (0 < d2) return d2 = 0, y2();
          }
          return _e.reject(e3);
        });
      }
      var n2, i2 = h3.dbReadyResolve, v3 = null, m3 = false;
      return _e.race([t2, ("undefined" == typeof navigator ? _e.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e3) {
        function t3() {
          return indexedDB.databases().finally(e3);
        }
        n2 = setInterval(t3, 100), t3();
      }).finally(function() {
        return clearInterval(n2);
      }) : Promise.resolve()).then(y2)]).then(function() {
        return e2(), h3.onReadyBeingFired = [], _e.resolve(mn(function() {
          return f2.on.ready.fire(f2.vip);
        })).then(function e3() {
          if (0 < h3.onReadyBeingFired.length) {
            var t3 = h3.onReadyBeingFired.reduce(re, G);
            return h3.onReadyBeingFired = [], _e.resolve(mn(function() {
              return t3(f2.vip);
            })).then(e3);
          }
        });
      }).finally(function() {
        h3.openCanceller === t2 && (h3.onReadyBeingFired = null, h3.isBeingOpened = false);
      }).catch(function(e3) {
        h3.dbOpenError = e3;
        try {
          v3 && v3.abort();
        } catch (e4) {
        }
        return t2 === h3.openCanceller && f2._close(), Xe(e3);
      }).finally(function() {
        h3.openComplete = true, i2();
      }).then(function() {
        var n3;
        return m3 && (n3 = {}, f2.tables.forEach(function(t3) {
          t3.schema.indexes.forEach(function(e3) {
            e3.name && (n3["idb://".concat(f2.name, "/").concat(t3.name, "/").concat(e3.name)] = new gn(-1 / 0, [[[]]]));
          }), n3["idb://".concat(f2.name, "/").concat(t3.name, "/")] = n3["idb://".concat(f2.name, "/").concat(t3.name, "/:dels")] = new gn(-1 / 0, [[[]]]);
        }), Nt(Mt).fire(n3), Tn(n3, true)), f2;
      });
    }
    function In(t2) {
      function e2(e3) {
        return t2.next(e3);
      }
      var r2 = n2(e2), i2 = n2(function(e3) {
        return t2.throw(e3);
      });
      function n2(n3) {
        return function(e3) {
          var t3 = n3(e3), e3 = t3.value;
          return t3.done ? e3 : e3 && "function" == typeof e3.then ? e3.then(r2, i2) : k(e3) ? Promise.all(e3).then(r2, i2) : r2(e3);
        };
      }
      return n2(e2)();
    }
    function Bn(e2, t2, n2) {
      for (var r2 = k(e2) ? e2.slice() : [e2], i2 = 0; i2 < n2; ++i2) r2.push(t2);
      return r2;
    }
    var Rn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(f2) {
      return _(_({}, f2), { table: function(e2) {
        var a2 = f2.table(e2), t2 = a2.schema, u2 = {}, s2 = [];
        function c2(e3, t3, n3) {
          var r3 = Xt(e3), i3 = u2[r3] = u2[r3] || [], o2 = null == e3 ? 0 : "string" == typeof e3 ? 1 : e3.length, a3 = 0 < t3, a3 = _(_({}, n3), { name: a3 ? "".concat(r3, "(virtual-from:").concat(n3.name, ")") : n3.name, lowLevelIndex: n3, isVirtual: a3, keyTail: t3, keyLength: o2, extractKey: $t(e3), unique: !a3 && n3.unique });
          return i3.push(a3), a3.isPrimaryKey || s2.push(a3), 1 < o2 && c2(2 === o2 ? e3[0] : e3.slice(0, o2 - 1), t3 + 1, n3), i3.sort(function(e4, t4) {
            return e4.keyTail - t4.keyTail;
          }), a3;
        }
        e2 = c2(t2.primaryKey.keyPath, 0, t2.primaryKey);
        u2[":id"] = [e2];
        for (var n2 = 0, r2 = t2.indexes; n2 < r2.length; n2++) {
          var i2 = r2[n2];
          c2(i2.keyPath, 0, i2);
        }
        function l2(e3) {
          var t3, n3 = e3.query.index;
          return n3.isVirtual ? _(_({}, e3), { query: { index: n3.lowLevelIndex, range: (t3 = e3.query.range, n3 = n3.keyTail, { type: 1 === t3.type ? 2 : t3.type, lower: Bn(t3.lower, t3.lowerOpen ? f2.MAX_KEY : f2.MIN_KEY, n3), lowerOpen: true, upper: Bn(t3.upper, t3.upperOpen ? f2.MIN_KEY : f2.MAX_KEY, n3), upperOpen: true }) } }) : e3;
        }
        return _(_({}, a2), { schema: _(_({}, t2), { primaryKey: e2, indexes: s2, getIndexByKeyPath: function(e3) {
          return (e3 = u2[Xt(e3)]) && e3[0];
        } }), count: function(e3) {
          return a2.count(l2(e3));
        }, query: function(e3) {
          return a2.query(l2(e3));
        }, openCursor: function(t3) {
          var e3 = t3.query.index, r3 = e3.keyTail, n3 = e3.isVirtual, i3 = e3.keyLength;
          return n3 ? a2.openCursor(l2(t3)).then(function(e4) {
            return e4 && o2(e4);
          }) : a2.openCursor(t3);
          function o2(n4) {
            return Object.create(n4, { continue: { value: function(e4) {
              null != e4 ? n4.continue(Bn(e4, t3.reverse ? f2.MAX_KEY : f2.MIN_KEY, r3)) : t3.unique ? n4.continue(n4.key.slice(0, i3).concat(t3.reverse ? f2.MIN_KEY : f2.MAX_KEY, r3)) : n4.continue();
            } }, continuePrimaryKey: { value: function(e4, t4) {
              n4.continuePrimaryKey(Bn(e4, f2.MAX_KEY, r3), t4);
            } }, primaryKey: { get: function() {
              return n4.primaryKey;
            } }, key: { get: function() {
              var e4 = n4.key;
              return 1 === i3 ? e4[0] : e4.slice(0, i3);
            } }, value: { get: function() {
              return n4.value;
            } } });
          }
        } });
      } });
    } };
    function Mn(i2, o2, a2, u2) {
      return a2 = a2 || {}, u2 = u2 || "", x(i2).forEach(function(e2) {
        var t2, n2, r2;
        m2(o2, e2) ? (t2 = i2[e2], n2 = o2[e2], "object" == typeof t2 && "object" == typeof n2 && t2 && n2 ? (r2 = A(t2)) !== A(n2) ? a2[u2 + e2] = o2[e2] : "Object" === r2 ? Mn(t2, n2, a2, u2 + e2 + ".") : t2 !== n2 && (a2[u2 + e2] = o2[e2]) : t2 !== n2 && (a2[u2 + e2] = o2[e2])) : a2[u2 + e2] = void 0;
      }), x(o2).forEach(function(e2) {
        m2(i2, e2) || (a2[u2 + e2] = o2[e2]);
      }), a2;
    }
    function Fn(e2, t2) {
      return "delete" === t2.type ? t2.keys : t2.keys || t2.values.map(e2.extractKey);
    }
    var Nn = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e2) {
      return _(_({}, e2), { table: function(r2) {
        var y2 = e2.table(r2), v3 = y2.schema.primaryKey;
        return _(_({}, y2), { mutate: function(e3) {
          var t2 = me.trans, n2 = t2.table(r2).hook, h3 = n2.deleting, d2 = n2.creating, p3 = n2.updating;
          switch (e3.type) {
            case "add":
              if (d2.fire === G) break;
              return t2._promise("readwrite", function() {
                return a2(e3);
              }, true);
            case "put":
              if (d2.fire === G && p3.fire === G) break;
              return t2._promise("readwrite", function() {
                return a2(e3);
              }, true);
            case "delete":
              if (h3.fire === G) break;
              return t2._promise("readwrite", function() {
                return a2(e3);
              }, true);
            case "deleteRange":
              if (h3.fire === G) break;
              return t2._promise("readwrite", function() {
                return function n3(r3, i2, o2) {
                  return y2.query({ trans: r3, values: false, query: { index: v3, range: i2 }, limit: o2 }).then(function(e4) {
                    var t3 = e4.result;
                    return a2({ type: "delete", keys: t3, trans: r3 }).then(function(e5) {
                      return 0 < e5.numFailures ? Promise.reject(e5.failures[0]) : t3.length < o2 ? { failures: [], numFailures: 0, lastResult: void 0 } : n3(r3, _(_({}, i2), { lower: t3[t3.length - 1], lowerOpen: true }), o2);
                    });
                  });
                }(e3.trans, e3.range, 1e4);
              }, true);
          }
          return y2.mutate(e3);
          function a2(c2) {
            var e4, t3, n3, l2 = me.trans, f2 = c2.keys || Fn(v3, c2);
            if (!f2) throw new Error("Keys missing");
            return "delete" !== (c2 = "add" === c2.type || "put" === c2.type ? _(_({}, c2), { keys: f2 }) : _({}, c2)).type && (c2.values = i([], c2.values)), c2.keys && (c2.keys = i([], c2.keys)), e4 = y2, n3 = f2, ("add" === (t3 = c2).type ? Promise.resolve([]) : e4.getMany({ trans: t3.trans, keys: n3, cache: "immutable" })).then(function(u2) {
              var s2 = f2.map(function(e5, t4) {
                var n4, r3, i2, o2 = u2[t4], a3 = { onerror: null, onsuccess: null };
                return "delete" === c2.type ? h3.fire.call(a3, e5, o2, l2) : "add" === c2.type || void 0 === o2 ? (n4 = d2.fire.call(a3, e5, c2.values[t4], l2), null == e5 && null != n4 && (c2.keys[t4] = e5 = n4, v3.outbound || P(c2.values[t4], v3.keyPath, e5))) : (n4 = Mn(o2, c2.values[t4]), (r3 = p3.fire.call(a3, n4, e5, o2, l2)) && (i2 = c2.values[t4], Object.keys(r3).forEach(function(e6) {
                  m2(i2, e6) ? i2[e6] = r3[e6] : P(i2, e6, r3[e6]);
                }))), a3;
              });
              return y2.mutate(c2).then(function(e5) {
                for (var t4 = e5.failures, n4 = e5.results, r3 = e5.numFailures, e5 = e5.lastResult, i2 = 0; i2 < f2.length; ++i2) {
                  var o2 = (n4 || f2)[i2], a3 = s2[i2];
                  null == o2 ? a3.onerror && a3.onerror(t4[i2]) : a3.onsuccess && a3.onsuccess("put" === c2.type && u2[i2] ? c2.values[i2] : o2);
                }
                return { failures: t4, results: n4, numFailures: r3, lastResult: e5 };
              }).catch(function(t4) {
                return s2.forEach(function(e5) {
                  return e5.onerror && e5.onerror(t4);
                }), Promise.reject(t4);
              });
            });
          }
        } });
      } });
    } };
    function Ln(e2, t2, n2) {
      try {
        if (!t2) return null;
        if (t2.keys.length < e2.length) return null;
        for (var r2 = [], i2 = 0, o2 = 0; i2 < t2.keys.length && o2 < e2.length; ++i2) 0 === st(t2.keys[i2], e2[o2]) && (r2.push(n2 ? S(t2.values[i2]) : t2.values[i2]), ++o2);
        return r2.length === e2.length ? r2 : null;
      } catch (e3) {
        return null;
      }
    }
    var Un = { stack: "dbcore", level: -1, create: function(t2) {
      return { table: function(e2) {
        var n2 = t2.table(e2);
        return _(_({}, n2), { getMany: function(t3) {
          if (!t3.cache) return n2.getMany(t3);
          var e3 = Ln(t3.keys, t3.trans._cache, "clone" === t3.cache);
          return e3 ? _e.resolve(e3) : n2.getMany(t3).then(function(e4) {
            return t3.trans._cache = { keys: t3.keys, values: "clone" === t3.cache ? S(e4) : e4 }, e4;
          });
        }, mutate: function(e3) {
          return "add" !== e3.type && (e3.trans._cache = null), n2.mutate(e3);
        } });
      } };
    } };
    function Vn(e2, t2) {
      return "readonly" === e2.trans.mode && !!e2.subscr && !e2.trans.explicit && "disabled" !== e2.trans.db._options.cache && !t2.schema.primaryKey.outbound;
    }
    function zn(e2, t2) {
      switch (e2) {
        case "query":
          return t2.values && !t2.unique;
        case "get":
        case "getMany":
        case "count":
        case "openCursor":
          return false;
      }
    }
    var Wn = { stack: "dbcore", level: 0, name: "Observability", create: function(b2) {
      var g2 = b2.schema.name, w2 = new gn(b2.MIN_KEY, b2.MAX_KEY);
      return _(_({}, b2), { transaction: function(e2, t2, n2) {
        if (me.subscr && "readonly" !== t2) throw new Y.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(me.querier));
        return b2.transaction(e2, t2, n2);
      }, table: function(d2) {
        var p3 = b2.table(d2), y2 = p3.schema, v3 = y2.primaryKey, e2 = y2.indexes, c2 = v3.extractKey, l2 = v3.outbound, m3 = v3.autoIncrement && e2.filter(function(e3) {
          return e3.compound && e3.keyPath.includes(v3.keyPath);
        }), t2 = _(_({}, p3), { mutate: function(a2) {
          function u2(e4) {
            return e4 = "idb://".concat(g2, "/").concat(d2, "/").concat(e4), n2[e4] || (n2[e4] = new gn());
          }
          var e3, o2, s2, t3 = a2.trans, n2 = a2.mutatedParts || (a2.mutatedParts = {}), r2 = u2(""), i2 = u2(":dels"), c3 = a2.type, l3 = "deleteRange" === a2.type ? [a2.range] : "delete" === a2.type ? [a2.keys] : a2.values.length < 50 ? [Fn(v3, a2).filter(function(e4) {
            return e4;
          }), a2.values] : [], f3 = l3[0], h3 = l3[1], l3 = a2.trans._cache;
          return k(f3) ? (r2.addKeys(f3), (l3 = "delete" === c3 || f3.length === h3.length ? Ln(f3, l3) : null) || i2.addKeys(f3), (l3 || h3) && (e3 = u2, o2 = l3, s2 = h3, y2.indexes.forEach(function(t4) {
            var n3 = e3(t4.name || "");
            function r3(e4) {
              return null != e4 ? t4.extractKey(e4) : null;
            }
            function i3(e4) {
              return t4.multiEntry && k(e4) ? e4.forEach(function(e5) {
                return n3.addKey(e5);
              }) : n3.addKey(e4);
            }
            (o2 || s2).forEach(function(e4, t5) {
              var n4 = o2 && r3(o2[t5]), t5 = s2 && r3(s2[t5]);
              0 !== st(n4, t5) && (null != n4 && i3(n4), null != t5 && i3(t5));
            });
          }))) : f3 ? (h3 = { from: null !== (h3 = f3.lower) && void 0 !== h3 ? h3 : b2.MIN_KEY, to: null !== (h3 = f3.upper) && void 0 !== h3 ? h3 : b2.MAX_KEY }, i2.add(h3), r2.add(h3)) : (r2.add(w2), i2.add(w2), y2.indexes.forEach(function(e4) {
            return u2(e4.name).add(w2);
          })), p3.mutate(a2).then(function(o3) {
            return !f3 || "add" !== a2.type && "put" !== a2.type || (r2.addKeys(o3.results), m3 && m3.forEach(function(t4) {
              for (var e4 = a2.values.map(function(e5) {
                return t4.extractKey(e5);
              }), n3 = t4.keyPath.findIndex(function(e5) {
                return e5 === v3.keyPath;
              }), r3 = 0, i3 = o3.results.length; r3 < i3; ++r3) e4[r3][n3] = o3.results[r3];
              u2(t4.name).addKeys(e4);
            })), t3.mutatedParts = Kn(t3.mutatedParts || {}, n2), o3;
          });
        } }), e2 = function(e3) {
          var t3 = e3.query, e3 = t3.index, t3 = t3.range;
          return [e3, new gn(null !== (e3 = t3.lower) && void 0 !== e3 ? e3 : b2.MIN_KEY, null !== (t3 = t3.upper) && void 0 !== t3 ? t3 : b2.MAX_KEY)];
        }, f2 = { get: function(e3) {
          return [v3, new gn(e3.key)];
        }, getMany: function(e3) {
          return [v3, new gn().addKeys(e3.keys)];
        }, count: e2, query: e2, openCursor: e2 };
        return x(f2).forEach(function(s2) {
          t2[s2] = function(i2) {
            var e3 = me.subscr, t3 = !!e3, n2 = Vn(me, p3) && zn(s2, i2) ? i2.obsSet = {} : e3;
            if (t3) {
              var r2 = function(e4) {
                e4 = "idb://".concat(g2, "/").concat(d2, "/").concat(e4);
                return n2[e4] || (n2[e4] = new gn());
              }, o2 = r2(""), a2 = r2(":dels"), e3 = f2[s2](i2), t3 = e3[0], e3 = e3[1];
              if (("query" === s2 && t3.isPrimaryKey && !i2.values ? a2 : r2(t3.name || "")).add(e3), !t3.isPrimaryKey) {
                if ("count" !== s2) {
                  var u2 = "query" === s2 && l2 && i2.values && p3.query(_(_({}, i2), { values: false }));
                  return p3[s2].apply(this, arguments).then(function(t4) {
                    if ("query" === s2) {
                      if (l2 && i2.values) return u2.then(function(e5) {
                        e5 = e5.result;
                        return o2.addKeys(e5), t4;
                      });
                      var e4 = i2.values ? t4.result.map(c2) : t4.result;
                      (i2.values ? o2 : a2).addKeys(e4);
                    } else if ("openCursor" === s2) {
                      var n3 = t4, r3 = i2.values;
                      return n3 && Object.create(n3, { key: { get: function() {
                        return a2.addKey(n3.primaryKey), n3.key;
                      } }, primaryKey: { get: function() {
                        var e5 = n3.primaryKey;
                        return a2.addKey(e5), e5;
                      } }, value: { get: function() {
                        return r3 && o2.addKey(n3.primaryKey), n3.value;
                      } } });
                    }
                    return t4;
                  });
                }
                a2.add(w2);
              }
            }
            return p3[s2].apply(this, arguments);
          };
        }), t2;
      } });
    } };
    function Yn(e2, t2, n2) {
      if (0 === n2.numFailures) return t2;
      if ("deleteRange" === t2.type) return null;
      var r2 = t2.keys ? t2.keys.length : "values" in t2 && t2.values ? t2.values.length : 1;
      if (n2.numFailures === r2) return null;
      t2 = _({}, t2);
      return k(t2.keys) && (t2.keys = t2.keys.filter(function(e3, t3) {
        return !(t3 in n2.failures);
      })), "values" in t2 && k(t2.values) && (t2.values = t2.values.filter(function(e3, t3) {
        return !(t3 in n2.failures);
      })), t2;
    }
    function $n(e2, t2) {
      return n2 = e2, (void 0 === (r2 = t2).lower || (r2.lowerOpen ? 0 < st(n2, r2.lower) : 0 <= st(n2, r2.lower))) && (e2 = e2, void 0 === (t2 = t2).upper || (t2.upperOpen ? st(e2, t2.upper) < 0 : st(e2, t2.upper) <= 0));
      var n2, r2;
    }
    function Qn(e2, d2, t2, n2, r2, i2) {
      if (!t2 || 0 === t2.length) return e2;
      var o2 = d2.query.index, p3 = o2.multiEntry, y2 = d2.query.range, v3 = n2.schema.primaryKey.extractKey, m3 = o2.extractKey, a2 = (o2.lowLevelIndex || o2).extractKey, t2 = t2.reduce(function(e3, t3) {
        var n3 = e3, r3 = [];
        if ("add" === t3.type || "put" === t3.type) for (var i3 = new gn(), o3 = t3.values.length - 1; 0 <= o3; --o3) {
          var a3, u2 = t3.values[o3], s2 = v3(u2);
          i3.hasKey(s2) || (a3 = m3(u2), (p3 && k(a3) ? a3.some(function(e4) {
            return $n(e4, y2);
          }) : $n(a3, y2)) && (i3.addKey(s2), r3.push(u2)));
        }
        switch (t3.type) {
          case "add":
            var c2 = new gn().addKeys(d2.values ? e3.map(function(e4) {
              return v3(e4);
            }) : e3), n3 = e3.concat(d2.values ? r3.filter(function(e4) {
              e4 = v3(e4);
              return !c2.hasKey(e4) && (c2.addKey(e4), true);
            }) : r3.map(function(e4) {
              return v3(e4);
            }).filter(function(e4) {
              return !c2.hasKey(e4) && (c2.addKey(e4), true);
            }));
            break;
          case "put":
            var l2 = new gn().addKeys(t3.values.map(function(e4) {
              return v3(e4);
            }));
            n3 = e3.filter(function(e4) {
              return !l2.hasKey(d2.values ? v3(e4) : e4);
            }).concat(d2.values ? r3 : r3.map(function(e4) {
              return v3(e4);
            }));
            break;
          case "delete":
            var f2 = new gn().addKeys(t3.keys);
            n3 = e3.filter(function(e4) {
              return !f2.hasKey(d2.values ? v3(e4) : e4);
            });
            break;
          case "deleteRange":
            var h3 = t3.range;
            n3 = e3.filter(function(e4) {
              return !$n(v3(e4), h3);
            });
        }
        return n3;
      }, e2);
      return t2 === e2 ? e2 : (t2.sort(function(e3, t3) {
        return st(a2(e3), a2(t3)) || st(v3(e3), v3(t3));
      }), d2.limit && d2.limit < 1 / 0 && (t2.length > d2.limit ? t2.length = d2.limit : e2.length === d2.limit && t2.length < d2.limit && (r2.dirty = true)), i2 ? Object.freeze(t2) : t2);
    }
    function Gn(e2, t2) {
      return 0 === st(e2.lower, t2.lower) && 0 === st(e2.upper, t2.upper) && !!e2.lowerOpen == !!t2.lowerOpen && !!e2.upperOpen == !!t2.upperOpen;
    }
    function Xn(e2, t2) {
      return function(e3, t3, n2, r2) {
        if (void 0 === e3) return void 0 !== t3 ? -1 : 0;
        if (void 0 === t3) return 1;
        if (0 === (t3 = st(e3, t3))) {
          if (n2 && r2) return 0;
          if (n2) return 1;
          if (r2) return -1;
        }
        return t3;
      }(e2.lower, t2.lower, e2.lowerOpen, t2.lowerOpen) <= 0 && 0 <= function(e3, t3, n2, r2) {
        if (void 0 === e3) return void 0 !== t3 ? 1 : 0;
        if (void 0 === t3) return -1;
        if (0 === (t3 = st(e3, t3))) {
          if (n2 && r2) return 0;
          if (n2) return -1;
          if (r2) return 1;
        }
        return t3;
      }(e2.upper, t2.upper, e2.upperOpen, t2.upperOpen);
    }
    function Hn(n2, r2, i2, e2) {
      n2.subscribers.add(i2), e2.addEventListener("abort", function() {
        var e3, t2;
        n2.subscribers.delete(i2), 0 === n2.subscribers.size && (e3 = n2, t2 = r2, setTimeout(function() {
          0 === e3.subscribers.size && q(t2, e3);
        }, 3e3));
      });
    }
    var Jn = { stack: "dbcore", level: 0, name: "Cache", create: function(k2) {
      var O2 = k2.schema.name;
      return _(_({}, k2), { transaction: function(g2, w2, e2) {
        var _2, t2, x2 = k2.transaction(g2, w2, e2);
        return "readwrite" === w2 && (t2 = (_2 = new AbortController()).signal, e2 = function(b2) {
          return function() {
            if (_2.abort(), "readwrite" === w2) {
              for (var t3 = /* @__PURE__ */ new Set(), e3 = 0, n2 = g2; e3 < n2.length; e3++) {
                var r2 = n2[e3], i2 = Sn["idb://".concat(O2, "/").concat(r2)];
                if (i2) {
                  var o2 = k2.table(r2), a2 = i2.optimisticOps.filter(function(e4) {
                    return e4.trans === x2;
                  });
                  if (x2._explicit && b2 && x2.mutatedParts) for (var u2 = 0, s2 = Object.values(i2.queries.query); u2 < s2.length; u2++) for (var c2 = 0, l2 = (d2 = s2[u2]).slice(); c2 < l2.length; c2++) En((p3 = l2[c2]).obsSet, x2.mutatedParts) && (q(d2, p3), p3.subscribers.forEach(function(e4) {
                    return t3.add(e4);
                  }));
                  else if (0 < a2.length) {
                    i2.optimisticOps = i2.optimisticOps.filter(function(e4) {
                      return e4.trans !== x2;
                    });
                    for (var f2 = 0, h3 = Object.values(i2.queries.query); f2 < h3.length; f2++) for (var d2, p3, y2, v3 = 0, m3 = (d2 = h3[f2]).slice(); v3 < m3.length; v3++) null != (p3 = m3[v3]).res && x2.mutatedParts && (b2 && !p3.dirty ? (y2 = Object.isFrozen(p3.res), y2 = Qn(p3.res, p3.req, a2, o2, p3, y2), p3.dirty ? (q(d2, p3), p3.subscribers.forEach(function(e4) {
                      return t3.add(e4);
                    })) : y2 !== p3.res && (p3.res = y2, p3.promise = _e.resolve({ result: y2 }))) : (p3.dirty && q(d2, p3), p3.subscribers.forEach(function(e4) {
                      return t3.add(e4);
                    })));
                  }
                }
              }
              t3.forEach(function(e4) {
                return e4();
              });
            }
          };
        }, x2.addEventListener("abort", e2(false), { signal: t2 }), x2.addEventListener("error", e2(false), { signal: t2 }), x2.addEventListener("complete", e2(true), { signal: t2 })), x2;
      }, table: function(c2) {
        var l2 = k2.table(c2), i2 = l2.schema.primaryKey;
        return _(_({}, l2), { mutate: function(t2) {
          var e2 = me.trans;
          if (i2.outbound || "disabled" === e2.db._options.cache || e2.explicit || "readwrite" !== e2.idbtrans.mode) return l2.mutate(t2);
          var n2 = Sn["idb://".concat(O2, "/").concat(c2)];
          if (!n2) return l2.mutate(t2);
          e2 = l2.mutate(t2);
          return "add" !== t2.type && "put" !== t2.type || !(50 <= t2.values.length || Fn(i2, t2).some(function(e3) {
            return null == e3;
          })) ? (n2.optimisticOps.push(t2), t2.mutatedParts && Cn(t2.mutatedParts), e2.then(function(e3) {
            0 < e3.numFailures && (q(n2.optimisticOps, t2), (e3 = Yn(0, t2, e3)) && n2.optimisticOps.push(e3), t2.mutatedParts && Cn(t2.mutatedParts));
          }), e2.catch(function() {
            q(n2.optimisticOps, t2), t2.mutatedParts && Cn(t2.mutatedParts);
          })) : e2.then(function(r2) {
            var e3 = Yn(0, _(_({}, t2), { values: t2.values.map(function(e4, t3) {
              var n3;
              if (r2.failures[t3]) return e4;
              e4 = null !== (n3 = i2.keyPath) && void 0 !== n3 && n3.includes(".") ? S(e4) : _({}, e4);
              return P(e4, i2.keyPath, r2.results[t3]), e4;
            }) }), r2);
            n2.optimisticOps.push(e3), queueMicrotask(function() {
              return t2.mutatedParts && Cn(t2.mutatedParts);
            });
          }), e2;
        }, query: function(t2) {
          if (!Vn(me, l2) || !zn("query", t2)) return l2.query(t2);
          var i3 = "immutable" === (null === (o2 = me.trans) || void 0 === o2 ? void 0 : o2.db._options.cache), e2 = me, n2 = e2.requery, r2 = e2.signal, o2 = function(e3, t3, n3, r3) {
            var i4 = Sn["idb://".concat(e3, "/").concat(t3)];
            if (!i4) return [];
            if (!(t3 = i4.queries[n3])) return [null, false, i4, null];
            var o3 = t3[(r3.query ? r3.query.index.name : null) || ""];
            if (!o3) return [null, false, i4, null];
            switch (n3) {
              case "query":
                var a3 = o3.find(function(e4) {
                  return e4.req.limit === r3.limit && e4.req.values === r3.values && Gn(e4.req.query.range, r3.query.range);
                });
                return a3 ? [a3, true, i4, o3] : [o3.find(function(e4) {
                  return ("limit" in e4.req ? e4.req.limit : 1 / 0) >= r3.limit && (!r3.values || e4.req.values) && Xn(e4.req.query.range, r3.query.range);
                }), false, i4, o3];
              case "count":
                a3 = o3.find(function(e4) {
                  return Gn(e4.req.query.range, r3.query.range);
                });
                return [a3, !!a3, i4, o3];
            }
          }(O2, c2, "query", t2), a2 = o2[0], e2 = o2[1], u2 = o2[2], s2 = o2[3];
          return a2 && e2 ? a2.obsSet = t2.obsSet : (e2 = l2.query(t2).then(function(e3) {
            var t3 = e3.result;
            if (a2 && (a2.res = t3), i3) {
              for (var n3 = 0, r3 = t3.length; n3 < r3; ++n3) Object.freeze(t3[n3]);
              Object.freeze(t3);
            } else e3.result = S(t3);
            return e3;
          }).catch(function(e3) {
            return s2 && a2 && q(s2, a2), Promise.reject(e3);
          }), a2 = { obsSet: t2.obsSet, promise: e2, subscribers: /* @__PURE__ */ new Set(), type: "query", req: t2, dirty: false }, s2 ? s2.push(a2) : (s2 = [a2], (u2 = u2 || (Sn["idb://".concat(O2, "/").concat(c2)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[t2.query.index.name || ""] = s2)), Hn(a2, s2, n2, r2), a2.promise.then(function(e3) {
            return { result: Qn(e3.result, t2, null == u2 ? void 0 : u2.optimisticOps, l2, a2, i3) };
          });
        } });
      } });
    } };
    function Zn(e2, r2) {
      return new Proxy(e2, { get: function(e3, t2, n2) {
        return "db" === t2 ? r2 : Reflect.get(e3, t2, n2);
      } });
    }
    var er = (tr.prototype.version = function(t2) {
      if (isNaN(t2) || t2 < 0.1) throw new Y.Type("Given version is not a positive number");
      if (t2 = Math.round(10 * t2) / 10, this.idbdb || this._state.isBeingOpened) throw new Y.Schema("Cannot add version when database is open");
      this.verno = Math.max(this.verno, t2);
      var e2 = this._versions, n2 = e2.filter(function(e3) {
        return e3._cfg.version === t2;
      })[0];
      return n2 || (n2 = new this.Version(t2), e2.push(n2), e2.sort(nn), n2.stores({}), this._state.autoSchema = false, n2);
    }, tr.prototype._whenReady = function(e2) {
      var n2 = this;
      return this.idbdb && (this._state.openComplete || me.letThrough || this._vip) ? e2() : new _e(function(e3, t2) {
        if (n2._state.openComplete) return t2(new Y.DatabaseClosed(n2._state.dbOpenError));
        if (!n2._state.isBeingOpened) {
          if (!n2._state.autoOpen) return void t2(new Y.DatabaseClosed());
          n2.open().catch(G);
        }
        n2._state.dbReadyPromise.then(e3, t2);
      }).then(e2);
    }, tr.prototype.use = function(e2) {
      var t2 = e2.stack, n2 = e2.create, r2 = e2.level, i2 = e2.name;
      i2 && this.unuse({ stack: t2, name: i2 });
      e2 = this._middlewares[t2] || (this._middlewares[t2] = []);
      return e2.push({ stack: t2, create: n2, level: null == r2 ? 10 : r2, name: i2 }), e2.sort(function(e3, t3) {
        return e3.level - t3.level;
      }), this;
    }, tr.prototype.unuse = function(e2) {
      var t2 = e2.stack, n2 = e2.name, r2 = e2.create;
      return t2 && this._middlewares[t2] && (this._middlewares[t2] = this._middlewares[t2].filter(function(e3) {
        return r2 ? e3.create !== r2 : !!n2 && e3.name !== n2;
      })), this;
    }, tr.prototype.open = function() {
      var e2 = this;
      return $e(ve, function() {
        return Dn(e2);
      });
    }, tr.prototype._close = function() {
      var n2 = this._state, e2 = et.indexOf(this);
      if (0 <= e2 && et.splice(e2, 1), this.idbdb) {
        try {
          this.idbdb.close();
        } catch (e3) {
        }
        this.idbdb = null;
      }
      n2.isBeingOpened || (n2.dbReadyPromise = new _e(function(e3) {
        n2.dbReadyResolve = e3;
      }), n2.openCanceller = new _e(function(e3, t2) {
        n2.cancelOpen = t2;
      }));
    }, tr.prototype.close = function(e2) {
      var t2 = (void 0 === e2 ? { disableAutoOpen: true } : e2).disableAutoOpen, e2 = this._state;
      t2 ? (e2.isBeingOpened && e2.cancelOpen(new Y.DatabaseClosed()), this._close(), e2.autoOpen = false, e2.dbOpenError = new Y.DatabaseClosed()) : (this._close(), e2.autoOpen = this._options.autoOpen || e2.isBeingOpened, e2.openComplete = false, e2.dbOpenError = null);
    }, tr.prototype.delete = function(n2) {
      var i2 = this;
      void 0 === n2 && (n2 = { disableAutoOpen: true });
      var o2 = 0 < arguments.length && "object" != typeof arguments[0], a2 = this._state;
      return new _e(function(r2, t2) {
        function e2() {
          i2.close(n2);
          var e3 = i2._deps.indexedDB.deleteDatabase(i2.name);
          e3.onsuccess = qe(function() {
            var e4, t3, n3;
            e4 = i2._deps, t3 = i2.name, n3 = e4.indexedDB, e4 = e4.IDBKeyRange, vn(n3) || t3 === tt2 || yn(n3, e4).delete(t3).catch(G), r2();
          }), e3.onerror = Bt(t2), e3.onblocked = i2._fireOnBlocked;
        }
        if (o2) throw new Y.InvalidArgument("Invalid closeOptions argument to db.delete()");
        a2.isBeingOpened ? a2.dbReadyPromise.then(e2) : e2();
      });
    }, tr.prototype.backendDB = function() {
      return this.idbdb;
    }, tr.prototype.isOpen = function() {
      return null !== this.idbdb;
    }, tr.prototype.hasBeenClosed = function() {
      var e2 = this._state.dbOpenError;
      return e2 && "DatabaseClosed" === e2.name;
    }, tr.prototype.hasFailed = function() {
      return null !== this._state.dbOpenError;
    }, tr.prototype.dynamicallyOpened = function() {
      return this._state.autoSchema;
    }, Object.defineProperty(tr.prototype, "tables", { get: function() {
      var t2 = this;
      return x(this._allTables).map(function(e2) {
        return t2._allTables[e2];
      });
    }, enumerable: false, configurable: true }), tr.prototype.transaction = function() {
      var e2 = (function(e3, t2, n2) {
        var r2 = arguments.length;
        if (r2 < 2) throw new Y.InvalidArgument("Too few arguments");
        for (var i2 = new Array(r2 - 1); --r2; ) i2[r2 - 1] = arguments[r2];
        return n2 = i2.pop(), [e3, w(i2), n2];
      }).apply(this, arguments);
      return this._transaction.apply(this, e2);
    }, tr.prototype._transaction = function(e2, t2, n2) {
      var r2 = this, i2 = me.trans;
      i2 && i2.db === this && -1 === e2.indexOf("!") || (i2 = null);
      var o2, a2, u2 = -1 !== e2.indexOf("?");
      e2 = e2.replace("!", "").replace("?", "");
      try {
        if (a2 = t2.map(function(e3) {
          e3 = e3 instanceof r2.Table ? e3.name : e3;
          if ("string" != typeof e3) throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
          return e3;
        }), "r" == e2 || e2 === nt) o2 = nt;
        else {
          if ("rw" != e2 && e2 != rt) throw new Y.InvalidArgument("Invalid transaction mode: " + e2);
          o2 = rt;
        }
        if (i2) {
          if (i2.mode === nt && o2 === rt) {
            if (!u2) throw new Y.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
            i2 = null;
          }
          i2 && a2.forEach(function(e3) {
            if (i2 && -1 === i2.storeNames.indexOf(e3)) {
              if (!u2) throw new Y.SubTransaction("Table " + e3 + " not included in parent transaction.");
              i2 = null;
            }
          }), u2 && i2 && !i2.active && (i2 = null);
        }
      } catch (n3) {
        return i2 ? i2._promise(null, function(e3, t3) {
          t3(n3);
        }) : Xe(n3);
      }
      var s2 = (function i3(o3, a3, u3, s3, c2) {
        return _e.resolve().then(function() {
          var e3 = me.transless || me, t3 = o3._createTransaction(a3, u3, o3._dbSchema, s3);
          if (t3.explicit = true, e3 = { trans: t3, transless: e3 }, s3) t3.idbtrans = s3.idbtrans;
          else try {
            t3.create(), t3.idbtrans._explicit = true, o3._state.PR1398_maxLoop = 3;
          } catch (e4) {
            return e4.name === z.InvalidState && o3.isOpen() && 0 < --o3._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), o3.close({ disableAutoOpen: false }), o3.open().then(function() {
              return i3(o3, a3, u3, null, c2);
            })) : Xe(e4);
          }
          var n3, r3 = B(c2);
          return r3 && Le(), e3 = _e.follow(function() {
            var e4;
            (n3 = c2.call(t3, t3)) && (r3 ? (e4 = Ue.bind(null, null), n3.then(e4, e4)) : "function" == typeof n3.next && "function" == typeof n3.throw && (n3 = In(n3)));
          }, e3), (n3 && "function" == typeof n3.then ? _e.resolve(n3).then(function(e4) {
            return t3.active ? e4 : Xe(new Y.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
          }) : e3.then(function() {
            return n3;
          })).then(function(e4) {
            return s3 && t3._resolve(), t3._completion.then(function() {
              return e4;
            });
          }).catch(function(e4) {
            return t3._reject(e4), Xe(e4);
          });
        });
      }).bind(null, this, o2, a2, i2, n2);
      return i2 ? i2._promise(o2, s2, "lock") : me.trans ? $e(me.transless, function() {
        return r2._whenReady(s2);
      }) : this._whenReady(s2);
    }, tr.prototype.table = function(e2) {
      if (!m2(this._allTables, e2)) throw new Y.InvalidTable("Table ".concat(e2, " does not exist"));
      return this._allTables[e2];
    }, tr);
    function tr(e2, t2) {
      var o2 = this;
      this._middlewares = {}, this.verno = 0;
      var n2 = tr.dependencies;
      this._options = t2 = _({ addons: tr.addons, autoOpen: true, indexedDB: n2.indexedDB, IDBKeyRange: n2.IDBKeyRange, cache: "cloned" }, t2), this._deps = { indexedDB: t2.indexedDB, IDBKeyRange: t2.IDBKeyRange };
      n2 = t2.addons;
      this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
      var a2, r2, u2, i2, s2, c2 = { dbOpenError: null, isBeingOpened: false, onReadyBeingFired: null, openComplete: false, dbReadyResolve: G, dbReadyPromise: null, cancelOpen: G, openCanceller: null, autoSchema: true, PR1398_maxLoop: 3, autoOpen: t2.autoOpen };
      c2.dbReadyPromise = new _e(function(e3) {
        c2.dbReadyResolve = e3;
      }), c2.openCanceller = new _e(function(e3, t3) {
        c2.cancelOpen = t3;
      }), this._state = c2, this.name = e2, this.on = dt(this, "populate", "blocked", "versionchange", "close", { ready: [re, G] }), this.on.ready.subscribe = p2(this.on.ready.subscribe, function(i3) {
        return function(n3, r3) {
          tr.vip(function() {
            var t3, e3 = o2._state;
            e3.openComplete ? (e3.dbOpenError || _e.resolve().then(n3), r3 && i3(n3)) : e3.onReadyBeingFired ? (e3.onReadyBeingFired.push(n3), r3 && i3(n3)) : (i3(n3), t3 = o2, r3 || i3(function e4() {
              t3.on.ready.unsubscribe(n3), t3.on.ready.unsubscribe(e4);
            }));
          });
        };
      }), this.Collection = (a2 = this, pt(Ot.prototype, function(e3, t3) {
        this.db = a2;
        var n3 = ot, r3 = null;
        if (t3) try {
          n3 = t3();
        } catch (e4) {
          r3 = e4;
        }
        var i3 = e3._ctx, t3 = i3.table, e3 = t3.hook.reading.fire;
        this._ctx = { table: t3, index: i3.index, isPrimKey: !i3.index || t3.schema.primKey.keyPath && i3.index === t3.schema.primKey.name, range: n3, keysOnly: false, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: true, isMatch: null, offset: 0, limit: 1 / 0, error: r3, or: i3.or, valueMapper: e3 !== X ? e3 : null };
      })), this.Table = (r2 = this, pt(ft.prototype, function(e3, t3, n3) {
        this.db = r2, this._tx = n3, this.name = e3, this.schema = t3, this.hook = r2._allTables[e3] ? r2._allTables[e3].hook : dt(null, { creating: [Z, G], reading: [H, X], updating: [te, G], deleting: [ee, G] });
      })), this.Transaction = (u2 = this, pt(Lt.prototype, function(e3, t3, n3, r3, i3) {
        var o3 = this;
        this.db = u2, this.mode = e3, this.storeNames = t3, this.schema = n3, this.chromeTransactionDurability = r3, this.idbtrans = null, this.on = dt(this, "complete", "error", "abort"), this.parent = i3 || null, this.active = true, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new _e(function(e4, t4) {
          o3._resolve = e4, o3._reject = t4;
        }), this._completion.then(function() {
          o3.active = false, o3.on.complete.fire();
        }, function(e4) {
          var t4 = o3.active;
          return o3.active = false, o3.on.error.fire(e4), o3.parent ? o3.parent._reject(e4) : t4 && o3.idbtrans && o3.idbtrans.abort(), Xe(e4);
        });
      })), this.Version = (i2 = this, pt(dn.prototype, function(e3) {
        this.db = i2, this._cfg = { version: e3, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      })), this.WhereClause = (s2 = this, pt(Dt.prototype, function(e3, t3, n3) {
        if (this.db = s2, this._ctx = { table: e3, index: ":id" === t3 ? null : t3, or: n3 }, this._cmp = this._ascending = st, this._descending = function(e4, t4) {
          return st(t4, e4);
        }, this._max = function(e4, t4) {
          return 0 < st(e4, t4) ? e4 : t4;
        }, this._min = function(e4, t4) {
          return st(e4, t4) < 0 ? e4 : t4;
        }, this._IDBKeyRange = s2._deps.IDBKeyRange, !this._IDBKeyRange) throw new Y.MissingAPI();
      })), this.on("versionchange", function(e3) {
        0 < e3.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o2.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o2.name, "'. Closing db now to resume the delete request.")), o2.close({ disableAutoOpen: false });
      }), this.on("blocked", function(e3) {
        !e3.newVersion || e3.newVersion < e3.oldVersion ? console.warn("Dexie.delete('".concat(o2.name, "') was blocked")) : console.warn("Upgrade '".concat(o2.name, "' blocked by other connection holding version ").concat(e3.oldVersion / 10));
      }), this._maxKey = Yt(t2.IDBKeyRange), this._createTransaction = function(e3, t3, n3, r3) {
        return new o2.Transaction(e3, t3, n3, o2._options.chromeTransactionDurability, r3);
      }, this._fireOnBlocked = function(t3) {
        o2.on("blocked").fire(t3), et.filter(function(e3) {
          return e3.name === o2.name && e3 !== o2 && !e3._state.vcFired;
        }).map(function(e3) {
          return e3.on("versionchange").fire(t3);
        });
      }, this.use(Un), this.use(Jn), this.use(Wn), this.use(Rn), this.use(Nn);
      var l2 = new Proxy(this, { get: function(e3, t3, n3) {
        if ("_vip" === t3) return true;
        if ("table" === t3) return function(e4) {
          return Zn(o2.table(e4), l2);
        };
        var r3 = Reflect.get(e3, t3, n3);
        return r3 instanceof ft ? Zn(r3, l2) : "tables" === t3 ? r3.map(function(e4) {
          return Zn(e4, l2);
        }) : "_createTransaction" === t3 ? function() {
          return Zn(r3.apply(this, arguments), l2);
        } : r3;
      } });
      this.vip = l2, n2.forEach(function(e3) {
        return e3(o2);
      });
    }
    var nr, M = "undefined" != typeof Symbol && "observable" in Symbol ? Symbol.observable : "@@observable", rr = (ir.prototype.subscribe = function(e2, t2, n2) {
      return this._subscribe(e2 && "function" != typeof e2 ? e2 : { next: e2, error: t2, complete: n2 });
    }, ir.prototype[M] = function() {
      return this;
    }, ir);
    function ir(e2) {
      this._subscribe = e2;
    }
    try {
      nr = { indexedDB: f.indexedDB || f.mozIndexedDB || f.webkitIndexedDB || f.msIndexedDB, IDBKeyRange: f.IDBKeyRange || f.webkitIDBKeyRange };
    } catch (e2) {
      nr = { indexedDB: null, IDBKeyRange: null };
    }
    function or(h3) {
      var d2, p3 = false, e2 = new rr(function(r2) {
        var i2 = B(h3);
        var o2, a2 = false, u2 = {}, s2 = {}, e3 = { get closed() {
          return a2;
        }, unsubscribe: function() {
          a2 || (a2 = true, o2 && o2.abort(), c2 && Nt.storagemutated.unsubscribe(f2));
        } };
        r2.start && r2.start(e3);
        var c2 = false, l2 = function() {
          return Ge(t2);
        };
        var f2 = function(e4) {
          Kn(u2, e4), En(s2, u2) && l2();
        }, t2 = function() {
          var t3, n2, e4;
          !a2 && nr.indexedDB && (u2 = {}, t3 = {}, o2 && o2.abort(), o2 = new AbortController(), e4 = function(e5) {
            var t4 = je();
            try {
              i2 && Le();
              var n3 = Ne(h3, e5);
              return n3 = i2 ? n3.finally(Ue) : n3;
            } finally {
              t4 && Ae();
            }
          }(n2 = { subscr: t3, signal: o2.signal, requery: l2, querier: h3, trans: null }), Promise.resolve(e4).then(function(e5) {
            p3 = true, d2 = e5, a2 || n2.signal.aborted || (u2 = {}, function(e6) {
              for (var t4 in e6) if (m2(e6, t4)) return;
              return 1;
            }(s2 = t3) || c2 || (Nt(Mt, f2), c2 = true), Ge(function() {
              return !a2 && r2.next && r2.next(e5);
            }));
          }, function(e5) {
            p3 = false, ["DatabaseClosedError", "AbortError"].includes(null == e5 ? void 0 : e5.name) || a2 || Ge(function() {
              a2 || r2.error && r2.error(e5);
            });
          }));
        };
        return setTimeout(l2, 0), e3;
      });
      return e2.hasValue = function() {
        return p3;
      }, e2.getValue = function() {
        return d2;
      }, e2;
    }
    var ar = er;
    function ur(e2) {
      var t2 = cr;
      try {
        cr = true, Nt.storagemutated.fire(e2), Tn(e2, true);
      } finally {
        cr = t2;
      }
    }
    r(ar, _(_({}, Q), { delete: function(e2) {
      return new ar(e2, { addons: [] }).delete();
    }, exists: function(e2) {
      return new ar(e2, { addons: [] }).open().then(function(e3) {
        return e3.close(), true;
      }).catch("NoSuchDatabaseError", function() {
        return false;
      });
    }, getDatabaseNames: function(e2) {
      try {
        return t2 = ar.dependencies, n2 = t2.indexedDB, t2 = t2.IDBKeyRange, (vn(n2) ? Promise.resolve(n2.databases()).then(function(e3) {
          return e3.map(function(e4) {
            return e4.name;
          }).filter(function(e4) {
            return e4 !== tt2;
          });
        }) : yn(n2, t2).toCollection().primaryKeys()).then(e2);
      } catch (e3) {
        return Xe(new Y.MissingAPI());
      }
      var t2, n2;
    }, defineClass: function() {
      return function(e2) {
        a(this, e2);
      };
    }, ignoreTransaction: function(e2) {
      return me.trans ? $e(me.transless, e2) : e2();
    }, vip: mn, async: function(t2) {
      return function() {
        try {
          var e2 = In(t2.apply(this, arguments));
          return e2 && "function" == typeof e2.then ? e2 : _e.resolve(e2);
        } catch (e3) {
          return Xe(e3);
        }
      };
    }, spawn: function(e2, t2, n2) {
      try {
        var r2 = In(e2.apply(n2, t2 || []));
        return r2 && "function" == typeof r2.then ? r2 : _e.resolve(r2);
      } catch (e3) {
        return Xe(e3);
      }
    }, currentTransaction: { get: function() {
      return me.trans || null;
    } }, waitFor: function(e2, t2) {
      t2 = _e.resolve("function" == typeof e2 ? ar.ignoreTransaction(e2) : e2).timeout(t2 || 6e4);
      return me.trans ? me.trans.waitFor(t2) : t2;
    }, Promise: _e, debug: { get: function() {
      return ie;
    }, set: function(e2) {
      oe(e2);
    } }, derive: o, extend: a, props: r, override: p2, Events: dt, on: Nt, liveQuery: or, extendObservabilitySet: Kn, getByKeyPath: O, setByKeyPath: P, delByKeyPath: function(t2, e2) {
      "string" == typeof e2 ? P(t2, e2, void 0) : "length" in e2 && [].map.call(e2, function(e3) {
        P(t2, e3, void 0);
      });
    }, shallowClone: g, deepClone: S, getObjectDiff: Mn, cmp: st, asap: v2, minKey: -1 / 0, addons: [], connections: et, errnames: z, dependencies: nr, cache: Sn, semVer: "4.0.10", version: "4.0.10".split(".").map(function(e2) {
      return parseInt(e2);
    }).reduce(function(e2, t2, n2) {
      return e2 + t2 / Math.pow(10, 2 * n2);
    }) })), ar.maxKey = Yt(ar.dependencies.IDBKeyRange), "undefined" != typeof dispatchEvent && "undefined" != typeof addEventListener && (Nt(Mt, function(e2) {
      cr || (e2 = new CustomEvent(Ft, { detail: e2 }), cr = true, dispatchEvent(e2), cr = false);
    }), addEventListener(Ft, function(e2) {
      e2 = e2.detail;
      cr || ur(e2);
    }));
    var sr, cr = false, lr = function() {
    };
    return "undefined" != typeof BroadcastChannel && ((lr = function() {
      (sr = new BroadcastChannel(Ft)).onmessage = function(e2) {
        return e2.data && ur(e2.data);
      };
    })(), "function" == typeof sr.unref && sr.unref(), Nt(Mt, function(e2) {
      cr || sr.postMessage(e2);
    })), "undefined" != typeof addEventListener && (addEventListener("pagehide", function(e2) {
      if (!er.disableBfCache && e2.persisted) {
        ie && console.debug("Dexie: handling persisted pagehide"), null != sr && sr.close();
        for (var t2 = 0, n2 = et; t2 < n2.length; t2++) n2[t2].close({ disableAutoOpen: false });
      }
    }), addEventListener("pageshow", function(e2) {
      !er.disableBfCache && e2.persisted && (ie && console.debug("Dexie: handling persisted pageshow"), lr(), ur({ all: new gn(-1 / 0, [[]]) }));
    })), _e.rejectionMapper = function(e2, t2) {
      return !e2 || e2 instanceof N || e2 instanceof TypeError || e2 instanceof SyntaxError || !e2.name || !$[e2.name] ? e2 : (t2 = new $[e2.name](t2 || e2.message, e2), "stack" in e2 && l(t2, "stack", { get: function() {
        return this.inner.stack;
      } }), t2);
    }, oe(ie), _(er, Object.freeze({ __proto__: null, Dexie: er, liveQuery: or, Entity: ut, cmp: st, PropModSymbol: e, PropModification: xt, replacePrefix: function(e2, t2) {
      return new xt({ replacePrefix: [e2, t2] });
    }, add: function(e2) {
      return new xt({ add: e2 });
    }, remove: function(e2) {
      return new xt({ remove: e2 });
    }, default: er, RangeSet: gn, mergeRanges: _n, rangesOverlap: xn }), { default: er }), er;
  });
})(dexie_min);
var dexie_minExports = dexie_min.exports;
const _Dexie = /* @__PURE__ */ getDefaultExportFromCjs(dexie_minExports);
const DexieSymbol = Symbol.for("Dexie");
const Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _Dexie);
if (_Dexie.semVer !== Dexie.semVer) {
  throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);
}
class GuardBlockListDB extends Dexie {
  constructor() {
    super("eternl-guard-blocklist");
    __publicField(this, "entry");
    __publicField(this, "domain");
    __publicField(this, "allowlist");
    __publicField(this, "address");
    __publicField(this, "asset");
    __publicField(this, "info");
    this.version(2).stores({
      entry: "++id, filename",
      domain: "id, *domain",
      allowlist: "id, *domain",
      address: "id, *address",
      asset: "id, *assets",
      info: "id"
    });
  }
}
let guardBlockListDB = null;
const getDB = async () => {
  let db = guardBlockListDB;
  if (!db) {
    db = new GuardBlockListDB();
    guardBlockListDB = db;
  }
  if (!db.isOpen()) {
    await db.open();
  }
  return db;
};
const bulkAddGuardReport = async (reports) => getDB().then((db) => {
  if (reports.r.length === 0) {
    return;
  }
  db.transaction("rw", [db.info, db.entry, db.domain, db.allowlist, db.asset, db.address], async (tx2) => {
    await db.info.clear();
    await db.entry.clear();
    await db.domain.clear();
    await db.allowlist.clear();
    await db.asset.clear();
    await db.address.clear();
    await db.info.put({
      id: 1,
      timestamp: Date.now(),
      lastHash: reports.h
    });
    for (const report of reports.r) {
      let inserted = await db.entry.put({
        filename: report.filename,
        description: report.description
      });
      if (report.domains && report.domains.length > 0) {
        await db.domain.put({
          id: inserted,
          domain: report.domains
        });
      }
      if (report.allowlist && report.allowlist.length > 0) {
        await db.allowlist.put({
          id: inserted,
          domain: report.allowlist
        });
      }
      if (report.related_assets && report.related_assets.length > 0) {
        await db.asset.put({
          id: inserted,
          assets: report.related_assets
        });
      }
      if (report.associated_addresses && report.associated_addresses.length > 0) {
        await db.address.put({
          id: inserted,
          address: report.associated_addresses
        });
      }
    }
  });
});
const getLastImportInfo = () => getDB().then((db) => db.info.get(1));
const findDomain = (url) => getDB().then((db) => db.domain.where("domain").anyOf(url).toArray());
const isBlockedDomain = (url) => getDB().then((db) => db.domain.where("domain").equals(url).toArray().then((res) => res.length > 0));
const isAllowedDomain = (url) => getDB().then((db) => db.allowlist.where("domain").equals(url).toArray().then((res) => res.length > 0));
const findAsset = (asset) => getDB().then((db) => db.asset.where("assets").equals(asset).toArray());
const findAddress = (address2) => getDB().then((db) => db.address.where("address").anyOf(address2).toArray());
const getScamDomainList = () => getDB().then((db) => db.domain.toArray());
const getScamAddressesList = () => getDB().then((db) => db.address.toArray());
const getScamAssetList = () => getDB().then((db) => db.asset.toArray());
const GuardBlockListDB$1 = {
  bulkAddGuardReport,
  getLastImportInfo,
  isBlockedDomain,
  isAllowedDomain,
  findDomain,
  findAsset,
  findAddress,
  getScamAssetList,
  getScamDomainList,
  getScamAddressesList
};
var dist = {};
Object.defineProperty(dist, "__esModule", { value: true });
dist.bech32m = bech32 = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
  const x = ALPHABET.charAt(z);
  ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
  const b = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
}
function prefixChk(prefix) {
  let chk = 1;
  for (let i = 0; i < prefix.length; ++i) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      return "Invalid prefix (" + prefix + ")";
    chk = polymodStep(chk) ^ c >> 5;
  }
  chk = polymodStep(chk);
  for (let i = 0; i < prefix.length; ++i) {
    const v2 = prefix.charCodeAt(i);
    chk = polymodStep(chk) ^ v2 & 31;
  }
  return chk;
}
function convert(data, inBits, outBits, pad2) {
  let value2 = 0;
  let bits = 0;
  const maxV = (1 << outBits) - 1;
  const result = [];
  for (let i = 0; i < data.length; ++i) {
    value2 = value2 << inBits | data[i];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value2 >> bits & maxV);
    }
  }
  if (pad2) {
    if (bits > 0) {
      result.push(value2 << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value2 << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWords(bytes) {
  return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
  const res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words) {
  const res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
  let ENCODING_CONST;
  if (encoding === "bech32") {
    ENCODING_CONST = 1;
  } else {
    ENCODING_CONST = 734539939;
  }
  function encode3(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT)
      throw new TypeError("Exceeds length limit");
    prefix = prefix.toLowerCase();
    let chk = prefixChk(prefix);
    if (typeof chk === "string")
      throw new Error(chk);
    let result = prefix + "1";
    for (let i = 0; i < words.length; ++i) {
      const x = words[i];
      if (x >> 5 !== 0)
        throw new Error("Non 5-bit word");
      chk = polymodStep(chk) ^ x;
      result += ALPHABET.charAt(x);
    }
    for (let i = 0; i < 6; ++i) {
      chk = polymodStep(chk);
    }
    chk ^= ENCODING_CONST;
    for (let i = 0; i < 6; ++i) {
      const v2 = chk >> (5 - i) * 5 & 31;
      result += ALPHABET.charAt(v2);
    }
    return result;
  }
  function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8)
      return str + " too short";
    if (str.length > LIMIT)
      return "Exceeds length limit";
    const lowered = str.toLowerCase();
    const uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered)
      return "Mixed-case string " + str;
    str = lowered;
    const split = str.lastIndexOf("1");
    if (split === -1)
      return "No separator character for " + str;
    if (split === 0)
      return "Missing prefix for " + str;
    const prefix = str.slice(0, split);
    const wordChars = str.slice(split + 1);
    if (wordChars.length < 6)
      return "Data too short";
    let chk = prefixChk(prefix);
    if (typeof chk === "string")
      return chk;
    const words = [];
    for (let i = 0; i < wordChars.length; ++i) {
      const c = wordChars.charAt(i);
      const v2 = ALPHABET_MAP[c];
      if (v2 === void 0)
        return "Unknown character " + c;
      chk = polymodStep(chk) ^ v2;
      if (i + 6 >= wordChars.length)
        continue;
      words.push(v2);
    }
    if (chk !== ENCODING_CONST)
      return "Invalid checksum for " + str;
    return { prefix, words };
  }
  function decodeUnsafe(str, LIMIT) {
    const res = __decode(str, LIMIT);
    if (typeof res === "object")
      return res;
  }
  function decode3(str, LIMIT) {
    const res = __decode(str, LIMIT);
    if (typeof res === "object")
      return res;
    throw new Error(res);
  }
  return {
    decodeUnsafe,
    decode: decode3,
    encode: encode3,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
var bech32 = dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
const ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
function normalizeInput(input) {
  let ret;
  if (input instanceof Uint8Array) {
    ret = input;
  } else if (typeof input === "string") {
    const encoder = new TextEncoder();
    ret = encoder.encode(input);
  } else {
    throw new Error(ERROR_MSG_INPUT);
  }
  return ret;
}
function toHex(bytes) {
  return Array.prototype.map.call(bytes, function(n) {
    return (n < 16 ? "0" : "") + n.toString(16);
  }).join("");
}
function uint32ToHex(val) {
  return (4294967296 + val).toString(16).substring(1);
}
function debugPrint(label2, arr, size2) {
  let msg = "\n" + label2 + " = ";
  for (let i = 0; i < arr.length; i += 2) {
    if (size2 === 32) {
      msg += uint32ToHex(arr[i]).toUpperCase();
      msg += " ";
      msg += uint32ToHex(arr[i + 1]).toUpperCase();
    } else if (size2 === 64) {
      msg += uint32ToHex(arr[i + 1]).toUpperCase();
      msg += uint32ToHex(arr[i]).toUpperCase();
    } else throw new Error("Invalid size " + size2);
    if (i % 6 === 4) {
      msg += "\n" + new Array(label2.length + 4).join(" ");
    } else if (i < arr.length - 2) {
      msg += " ";
    }
  }
  console.log(msg);
}
function testSpeed(hashFn, N, M) {
  let startMs = (/* @__PURE__ */ new Date()).getTime();
  const input = new Uint8Array(N);
  for (let i = 0; i < N; i++) {
    input[i] = i % 256;
  }
  const genMs = (/* @__PURE__ */ new Date()).getTime();
  console.log("Generated random input in " + (genMs - startMs) + "ms");
  startMs = genMs;
  for (let i = 0; i < M; i++) {
    const hashHex = hashFn(input);
    const hashMs = (/* @__PURE__ */ new Date()).getTime();
    const ms = hashMs - startMs;
    startMs = hashMs;
    console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
    console.log(
      Math.round(N / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
    );
  }
}
var util$2 = {
  normalizeInput,
  toHex,
  debugPrint,
  testSpeed
};
const util$1 = util$2;
function ADD64AA(v2, a, b) {
  const o0 = v2[a] + v2[b];
  let o1 = v2[a + 1] + v2[b + 1];
  if (o0 >= 4294967296) {
    o1++;
  }
  v2[a] = o0;
  v2[a + 1] = o1;
}
function ADD64AC(v2, a, b0, b1) {
  let o0 = v2[a] + b0;
  if (b0 < 0) {
    o0 += 4294967296;
  }
  let o1 = v2[a + 1] + b1;
  if (o0 >= 4294967296) {
    o1++;
  }
  v2[a] = o0;
  v2[a + 1] = o1;
}
function B2B_GET32(arr, i) {
  return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
}
function B2B_G(a, b, c, d, ix, iy) {
  const x0 = m$1[ix];
  const x1 = m$1[ix + 1];
  const y0 = m$1[iy];
  const y1 = m$1[iy + 1];
  ADD64AA(v$1, a, b);
  ADD64AC(v$1, a, x0, x1);
  let xor0 = v$1[d] ^ v$1[a];
  let xor1 = v$1[d + 1] ^ v$1[a + 1];
  v$1[d] = xor1;
  v$1[d + 1] = xor0;
  ADD64AA(v$1, c, d);
  xor0 = v$1[b] ^ v$1[c];
  xor1 = v$1[b + 1] ^ v$1[c + 1];
  v$1[b] = xor0 >>> 24 ^ xor1 << 8;
  v$1[b + 1] = xor1 >>> 24 ^ xor0 << 8;
  ADD64AA(v$1, a, b);
  ADD64AC(v$1, a, y0, y1);
  xor0 = v$1[d] ^ v$1[a];
  xor1 = v$1[d + 1] ^ v$1[a + 1];
  v$1[d] = xor0 >>> 16 ^ xor1 << 16;
  v$1[d + 1] = xor1 >>> 16 ^ xor0 << 16;
  ADD64AA(v$1, c, d);
  xor0 = v$1[b] ^ v$1[c];
  xor1 = v$1[b + 1] ^ v$1[c + 1];
  v$1[b] = xor1 >>> 31 ^ xor0 << 1;
  v$1[b + 1] = xor0 >>> 31 ^ xor1 << 1;
}
const BLAKE2B_IV32 = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
const SIGMA8 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
];
const SIGMA82 = new Uint8Array(
  SIGMA8.map(function(x) {
    return x * 2;
  })
);
const v$1 = new Uint32Array(32);
const m$1 = new Uint32Array(32);
function blake2bCompress(ctx, last) {
  let i = 0;
  for (i = 0; i < 16; i++) {
    v$1[i] = ctx.h[i];
    v$1[i + 16] = BLAKE2B_IV32[i];
  }
  v$1[24] = v$1[24] ^ ctx.t;
  v$1[25] = v$1[25] ^ ctx.t / 4294967296;
  if (last) {
    v$1[28] = ~v$1[28];
    v$1[29] = ~v$1[29];
  }
  for (i = 0; i < 32; i++) {
    m$1[i] = B2B_GET32(ctx.b, 4 * i);
  }
  for (i = 0; i < 12; i++) {
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
  }
  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v$1[i] ^ v$1[i + 16];
  }
}
const parameterBlock = new Uint8Array([
  0,
  0,
  0,
  0,
  //  0: outlen, keylen, fanout, depth
  0,
  0,
  0,
  0,
  //  4: leaf length, sequential mode
  0,
  0,
  0,
  0,
  //  8: node offset
  0,
  0,
  0,
  0,
  // 12: node offset
  0,
  0,
  0,
  0,
  // 16: node depth, inner length, rfu
  0,
  0,
  0,
  0,
  // 20: rfu
  0,
  0,
  0,
  0,
  // 24: rfu
  0,
  0,
  0,
  0,
  // 28: rfu
  0,
  0,
  0,
  0,
  // 32: salt
  0,
  0,
  0,
  0,
  // 36: salt
  0,
  0,
  0,
  0,
  // 40: salt
  0,
  0,
  0,
  0,
  // 44: salt
  0,
  0,
  0,
  0,
  // 48: personal
  0,
  0,
  0,
  0,
  // 52: personal
  0,
  0,
  0,
  0,
  // 56: personal
  0,
  0,
  0,
  0
  // 60: personal
]);
function blake2bInit(outlen, key, salt, personal) {
  if (outlen === 0 || outlen > 64) {
    throw new Error("Illegal output length, expected 0 < length <= 64");
  }
  if (key && key.length > 64) {
    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
  }
  if (salt && salt.length !== 16) {
    throw new Error("Illegal salt, expected Uint8Array with length is 16");
  }
  if (personal && personal.length !== 16) {
    throw new Error("Illegal personal, expected Uint8Array with length is 16");
  }
  const ctx = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0,
    // input count
    c: 0,
    // pointer within buffer
    outlen
    // output length in bytes
  };
  parameterBlock.fill(0);
  parameterBlock[0] = outlen;
  if (key) parameterBlock[1] = key.length;
  parameterBlock[2] = 1;
  parameterBlock[3] = 1;
  if (salt) parameterBlock.set(salt, 32);
  if (personal) parameterBlock.set(personal, 48);
  for (let i = 0; i < 16; i++) {
    ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
  }
  if (key) {
    blake2bUpdate(ctx, key);
    ctx.c = 128;
  }
  return ctx;
}
function blake2bUpdate(ctx, input) {
  for (let i = 0; i < input.length; i++) {
    if (ctx.c === 128) {
      ctx.t += ctx.c;
      blake2bCompress(ctx, false);
      ctx.c = 0;
    }
    ctx.b[ctx.c++] = input[i];
  }
}
function blake2bFinal(ctx) {
  ctx.t += ctx.c;
  while (ctx.c < 128) {
    ctx.b[ctx.c++] = 0;
  }
  blake2bCompress(ctx, true);
  const out = new Uint8Array(ctx.outlen);
  for (let i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
  }
  return out;
}
function blake2b(input, key, outlen, salt, personal) {
  outlen = outlen || 64;
  input = util$1.normalizeInput(input);
  if (salt) {
    salt = util$1.normalizeInput(salt);
  }
  if (personal) {
    personal = util$1.normalizeInput(personal);
  }
  const ctx = blake2bInit(outlen, key, salt, personal);
  blake2bUpdate(ctx, input);
  return blake2bFinal(ctx);
}
function blake2bHex(input, key, outlen, salt, personal) {
  const output = blake2b(input, key, outlen, salt, personal);
  return util$1.toHex(output);
}
var blake2b_1 = {
  blake2b,
  blake2bHex,
  blake2bInit,
  blake2bUpdate,
  blake2bFinal
};
const util = util$2;
function B2S_GET32(v2, i) {
  return v2[i] ^ v2[i + 1] << 8 ^ v2[i + 2] << 16 ^ v2[i + 3] << 24;
}
function B2S_G(a, b, c, d, x, y) {
  v[a] = v[a] + v[b] + x;
  v[d] = ROTR32(v[d] ^ v[a], 16);
  v[c] = v[c] + v[d];
  v[b] = ROTR32(v[b] ^ v[c], 12);
  v[a] = v[a] + v[b] + y;
  v[d] = ROTR32(v[d] ^ v[a], 8);
  v[c] = v[c] + v[d];
  v[b] = ROTR32(v[b] ^ v[c], 7);
}
function ROTR32(x, y) {
  return x >>> y ^ x << 32 - y;
}
const BLAKE2S_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0
]);
const v = new Uint32Array(16);
const m = new Uint32Array(16);
function blake2sCompress(ctx, last) {
  let i = 0;
  for (i = 0; i < 8; i++) {
    v[i] = ctx.h[i];
    v[i + 8] = BLAKE2S_IV[i];
  }
  v[12] ^= ctx.t;
  v[13] ^= ctx.t / 4294967296;
  if (last) {
    v[14] = ~v[14];
  }
  for (i = 0; i < 16; i++) {
    m[i] = B2S_GET32(ctx.b, 4 * i);
  }
  for (i = 0; i < 10; i++) {
    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
  }
  for (i = 0; i < 8; i++) {
    ctx.h[i] ^= v[i] ^ v[i + 8];
  }
}
function blake2sInit(outlen, key) {
  if (!(outlen > 0 && outlen <= 32)) {
    throw new Error("Incorrect output length, should be in [1, 32]");
  }
  const keylen = key ? key.length : 0;
  if (key && !(keylen > 0 && keylen <= 32)) {
    throw new Error("Incorrect key length, should be in [1, 32]");
  }
  const ctx = {
    h: new Uint32Array(BLAKE2S_IV),
    // hash state
    b: new Uint8Array(64),
    // input block
    c: 0,
    // pointer within block
    t: 0,
    // input count
    outlen
    // output length in bytes
  };
  ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
  if (keylen > 0) {
    blake2sUpdate(ctx, key);
    ctx.c = 64;
  }
  return ctx;
}
function blake2sUpdate(ctx, input) {
  for (let i = 0; i < input.length; i++) {
    if (ctx.c === 64) {
      ctx.t += ctx.c;
      blake2sCompress(ctx, false);
      ctx.c = 0;
    }
    ctx.b[ctx.c++] = input[i];
  }
}
function blake2sFinal(ctx) {
  ctx.t += ctx.c;
  while (ctx.c < 64) {
    ctx.b[ctx.c++] = 0;
  }
  blake2sCompress(ctx, true);
  const out = new Uint8Array(ctx.outlen);
  for (let i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
  }
  return out;
}
function blake2s(input, key, outlen) {
  outlen = outlen || 32;
  input = util.normalizeInput(input);
  const ctx = blake2sInit(outlen, key);
  blake2sUpdate(ctx, input);
  return blake2sFinal(ctx);
}
function blake2sHex(input, key, outlen) {
  const output = blake2s(input, key, outlen);
  return util.toHex(output);
}
var blake2s_1 = {
  blake2s,
  blake2sHex,
  blake2sInit,
  blake2sUpdate,
  blake2sFinal
};
const b2b = blake2b_1;
const b2s = blake2s_1;
var blakejs = {
  blake2b: b2b.blake2b,
  blake2bHex: b2b.blake2bHex,
  blake2bInit: b2b.blake2bInit,
  blake2bUpdate: b2b.blake2bUpdate,
  blake2bFinal: b2b.blake2bFinal,
  blake2s: b2s.blake2s,
  blake2sHex: b2s.blake2sHex,
  blake2sInit: b2s.blake2sInit,
  blake2sUpdate: b2s.blake2sUpdate,
  blake2sFinal: b2s.blake2sFinal
};
const blake2b160 = (data) => blakejs.blake2b(data, void 0, 20);
globalThis["cslInitialized"] = false;
const assetIdBech32Map = {};
const getAssetIdBech32 = (policyId, assetName) => {
  if (policyId.length === 0) {
    return "";
  }
  let _bech32 = assetIdBech32Map[policyId + "." + assetName];
  if (!_bech32) {
    _bech32 = bech32.encode(
      "asset",
      bech32.toWords(
        blake2b160(
          toHexBuffer(
            byteaToHex(policyId) + byteaToHex(assetName)
          )
        )
      )
    );
    assetIdBech32Map[policyId + "." + assetName] = _bech32;
  }
  return _bech32;
};
const spamDomains = ref([]);
const spamAddress = ref([]);
const spamAssets = ref([]);
const useGuard = () => {
  const isDomainOnBlockList = async (urlToCheck) => {
    let url;
    try {
      url = new URL(urlToCheck);
    } catch (err) {
      return false;
    }
    let urlParts = url.hostname.split(".");
    let tld = "";
    let domain = "";
    let checkDomain = "";
    if (urlParts.length > 1) {
      tld = urlParts[urlParts.length - 1] ?? "";
      domain = urlParts[urlParts.length - 2] ?? "";
      checkDomain = domain + "." + tld;
    } else if (urlParts.length === 1) {
      domain = urlParts[urlParts.length - 1] ?? "";
      checkDomain = domain;
    }
    if (await GuardBlockListDB$1.isAllowedDomain(checkDomain)) {
      return false;
    }
    if (await GuardBlockListDB$1.isBlockedDomain(domain)) {
      return true;
    }
    while (urlParts.length > 0) {
      checkDomain = urlParts.join(".");
      if (await GuardBlockListDB$1.isBlockedDomain(checkDomain)) {
        return true;
      }
      urlParts.shift();
      if (urlParts.length === 0) {
        break;
      }
    }
    return false;
  };
  const isAddressOnBlockList = (address2) => {
    return spamAddress.value.includes(address2);
  };
  const isAssetOnBlockList = (asset) => spamAssets.value.includes(asset);
  const getScamAssetList2 = () => GuardBlockListDB$1.getScamAssetList();
  const cacheServerScamInfos = async () => {
    const guardDomains = await GuardBlockListDB$1.getScamDomainList();
    for (let domains of guardDomains ?? []) {
      for (let domain of domains.domain ?? []) {
        if (!spamDomains.value.includes(domain)) {
          spamDomains.value.push(domain);
        }
      }
    }
    const guardAssets = await GuardBlockListDB$1.getScamAssetList();
    for (let assets2 of guardAssets ?? []) {
      for (let asset of assets2.assets ?? []) {
        if (!spamAssets.value.includes(asset)) {
          spamAssets.value.push(asset);
        }
      }
    }
    const guardAddress = await GuardBlockListDB$1.getScamAddressesList();
    for (let addresses of guardAddress ?? []) {
      for (let address2 of addresses.address ?? []) {
        if (!spamAddress.value.includes(address2)) {
          spamAddress.value.push(address2);
        }
      }
    }
  };
  const isSpamAsset = (asset) => {
    if (spamAssets.value.length === 0) {
      console.warn("Guard does not contain cached asset data.");
    }
    return spamAssets.value.includes(getAssetIdBech32(asset.p, asset.t.a));
  };
  return {
    isDomainOnBlockList,
    isAddressOnBlockList,
    isAssetOnBlockList,
    getScamAssetList: getScamAssetList2,
    isSpamAsset,
    cacheServerScamInfos
  };
};
const useTranslation = () => {
  const i18n2 = useI18n();
  const it = (id3) => i18n2.t(id3);
  const t = it;
  const itd = (id3) => {
    const str = i18n2.t(id3, "####");
    return str === "####" ? "" : str;
  };
  const c = (id3) => {
    const nw = networkId.value ?? "mainnet";
    if (id3 === "gradient") {
      if (nw === "mainnet") return "cc-mainnet-gradient";
      if (nw === "guild") return "cc-guild-gradient";
      if (nw === "sancho") return "cc-sancho-gradient";
      if (nw === "preprod") return "cc-testnet-gradient";
      if (nw === "preview") return "cc-testnet-gradient";
      if (nw === "afvt") return "cc-afv-gradient";
      if (nw === "afvm") return "cc-afv-gradient";
      if (nw === "afpt") return "cc-afp-gradient";
      if (nw === "afpm") return "cc-afp-gradient";
    }
    if (id3 === "border") {
      if (nw === "mainnet") return "cc-mainnet-walletbutton-border";
      if (nw === "guild") return "cc-guild-walletbutton-border";
      if (nw === "sancho") return "cc-sancho-walletbutton-border";
      if (nw === "preprod") return "cc-testnet-walletbutton-border";
      if (nw === "preview") return "cc-testnet-walletbutton-border";
      if (nw === "afvt") return "cc-af-walletbutton-border";
      if (nw === "afvm") return "cc-af-walletbutton-border";
      if (nw === "afpt") return "cc-af-walletbutton-border";
      if (nw === "afpm") return "cc-af-walletbutton-border";
    }
    if (id3 === "hover") {
      if (nw === "mainnet") return "cc-mainnet-walletbutton-hover";
      if (nw === "guild") return "cc-guild-walletbutton-hover";
      if (nw === "sancho") return "cc-sancho-walletbutton-hover";
      if (nw === "preprod") return "cc-testnet-walletbutton-hover";
      if (nw === "preview") return "cc-testnet-walletbutton-hover";
      if (nw === "afvt") return "cc-af-walletbutton-hover";
      if (nw === "afvm") return "cc-af-walletbutton-hover";
      if (nw === "afpt") return "cc-af-walletbutton-hover";
      if (nw === "afpm") return "cc-af-walletbutton-hover";
    }
    if (id3 === "hover-large") {
      if (nw === "mainnet") return "cc-mainnet-walletbutton-hover-large";
      if (nw === "guild") return "cc-guild-walletbutton-hover-large";
      if (nw === "sancho") return "cc-sancho-walletbutton-hover-large";
      if (nw === "preprod") return "cc-testnet-walletbutton-hover-large";
      if (nw === "preview") return "cc-testnet-walletbutton-hover-large";
      if (nw === "afvt") return "cc-af-walletbutton-hover-large";
      if (nw === "afvm") return "cc-af-walletbutton-hover-large";
      if (nw === "afpt") return "cc-af-walletbutton-hover-large";
      if (nw === "afpm") return "cc-af-walletbutton-hover-large";
    }
    if (id3 === "hover-locked") {
      if (nw === "mainnet") return "cc-mainnet-walletbutton-hover-locked";
      if (nw === "guild") return "cc-mainnet-walletbutton-hover-locked";
      if (nw === "sancho") return "cc-mainnet-walletbutton-hover-locked";
      if (nw === "preprod") return "cc-mainnet-walletbutton-hover-locked";
      if (nw === "preview") return "cc-mainnet-walletbutton-hover-locked";
      if (nw === "afvt") return "cc-mainnet-walletbutton-hover-locked";
      if (nw === "afvm") return "cc-mainnet-walletbutton-hover-locked";
      if (nw === "afpt") return "cc-mainnet-walletbutton-hover-locked";
      if (nw === "afpm") return "cc-mainnet-walletbutton-hover-locked";
    }
    return "";
  };
  return { it, itd, t, c };
};
const _imports_0 = "/images/img-logo-small.png";
const _imports_1 = "/images/img-logo-small-beta.png";
const _hoisted_1$a = {
  class: "relative",
  style: { "width": "106px", "height": "36px" }
};
const _hoisted_2$8 = {
  key: 0,
  src: _imports_0,
  alt: "",
  class: "absolute top-0 left-0 origin-top-left scale-100",
  style: { "height": "36px" }
};
const _hoisted_3$4 = {
  key: 1,
  src: _imports_1,
  alt: "",
  class: "absolute top-0 left-0 origin-top-left scale-100",
  style: { "height": "36px" }
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "HeaderLogoAnimation",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        !unref(isBetaApp)() ? (openBlock(), createElementBlock("img", _hoisted_2$8)) : (openBlock(), createElementBlock("img", _hoisted_3$4))
      ]);
    };
  }
});
const _hoisted_1$9 = { class: "relative w-full h-12 px-1.5 cc-flex-fixed cc-site-max-width mx-auto flex flex-row flex-nowrap justify-start items-center" };
const _hoisted_2$7 = { class: "group shrink flex flex-row flex-nowrap items-start justify-start cc-rounded cc-btn-focus h-3/4 cc-border-reset cc-btn-focus cc-text-semi-bold cc-text-xl text-center whitespace-nowrap" };
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "HeaderShallow",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("header", _hoisted_1$9, [
        createBaseVNode("div", _hoisted_2$7, [
          createVNode(_sfc_main$f)
        ]),
        _cache[0] || (_cache[0] = createBaseVNode("div", { class: "grow shrink" }, null, -1)),
        _cache[1] || (_cache[1] = createBaseVNode("div", { class: "w-10 h-10 flex flex-row flex-nowrap justify-center items-center" }, null, -1))
      ]);
    };
  }
});
const _hoisted_1$8 = {
  class: "relative w-full cc-flex-fixed mb-1.5 cc-site-max-width mx-auto inline-block",
  id: "cc-epoch-container"
};
const _hoisted_2$6 = { class: "relative w-full px-1 py-0.5 overflow-hidden cc-site-max-width mx-auto cc-rounded-la cc-shadow cc-text-medium cc-text-xs cc-text-color-light text-center cc-online" };
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "EpochProgressShallow",
  setup(__props) {
    const { c, it } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$8, [
        createBaseVNode("div", _hoisted_2$6, [
          !unref(networkId) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["absolute cc-rounded-la top-0 left-0 h-full cc-shadow", unref(c)("gradient")]),
            style: "width: 100%"
          }, null, 2)) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: normalizeClass(["absolute cc-rounded-la top-0 left-0 h-full opacity-100 cc-shadow", unref(c)("gradient")]),
            style: "width: 100%"
          }, null, 2),
          _cache[0] || (_cache[0] = createBaseVNode("div", { class: "relative whitespace-nowrap capitalize cc-text-semi-bold mt-px -mb-px" }, [
            createBaseVNode("span", null, "")
          ], -1))
        ])
      ]);
    };
  }
});
const _hoisted_1$7 = {
  key: 0,
  class: "absolute top-0 right-0 pl-2 pr-1.5 py-0.5 whitespace-nowrap cc-rounded-la-r cc-text-medium cc-text-xs cc-online bg-purple-700 dark:bg-purple-900"
};
const _hoisted_2$5 = { class: "capitalize mr-1" };
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "NetworkBadgeShallow",
  setup(__props) {
    const { it } = useTranslation();
    return (_ctx, _cache) => {
      return unref(networkId) ? (openBlock(), createElementBlock("div", _hoisted_1$7, [
        createBaseVNode("span", _hoisted_2$5, toDisplayString$1(unref(it)("common.network." + unref(networkId) + ".badge")), 1),
        _cache[0] || (_cache[0] = createBaseVNode("i", { class: "text-xs -mt-0.5 mdi mdi-check-circle text-purple-400 dark:text-purple-600" }, null, -1))
      ])) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1$6 = {
  class: "relative w-full cc-flex-fixed cc-layout-mt cc-site-max-width mx-auto mb-1 sm:mb-2",
  id: "cc-footer-container"
};
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "FooterShallow",
  setup(__props) {
    const { c } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("footer", _hoisted_1$6, [
        createBaseVNode("div", {
          class: normalizeClass(["relative w-full py-0.5 px-1.5 overflow-hidden cc-rounded-la cc-shadow cc-online cc-text-medium cc-text-xs flex sm:justify-center items-center", unref(c)("gradient")])
        }, [
          _cache[0] || (_cache[0] = createBaseVNode("div", { class: "whitespace-nowrap text-center flex flex-row flex-nowrap space-x-1.5" }, "", -1)),
          createVNode(_sfc_main$c)
        ], 2)
      ]);
    };
  }
});
const _hoisted_1$5 = {
  class: "shallow-layout relative w-full h-full cc-layout-px cc-layout-py cc-text-color flex flex-col flex-nowrap",
  id: "cc-layout-container"
};
const _hoisted_2$4 = {
  class: "relative flex-grow w-full flex-1 cc-site-max-width mx-auto flex flex-col flex-nowrap",
  id: "cc-main-container"
};
const _hoisted_3$3 = {
  class: "relative flex-1 flex-grow-1 h-full overflow-hidden cc-rounded-la cc-shadow flex flex-row flex-nowrap",
  style: { "min-height": "222px" }
};
const _hoisted_4$2 = { class: "relative flex-1 w-full h-full" };
const _hoisted_5$2 = { class: "relative w-full h-full cc-rounded-la flex flex-row flex-nowrap cc-bg-light-1" };
const _hoisted_6$1 = { class: "shallow-layout-main relative h-full flex-1 overflow-hidden focus:outline-none flex flex-col flex-nowrap" };
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "ShallowLayout",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        _cache[0] || (_cache[0] = createBaseVNode("div", {
          class: "fixed inset-0 bg-gradient-to-r from-slate-200 to-stone-200 dark:from-slate-900 dark:to-stone-900",
          id: "cc-background-iframe-container"
        }, null, -1)),
        createVNode(_sfc_main$e),
        createVNode(_sfc_main$d),
        createBaseVNode("div", _hoisted_2$4, [
          createBaseVNode("div", _hoisted_3$3, [
            createBaseVNode("div", _hoisted_4$2, [
              createBaseVNode("div", _hoisted_5$2, [
                createBaseVNode("main", _hoisted_6$1, [
                  renderSlot(_ctx.$slots, "default")
                ])
              ])
            ])
          ])
        ]),
        createVNode(_sfc_main$b)
      ]);
    };
  }
});
const _hoisted_1$4 = {
  key: 1,
  class: "col-span-12"
};
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "GridSpace",
  props: {
    dense: { type: Boolean, default: false },
    hr: { type: Boolean, default: false },
    label: { type: String, default: "" },
    alignLabel: { type: String, default: "center" },
    labelCSS: { type: String, default: "cc-text-xs" },
    lineCSS: { type: String, default: "" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return !__props.hr ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["col-span-12", __props.dense ? " h-0" : " h-1"])
      }, null, 2)) : (openBlock(), createElementBlock("div", _hoisted_1$4, [
        __props.label.length === 0 ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["w-full border-b", __props.lineCSS])
        }, null, 2)) : createCommentVNode("", true),
        __props.label.length > 0 ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["flex items-center text-center separator", __props.lineCSS + (" separator-" + __props.alignLabel)])
        }, [
          createBaseVNode("span", {
            class: normalizeClass(__props.labelCSS)
          }, toDisplayString$1(__props.label), 3)
        ], 2)) : createCommentVNode("", true)
      ]));
    };
  }
});
const _export_sfc = (sfc, props4) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key, val] of props4) {
    target2[key] = val;
  }
  return target2;
};
const GridSpace = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-cf1a29a6"]]);
function injectProp(target2, propName, get2, set2) {
  Object.defineProperty(target2, propName, {
    get: get2,
    set: set2,
    enumerable: true
  });
  return target2;
}
function injectMultipleProps(target2, props4) {
  for (const key in props4) {
    injectProp(target2, key, props4[key]);
  }
  return target2;
}
var isRuntimeSsrPreHydration = ref(
  false
);
var preHydrationBrowser;
function getMatch(userAgent2, platformMatch) {
  const match = /(edg|edge|edga|edgios)\/([\w.]+)/.exec(userAgent2) || /(opr)[\/]([\w.]+)/.exec(userAgent2) || /(vivaldi)[\/]([\w.]+)/.exec(userAgent2) || /(chrome|crios)[\/]([\w.]+)/.exec(userAgent2) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent2) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent2) || /(firefox|fxios)[\/]([\w.]+)/.exec(userAgent2) || /(webkit)[\/]([\w.]+)/.exec(userAgent2) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(userAgent2) || [];
  return {
    browser: match[5] || match[3] || match[1] || "",
    version: match[4] || match[2] || "0",
    platform: platformMatch[0] || ""
  };
}
function getPlatformMatch(userAgent2) {
  return /(ipad)/.exec(userAgent2) || /(ipod)/.exec(userAgent2) || /(windows phone)/.exec(userAgent2) || /(iphone)/.exec(userAgent2) || /(kindle)/.exec(userAgent2) || /(silk)/.exec(userAgent2) || /(android)/.exec(userAgent2) || /(win)/.exec(userAgent2) || /(mac)/.exec(userAgent2) || /(linux)/.exec(userAgent2) || /(cros)/.exec(userAgent2) || /(playbook)/.exec(userAgent2) || /(bb)/.exec(userAgent2) || /(blackberry)/.exec(userAgent2) || [];
}
var hasTouch = "ontouchstart" in window || window.navigator.maxTouchPoints > 0;
function getPlatform(UA) {
  const userAgent2 = UA.toLowerCase();
  const platformMatch = getPlatformMatch(userAgent2);
  const matched = getMatch(userAgent2, platformMatch);
  const browser2 = {
    mobile: false,
    desktop: false,
    cordova: false,
    capacitor: false,
    nativeMobile: false,
    // nativeMobileWrapper: void 0,
    electron: false,
    bex: false,
    linux: false,
    mac: false,
    win: false,
    cros: false,
    chrome: false,
    firefox: false,
    opera: false,
    safari: false,
    vivaldi: false,
    edge: false,
    edgeChromium: false,
    ie: false,
    webkit: false,
    android: false,
    ios: false,
    ipad: false,
    iphone: false,
    ipod: false,
    kindle: false,
    winphone: false,
    blackberry: false,
    playbook: false,
    silk: false
  };
  if (matched.browser) {
    browser2[matched.browser] = true;
    browser2.version = matched.version;
    browser2.versionNumber = parseInt(matched.version, 10);
  }
  if (matched.platform) {
    browser2[matched.platform] = true;
  }
  const knownMobiles = browser2.android || browser2.ios || browser2.bb || browser2.blackberry || browser2.ipad || browser2.iphone || browser2.ipod || browser2.kindle || browser2.playbook || browser2.silk || browser2["windows phone"];
  if (knownMobiles === true || userAgent2.indexOf("mobile") !== -1) {
    browser2.mobile = true;
  } else {
    browser2.desktop = true;
  }
  if (browser2["windows phone"]) {
    browser2.winphone = true;
    delete browser2["windows phone"];
  }
  if (browser2.edga || browser2.edgios || browser2.edg) {
    browser2.edge = true;
    matched.browser = "edge";
  } else if (browser2.crios) {
    browser2.chrome = true;
    matched.browser = "chrome";
  } else if (browser2.fxios) {
    browser2.firefox = true;
    matched.browser = "firefox";
  }
  if (browser2.ipod || browser2.ipad || browser2.iphone) {
    browser2.ios = true;
  }
  if (browser2.vivaldi) {
    matched.browser = "vivaldi";
    browser2.vivaldi = true;
  }
  if (
    // Chrome, Opera 15+, Vivaldi and Safari are webkit based browsers
    browser2.chrome || browser2.opr || browser2.safari || browser2.vivaldi || browser2.mobile === true && browser2.ios !== true && knownMobiles !== true
  ) {
    browser2.webkit = true;
  }
  if (browser2.opr) {
    matched.browser = "opera";
    browser2.opera = true;
  }
  if (browser2.safari) {
    if (browser2.blackberry || browser2.bb) {
      matched.browser = "blackberry";
      browser2.blackberry = true;
    } else if (browser2.playbook) {
      matched.browser = "playbook";
      browser2.playbook = true;
    } else if (browser2.android) {
      matched.browser = "android";
      browser2.android = true;
    } else if (browser2.kindle) {
      matched.browser = "kindle";
      browser2.kindle = true;
    } else if (browser2.silk) {
      matched.browser = "silk";
      browser2.silk = true;
    }
  }
  browser2.name = matched.browser;
  browser2.platform = matched.platform;
  {
    if (userAgent2.indexOf("electron") !== -1) {
      browser2.electron = true;
    } else if (document.location.href.indexOf("-extension://") !== -1) {
      browser2.bex = true;
    } else {
      if (window.Capacitor !== void 0) {
        browser2.capacitor = true;
        browser2.nativeMobile = true;
        browser2.nativeMobileWrapper = "capacitor";
      } else if (window._cordovaNative !== void 0 || window.cordova !== void 0) {
        browser2.cordova = true;
        browser2.nativeMobile = true;
        browser2.nativeMobileWrapper = "cordova";
      }
      if (isRuntimeSsrPreHydration.value === true) {
        preHydrationBrowser = { is: { ...browser2 } };
      }
      if (hasTouch === true && browser2.mac === true && (browser2.desktop === true && browser2.safari === true || browser2.nativeMobile === true && browser2.android !== true && browser2.ios !== true && browser2.ipad !== true)) {
        delete browser2.mac;
        delete browser2.desktop;
        const platform = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone";
        Object.assign(browser2, {
          mobile: true,
          ios: true,
          platform,
          [platform]: true
        });
      }
      if (browser2.mobile !== true && window.navigator.userAgentData && window.navigator.userAgentData.mobile) {
        delete browser2.desktop;
        browser2.mobile = true;
      }
    }
  }
  return browser2;
}
var userAgent = navigator.userAgent || navigator.vendor || window.opera;
var ssrClient = {
  has: {
    touch: false,
    webStorage: false
  },
  within: { iframe: false }
};
var client = {
  userAgent,
  is: getPlatform(userAgent),
  has: {
    touch: hasTouch
  },
  within: {
    iframe: window.self !== window.top
  }
};
var Platform = {
  install(opts) {
    const { $q } = opts;
    if (isRuntimeSsrPreHydration.value === true) {
      opts.onSSRHydrated.push(() => {
        Object.assign($q.platform, client);
        isRuntimeSsrPreHydration.value = false;
      });
      $q.platform = reactive(this);
    } else {
      $q.platform = this;
    }
  }
};
{
  let hasWebStorage;
  injectProp(client.has, "webStorage", () => {
    if (hasWebStorage !== void 0) {
      return hasWebStorage;
    }
    try {
      if (window.localStorage) {
        hasWebStorage = true;
        return true;
      }
    } catch (_) {
    }
    hasWebStorage = false;
    return false;
  });
  Object.assign(Platform, client);
  if (isRuntimeSsrPreHydration.value === true) {
    Object.assign(Platform, preHydrationBrowser, ssrClient);
    preHydrationBrowser = null;
  }
}
var Platform_default = Platform;
function createComponent(raw) {
  return markRaw(/* @__PURE__ */ defineComponent(raw));
}
function createDirective(raw) {
  return markRaw(raw);
}
var createReactivePlugin = (state, plugin) => {
  const reactiveState = reactive(state);
  for (const name2 in state) {
    injectProp(
      plugin,
      name2,
      () => reactiveState[name2],
      (val) => {
        reactiveState[name2] = val;
      }
    );
  }
  return plugin;
};
var listenOpts = {
  hasPassive: false,
  passiveCapture: true,
  notPassiveCapture: true
};
try {
  const opts = Object.defineProperty({}, "passive", {
    get() {
      Object.assign(listenOpts, {
        hasPassive: true,
        passive: { passive: true },
        notPassive: { passive: false },
        passiveCapture: { passive: true, capture: true },
        notPassiveCapture: { passive: false, capture: true }
      });
    }
  });
  window.addEventListener("qtest", null, opts);
  window.removeEventListener("qtest", null, opts);
} catch (_) {
}
function noop() {
}
function leftClick(e) {
  return e.button === 0;
}
function position(e) {
  if (e.touches && e.touches[0]) {
    e = e.touches[0];
  } else if (e.changedTouches && e.changedTouches[0]) {
    e = e.changedTouches[0];
  } else if (e.targetTouches && e.targetTouches[0]) {
    e = e.targetTouches[0];
  }
  return {
    top: e.clientY,
    left: e.clientX
  };
}
function getEventPath(e) {
  if (e.path) {
    return e.path;
  }
  if (e.composedPath) {
    return e.composedPath();
  }
  const path = [];
  let el = e.target;
  while (el) {
    path.push(el);
    if (el.tagName === "HTML") {
      path.push(document);
      path.push(window);
      return path;
    }
    el = el.parentElement;
  }
}
function stop(e) {
  e.stopPropagation();
}
function prevent(e) {
  e.cancelable !== false && e.preventDefault();
}
function stopAndPrevent(e) {
  e.cancelable !== false && e.preventDefault();
  e.stopPropagation();
}
function preventDraggable(el, status2) {
  if (el === void 0 || status2 === true && el.__dragPrevented === true) {
    return;
  }
  const fn = status2 === true ? (el2) => {
    el2.__dragPrevented = true;
    el2.addEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
  } : (el2) => {
    delete el2.__dragPrevented;
    el2.removeEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
  };
  el.querySelectorAll("a, img").forEach(fn);
}
function addEvt(ctx, targetName, events) {
  const name2 = `__q_${targetName}_evt`;
  ctx[name2] = ctx[name2] !== void 0 ? ctx[name2].concat(events) : events;
  events.forEach((evt) => {
    evt[0].addEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
  });
}
function cleanEvt(ctx, targetName) {
  const name2 = `__q_${targetName}_evt`;
  if (ctx[name2] !== void 0) {
    ctx[name2].forEach((evt) => {
      evt[0].removeEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
    });
    ctx[name2] = void 0;
  }
}
function debounce_default(fn, wait = 250, immediate) {
  let timer2 = null;
  function debounced() {
    const args = arguments;
    const later = () => {
      timer2 = null;
      {
        fn.apply(this, args);
      }
    };
    if (timer2 !== null) {
      clearTimeout(timer2);
    }
    timer2 = setTimeout(later, wait);
  }
  debounced.cancel = () => {
    timer2 !== null && clearTimeout(timer2);
  };
  return debounced;
}
var SIZE_LIST = ["sm", "md", "lg", "xl"];
var { passive } = listenOpts;
createReactivePlugin({
  width: 0,
  height: 0,
  name: "xs",
  sizes: {
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
  },
  lt: {
    sm: true,
    md: true,
    lg: true,
    xl: true
  },
  gt: {
    xs: false,
    sm: false,
    md: false,
    lg: false
  },
  xs: true,
  sm: false,
  md: false,
  lg: false,
  xl: false
}, {
  setSizes: noop,
  setDebounce: noop,
  install({ $q, onSSRHydrated }) {
    $q.screen = this;
    if (this.__installed === true) {
      if ($q.config.screen !== void 0) {
        if ($q.config.screen.bodyClasses === false) {
          document.body.classList.remove(`screen--${this.name}`);
        } else {
          this.__update(true);
        }
      }
      return;
    }
    const { visualViewport } = window;
    const target2 = visualViewport || window;
    const scrollingElement = document.scrollingElement || document.documentElement;
    const getSize = visualViewport === void 0 || client.is.mobile === true ? () => [
      Math.max(window.innerWidth, scrollingElement.clientWidth),
      Math.max(window.innerHeight, scrollingElement.clientHeight)
    ] : () => [
      visualViewport.width * visualViewport.scale + window.innerWidth - scrollingElement.clientWidth,
      visualViewport.height * visualViewport.scale + window.innerHeight - scrollingElement.clientHeight
    ];
    const classes = $q.config.screen !== void 0 && $q.config.screen.bodyClasses === true;
    this.__update = (force) => {
      const [w, h138] = getSize();
      if (h138 !== this.height) {
        this.height = h138;
      }
      if (w !== this.width) {
        this.width = w;
      } else if (force !== true) {
        return;
      }
      let s = this.sizes;
      this.gt.xs = w >= s.sm;
      this.gt.sm = w >= s.md;
      this.gt.md = w >= s.lg;
      this.gt.lg = w >= s.xl;
      this.lt.sm = w < s.sm;
      this.lt.md = w < s.md;
      this.lt.lg = w < s.lg;
      this.lt.xl = w < s.xl;
      this.xs = this.lt.sm;
      this.sm = this.gt.xs === true && this.lt.md === true;
      this.md = this.gt.sm === true && this.lt.lg === true;
      this.lg = this.gt.md === true && this.lt.xl === true;
      this.xl = this.gt.lg;
      s = this.xs === true && "xs" || this.sm === true && "sm" || this.md === true && "md" || this.lg === true && "lg" || "xl";
      if (s !== this.name) {
        if (classes === true) {
          document.body.classList.remove(`screen--${this.name}`);
          document.body.classList.add(`screen--${s}`);
        }
        this.name = s;
      }
    };
    let updateEvt, updateSizes = {}, updateDebounce = 16;
    this.setSizes = (sizes) => {
      SIZE_LIST.forEach((name2) => {
        if (sizes[name2] !== void 0) {
          updateSizes[name2] = sizes[name2];
        }
      });
    };
    this.setDebounce = (deb) => {
      updateDebounce = deb;
    };
    const start = () => {
      const style2 = getComputedStyle(document.body);
      if (style2.getPropertyValue("--q-size-sm")) {
        SIZE_LIST.forEach((name2) => {
          this.sizes[name2] = parseInt(style2.getPropertyValue(`--q-size-${name2}`), 10);
        });
      }
      this.setSizes = (sizes) => {
        SIZE_LIST.forEach((name2) => {
          if (sizes[name2]) {
            this.sizes[name2] = sizes[name2];
          }
        });
        this.__update(true);
      };
      this.setDebounce = (delay) => {
        updateEvt !== void 0 && target2.removeEventListener("resize", updateEvt, passive);
        updateEvt = delay > 0 ? debounce_default(this.__update, delay) : this.__update;
        target2.addEventListener("resize", updateEvt, passive);
      };
      this.setDebounce(updateDebounce);
      if (Object.keys(updateSizes).length !== 0) {
        this.setSizes(updateSizes);
        updateSizes = void 0;
      } else {
        this.__update();
      }
      classes === true && this.name === "xs" && document.body.classList.add("screen--xs");
    };
    if (isRuntimeSsrPreHydration.value === true) {
      onSSRHydrated.push(start);
    } else {
      start();
    }
  }
});
var Plugin = createReactivePlugin({
  isActive: false,
  mode: false
}, {
  __media: void 0,
  set(val) {
    Plugin.mode = val;
    if (val === "auto") {
      if (Plugin.__media === void 0) {
        Plugin.__media = window.matchMedia("(prefers-color-scheme: dark)");
        Plugin.__updateMedia = () => {
          Plugin.set("auto");
        };
        Plugin.__media.addListener(Plugin.__updateMedia);
      }
      val = Plugin.__media.matches;
    } else if (Plugin.__media !== void 0) {
      Plugin.__media.removeListener(Plugin.__updateMedia);
      Plugin.__media = void 0;
    }
    Plugin.isActive = val === true;
    document.body.classList.remove(`body--${val === true ? "light" : "dark"}`);
    document.body.classList.add(`body--${val === true ? "dark" : "light"}`);
  },
  toggle() {
    {
      Plugin.set(Plugin.isActive === false);
    }
  },
  install({ $q, ssrContext }) {
    const { dark } = $q.config;
    $q.dark = this;
    if (this.__installed !== true) {
      this.set(dark !== void 0 ? dark : false);
    }
  }
});
function shouldIgnoreKey(evt) {
  return evt !== Object(evt) || evt.isComposing === true || evt.qKeyEvent === true;
}
function isKeyCode(evt, keyCodes4) {
  return shouldIgnoreKey(evt) === true ? false : [].concat(keyCodes4).includes(evt.keyCode);
}
var en_US_default = {
  isoName: "en-US",
  nativeName: "English (US)",
  label: {
    clear: "Clear",
    ok: "OK",
    cancel: "Cancel",
    close: "Close",
    set: "Set",
    select: "Select",
    reset: "Reset",
    remove: "Remove",
    update: "Update",
    create: "Create",
    search: "Search",
    filter: "Filter",
    refresh: "Refresh",
    expand: (label2) => label2 ? `Expand "${label2}"` : "Expand",
    collapse: (label2) => label2 ? `Collapse "${label2}"` : "Collapse"
  },
  date: {
    days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    firstDayOfWeek: 0,
    // 0-6, 0 - Sunday, 1 Monday, ...
    format24h: false,
    pluralDay: "days"
  },
  table: {
    noData: "No data available",
    noResults: "No matching records found",
    loading: "Loading...",
    selectedRecords: (rows) => rows === 1 ? "1 record selected." : (rows === 0 ? "No" : rows) + " records selected.",
    recordsPerPage: "Records per page:",
    allRows: "All",
    pagination: (start, end, total) => start + "-" + end + " of " + total,
    columns: "Columns"
  },
  editor: {
    url: "URL",
    bold: "Bold",
    italic: "Italic",
    strikethrough: "Strikethrough",
    underline: "Underline",
    unorderedList: "Unordered List",
    orderedList: "Ordered List",
    subscript: "Subscript",
    superscript: "Superscript",
    hyperlink: "Hyperlink",
    toggleFullscreen: "Toggle Fullscreen",
    quote: "Quote",
    left: "Left align",
    center: "Center align",
    right: "Right align",
    justify: "Justify align",
    print: "Print",
    outdent: "Decrease indentation",
    indent: "Increase indentation",
    removeFormat: "Remove formatting",
    formatting: "Formatting",
    fontSize: "Font Size",
    align: "Align",
    hr: "Insert Horizontal Rule",
    undo: "Undo",
    redo: "Redo",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    paragraph: "Paragraph",
    code: "Code",
    size1: "Very small",
    size2: "A bit small",
    size3: "Normal",
    size4: "Medium-large",
    size5: "Big",
    size6: "Very big",
    size7: "Maximum",
    defaultFont: "Default Font",
    viewSource: "View Source"
  },
  tree: {
    noNodes: "No nodes available",
    noResults: "No matching nodes found"
  }
};
function getLocale() {
  const val = Array.isArray(navigator.languages) === true && navigator.languages.length !== 0 ? navigator.languages[0] : navigator.language;
  if (typeof val === "string") {
    return val.split(/[-_]/).map((v2, i) => i === 0 ? v2.toLowerCase() : i > 1 || v2.length < 4 ? v2.toUpperCase() : v2[0].toUpperCase() + v2.slice(1).toLowerCase()).join("-");
  }
}
var Plugin2 = createReactivePlugin({
  __qLang: {}
}, {
  // props: object
  // __langConfig: object
  getLocale,
  set(langObject = en_US_default, ssrContext) {
    const lang = {
      ...langObject,
      rtl: langObject.rtl === true,
      getLocale
    };
    {
      lang.set = Plugin2.set;
      if (Plugin2.__langConfig === void 0 || Plugin2.__langConfig.noHtmlAttrs !== true) {
        const el = document.documentElement;
        el.setAttribute("dir", lang.rtl === true ? "rtl" : "ltr");
        el.setAttribute("lang", lang.isoName);
      }
      Object.assign(Plugin2.__qLang, lang);
    }
  },
  install({ $q, lang, ssrContext }) {
    {
      $q.lang = Plugin2.__qLang;
      Plugin2.__langConfig = $q.config.lang;
      if (this.__installed === true) {
        lang !== void 0 && this.set(lang);
      } else {
        this.props = new Proxy(this.__qLang, {
          get() {
            return Reflect.get(...arguments);
          },
          ownKeys(target2) {
            return Reflect.ownKeys(target2).filter((key) => key !== "set" && key !== "getLocale");
          }
        });
        this.set(lang || en_US_default);
      }
    }
  }
});
var Lang_default = Plugin2;
var material_icons_default = {
  name: "material-icons",
  type: {
    positive: "check_circle",
    negative: "warning",
    info: "info",
    warning: "priority_high"
  },
  arrow: {
    up: "arrow_upward",
    right: "arrow_forward",
    down: "arrow_downward",
    left: "arrow_back",
    dropdown: "arrow_drop_down"
  },
  chevron: {
    left: "chevron_left",
    right: "chevron_right"
  },
  colorPicker: {
    spectrum: "gradient",
    tune: "tune",
    palette: "style"
  },
  pullToRefresh: {
    icon: "refresh"
  },
  carousel: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down",
    navigationIcon: "lens"
  },
  chip: {
    remove: "cancel",
    selected: "check"
  },
  datetime: {
    arrowLeft: "chevron_left",
    arrowRight: "chevron_right",
    now: "access_time",
    today: "today"
  },
  editor: {
    bold: "format_bold",
    italic: "format_italic",
    strikethrough: "strikethrough_s",
    underline: "format_underlined",
    unorderedList: "format_list_bulleted",
    orderedList: "format_list_numbered",
    subscript: "vertical_align_bottom",
    superscript: "vertical_align_top",
    hyperlink: "link",
    toggleFullscreen: "fullscreen",
    quote: "format_quote",
    left: "format_align_left",
    center: "format_align_center",
    right: "format_align_right",
    justify: "format_align_justify",
    print: "print",
    outdent: "format_indent_decrease",
    indent: "format_indent_increase",
    removeFormat: "format_clear",
    formatting: "text_format",
    fontSize: "format_size",
    align: "format_align_left",
    hr: "remove",
    undo: "undo",
    redo: "redo",
    heading: "format_size",
    code: "code",
    size: "format_size",
    font: "font_download",
    viewSource: "code"
  },
  expansionItem: {
    icon: "keyboard_arrow_down",
    denseIcon: "arrow_drop_down"
  },
  fab: {
    icon: "add",
    activeIcon: "close"
  },
  field: {
    clear: "cancel",
    error: "error"
  },
  pagination: {
    first: "first_page",
    prev: "keyboard_arrow_left",
    next: "keyboard_arrow_right",
    last: "last_page"
  },
  rating: {
    icon: "grade"
  },
  stepper: {
    done: "check",
    active: "edit",
    error: "warning"
  },
  tabs: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down"
  },
  table: {
    arrowUp: "arrow_upward",
    warning: "warning",
    firstPage: "first_page",
    prevPage: "chevron_left",
    nextPage: "chevron_right",
    lastPage: "last_page"
  },
  tree: {
    icon: "play_arrow"
  },
  uploader: {
    done: "done",
    clear: "clear",
    add: "add_box",
    upload: "cloud_upload",
    removeQueue: "clear_all",
    removeUploaded: "done_all"
  }
};
var Plugin3 = createReactivePlugin({
  iconMapFn: null,
  __qIconSet: {}
}, {
  // props: object
  set(setObject, ssrContext) {
    const def2 = { ...setObject };
    {
      def2.set = Plugin3.set;
      Object.assign(Plugin3.__qIconSet, def2);
    }
  },
  install({ $q, iconSet, ssrContext }) {
    {
      if ($q.config.iconMapFn !== void 0) {
        this.iconMapFn = $q.config.iconMapFn;
      }
      $q.iconSet = this.__qIconSet;
      injectProp($q, "iconMapFn", () => this.iconMapFn, (val) => {
        this.iconMapFn = val;
      });
      if (this.__installed === true) {
        iconSet !== void 0 && this.set(iconSet);
      } else {
        this.props = new Proxy(this.__qIconSet, {
          get() {
            return Reflect.get(...arguments);
          },
          ownKeys(target2) {
            return Reflect.ownKeys(target2).filter((key) => key !== "set");
          }
        });
        this.set(iconSet || material_icons_default);
      }
    }
  }
});
var timelineKey = "_q_t_";
var stepperKey = "_q_s_";
var layoutKey = "_q_l_";
var pageContainerKey = "_q_pc_";
var fabKey = "_q_f_";
var formKey = "_q_fo_";
var tabsKey = "_q_tabs_";
var uploaderKey = "_q_u_";
function emptyRenderFn() {
}
var globalConfig = {};
function isDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (a !== null && b !== null && typeof a === "object" && typeof b === "object") {
    if (a.constructor !== b.constructor) {
      return false;
    }
    let length, i;
    if (a.constructor === Array) {
      length = a.length;
      if (length !== b.length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (isDeepEqual(a[i], b[i]) !== true) {
          return false;
        }
      }
      return true;
    }
    if (a.constructor === Map) {
      if (a.size !== b.size) {
        return false;
      }
      let iter = a.entries();
      i = iter.next();
      while (i.done !== true) {
        if (b.has(i.value[0]) !== true) {
          return false;
        }
        i = iter.next();
      }
      iter = a.entries();
      i = iter.next();
      while (i.done !== true) {
        if (isDeepEqual(i.value[1], b.get(i.value[0])) !== true) {
          return false;
        }
        i = iter.next();
      }
      return true;
    }
    if (a.constructor === Set) {
      if (a.size !== b.size) {
        return false;
      }
      const iter = a.entries();
      i = iter.next();
      while (i.done !== true) {
        if (b.has(i.value[0]) !== true) {
          return false;
        }
        i = iter.next();
      }
      return true;
    }
    if (a.buffer != null && a.buffer.constructor === ArrayBuffer) {
      length = a.length;
      if (length !== b.length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    if (a.constructor === RegExp) {
      return a.source === b.source && a.flags === b.flags;
    }
    if (a.valueOf !== Object.prototype.valueOf) {
      return a.valueOf() === b.valueOf();
    }
    if (a.toString !== Object.prototype.toString) {
      return a.toString() === b.toString();
    }
    const keys = Object.keys(a).filter((key) => a[key] !== void 0);
    length = keys.length;
    if (length !== Object.keys(b).filter((key) => b[key] !== void 0).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (isDeepEqual(a[key], b[key]) !== true) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function isObject(v2) {
  return v2 !== null && typeof v2 === "object" && Array.isArray(v2) !== true;
}
function isDate(v2) {
  return Object.prototype.toString.call(v2) === "[object Date]";
}
function isRegexp(v2) {
  return Object.prototype.toString.call(v2) === "[object RegExp]";
}
function isNumber(v2) {
  return typeof v2 === "number" && isFinite(v2);
}
function createChildApp(appCfg, parentApp) {
  const app2 = createApp(appCfg);
  app2.config.globalProperties = parentApp.config.globalProperties;
  const { reload, ...appContext } = parentApp._context;
  Object.assign(app2._context, appContext);
  return app2;
}
var units = ["B", "KB", "MB", "GB", "TB", "PB"];
function humanStorageSize(bytes, decimals = 1) {
  let u = 0;
  while (parseInt(bytes, 10) >= 1024 && u < units.length - 1) {
    bytes /= 1024;
    ++u;
  }
  return `${bytes.toFixed(decimals)}${units[u]}`;
}
function between(v2, min, max) {
  return max <= min ? min : Math.min(max, Math.max(min, v2));
}
function normalizeToInterval(v2, min, max) {
  if (max <= min) {
    return min;
  }
  const size2 = max - min + 1;
  let index = min + (v2 - min) % size2;
  if (index < min) {
    index = size2 + index;
  }
  return index === 0 ? 0 : index;
}
function pad(v2, length = 2, char = "0") {
  if (v2 === void 0 || v2 === null) {
    return v2;
  }
  const val = "" + v2;
  return val.length >= length ? val : new Array(length - val.length + 1).join(char) + val;
}
var xhr = XMLHttpRequest;
var open = xhr.prototype.open;
var positionValues = ["top", "right", "bottom", "left"];
var stack = [];
var highjackCount = 0;
function translate({ p: p2, pos, active, horiz, reverse, dir }) {
  let x = 1, y = 1;
  if (horiz === true) {
    if (reverse === true) {
      x = -1;
    }
    if (pos === "bottom") {
      y = -1;
    }
    return { transform: `translate3d(${x * (p2 - 100)}%,${active ? 0 : y * -200}%,0)` };
  }
  if (reverse === true) {
    y = -1;
  }
  if (pos === "right") {
    x = -1;
  }
  return { transform: `translate3d(${active ? 0 : dir * x * -200}%,${y * (p2 - 100)}%,0)` };
}
function inc(p2, amount) {
  if (typeof amount !== "number") {
    if (p2 < 25) {
      amount = Math.random() * 3 + 3;
    } else if (p2 < 65) {
      amount = Math.random() * 3;
    } else if (p2 < 85) {
      amount = Math.random() * 2;
    } else if (p2 < 99) {
      amount = 0.6;
    } else {
      amount = 0;
    }
  }
  return between(p2 + amount, 0, 100);
}
function highjackAjax(stackEntry) {
  highjackCount++;
  stack.push(stackEntry);
  if (highjackCount > 1) return;
  xhr.prototype.open = function(_, url) {
    const stopStack = [];
    const loadStart = () => {
      stack.forEach((entry) => {
        if (entry.hijackFilter.value === null || entry.hijackFilter.value(url) === true) {
          entry.start();
          stopStack.push(entry.stop);
        }
      });
    };
    const loadEnd = () => {
      stopStack.forEach((stop2) => {
        stop2();
      });
    };
    this.addEventListener("loadstart", loadStart, { once: true });
    this.addEventListener("loadend", loadEnd, { once: true });
    open.apply(this, arguments);
  };
}
function restoreAjax(start) {
  stack = stack.filter((entry) => entry.start !== start);
  highjackCount = Math.max(0, highjackCount - 1);
  if (highjackCount === 0) {
    xhr.prototype.open = open;
  }
}
var QAjaxBar_default = createComponent({
  name: "QAjaxBar",
  props: {
    position: {
      type: String,
      default: "top",
      validator: (val) => positionValues.includes(val)
    },
    size: {
      type: String,
      default: "2px"
    },
    color: String,
    skipHijack: Boolean,
    reverse: Boolean,
    hijackFilter: Function
  },
  emits: ["start", "stop"],
  setup(props4, { emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const progress = ref(0);
    const onScreen = ref(false);
    const animate = ref(true);
    let sessions = 0, timer2 = null, speed;
    const classes = computed(
      () => `q-loading-bar q-loading-bar--${props4.position}` + (props4.color !== void 0 ? ` bg-${props4.color}` : "") + (animate.value === true ? "" : " no-transition")
    );
    const horizontal = computed(() => props4.position === "top" || props4.position === "bottom");
    const sizeProp = computed(() => horizontal.value === true ? "height" : "width");
    const style2 = computed(() => {
      const active = onScreen.value;
      const obj = translate({
        p: progress.value,
        pos: props4.position,
        active,
        horiz: horizontal.value,
        reverse: proxy.$q.lang.rtl === true && ["top", "bottom"].includes(props4.position) ? props4.reverse === false : props4.reverse,
        dir: proxy.$q.lang.rtl === true ? -1 : 1
      });
      obj[sizeProp.value] = props4.size;
      obj.opacity = active ? 1 : 0;
      return obj;
    });
    const attributes = computed(() => onScreen.value === true ? {
      role: "progressbar",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": progress.value
    } : { "aria-hidden": "true" });
    function start(newSpeed = 300) {
      const oldSpeed = speed;
      speed = Math.max(0, newSpeed) || 0;
      sessions++;
      if (sessions > 1) {
        if (oldSpeed === 0 && newSpeed > 0) {
          planNextStep();
        } else if (timer2 !== null && oldSpeed > 0 && newSpeed <= 0) {
          clearTimeout(timer2);
          timer2 = null;
        }
        return sessions;
      }
      timer2 !== null && clearTimeout(timer2);
      emit2("start");
      progress.value = 0;
      timer2 = setTimeout(() => {
        timer2 = null;
        animate.value = true;
        newSpeed > 0 && planNextStep();
      }, onScreen._value === true ? 500 : 1);
      if (onScreen._value !== true) {
        onScreen.value = true;
        animate.value = false;
      }
      return sessions;
    }
    function increment(amount) {
      if (sessions > 0) {
        progress.value = inc(progress.value, amount);
      }
      return sessions;
    }
    function stop2() {
      sessions = Math.max(0, sessions - 1);
      if (sessions > 0) {
        return sessions;
      }
      if (timer2 !== null) {
        clearTimeout(timer2);
        timer2 = null;
      }
      emit2("stop");
      const end = () => {
        animate.value = true;
        progress.value = 100;
        timer2 = setTimeout(() => {
          timer2 = null;
          onScreen.value = false;
        }, 1e3);
      };
      if (progress.value === 0) {
        timer2 = setTimeout(end, 1);
      } else {
        end();
      }
      return sessions;
    }
    function planNextStep() {
      if (progress.value < 100) {
        timer2 = setTimeout(() => {
          timer2 = null;
          increment();
          planNextStep();
        }, speed);
      }
    }
    let hijacked;
    onMounted(() => {
      if (props4.skipHijack !== true) {
        hijacked = true;
        highjackAjax({
          start,
          stop: stop2,
          hijackFilter: computed(() => props4.hijackFilter || null)
        });
      }
    });
    onBeforeUnmount(() => {
      timer2 !== null && clearTimeout(timer2);
      hijacked === true && restoreAjax(start);
    });
    Object.assign(proxy, { start, stop: stop2, increment });
    return () => h("div", {
      class: classes.value,
      style: style2.value,
      ...attributes.value
    });
  }
});
var useSizeDefaults = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
};
var useSizeProps = {
  size: String
};
function use_size_default(props4, sizes = useSizeDefaults) {
  return computed(() => props4.size !== void 0 ? { fontSize: props4.size in sizes ? `${sizes[props4.size]}px` : props4.size } : null);
}
function hSlot(slot, otherwise) {
  return slot !== void 0 ? slot() || otherwise : otherwise;
}
function hUniqueSlot(slot, otherwise) {
  if (slot !== void 0) {
    const vnode = slot();
    if (vnode !== void 0 && vnode !== null) {
      return vnode.slice();
    }
  }
  return otherwise;
}
function hMergeSlot(slot, source) {
  return slot !== void 0 ? source.concat(slot()) : source;
}
function hMergeSlotSafely(slot, source) {
  if (slot === void 0) {
    return source;
  }
  return source !== void 0 ? source.concat(slot()) : slot();
}
function hDir(tag, data, children, key, condition, getDirsFn) {
  data.key = key + condition;
  const vnode = h(tag, data, children);
  return condition === true ? withDirectives(vnode, getDirsFn()) : vnode;
}
var defaultViewBox = "0 0 24 24";
var sameFn = (i) => i;
var ionFn = (i) => `ionicons ${i}`;
var libMap = {
  "mdi-": (i) => `mdi ${i}`,
  "icon-": sameFn,
  // fontawesome equiv
  "bt-": (i) => `bt ${i}`,
  "eva-": (i) => `eva ${i}`,
  "ion-md": ionFn,
  "ion-ios": ionFn,
  "ion-logo": ionFn,
  "iconfont ": sameFn,
  "ti-": (i) => `themify-icon ${i}`,
  "bi-": (i) => `bootstrap-icons ${i}`
};
var matMap = {
  o_: "-outlined",
  r_: "-round",
  s_: "-sharp"
};
var symMap = {
  sym_o_: "-outlined",
  sym_r_: "-rounded",
  sym_s_: "-sharp"
};
var libRE = new RegExp("^(" + Object.keys(libMap).join("|") + ")");
var matRE = new RegExp("^(" + Object.keys(matMap).join("|") + ")");
var symRE = new RegExp("^(" + Object.keys(symMap).join("|") + ")");
var mRE = /^[Mm]\s?[-+]?\.?\d/;
var imgRE = /^img:/;
var svgUseRE = /^svguse:/;
var ionRE = /^ion-/;
var faRE = /^(fa-(classic|sharp|solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /;
var QIcon_default = createComponent({
  name: "QIcon",
  props: {
    ...useSizeProps,
    tag: {
      type: String,
      default: "i"
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  setup(props4, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const sizeStyle = use_size_default(props4);
    const classes = computed(
      () => "q-icon" + (props4.left === true ? " on-left" : "") + (props4.right === true ? " on-right" : "") + (props4.color !== void 0 ? ` text-${props4.color}` : "")
    );
    const type = computed(() => {
      let cls;
      let icon2 = props4.name;
      if (icon2 === "none" || !icon2) {
        return { none: true };
      }
      if ($q.iconMapFn !== null) {
        const res = $q.iconMapFn(icon2);
        if (res !== void 0) {
          if (res.icon !== void 0) {
            icon2 = res.icon;
            if (icon2 === "none" || !icon2) {
              return { none: true };
            }
          } else {
            return {
              cls: res.cls,
              content: res.content !== void 0 ? res.content : " "
            };
          }
        }
      }
      if (mRE.test(icon2) === true) {
        const [def2, viewBox = defaultViewBox] = icon2.split("|");
        return {
          svg: true,
          viewBox,
          nodes: def2.split("&&").map((path) => {
            const [d, style2, transform2] = path.split("@@");
            return h("path", { style: style2, d, transform: transform2 });
          })
        };
      }
      if (imgRE.test(icon2) === true) {
        return {
          img: true,
          src: icon2.substring(4)
        };
      }
      if (svgUseRE.test(icon2) === true) {
        const [def2, viewBox = defaultViewBox] = icon2.split("|");
        return {
          svguse: true,
          src: def2.substring(7),
          viewBox
        };
      }
      let content = " ";
      const matches2 = icon2.match(libRE);
      if (matches2 !== null) {
        cls = libMap[matches2[1]](icon2);
      } else if (faRE.test(icon2) === true) {
        cls = icon2;
      } else if (ionRE.test(icon2) === true) {
        cls = `ionicons ion-${$q.platform.is.ios === true ? "ios" : "md"}${icon2.substring(3)}`;
      } else if (symRE.test(icon2) === true) {
        cls = "notranslate material-symbols";
        const matches22 = icon2.match(symRE);
        if (matches22 !== null) {
          icon2 = icon2.substring(6);
          cls += symMap[matches22[1]];
        }
        content = icon2;
      } else {
        cls = "notranslate material-icons";
        const matches22 = icon2.match(matRE);
        if (matches22 !== null) {
          icon2 = icon2.substring(2);
          cls += matMap[matches22[1]];
        }
        content = icon2;
      }
      return {
        cls,
        content
      };
    });
    return () => {
      const data = {
        class: classes.value,
        style: sizeStyle.value,
        "aria-hidden": "true",
        role: "presentation"
      };
      if (type.value.none === true) {
        return h(props4.tag, data, hSlot(slots.default));
      }
      if (type.value.img === true) {
        return h(props4.tag, data, hMergeSlot(slots.default, [
          h("img", { src: type.value.src })
        ]));
      }
      if (type.value.svg === true) {
        return h(props4.tag, data, hMergeSlot(slots.default, [
          h("svg", {
            viewBox: type.value.viewBox || "0 0 24 24"
          }, type.value.nodes)
        ]));
      }
      if (type.value.svguse === true) {
        return h(props4.tag, data, hMergeSlot(slots.default, [
          h("svg", {
            viewBox: type.value.viewBox
          }, [
            h("use", { "xlink:href": type.value.src })
          ])
        ]));
      }
      if (type.value.cls !== void 0) {
        data.class += " " + type.value.cls;
      }
      return h(props4.tag, data, hMergeSlot(slots.default, [
        type.value.content
      ]));
    };
  }
});
createComponent({
  name: "QAvatar",
  props: {
    ...useSizeProps,
    fontSize: String,
    color: String,
    textColor: String,
    icon: String,
    square: Boolean,
    rounded: Boolean
  },
  setup(props4, { slots }) {
    const sizeStyle = use_size_default(props4);
    const classes = computed(
      () => "q-avatar" + (props4.color ? ` bg-${props4.color}` : "") + (props4.textColor ? ` text-${props4.textColor} q-chip--colored` : "") + (props4.square === true ? " q-avatar--square" : props4.rounded === true ? " rounded-borders" : "")
    );
    const contentStyle = computed(() => props4.fontSize ? { fontSize: props4.fontSize } : null);
    return () => {
      const icon2 = props4.icon !== void 0 ? [h(QIcon_default, { name: props4.icon })] : void 0;
      return h("div", {
        class: classes.value,
        style: sizeStyle.value
      }, [
        h("div", {
          class: "q-avatar__content row flex-center overflow-hidden",
          style: contentStyle.value
        }, hMergeSlotSafely(slots.default, icon2))
      ]);
    };
  }
});
var alignValues = ["top", "middle", "bottom"];
createComponent({
  name: "QBadge",
  props: {
    color: String,
    textColor: String,
    floating: Boolean,
    transparent: Boolean,
    multiLine: Boolean,
    outline: Boolean,
    rounded: Boolean,
    label: [Number, String],
    align: {
      type: String,
      validator: (v2) => alignValues.includes(v2)
    }
  },
  setup(props4, { slots }) {
    const style2 = computed(() => {
      return props4.align !== void 0 ? { verticalAlign: props4.align } : null;
    });
    const classes = computed(() => {
      const text = props4.outline === true ? props4.color || props4.textColor : props4.textColor;
      return `q-badge flex inline items-center no-wrap q-badge--${props4.multiLine === true ? "multi" : "single"}-line` + (props4.outline === true ? " q-badge--outline" : props4.color !== void 0 ? ` bg-${props4.color}` : "") + (text !== void 0 ? ` text-${text}` : "") + (props4.floating === true ? " q-badge--floating" : "") + (props4.rounded === true ? " q-badge--rounded" : "") + (props4.transparent === true ? " q-badge--transparent" : "");
    });
    return () => h("div", {
      class: classes.value,
      style: style2.value,
      role: "status",
      "aria-label": props4.label
    }, hMergeSlot(slots.default, props4.label !== void 0 ? [props4.label] : []));
  }
});
var useDarkProps = {
  dark: {
    type: Boolean,
    default: null
  }
};
function use_dark_default(props4, $q) {
  return computed(() => props4.dark === null ? $q.dark.isActive : props4.dark);
}
createComponent({
  name: "QBanner",
  props: {
    ...useDarkProps,
    inlineActions: Boolean,
    dense: Boolean,
    rounded: Boolean
  },
  setup(props4, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = use_dark_default(props4, $q);
    const classes = computed(
      () => "q-banner row items-center" + (props4.dense === true ? " q-banner--dense" : "") + (isDark.value === true ? " q-banner--dark q-dark" : "") + (props4.rounded === true ? " rounded-borders" : "")
    );
    const actionClass = computed(
      () => `q-banner__actions row items-center justify-end col-${props4.inlineActions === true ? "auto" : "all"}`
    );
    return () => {
      const child = [
        h("div", {
          class: "q-banner__avatar col-auto row items-center self-start"
        }, hSlot(slots.avatar)),
        h("div", {
          class: "q-banner__content col text-body2"
        }, hSlot(slots.default))
      ];
      const actions = hSlot(slots.action);
      actions !== void 0 && child.push(
        h("div", { class: actionClass.value }, actions)
      );
      return h("div", {
        class: classes.value + (props4.inlineActions === false && actions !== void 0 ? " q-banner--top-padding" : ""),
        role: "alert"
      }, child);
    };
  }
});
createComponent({
  name: "QBar",
  props: {
    ...useDarkProps,
    dense: Boolean
  },
  setup(props4, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = use_dark_default(props4, $q);
    const classes = computed(
      () => `q-bar row no-wrap items-center q-bar--${props4.dense === true ? "dense" : "standard"}  q-bar--${isDark.value === true ? "dark" : "light"}`
    );
    return () => h("div", {
      class: classes.value,
      role: "toolbar"
    }, hSlot(slots.default));
  }
});
var alignMap = {
  left: "start",
  center: "center",
  right: "end",
  between: "between",
  around: "around",
  evenly: "evenly",
  stretch: "stretch"
};
var alignValues2 = Object.keys(alignMap);
var useAlignProps = {
  align: {
    type: String,
    validator: (v2) => alignValues2.includes(v2)
  }
};
function use_align_default(props4) {
  return computed(() => {
    const align = props4.align === void 0 ? props4.vertical === true ? "stretch" : "left" : props4.align;
    return `${props4.vertical === true ? "items" : "justify"}-${alignMap[align]}`;
  });
}
function getParentProxy(proxy) {
  if (Object(proxy.$parent) === proxy.$parent) {
    return proxy.$parent;
  }
  let { parent } = proxy.$;
  while (Object(parent) === parent) {
    if (Object(parent.proxy) === parent.proxy) {
      return parent.proxy;
    }
    parent = parent.parent;
  }
}
function fillNormalizedVNodes(children, vnode) {
  if (typeof vnode.type === "symbol") {
    if (Array.isArray(vnode.children) === true) {
      vnode.children.forEach((child) => {
        fillNormalizedVNodes(children, child);
      });
    }
  } else {
    children.add(vnode);
  }
}
function getNormalizedVNodes(vnodes) {
  const children = /* @__PURE__ */ new Set();
  vnodes.forEach((vnode) => {
    fillNormalizedVNodes(children, vnode);
  });
  return Array.from(children);
}
function vmHasRouter(vm2) {
  return vm2.appContext.config.globalProperties.$router !== void 0;
}
function vmIsDestroyed(vm2) {
  return vm2.isUnmounted === true || vm2.isDeactivated === true;
}
var disabledValues = ["", true];
createComponent({
  name: "QBreadcrumbs",
  props: {
    ...useAlignProps,
    separator: {
      type: String,
      default: "/"
    },
    separatorColor: String,
    activeColor: {
      type: String,
      default: "primary"
    },
    gutter: {
      type: String,
      validator: (v2) => ["none", "xs", "sm", "md", "lg", "xl"].includes(v2),
      default: "sm"
    }
  },
  setup(props4, { slots }) {
    const alignClass = use_align_default(props4);
    const classes = computed(
      () => `flex items-center ${alignClass.value}${props4.gutter === "none" ? "" : ` q-gutter-${props4.gutter}`}`
    );
    const sepClass = computed(() => props4.separatorColor ? ` text-${props4.separatorColor}` : "");
    const activeClass = computed(() => ` text-${props4.activeColor}`);
    return () => {
      if (slots.default === void 0) return;
      const vnodes = getNormalizedVNodes(
        hSlot(slots.default)
      );
      if (vnodes.length === 0) return;
      let els = 1;
      const child = [], len = vnodes.filter((c) => c.type !== void 0 && c.type.name === "QBreadcrumbsEl").length, separator = slots.separator !== void 0 ? slots.separator : () => props4.separator;
      vnodes.forEach((comp) => {
        if (comp.type !== void 0 && comp.type.name === "QBreadcrumbsEl") {
          const middle = els < len;
          const disabled = comp.props !== null && disabledValues.includes(comp.props.disable);
          const cls = (middle === true ? "" : " q-breadcrumbs--last") + (disabled !== true && middle === true ? activeClass.value : "");
          els++;
          child.push(
            h("div", {
              class: `flex items-center${cls}`
            }, [comp])
          );
          if (middle === true) {
            child.push(
              h("div", {
                class: "q-breadcrumbs__separator" + sepClass.value
              }, separator())
            );
          }
        } else {
          child.push(comp);
        }
      });
      return h("div", {
        class: "q-breadcrumbs"
      }, [
        h("div", { class: classes.value }, child)
      ]);
    };
  }
});
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key], outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue) {
        return false;
      }
    } else if (Array.isArray(outerValue) === false || outerValue.length !== innerValue.length || innerValue.some((value2, i) => value2 !== outerValue[i])) {
      return false;
    }
  }
  return true;
}
function isEquivalentArray(a, b) {
  return Array.isArray(b) === true ? a.length === b.length && a.every((value2, i) => value2 === b[i]) : a.length === 1 && a[0] === b;
}
function isSameRouteLocationParamsValue(a, b) {
  return Array.isArray(a) === true ? isEquivalentArray(a, b) : Array.isArray(b) === true ? isEquivalentArray(b, a) : a === b;
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (isSameRouteLocationParamsValue(a[key], b[key]) === false) {
      return false;
    }
  }
  return true;
}
var useRouterLinkNonMatchingProps = {
  // router-link
  to: [String, Object],
  replace: Boolean,
  // regular <a> link
  href: String,
  target: String,
  // state
  disable: Boolean
};
var useRouterLinkProps = {
  ...useRouterLinkNonMatchingProps,
  // router-link
  exact: Boolean,
  activeClass: {
    type: String,
    default: "q-router-link--active"
  },
  exactActiveClass: {
    type: String,
    default: "q-router-link--exact-active"
  }
};
function use_router_link_default({ fallbackTag, useDisableForRouterLinkProps = true } = {}) {
  const vm2 = getCurrentInstance();
  const { props: props4, proxy, emit: emit2 } = vm2;
  const hasRouter = vmHasRouter(vm2);
  const hasHrefLink = computed(() => props4.disable !== true && props4.href !== void 0);
  const hasRouterLinkProps = useDisableForRouterLinkProps === true ? computed(
    () => hasRouter === true && props4.disable !== true && hasHrefLink.value !== true && props4.to !== void 0 && props4.to !== null && props4.to !== ""
  ) : computed(
    () => hasRouter === true && hasHrefLink.value !== true && props4.to !== void 0 && props4.to !== null && props4.to !== ""
  );
  const resolvedLink = computed(() => hasRouterLinkProps.value === true ? getLink(props4.to) : null);
  const hasRouterLink = computed(() => resolvedLink.value !== null);
  const hasLink = computed(() => hasHrefLink.value === true || hasRouterLink.value === true);
  const linkTag = computed(() => props4.type === "a" || hasLink.value === true ? "a" : props4.tag || fallbackTag || "div");
  const linkAttrs = computed(() => hasHrefLink.value === true ? {
    href: props4.href,
    target: props4.target
  } : hasRouterLink.value === true ? {
    href: resolvedLink.value.href,
    target: props4.target
  } : {});
  const linkActiveIndex = computed(() => {
    if (hasRouterLink.value === false) {
      return -1;
    }
    const { matched } = resolvedLink.value, { length } = matched, routeMatched = matched[length - 1];
    if (routeMatched === void 0) {
      return -1;
    }
    const currentMatched = proxy.$route.matched;
    if (currentMatched.length === 0) {
      return -1;
    }
    const index = currentMatched.findIndex(
      isSameRouteRecord.bind(null, routeMatched)
    );
    if (index !== -1) {
      return index;
    }
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(
        isSameRouteRecord.bind(null, matched[length - 2])
      ) : index
    );
  });
  const linkIsActive = computed(
    () => hasRouterLink.value === true && linkActiveIndex.value !== -1 && includesParams(proxy.$route.params, resolvedLink.value.params)
  );
  const linkIsExactActive = computed(
    () => linkIsActive.value === true && linkActiveIndex.value === proxy.$route.matched.length - 1 && isSameRouteLocationParams(proxy.$route.params, resolvedLink.value.params)
  );
  const linkClass = computed(() => hasRouterLink.value === true ? linkIsExactActive.value === true ? ` ${props4.exactActiveClass} ${props4.activeClass}` : props4.exact === true ? "" : linkIsActive.value === true ? ` ${props4.activeClass}` : "" : "");
  function getLink(to) {
    try {
      return proxy.$router.resolve(to);
    } catch (_) {
    }
    return null;
  }
  function navigateToRouterLink(e, { returnRouterError, to = props4.to, replace = props4.replace } = {}) {
    if (props4.disable === true) {
      e.preventDefault();
      return Promise.resolve(false);
    }
    if (
      // don't redirect with control keys;
      // should match RouterLink from Vue Router
      e.metaKey || e.altKey || e.ctrlKey || e.shiftKey || e.button !== void 0 && e.button !== 0 || props4.target === "_blank"
    ) {
      return Promise.resolve(false);
    }
    e.preventDefault();
    const promise = proxy.$router[replace === true ? "replace" : "push"](to);
    return returnRouterError === true ? promise : promise.then(() => {
    }).catch(() => {
    });
  }
  function navigateOnClick(e) {
    if (hasRouterLink.value === true) {
      const go = (opts) => navigateToRouterLink(e, opts);
      emit2("click", e, go);
      e.defaultPrevented !== true && go();
    } else {
      emit2("click", e);
    }
  }
  return {
    hasRouterLink,
    hasHrefLink,
    hasLink,
    linkTag,
    resolvedLink,
    linkIsActive,
    linkIsExactActive,
    linkClass,
    linkAttrs,
    getLink,
    navigateToRouterLink,
    navigateOnClick
  };
}
createComponent({
  name: "QBreadcrumbsEl",
  props: {
    ...useRouterLinkProps,
    label: String,
    icon: String,
    tag: {
      type: String,
      default: "span"
    }
  },
  emits: ["click"],
  setup(props4, { slots }) {
    const { linkTag, linkAttrs, linkClass, navigateOnClick } = use_router_link_default();
    const data = computed(() => {
      return {
        class: "q-breadcrumbs__el q-link flex inline items-center relative-position " + (props4.disable !== true ? "q-link--focusable" + linkClass.value : "q-breadcrumbs__el--disable"),
        ...linkAttrs.value,
        onClick: navigateOnClick
      };
    });
    const iconClass = computed(
      () => "q-breadcrumbs__el-icon" + (props4.label !== void 0 ? " q-breadcrumbs__el-icon--with-label" : "")
    );
    return () => {
      const child = [];
      props4.icon !== void 0 && child.push(
        h(QIcon_default, {
          class: iconClass.value,
          name: props4.icon
        })
      );
      props4.label !== void 0 && child.push(props4.label);
      return h(
        linkTag.value,
        { ...data.value },
        hMergeSlot(slots.default, child)
      );
    };
  }
});
var useSpinnerProps = {
  size: {
    type: [String, Number],
    default: "1em"
  },
  color: String
};
function useSpinner(props4) {
  return {
    cSize: computed(() => props4.size in useSizeDefaults ? `${useSizeDefaults[props4.size]}px` : props4.size),
    classes: computed(
      () => "q-spinner" + (props4.color ? ` text-${props4.color}` : "")
    )
  };
}
var QSpinner_default = createComponent({
  name: "QSpinner",
  props: {
    ...useSpinnerProps,
    thickness: {
      type: Number,
      default: 5
    }
  },
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value + " q-spinner-mat",
      width: cSize.value,
      height: cSize.value,
      viewBox: "25 25 50 50"
    }, [
      h("circle", {
        class: "path",
        cx: "50",
        cy: "50",
        r: "20",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": props4.thickness,
        "stroke-miterlimit": "10"
      })
    ]);
  }
});
function offset(el) {
  if (el === window) {
    return { top: 0, left: 0 };
  }
  const { top, left } = el.getBoundingClientRect();
  return { top, left };
}
function height(el) {
  return el === window ? window.innerHeight : el.getBoundingClientRect().height;
}
function css(element, css2) {
  const style2 = element.style;
  for (const prop in css2) {
    style2[prop] = css2[prop];
  }
}
function getElement(el) {
  if (el === void 0 || el === null) {
    return void 0;
  }
  if (typeof el === "string") {
    try {
      return document.querySelector(el) || void 0;
    } catch (err) {
      return void 0;
    }
  }
  const target2 = unref(el);
  if (target2) {
    return target2.$el || target2;
  }
}
function childHasFocus(el, focusedEl) {
  if (el === void 0 || el === null || el.contains(focusedEl) === true) {
    return true;
  }
  for (let next = el.nextElementSibling; next !== null; next = next.nextElementSibling) {
    if (next.contains(focusedEl)) {
      return true;
    }
  }
  return false;
}
function throttle_default(fn, limit = 250) {
  let wait = false, result;
  return function() {
    if (wait === false) {
      wait = true;
      setTimeout(() => {
        wait = false;
      }, limit);
      result = fn.apply(this, arguments);
    }
    return result;
  };
}
function showRipple(evt, el, ctx, forceCenter) {
  ctx.modifiers.stop === true && stop(evt);
  const color = ctx.modifiers.color;
  let center = ctx.modifiers.center;
  center = center === true || forceCenter === true;
  const node = document.createElement("span"), innerNode = document.createElement("span"), pos = position(evt), { left, top, width: width3, height: height2 } = el.getBoundingClientRect(), diameter2 = Math.sqrt(width3 * width3 + height2 * height2), radius2 = diameter2 / 2, centerX = `${(width3 - diameter2) / 2}px`, x = center ? centerX : `${pos.left - left - radius2}px`, centerY = `${(height2 - diameter2) / 2}px`, y = center ? centerY : `${pos.top - top - radius2}px`;
  innerNode.className = "q-ripple__inner";
  css(innerNode, {
    height: `${diameter2}px`,
    width: `${diameter2}px`,
    transform: `translate3d(${x},${y},0) scale3d(.2,.2,1)`,
    opacity: 0
  });
  node.className = `q-ripple${color ? " text-" + color : ""}`;
  node.setAttribute("dir", "ltr");
  node.appendChild(innerNode);
  el.appendChild(node);
  const abort = () => {
    node.remove();
    clearTimeout(timer2);
  };
  ctx.abort.push(abort);
  let timer2 = setTimeout(() => {
    innerNode.classList.add("q-ripple__inner--enter");
    innerNode.style.transform = `translate3d(${centerX},${centerY},0) scale3d(1,1,1)`;
    innerNode.style.opacity = 0.2;
    timer2 = setTimeout(() => {
      innerNode.classList.remove("q-ripple__inner--enter");
      innerNode.classList.add("q-ripple__inner--leave");
      innerNode.style.opacity = 0;
      timer2 = setTimeout(() => {
        node.remove();
        ctx.abort.splice(ctx.abort.indexOf(abort), 1);
      }, 275);
    }, 250);
  }, 50);
}
function updateModifiers(ctx, { modifiers, value: value2, arg }) {
  const cfg = Object.assign({}, ctx.cfg.ripple, modifiers, value2);
  ctx.modifiers = {
    early: cfg.early === true,
    stop: cfg.stop === true,
    center: cfg.center === true,
    color: cfg.color || arg,
    keyCodes: [].concat(cfg.keyCodes || 13)
  };
}
var Ripple_default = createDirective(
  {
    name: "ripple",
    beforeMount(el, binding) {
      const cfg = binding.instance.$.appContext.config.globalProperties.$q.config || {};
      if (cfg.ripple === false) {
        return;
      }
      const ctx = {
        cfg,
        enabled: binding.value !== false,
        modifiers: {},
        abort: [],
        start(evt) {
          if (ctx.enabled === true && evt.qSkipRipple !== true && evt.type === (ctx.modifiers.early === true ? "pointerdown" : "click")) {
            showRipple(evt, el, ctx, evt.qKeyEvent === true);
          }
        },
        keystart: throttle_default((evt) => {
          if (ctx.enabled === true && evt.qSkipRipple !== true && isKeyCode(evt, ctx.modifiers.keyCodes) === true && evt.type === `key${ctx.modifiers.early === true ? "down" : "up"}`) {
            showRipple(evt, el, ctx, true);
          }
        }, 300)
      };
      updateModifiers(ctx, binding);
      el.__qripple = ctx;
      addEvt(ctx, "main", [
        [el, "pointerdown", "start", "passive"],
        [el, "click", "start", "passive"],
        [el, "keydown", "keystart", "passive"],
        [el, "keyup", "keystart", "passive"]
      ]);
    },
    updated(el, binding) {
      if (binding.oldValue !== binding.value) {
        const ctx = el.__qripple;
        if (ctx !== void 0) {
          ctx.enabled = binding.value !== false;
          if (ctx.enabled === true && Object(binding.value) === binding.value) {
            updateModifiers(ctx, binding);
          }
        }
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qripple;
      if (ctx !== void 0) {
        ctx.abort.forEach((fn) => {
          fn();
        });
        cleanEvt(ctx, "main");
        delete el._qripple;
      }
    }
  }
);
var btnPadding = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
};
var defaultSizes = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
};
var formTypes = ["button", "submit", "reset"];
var mediaTypeRE = /[^\s]\/[^\s]/;
var btnDesignOptions = ["flat", "outline", "push", "unelevated"];
function getBtnDesign(props4, defaultValue) {
  if (props4.flat === true) return "flat";
  if (props4.outline === true) return "outline";
  if (props4.push === true) return "push";
  if (props4.unelevated === true) return "unelevated";
  return defaultValue;
}
function getBtnDesignAttr(props4) {
  const design = getBtnDesign(props4);
  return design !== void 0 ? { [design]: true } : {};
}
var nonRoundBtnProps = {
  ...useSizeProps,
  ...useRouterLinkNonMatchingProps,
  type: {
    type: String,
    default: "button"
  },
  label: [Number, String],
  icon: String,
  iconRight: String,
  ...btnDesignOptions.reduce(
    (acc, val) => (acc[val] = Boolean) && acc,
    {}
  ),
  square: Boolean,
  rounded: Boolean,
  glossy: Boolean,
  size: String,
  fab: Boolean,
  fabMini: Boolean,
  padding: String,
  color: String,
  textColor: String,
  noCaps: Boolean,
  noWrap: Boolean,
  dense: Boolean,
  tabindex: [Number, String],
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  align: {
    ...useAlignProps.align,
    default: "center"
  },
  stack: Boolean,
  stretch: Boolean,
  loading: {
    type: Boolean,
    default: null
  },
  disable: Boolean
};
var useBtnProps = {
  ...nonRoundBtnProps,
  round: Boolean
};
function use_btn_default(props4) {
  const sizeStyle = use_size_default(props4, defaultSizes);
  const alignClass = use_align_default(props4);
  const { hasRouterLink, hasLink, linkTag, linkAttrs, navigateOnClick } = use_router_link_default({
    fallbackTag: "button"
  });
  const style2 = computed(() => {
    const obj = props4.fab === false && props4.fabMini === false ? sizeStyle.value : {};
    return props4.padding !== void 0 ? Object.assign({}, obj, {
      padding: props4.padding.split(/\s+/).map((v2) => v2 in btnPadding ? btnPadding[v2] + "px" : v2).join(" "),
      minWidth: "0",
      minHeight: "0"
    }) : obj;
  });
  const isRounded = computed(
    () => props4.rounded === true || props4.fab === true || props4.fabMini === true
  );
  const isActionable = computed(
    () => props4.disable !== true && props4.loading !== true
  );
  const tabIndex = computed(() => isActionable.value === true ? props4.tabindex || 0 : -1);
  const design = computed(() => getBtnDesign(props4, "standard"));
  const attributes = computed(() => {
    const acc = { tabindex: tabIndex.value };
    if (hasLink.value === true) {
      Object.assign(acc, linkAttrs.value);
    } else if (formTypes.includes(props4.type) === true) {
      acc.type = props4.type;
    }
    if (linkTag.value === "a") {
      if (props4.disable === true) {
        acc["aria-disabled"] = "true";
      } else if (acc.href === void 0) {
        acc.role = "button";
      }
      if (hasRouterLink.value !== true && mediaTypeRE.test(props4.type) === true) {
        acc.type = props4.type;
      }
    } else if (props4.disable === true) {
      acc.disabled = "";
      acc["aria-disabled"] = "true";
    }
    if (props4.loading === true && props4.percentage !== void 0) {
      Object.assign(acc, {
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": props4.percentage
      });
    }
    return acc;
  });
  const classes = computed(() => {
    let colors;
    if (props4.color !== void 0) {
      if (props4.flat === true || props4.outline === true) {
        colors = `text-${props4.textColor || props4.color}`;
      } else {
        colors = `bg-${props4.color} text-${props4.textColor || "white"}`;
      }
    } else if (props4.textColor) {
      colors = `text-${props4.textColor}`;
    }
    const shape = props4.round === true ? "round" : `rectangle${isRounded.value === true ? " q-btn--rounded" : props4.square === true ? " q-btn--square" : ""}`;
    return `q-btn--${design.value} q-btn--${shape}` + (colors !== void 0 ? " " + colors : "") + (isActionable.value === true ? " q-btn--actionable q-focusable q-hoverable" : props4.disable === true ? " disabled" : "") + (props4.fab === true ? " q-btn--fab" : props4.fabMini === true ? " q-btn--fab-mini" : "") + (props4.noCaps === true ? " q-btn--no-uppercase" : "") + (props4.dense === true ? " q-btn--dense" : "") + (props4.stretch === true ? " no-border-radius self-stretch" : "") + (props4.glossy === true ? " glossy" : "") + (props4.square ? " q-btn--square" : "");
  });
  const innerClasses = computed(
    () => alignClass.value + (props4.stack === true ? " column" : " row") + (props4.noWrap === true ? " no-wrap text-no-wrap" : "") + (props4.loading === true ? " q-btn__content--hidden" : "")
  );
  return {
    classes,
    style: style2,
    innerClasses,
    attributes,
    hasLink,
    linkTag,
    navigateOnClick,
    isActionable
  };
}
var { passiveCapture } = listenOpts;
var touchTarget = null;
var keyboardTarget = null;
var mouseTarget = null;
var QBtn_default = createComponent({
  name: "QBtn",
  props: {
    ...useBtnProps,
    percentage: Number,
    darkPercentage: Boolean,
    onTouchstart: [Function, Array]
  },
  emits: ["click", "keydown", "mousedown", "keyup"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const {
      classes,
      style: style2,
      innerClasses,
      attributes,
      hasLink,
      linkTag,
      navigateOnClick,
      isActionable
    } = use_btn_default(props4);
    const rootRef = ref(null);
    const blurTargetRef = ref(null);
    let localTouchTargetEl = null, avoidMouseRipple, mouseTimer = null;
    const hasLabel = computed(
      () => props4.label !== void 0 && props4.label !== null && props4.label !== ""
    );
    const ripple = computed(() => props4.disable === true || props4.ripple === false ? false : {
      keyCodes: hasLink.value === true ? [13, 32] : [13],
      ...props4.ripple === true ? {} : props4.ripple
    });
    const rippleProps = computed(() => ({ center: props4.round }));
    const percentageStyle = computed(() => {
      const val = Math.max(0, Math.min(100, props4.percentage));
      return val > 0 ? { transition: "transform 0.6s", transform: `translateX(${val - 100}%)` } : {};
    });
    const onEvents = computed(() => {
      if (props4.loading === true) {
        return {
          onMousedown: onLoadingEvt,
          onTouchstart: onLoadingEvt,
          onClick: onLoadingEvt,
          onKeydown: onLoadingEvt,
          onKeyup: onLoadingEvt
        };
      }
      if (isActionable.value === true) {
        const acc = {
          onClick,
          onKeydown: onKeydown2,
          onMousedown
        };
        if (proxy.$q.platform.has.touch === true) {
          const suffix = props4.onTouchstart !== void 0 ? "" : "Passive";
          acc[`onTouchstart${suffix}`] = onTouchstart;
        }
        return acc;
      }
      return {
        // needed; especially for disabled <a> tags
        onClick: stopAndPrevent
      };
    });
    const nodeProps = computed(() => ({
      ref: rootRef,
      class: "q-btn q-btn-item non-selectable no-outline " + classes.value,
      style: style2.value,
      ...attributes.value,
      ...onEvents.value
    }));
    function onClick(e) {
      if (rootRef.value === null) return;
      if (e !== void 0) {
        if (e.defaultPrevented === true) {
          return;
        }
        const el = document.activeElement;
        if (props4.type === "submit" && el !== document.body && rootRef.value.contains(el) === false && el.contains(rootRef.value) === false) {
          rootRef.value.focus();
          const onClickCleanup = () => {
            document.removeEventListener("keydown", stopAndPrevent, true);
            document.removeEventListener("keyup", onClickCleanup, passiveCapture);
            rootRef.value !== null && rootRef.value.removeEventListener("blur", onClickCleanup, passiveCapture);
          };
          document.addEventListener("keydown", stopAndPrevent, true);
          document.addEventListener("keyup", onClickCleanup, passiveCapture);
          rootRef.value.addEventListener("blur", onClickCleanup, passiveCapture);
        }
      }
      navigateOnClick(e);
    }
    function onKeydown2(e) {
      if (rootRef.value === null) return;
      emit2("keydown", e);
      if (isKeyCode(e, [13, 32]) === true && keyboardTarget !== rootRef.value) {
        keyboardTarget !== null && cleanup();
        if (e.defaultPrevented !== true) {
          rootRef.value.focus();
          keyboardTarget = rootRef.value;
          rootRef.value.classList.add("q-btn--active");
          document.addEventListener("keyup", onPressEnd, true);
          rootRef.value.addEventListener("blur", onPressEnd, passiveCapture);
        }
        stopAndPrevent(e);
      }
    }
    function onTouchstart(e) {
      if (rootRef.value === null) return;
      emit2("touchstart", e);
      if (e.defaultPrevented === true) return;
      if (touchTarget !== rootRef.value) {
        touchTarget !== null && cleanup();
        touchTarget = rootRef.value;
        localTouchTargetEl = e.target;
        localTouchTargetEl.addEventListener("touchcancel", onPressEnd, passiveCapture);
        localTouchTargetEl.addEventListener("touchend", onPressEnd, passiveCapture);
      }
      avoidMouseRipple = true;
      mouseTimer !== null && clearTimeout(mouseTimer);
      mouseTimer = setTimeout(() => {
        mouseTimer = null;
        avoidMouseRipple = false;
      }, 200);
    }
    function onMousedown(e) {
      if (rootRef.value === null) return;
      e.qSkipRipple = avoidMouseRipple === true;
      emit2("mousedown", e);
      if (e.defaultPrevented !== true && mouseTarget !== rootRef.value) {
        mouseTarget !== null && cleanup();
        mouseTarget = rootRef.value;
        rootRef.value.classList.add("q-btn--active");
        document.addEventListener("mouseup", onPressEnd, passiveCapture);
      }
    }
    function onPressEnd(e) {
      if (rootRef.value === null) return;
      if (e !== void 0 && e.type === "blur" && document.activeElement === rootRef.value) {
        return;
      }
      if (e !== void 0 && e.type === "keyup") {
        if (keyboardTarget === rootRef.value && isKeyCode(e, [13, 32]) === true) {
          const evt = new MouseEvent("click", e);
          evt.qKeyEvent = true;
          e.defaultPrevented === true && prevent(evt);
          e.cancelBubble === true && stop(evt);
          rootRef.value.dispatchEvent(evt);
          stopAndPrevent(e);
          e.qKeyEvent = true;
        }
        emit2("keyup", e);
      }
      cleanup();
    }
    function cleanup(destroying) {
      const blurTarget = blurTargetRef.value;
      if (destroying !== true && (touchTarget === rootRef.value || mouseTarget === rootRef.value) && blurTarget !== null && blurTarget !== document.activeElement) {
        blurTarget.setAttribute("tabindex", -1);
        blurTarget.focus();
      }
      if (touchTarget === rootRef.value) {
        if (localTouchTargetEl !== null) {
          localTouchTargetEl.removeEventListener("touchcancel", onPressEnd, passiveCapture);
          localTouchTargetEl.removeEventListener("touchend", onPressEnd, passiveCapture);
        }
        touchTarget = localTouchTargetEl = null;
      }
      if (mouseTarget === rootRef.value) {
        document.removeEventListener("mouseup", onPressEnd, passiveCapture);
        mouseTarget = null;
      }
      if (keyboardTarget === rootRef.value) {
        document.removeEventListener("keyup", onPressEnd, true);
        rootRef.value !== null && rootRef.value.removeEventListener("blur", onPressEnd, passiveCapture);
        keyboardTarget = null;
      }
      rootRef.value !== null && rootRef.value.classList.remove("q-btn--active");
    }
    function onLoadingEvt(evt) {
      stopAndPrevent(evt);
      evt.qSkipRipple = true;
    }
    onBeforeUnmount(() => {
      cleanup(true);
    });
    Object.assign(proxy, {
      click: (e) => {
        if (isActionable.value === true) {
          onClick(e);
        }
      }
    });
    return () => {
      let inner = [];
      props4.icon !== void 0 && inner.push(
        h(QIcon_default, {
          name: props4.icon,
          left: props4.stack !== true && hasLabel.value === true,
          role: "img"
        })
      );
      hasLabel.value === true && inner.push(
        h("span", { class: "block" }, [props4.label])
      );
      inner = hMergeSlot(slots.default, inner);
      if (props4.iconRight !== void 0 && props4.round === false) {
        inner.push(
          h(QIcon_default, {
            name: props4.iconRight,
            right: props4.stack !== true && hasLabel.value === true,
            role: "img"
          })
        );
      }
      const child = [
        h("span", {
          class: "q-focus-helper",
          ref: blurTargetRef
        })
      ];
      if (props4.loading === true && props4.percentage !== void 0) {
        child.push(
          h("span", {
            class: "q-btn__progress absolute-full overflow-hidden" + (props4.darkPercentage === true ? " q-btn__progress--dark" : "")
          }, [
            h("span", {
              class: "q-btn__progress-indicator fit block",
              style: percentageStyle.value
            })
          ])
        );
      }
      child.push(
        h("span", {
          class: "q-btn__content text-center col items-center q-anchor--skip " + innerClasses.value
        }, inner)
      );
      props4.loading !== null && child.push(
        h(Transition, {
          name: "q-transition--fade"
        }, () => props4.loading === true ? [
          h("span", {
            key: "loading",
            class: "absolute-full flex flex-center"
          }, slots.loading !== void 0 ? slots.loading() : [h(QSpinner_default)])
        ] : null)
      );
      return withDirectives(
        h(
          linkTag.value,
          nodeProps.value,
          child
        ),
        [[
          Ripple_default,
          ripple.value,
          void 0,
          rippleProps.value
        ]]
      );
    };
  }
});
var QBtnGroup_default = createComponent({
  name: "QBtnGroup",
  props: {
    unelevated: Boolean,
    outline: Boolean,
    flat: Boolean,
    rounded: Boolean,
    square: Boolean,
    push: Boolean,
    stretch: Boolean,
    glossy: Boolean,
    spread: Boolean
  },
  setup(props4, { slots }) {
    const classes = computed(() => {
      const cls = ["unelevated", "outline", "flat", "rounded", "square", "push", "stretch", "glossy"].filter((t) => props4[t] === true).map((t) => `q-btn-group--${t}`).join(" ");
      return `q-btn-group row no-wrap${cls.length !== 0 ? " " + cls : ""}` + (props4.spread === true ? " q-btn-group--spread" : " inline");
    });
    return () => h("div", { class: classes.value }, hSlot(slots.default));
  }
});
function clearSelection() {
  if (window.getSelection !== void 0) {
    const selection = window.getSelection();
    if (selection.empty !== void 0) {
      selection.empty();
    } else if (selection.removeAllRanges !== void 0) {
      selection.removeAllRanges();
      Platform_default.is.mobile !== true && selection.addRange(document.createRange());
    }
  } else if (document.selection !== void 0) {
    document.selection.empty();
  }
}
var useAnchorStaticProps = {
  /* SSR does not know about Element */
  target: {
    type: [Boolean, String, Element],
    default: true
  },
  noParentEvent: Boolean
};
var useAnchorProps = {
  ...useAnchorStaticProps,
  contextMenu: Boolean
};
function use_anchor_default({
  showing,
  avoidEmit,
  // required for QPopupProxy (true)
  configureAnchorEl
  // optional
}) {
  const { props: props4, proxy, emit: emit2 } = getCurrentInstance();
  const anchorEl = ref(null);
  let touchTimer = null;
  function canShow(evt) {
    return anchorEl.value === null ? false : evt === void 0 || evt.touches === void 0 || evt.touches.length <= 1;
  }
  const anchorEvents = {};
  if (configureAnchorEl === void 0) {
    Object.assign(anchorEvents, {
      hide(evt) {
        proxy.hide(evt);
      },
      toggle(evt) {
        proxy.toggle(evt);
        evt.qAnchorHandled = true;
      },
      toggleKey(evt) {
        isKeyCode(evt, 13) === true && anchorEvents.toggle(evt);
      },
      contextClick(evt) {
        proxy.hide(evt);
        prevent(evt);
        nextTick(() => {
          proxy.show(evt);
          evt.qAnchorHandled = true;
        });
      },
      prevent,
      mobileTouch(evt) {
        anchorEvents.mobileCleanup(evt);
        if (canShow(evt) !== true) {
          return;
        }
        proxy.hide(evt);
        anchorEl.value.classList.add("non-selectable");
        const target2 = evt.target;
        addEvt(anchorEvents, "anchor", [
          [target2, "touchmove", "mobileCleanup", "passive"],
          [target2, "touchend", "mobileCleanup", "passive"],
          [target2, "touchcancel", "mobileCleanup", "passive"],
          [anchorEl.value, "contextmenu", "prevent", "notPassive"]
        ]);
        touchTimer = setTimeout(() => {
          touchTimer = null;
          proxy.show(evt);
          evt.qAnchorHandled = true;
        }, 300);
      },
      mobileCleanup(evt) {
        anchorEl.value.classList.remove("non-selectable");
        if (touchTimer !== null) {
          clearTimeout(touchTimer);
          touchTimer = null;
        }
        if (showing.value === true && evt !== void 0) {
          clearSelection();
        }
      }
    });
    configureAnchorEl = function(context = props4.contextMenu) {
      if (props4.noParentEvent === true || anchorEl.value === null) return;
      let evts;
      if (context === true) {
        if (proxy.$q.platform.is.mobile === true) {
          evts = [
            [anchorEl.value, "touchstart", "mobileTouch", "passive"]
          ];
        } else {
          evts = [
            [anchorEl.value, "mousedown", "hide", "passive"],
            [anchorEl.value, "contextmenu", "contextClick", "notPassive"]
          ];
        }
      } else {
        evts = [
          [anchorEl.value, "click", "toggle", "passive"],
          [anchorEl.value, "keyup", "toggleKey", "passive"]
        ];
      }
      addEvt(anchorEvents, "anchor", evts);
    };
  }
  function unconfigureAnchorEl() {
    cleanEvt(anchorEvents, "anchor");
  }
  function setAnchorEl(el) {
    anchorEl.value = el;
    while (anchorEl.value.classList.contains("q-anchor--skip")) {
      anchorEl.value = anchorEl.value.parentNode;
    }
    configureAnchorEl();
  }
  function pickAnchorEl() {
    if (props4.target === false || props4.target === "" || proxy.$el.parentNode === null) {
      anchorEl.value = null;
    } else if (props4.target === true) {
      setAnchorEl(proxy.$el.parentNode);
    } else {
      let el = props4.target;
      if (typeof props4.target === "string") {
        try {
          el = document.querySelector(props4.target);
        } catch (err) {
          el = void 0;
        }
      }
      if (el !== void 0 && el !== null) {
        anchorEl.value = el.$el || el;
        configureAnchorEl();
      } else {
        anchorEl.value = null;
        console.error(`Anchor: target "${props4.target}" not found`);
      }
    }
  }
  watch(() => props4.contextMenu, (val) => {
    if (anchorEl.value !== null) {
      unconfigureAnchorEl();
      configureAnchorEl(val);
    }
  });
  watch(() => props4.target, () => {
    if (anchorEl.value !== null) {
      unconfigureAnchorEl();
    }
    pickAnchorEl();
  });
  watch(() => props4.noParentEvent, (val) => {
    if (anchorEl.value !== null) {
      if (val === true) {
        unconfigureAnchorEl();
      } else {
        configureAnchorEl();
      }
    }
  });
  onMounted(() => {
    pickAnchorEl();
    if (avoidEmit !== true && props4.modelValue === true && anchorEl.value === null) {
      emit2("update:modelValue", false);
    }
  });
  onBeforeUnmount(() => {
    touchTimer !== null && clearTimeout(touchTimer);
    unconfigureAnchorEl();
  });
  return {
    anchorEl,
    canShow,
    anchorEvents
  };
}
function use_scroll_target_default(props4, configureScrollTarget) {
  const localScrollTarget = ref(null);
  let scrollFn;
  function changeScrollEvent(scrollTarget, fn) {
    const fnProp = `${fn !== void 0 ? "add" : "remove"}EventListener`;
    const fnHandler = fn !== void 0 ? fn : scrollFn;
    if (scrollTarget !== window) {
      scrollTarget[fnProp]("scroll", fnHandler, listenOpts.passive);
    }
    window[fnProp]("scroll", fnHandler, listenOpts.passive);
    scrollFn = fn;
  }
  function unconfigureScrollTarget() {
    if (localScrollTarget.value !== null) {
      changeScrollEvent(localScrollTarget.value);
      localScrollTarget.value = null;
    }
  }
  const noParentEventWatcher = watch(() => props4.noParentEvent, () => {
    if (localScrollTarget.value !== null) {
      unconfigureScrollTarget();
      configureScrollTarget();
    }
  });
  onBeforeUnmount(noParentEventWatcher);
  return {
    localScrollTarget,
    unconfigureScrollTarget,
    changeScrollEvent
  };
}
var useModelToggleProps = {
  modelValue: {
    type: Boolean,
    default: null
  },
  "onUpdate:modelValue": [Function, Array]
};
var useModelToggleEmits = [
  "beforeShow",
  "show",
  "beforeHide",
  "hide"
];
function use_model_toggle_default({
  showing,
  canShow,
  // optional
  hideOnRouteChange,
  // optional
  handleShow,
  // optional
  handleHide,
  // optional
  processOnMount
  // optional
}) {
  const vm2 = getCurrentInstance();
  const { props: props4, emit: emit2, proxy } = vm2;
  let payload;
  function toggle(evt) {
    if (showing.value === true) {
      hide(evt);
    } else {
      show(evt);
    }
  }
  function show(evt) {
    if (props4.disable === true || evt !== void 0 && evt.qAnchorHandled === true || canShow !== void 0 && canShow(evt) !== true) {
      return;
    }
    const listener = props4["onUpdate:modelValue"] !== void 0;
    if (listener === true && true) {
      emit2("update:modelValue", true);
      payload = evt;
      nextTick(() => {
        if (payload === evt) {
          payload = void 0;
        }
      });
    }
    if (props4.modelValue === null || listener === false || false) {
      processShow(evt);
    }
  }
  function processShow(evt) {
    if (showing.value === true) {
      return;
    }
    showing.value = true;
    emit2("beforeShow", evt);
    if (handleShow !== void 0) {
      handleShow(evt);
    } else {
      emit2("show", evt);
    }
  }
  function hide(evt) {
    if (props4.disable === true) {
      return;
    }
    const listener = props4["onUpdate:modelValue"] !== void 0;
    if (listener === true && true) {
      emit2("update:modelValue", false);
      payload = evt;
      nextTick(() => {
        if (payload === evt) {
          payload = void 0;
        }
      });
    }
    if (props4.modelValue === null || listener === false || false) {
      processHide(evt);
    }
  }
  function processHide(evt) {
    if (showing.value === false) {
      return;
    }
    showing.value = false;
    emit2("beforeHide", evt);
    if (handleHide !== void 0) {
      handleHide(evt);
    } else {
      emit2("hide", evt);
    }
  }
  function processModelChange(val) {
    if (props4.disable === true && val === true) {
      if (props4["onUpdate:modelValue"] !== void 0) {
        emit2("update:modelValue", false);
      }
    } else if (val === true !== showing.value) {
      const fn = val === true ? processShow : processHide;
      fn(payload);
    }
  }
  watch(() => props4.modelValue, processModelChange);
  if (hideOnRouteChange !== void 0 && vmHasRouter(vm2) === true) {
    watch(() => proxy.$route.fullPath, () => {
      if (hideOnRouteChange.value === true && showing.value === true) {
        hide();
      }
    });
  }
  processOnMount === true && onMounted(() => {
    processModelChange(props4.modelValue);
  });
  const publicMethods = { show, hide, toggle };
  Object.assign(proxy, publicMethods);
  return publicMethods;
}
var queue = [];
var waitFlags = [];
function clearFlag(flag) {
  waitFlags = waitFlags.filter((entry) => entry !== flag);
}
function addFocusWaitFlag(flag) {
  clearFlag(flag);
  waitFlags.push(flag);
}
function removeFocusWaitFlag(flag) {
  clearFlag(flag);
  if (waitFlags.length === 0 && queue.length !== 0) {
    queue[queue.length - 1]();
    queue = [];
  }
}
function addFocusFn(fn) {
  if (waitFlags.length === 0) {
    fn();
  } else {
    queue.push(fn);
  }
}
function removeFocusFn(fn) {
  queue = queue.filter((entry) => entry !== fn);
}
var nodesList = [];
var portalTypeList = [];
var portalIndex = 1;
var target = document.body;
function createGlobalNode(id3, portalType) {
  const el = document.createElement("div");
  el.id = portalType !== void 0 ? `q-portal--${portalType}--${portalIndex++}` : id3;
  if (globalConfig.globalNodes !== void 0) {
    const cls = globalConfig.globalNodes.class;
    if (cls !== void 0) {
      el.className = cls;
    }
  }
  target.appendChild(el);
  nodesList.push(el);
  portalTypeList.push(portalType);
  return el;
}
function removeGlobalNode(el) {
  const nodeIndex = nodesList.indexOf(el);
  nodesList.splice(nodeIndex, 1);
  portalTypeList.splice(nodeIndex, 1);
  el.remove();
}
function changeGlobalNodesTarget(newTarget) {
  if (newTarget === target) return;
  target = newTarget;
  if (target === document.body || portalTypeList.reduce((acc, type) => type === "dialog" ? acc + 1 : acc, 0) < 2) {
    nodesList.forEach((node) => {
      if (node.contains(target) === false) {
        target.appendChild(node);
      }
    });
    return;
  }
  const lastDialogIndex = portalTypeList.lastIndexOf("dialog");
  for (let i = 0; i < nodesList.length; i++) {
    const el = nodesList[i];
    if ((i === lastDialogIndex || portalTypeList[i] !== "dialog") && el.contains(target) === false) {
      target.appendChild(el);
    }
  }
}
var portalProxyList = [];
function getPortalProxy(el) {
  return portalProxyList.find(
    (proxy) => proxy.contentEl !== null && proxy.contentEl.contains(el)
  );
}
function closePortalMenus(proxy, evt) {
  do {
    if (proxy.$options.name === "QMenu") {
      proxy.hide(evt);
      if (proxy.$props.separateClosePopup === true) {
        return getParentProxy(proxy);
      }
    } else if (proxy.__qPortal === true) {
      const parent = getParentProxy(proxy);
      if (parent !== void 0 && parent.$options.name === "QPopupProxy") {
        proxy.hide(evt);
        return parent;
      } else {
        return proxy;
      }
    }
    proxy = getParentProxy(proxy);
  } while (proxy !== void 0 && proxy !== null);
}
function closePortals(proxy, evt, depth) {
  while (depth !== 0 && proxy !== void 0 && proxy !== null) {
    if (proxy.__qPortal === true) {
      depth--;
      if (proxy.$options.name === "QMenu") {
        proxy = closePortalMenus(proxy, evt);
        continue;
      }
      proxy.hide(evt);
    }
    proxy = getParentProxy(proxy);
  }
}
var QPortal = createComponent({
  name: "QPortal",
  setup(_, { slots }) {
    return () => slots.default();
  }
});
function isOnGlobalDialog(vm2) {
  vm2 = vm2.parent;
  while (vm2 !== void 0 && vm2 !== null) {
    if (vm2.type.name === "QGlobalDialog") {
      return true;
    }
    if (vm2.type.name === "QDialog" || vm2.type.name === "QMenu") {
      return false;
    }
    vm2 = vm2.parent;
  }
  return false;
}
function use_portal_default(vm2, innerRef, renderPortalContent, type) {
  const portalIsActive = ref(false);
  const portalIsAccessible = ref(false);
  let portalEl = null;
  const focusObj = {};
  const onGlobalDialog = type === "dialog" && isOnGlobalDialog(vm2);
  function showPortal(isReady) {
    if (isReady === true) {
      removeFocusWaitFlag(focusObj);
      portalIsAccessible.value = true;
      return;
    }
    portalIsAccessible.value = false;
    if (portalIsActive.value === false) {
      if (onGlobalDialog === false && portalEl === null) {
        portalEl = createGlobalNode(false, type);
      }
      portalIsActive.value = true;
      portalProxyList.push(vm2.proxy);
      addFocusWaitFlag(focusObj);
    }
  }
  function hidePortal(isReady) {
    portalIsAccessible.value = false;
    if (isReady !== true) return;
    removeFocusWaitFlag(focusObj);
    portalIsActive.value = false;
    const index = portalProxyList.indexOf(vm2.proxy);
    if (index !== -1) {
      portalProxyList.splice(index, 1);
    }
    if (portalEl !== null) {
      removeGlobalNode(portalEl);
      portalEl = null;
    }
  }
  onUnmounted(() => {
    hidePortal(true);
  });
  vm2.proxy.__qPortal = true;
  injectProp(vm2.proxy, "contentEl", () => innerRef.value);
  return {
    showPortal,
    hidePortal,
    portalIsActive,
    portalIsAccessible,
    renderPortal: () => onGlobalDialog === true ? renderPortalContent() : portalIsActive.value === true ? [h(Teleport, { to: portalEl }, h(QPortal, renderPortalContent))] : void 0
  };
}
var useTransitionProps = {
  transitionShow: {
    type: String,
    default: "fade"
  },
  transitionHide: {
    type: String,
    default: "fade"
  },
  transitionDuration: {
    type: [String, Number],
    default: 300
  }
};
function use_transition_default(props4, defaultShowFn = () => {
}, defaultHideFn = () => {
}) {
  return {
    transitionProps: computed(() => {
      const show = `q-transition--${props4.transitionShow || defaultShowFn()}`;
      const hide = `q-transition--${props4.transitionHide || defaultHideFn()}`;
      return {
        appear: true,
        enterFromClass: `${show}-enter-from`,
        enterActiveClass: `${show}-enter-active`,
        enterToClass: `${show}-enter-to`,
        leaveFromClass: `${hide}-leave-from`,
        leaveActiveClass: `${hide}-leave-active`,
        leaveToClass: `${hide}-leave-to`
      };
    }),
    transitionStyle: computed(() => `--q-transition-duration: ${props4.transitionDuration}ms`)
  };
}
function use_tick_default() {
  let tickFn;
  const vm2 = getCurrentInstance();
  function removeTick() {
    tickFn = void 0;
  }
  onDeactivated(removeTick);
  onBeforeUnmount(removeTick);
  return {
    removeTick,
    registerTick(fn) {
      tickFn = fn;
      nextTick(() => {
        if (tickFn === fn) {
          vmIsDestroyed(vm2) === false && tickFn();
          tickFn = void 0;
        }
      });
    }
  };
}
function use_timeout_default() {
  let timer2 = null;
  const vm2 = getCurrentInstance();
  function removeTimeout() {
    if (timer2 !== null) {
      clearTimeout(timer2);
      timer2 = null;
    }
  }
  onDeactivated(removeTimeout);
  onBeforeUnmount(removeTimeout);
  return {
    removeTimeout,
    registerTimeout(fn, delay) {
      removeTimeout();
      if (vmIsDestroyed(vm2) === false) {
        timer2 = setTimeout(() => {
          timer2 = null;
          fn();
        }, delay);
      }
    }
  };
}
var scrollTargetProp = [Element, String];
var scrollTargets = [null, document, document.body, document.scrollingElement, document.documentElement];
function getScrollTarget(el, targetEl) {
  let target2 = getElement(targetEl);
  if (target2 === void 0) {
    if (el === void 0 || el === null) {
      return window;
    }
    target2 = el.closest(".scroll,.scroll-y,.overflow-auto");
  }
  return scrollTargets.includes(target2) ? window : target2;
}
function getScrollHeight(el) {
  return (el === window ? document.body : el).scrollHeight;
}
function getVerticalScrollPosition(scrollTarget) {
  return scrollTarget === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : scrollTarget.scrollTop;
}
function getHorizontalScrollPosition(scrollTarget) {
  return scrollTarget === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : scrollTarget.scrollLeft;
}
function animVerticalScrollTo(el, to, duration2 = 0) {
  const prevTime = arguments[3] === void 0 ? performance.now() : arguments[3];
  const pos = getVerticalScrollPosition(el);
  if (duration2 <= 0) {
    if (pos !== to) {
      setScroll(el, to);
    }
    return;
  }
  requestAnimationFrame((nowTime) => {
    const frameTime = nowTime - prevTime;
    const newPos = pos + (to - pos) / Math.max(frameTime, duration2) * frameTime;
    setScroll(el, newPos);
    if (newPos !== to) {
      animVerticalScrollTo(el, to, duration2 - frameTime, nowTime);
    }
  });
}
function animHorizontalScrollTo(el, to, duration2 = 0) {
  const prevTime = arguments[3] === void 0 ? performance.now() : arguments[3];
  const pos = getHorizontalScrollPosition(el);
  if (duration2 <= 0) {
    if (pos !== to) {
      setHorizontalScroll(el, to);
    }
    return;
  }
  requestAnimationFrame((nowTime) => {
    const frameTime = nowTime - prevTime;
    const newPos = pos + (to - pos) / Math.max(frameTime, duration2) * frameTime;
    setHorizontalScroll(el, newPos);
    if (newPos !== to) {
      animHorizontalScrollTo(el, to, duration2 - frameTime, nowTime);
    }
  });
}
function setScroll(scrollTarget, offset2) {
  if (scrollTarget === window) {
    window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, offset2);
    return;
  }
  scrollTarget.scrollTop = offset2;
}
function setHorizontalScroll(scrollTarget, offset2) {
  if (scrollTarget === window) {
    window.scrollTo(offset2, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
    return;
  }
  scrollTarget.scrollLeft = offset2;
}
function setVerticalScrollPosition(scrollTarget, offset2, duration2) {
  if (duration2) {
    animVerticalScrollTo(scrollTarget, offset2, duration2);
    return;
  }
  setScroll(scrollTarget, offset2);
}
function setHorizontalScrollPosition(scrollTarget, offset2, duration2) {
  if (duration2) {
    animHorizontalScrollTo(scrollTarget, offset2, duration2);
    return;
  }
  setHorizontalScroll(scrollTarget, offset2);
}
var size;
function getScrollbarWidth() {
  if (size !== void 0) {
    return size;
  }
  const inner = document.createElement("p"), outer = document.createElement("div");
  css(inner, {
    width: "100%",
    height: "200px"
  });
  css(outer, {
    position: "absolute",
    top: "0px",
    left: "0px",
    visibility: "hidden",
    width: "200px",
    height: "150px",
    overflow: "hidden"
  });
  outer.appendChild(inner);
  document.body.appendChild(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  let w2 = inner.offsetWidth;
  if (w1 === w2) {
    w2 = outer.clientWidth;
  }
  outer.remove();
  size = w1 - w2;
  return size;
}
function hasScrollbar(el, onY = true) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  return onY ? el.scrollHeight > el.clientHeight && (el.classList.contains("scroll") || el.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(el)["overflow-y"])) : el.scrollWidth > el.clientWidth && (el.classList.contains("scroll") || el.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(el)["overflow-x"]));
}
var handlers = [];
var escDown;
function onKeydown(evt) {
  escDown = evt.keyCode === 27;
}
function onBlur() {
  if (escDown === true) {
    escDown = false;
  }
}
function onKeyup(evt) {
  if (escDown === true) {
    escDown = false;
    if (isKeyCode(evt, 27) === true) {
      handlers[handlers.length - 1](evt);
    }
  }
}
function update(action) {
  window[action]("keydown", onKeydown);
  window[action]("blur", onBlur);
  window[action]("keyup", onKeyup);
  escDown = false;
}
function addEscapeKey(fn) {
  if (client.is.desktop === true) {
    handlers.push(fn);
    if (handlers.length === 1) {
      update("addEventListener");
    }
  }
}
function removeEscapeKey(fn) {
  const index = handlers.indexOf(fn);
  if (index !== -1) {
    handlers.splice(index, 1);
    if (handlers.length === 0) {
      update("removeEventListener");
    }
  }
}
var handlers2 = [];
function trigger(e) {
  handlers2[handlers2.length - 1](e);
}
function addFocusout(fn) {
  if (client.is.desktop === true) {
    handlers2.push(fn);
    if (handlers2.length === 1) {
      document.body.addEventListener("focusin", trigger);
    }
  }
}
function removeFocusout(fn) {
  const index = handlers2.indexOf(fn);
  if (index !== -1) {
    handlers2.splice(index, 1);
    if (handlers2.length === 0) {
      document.body.removeEventListener("focusin", trigger);
    }
  }
}
var { notPassiveCapture } = listenOpts;
var registeredList = [];
function globalHandler(evt) {
  const target2 = evt.target;
  if (target2 === void 0 || target2.nodeType === 8 || target2.classList.contains("no-pointer-events") === true) {
    return;
  }
  let portalIndex2 = portalProxyList.length - 1;
  while (portalIndex2 >= 0) {
    const proxy = portalProxyList[portalIndex2].$;
    if (proxy.type.name === "QTooltip") {
      portalIndex2--;
      continue;
    }
    if (proxy.type.name !== "QDialog") {
      break;
    }
    if (proxy.props.seamless !== true) {
      return;
    }
    portalIndex2--;
  }
  for (let i = registeredList.length - 1; i >= 0; i--) {
    const state = registeredList[i];
    if ((state.anchorEl.value === null || state.anchorEl.value.contains(target2) === false) && (target2 === document.body || state.innerRef.value !== null && state.innerRef.value.contains(target2) === false)) {
      evt.qClickOutside = true;
      state.onClickOutside(evt);
    } else {
      return;
    }
  }
}
function addClickOutside(clickOutsideProps) {
  registeredList.push(clickOutsideProps);
  if (registeredList.length === 1) {
    document.addEventListener("mousedown", globalHandler, notPassiveCapture);
    document.addEventListener("touchstart", globalHandler, notPassiveCapture);
  }
}
function removeClickOutside(clickOutsideProps) {
  const index = registeredList.findIndex((h138) => h138 === clickOutsideProps);
  if (index !== -1) {
    registeredList.splice(index, 1);
    if (registeredList.length === 0) {
      document.removeEventListener("mousedown", globalHandler, notPassiveCapture);
      document.removeEventListener("touchstart", globalHandler, notPassiveCapture);
    }
  }
}
var vpLeft;
var vpTop;
function validatePosition(pos) {
  const parts = pos.split(" ");
  if (parts.length !== 2) {
    return false;
  }
  if (["top", "center", "bottom"].includes(parts[0]) !== true) {
    console.error("Anchor/Self position must start with one of top/center/bottom");
    return false;
  }
  if (["left", "middle", "right", "start", "end"].includes(parts[1]) !== true) {
    console.error("Anchor/Self position must end with one of left/middle/right/start/end");
    return false;
  }
  return true;
}
function validateOffset(val) {
  if (!val) {
    return true;
  }
  if (val.length !== 2) {
    return false;
  }
  if (typeof val[0] !== "number" || typeof val[1] !== "number") {
    return false;
  }
  return true;
}
var horizontalPos = {
  "start#ltr": "left",
  "start#rtl": "right",
  "end#ltr": "right",
  "end#rtl": "left"
};
["left", "middle", "right"].forEach((pos) => {
  horizontalPos[`${pos}#ltr`] = pos;
  horizontalPos[`${pos}#rtl`] = pos;
});
function parsePosition(pos, rtl) {
  const parts = pos.split(" ");
  return {
    vertical: parts[0],
    horizontal: horizontalPos[`${parts[1]}#${rtl === true ? "rtl" : "ltr"}`]
  };
}
function getAnchorProps(el, offset2) {
  let { top, left, right, bottom, width: width3, height: height2 } = el.getBoundingClientRect();
  if (offset2 !== void 0) {
    top -= offset2[1];
    left -= offset2[0];
    bottom += offset2[1];
    right += offset2[0];
    width3 += offset2[0];
    height2 += offset2[1];
  }
  return {
    top,
    bottom,
    height: height2,
    left,
    right,
    width: width3,
    middle: left + (right - left) / 2,
    center: top + (bottom - top) / 2
  };
}
function getAbsoluteAnchorProps(el, absoluteOffset, offset2) {
  let { top, left } = el.getBoundingClientRect();
  top += absoluteOffset.top;
  left += absoluteOffset.left;
  if (offset2 !== void 0) {
    top += offset2[1];
    left += offset2[0];
  }
  return {
    top,
    bottom: top + 1,
    height: 1,
    left,
    right: left + 1,
    width: 1,
    middle: left,
    center: top
  };
}
function getTargetProps(width3, height2) {
  return {
    top: 0,
    center: height2 / 2,
    bottom: height2,
    left: 0,
    middle: width3 / 2,
    right: width3
  };
}
function getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin) {
  return {
    top: anchorProps[anchorOrigin.vertical] - targetProps[selfOrigin.vertical],
    left: anchorProps[anchorOrigin.horizontal] - targetProps[selfOrigin.horizontal]
  };
}
function setPosition(cfg, retryNumber = 0) {
  if (cfg.targetEl === null || cfg.anchorEl === null || retryNumber > 5) {
    return;
  }
  if (cfg.targetEl.offsetHeight === 0 || cfg.targetEl.offsetWidth === 0) {
    setTimeout(() => {
      setPosition(cfg, retryNumber + 1);
    }, 10);
    return;
  }
  const {
    targetEl,
    offset: offset2,
    anchorEl,
    anchorOrigin,
    selfOrigin,
    absoluteOffset,
    fit,
    cover,
    maxHeight,
    maxWidth
  } = cfg;
  if (client.is.ios === true && window.visualViewport !== void 0) {
    const el = document.body.style;
    const { offsetLeft: left, offsetTop: top } = window.visualViewport;
    if (left !== vpLeft) {
      el.setProperty("--q-pe-left", left + "px");
      vpLeft = left;
    }
    if (top !== vpTop) {
      el.setProperty("--q-pe-top", top + "px");
      vpTop = top;
    }
  }
  const { scrollLeft, scrollTop } = targetEl;
  const anchorProps = absoluteOffset === void 0 ? getAnchorProps(anchorEl, cover === true ? [0, 0] : offset2) : getAbsoluteAnchorProps(anchorEl, absoluteOffset, offset2);
  Object.assign(targetEl.style, {
    top: 0,
    left: 0,
    minWidth: null,
    minHeight: null,
    maxWidth,
    maxHeight,
    visibility: "visible"
  });
  const { offsetWidth: origElWidth, offsetHeight: origElHeight } = targetEl;
  const { elWidth, elHeight } = fit === true || cover === true ? { elWidth: Math.max(anchorProps.width, origElWidth), elHeight: cover === true ? Math.max(anchorProps.height, origElHeight) : origElHeight } : { elWidth: origElWidth, elHeight: origElHeight };
  let elStyle = { maxWidth, maxHeight };
  if (fit === true || cover === true) {
    elStyle.minWidth = anchorProps.width + "px";
    if (cover === true) {
      elStyle.minHeight = anchorProps.height + "px";
    }
  }
  Object.assign(targetEl.style, elStyle);
  const targetProps = getTargetProps(elWidth, elHeight);
  let props4 = getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin);
  if (absoluteOffset === void 0 || offset2 === void 0) {
    applyBoundaries(props4, anchorProps, targetProps, anchorOrigin, selfOrigin);
  } else {
    const { top, left } = props4;
    applyBoundaries(props4, anchorProps, targetProps, anchorOrigin, selfOrigin);
    let hasChanged2 = false;
    if (props4.top !== top) {
      hasChanged2 = true;
      const offsetY = 2 * offset2[1];
      anchorProps.center = anchorProps.top -= offsetY;
      anchorProps.bottom -= offsetY + 2;
    }
    if (props4.left !== left) {
      hasChanged2 = true;
      const offsetX = 2 * offset2[0];
      anchorProps.middle = anchorProps.left -= offsetX;
      anchorProps.right -= offsetX + 2;
    }
    if (hasChanged2 === true) {
      props4 = getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin);
      applyBoundaries(props4, anchorProps, targetProps, anchorOrigin, selfOrigin);
    }
  }
  elStyle = {
    top: props4.top + "px",
    left: props4.left + "px"
  };
  if (props4.maxHeight !== void 0) {
    elStyle.maxHeight = props4.maxHeight + "px";
    if (anchorProps.height > props4.maxHeight) {
      elStyle.minHeight = elStyle.maxHeight;
    }
  }
  if (props4.maxWidth !== void 0) {
    elStyle.maxWidth = props4.maxWidth + "px";
    if (anchorProps.width > props4.maxWidth) {
      elStyle.minWidth = elStyle.maxWidth;
    }
  }
  Object.assign(targetEl.style, elStyle);
  if (targetEl.scrollTop !== scrollTop) {
    targetEl.scrollTop = scrollTop;
  }
  if (targetEl.scrollLeft !== scrollLeft) {
    targetEl.scrollLeft = scrollLeft;
  }
}
function applyBoundaries(props4, anchorProps, targetProps, anchorOrigin, selfOrigin) {
  const currentHeight = targetProps.bottom, currentWidth = targetProps.right, margin = getScrollbarWidth(), innerHeight = window.innerHeight - margin, innerWidth = document.body.clientWidth;
  if (props4.top < 0 || props4.top + currentHeight > innerHeight) {
    if (selfOrigin.vertical === "center") {
      props4.top = anchorProps[anchorOrigin.vertical] > innerHeight / 2 ? Math.max(0, innerHeight - currentHeight) : 0;
      props4.maxHeight = Math.min(currentHeight, innerHeight);
    } else if (anchorProps[anchorOrigin.vertical] > innerHeight / 2) {
      const anchorY = Math.min(
        innerHeight,
        anchorOrigin.vertical === "center" ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top
      );
      props4.maxHeight = Math.min(currentHeight, anchorY);
      props4.top = Math.max(0, anchorY - currentHeight);
    } else {
      props4.top = Math.max(
        0,
        anchorOrigin.vertical === "center" ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom
      );
      props4.maxHeight = Math.min(currentHeight, innerHeight - props4.top);
    }
  }
  if (props4.left < 0 || props4.left + currentWidth > innerWidth) {
    props4.maxWidth = Math.min(currentWidth, innerWidth);
    if (selfOrigin.horizontal === "middle") {
      props4.left = anchorProps[anchorOrigin.horizontal] > innerWidth / 2 ? Math.max(0, innerWidth - currentWidth) : 0;
    } else if (anchorProps[anchorOrigin.horizontal] > innerWidth / 2) {
      const anchorX = Math.min(
        innerWidth,
        anchorOrigin.horizontal === "middle" ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left
      );
      props4.maxWidth = Math.min(currentWidth, anchorX);
      props4.left = Math.max(0, anchorX - props4.maxWidth);
    } else {
      props4.left = Math.max(
        0,
        anchorOrigin.horizontal === "middle" ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right
      );
      props4.maxWidth = Math.min(currentWidth, innerWidth - props4.left);
    }
  }
}
var QMenu_default = createComponent({
  name: "QMenu",
  inheritAttrs: false,
  props: {
    ...useAnchorProps,
    ...useModelToggleProps,
    ...useDarkProps,
    ...useTransitionProps,
    persistent: Boolean,
    autoClose: Boolean,
    separateClosePopup: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    fit: Boolean,
    cover: Boolean,
    square: Boolean,
    anchor: {
      type: String,
      validator: validatePosition
    },
    self: {
      type: String,
      validator: validatePosition
    },
    offset: {
      type: Array,
      validator: validateOffset
    },
    scrollTarget: scrollTargetProp,
    touchPosition: Boolean,
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    }
  },
  emits: [
    ...useModelToggleEmits,
    "click",
    "escapeKey"
  ],
  setup(props4, { slots, emit: emit2, attrs }) {
    let refocusTarget = null, absoluteOffset, unwatchPosition, avoidAutoClose;
    const vm2 = getCurrentInstance();
    const { proxy } = vm2;
    const { $q } = proxy;
    const innerRef = ref(null);
    const showing = ref(false);
    const hideOnRouteChange = computed(
      () => props4.persistent !== true && props4.noRouteDismiss !== true
    );
    const isDark = use_dark_default(props4, $q);
    const { registerTick, removeTick } = use_tick_default();
    const { registerTimeout } = use_timeout_default();
    const { transitionProps, transitionStyle } = use_transition_default(props4);
    const { localScrollTarget, changeScrollEvent, unconfigureScrollTarget } = use_scroll_target_default(props4, configureScrollTarget);
    const { anchorEl, canShow } = use_anchor_default({ showing });
    const { hide } = use_model_toggle_default({
      showing,
      canShow,
      handleShow,
      handleHide,
      hideOnRouteChange,
      processOnMount: true
    });
    const { showPortal, hidePortal, renderPortal } = use_portal_default(vm2, innerRef, renderPortalContent, "menu");
    const clickOutsideProps = {
      anchorEl,
      innerRef,
      onClickOutside(e) {
        if (props4.persistent !== true && showing.value === true) {
          hide(e);
          if (
            // always prevent touch event
            e.type === "touchstart" || e.target.classList.contains("q-dialog__backdrop")
          ) {
            stopAndPrevent(e);
          }
          return true;
        }
      }
    };
    const anchorOrigin = computed(
      () => parsePosition(
        props4.anchor || (props4.cover === true ? "center middle" : "bottom start"),
        $q.lang.rtl
      )
    );
    const selfOrigin = computed(() => props4.cover === true ? anchorOrigin.value : parsePosition(props4.self || "top start", $q.lang.rtl));
    const menuClass = computed(
      () => (props4.square === true ? " q-menu--square" : "") + (isDark.value === true ? " q-menu--dark q-dark" : "")
    );
    const onEvents = computed(() => props4.autoClose === true ? { onClick: onAutoClose } : {});
    const handlesFocus = computed(
      () => showing.value === true && props4.persistent !== true
    );
    watch(handlesFocus, (val) => {
      if (val === true) {
        addEscapeKey(onEscapeKey);
        addClickOutside(clickOutsideProps);
      } else {
        removeEscapeKey(onEscapeKey);
        removeClickOutside(clickOutsideProps);
      }
    });
    function focus() {
      addFocusFn(() => {
        let node = innerRef.value;
        if (node && node.contains(document.activeElement) !== true) {
          node = node.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || node.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || node.querySelector("[autofocus], [data-autofocus]") || node;
          node.focus({ preventScroll: true });
        }
      });
    }
    function handleShow(evt) {
      refocusTarget = props4.noRefocus === false ? document.activeElement : null;
      addFocusout(onFocusout);
      showPortal();
      configureScrollTarget();
      absoluteOffset = void 0;
      if (evt !== void 0 && (props4.touchPosition || props4.contextMenu)) {
        const pos = position(evt);
        if (pos.left !== void 0) {
          const { top, left } = anchorEl.value.getBoundingClientRect();
          absoluteOffset = { left: pos.left - left, top: pos.top - top };
        }
      }
      if (unwatchPosition === void 0) {
        unwatchPosition = watch(
          () => $q.screen.width + "|" + $q.screen.height + "|" + props4.self + "|" + props4.anchor + "|" + $q.lang.rtl,
          updatePosition
        );
      }
      if (props4.noFocus !== true) {
        document.activeElement.blur();
      }
      registerTick(() => {
        updatePosition();
        props4.noFocus !== true && focus();
      });
      registerTimeout(() => {
        if ($q.platform.is.ios === true) {
          avoidAutoClose = props4.autoClose;
          innerRef.value.click();
        }
        updatePosition();
        showPortal(true);
        emit2("show", evt);
      }, props4.transitionDuration);
    }
    function handleHide(evt) {
      removeTick();
      hidePortal();
      anchorCleanup(true);
      if (refocusTarget !== null && // menu was hidden from code or ESC plugin
      (evt === void 0 || evt.qClickOutside !== true)) {
        ((evt && evt.type.indexOf("key") === 0 ? refocusTarget.closest('[tabindex]:not([tabindex^="-"])') : void 0) || refocusTarget).focus();
        refocusTarget = null;
      }
      registerTimeout(() => {
        hidePortal(true);
        emit2("hide", evt);
      }, props4.transitionDuration);
    }
    function anchorCleanup(hiding) {
      absoluteOffset = void 0;
      if (unwatchPosition !== void 0) {
        unwatchPosition();
        unwatchPosition = void 0;
      }
      if (hiding === true || showing.value === true) {
        removeFocusout(onFocusout);
        unconfigureScrollTarget();
        removeClickOutside(clickOutsideProps);
        removeEscapeKey(onEscapeKey);
      }
      if (hiding !== true) {
        refocusTarget = null;
      }
    }
    function configureScrollTarget() {
      if (anchorEl.value !== null || props4.scrollTarget !== void 0) {
        localScrollTarget.value = getScrollTarget(anchorEl.value, props4.scrollTarget);
        changeScrollEvent(localScrollTarget.value, updatePosition);
      }
    }
    function onAutoClose(e) {
      if (avoidAutoClose !== true) {
        closePortalMenus(proxy, e);
        emit2("click", e);
      } else {
        avoidAutoClose = false;
      }
    }
    function onFocusout(evt) {
      if (handlesFocus.value === true && props4.noFocus !== true && childHasFocus(innerRef.value, evt.target) !== true) {
        focus();
      }
    }
    function onEscapeKey(evt) {
      emit2("escapeKey");
      hide(evt);
    }
    function updatePosition() {
      setPosition({
        targetEl: innerRef.value,
        offset: props4.offset,
        anchorEl: anchorEl.value,
        anchorOrigin: anchorOrigin.value,
        selfOrigin: selfOrigin.value,
        absoluteOffset,
        fit: props4.fit,
        cover: props4.cover,
        maxHeight: props4.maxHeight,
        maxWidth: props4.maxWidth
      });
    }
    function renderPortalContent() {
      return h(
        Transition,
        transitionProps.value,
        () => showing.value === true ? h("div", {
          role: "menu",
          ...attrs,
          ref: innerRef,
          tabindex: -1,
          class: [
            "q-menu q-position-engine scroll" + menuClass.value,
            attrs.class
          ],
          style: [
            attrs.style,
            transitionStyle.value
          ],
          ...onEvents.value
        }, hSlot(slots.default)) : null
      );
    }
    onBeforeUnmount(anchorCleanup);
    Object.assign(proxy, { focus, updatePosition });
    return renderPortal;
  }
});
var buf;
var bufIdx = 0;
var hexBytes = new Array(256);
for (let i = 0; i < 256; i++) {
  hexBytes[i] = (i + 256).toString(16).substring(1);
}
var randomBytes = (() => {
  const lib = typeof crypto !== "undefined" ? crypto : typeof window !== "undefined" ? window.crypto || window.msCrypto : void 0;
  if (lib !== void 0) {
    if (lib.randomBytes !== void 0) {
      return lib.randomBytes;
    }
    if (lib.getRandomValues !== void 0) {
      return (n) => {
        const bytes = new Uint8Array(n);
        lib.getRandomValues(bytes);
        return bytes;
      };
    }
  }
  return (n) => {
    const r = [];
    for (let i = n; i > 0; i--) {
      r.push(Math.floor(Math.random() * 256));
    }
    return r;
  };
})();
var BUFFER_SIZE = 4096;
function uid_default() {
  if (buf === void 0 || bufIdx + 16 > BUFFER_SIZE) {
    bufIdx = 0;
    buf = randomBytes(BUFFER_SIZE);
  }
  const b = Array.prototype.slice.call(buf, bufIdx, bufIdx += 16);
  b[6] = b[6] & 15 | 64;
  b[8] = b[8] & 63 | 128;
  return hexBytes[b[0]] + hexBytes[b[1]] + hexBytes[b[2]] + hexBytes[b[3]] + "-" + hexBytes[b[4]] + hexBytes[b[5]] + "-" + hexBytes[b[6]] + hexBytes[b[7]] + "-" + hexBytes[b[8]] + hexBytes[b[9]] + "-" + hexBytes[b[10]] + hexBytes[b[11]] + hexBytes[b[12]] + hexBytes[b[13]] + hexBytes[b[14]] + hexBytes[b[15]];
}
function parseValue(val) {
  return val === void 0 || val === null ? null : val;
}
function getId(val, required) {
  return val === void 0 || val === null ? required === true ? `f_${uid_default()}` : null : val;
}
function use_id_default({ getValue, required = true } = {}) {
  if (isRuntimeSsrPreHydration.value === true) {
    const id3 = getValue !== void 0 ? ref(parseValue(getValue())) : ref(null);
    if (required === true && id3.value === null) {
      onMounted(() => {
        id3.value = `f_${uid_default()}`;
      });
    }
    if (getValue !== void 0) {
      watch(getValue, (newId) => {
        id3.value = getId(newId, required);
      });
    }
    return id3;
  }
  return getValue !== void 0 ? computed(() => getId(getValue(), required)) : ref(`f_${uid_default()}`);
}
var btnPropsList = Object.keys(nonRoundBtnProps);
function passBtnProps(props4) {
  return btnPropsList.reduce((acc, key) => {
    const val = props4[key];
    if (val !== void 0) {
      acc[key] = val;
    }
    return acc;
  }, {});
}
var QBtnDropdown_default = createComponent({
  name: "QBtnDropdown",
  props: {
    ...nonRoundBtnProps,
    ...useTransitionProps,
    modelValue: Boolean,
    split: Boolean,
    dropdownIcon: String,
    contentClass: [Array, String, Object],
    contentStyle: [Array, String, Object],
    cover: Boolean,
    persistent: Boolean,
    noRouteDismiss: Boolean,
    autoClose: Boolean,
    menuAnchor: {
      type: String,
      default: "bottom end"
    },
    menuSelf: {
      type: String,
      default: "top end"
    },
    menuOffset: Array,
    disableMainBtn: Boolean,
    disableDropdown: Boolean,
    noIconAnimation: Boolean,
    toggleAriaLabel: String
  },
  emits: ["update:modelValue", "click", "beforeShow", "show", "beforeHide", "hide"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const showing = ref(props4.modelValue);
    const menuRef = ref(null);
    const targetUid = use_id_default();
    const ariaAttrs = computed(() => {
      const acc = {
        "aria-expanded": showing.value === true ? "true" : "false",
        "aria-haspopup": "true",
        "aria-controls": targetUid.value,
        "aria-label": props4.toggleAriaLabel || proxy.$q.lang.label[showing.value === true ? "collapse" : "expand"](props4.label)
      };
      if (props4.disable === true || (props4.split === false && props4.disableMainBtn === true || props4.disableDropdown === true)) {
        acc["aria-disabled"] = "true";
      }
      return acc;
    });
    const iconClass = computed(
      () => "q-btn-dropdown__arrow" + (showing.value === true && props4.noIconAnimation === false ? " rotate-180" : "") + (props4.split === false ? " q-btn-dropdown__arrow-container" : "")
    );
    const btnDesignAttr = computed(() => getBtnDesignAttr(props4));
    const btnProps = computed(() => passBtnProps(props4));
    watch(() => props4.modelValue, (val) => {
      menuRef.value !== null && menuRef.value[val ? "show" : "hide"]();
    });
    watch(() => props4.split, hide);
    function onBeforeShow(e) {
      showing.value = true;
      emit2("beforeShow", e);
    }
    function onShow(e) {
      emit2("show", e);
      emit2("update:modelValue", true);
    }
    function onBeforeHide(e) {
      showing.value = false;
      emit2("beforeHide", e);
    }
    function onHide(e) {
      emit2("hide", e);
      emit2("update:modelValue", false);
    }
    function onClick(e) {
      emit2("click", e);
    }
    function onClickHide(e) {
      stop(e);
      hide();
      emit2("click", e);
    }
    function toggle(evt) {
      menuRef.value !== null && menuRef.value.toggle(evt);
    }
    function show(evt) {
      menuRef.value !== null && menuRef.value.show(evt);
    }
    function hide(evt) {
      menuRef.value !== null && menuRef.value.hide(evt);
    }
    Object.assign(proxy, {
      show,
      hide,
      toggle
    });
    onMounted(() => {
      props4.modelValue === true && show();
    });
    return () => {
      const Arrow = [
        h(QIcon_default, {
          class: iconClass.value,
          name: props4.dropdownIcon || proxy.$q.iconSet.arrow.dropdown
        })
      ];
      props4.disableDropdown !== true && Arrow.push(
        h(QMenu_default, {
          ref: menuRef,
          id: targetUid.value,
          class: props4.contentClass,
          style: props4.contentStyle,
          cover: props4.cover,
          fit: true,
          persistent: props4.persistent,
          noRouteDismiss: props4.noRouteDismiss,
          autoClose: props4.autoClose,
          anchor: props4.menuAnchor,
          self: props4.menuSelf,
          offset: props4.menuOffset,
          separateClosePopup: true,
          transitionShow: props4.transitionShow,
          transitionHide: props4.transitionHide,
          transitionDuration: props4.transitionDuration,
          onBeforeShow,
          onShow,
          onBeforeHide,
          onHide
        }, slots.default)
      );
      if (props4.split === false) {
        return h(QBtn_default, {
          class: "q-btn-dropdown q-btn-dropdown--simple",
          ...btnProps.value,
          ...ariaAttrs.value,
          disable: props4.disable === true || props4.disableMainBtn === true,
          noWrap: true,
          round: false,
          onClick
        }, {
          default: () => hSlot(slots.label, []).concat(Arrow),
          loading: slots.loading
        });
      }
      return h(QBtnGroup_default, {
        class: "q-btn-dropdown q-btn-dropdown--split no-wrap q-btn-item",
        rounded: props4.rounded,
        square: props4.square,
        ...btnDesignAttr.value,
        glossy: props4.glossy,
        stretch: props4.stretch
      }, () => [
        h(QBtn_default, {
          class: "q-btn-dropdown--current",
          ...btnProps.value,
          disable: props4.disable === true || props4.disableMainBtn === true,
          noWrap: true,
          round: false,
          onClick: onClickHide
        }, {
          default: slots.label,
          loading: slots.loading
        }),
        h(QBtn_default, {
          class: "q-btn-dropdown__arrow-container q-anchor--skip",
          ...ariaAttrs.value,
          ...btnDesignAttr.value,
          disable: props4.disable === true || props4.disableDropdown === true,
          rounded: props4.rounded,
          color: props4.color,
          textColor: props4.textColor,
          dense: props4.dense,
          size: props4.size,
          padding: props4.padding,
          ripple: props4.ripple
        }, () => Arrow)
      ]);
    };
  }
});
var useFormProps = {
  name: String
};
function useFormAttrs(props4) {
  return computed(() => ({
    type: "hidden",
    name: props4.name,
    value: props4.modelValue
  }));
}
function useFormInject(formAttrs = {}) {
  return (child, action, className) => {
    child[action](
      h("input", {
        class: "hidden" + (className || ""),
        ...formAttrs.value
      })
    );
  };
}
function useFormInputNameAttr(props4) {
  return computed(() => props4.name || props4.for);
}
createComponent({
  name: "QBtnToggle",
  props: {
    ...useFormProps,
    modelValue: {
      required: true
    },
    options: {
      type: Array,
      required: true,
      validator: (v2) => v2.every(
        (opt) => ("label" in opt || "icon" in opt || "slot" in opt) && "value" in opt
      )
    },
    // To avoid seeing the active raise shadow through
    // the transparent button, give it a color (even white)
    color: String,
    textColor: String,
    toggleColor: {
      type: String,
      default: "primary"
    },
    toggleTextColor: String,
    outline: Boolean,
    flat: Boolean,
    unelevated: Boolean,
    rounded: Boolean,
    push: Boolean,
    glossy: Boolean,
    size: String,
    padding: String,
    noCaps: Boolean,
    noWrap: Boolean,
    dense: Boolean,
    readonly: Boolean,
    disable: Boolean,
    stack: Boolean,
    stretch: Boolean,
    spread: Boolean,
    clearable: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: true
    }
  },
  emits: ["update:modelValue", "clear", "click"],
  setup(props4, { slots, emit: emit2 }) {
    const hasActiveValue = computed(
      () => props4.options.find((opt) => opt.value === props4.modelValue) !== void 0
    );
    const formAttrs = computed(() => ({
      type: "hidden",
      name: props4.name,
      value: props4.modelValue
    }));
    const injectFormInput = useFormInject(formAttrs);
    const btnDesignAttr = computed(() => getBtnDesignAttr(props4));
    const btnOptionDesign = computed(() => ({
      rounded: props4.rounded,
      dense: props4.dense,
      ...btnDesignAttr.value
    }));
    const btnOptions = computed(() => props4.options.map((item, i) => {
      const { attrs, value: value2, slot, ...opt } = item;
      return {
        slot,
        props: {
          key: i,
          "aria-pressed": value2 === props4.modelValue ? "true" : "false",
          ...attrs,
          ...opt,
          ...btnOptionDesign.value,
          disable: props4.disable === true || opt.disable === true,
          // Options that come from the button specific options first, then from general props
          color: value2 === props4.modelValue ? mergeOpt(opt, "toggleColor") : mergeOpt(opt, "color"),
          textColor: value2 === props4.modelValue ? mergeOpt(opt, "toggleTextColor") : mergeOpt(opt, "textColor"),
          noCaps: mergeOpt(opt, "noCaps") === true,
          noWrap: mergeOpt(opt, "noWrap") === true,
          size: mergeOpt(opt, "size"),
          padding: mergeOpt(opt, "padding"),
          ripple: mergeOpt(opt, "ripple"),
          stack: mergeOpt(opt, "stack") === true,
          stretch: mergeOpt(opt, "stretch") === true,
          onClick(e) {
            set2(value2, item, e);
          }
        }
      };
    }));
    function set2(value2, opt, e) {
      if (props4.readonly !== true) {
        if (props4.modelValue === value2) {
          if (props4.clearable === true) {
            emit2("update:modelValue", null, null);
            emit2("clear");
          }
        } else {
          emit2("update:modelValue", value2, opt);
        }
        emit2("click", e);
      }
    }
    function mergeOpt(opt, key) {
      return opt[key] === void 0 ? props4[key] : opt[key];
    }
    function getContent() {
      const child = btnOptions.value.map((opt) => {
        return h(QBtn_default, opt.props, opt.slot !== void 0 ? slots[opt.slot] : void 0);
      });
      if (props4.name !== void 0 && props4.disable !== true && hasActiveValue.value === true) {
        injectFormInput(child, "push");
      }
      return hMergeSlot(slots.default, child);
    }
    return () => h(QBtnGroup_default, {
      class: "q-btn-toggle",
      ...btnDesignAttr.value,
      rounded: props4.rounded,
      stretch: props4.stretch,
      glossy: props4.glossy,
      spread: props4.spread
    }, getContent);
  }
});
var QCard_default = createComponent({
  name: "QCard",
  props: {
    ...useDarkProps,
    tag: {
      type: String,
      default: "div"
    },
    square: Boolean,
    flat: Boolean,
    bordered: Boolean
  },
  setup(props4, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = use_dark_default(props4, $q);
    const classes = computed(
      () => "q-card" + (isDark.value === true ? " q-card--dark q-dark" : "") + (props4.bordered === true ? " q-card--bordered" : "") + (props4.square === true ? " q-card--square no-border-radius" : "") + (props4.flat === true ? " q-card--flat no-shadow" : "")
    );
    return () => h(props4.tag, { class: classes.value }, hSlot(slots.default));
  }
});
var QCardSection_default = createComponent({
  name: "QCardSection",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    horizontal: Boolean
  },
  setup(props4, { slots }) {
    const classes = computed(
      () => `q-card__section q-card__section--${props4.horizontal === true ? "horiz row no-wrap" : "vert"}`
    );
    return () => h(props4.tag, { class: classes.value }, hSlot(slots.default));
  }
});
var QCardActions_default = createComponent({
  name: "QCardActions",
  props: {
    ...useAlignProps,
    vertical: Boolean
  },
  setup(props4, { slots }) {
    const alignClass = use_align_default(props4);
    const classes = computed(
      () => `q-card__actions ${alignClass.value} q-card__actions--${props4.vertical === true ? "vert column" : "horiz row"}`
    );
    return () => h("div", { class: classes.value }, hSlot(slots.default));
  }
});
var modifiersAll = {
  left: true,
  right: true,
  up: true,
  down: true,
  horizontal: true,
  vertical: true
};
var directionList = Object.keys(modifiersAll);
modifiersAll.all = true;
function getModifierDirections(mod2) {
  const dir = {};
  for (const direction of directionList) {
    if (mod2[direction] === true) {
      dir[direction] = true;
    }
  }
  if (Object.keys(dir).length === 0) {
    return modifiersAll;
  }
  if (dir.horizontal === true) {
    dir.left = dir.right = true;
  } else if (dir.left === true && dir.right === true) {
    dir.horizontal = true;
  }
  if (dir.vertical === true) {
    dir.up = dir.down = true;
  } else if (dir.up === true && dir.down === true) {
    dir.vertical = true;
  }
  if (dir.horizontal === true && dir.vertical === true) {
    dir.all = true;
  }
  return dir;
}
var avoidNodeNamesList = ["INPUT", "TEXTAREA"];
function shouldStart(evt, ctx) {
  return ctx.event === void 0 && evt.target !== void 0 && evt.target.draggable !== true && typeof ctx.handler === "function" && avoidNodeNamesList.includes(evt.target.nodeName.toUpperCase()) === false && (evt.qClonedBy === void 0 || evt.qClonedBy.indexOf(ctx.uid) === -1);
}
function parseArg(arg) {
  const data = [0.06, 6, 50];
  if (typeof arg === "string" && arg.length) {
    arg.split(":").forEach((val, index) => {
      const v2 = parseFloat(val);
      v2 && (data[index] = v2);
    });
  }
  return data;
}
var TouchSwipe_default = createDirective(
  {
    name: "touch-swipe",
    beforeMount(el, { value: value2, arg, modifiers }) {
      if (modifiers.mouse !== true && client.has.touch !== true) {
        return;
      }
      const mouseCapture = modifiers.mouseCapture === true ? "Capture" : "";
      const ctx = {
        handler: value2,
        sensitivity: parseArg(arg),
        direction: getModifierDirections(modifiers),
        noop,
        mouseStart(evt) {
          if (shouldStart(evt, ctx) && leftClick(evt)) {
            addEvt(ctx, "temp", [
              [document, "mousemove", "move", `notPassive${mouseCapture}`],
              [document, "mouseup", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt, true);
          }
        },
        touchStart(evt) {
          if (shouldStart(evt, ctx)) {
            const target2 = evt.target;
            addEvt(ctx, "temp", [
              [target2, "touchmove", "move", "notPassiveCapture"],
              [target2, "touchcancel", "end", "notPassiveCapture"],
              [target2, "touchend", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt);
          }
        },
        start(evt, mouseEvent) {
          client.is.firefox === true && preventDraggable(el, true);
          const pos = position(evt);
          ctx.event = {
            x: pos.left,
            y: pos.top,
            time: Date.now(),
            mouse: mouseEvent === true,
            dir: false
          };
        },
        move(evt) {
          if (ctx.event === void 0) {
            return;
          }
          if (ctx.event.dir !== false) {
            stopAndPrevent(evt);
            return;
          }
          const time = Date.now() - ctx.event.time;
          if (time === 0) {
            return;
          }
          const pos = position(evt), distX = pos.left - ctx.event.x, absX = Math.abs(distX), distY = pos.top - ctx.event.y, absY = Math.abs(distY);
          if (ctx.event.mouse !== true) {
            if (absX < ctx.sensitivity[1] && absY < ctx.sensitivity[1]) {
              ctx.end(evt);
              return;
            }
          } else if (window.getSelection().toString() !== "") {
            ctx.end(evt);
            return;
          } else if (absX < ctx.sensitivity[2] && absY < ctx.sensitivity[2]) {
            return;
          }
          const velX = absX / time, velY = absY / time;
          if (ctx.direction.vertical === true && absX < absY && absX < 100 && velY > ctx.sensitivity[0]) {
            ctx.event.dir = distY < 0 ? "up" : "down";
          }
          if (ctx.direction.horizontal === true && absX > absY && absY < 100 && velX > ctx.sensitivity[0]) {
            ctx.event.dir = distX < 0 ? "left" : "right";
          }
          if (ctx.direction.up === true && absX < absY && distY < 0 && absX < 100 && velY > ctx.sensitivity[0]) {
            ctx.event.dir = "up";
          }
          if (ctx.direction.down === true && absX < absY && distY > 0 && absX < 100 && velY > ctx.sensitivity[0]) {
            ctx.event.dir = "down";
          }
          if (ctx.direction.left === true && absX > absY && distX < 0 && absY < 100 && velX > ctx.sensitivity[0]) {
            ctx.event.dir = "left";
          }
          if (ctx.direction.right === true && absX > absY && distX > 0 && absY < 100 && velX > ctx.sensitivity[0]) {
            ctx.event.dir = "right";
          }
          if (ctx.event.dir !== false) {
            stopAndPrevent(evt);
            if (ctx.event.mouse === true) {
              document.body.classList.add("no-pointer-events--children");
              document.body.classList.add("non-selectable");
              clearSelection();
              ctx.styleCleanup = (withDelay) => {
                ctx.styleCleanup = void 0;
                document.body.classList.remove("non-selectable");
                const remove2 = () => {
                  document.body.classList.remove("no-pointer-events--children");
                };
                if (withDelay === true) {
                  setTimeout(remove2, 50);
                } else {
                  remove2();
                }
              };
            }
            ctx.handler({
              evt,
              touch: ctx.event.mouse !== true,
              mouse: ctx.event.mouse,
              direction: ctx.event.dir,
              duration: time,
              distance: {
                x: absX,
                y: absY
              }
            });
          } else {
            ctx.end(evt);
          }
        },
        end(evt) {
          if (ctx.event === void 0) {
            return;
          }
          cleanEvt(ctx, "temp");
          client.is.firefox === true && preventDraggable(el, false);
          ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);
          evt !== void 0 && ctx.event.dir !== false && stopAndPrevent(evt);
          ctx.event = void 0;
        }
      };
      el.__qtouchswipe = ctx;
      if (modifiers.mouse === true) {
        const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true ? "Capture" : "";
        addEvt(ctx, "main", [
          [el, "mousedown", "mouseStart", `passive${capture}`]
        ]);
      }
      client.has.touch === true && addEvt(ctx, "main", [
        [el, "touchstart", "touchStart", `passive${modifiers.capture === true ? "Capture" : ""}`],
        [el, "touchmove", "noop", "notPassiveCapture"]
        // cannot be passive (ex: iOS scroll)
      ]);
    },
    updated(el, bindings) {
      const ctx = el.__qtouchswipe;
      if (ctx !== void 0) {
        if (bindings.oldValue !== bindings.value) {
          typeof bindings.value !== "function" && ctx.end();
          ctx.handler = bindings.value;
        }
        ctx.direction = getModifierDirections(bindings.modifiers);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qtouchswipe;
      if (ctx !== void 0) {
        cleanEvt(ctx, "main");
        cleanEvt(ctx, "temp");
        client.is.firefox === true && preventDraggable(el, false);
        ctx.styleCleanup !== void 0 && ctx.styleCleanup();
        delete el.__qtouchswipe;
      }
    }
  }
);
function use_render_cache_default() {
  let cache2 = /* @__PURE__ */ Object.create(null);
  return {
    getCache: (key, defaultValue) => cache2[key] === void 0 ? cache2[key] = typeof defaultValue === "function" ? defaultValue() : defaultValue : cache2[key],
    setCache(key, obj) {
      cache2[key] = obj;
    },
    hasCache(key) {
      return Object.hasOwnProperty.call(cache2, key);
    },
    clearCache(key) {
      if (key !== void 0) {
        delete cache2[key];
      } else {
        cache2 = /* @__PURE__ */ Object.create(null);
      }
    }
  };
}
var usePanelChildProps = {
  name: { required: true },
  disable: Boolean
};
var PanelWrapper = {
  setup(_, { slots }) {
    return () => h("div", {
      class: "q-panel scroll",
      role: "tabpanel"
    }, hSlot(slots.default));
  }
};
var usePanelProps = {
  modelValue: {
    required: true
  },
  animated: Boolean,
  infinite: Boolean,
  swipeable: Boolean,
  vertical: Boolean,
  transitionPrev: String,
  transitionNext: String,
  transitionDuration: {
    type: [String, Number],
    default: 300
  },
  keepAlive: Boolean,
  keepAliveInclude: [String, Array, RegExp],
  keepAliveExclude: [String, Array, RegExp],
  keepAliveMax: Number
};
var usePanelEmits = ["update:modelValue", "beforeTransition", "transition"];
function use_panel_default() {
  const { props: props4, emit: emit2, proxy } = getCurrentInstance();
  const { getCache } = use_render_cache_default();
  const { registerTimeout } = use_timeout_default();
  let panels, forcedPanelTransition;
  const panelIndex = ref(null);
  const panelTransition = ref(null);
  function onSwipe(evt) {
    const dir = props4.vertical === true ? "up" : "left";
    goToPanelByOffset((proxy.$q.lang.rtl === true ? -1 : 1) * (evt.direction === dir ? 1 : -1));
  }
  const panelDirectives = computed(() => {
    return [[
      TouchSwipe_default,
      onSwipe,
      void 0,
      {
        horizontal: props4.vertical !== true,
        vertical: props4.vertical,
        mouse: true
      }
    ]];
  });
  const transitionPrev = computed(
    () => props4.transitionPrev || `slide-${props4.vertical === true ? "down" : "right"}`
  );
  const transitionNext = computed(
    () => props4.transitionNext || `slide-${props4.vertical === true ? "up" : "left"}`
  );
  const transitionStyle = computed(
    () => `--q-transition-duration: ${props4.transitionDuration}ms`
  );
  const contentKey = computed(() => typeof props4.modelValue === "string" || typeof props4.modelValue === "number" ? props4.modelValue : String(props4.modelValue));
  const keepAliveProps = computed(() => ({
    include: props4.keepAliveInclude,
    exclude: props4.keepAliveExclude,
    max: props4.keepAliveMax
  }));
  const needsUniqueKeepAliveWrapper = computed(
    () => props4.keepAliveInclude !== void 0 || props4.keepAliveExclude !== void 0
  );
  watch(() => props4.modelValue, (newVal, oldVal) => {
    const index = isValidPanelName(newVal) === true ? getPanelIndex(newVal) : -1;
    if (forcedPanelTransition !== true) {
      updatePanelTransition(
        index === -1 ? 0 : index < getPanelIndex(oldVal) ? -1 : 1
      );
    }
    if (panelIndex.value !== index) {
      panelIndex.value = index;
      emit2("beforeTransition", newVal, oldVal);
      registerTimeout(() => {
        emit2("transition", newVal, oldVal);
      }, props4.transitionDuration);
    }
  });
  function nextPanel() {
    goToPanelByOffset(1);
  }
  function previousPanel() {
    goToPanelByOffset(-1);
  }
  function goToPanel(name2) {
    emit2("update:modelValue", name2);
  }
  function isValidPanelName(name2) {
    return name2 !== void 0 && name2 !== null && name2 !== "";
  }
  function getPanelIndex(name2) {
    return panels.findIndex((panel) => {
      return panel.props.name === name2 && panel.props.disable !== "" && panel.props.disable !== true;
    });
  }
  function getEnabledPanels() {
    return panels.filter((panel) => {
      return panel.props.disable !== "" && panel.props.disable !== true;
    });
  }
  function updatePanelTransition(direction) {
    const val = direction !== 0 && props4.animated === true && panelIndex.value !== -1 ? "q-transition--" + (direction === -1 ? transitionPrev.value : transitionNext.value) : null;
    if (panelTransition.value !== val) {
      panelTransition.value = val;
    }
  }
  function goToPanelByOffset(direction, startIndex = panelIndex.value) {
    let index = startIndex + direction;
    while (index !== -1 && index < panels.length) {
      const opt = panels[index];
      if (opt !== void 0 && opt.props.disable !== "" && opt.props.disable !== true) {
        updatePanelTransition(direction);
        forcedPanelTransition = true;
        emit2("update:modelValue", opt.props.name);
        setTimeout(() => {
          forcedPanelTransition = false;
        });
        return;
      }
      index += direction;
    }
    if (props4.infinite === true && panels.length !== 0 && startIndex !== -1 && startIndex !== panels.length) {
      goToPanelByOffset(direction, direction === -1 ? panels.length : -1);
    }
  }
  function updatePanelIndex() {
    const index = getPanelIndex(props4.modelValue);
    if (panelIndex.value !== index) {
      panelIndex.value = index;
    }
    return true;
  }
  function getPanelContentChild() {
    const panel = isValidPanelName(props4.modelValue) === true && updatePanelIndex() && panels[panelIndex.value];
    return props4.keepAlive === true ? [
      h(KeepAlive, keepAliveProps.value, [
        h(
          needsUniqueKeepAliveWrapper.value === true ? getCache(contentKey.value, () => ({ ...PanelWrapper, name: contentKey.value })) : PanelWrapper,
          { key: contentKey.value, style: transitionStyle.value },
          () => panel
        )
      ])
    ] : [
      h("div", {
        class: "q-panel scroll",
        style: transitionStyle.value,
        key: contentKey.value,
        role: "tabpanel"
      }, [panel])
    ];
  }
  function getPanelContent() {
    if (panels.length === 0) {
      return;
    }
    return props4.animated === true ? [h(Transition, { name: panelTransition.value }, getPanelContentChild)] : getPanelContentChild();
  }
  function updatePanelsList(slots) {
    panels = getNormalizedVNodes(
      hSlot(slots.default, [])
    ).filter(
      (panel) => panel.props !== null && panel.props.slot === void 0 && isValidPanelName(panel.props.name) === true
    );
    return panels.length;
  }
  function getPanels() {
    return panels;
  }
  Object.assign(proxy, {
    next: nextPanel,
    previous: previousPanel,
    goTo: goToPanel
  });
  return {
    panelIndex,
    panelDirectives,
    updatePanelsList,
    updatePanelIndex,
    getPanelContent,
    getEnabledPanels,
    getPanels,
    isValidPanelName,
    keepAliveProps,
    needsUniqueKeepAliveWrapper,
    goToPanelByOffset,
    goToPanel,
    nextPanel,
    previousPanel
  };
}
var counter = 0;
var useFullscreenProps = {
  fullscreen: Boolean,
  noRouteFullscreenExit: Boolean
};
var useFullscreenEmits = ["update:fullscreen", "fullscreen"];
function use_fullscreen_default() {
  const vm2 = getCurrentInstance();
  const { props: props4, emit: emit2, proxy } = vm2;
  let fullscreenFillerNode, container;
  const inFullscreen = ref(false);
  vmHasRouter(vm2) === true && watch(() => proxy.$route.fullPath, () => {
    props4.noRouteFullscreenExit !== true && exitFullscreen();
  });
  watch(() => props4.fullscreen, (v2) => {
    if (inFullscreen.value !== v2) {
      toggleFullscreen();
    }
  });
  watch(inFullscreen, (v2) => {
    emit2("update:fullscreen", v2);
    emit2("fullscreen", v2);
  });
  function toggleFullscreen() {
    if (inFullscreen.value === true) {
      exitFullscreen();
    } else {
      setFullscreen();
    }
  }
  function setFullscreen() {
    if (inFullscreen.value === true) {
      return;
    }
    inFullscreen.value = true;
    container = proxy.$el.parentNode;
    container.replaceChild(fullscreenFillerNode, proxy.$el);
    document.body.appendChild(proxy.$el);
    counter++;
    if (counter === 1) {
      document.body.classList.add("q-body--fullscreen-mixin");
    }
  }
  function exitFullscreen() {
    if (inFullscreen.value !== true) {
      return;
    }
    container.replaceChild(proxy.$el, fullscreenFillerNode);
    inFullscreen.value = false;
    counter = Math.max(0, counter - 1);
    if (counter === 0) {
      document.body.classList.remove("q-body--fullscreen-mixin");
      if (proxy.$el.scrollIntoView !== void 0) {
        setTimeout(() => {
          proxy.$el.scrollIntoView();
        });
      }
    }
  }
  onBeforeMount(() => {
    fullscreenFillerNode = document.createElement("span");
  });
  onMounted(() => {
    props4.fullscreen === true && setFullscreen();
  });
  onBeforeUnmount(exitFullscreen);
  Object.assign(proxy, {
    toggleFullscreen,
    setFullscreen,
    exitFullscreen
  });
  return {
    inFullscreen,
    toggleFullscreen
  };
}
var navigationPositionOptions = ["top", "right", "bottom", "left"];
var controlTypeOptions = ["regular", "flat", "outline", "push", "unelevated"];
createComponent({
  name: "QCarousel",
  props: {
    ...useDarkProps,
    ...usePanelProps,
    ...useFullscreenProps,
    transitionPrev: {
      // usePanelParentProps override
      type: String,
      default: "fade"
    },
    transitionNext: {
      // usePanelParentProps override
      type: String,
      default: "fade"
    },
    height: String,
    padding: Boolean,
    controlColor: String,
    controlTextColor: String,
    controlType: {
      type: String,
      validator: (v2) => controlTypeOptions.includes(v2),
      default: "flat"
    },
    autoplay: [Number, Boolean],
    arrows: Boolean,
    prevIcon: String,
    nextIcon: String,
    navigation: Boolean,
    navigationPosition: {
      type: String,
      validator: (v2) => navigationPositionOptions.includes(v2)
    },
    navigationIcon: String,
    navigationActiveIcon: String,
    thumbnails: Boolean
  },
  emits: [
    ...useFullscreenEmits,
    ...usePanelEmits
  ],
  setup(props4, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = use_dark_default(props4, $q);
    let timer2 = null, panelsLen;
    const {
      updatePanelsList,
      getPanelContent,
      panelDirectives,
      goToPanel,
      previousPanel,
      nextPanel,
      getEnabledPanels,
      panelIndex
    } = use_panel_default();
    const { inFullscreen } = use_fullscreen_default();
    const style2 = computed(() => inFullscreen.value !== true && props4.height !== void 0 ? { height: props4.height } : {});
    const direction = computed(() => props4.vertical === true ? "vertical" : "horizontal");
    const navigationPosition = computed(
      () => props4.navigationPosition || (props4.vertical === true ? "right" : "bottom")
    );
    const classes = computed(
      () => `q-carousel q-panel-parent q-carousel--with${props4.padding === true ? "" : "out"}-padding` + (inFullscreen.value === true ? " fullscreen" : "") + (isDark.value === true ? " q-carousel--dark q-dark" : "") + (props4.arrows === true ? ` q-carousel--arrows-${direction.value}` : "") + (props4.navigation === true ? ` q-carousel--navigation-${navigationPosition.value}` : "")
    );
    const arrowIcons = computed(() => {
      const ico = [
        props4.prevIcon || $q.iconSet.carousel[props4.vertical === true ? "up" : "left"],
        props4.nextIcon || $q.iconSet.carousel[props4.vertical === true ? "down" : "right"]
      ];
      return props4.vertical === false && $q.lang.rtl === true ? ico.reverse() : ico;
    });
    const navIcon = computed(() => props4.navigationIcon || $q.iconSet.carousel.navigationIcon);
    const navActiveIcon = computed(() => props4.navigationActiveIcon || navIcon.value);
    const controlProps = computed(() => ({
      color: props4.controlColor,
      textColor: props4.controlTextColor,
      round: true,
      [props4.controlType]: true,
      dense: true
    }));
    watch(() => props4.modelValue, () => {
      if (props4.autoplay) {
        startTimer();
      }
    });
    watch(() => props4.autoplay, (val) => {
      if (val) {
        startTimer();
      } else if (timer2 !== null) {
        clearTimeout(timer2);
        timer2 = null;
      }
    });
    function startTimer() {
      const duration2 = isNumber(props4.autoplay) === true ? Math.abs(props4.autoplay) : 5e3;
      timer2 !== null && clearTimeout(timer2);
      timer2 = setTimeout(() => {
        timer2 = null;
        if (duration2 >= 0) {
          nextPanel();
        } else {
          previousPanel();
        }
      }, duration2);
    }
    onMounted(() => {
      props4.autoplay && startTimer();
    });
    onBeforeUnmount(() => {
      timer2 !== null && clearTimeout(timer2);
    });
    function getNavigationContainer(type, mapping) {
      return h("div", {
        class: `q-carousel__control q-carousel__navigation no-wrap absolute flex q-carousel__navigation--${type} q-carousel__navigation--${navigationPosition.value}` + (props4.controlColor !== void 0 ? ` text-${props4.controlColor}` : "")
      }, [
        h("div", {
          class: "q-carousel__navigation-inner flex flex-center no-wrap"
        }, getEnabledPanels().map(mapping))
      ]);
    }
    function getContent() {
      const node = [];
      if (props4.navigation === true) {
        const fn = slots["navigation-icon"] !== void 0 ? slots["navigation-icon"] : (opts) => h(QBtn_default, {
          key: "nav" + opts.name,
          class: `q-carousel__navigation-icon q-carousel__navigation-icon--${opts.active === true ? "" : "in"}active`,
          ...opts.btnProps,
          onClick: opts.onClick
        });
        const maxIndex = panelsLen - 1;
        node.push(
          getNavigationContainer("buttons", (panel, index) => {
            const name2 = panel.props.name;
            const active = panelIndex.value === index;
            return fn({
              index,
              maxIndex,
              name: name2,
              active,
              btnProps: {
                icon: active === true ? navActiveIcon.value : navIcon.value,
                size: "sm",
                ...controlProps.value
              },
              onClick: () => {
                goToPanel(name2);
              }
            });
          })
        );
      } else if (props4.thumbnails === true) {
        const color = props4.controlColor !== void 0 ? ` text-${props4.controlColor}` : "";
        node.push(getNavigationContainer("thumbnails", (panel) => {
          const slide = panel.props;
          return h("img", {
            key: "tmb#" + slide.name,
            class: `q-carousel__thumbnail q-carousel__thumbnail--${slide.name === props4.modelValue ? "" : "in"}active` + color,
            src: slide.imgSrc || slide["img-src"],
            onClick: () => {
              goToPanel(slide.name);
            }
          });
        }));
      }
      if (props4.arrows === true && panelIndex.value >= 0) {
        if (props4.infinite === true || panelIndex.value > 0) {
          node.push(
            h("div", {
              key: "prev",
              class: `q-carousel__control q-carousel__arrow q-carousel__prev-arrow q-carousel__prev-arrow--${direction.value} absolute flex flex-center`
            }, [
              h(QBtn_default, {
                icon: arrowIcons.value[0],
                ...controlProps.value,
                onClick: previousPanel
              })
            ])
          );
        }
        if (props4.infinite === true || panelIndex.value < panelsLen - 1) {
          node.push(
            h("div", {
              key: "next",
              class: `q-carousel__control q-carousel__arrow q-carousel__next-arrow q-carousel__next-arrow--${direction.value} absolute flex flex-center`
            }, [
              h(QBtn_default, {
                icon: arrowIcons.value[1],
                ...controlProps.value,
                onClick: nextPanel
              })
            ])
          );
        }
      }
      return hMergeSlot(slots.control, node);
    }
    return () => {
      panelsLen = updatePanelsList(slots);
      return h("div", {
        class: classes.value,
        style: style2.value
      }, [
        hDir(
          "div",
          { class: "q-carousel__slides-container" },
          getPanelContent(),
          "sl-cont",
          props4.swipeable,
          () => panelDirectives.value
        )
      ].concat(getContent()));
    };
  }
});
createComponent({
  name: "QCarouselSlide",
  props: {
    ...usePanelChildProps,
    imgSrc: String
  },
  setup(props4, { slots }) {
    const style2 = computed(() => props4.imgSrc ? { backgroundImage: `url("${props4.imgSrc}")` } : {});
    return () => h("div", {
      class: "q-carousel__slide",
      style: style2.value
    }, hSlot(slots.default));
  }
});
createComponent({
  name: "QCarouselControl",
  props: {
    position: {
      type: String,
      default: "bottom-right",
      validator: (v2) => [
        "top-right",
        "top-left",
        "bottom-right",
        "bottom-left",
        "top",
        "right",
        "bottom",
        "left"
      ].includes(v2)
    },
    offset: {
      type: Array,
      default: () => [18, 18],
      validator: (v2) => v2.length === 2
    }
  },
  setup(props4, { slots }) {
    const classes = computed(() => `q-carousel__control absolute absolute-${props4.position}`);
    const style2 = computed(() => ({
      margin: `${props4.offset[1]}px ${props4.offset[0]}px`
    }));
    return () => h("div", {
      class: classes.value,
      style: style2.value
    }, hSlot(slots.default));
  }
});
createComponent({
  name: "QChatMessage",
  props: {
    sent: Boolean,
    label: String,
    bgColor: String,
    textColor: String,
    name: String,
    avatar: String,
    text: Array,
    stamp: String,
    size: String,
    labelHtml: Boolean,
    nameHtml: Boolean,
    textHtml: Boolean,
    stampHtml: Boolean
  },
  setup(props4, { slots }) {
    const op = computed(() => props4.sent === true ? "sent" : "received");
    const textClass = computed(
      () => `q-message-text-content q-message-text-content--${op.value}` + (props4.textColor !== void 0 ? ` text-${props4.textColor}` : "")
    );
    const messageClass = computed(
      () => `q-message-text q-message-text--${op.value}` + (props4.bgColor !== void 0 ? ` text-${props4.bgColor}` : "")
    );
    const containerClass = computed(
      () => "q-message-container row items-end no-wrap" + (props4.sent === true ? " reverse" : "")
    );
    const sizeClass = computed(() => props4.size !== void 0 ? `col-${props4.size}` : "");
    const domProps = computed(() => ({
      msg: props4.textHtml === true ? "innerHTML" : "textContent",
      stamp: props4.stampHtml === true ? "innerHTML" : "textContent",
      name: props4.nameHtml === true ? "innerHTML" : "textContent",
      label: props4.labelHtml === true ? "innerHTML" : "textContent"
    }));
    function wrapStamp(node) {
      if (slots.stamp !== void 0) {
        return [node, h("div", { class: "q-message-stamp" }, slots.stamp())];
      }
      if (props4.stamp) {
        return [
          node,
          h("div", {
            class: "q-message-stamp",
            [domProps.value.stamp]: props4.stamp
          })
        ];
      }
      return [node];
    }
    function getText(contentList, withSlots) {
      const content = withSlots === true ? contentList.length > 1 ? (text) => text : (text) => h("div", [text]) : (text) => h("div", { [domProps.value.msg]: text });
      return contentList.map((msg, index) => h("div", {
        key: index,
        class: messageClass.value
      }, [
        h("div", { class: textClass.value }, wrapStamp(content(msg)))
      ]));
    }
    return () => {
      const container = [];
      if (slots.avatar !== void 0) {
        container.push(slots.avatar());
      } else if (props4.avatar !== void 0) {
        container.push(
          h("img", {
            class: `q-message-avatar q-message-avatar--${op.value}`,
            src: props4.avatar,
            "aria-hidden": "true"
          })
        );
      }
      const msg = [];
      if (slots.name !== void 0) {
        msg.push(
          h("div", { class: `q-message-name q-message-name--${op.value}` }, slots.name())
        );
      } else if (props4.name !== void 0) {
        msg.push(
          h("div", {
            class: `q-message-name q-message-name--${op.value}`,
            [domProps.value.name]: props4.name
          })
        );
      }
      if (slots.default !== void 0) {
        msg.push(
          getText(
            getNormalizedVNodes(slots.default()),
            true
          )
        );
      } else if (props4.text !== void 0) {
        msg.push(getText(props4.text));
      }
      container.push(
        h("div", { class: sizeClass.value }, msg)
      );
      const child = [];
      if (slots.label !== void 0) {
        child.push(
          h("div", { class: "q-message-label" }, slots.label())
        );
      } else if (props4.label !== void 0) {
        child.push(
          h("div", {
            class: "q-message-label",
            [domProps.value.label]: props4.label
          })
        );
      }
      child.push(
        h("div", { class: containerClass.value }, container)
      );
      return h("div", {
        class: `q-message q-message-${op.value}`
      }, child);
    };
  }
});
function use_refocus_target_default(props4, rootRef) {
  const refocusRef = ref(null);
  const refocusTargetEl = computed(() => {
    if (props4.disable === true) {
      return null;
    }
    return h("span", {
      ref: refocusRef,
      class: "no-outline",
      tabindex: -1
    });
  });
  function refocusTarget(e) {
    const root = rootRef.value;
    if (e !== void 0 && e.type.indexOf("key") === 0) {
      if (root !== null && document.activeElement !== root && root.contains(document.activeElement) === true) {
        root.focus();
      }
    } else if (refocusRef.value !== null && (e === void 0 || root !== null && root.contains(e.target) === true)) {
      refocusRef.value.focus();
    }
  }
  return {
    refocusTargetEl,
    refocusTarget
  };
}
var option_sizes_default = {
  xs: 30,
  sm: 35,
  md: 40,
  lg: 50,
  xl: 60
};
var useCheckboxProps = {
  ...useDarkProps,
  ...useSizeProps,
  ...useFormProps,
  modelValue: {
    required: true,
    default: null
  },
  val: {},
  trueValue: { default: true },
  falseValue: { default: false },
  indeterminateValue: { default: null },
  checkedIcon: String,
  uncheckedIcon: String,
  indeterminateIcon: String,
  toggleOrder: {
    type: String,
    validator: (v2) => v2 === "tf" || v2 === "ft"
  },
  toggleIndeterminate: Boolean,
  label: String,
  leftLabel: Boolean,
  color: String,
  keepColor: Boolean,
  dense: Boolean,
  disable: Boolean,
  tabindex: [String, Number]
};
var useCheckboxEmits = ["update:modelValue"];
function use_checkbox_default(type, getInner) {
  const { props: props4, slots, emit: emit2, proxy } = getCurrentInstance();
  const { $q } = proxy;
  const isDark = use_dark_default(props4, $q);
  const rootRef = ref(null);
  const { refocusTargetEl, refocusTarget } = use_refocus_target_default(props4, rootRef);
  const sizeStyle = use_size_default(props4, option_sizes_default);
  const modelIsArray = computed(
    () => props4.val !== void 0 && Array.isArray(props4.modelValue)
  );
  const index = computed(() => {
    const val = toRaw(props4.val);
    return modelIsArray.value === true ? props4.modelValue.findIndex((opt) => toRaw(opt) === val) : -1;
  });
  const isTrue = computed(() => modelIsArray.value === true ? index.value !== -1 : toRaw(props4.modelValue) === toRaw(props4.trueValue));
  const isFalse = computed(() => modelIsArray.value === true ? index.value === -1 : toRaw(props4.modelValue) === toRaw(props4.falseValue));
  const isIndeterminate = computed(
    () => isTrue.value === false && isFalse.value === false
  );
  const tabindex = computed(() => props4.disable === true ? -1 : props4.tabindex || 0);
  const classes = computed(
    () => `q-${type} cursor-pointer no-outline row inline no-wrap items-center` + (props4.disable === true ? " disabled" : "") + (isDark.value === true ? ` q-${type}--dark` : "") + (props4.dense === true ? ` q-${type}--dense` : "") + (props4.leftLabel === true ? " reverse" : "")
  );
  const innerClass = computed(() => {
    const state = isTrue.value === true ? "truthy" : isFalse.value === true ? "falsy" : "indet";
    const color = props4.color !== void 0 && (props4.keepColor === true || (type === "toggle" ? isTrue.value === true : isFalse.value !== true)) ? ` text-${props4.color}` : "";
    return `q-${type}__inner relative-position non-selectable q-${type}__inner--${state}${color}`;
  });
  const formAttrs = computed(() => {
    const prop = { type: "checkbox" };
    props4.name !== void 0 && Object.assign(prop, {
      // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
      ".checked": isTrue.value,
      "^checked": isTrue.value === true ? "checked" : void 0,
      name: props4.name,
      value: modelIsArray.value === true ? props4.val : props4.trueValue
    });
    return prop;
  });
  const injectFormInput = useFormInject(formAttrs);
  const attributes = computed(() => {
    const attrs = {
      tabindex: tabindex.value,
      role: type === "toggle" ? "switch" : "checkbox",
      "aria-label": props4.label,
      "aria-checked": isIndeterminate.value === true ? "mixed" : isTrue.value === true ? "true" : "false"
    };
    if (props4.disable === true) {
      attrs["aria-disabled"] = "true";
    }
    return attrs;
  });
  function onClick(e) {
    if (e !== void 0) {
      stopAndPrevent(e);
      refocusTarget(e);
    }
    if (props4.disable !== true) {
      emit2("update:modelValue", getNextValue(), e);
    }
  }
  function getNextValue() {
    if (modelIsArray.value === true) {
      if (isTrue.value === true) {
        const val = props4.modelValue.slice();
        val.splice(index.value, 1);
        return val;
      }
      return props4.modelValue.concat([props4.val]);
    }
    if (isTrue.value === true) {
      if (props4.toggleOrder !== "ft" || props4.toggleIndeterminate === false) {
        return props4.falseValue;
      }
    } else if (isFalse.value === true) {
      if (props4.toggleOrder === "ft" || props4.toggleIndeterminate === false) {
        return props4.trueValue;
      }
    } else {
      return props4.toggleOrder !== "ft" ? props4.trueValue : props4.falseValue;
    }
    return props4.indeterminateValue;
  }
  function onKeydown2(e) {
    if (e.keyCode === 13 || e.keyCode === 32) {
      stopAndPrevent(e);
    }
  }
  function onKeyup2(e) {
    if (e.keyCode === 13 || e.keyCode === 32) {
      onClick(e);
    }
  }
  const getInnerContent = getInner(isTrue, isIndeterminate);
  Object.assign(proxy, { toggle: onClick });
  return () => {
    const inner = getInnerContent();
    props4.disable !== true && injectFormInput(
      inner,
      "unshift",
      ` q-${type}__native absolute q-ma-none q-pa-none`
    );
    const child = [
      h("div", {
        class: innerClass.value,
        style: sizeStyle.value,
        "aria-hidden": "true"
      }, inner)
    ];
    if (refocusTargetEl.value !== null) {
      child.push(refocusTargetEl.value);
    }
    const label2 = props4.label !== void 0 ? hMergeSlot(slots.default, [props4.label]) : hSlot(slots.default);
    label2 !== void 0 && child.push(
      h("div", {
        class: `q-${type}__label q-anchor--skip`
      }, label2)
    );
    return h("div", {
      ref: rootRef,
      class: classes.value,
      ...attributes.value,
      onClick,
      onKeydown: onKeydown2,
      onKeyup: onKeyup2
    }, child);
  };
}
var createBgNode = () => h("div", {
  key: "svg",
  class: "q-checkbox__bg absolute"
}, [
  h("svg", {
    class: "q-checkbox__svg fit absolute-full",
    viewBox: "0 0 24 24"
  }, [
    h("path", {
      class: "q-checkbox__truthy",
      fill: "none",
      d: "M1.73,12.91 8.1,19.28 22.79,4.59"
    }),
    h("path", {
      class: "q-checkbox__indet",
      d: "M4,14H20V10H4"
    })
  ])
]);
var QCheckbox_default = createComponent({
  name: "QCheckbox",
  props: useCheckboxProps,
  emits: useCheckboxEmits,
  setup(props4) {
    const bgNode = createBgNode();
    function getInner(isTrue, isIndeterminate) {
      const icon2 = computed(
        () => (isTrue.value === true ? props4.checkedIcon : isIndeterminate.value === true ? props4.indeterminateIcon : props4.uncheckedIcon) || null
      );
      return () => icon2.value !== null ? [
        h("div", {
          key: "icon",
          class: "q-checkbox__icon-container absolute-full flex flex-center no-wrap"
        }, [
          h(QIcon_default, {
            class: "q-checkbox__icon",
            name: icon2.value
          })
        ])
      ] : [bgNode];
    }
    return use_checkbox_default("checkbox", getInner);
  }
});
var defaultSizes2 = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
};
var QChip_default = createComponent({
  name: "QChip",
  props: {
    ...useDarkProps,
    ...useSizeProps,
    dense: Boolean,
    icon: String,
    iconRight: String,
    iconRemove: String,
    iconSelected: String,
    label: [String, Number],
    color: String,
    textColor: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    selected: {
      type: Boolean,
      default: null
    },
    square: Boolean,
    outline: Boolean,
    clickable: Boolean,
    removable: Boolean,
    removeAriaLabel: String,
    tabindex: [String, Number],
    disable: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: true
    }
  },
  emits: ["update:modelValue", "update:selected", "remove", "click"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = use_dark_default(props4, $q);
    const sizeStyle = use_size_default(props4, defaultSizes2);
    const hasLeftIcon = computed(() => props4.selected === true || props4.icon !== void 0);
    const leftIcon = computed(() => props4.selected === true ? props4.iconSelected || $q.iconSet.chip.selected : props4.icon);
    const removeIcon = computed(() => props4.iconRemove || $q.iconSet.chip.remove);
    const isClickable = computed(
      () => props4.disable === false && (props4.clickable === true || props4.selected !== null)
    );
    const classes = computed(() => {
      const text = props4.outline === true ? props4.color || props4.textColor : props4.textColor;
      return "q-chip row inline no-wrap items-center" + (props4.outline === false && props4.color !== void 0 ? ` bg-${props4.color}` : "") + (text ? ` text-${text} q-chip--colored` : "") + (props4.disable === true ? " disabled" : "") + (props4.dense === true ? " q-chip--dense" : "") + (props4.outline === true ? " q-chip--outline" : "") + (props4.selected === true ? " q-chip--selected" : "") + (isClickable.value === true ? " q-chip--clickable cursor-pointer non-selectable q-hoverable" : "") + (props4.square === true ? " q-chip--square" : "") + (isDark.value === true ? " q-chip--dark q-dark" : "");
    });
    const attributes = computed(() => {
      const chip = props4.disable === true ? { tabindex: -1, "aria-disabled": "true" } : { tabindex: props4.tabindex || 0 };
      const remove2 = {
        ...chip,
        role: "button",
        "aria-hidden": "false",
        "aria-label": props4.removeAriaLabel || $q.lang.label.remove
      };
      return { chip, remove: remove2 };
    });
    function onKeyup2(e) {
      e.keyCode === 13 && onClick(e);
    }
    function onClick(e) {
      if (!props4.disable) {
        emit2("update:selected", !props4.selected);
        emit2("click", e);
      }
    }
    function onRemove(e) {
      if (e.keyCode === void 0 || e.keyCode === 13) {
        stopAndPrevent(e);
        if (props4.disable === false) {
          emit2("update:modelValue", false);
          emit2("remove");
        }
      }
    }
    function getContent() {
      const child = [];
      isClickable.value === true && child.push(
        h("div", { class: "q-focus-helper" })
      );
      hasLeftIcon.value === true && child.push(
        h(QIcon_default, {
          class: "q-chip__icon q-chip__icon--left",
          name: leftIcon.value
        })
      );
      const label2 = props4.label !== void 0 ? [h("div", { class: "ellipsis" }, [props4.label])] : void 0;
      child.push(
        h("div", {
          class: "q-chip__content col row no-wrap items-center q-anchor--skip"
        }, hMergeSlotSafely(slots.default, label2))
      );
      props4.iconRight && child.push(
        h(QIcon_default, {
          class: "q-chip__icon q-chip__icon--right",
          name: props4.iconRight
        })
      );
      props4.removable === true && child.push(
        h(QIcon_default, {
          class: "q-chip__icon q-chip__icon--remove cursor-pointer",
          name: removeIcon.value,
          ...attributes.value.remove,
          onClick: onRemove,
          onKeyup: onRemove
        })
      );
      return child;
    }
    return () => {
      if (props4.modelValue === false) return;
      const data = {
        class: classes.value,
        style: sizeStyle.value
      };
      isClickable.value === true && Object.assign(
        data,
        attributes.value.chip,
        { onClick, onKeyup: onKeyup2 }
      );
      return hDir(
        "div",
        data,
        getContent(),
        "ripple",
        props4.ripple !== false && props4.disable !== true,
        () => [[Ripple_default, props4.ripple]]
      );
    };
  }
});
var useCircularCommonProps = {
  ...useSizeProps,
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  color: String,
  centerColor: String,
  trackColor: String,
  fontSize: String,
  rounded: Boolean,
  // ratio
  thickness: {
    type: Number,
    default: 0.2,
    validator: (v2) => v2 >= 0 && v2 <= 1
  },
  angle: {
    type: Number,
    default: 0
  },
  showValue: Boolean,
  reverse: Boolean,
  instantFeedback: Boolean
};
var radius = 50;
var diameter = 2 * radius;
var circumference = diameter * Math.PI;
var strokeDashArray = Math.round(circumference * 1e3) / 1e3;
var QCircularProgress_default = createComponent({
  name: "QCircularProgress",
  props: {
    ...useCircularCommonProps,
    value: {
      type: Number,
      default: 0
    },
    animationSpeed: {
      type: [String, Number],
      default: 600
    },
    indeterminate: Boolean
  },
  setup(props4, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const sizeStyle = use_size_default(props4);
    const svgStyle = computed(() => {
      const angle = ($q.lang.rtl === true ? -1 : 1) * props4.angle;
      return {
        transform: props4.reverse !== ($q.lang.rtl === true) ? `scale3d(-1, 1, 1) rotate3d(0, 0, 1, ${-90 - angle}deg)` : `rotate3d(0, 0, 1, ${angle - 90}deg)`
      };
    });
    const circleStyle = computed(() => props4.instantFeedback !== true && props4.indeterminate !== true ? { transition: `stroke-dashoffset ${props4.animationSpeed}ms ease 0s, stroke ${props4.animationSpeed}ms ease` } : "");
    const viewBox = computed(() => diameter / (1 - props4.thickness / 2));
    const viewBoxAttr = computed(
      () => `${viewBox.value / 2} ${viewBox.value / 2} ${viewBox.value} ${viewBox.value}`
    );
    const normalized = computed(() => between(props4.value, props4.min, props4.max));
    const range = computed(() => props4.max - props4.min);
    const strokeWidth = computed(() => props4.thickness / 2 * viewBox.value);
    const strokeDashOffset = computed(() => {
      const dashRatio = (props4.max - normalized.value) / range.value;
      const dashGap = props4.rounded === true && normalized.value < props4.max && dashRatio < 0.25 ? strokeWidth.value / 2 * (1 - dashRatio / 0.25) : 0;
      return circumference * dashRatio + dashGap;
    });
    function getCircle({ thickness, offset: offset2, color, cls, rounded }) {
      return h("circle", {
        class: "q-circular-progress__" + cls + (color !== void 0 ? ` text-${color}` : ""),
        style: circleStyle.value,
        fill: "transparent",
        stroke: "currentColor",
        "stroke-width": thickness,
        "stroke-dasharray": strokeDashArray,
        "stroke-dashoffset": offset2,
        "stroke-linecap": rounded,
        cx: viewBox.value,
        cy: viewBox.value,
        r: radius
      });
    }
    return () => {
      const svgChild = [];
      props4.centerColor !== void 0 && props4.centerColor !== "transparent" && svgChild.push(
        h("circle", {
          class: `q-circular-progress__center text-${props4.centerColor}`,
          fill: "currentColor",
          r: radius - strokeWidth.value / 2,
          cx: viewBox.value,
          cy: viewBox.value
        })
      );
      props4.trackColor !== void 0 && props4.trackColor !== "transparent" && svgChild.push(
        getCircle({
          cls: "track",
          thickness: strokeWidth.value,
          offset: 0,
          color: props4.trackColor
        })
      );
      svgChild.push(
        getCircle({
          cls: "circle",
          thickness: strokeWidth.value,
          offset: strokeDashOffset.value,
          color: props4.color,
          rounded: props4.rounded === true ? "round" : void 0
        })
      );
      const child = [
        h("svg", {
          class: "q-circular-progress__svg",
          style: svgStyle.value,
          viewBox: viewBoxAttr.value,
          "aria-hidden": "true"
        }, svgChild)
      ];
      props4.showValue === true && child.push(
        h("div", {
          class: "q-circular-progress__text absolute-full row flex-center content-center",
          style: { fontSize: props4.fontSize }
        }, slots.default !== void 0 ? slots.default() : [h("div", normalized.value)])
      );
      return h("div", {
        class: `q-circular-progress q-circular-progress--${props4.indeterminate === true ? "in" : ""}determinate`,
        style: sizeStyle.value,
        role: "progressbar",
        "aria-valuemin": props4.min,
        "aria-valuemax": props4.max,
        "aria-valuenow": props4.indeterminate === true ? void 0 : normalized.value
      }, hMergeSlotSafely(slots.internal, child));
    };
  }
});
function getChanges(evt, ctx, isFinal) {
  const pos = position(evt);
  let dir, distX = pos.left - ctx.event.x, distY = pos.top - ctx.event.y, absX = Math.abs(distX), absY = Math.abs(distY);
  const direction = ctx.direction;
  if (direction.horizontal === true && direction.vertical !== true) {
    dir = distX < 0 ? "left" : "right";
  } else if (direction.horizontal !== true && direction.vertical === true) {
    dir = distY < 0 ? "up" : "down";
  } else if (direction.up === true && distY < 0) {
    dir = "up";
    if (absX > absY) {
      if (direction.left === true && distX < 0) {
        dir = "left";
      } else if (direction.right === true && distX > 0) {
        dir = "right";
      }
    }
  } else if (direction.down === true && distY > 0) {
    dir = "down";
    if (absX > absY) {
      if (direction.left === true && distX < 0) {
        dir = "left";
      } else if (direction.right === true && distX > 0) {
        dir = "right";
      }
    }
  } else if (direction.left === true && distX < 0) {
    dir = "left";
    if (absX < absY) {
      if (direction.up === true && distY < 0) {
        dir = "up";
      } else if (direction.down === true && distY > 0) {
        dir = "down";
      }
    }
  } else if (direction.right === true && distX > 0) {
    dir = "right";
    if (absX < absY) {
      if (direction.up === true && distY < 0) {
        dir = "up";
      } else if (direction.down === true && distY > 0) {
        dir = "down";
      }
    }
  }
  let synthetic = false;
  if (dir === void 0 && isFinal === false) {
    if (ctx.event.isFirst === true || ctx.event.lastDir === void 0) {
      return {};
    }
    dir = ctx.event.lastDir;
    synthetic = true;
    if (dir === "left" || dir === "right") {
      pos.left -= distX;
      absX = 0;
      distX = 0;
    } else {
      pos.top -= distY;
      absY = 0;
      distY = 0;
    }
  }
  return {
    synthetic,
    payload: {
      evt,
      touch: ctx.event.mouse !== true,
      mouse: ctx.event.mouse === true,
      position: pos,
      direction: dir,
      isFirst: ctx.event.isFirst,
      isFinal: isFinal === true,
      duration: Date.now() - ctx.event.time,
      distance: {
        x: absX,
        y: absY
      },
      offset: {
        x: distX,
        y: distY
      },
      delta: {
        x: pos.left - ctx.event.lastX,
        y: pos.top - ctx.event.lastY
      }
    }
  };
}
var uid = 0;
var TouchPan_default = createDirective(
  {
    name: "touch-pan",
    beforeMount(el, { value: value2, modifiers }) {
      if (modifiers.mouse !== true && client.has.touch !== true) {
        return;
      }
      function handleEvent(evt, mouseEvent) {
        if (modifiers.mouse === true && mouseEvent === true) {
          stopAndPrevent(evt);
        } else {
          modifiers.stop === true && stop(evt);
          modifiers.prevent === true && prevent(evt);
        }
      }
      const ctx = {
        uid: "qvtp_" + uid++,
        handler: value2,
        modifiers,
        direction: getModifierDirections(modifiers),
        noop,
        mouseStart(evt) {
          if (shouldStart(evt, ctx) && leftClick(evt)) {
            addEvt(ctx, "temp", [
              [document, "mousemove", "move", "notPassiveCapture"],
              [document, "mouseup", "end", "passiveCapture"]
            ]);
            ctx.start(evt, true);
          }
        },
        touchStart(evt) {
          if (shouldStart(evt, ctx)) {
            const target2 = evt.target;
            addEvt(ctx, "temp", [
              [target2, "touchmove", "move", "notPassiveCapture"],
              [target2, "touchcancel", "end", "passiveCapture"],
              [target2, "touchend", "end", "passiveCapture"]
            ]);
            ctx.start(evt);
          }
        },
        start(evt, mouseEvent) {
          client.is.firefox === true && preventDraggable(el, true);
          ctx.lastEvt = evt;
          if (mouseEvent === true || modifiers.stop === true) {
            if (ctx.direction.all !== true && (mouseEvent !== true || ctx.modifiers.mouseAllDir !== true && ctx.modifiers.mousealldir !== true)) {
              const clone2 = evt.type.indexOf("mouse") !== -1 ? new MouseEvent(evt.type, evt) : new TouchEvent(evt.type, evt);
              evt.defaultPrevented === true && prevent(clone2);
              evt.cancelBubble === true && stop(clone2);
              Object.assign(clone2, {
                qKeyEvent: evt.qKeyEvent,
                qClickOutside: evt.qClickOutside,
                qAnchorHandled: evt.qAnchorHandled,
                qClonedBy: evt.qClonedBy === void 0 ? [ctx.uid] : evt.qClonedBy.concat(ctx.uid)
              });
              ctx.initialEvent = {
                target: evt.target,
                event: clone2
              };
            }
            stop(evt);
          }
          const { left, top } = position(evt);
          ctx.event = {
            x: left,
            y: top,
            time: Date.now(),
            mouse: mouseEvent === true,
            detected: false,
            isFirst: true,
            isFinal: false,
            lastX: left,
            lastY: top
          };
        },
        move(evt) {
          if (ctx.event === void 0) {
            return;
          }
          const pos = position(evt), distX = pos.left - ctx.event.x, distY = pos.top - ctx.event.y;
          if (distX === 0 && distY === 0) {
            return;
          }
          ctx.lastEvt = evt;
          const isMouseEvt = ctx.event.mouse === true;
          const start = () => {
            handleEvent(evt, isMouseEvt);
            let cursor;
            if (modifiers.preserveCursor !== true && modifiers.preservecursor !== true) {
              cursor = document.documentElement.style.cursor || "";
              document.documentElement.style.cursor = "grabbing";
            }
            isMouseEvt === true && document.body.classList.add("no-pointer-events--children");
            document.body.classList.add("non-selectable");
            clearSelection();
            ctx.styleCleanup = (withDelayedFn) => {
              ctx.styleCleanup = void 0;
              if (cursor !== void 0) {
                document.documentElement.style.cursor = cursor;
              }
              document.body.classList.remove("non-selectable");
              if (isMouseEvt === true) {
                const remove2 = () => {
                  document.body.classList.remove("no-pointer-events--children");
                };
                if (withDelayedFn !== void 0) {
                  setTimeout(() => {
                    remove2();
                    withDelayedFn();
                  }, 50);
                } else {
                  remove2();
                }
              } else if (withDelayedFn !== void 0) {
                withDelayedFn();
              }
            };
          };
          if (ctx.event.detected === true) {
            ctx.event.isFirst !== true && handleEvent(evt, ctx.event.mouse);
            const { payload, synthetic } = getChanges(evt, ctx, false);
            if (payload !== void 0) {
              if (ctx.handler(payload) === false) {
                ctx.end(evt);
              } else {
                if (ctx.styleCleanup === void 0 && ctx.event.isFirst === true) {
                  start();
                }
                ctx.event.lastX = payload.position.left;
                ctx.event.lastY = payload.position.top;
                ctx.event.lastDir = synthetic === true ? void 0 : payload.direction;
                ctx.event.isFirst = false;
              }
            }
            return;
          }
          if (ctx.direction.all === true || isMouseEvt === true && (ctx.modifiers.mouseAllDir === true || ctx.modifiers.mousealldir === true)) {
            start();
            ctx.event.detected = true;
            ctx.move(evt);
            return;
          }
          const absX = Math.abs(distX), absY = Math.abs(distY);
          if (absX !== absY) {
            if (ctx.direction.horizontal === true && absX > absY || ctx.direction.vertical === true && absX < absY || ctx.direction.up === true && absX < absY && distY < 0 || ctx.direction.down === true && absX < absY && distY > 0 || ctx.direction.left === true && absX > absY && distX < 0 || ctx.direction.right === true && absX > absY && distX > 0) {
              ctx.event.detected = true;
              ctx.move(evt);
            } else {
              ctx.end(evt, true);
            }
          }
        },
        end(evt, abort) {
          if (ctx.event === void 0) {
            return;
          }
          cleanEvt(ctx, "temp");
          client.is.firefox === true && preventDraggable(el, false);
          if (abort === true) {
            ctx.styleCleanup !== void 0 && ctx.styleCleanup();
            if (ctx.event.detected !== true && ctx.initialEvent !== void 0) {
              ctx.initialEvent.target.dispatchEvent(ctx.initialEvent.event);
            }
          } else if (ctx.event.detected === true) {
            ctx.event.isFirst === true && ctx.handler(getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx).payload);
            const { payload } = getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx, true);
            const fn = () => {
              ctx.handler(payload);
            };
            if (ctx.styleCleanup !== void 0) {
              ctx.styleCleanup(fn);
            } else {
              fn();
            }
          }
          ctx.event = void 0;
          ctx.initialEvent = void 0;
          ctx.lastEvt = void 0;
        }
      };
      el.__qtouchpan = ctx;
      if (modifiers.mouse === true) {
        const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true ? "Capture" : "";
        addEvt(ctx, "main", [
          [el, "mousedown", "mouseStart", `passive${capture}`]
        ]);
      }
      client.has.touch === true && addEvt(ctx, "main", [
        [el, "touchstart", "touchStart", `passive${modifiers.capture === true ? "Capture" : ""}`],
        [el, "touchmove", "noop", "notPassiveCapture"]
        // cannot be passive (ex: iOS scroll)
      ]);
    },
    updated(el, bindings) {
      const ctx = el.__qtouchpan;
      if (ctx !== void 0) {
        if (bindings.oldValue !== bindings.value) {
          typeof value !== "function" && ctx.end();
          ctx.handler = bindings.value;
        }
        ctx.direction = getModifierDirections(bindings.modifiers);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qtouchpan;
      if (ctx !== void 0) {
        ctx.event !== void 0 && ctx.end();
        cleanEvt(ctx, "main");
        cleanEvt(ctx, "temp");
        client.is.firefox === true && preventDraggable(el, false);
        ctx.styleCleanup !== void 0 && ctx.styleCleanup();
        delete el.__qtouchpan;
      }
    }
  }
);
var markerPrefixClass = "q-slider__marker-labels";
var defaultMarkerConvertFn = (v2) => ({ value: v2 });
var defaultMarkerLabelRenderFn = ({ marker }) => h("div", {
  key: marker.value,
  style: marker.style,
  class: marker.classes
}, marker.label);
var keyCodes = [34, 37, 40, 33, 39, 38];
var useSliderProps = {
  ...useDarkProps,
  ...useFormProps,
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  innerMin: Number,
  innerMax: Number,
  step: {
    type: Number,
    default: 1,
    validator: (v2) => v2 >= 0
  },
  snap: Boolean,
  vertical: Boolean,
  reverse: Boolean,
  color: String,
  markerLabelsClass: String,
  label: Boolean,
  labelColor: String,
  labelTextColor: String,
  labelAlways: Boolean,
  switchLabelSide: Boolean,
  markers: [Boolean, Number],
  markerLabels: [Boolean, Array, Object, Function],
  switchMarkerLabelsSide: Boolean,
  trackImg: String,
  trackColor: String,
  innerTrackImg: String,
  innerTrackColor: String,
  selectionColor: String,
  selectionImg: String,
  thumbSize: {
    type: String,
    default: "20px"
  },
  trackSize: {
    type: String,
    default: "4px"
  },
  disable: Boolean,
  readonly: Boolean,
  dense: Boolean,
  tabindex: [String, Number],
  thumbColor: String,
  thumbPath: {
    type: String,
    default: "M 4, 10 a 6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0"
  }
};
var useSliderEmits = ["pan", "update:modelValue", "change"];
function use_slider_default({ updateValue: updateValue2, updatePosition, getDragging, formAttrs }) {
  const { props: props4, emit: emit2, slots, proxy: { $q } } = getCurrentInstance();
  const isDark = use_dark_default(props4, $q);
  const injectFormInput = useFormInject(formAttrs);
  const active = ref(false);
  const preventFocus = ref(false);
  const focus = ref(false);
  const dragging = ref(false);
  const axis = computed(() => props4.vertical === true ? "--v" : "--h");
  const labelSide = computed(() => "-" + (props4.switchLabelSide === true ? "switched" : "standard"));
  const isReversed = computed(() => props4.vertical === true ? props4.reverse === true : props4.reverse !== ($q.lang.rtl === true));
  const innerMin = computed(() => isNaN(props4.innerMin) === true || props4.innerMin < props4.min ? props4.min : props4.innerMin);
  const innerMax = computed(() => isNaN(props4.innerMax) === true || props4.innerMax > props4.max ? props4.max : props4.innerMax);
  const editable = computed(() => props4.disable !== true && props4.readonly !== true && innerMin.value < innerMax.value);
  const roundValueFn = computed(() => {
    if (props4.step === 0) {
      return (v2) => v2;
    }
    const decimals = (String(props4.step).trim().split(".")[1] || "").length;
    return (v2) => parseFloat(v2.toFixed(decimals));
  });
  const keyStep = computed(() => props4.step === 0 ? 1 : props4.step);
  const tabindex = computed(() => editable.value === true ? props4.tabindex || 0 : -1);
  const trackLen = computed(() => props4.max - props4.min);
  const innerBarLen = computed(() => innerMax.value - innerMin.value);
  const innerMinRatio = computed(() => convertModelToRatio(innerMin.value));
  const innerMaxRatio = computed(() => convertModelToRatio(innerMax.value));
  const positionProp = computed(() => props4.vertical === true ? isReversed.value === true ? "bottom" : "top" : isReversed.value === true ? "right" : "left");
  const sizeProp = computed(() => props4.vertical === true ? "height" : "width");
  const thicknessProp = computed(() => props4.vertical === true ? "width" : "height");
  const orientation = computed(() => props4.vertical === true ? "vertical" : "horizontal");
  const attributes = computed(() => {
    const acc = {
      role: "slider",
      "aria-valuemin": innerMin.value,
      "aria-valuemax": innerMax.value,
      "aria-orientation": orientation.value,
      "data-step": props4.step
    };
    if (props4.disable === true) {
      acc["aria-disabled"] = "true";
    } else if (props4.readonly === true) {
      acc["aria-readonly"] = "true";
    }
    return acc;
  });
  const classes = computed(
    () => `q-slider q-slider${axis.value} q-slider--${active.value === true ? "" : "in"}active inline no-wrap ` + (props4.vertical === true ? "row" : "column") + (props4.disable === true ? " disabled" : " q-slider--enabled" + (editable.value === true ? " q-slider--editable" : "")) + (focus.value === "both" ? " q-slider--focus" : "") + (props4.label || props4.labelAlways === true ? " q-slider--label" : "") + (props4.labelAlways === true ? " q-slider--label-always" : "") + (isDark.value === true ? " q-slider--dark" : "") + (props4.dense === true ? " q-slider--dense q-slider--dense" + axis.value : "")
  );
  function getPositionClass(name2) {
    const cls = "q-slider__" + name2;
    return `${cls} ${cls}${axis.value} ${cls}${axis.value}${labelSide.value}`;
  }
  function getAxisClass(name2) {
    const cls = "q-slider__" + name2;
    return `${cls} ${cls}${axis.value}`;
  }
  const selectionBarClass = computed(() => {
    const color = props4.selectionColor || props4.color;
    return "q-slider__selection absolute" + (color !== void 0 ? ` text-${color}` : "");
  });
  const markerClass = computed(() => getAxisClass("markers") + " absolute overflow-hidden");
  const trackContainerClass = computed(() => getAxisClass("track-container"));
  const pinClass = computed(() => getPositionClass("pin"));
  const labelClass = computed(() => getPositionClass("label"));
  const textContainerClass = computed(() => getPositionClass("text-container"));
  const markerLabelsContainerClass = computed(
    () => getPositionClass("marker-labels-container") + (props4.markerLabelsClass !== void 0 ? ` ${props4.markerLabelsClass}` : "")
  );
  const trackClass = computed(
    () => "q-slider__track relative-position no-outline" + (props4.trackColor !== void 0 ? ` bg-${props4.trackColor}` : "")
  );
  const trackStyle = computed(() => {
    const acc = { [thicknessProp.value]: props4.trackSize };
    if (props4.trackImg !== void 0) {
      acc.backgroundImage = `url(${props4.trackImg}) !important`;
    }
    return acc;
  });
  const innerBarClass = computed(
    () => "q-slider__inner absolute" + (props4.innerTrackColor !== void 0 ? ` bg-${props4.innerTrackColor}` : "")
  );
  const innerBarStyle = computed(() => {
    const innerDiff = innerMaxRatio.value - innerMinRatio.value;
    const acc = {
      [positionProp.value]: `${100 * innerMinRatio.value}%`,
      [sizeProp.value]: innerDiff === 0 ? "2px" : `${100 * innerDiff}%`
    };
    if (props4.innerTrackImg !== void 0) {
      acc.backgroundImage = `url(${props4.innerTrackImg}) !important`;
    }
    return acc;
  });
  function convertRatioToModel(ratio) {
    const { min, max, step } = props4;
    let model = min + ratio * (max - min);
    if (step > 0) {
      const modulo = (model - innerMin.value) % step;
      model += (Math.abs(modulo) >= step / 2 ? (modulo < 0 ? -1 : 1) * step : 0) - modulo;
    }
    model = roundValueFn.value(model);
    return between(model, innerMin.value, innerMax.value);
  }
  function convertModelToRatio(model) {
    return trackLen.value === 0 ? 0 : (model - props4.min) / trackLen.value;
  }
  function getDraggingRatio(evt, dragging2) {
    const pos = position(evt), val = props4.vertical === true ? between((pos.top - dragging2.top) / dragging2.height, 0, 1) : between((pos.left - dragging2.left) / dragging2.width, 0, 1);
    return between(
      isReversed.value === true ? 1 - val : val,
      innerMinRatio.value,
      innerMaxRatio.value
    );
  }
  const markerStep = computed(
    () => isNumber(props4.markers) === true ? props4.markers : keyStep.value
  );
  const markerTicks = computed(() => {
    const acc = [];
    const step = markerStep.value;
    const max = props4.max;
    let value2 = props4.min;
    do {
      acc.push(value2);
      value2 += step;
    } while (value2 < max);
    acc.push(max);
    return acc;
  });
  const markerLabelClass = computed(() => {
    const prefix = ` ${markerPrefixClass}${axis.value}-`;
    return markerPrefixClass + `${prefix}${props4.switchMarkerLabelsSide === true ? "switched" : "standard"}${prefix}${isReversed.value === true ? "rtl" : "ltr"}`;
  });
  const markerLabelsList = computed(() => {
    if (props4.markerLabels === false) {
      return null;
    }
    return getMarkerList(props4.markerLabels).map((entry, index) => ({
      index,
      value: entry.value,
      label: entry.label || entry.value,
      classes: markerLabelClass.value + (entry.classes !== void 0 ? " " + entry.classes : ""),
      style: {
        ...getMarkerLabelStyle(entry.value),
        ...entry.style || {}
      }
    }));
  });
  const markerScope = computed(() => ({
    markerList: markerLabelsList.value,
    markerMap: markerLabelsMap.value,
    classes: markerLabelClass.value,
    // TODO ts definition
    getStyle: getMarkerLabelStyle
  }));
  const markerStyle = computed(() => {
    const size2 = innerBarLen.value === 0 ? "2px" : 100 * markerStep.value / innerBarLen.value;
    return {
      ...innerBarStyle.value,
      backgroundSize: props4.vertical === true ? `2px ${size2}%` : `${size2}% 2px`
    };
  });
  function getMarkerList(def2) {
    if (def2 === false) {
      return null;
    }
    if (def2 === true) {
      return markerTicks.value.map(defaultMarkerConvertFn);
    }
    if (typeof def2 === "function") {
      return markerTicks.value.map((value2) => {
        const item = def2(value2);
        return isObject(item) === true ? { ...item, value: value2 } : { value: value2, label: item };
      });
    }
    const filterFn = ({ value: value2 }) => value2 >= props4.min && value2 <= props4.max;
    if (Array.isArray(def2) === true) {
      return def2.map((item) => isObject(item) === true ? item : { value: item }).filter(filterFn);
    }
    return Object.keys(def2).map((key) => {
      const item = def2[key];
      const value2 = Number(key);
      return isObject(item) === true ? { ...item, value: value2 } : { value: value2, label: item };
    }).filter(filterFn);
  }
  function getMarkerLabelStyle(val) {
    return { [positionProp.value]: `${100 * (val - props4.min) / trackLen.value}%` };
  }
  const markerLabelsMap = computed(() => {
    if (props4.markerLabels === false) {
      return null;
    }
    const acc = {};
    markerLabelsList.value.forEach((entry) => {
      acc[entry.value] = entry;
    });
    return acc;
  });
  function getMarkerLabelsContent() {
    if (slots["marker-label-group"] !== void 0) {
      return slots["marker-label-group"](markerScope.value);
    }
    const fn = slots["marker-label"] || defaultMarkerLabelRenderFn;
    return markerLabelsList.value.map((marker) => fn({
      marker,
      ...markerScope.value
    }));
  }
  const panDirective = computed(() => {
    return [[
      TouchPan_default,
      onPan,
      void 0,
      {
        [orientation.value]: true,
        prevent: true,
        stop: true,
        mouse: true,
        mouseAllDir: true
      }
    ]];
  });
  function onPan(event) {
    if (event.isFinal === true) {
      if (dragging.value !== void 0) {
        updatePosition(event.evt);
        event.touch === true && updateValue2(true);
        dragging.value = void 0;
        emit2("pan", "end");
      }
      active.value = false;
      focus.value = false;
    } else if (event.isFirst === true) {
      dragging.value = getDragging(event.evt);
      updatePosition(event.evt);
      updateValue2();
      active.value = true;
      emit2("pan", "start");
    } else {
      updatePosition(event.evt);
      updateValue2();
    }
  }
  function onBlur2() {
    focus.value = false;
  }
  function onActivate(evt) {
    updatePosition(evt, getDragging(evt));
    updateValue2();
    preventFocus.value = true;
    active.value = true;
    document.addEventListener("mouseup", onDeactivate, true);
  }
  function onDeactivate() {
    preventFocus.value = false;
    active.value = false;
    updateValue2(true);
    onBlur2();
    document.removeEventListener("mouseup", onDeactivate, true);
  }
  function onMobileClick(evt) {
    updatePosition(evt, getDragging(evt));
    updateValue2(true);
  }
  function onKeyup2(evt) {
    if (keyCodes.includes(evt.keyCode)) {
      updateValue2(true);
    }
  }
  function getTextContainerStyle(ratio) {
    if (props4.vertical === true) {
      return null;
    }
    const p2 = $q.lang.rtl !== props4.reverse ? 1 - ratio : ratio;
    return {
      transform: `translateX(calc(${2 * p2 - 1} * ${props4.thumbSize} / 2 + ${50 - 100 * p2}%))`
    };
  }
  function getThumbRenderFn(thumb) {
    const focusClass = computed(() => preventFocus.value === false && (focus.value === thumb.focusValue || focus.value === "both") ? " q-slider--focus" : "");
    const classes2 = computed(
      () => `q-slider__thumb q-slider__thumb${axis.value} q-slider__thumb${axis.value}-${isReversed.value === true ? "rtl" : "ltr"} absolute non-selectable` + focusClass.value + (thumb.thumbColor.value !== void 0 ? ` text-${thumb.thumbColor.value}` : "")
    );
    const style2 = computed(() => ({
      width: props4.thumbSize,
      height: props4.thumbSize,
      [positionProp.value]: `${100 * thumb.ratio.value}%`,
      zIndex: focus.value === thumb.focusValue ? 2 : void 0
    }));
    const pinColor = computed(() => thumb.labelColor.value !== void 0 ? ` text-${thumb.labelColor.value}` : "");
    const textContainerStyle = computed(() => getTextContainerStyle(thumb.ratio.value));
    const textClass = computed(() => "q-slider__text" + (thumb.labelTextColor.value !== void 0 ? ` text-${thumb.labelTextColor.value}` : ""));
    return () => {
      const thumbContent = [
        h("svg", {
          class: "q-slider__thumb-shape absolute-full",
          viewBox: "0 0 20 20",
          "aria-hidden": "true"
        }, [
          h("path", { d: props4.thumbPath })
        ]),
        h("div", { class: "q-slider__focus-ring fit" })
      ];
      if (props4.label === true || props4.labelAlways === true) {
        thumbContent.push(
          h("div", {
            class: pinClass.value + " absolute fit no-pointer-events" + pinColor.value
          }, [
            h("div", {
              class: labelClass.value,
              style: { minWidth: props4.thumbSize }
            }, [
              h("div", {
                class: textContainerClass.value,
                style: textContainerStyle.value
              }, [
                h("span", { class: textClass.value }, thumb.label.value)
              ])
            ])
          ])
        );
        if (props4.name !== void 0 && props4.disable !== true) {
          injectFormInput(thumbContent, "push");
        }
      }
      return h("div", {
        class: classes2.value,
        style: style2.value,
        ...thumb.getNodeData()
      }, thumbContent);
    };
  }
  function getContent(selectionBarStyle, trackContainerTabindex, trackContainerEvents, injectThumb) {
    const trackContent = [];
    props4.innerTrackColor !== "transparent" && trackContent.push(
      h("div", {
        key: "inner",
        class: innerBarClass.value,
        style: innerBarStyle.value
      })
    );
    props4.selectionColor !== "transparent" && trackContent.push(
      h("div", {
        key: "selection",
        class: selectionBarClass.value,
        style: selectionBarStyle.value
      })
    );
    props4.markers !== false && trackContent.push(
      h("div", {
        key: "marker",
        class: markerClass.value,
        style: markerStyle.value
      })
    );
    injectThumb(trackContent);
    const content = [
      hDir(
        "div",
        {
          key: "trackC",
          class: trackContainerClass.value,
          tabindex: trackContainerTabindex.value,
          ...trackContainerEvents.value
        },
        [
          h("div", {
            class: trackClass.value,
            style: trackStyle.value
          }, trackContent)
        ],
        "slide",
        editable.value,
        () => panDirective.value
      )
    ];
    if (props4.markerLabels !== false) {
      const action = props4.switchMarkerLabelsSide === true ? "unshift" : "push";
      content[action](
        h("div", {
          key: "markerL",
          class: markerLabelsContainerClass.value
        }, getMarkerLabelsContent())
      );
    }
    return content;
  }
  onBeforeUnmount(() => {
    document.removeEventListener("mouseup", onDeactivate, true);
  });
  return {
    state: {
      active,
      focus,
      preventFocus,
      dragging,
      editable,
      classes,
      tabindex,
      attributes,
      roundValueFn,
      keyStep,
      trackLen,
      innerMin,
      innerMinRatio,
      innerMax,
      innerMaxRatio,
      positionProp,
      sizeProp,
      isReversed
    },
    methods: {
      onActivate,
      onMobileClick,
      onBlur: onBlur2,
      onKeyup: onKeyup2,
      getContent,
      getThumbRenderFn,
      convertRatioToModel,
      convertModelToRatio,
      getDraggingRatio
    }
  };
}
var getNodeData = () => ({});
var QSlider_default = createComponent({
  name: "QSlider",
  props: {
    ...useSliderProps,
    modelValue: {
      required: true,
      default: null,
      validator: (v2) => typeof v2 === "number" || v2 === null
    },
    labelValue: [String, Number]
  },
  emits: useSliderEmits,
  setup(props4, { emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const { state, methods } = use_slider_default({
      updateValue: updateValue2,
      updatePosition,
      getDragging,
      formAttrs: useFormAttrs(props4)
    });
    const rootRef = ref(null);
    const curRatio = ref(0);
    const model = ref(0);
    function normalizeModel() {
      model.value = props4.modelValue === null ? state.innerMin.value : between(props4.modelValue, state.innerMin.value, state.innerMax.value);
    }
    watch(
      () => `${props4.modelValue}|${state.innerMin.value}|${state.innerMax.value}`,
      normalizeModel
    );
    normalizeModel();
    const modelRatio = computed(() => methods.convertModelToRatio(model.value));
    const ratio = computed(() => state.active.value === true ? curRatio.value : modelRatio.value);
    const selectionBarStyle = computed(() => {
      const acc = {
        [state.positionProp.value]: `${100 * state.innerMinRatio.value}%`,
        [state.sizeProp.value]: `${100 * (ratio.value - state.innerMinRatio.value)}%`
      };
      if (props4.selectionImg !== void 0) {
        acc.backgroundImage = `url(${props4.selectionImg}) !important`;
      }
      return acc;
    });
    const getThumb = methods.getThumbRenderFn({
      focusValue: true,
      getNodeData,
      ratio,
      label: computed(() => props4.labelValue !== void 0 ? props4.labelValue : model.value),
      thumbColor: computed(() => props4.thumbColor || props4.color),
      labelColor: computed(() => props4.labelColor),
      labelTextColor: computed(() => props4.labelTextColor)
    });
    const trackContainerEvents = computed(() => {
      if (state.editable.value !== true) {
        return {};
      }
      return $q.platform.is.mobile === true ? { onClick: methods.onMobileClick } : {
        onMousedown: methods.onActivate,
        onFocus,
        onBlur: methods.onBlur,
        onKeydown: onKeydown2,
        onKeyup: methods.onKeyup
      };
    });
    function updateValue2(change) {
      if (model.value !== props4.modelValue) {
        emit2("update:modelValue", model.value);
      }
      change === true && emit2("change", model.value);
    }
    function getDragging() {
      return rootRef.value.getBoundingClientRect();
    }
    function updatePosition(event, dragging = state.dragging.value) {
      const ratio2 = methods.getDraggingRatio(event, dragging);
      model.value = methods.convertRatioToModel(ratio2);
      curRatio.value = props4.snap !== true || props4.step === 0 ? ratio2 : methods.convertModelToRatio(model.value);
    }
    function onFocus() {
      state.focus.value = true;
    }
    function onKeydown2(evt) {
      if (!keyCodes.includes(evt.keyCode)) {
        return;
      }
      stopAndPrevent(evt);
      const stepVal = ([34, 33].includes(evt.keyCode) ? 10 : 1) * state.keyStep.value, offset2 = ([34, 37, 40].includes(evt.keyCode) ? -1 : 1) * (state.isReversed.value === true ? -1 : 1) * (props4.vertical === true ? -1 : 1) * stepVal;
      model.value = between(
        state.roundValueFn.value(model.value + offset2),
        state.innerMin.value,
        state.innerMax.value
      );
      updateValue2();
    }
    return () => {
      const content = methods.getContent(
        selectionBarStyle,
        state.tabindex,
        trackContainerEvents,
        (node) => {
          node.push(getThumb());
        }
      );
      return h("div", {
        ref: rootRef,
        class: state.classes.value + (props4.modelValue === null ? " q-slider--no-value" : ""),
        ...state.attributes.value,
        "aria-valuenow": props4.modelValue
      }, content);
    };
  }
});
function use_hydration_default() {
  const isHydrated = ref(!isRuntimeSsrPreHydration.value);
  if (isHydrated.value === false) {
    onMounted(() => {
      isHydrated.value = true;
    });
  }
  return { isHydrated };
}
var hasObserver = typeof ResizeObserver !== "undefined";
var resizeProps = hasObserver === true ? {} : {
  style: "display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;",
  url: "about:blank"
};
var QResizeObserver_default = createComponent({
  name: "QResizeObserver",
  props: {
    debounce: {
      type: [String, Number],
      default: 100
    }
  },
  emits: ["resize"],
  setup(props4, { emit: emit2 }) {
    let timer2 = null, targetEl, size2 = { width: -1, height: -1 };
    function trigger3(immediately) {
      if (immediately === true || props4.debounce === 0 || props4.debounce === "0") {
        emitEvent();
      } else if (timer2 === null) {
        timer2 = setTimeout(emitEvent, props4.debounce);
      }
    }
    function emitEvent() {
      if (timer2 !== null) {
        clearTimeout(timer2);
        timer2 = null;
      }
      if (targetEl) {
        const { offsetWidth: width3, offsetHeight: height2 } = targetEl;
        if (width3 !== size2.width || height2 !== size2.height) {
          size2 = { width: width3, height: height2 };
          emit2("resize", size2);
        }
      }
    }
    const { proxy } = getCurrentInstance();
    proxy.trigger = trigger3;
    if (hasObserver === true) {
      let observer;
      const init2 = (stop2) => {
        targetEl = proxy.$el.parentNode;
        if (targetEl) {
          observer = new ResizeObserver(trigger3);
          observer.observe(targetEl);
          emitEvent();
        } else if (stop2 !== true) {
          nextTick(() => {
            init2(true);
          });
        }
      };
      onMounted(() => {
        init2();
      });
      onBeforeUnmount(() => {
        timer2 !== null && clearTimeout(timer2);
        if (observer !== void 0) {
          if (observer.disconnect !== void 0) {
            observer.disconnect();
          } else if (targetEl) {
            observer.unobserve(targetEl);
          }
        }
      });
      return noop;
    } else {
      let cleanup = function() {
        if (timer2 !== null) {
          clearTimeout(timer2);
          timer2 = null;
        }
        if (curDocView !== void 0) {
          if (curDocView.removeEventListener !== void 0) {
            curDocView.removeEventListener("resize", trigger3, listenOpts.passive);
          }
          curDocView = void 0;
        }
      }, onObjLoad = function() {
        cleanup();
        if (targetEl && targetEl.contentDocument) {
          curDocView = targetEl.contentDocument.defaultView;
          curDocView.addEventListener("resize", trigger3, listenOpts.passive);
          emitEvent();
        }
      };
      const { isHydrated } = use_hydration_default();
      let curDocView;
      onMounted(() => {
        nextTick(() => {
          targetEl = proxy.$el;
          targetEl && onObjLoad();
        });
      });
      onBeforeUnmount(cleanup);
      return () => {
        if (isHydrated.value === true) {
          return h("object", {
            class: "q--avoid-card-border",
            style: resizeProps.style,
            tabindex: -1,
            // fix for Firefox
            type: "text/html",
            data: resizeProps.url,
            "aria-hidden": "true",
            onLoad: onObjLoad
          });
        }
      };
    }
  }
});
var rtlHasScrollBug = false;
{
  const scroller = document.createElement("div");
  scroller.setAttribute("dir", "rtl");
  Object.assign(scroller.style, {
    width: "1px",
    height: "1px",
    overflow: "auto"
  });
  const spacer = document.createElement("div");
  Object.assign(spacer.style, {
    width: "1000px",
    height: "1px"
  });
  document.body.appendChild(scroller);
  scroller.appendChild(spacer);
  scroller.scrollLeft = -1e3;
  rtlHasScrollBug = scroller.scrollLeft >= 0;
  scroller.remove();
}
function getIndicatorClass(color, top, vertical) {
  const pos = vertical === true ? ["left", "right"] : ["top", "bottom"];
  return `absolute-${top === true ? pos[0] : pos[1]}${color ? ` text-${color}` : ""}`;
}
var alignValues3 = ["left", "center", "right", "justify"];
var QTabs_default = createComponent({
  name: "QTabs",
  props: {
    modelValue: [Number, String],
    align: {
      type: String,
      default: "center",
      validator: (v2) => alignValues3.includes(v2)
    },
    breakpoint: {
      type: [String, Number],
      default: 600
    },
    vertical: Boolean,
    shrink: Boolean,
    stretch: Boolean,
    activeClass: String,
    activeColor: String,
    activeBgColor: String,
    indicatorColor: String,
    leftIcon: String,
    rightIcon: String,
    outsideArrows: Boolean,
    mobileArrows: Boolean,
    switchIndicator: Boolean,
    narrowIndicator: Boolean,
    inlineLabel: Boolean,
    noCaps: Boolean,
    dense: Boolean,
    contentClass: String,
    "onUpdate:modelValue": [Function, Array]
  },
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const { registerTick: registerScrollTick } = use_tick_default();
    const { registerTick: registerUpdateArrowsTick } = use_tick_default();
    const { registerTick: registerAnimateTick } = use_tick_default();
    const { registerTimeout: registerFocusTimeout, removeTimeout: removeFocusTimeout } = use_timeout_default();
    const { registerTimeout: registerScrollToTabTimeout, removeTimeout: removeScrollToTabTimeout } = use_timeout_default();
    const rootRef = ref(null);
    const contentRef = ref(null);
    const currentModel = ref(props4.modelValue);
    const scrollable = ref(false);
    const leftArrow = ref(true);
    const rightArrow = ref(false);
    const justify = ref(false);
    const tabDataList = [];
    const tabDataListLen = ref(0);
    const hasFocus = ref(false);
    let animateTimer = null, scrollTimer = null, unwatchRoute;
    const tabProps = computed(() => ({
      activeClass: props4.activeClass,
      activeColor: props4.activeColor,
      activeBgColor: props4.activeBgColor,
      indicatorClass: getIndicatorClass(
        props4.indicatorColor,
        props4.switchIndicator,
        props4.vertical
      ),
      narrowIndicator: props4.narrowIndicator,
      inlineLabel: props4.inlineLabel,
      noCaps: props4.noCaps
    }));
    const hasActiveTab = computed(() => {
      const len = tabDataListLen.value;
      const val = currentModel.value;
      for (let i = 0; i < len; i++) {
        if (tabDataList[i].name.value === val) {
          return true;
        }
      }
      return false;
    });
    const alignClass = computed(() => {
      const align = scrollable.value === true ? "left" : justify.value === true ? "justify" : props4.align;
      return `q-tabs__content--align-${align}`;
    });
    const classes = computed(
      () => `q-tabs row no-wrap items-center q-tabs--${scrollable.value === true ? "" : "not-"}scrollable q-tabs--${props4.vertical === true ? "vertical" : "horizontal"} q-tabs__arrows--${props4.outsideArrows === true ? "outside" : "inside"} q-tabs--mobile-with${props4.mobileArrows === true ? "" : "out"}-arrows` + (props4.dense === true ? " q-tabs--dense" : "") + (props4.shrink === true ? " col-shrink" : "") + (props4.stretch === true ? " self-stretch" : "")
    );
    const innerClass = computed(
      () => "q-tabs__content scroll--mobile row no-wrap items-center self-stretch hide-scrollbar relative-position " + alignClass.value + (props4.contentClass !== void 0 ? ` ${props4.contentClass}` : "")
    );
    const domProps = computed(() => props4.vertical === true ? { container: "height", content: "offsetHeight", scroll: "scrollHeight" } : { container: "width", content: "offsetWidth", scroll: "scrollWidth" });
    const isRTL = computed(() => props4.vertical !== true && $q.lang.rtl === true);
    const rtlPosCorrection = computed(() => rtlHasScrollBug === false && isRTL.value === true);
    watch(isRTL, updateArrows);
    watch(() => props4.modelValue, (name2) => {
      updateModel2({ name: name2, setCurrent: true, skipEmit: true });
    });
    watch(() => props4.outsideArrows, recalculateScroll);
    function updateModel2({ name: name2, setCurrent, skipEmit }) {
      if (currentModel.value === name2) return;
      if (skipEmit !== true && props4["onUpdate:modelValue"] !== void 0) {
        emit2("update:modelValue", name2);
      }
      if (setCurrent === true || props4["onUpdate:modelValue"] === void 0) {
        animate(currentModel.value, name2);
        currentModel.value = name2;
      }
    }
    function recalculateScroll() {
      registerScrollTick(() => {
        updateContainer({
          width: rootRef.value.offsetWidth,
          height: rootRef.value.offsetHeight
        });
      });
    }
    function updateContainer(domSize) {
      if (domProps.value === void 0 || contentRef.value === null) return;
      const size2 = domSize[domProps.value.container], scrollSize = Math.min(
        contentRef.value[domProps.value.scroll],
        Array.prototype.reduce.call(
          contentRef.value.children,
          (acc, el) => acc + (el[domProps.value.content] || 0),
          0
        )
      ), scroll = size2 > 0 && scrollSize > size2;
      scrollable.value = scroll;
      scroll === true && registerUpdateArrowsTick(updateArrows);
      justify.value = size2 < parseInt(props4.breakpoint, 10);
    }
    function animate(oldName, newName) {
      const oldTab = oldName !== void 0 && oldName !== null && oldName !== "" ? tabDataList.find((tab) => tab.name.value === oldName) : null, newTab = newName !== void 0 && newName !== null && newName !== "" ? tabDataList.find((tab) => tab.name.value === newName) : null;
      if (hadActivated === true) {
        hadActivated = false;
      } else if (oldTab && newTab) {
        const oldEl = oldTab.tabIndicatorRef.value, newEl = newTab.tabIndicatorRef.value;
        if (animateTimer !== null) {
          clearTimeout(animateTimer);
          animateTimer = null;
        }
        oldEl.style.transition = "none";
        oldEl.style.transform = "none";
        newEl.style.transition = "none";
        newEl.style.transform = "none";
        const oldPos = oldEl.getBoundingClientRect(), newPos = newEl.getBoundingClientRect();
        newEl.style.transform = props4.vertical === true ? `translate3d(0,${oldPos.top - newPos.top}px,0) scale3d(1,${newPos.height ? oldPos.height / newPos.height : 1},1)` : `translate3d(${oldPos.left - newPos.left}px,0,0) scale3d(${newPos.width ? oldPos.width / newPos.width : 1},1,1)`;
        registerAnimateTick(() => {
          animateTimer = setTimeout(() => {
            animateTimer = null;
            newEl.style.transition = "transform .25s cubic-bezier(.4, 0, .2, 1)";
            newEl.style.transform = "none";
          }, 70);
        });
      }
      if (newTab && scrollable.value === true) {
        scrollToTabEl(newTab.rootRef.value);
      }
    }
    function scrollToTabEl(el) {
      const { left, width: width3, top, height: height2 } = contentRef.value.getBoundingClientRect(), newPos = el.getBoundingClientRect();
      let offset2 = props4.vertical === true ? newPos.top - top : newPos.left - left;
      if (offset2 < 0) {
        contentRef.value[props4.vertical === true ? "scrollTop" : "scrollLeft"] += Math.floor(offset2);
        updateArrows();
        return;
      }
      offset2 += props4.vertical === true ? newPos.height - height2 : newPos.width - width3;
      if (offset2 > 0) {
        contentRef.value[props4.vertical === true ? "scrollTop" : "scrollLeft"] += Math.ceil(offset2);
        updateArrows();
      }
    }
    function updateArrows() {
      const content = contentRef.value;
      if (content === null) return;
      const rect = content.getBoundingClientRect(), pos = props4.vertical === true ? content.scrollTop : Math.abs(content.scrollLeft);
      if (isRTL.value === true) {
        leftArrow.value = Math.ceil(pos + rect.width) < content.scrollWidth - 1;
        rightArrow.value = pos > 0;
      } else {
        leftArrow.value = pos > 0;
        rightArrow.value = props4.vertical === true ? Math.ceil(pos + rect.height) < content.scrollHeight : Math.ceil(pos + rect.width) < content.scrollWidth;
      }
    }
    function animScrollTo(value2) {
      scrollTimer !== null && clearInterval(scrollTimer);
      scrollTimer = setInterval(() => {
        if (scrollTowards(value2) === true) {
          stopAnimScroll();
        }
      }, 5);
    }
    function scrollToStart() {
      animScrollTo(rtlPosCorrection.value === true ? Number.MAX_SAFE_INTEGER : 0);
    }
    function scrollToEnd() {
      animScrollTo(rtlPosCorrection.value === true ? 0 : Number.MAX_SAFE_INTEGER);
    }
    function stopAnimScroll() {
      if (scrollTimer !== null) {
        clearInterval(scrollTimer);
        scrollTimer = null;
      }
    }
    function onKbdNavigate(keyCode, fromEl) {
      const tabs = Array.prototype.filter.call(
        contentRef.value.children,
        (el) => el === fromEl || el.matches && el.matches(".q-tab.q-focusable") === true
      );
      const len = tabs.length;
      if (len === 0) return;
      if (keyCode === 36) {
        scrollToTabEl(tabs[0]);
        tabs[0].focus();
        return true;
      }
      if (keyCode === 35) {
        scrollToTabEl(tabs[len - 1]);
        tabs[len - 1].focus();
        return true;
      }
      const dirPrev = keyCode === (props4.vertical === true ? 38 : 37);
      const dirNext = keyCode === (props4.vertical === true ? 40 : 39);
      const dir = dirPrev === true ? -1 : dirNext === true ? 1 : void 0;
      if (dir !== void 0) {
        const rtlDir = isRTL.value === true ? -1 : 1;
        const index = tabs.indexOf(fromEl) + dir * rtlDir;
        if (index >= 0 && index < len) {
          scrollToTabEl(tabs[index]);
          tabs[index].focus({ preventScroll: true });
        }
        return true;
      }
    }
    const posFn = computed(() => rtlPosCorrection.value === true ? { get: (content) => Math.abs(content.scrollLeft), set: (content, pos) => {
      content.scrollLeft = -pos;
    } } : props4.vertical === true ? { get: (content) => content.scrollTop, set: (content, pos) => {
      content.scrollTop = pos;
    } } : { get: (content) => content.scrollLeft, set: (content, pos) => {
      content.scrollLeft = pos;
    } });
    function scrollTowards(value2) {
      const content = contentRef.value, { get: get2, set: set2 } = posFn.value;
      let done = false, pos = get2(content);
      const direction = value2 < pos ? -1 : 1;
      pos += direction * 5;
      if (pos < 0) {
        done = true;
        pos = 0;
      } else if (direction === -1 && pos <= value2 || direction === 1 && pos >= value2) {
        done = true;
        pos = value2;
      }
      set2(content, pos);
      updateArrows();
      return done;
    }
    function hasQueryIncluded(targetQuery, matchingQuery) {
      for (const key in targetQuery) {
        if (targetQuery[key] !== matchingQuery[key]) {
          return false;
        }
      }
      return true;
    }
    function updateActiveRoute() {
      let name2 = null, bestScore = { matchedLen: 0, queryDiff: 9999, hrefLen: 0 };
      const list = tabDataList.filter((tab) => tab.routeData !== void 0 && tab.routeData.hasRouterLink.value === true);
      const { hash: currentHash, query: currentQuery } = proxy.$route;
      const currentQueryLen = Object.keys(currentQuery).length;
      for (const tab of list) {
        const exact = tab.routeData.exact.value === true;
        if (tab.routeData[exact === true ? "linkIsExactActive" : "linkIsActive"].value !== true) {
          continue;
        }
        const { hash, query, matched, href: href2 } = tab.routeData.resolvedLink.value;
        const queryLen = Object.keys(query).length;
        if (exact === true) {
          if (hash !== currentHash) {
            continue;
          }
          if (queryLen !== currentQueryLen || hasQueryIncluded(currentQuery, query) === false) {
            continue;
          }
          name2 = tab.name.value;
          break;
        }
        if (hash !== "" && hash !== currentHash) {
          continue;
        }
        if (queryLen !== 0 && hasQueryIncluded(query, currentQuery) === false) {
          continue;
        }
        const newScore = {
          matchedLen: matched.length,
          queryDiff: currentQueryLen - queryLen,
          hrefLen: href2.length - hash.length
        };
        if (newScore.matchedLen > bestScore.matchedLen) {
          name2 = tab.name.value;
          bestScore = newScore;
          continue;
        } else if (newScore.matchedLen !== bestScore.matchedLen) {
          continue;
        }
        if (newScore.queryDiff < bestScore.queryDiff) {
          name2 = tab.name.value;
          bestScore = newScore;
        } else if (newScore.queryDiff !== bestScore.queryDiff) {
          continue;
        }
        if (newScore.hrefLen > bestScore.hrefLen) {
          name2 = tab.name.value;
          bestScore = newScore;
        }
      }
      if (name2 === null && tabDataList.some((tab) => tab.routeData === void 0 && tab.name.value === currentModel.value) === true) {
        hadActivated = false;
        return;
      }
      updateModel2({ name: name2, setCurrent: true });
    }
    function onFocusin(e) {
      removeFocusTimeout();
      if (hasFocus.value !== true && rootRef.value !== null && e.target && typeof e.target.closest === "function") {
        const tab = e.target.closest(".q-tab");
        if (tab && rootRef.value.contains(tab) === true) {
          hasFocus.value = true;
          scrollable.value === true && scrollToTabEl(tab);
        }
      }
    }
    function onFocusout() {
      registerFocusTimeout(() => {
        hasFocus.value = false;
      }, 30);
    }
    function verifyRouteModel() {
      if ($tabs.avoidRouteWatcher === false) {
        registerScrollToTabTimeout(updateActiveRoute);
      } else {
        removeScrollToTabTimeout();
      }
    }
    function watchRoute() {
      if (unwatchRoute === void 0) {
        const unwatch = watch(() => proxy.$route.fullPath, verifyRouteModel);
        unwatchRoute = () => {
          unwatch();
          unwatchRoute = void 0;
        };
      }
    }
    function registerTab(tabData) {
      tabDataList.push(tabData);
      tabDataListLen.value++;
      recalculateScroll();
      if (tabData.routeData === void 0 || proxy.$route === void 0) {
        registerScrollToTabTimeout(() => {
          if (scrollable.value === true) {
            const value2 = currentModel.value;
            const newTab = value2 !== void 0 && value2 !== null && value2 !== "" ? tabDataList.find((tab) => tab.name.value === value2) : null;
            newTab && scrollToTabEl(newTab.rootRef.value);
          }
        });
      } else {
        watchRoute();
        if (tabData.routeData.hasRouterLink.value === true) {
          verifyRouteModel();
        }
      }
    }
    function unregisterTab(tabData) {
      tabDataList.splice(tabDataList.indexOf(tabData), 1);
      tabDataListLen.value--;
      recalculateScroll();
      if (unwatchRoute !== void 0 && tabData.routeData !== void 0) {
        if (tabDataList.every((tab) => tab.routeData === void 0) === true) {
          unwatchRoute();
        }
        verifyRouteModel();
      }
    }
    const $tabs = {
      currentModel,
      tabProps,
      hasFocus,
      hasActiveTab,
      registerTab,
      unregisterTab,
      verifyRouteModel,
      updateModel: updateModel2,
      onKbdNavigate,
      avoidRouteWatcher: false
      // false | string (uid)
    };
    provide(tabsKey, $tabs);
    function cleanup() {
      animateTimer !== null && clearTimeout(animateTimer);
      stopAnimScroll();
      unwatchRoute !== void 0 && unwatchRoute();
    }
    let hadRouteWatcher, hadActivated;
    onBeforeUnmount(cleanup);
    onDeactivated(() => {
      hadRouteWatcher = unwatchRoute !== void 0;
      cleanup();
    });
    onActivated(() => {
      if (hadRouteWatcher === true) {
        watchRoute();
        hadActivated = true;
        verifyRouteModel();
      }
      recalculateScroll();
    });
    return () => {
      return h("div", {
        ref: rootRef,
        class: classes.value,
        role: "tablist",
        onFocusin,
        onFocusout
      }, [
        h(QResizeObserver_default, { onResize: updateContainer }),
        h("div", {
          ref: contentRef,
          class: innerClass.value,
          onScroll: updateArrows
        }, hSlot(slots.default)),
        h(QIcon_default, {
          class: "q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon" + (leftArrow.value === true ? "" : " q-tabs__arrow--faded"),
          name: props4.leftIcon || $q.iconSet.tabs[props4.vertical === true ? "up" : "left"],
          onMousedownPassive: scrollToStart,
          onTouchstartPassive: scrollToStart,
          onMouseupPassive: stopAnimScroll,
          onMouseleavePassive: stopAnimScroll,
          onTouchendPassive: stopAnimScroll
        }),
        h(QIcon_default, {
          class: "q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon" + (rightArrow.value === true ? "" : " q-tabs__arrow--faded"),
          name: props4.rightIcon || $q.iconSet.tabs[props4.vertical === true ? "down" : "right"],
          onMousedownPassive: scrollToEnd,
          onTouchstartPassive: scrollToEnd,
          onMouseupPassive: stopAnimScroll,
          onMouseleavePassive: stopAnimScroll,
          onTouchendPassive: stopAnimScroll
        })
      ]);
    };
  }
});
var id = 0;
var useTabEmits = ["click", "keydown"];
var useTabProps = {
  icon: String,
  label: [Number, String],
  alert: [Boolean, String],
  alertIcon: String,
  name: {
    type: [Number, String],
    default: () => `t_${id++}`
  },
  noCaps: Boolean,
  tabindex: [String, Number],
  disable: Boolean,
  contentClass: String,
  ripple: {
    type: [Boolean, Object],
    default: true
  }
};
function use_tab_default(props4, slots, emit2, routeData) {
  const $tabs = inject(tabsKey, emptyRenderFn);
  if ($tabs === emptyRenderFn) {
    console.error("QTab/QRouteTab component needs to be child of QTabs");
    return emptyRenderFn;
  }
  const { proxy } = getCurrentInstance();
  const blurTargetRef = ref(null);
  const rootRef = ref(null);
  const tabIndicatorRef = ref(null);
  const ripple = computed(() => props4.disable === true || props4.ripple === false ? false : Object.assign(
    { keyCodes: [13, 32], early: true },
    props4.ripple === true ? {} : props4.ripple
  ));
  const isActive = computed(() => $tabs.currentModel.value === props4.name);
  const classes = computed(
    () => "q-tab relative-position self-stretch flex flex-center text-center" + (isActive.value === true ? " q-tab--active" + ($tabs.tabProps.value.activeClass ? " " + $tabs.tabProps.value.activeClass : "") + ($tabs.tabProps.value.activeColor ? ` text-${$tabs.tabProps.value.activeColor}` : "") + ($tabs.tabProps.value.activeBgColor ? ` bg-${$tabs.tabProps.value.activeBgColor}` : "") : " q-tab--inactive") + (props4.icon && props4.label && $tabs.tabProps.value.inlineLabel === false ? " q-tab--full" : "") + (props4.noCaps === true || $tabs.tabProps.value.noCaps === true ? " q-tab--no-caps" : "") + (props4.disable === true ? " disabled" : " q-focusable q-hoverable cursor-pointer") + (routeData !== void 0 ? routeData.linkClass.value : "")
  );
  const innerClass = computed(
    () => "q-tab__content self-stretch flex-center relative-position q-anchor--skip non-selectable " + ($tabs.tabProps.value.inlineLabel === true ? "row no-wrap q-tab__content--inline" : "column") + (props4.contentClass !== void 0 ? ` ${props4.contentClass}` : "")
  );
  const tabIndex = computed(() => props4.disable === true || $tabs.hasFocus.value === true || isActive.value === false && $tabs.hasActiveTab.value === true ? -1 : props4.tabindex || 0);
  function onClick(e, keyboard) {
    if (keyboard !== true && blurTargetRef.value !== null) {
      blurTargetRef.value.focus();
    }
    if (props4.disable === true) {
      if (routeData !== void 0 && routeData.hasRouterLink.value === true) {
        stopAndPrevent(e);
      }
      return;
    }
    if (routeData === void 0) {
      $tabs.updateModel({ name: props4.name });
      emit2("click", e);
      return;
    }
    if (routeData.hasRouterLink.value === true) {
      const go = (opts = {}) => {
        let hardError;
        const reqId = opts.to === void 0 || isDeepEqual(opts.to, props4.to) === true ? $tabs.avoidRouteWatcher = uid_default() : null;
        return routeData.navigateToRouterLink(e, { ...opts, returnRouterError: true }).catch((err) => {
          hardError = err;
        }).then((softError) => {
          if (reqId === $tabs.avoidRouteWatcher) {
            $tabs.avoidRouteWatcher = false;
            if (hardError === void 0 && (softError === void 0 || softError.message !== void 0 && softError.message.startsWith("Avoided redundant navigation") === true)) {
              $tabs.updateModel({ name: props4.name });
            }
          }
          if (opts.returnRouterError === true) {
            return hardError !== void 0 ? Promise.reject(hardError) : softError;
          }
        });
      };
      emit2("click", e, go);
      e.defaultPrevented !== true && go();
      return;
    }
    emit2("click", e);
  }
  function onKeydown2(e) {
    if (isKeyCode(e, [13, 32])) {
      onClick(e, true);
    } else if (shouldIgnoreKey(e) !== true && e.keyCode >= 35 && e.keyCode <= 40 && e.altKey !== true && e.metaKey !== true) {
      $tabs.onKbdNavigate(e.keyCode, proxy.$el) === true && stopAndPrevent(e);
    }
    emit2("keydown", e);
  }
  function getContent() {
    const narrow = $tabs.tabProps.value.narrowIndicator, content = [], indicator = h("div", {
      ref: tabIndicatorRef,
      class: [
        "q-tab__indicator",
        $tabs.tabProps.value.indicatorClass
      ]
    });
    props4.icon !== void 0 && content.push(
      h(QIcon_default, {
        class: "q-tab__icon",
        name: props4.icon
      })
    );
    props4.label !== void 0 && content.push(
      h("div", { class: "q-tab__label" }, props4.label)
    );
    props4.alert !== false && content.push(
      props4.alertIcon !== void 0 ? h(QIcon_default, {
        class: "q-tab__alert-icon",
        color: props4.alert !== true ? props4.alert : void 0,
        name: props4.alertIcon
      }) : h("div", {
        class: "q-tab__alert" + (props4.alert !== true ? ` text-${props4.alert}` : "")
      })
    );
    narrow === true && content.push(indicator);
    const node = [
      h("div", { class: "q-focus-helper", tabindex: -1, ref: blurTargetRef }),
      h("div", { class: innerClass.value }, hMergeSlot(slots.default, content))
    ];
    narrow === false && node.push(indicator);
    return node;
  }
  const tabData = {
    name: computed(() => props4.name),
    rootRef,
    tabIndicatorRef,
    routeData
  };
  onBeforeUnmount(() => {
    $tabs.unregisterTab(tabData);
  });
  onMounted(() => {
    $tabs.registerTab(tabData);
  });
  function renderTab(tag, customData) {
    const data = {
      ref: rootRef,
      class: classes.value,
      tabindex: tabIndex.value,
      role: "tab",
      "aria-selected": isActive.value === true ? "true" : "false",
      "aria-disabled": props4.disable === true ? "true" : void 0,
      onClick,
      onKeydown: onKeydown2,
      ...customData
    };
    return withDirectives(
      h(tag, data, getContent()),
      [[Ripple_default, ripple.value]]
    );
  }
  return { renderTab, $tabs };
}
var QTab_default = createComponent({
  name: "QTab",
  props: useTabProps,
  emits: useTabEmits,
  setup(props4, { slots, emit: emit2 }) {
    const { renderTab } = use_tab_default(props4, slots, emit2);
    return () => renderTab("div");
  }
});
var QTabPanels_default = createComponent({
  name: "QTabPanels",
  props: {
    ...usePanelProps,
    ...useDarkProps
  },
  emits: usePanelEmits,
  setup(props4, { slots }) {
    const vm2 = getCurrentInstance();
    const isDark = use_dark_default(props4, vm2.proxy.$q);
    const { updatePanelsList, getPanelContent, panelDirectives } = use_panel_default();
    const classes = computed(
      () => "q-tab-panels q-panel-parent" + (isDark.value === true ? " q-tab-panels--dark q-dark" : "")
    );
    return () => {
      updatePanelsList(slots);
      return hDir(
        "div",
        { class: classes.value },
        getPanelContent(),
        "pan",
        props4.swipeable,
        () => panelDirectives.value
      );
    };
  }
});
var QTabPanel_default = createComponent({
  name: "QTabPanel",
  props: usePanelChildProps,
  setup(_, { slots }) {
    return () => h("div", { class: "q-tab-panel", role: "tabpanel" }, hSlot(slots.default));
  }
});
var hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/;
var hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/;
var hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/;
var rgb = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/;
var rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/;
var testPattern = {
  date: (v2) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v2),
  time: (v2) => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(v2),
  fulltime: (v2) => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(v2),
  timeOrFulltime: (v2) => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(v2),
  // -- RFC 5322 --
  // -- Added in v2.6.6 --
  // This is a basic helper validation.
  // For something more complex (like RFC 822) you should write and use your own rule.
  // We won't be accepting PRs to enhance the one below because of the reason above.
  // eslint-disable-next-line
  email: (v2) => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v2),
  hexColor: (v2) => hex.test(v2),
  hexaColor: (v2) => hexa.test(v2),
  hexOrHexaColor: (v2) => hexOrHexa.test(v2),
  rgbColor: (v2) => rgb.test(v2),
  rgbaColor: (v2) => rgba.test(v2),
  rgbOrRgbaColor: (v2) => rgb.test(v2) || rgba.test(v2),
  hexOrRgbColor: (v2) => hex.test(v2) || rgb.test(v2),
  hexaOrRgbaColor: (v2) => hexa.test(v2) || rgba.test(v2),
  anyColor: (v2) => hexOrHexa.test(v2) || rgb.test(v2) || rgba.test(v2)
};
var reRGBA = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;
function rgbToHex({ r, g, b, a }) {
  const alpha = a !== void 0;
  r = Math.round(r);
  g = Math.round(g);
  b = Math.round(b);
  if (r > 255 || g > 255 || b > 255 || alpha && a > 100) {
    throw new TypeError("Expected 3 numbers below 256 (and optionally one below 100)");
  }
  a = alpha ? (Math.round(255 * a / 100) | 1 << 8).toString(16).slice(1) : "";
  return "#" + (b | g << 8 | r << 16 | 1 << 24).toString(16).slice(1) + a;
}
function rgbToString({ r, g, b, a }) {
  return `rgb${a !== void 0 ? "a" : ""}(${r},${g},${b}${a !== void 0 ? "," + a / 100 : ""})`;
}
function hexToRgb(hex2) {
  if (typeof hex2 !== "string") {
    throw new TypeError("Expected a string");
  }
  hex2 = hex2.replace(/^#/, "");
  if (hex2.length === 3) {
    hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2];
  } else if (hex2.length === 4) {
    hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2] + hex2[3] + hex2[3];
  }
  const num = parseInt(hex2, 16);
  return hex2.length > 6 ? { r: num >> 24 & 255, g: num >> 16 & 255, b: num >> 8 & 255, a: Math.round((num & 255) / 2.55) } : { r: num >> 16, g: num >> 8 & 255, b: num & 255 };
}
function hsvToRgb({ h: h138, s, v: v2, a }) {
  let r, g, b;
  s = s / 100;
  v2 = v2 / 100;
  h138 = h138 / 360;
  const i = Math.floor(h138 * 6), f = h138 * 6 - i, p2 = v2 * (1 - s), q = v2 * (1 - f * s), t = v2 * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      r = v2;
      g = t;
      b = p2;
      break;
    case 1:
      r = q;
      g = v2;
      b = p2;
      break;
    case 2:
      r = p2;
      g = v2;
      b = t;
      break;
    case 3:
      r = p2;
      g = q;
      b = v2;
      break;
    case 4:
      r = t;
      g = p2;
      b = v2;
      break;
    case 5:
      r = v2;
      g = p2;
      b = q;
      break;
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
    a
  };
}
function rgbToHsv({ r, g, b, a }) {
  const max = Math.max(r, g, b), min = Math.min(r, g, b), d = max - min, s = max === 0 ? 0 : d / max, v2 = max / 255;
  let h138;
  switch (max) {
    case min:
      h138 = 0;
      break;
    case r:
      h138 = g - b + d * (g < b ? 6 : 0);
      h138 /= 6 * d;
      break;
    case g:
      h138 = b - r + d * 2;
      h138 /= 6 * d;
      break;
    case b:
      h138 = r - g + d * 4;
      h138 /= 6 * d;
      break;
  }
  return {
    h: Math.round(h138 * 360),
    s: Math.round(s * 100),
    v: Math.round(v2 * 100),
    a
  };
}
function textToRgb(str) {
  if (typeof str !== "string") {
    throw new TypeError("Expected a string");
  }
  const color = str.replace(/ /g, "");
  const m2 = reRGBA.exec(color);
  if (m2 === null) {
    return hexToRgb(color);
  }
  const rgb2 = {
    r: Math.min(255, parseInt(m2[2], 10)),
    g: Math.min(255, parseInt(m2[3], 10)),
    b: Math.min(255, parseInt(m2[4], 10))
  };
  if (m2[1]) {
    const alpha = parseFloat(m2[5]);
    rgb2.a = Math.min(1, isNaN(alpha) === true ? 1 : alpha) * 100;
  }
  return rgb2;
}
function luminosity(color) {
  if (typeof color !== "string" && (!color || color.r === void 0)) {
    throw new TypeError("Expected a string or a {r, g, b} object as color");
  }
  const rgb2 = typeof color === "string" ? textToRgb(color) : color, r = rgb2.r / 255, g = rgb2.g / 255, b = rgb2.b / 255, R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4), G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4), B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
  return 0.2126 * R + 0.7152 * G + 0.0722 * B;
}
var palette = [
  "rgb(255,204,204)",
  "rgb(255,230,204)",
  "rgb(255,255,204)",
  "rgb(204,255,204)",
  "rgb(204,255,230)",
  "rgb(204,255,255)",
  "rgb(204,230,255)",
  "rgb(204,204,255)",
  "rgb(230,204,255)",
  "rgb(255,204,255)",
  "rgb(255,153,153)",
  "rgb(255,204,153)",
  "rgb(255,255,153)",
  "rgb(153,255,153)",
  "rgb(153,255,204)",
  "rgb(153,255,255)",
  "rgb(153,204,255)",
  "rgb(153,153,255)",
  "rgb(204,153,255)",
  "rgb(255,153,255)",
  "rgb(255,102,102)",
  "rgb(255,179,102)",
  "rgb(255,255,102)",
  "rgb(102,255,102)",
  "rgb(102,255,179)",
  "rgb(102,255,255)",
  "rgb(102,179,255)",
  "rgb(102,102,255)",
  "rgb(179,102,255)",
  "rgb(255,102,255)",
  "rgb(255,51,51)",
  "rgb(255,153,51)",
  "rgb(255,255,51)",
  "rgb(51,255,51)",
  "rgb(51,255,153)",
  "rgb(51,255,255)",
  "rgb(51,153,255)",
  "rgb(51,51,255)",
  "rgb(153,51,255)",
  "rgb(255,51,255)",
  "rgb(255,0,0)",
  "rgb(255,128,0)",
  "rgb(255,255,0)",
  "rgb(0,255,0)",
  "rgb(0,255,128)",
  "rgb(0,255,255)",
  "rgb(0,128,255)",
  "rgb(0,0,255)",
  "rgb(128,0,255)",
  "rgb(255,0,255)",
  "rgb(245,0,0)",
  "rgb(245,123,0)",
  "rgb(245,245,0)",
  "rgb(0,245,0)",
  "rgb(0,245,123)",
  "rgb(0,245,245)",
  "rgb(0,123,245)",
  "rgb(0,0,245)",
  "rgb(123,0,245)",
  "rgb(245,0,245)",
  "rgb(214,0,0)",
  "rgb(214,108,0)",
  "rgb(214,214,0)",
  "rgb(0,214,0)",
  "rgb(0,214,108)",
  "rgb(0,214,214)",
  "rgb(0,108,214)",
  "rgb(0,0,214)",
  "rgb(108,0,214)",
  "rgb(214,0,214)",
  "rgb(163,0,0)",
  "rgb(163,82,0)",
  "rgb(163,163,0)",
  "rgb(0,163,0)",
  "rgb(0,163,82)",
  "rgb(0,163,163)",
  "rgb(0,82,163)",
  "rgb(0,0,163)",
  "rgb(82,0,163)",
  "rgb(163,0,163)",
  "rgb(92,0,0)",
  "rgb(92,46,0)",
  "rgb(92,92,0)",
  "rgb(0,92,0)",
  "rgb(0,92,46)",
  "rgb(0,92,92)",
  "rgb(0,46,92)",
  "rgb(0,0,92)",
  "rgb(46,0,92)",
  "rgb(92,0,92)",
  "rgb(255,255,255)",
  "rgb(205,205,205)",
  "rgb(178,178,178)",
  "rgb(153,153,153)",
  "rgb(127,127,127)",
  "rgb(102,102,102)",
  "rgb(76,76,76)",
  "rgb(51,51,51)",
  "rgb(25,25,25)",
  "rgb(0,0,0)"
];
var thumbPath = "M5 5 h10 v10 h-10 v-10 z";
var alphaTrackImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAH0lEQVQoU2NkYGAwZkAFZ5G5jPRRgOYEVDeB3EBjBQBOZwTVugIGyAAAAABJRU5ErkJggg==";
createComponent({
  name: "QColor",
  props: {
    ...useDarkProps,
    ...useFormProps,
    modelValue: String,
    defaultValue: String,
    defaultView: {
      type: String,
      default: "spectrum",
      validator: (v2) => ["spectrum", "tune", "palette"].includes(v2)
    },
    formatModel: {
      type: String,
      default: "auto",
      validator: (v2) => ["auto", "hex", "rgb", "hexa", "rgba"].includes(v2)
    },
    palette: Array,
    noHeader: Boolean,
    noHeaderTabs: Boolean,
    noFooter: Boolean,
    square: Boolean,
    flat: Boolean,
    bordered: Boolean,
    disable: Boolean,
    readonly: Boolean
  },
  emits: ["update:modelValue", "change"],
  setup(props4, { emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = use_dark_default(props4, $q);
    const { getCache } = use_render_cache_default();
    const spectrumRef = ref(null);
    const errorIconRef = ref(null);
    const forceHex = computed(() => props4.formatModel === "auto" ? null : props4.formatModel.indexOf("hex") !== -1);
    const forceAlpha = computed(() => props4.formatModel === "auto" ? null : props4.formatModel.indexOf("a") !== -1);
    const topView = ref(
      props4.formatModel === "auto" ? props4.modelValue === void 0 || props4.modelValue === null || props4.modelValue === "" || props4.modelValue.startsWith("#") ? "hex" : "rgb" : props4.formatModel.startsWith("hex") ? "hex" : "rgb"
    );
    const view = ref(props4.defaultView);
    const model = ref(parseModel(props4.modelValue || props4.defaultValue));
    const editable = computed(() => props4.disable !== true && props4.readonly !== true);
    const isHex = computed(
      () => props4.modelValue === void 0 || props4.modelValue === null || props4.modelValue === "" || props4.modelValue.startsWith("#")
    );
    const isOutputHex = computed(() => forceHex.value !== null ? forceHex.value : isHex.value);
    const formAttrs = computed(() => ({
      type: "hidden",
      name: props4.name,
      value: model.value[isOutputHex.value === true ? "hex" : "rgb"]
    }));
    const injectFormInput = useFormInject(formAttrs);
    const hasAlpha = computed(() => forceAlpha.value !== null ? forceAlpha.value : model.value.a !== void 0);
    const currentBgColor = computed(() => ({
      backgroundColor: model.value.rgb || "#000"
    }));
    const headerClass = computed(() => {
      const light = model.value.a !== void 0 && model.value.a < 65 ? true : luminosity(model.value) > 0.4;
      return `q-color-picker__header-content q-color-picker__header-content--${light ? "light" : "dark"}`;
    });
    const spectrumStyle = computed(() => ({
      background: `hsl(${model.value.h},100%,50%)`
    }));
    const spectrumPointerStyle = computed(() => ({
      top: `${100 - model.value.v}%`,
      [$q.lang.rtl === true ? "right" : "left"]: `${model.value.s}%`
    }));
    const computedPalette = computed(() => props4.palette !== void 0 && props4.palette.length !== 0 ? props4.palette : palette);
    const classes = computed(
      () => "q-color-picker" + (props4.bordered === true ? " q-color-picker--bordered" : "") + (props4.square === true ? " q-color-picker--square no-border-radius" : "") + (props4.flat === true ? " q-color-picker--flat no-shadow" : "") + (props4.disable === true ? " disabled" : "") + (isDark.value === true ? " q-color-picker--dark q-dark" : "")
    );
    const attributes = computed(() => props4.disable === true ? { "aria-disabled": "true" } : {});
    const spectrumDirective = computed(() => {
      return [[
        TouchPan_default,
        onSpectrumPan,
        void 0,
        { prevent: true, stop: true, mouse: true }
      ]];
    });
    watch(() => props4.modelValue, (v2) => {
      const localModel = parseModel(v2 || props4.defaultValue);
      if (localModel.hex !== model.value.hex) {
        model.value = localModel;
      }
    });
    watch(() => props4.defaultValue, (v2) => {
      if (!props4.modelValue && v2) {
        const localModel = parseModel(v2);
        if (localModel.hex !== model.value.hex) {
          model.value = localModel;
        }
      }
    });
    function updateModel2(rgb2, change) {
      model.value.hex = rgbToHex(rgb2);
      model.value.rgb = rgbToString(rgb2);
      model.value.r = rgb2.r;
      model.value.g = rgb2.g;
      model.value.b = rgb2.b;
      model.value.a = rgb2.a;
      const value2 = model.value[isOutputHex.value === true ? "hex" : "rgb"];
      emit2("update:modelValue", value2);
      change === true && emit2("change", value2);
    }
    function parseModel(v2) {
      const alpha = forceAlpha.value !== void 0 ? forceAlpha.value : props4.formatModel === "auto" ? null : props4.formatModel.indexOf("a") !== -1;
      if (typeof v2 !== "string" || v2.length === 0 || testPattern.anyColor(v2.replace(/ /g, "")) !== true) {
        return {
          h: 0,
          s: 0,
          v: 0,
          r: 0,
          g: 0,
          b: 0,
          a: alpha === true ? 100 : void 0,
          hex: void 0,
          rgb: void 0
        };
      }
      const model2 = textToRgb(v2);
      if (alpha === true && model2.a === void 0) {
        model2.a = 100;
      }
      model2.hex = rgbToHex(model2);
      model2.rgb = rgbToString(model2);
      return Object.assign(model2, rgbToHsv(model2));
    }
    function changeSpectrum(left, top, change) {
      const panel = spectrumRef.value;
      if (panel === null) return;
      const width3 = panel.clientWidth, height2 = panel.clientHeight, rect = panel.getBoundingClientRect();
      let x = Math.min(width3, Math.max(0, left - rect.left));
      if ($q.lang.rtl === true) {
        x = width3 - x;
      }
      const y = Math.min(height2, Math.max(0, top - rect.top)), s = Math.round(100 * x / width3), v2 = Math.round(100 * Math.max(0, Math.min(1, -(y / height2) + 1))), rgb2 = hsvToRgb({
        h: model.value.h,
        s,
        v: v2,
        a: hasAlpha.value === true ? model.value.a : void 0
      });
      model.value.s = s;
      model.value.v = v2;
      updateModel2(rgb2, change);
    }
    function onHue(val, change) {
      const h138 = Math.round(val);
      const rgb2 = hsvToRgb({
        h: h138,
        s: model.value.s,
        v: model.value.v,
        a: hasAlpha.value === true ? model.value.a : void 0
      });
      model.value.h = h138;
      updateModel2(rgb2, change);
    }
    function onHueChange(val) {
      onHue(val, true);
    }
    function onNumericChange(value2, formatModel, max, evt, change) {
      evt !== void 0 && stop(evt);
      if (!/^[0-9]+$/.test(value2)) {
        change === true && proxy.$forceUpdate();
        return;
      }
      const val = Math.floor(Number(value2));
      if (val < 0 || val > max) {
        change === true && proxy.$forceUpdate();
        return;
      }
      const rgb2 = {
        r: formatModel === "r" ? val : model.value.r,
        g: formatModel === "g" ? val : model.value.g,
        b: formatModel === "b" ? val : model.value.b,
        a: hasAlpha.value === true ? formatModel === "a" ? val : model.value.a : void 0
      };
      if (formatModel !== "a") {
        const hsv = rgbToHsv(rgb2);
        model.value.h = hsv.h;
        model.value.s = hsv.s;
        model.value.v = hsv.v;
      }
      updateModel2(rgb2, change);
      if (evt !== void 0 && change !== true && evt.target.selectionEnd !== void 0) {
        const index = evt.target.selectionEnd;
        nextTick(() => {
          evt.target.setSelectionRange(index, index);
        });
      }
    }
    function onEditorChange(evt, change) {
      let rgb2;
      const inp = evt.target.value;
      stop(evt);
      if (topView.value === "hex") {
        if (inp.length !== (hasAlpha.value === true ? 9 : 7) || !/^#[0-9A-Fa-f]+$/.test(inp)) {
          return true;
        }
        rgb2 = hexToRgb(inp);
      } else {
        let model2;
        if (!inp.endsWith(")")) {
          return true;
        } else if (hasAlpha.value !== true && inp.startsWith("rgb(")) {
          model2 = inp.substring(4, inp.length - 1).split(",").map((n) => parseInt(n, 10));
          if (model2.length !== 3 || !/^rgb\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3}\)$/.test(inp)) {
            return true;
          }
        } else if (hasAlpha.value === true && inp.startsWith("rgba(")) {
          model2 = inp.substring(5, inp.length - 1).split(",");
          if (model2.length !== 4 || !/^rgba\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/.test(inp)) {
            return true;
          }
          for (let i = 0; i < 3; i++) {
            const v22 = parseInt(model2[i], 10);
            if (v22 < 0 || v22 > 255) {
              return true;
            }
            model2[i] = v22;
          }
          const v2 = parseFloat(model2[3]);
          if (v2 < 0 || v2 > 1) {
            return true;
          }
          model2[3] = v2;
        } else {
          return true;
        }
        if (model2[0] < 0 || model2[0] > 255 || model2[1] < 0 || model2[1] > 255 || model2[2] < 0 || model2[2] > 255 || hasAlpha.value === true && (model2[3] < 0 || model2[3] > 1)) {
          return true;
        }
        rgb2 = {
          r: model2[0],
          g: model2[1],
          b: model2[2],
          a: hasAlpha.value === true ? model2[3] * 100 : void 0
        };
      }
      const hsv = rgbToHsv(rgb2);
      model.value.h = hsv.h;
      model.value.s = hsv.s;
      model.value.v = hsv.v;
      updateModel2(rgb2, change);
      if (change !== true) {
        const index = evt.target.selectionEnd;
        nextTick(() => {
          evt.target.setSelectionRange(index, index);
        });
      }
    }
    function onPalettePick(color) {
      const def2 = parseModel(color);
      const rgb2 = { r: def2.r, g: def2.g, b: def2.b, a: def2.a };
      if (rgb2.a === void 0) {
        rgb2.a = model.value.a;
      }
      model.value.h = def2.h;
      model.value.s = def2.s;
      model.value.v = def2.v;
      updateModel2(rgb2, true);
    }
    function onSpectrumPan(evt) {
      if (evt.isFinal) {
        changeSpectrum(
          evt.position.left,
          evt.position.top,
          true
        );
      } else {
        onSpectrumChange(evt);
      }
    }
    const onSpectrumChange = throttle_default(
      (evt) => {
        changeSpectrum(evt.position.left, evt.position.top);
      },
      20
    );
    function onSpectrumClick(evt) {
      changeSpectrum(
        evt.pageX - window.pageXOffset,
        evt.pageY - window.pageYOffset,
        true
      );
    }
    function onActivate(evt) {
      changeSpectrum(
        evt.pageX - window.pageXOffset,
        evt.pageY - window.pageYOffset
      );
    }
    function updateErrorIcon(val) {
      if (errorIconRef.value !== null) {
        errorIconRef.value.$el.style.opacity = val ? 1 : 0;
      }
    }
    function setTopView(val) {
      topView.value = val;
    }
    function getHeader() {
      const child = [];
      props4.noHeaderTabs !== true && child.push(
        h(QTabs_default, {
          class: "q-color-picker__header-tabs",
          modelValue: topView.value,
          dense: true,
          align: "justify",
          "onUpdate:modelValue": setTopView
        }, () => [
          h(QTab_default, {
            label: "HEX" + (hasAlpha.value === true ? "A" : ""),
            name: "hex",
            ripple: false
          }),
          h(QTab_default, {
            label: "RGB" + (hasAlpha.value === true ? "A" : ""),
            name: "rgb",
            ripple: false
          })
        ])
      );
      child.push(
        h("div", {
          class: "q-color-picker__header-banner row flex-center no-wrap"
        }, [
          h("input", {
            class: "fit",
            value: model.value[topView.value],
            ...editable.value !== true ? { readonly: true } : {},
            ...getCache("topIn", {
              onInput: (evt) => {
                updateErrorIcon(onEditorChange(evt) === true);
              },
              onChange: stop,
              onBlur: (evt) => {
                onEditorChange(evt, true) === true && proxy.$forceUpdate();
                updateErrorIcon(false);
              }
            })
          }),
          h(QIcon_default, {
            ref: errorIconRef,
            class: "q-color-picker__error-icon absolute no-pointer-events",
            name: $q.iconSet.type.negative
          })
        ])
      );
      return h("div", {
        class: "q-color-picker__header relative-position overflow-hidden"
      }, [
        h("div", { class: "q-color-picker__header-bg absolute-full" }),
        h("div", {
          class: headerClass.value,
          style: currentBgColor.value
        }, child)
      ]);
    }
    function getContent() {
      return h(QTabPanels_default, {
        modelValue: view.value,
        animated: true
      }, () => [
        h(QTabPanel_default, {
          class: "q-color-picker__spectrum-tab overflow-hidden",
          name: "spectrum"
        }, getSpectrumTab),
        h(QTabPanel_default, {
          class: "q-pa-md q-color-picker__tune-tab",
          name: "tune"
        }, getTuneTab),
        h(QTabPanel_default, {
          class: "q-color-picker__palette-tab",
          name: "palette"
        }, getPaletteTab)
      ]);
    }
    function setView(val) {
      view.value = val;
    }
    function getFooter() {
      return h("div", {
        class: "q-color-picker__footer relative-position overflow-hidden"
      }, [
        h(QTabs_default, {
          class: "absolute-full",
          modelValue: view.value,
          dense: true,
          align: "justify",
          "onUpdate:modelValue": setView
        }, () => [
          h(QTab_default, {
            icon: $q.iconSet.colorPicker.spectrum,
            name: "spectrum",
            ripple: false
          }),
          h(QTab_default, {
            icon: $q.iconSet.colorPicker.tune,
            name: "tune",
            ripple: false
          }),
          h(QTab_default, {
            icon: $q.iconSet.colorPicker.palette,
            name: "palette",
            ripple: false
          })
        ])
      ]);
    }
    function getSpectrumTab() {
      const data = {
        ref: spectrumRef,
        class: "q-color-picker__spectrum non-selectable relative-position cursor-pointer" + (editable.value !== true ? " readonly" : ""),
        style: spectrumStyle.value,
        ...editable.value === true ? {
          onClick: onSpectrumClick,
          onMousedown: onActivate
        } : {}
      };
      const child = [
        h("div", { style: { paddingBottom: "100%" } }),
        h("div", { class: "q-color-picker__spectrum-white absolute-full" }),
        h("div", { class: "q-color-picker__spectrum-black absolute-full" }),
        h("div", {
          class: "absolute",
          style: spectrumPointerStyle.value
        }, [
          model.value.hex !== void 0 ? h("div", { class: "q-color-picker__spectrum-circle" }) : null
        ])
      ];
      const sliders = [
        h(QSlider_default, {
          class: "q-color-picker__hue non-selectable",
          modelValue: model.value.h,
          min: 0,
          max: 360,
          trackSize: "8px",
          innerTrackColor: "transparent",
          selectionColor: "transparent",
          readonly: editable.value !== true,
          thumbPath,
          "onUpdate:modelValue": onHue,
          onChange: onHueChange
        })
      ];
      hasAlpha.value === true && sliders.push(
        h(QSlider_default, {
          class: "q-color-picker__alpha non-selectable",
          modelValue: model.value.a,
          min: 0,
          max: 100,
          trackSize: "8px",
          trackColor: "white",
          innerTrackColor: "transparent",
          selectionColor: "transparent",
          trackImg: alphaTrackImg,
          readonly: editable.value !== true,
          hideSelection: true,
          thumbPath,
          ...getCache("alphaSlide", {
            "onUpdate:modelValue": (value2) => onNumericChange(value2, "a", 100),
            onChange: (value2) => onNumericChange(value2, "a", 100, void 0, true)
          })
        })
      );
      return [
        hDir("div", data, child, "spec", editable.value, () => spectrumDirective.value),
        h("div", { class: "q-color-picker__sliders" }, sliders)
      ];
    }
    function getTuneTab() {
      return [
        h("div", { class: "row items-center no-wrap" }, [
          h("div", "R"),
          h(QSlider_default, {
            modelValue: model.value.r,
            min: 0,
            max: 255,
            color: "red",
            dark: isDark.value,
            readonly: editable.value !== true,
            ...getCache("rSlide", {
              "onUpdate:modelValue": (value2) => onNumericChange(value2, "r", 255),
              onChange: (value2) => onNumericChange(value2, "r", 255, void 0, true)
            })
          }),
          h("input", {
            value: model.value.r,
            maxlength: 3,
            readonly: editable.value !== true,
            onChange: stop,
            ...getCache("rIn", {
              onInput: (evt) => onNumericChange(evt.target.value, "r", 255, evt),
              onBlur: (evt) => onNumericChange(evt.target.value, "r", 255, evt, true)
            })
          })
        ]),
        h("div", { class: "row items-center no-wrap" }, [
          h("div", "G"),
          h(QSlider_default, {
            modelValue: model.value.g,
            min: 0,
            max: 255,
            color: "green",
            dark: isDark.value,
            readonly: editable.value !== true,
            ...getCache("gSlide", {
              "onUpdate:modelValue": (value2) => onNumericChange(value2, "g", 255),
              onChange: (value2) => onNumericChange(value2, "g", 255, void 0, true)
            })
          }),
          h("input", {
            value: model.value.g,
            maxlength: 3,
            readonly: editable.value !== true,
            onChange: stop,
            ...getCache("gIn", {
              onInput: (evt) => onNumericChange(evt.target.value, "g", 255, evt),
              onBlur: (evt) => onNumericChange(evt.target.value, "g", 255, evt, true)
            })
          })
        ]),
        h("div", { class: "row items-center no-wrap" }, [
          h("div", "B"),
          h(QSlider_default, {
            modelValue: model.value.b,
            min: 0,
            max: 255,
            color: "blue",
            readonly: editable.value !== true,
            dark: isDark.value,
            ...getCache("bSlide", {
              "onUpdate:modelValue": (value2) => onNumericChange(value2, "b", 255),
              onChange: (value2) => onNumericChange(value2, "b", 255, void 0, true)
            })
          }),
          h("input", {
            value: model.value.b,
            maxlength: 3,
            readonly: editable.value !== true,
            onChange: stop,
            ...getCache("bIn", {
              onInput: (evt) => onNumericChange(evt.target.value, "b", 255, evt),
              onBlur: (evt) => onNumericChange(evt.target.value, "b", 255, evt, true)
            })
          })
        ]),
        hasAlpha.value === true ? h("div", { class: "row items-center no-wrap" }, [
          h("div", "A"),
          h(QSlider_default, {
            modelValue: model.value.a,
            color: "grey",
            readonly: editable.value !== true,
            dark: isDark.value,
            ...getCache("aSlide", {
              "onUpdate:modelValue": (value2) => onNumericChange(value2, "a", 100),
              onChange: (value2) => onNumericChange(value2, "a", 100, void 0, true)
            })
          }),
          h("input", {
            value: model.value.a,
            maxlength: 3,
            readonly: editable.value !== true,
            onChange: stop,
            ...getCache("aIn", {
              onInput: (evt) => onNumericChange(evt.target.value, "a", 100, evt),
              onBlur: (evt) => onNumericChange(evt.target.value, "a", 100, evt, true)
            })
          })
        ]) : null
      ];
    }
    function getPaletteTab() {
      const fn = (color) => h("div", {
        class: "q-color-picker__cube col-auto",
        style: { backgroundColor: color },
        ...editable.value === true ? getCache("palette#" + color, {
          onClick: () => {
            onPalettePick(color);
          }
        }) : {}
      });
      return [
        h("div", {
          class: "row items-center q-color-picker__palette-rows" + (editable.value === true ? " q-color-picker__palette-rows--editable" : "")
        }, computedPalette.value.map(fn))
      ];
    }
    return () => {
      const child = [getContent()];
      if (props4.name !== void 0 && props4.disable !== true) {
        injectFormInput(child, "push");
      }
      props4.noHeader !== true && child.unshift(
        getHeader()
      );
      props4.noFooter !== true && child.push(
        getFooter()
      );
      return h("div", {
        class: classes.value,
        ...attributes.value
      }, child);
    };
  }
});
var breaks = [
  -61,
  9,
  38,
  199,
  426,
  686,
  756,
  818,
  1111,
  1181,
  1210,
  1635,
  2060,
  2097,
  2192,
  2262,
  2324,
  2394,
  2456,
  3178
];
function toJalaali(gy, gm, gd) {
  if (Object.prototype.toString.call(gy) === "[object Date]") {
    gd = gy.getDate();
    gm = gy.getMonth() + 1;
    gy = gy.getFullYear();
  }
  return d2j(g2d(gy, gm, gd));
}
function toGregorian(jy, jm, jd) {
  return d2g(j2d(jy, jm, jd));
}
function isLeapJalaaliYear(jy) {
  return jalCalLeap(jy) === 0;
}
function jalaaliMonthLength(jy, jm) {
  if (jm <= 6) return 31;
  if (jm <= 11) return 30;
  if (isLeapJalaaliYear(jy)) return 30;
  return 29;
}
function jalCalLeap(jy) {
  const bl = breaks.length;
  let jp = breaks[0], jm, jump, leap, n, i;
  if (jy < jp || jy >= breaks[bl - 1]) {
    throw new Error("Invalid Jalaali year " + jy);
  }
  for (i = 1; i < bl; i += 1) {
    jm = breaks[i];
    jump = jm - jp;
    if (jy < jm) {
      break;
    }
    jp = jm;
  }
  n = jy - jp;
  if (jump - n < 6) {
    n = n - jump + div(jump + 4, 33) * 33;
  }
  leap = mod(mod(n + 1, 33) - 1, 4);
  if (leap === -1) {
    leap = 4;
  }
  return leap;
}
function jalCal(jy, withoutLeap) {
  const bl = breaks.length, gy = jy + 621;
  let leapJ = -14, jp = breaks[0], jm, jump, leap, n, i;
  if (jy < jp || jy >= breaks[bl - 1]) {
    throw new Error("Invalid Jalaali year " + jy);
  }
  for (i = 1; i < bl; i += 1) {
    jm = breaks[i];
    jump = jm - jp;
    if (jy < jm) {
      break;
    }
    leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
    jp = jm;
  }
  n = jy - jp;
  leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
  if (mod(jump, 33) === 4 && jump - n === 4) {
    leapJ += 1;
  }
  const leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;
  const march = 20 + leapJ - leapG;
  if (!withoutLeap) {
    if (jump - n < 6) {
      n = n - jump + div(jump + 4, 33) * 33;
    }
    leap = mod(mod(n + 1, 33) - 1, 4);
    if (leap === -1) {
      leap = 4;
    }
  }
  return {
    leap,
    gy,
    march
  };
}
function j2d(jy, jm, jd) {
  const r = jalCal(jy, true);
  return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1;
}
function d2j(jdn) {
  const gy = d2g(jdn).gy;
  let jy = gy - 621, jd, jm, k;
  const r = jalCal(jy, false), jdn1f = g2d(gy, 3, r.march);
  k = jdn - jdn1f;
  if (k >= 0) {
    if (k <= 185) {
      jm = 1 + div(k, 31);
      jd = mod(k, 31) + 1;
      return {
        jy,
        jm,
        jd
      };
    } else {
      k -= 186;
    }
  } else {
    jy -= 1;
    k += 179;
    if (r.leap === 1) {
      k += 1;
    }
  }
  jm = 7 + div(k, 30);
  jd = mod(k, 30) + 1;
  return {
    jy,
    jm,
    jd
  };
}
function g2d(gy, gm, gd) {
  let d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) + div(153 * mod(gm + 9, 12) + 2, 5) + gd - 34840408;
  d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
  return d;
}
function d2g(jdn) {
  let j = 4 * jdn + 139361631;
  j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
  const i = div(mod(j, 1461), 4) * 5 + 308, gd = div(mod(i, 153), 5) + 1, gm = mod(div(i, 153), 12) + 1, gy = div(j, 1461) - 100100 + div(8 - gm, 6);
  return {
    gy,
    gm,
    gd
  };
}
function div(a, b) {
  return ~~(a / b);
}
function mod(a, b) {
  return a - ~~(a / b) * b;
}
var calendars = ["gregorian", "persian"];
var useDatetimeProps = {
  // should define modelValue in the target component
  mask: {
    type: String
  },
  locale: Object,
  calendar: {
    type: String,
    validator: (v2) => calendars.includes(v2),
    default: "gregorian"
  },
  landscape: Boolean,
  color: String,
  textColor: String,
  square: Boolean,
  flat: Boolean,
  bordered: Boolean,
  readonly: Boolean,
  disable: Boolean
};
var useDatetimeEmits = ["update:modelValue"];
function getDayHash(date) {
  return date.year + "/" + pad(date.month) + "/" + pad(date.day);
}
function use_datetime_default(props4, $q) {
  const editable = computed(() => {
    return props4.disable !== true && props4.readonly !== true;
  });
  const tabindex = computed(() => {
    return editable.value === true ? 0 : -1;
  });
  const headerClass = computed(() => {
    const cls = [];
    props4.color !== void 0 && cls.push(`bg-${props4.color}`);
    props4.textColor !== void 0 && cls.push(`text-${props4.textColor}`);
    return cls.join(" ");
  });
  function getLocale2() {
    return props4.locale !== void 0 ? { ...$q.lang.date, ...props4.locale } : $q.lang.date;
  }
  function getCurrentDate(dateOnly) {
    const d = /* @__PURE__ */ new Date();
    const timeFill = dateOnly === true ? null : 0;
    if (props4.calendar === "persian") {
      const jDate = toJalaali(d);
      return {
        year: jDate.jy,
        month: jDate.jm,
        day: jDate.jd
      };
    }
    return {
      year: d.getFullYear(),
      month: d.getMonth() + 1,
      day: d.getDate(),
      hour: timeFill,
      minute: timeFill,
      second: timeFill,
      millisecond: timeFill
    };
  }
  return {
    editable,
    tabindex,
    headerClass,
    getLocale: getLocale2,
    getCurrentDate
  };
}
var MILLISECONDS_IN_DAY = 864e5;
var MILLISECONDS_IN_HOUR = 36e5;
var MILLISECONDS_IN_MINUTE = 6e4;
var defaultMask = "YYYY-MM-DDTHH:mm:ss.SSSZ";
var token$1 = /\[((?:[^\]\\]|\\]|\\)*)\]|do|d{1,4}|Mo|M{1,4}|m{1,2}|wo|w{1,2}|Qo|Do|DDDo|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]/g;
var reverseToken = /(\[[^\]]*\])|do|d{1,4}|Mo|M{1,4}|m{1,2}|wo|w{1,2}|Qo|Do|DDDo|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]|([.*+:?^,\s${}()|\\]+)/g;
var regexStore = {};
function getRegexData(mask, dateLocale) {
  const days = "(" + dateLocale.days.join("|") + ")", key = mask + days;
  if (regexStore[key] !== void 0) {
    return regexStore[key];
  }
  const daysShort = "(" + dateLocale.daysShort.join("|") + ")", months = "(" + dateLocale.months.join("|") + ")", monthsShort = "(" + dateLocale.monthsShort.join("|") + ")";
  const map = {};
  let index = 0;
  const regexText = mask.replace(reverseToken, (match) => {
    index++;
    switch (match) {
      case "YY":
        map.YY = index;
        return "(-?\\d{1,2})";
      case "YYYY":
        map.YYYY = index;
        return "(-?\\d{1,4})";
      case "M":
        map.M = index;
        return "(\\d{1,2})";
      case "Mo":
        map.M = index++;
        return "(\\d{1,2}(st|nd|rd|th))";
      case "MM":
        map.M = index;
        return "(\\d{2})";
      case "MMM":
        map.MMM = index;
        return monthsShort;
      case "MMMM":
        map.MMMM = index;
        return months;
      case "D":
        map.D = index;
        return "(\\d{1,2})";
      case "Do":
        map.D = index++;
        return "(\\d{1,2}(st|nd|rd|th))";
      case "DD":
        map.D = index;
        return "(\\d{2})";
      case "H":
        map.H = index;
        return "(\\d{1,2})";
      case "HH":
        map.H = index;
        return "(\\d{2})";
      case "h":
        map.h = index;
        return "(\\d{1,2})";
      case "hh":
        map.h = index;
        return "(\\d{2})";
      case "m":
        map.m = index;
        return "(\\d{1,2})";
      case "mm":
        map.m = index;
        return "(\\d{2})";
      case "s":
        map.s = index;
        return "(\\d{1,2})";
      case "ss":
        map.s = index;
        return "(\\d{2})";
      case "S":
        map.S = index;
        return "(\\d{1})";
      case "SS":
        map.S = index;
        return "(\\d{2})";
      case "SSS":
        map.S = index;
        return "(\\d{3})";
      case "A":
        map.A = index;
        return "(AM|PM)";
      case "a":
        map.a = index;
        return "(am|pm)";
      case "aa":
        map.aa = index;
        return "(a\\.m\\.|p\\.m\\.)";
      case "ddd":
        return daysShort;
      case "dddd":
        return days;
      case "Q":
      case "d":
      case "E":
        return "(\\d{1})";
      case "do":
        index++;
        return "(\\d{1}(st|nd|rd|th))";
      case "Qo":
        return "(1st|2nd|3rd|4th)";
      case "DDD":
      case "DDDD":
        return "(\\d{1,3})";
      case "DDDo":
        index++;
        return "(\\d{1,3}(st|nd|rd|th))";
      case "w":
        return "(\\d{1,2})";
      case "wo":
        index++;
        return "(\\d{1,2}(st|nd|rd|th))";
      case "ww":
        return "(\\d{2})";
      case "Z":
        map.Z = index;
        return "(Z|[+-]\\d{2}:\\d{2})";
      case "ZZ":
        map.ZZ = index;
        return "(Z|[+-]\\d{2}\\d{2})";
      case "X":
        map.X = index;
        return "(-?\\d+)";
      case "x":
        map.x = index;
        return "(-?\\d{4,})";
      default:
        index--;
        if (match[0] === "[") {
          match = match.substring(1, match.length - 1);
        }
        return match.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  });
  const res = { map, regex: new RegExp("^" + regexText) };
  regexStore[key] = res;
  return res;
}
function getDateLocale(paramDateLocale, langProps) {
  return paramDateLocale !== void 0 ? paramDateLocale : langProps !== void 0 ? langProps.date : en_US_default.date;
}
function formatTimezone(offset2, delimeter = "") {
  const sign = offset2 > 0 ? "-" : "+", absOffset = Math.abs(offset2), hours = Math.floor(absOffset / 60), minutes = absOffset % 60;
  return sign + pad(hours) + delimeter + pad(minutes);
}
function __splitDate(str, mask, dateLocale, calendar, defaultModel) {
  const date = {
    year: null,
    month: null,
    day: null,
    hour: null,
    minute: null,
    second: null,
    millisecond: null,
    timezoneOffset: null,
    dateHash: null,
    timeHash: null
  };
  defaultModel !== void 0 && Object.assign(date, defaultModel);
  if (str === void 0 || str === null || str === "" || typeof str !== "string") {
    return date;
  }
  if (mask === void 0) {
    mask = defaultMask;
  }
  const langOpts = getDateLocale(dateLocale, Lang_default.props), months = langOpts.months, monthsShort = langOpts.monthsShort;
  const { regex, map } = getRegexData(mask, langOpts);
  const match = str.match(regex);
  if (match === null) {
    return date;
  }
  let tzString = "";
  if (map.X !== void 0 || map.x !== void 0) {
    const stamp = parseInt(match[map.X !== void 0 ? map.X : map.x], 10);
    if (isNaN(stamp) === true || stamp < 0) {
      return date;
    }
    const d = new Date(stamp * (map.X !== void 0 ? 1e3 : 1));
    date.year = d.getFullYear();
    date.month = d.getMonth() + 1;
    date.day = d.getDate();
    date.hour = d.getHours();
    date.minute = d.getMinutes();
    date.second = d.getSeconds();
    date.millisecond = d.getMilliseconds();
  } else {
    if (map.YYYY !== void 0) {
      date.year = parseInt(match[map.YYYY], 10);
    } else if (map.YY !== void 0) {
      const y = parseInt(match[map.YY], 10);
      date.year = y < 0 ? y : 2e3 + y;
    }
    if (map.M !== void 0) {
      date.month = parseInt(match[map.M], 10);
      if (date.month < 1 || date.month > 12) {
        return date;
      }
    } else if (map.MMM !== void 0) {
      date.month = monthsShort.indexOf(match[map.MMM]) + 1;
    } else if (map.MMMM !== void 0) {
      date.month = months.indexOf(match[map.MMMM]) + 1;
    }
    if (map.D !== void 0) {
      date.day = parseInt(match[map.D], 10);
      if (date.year === null || date.month === null || date.day < 1) {
        return date;
      }
      const maxDay = calendar !== "persian" ? new Date(date.year, date.month, 0).getDate() : jalaaliMonthLength(date.year, date.month);
      if (date.day > maxDay) {
        return date;
      }
    }
    if (map.H !== void 0) {
      date.hour = parseInt(match[map.H], 10) % 24;
    } else if (map.h !== void 0) {
      date.hour = parseInt(match[map.h], 10) % 12;
      if (map.A && match[map.A] === "PM" || map.a && match[map.a] === "pm" || map.aa && match[map.aa] === "p.m.") {
        date.hour += 12;
      }
      date.hour = date.hour % 24;
    }
    if (map.m !== void 0) {
      date.minute = parseInt(match[map.m], 10) % 60;
    }
    if (map.s !== void 0) {
      date.second = parseInt(match[map.s], 10) % 60;
    }
    if (map.S !== void 0) {
      date.millisecond = parseInt(match[map.S], 10) * 10 ** (3 - match[map.S].length);
    }
    if (map.Z !== void 0 || map.ZZ !== void 0) {
      tzString = map.Z !== void 0 ? match[map.Z].replace(":", "") : match[map.ZZ];
      date.timezoneOffset = (tzString[0] === "+" ? -1 : 1) * (60 * tzString.slice(1, 3) + 1 * tzString.slice(3, 5));
    }
  }
  date.dateHash = pad(date.year, 6) + "/" + pad(date.month) + "/" + pad(date.day);
  date.timeHash = pad(date.hour) + ":" + pad(date.minute) + ":" + pad(date.second) + tzString;
  return date;
}
function getWeekOfYear(date) {
  const thursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  thursday.setDate(thursday.getDate() - (thursday.getDay() + 6) % 7 + 3);
  const firstThursday = new Date(thursday.getFullYear(), 0, 4);
  firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);
  const ds = thursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
  thursday.setHours(thursday.getHours() - ds);
  const weekDiff = (thursday - firstThursday) / (MILLISECONDS_IN_DAY * 7);
  return 1 + Math.floor(weekDiff);
}
function startOfDate(date, unit, utc) {
  const t = new Date(date), prefix = `set${utc === true ? "UTC" : ""}`;
  switch (unit) {
    case "year":
    case "years":
      t[`${prefix}Month`](0);
    case "month":
    case "months":
      t[`${prefix}Date`](1);
    case "day":
    case "days":
    case "date":
      t[`${prefix}Hours`](0);
    case "hour":
    case "hours":
      t[`${prefix}Minutes`](0);
    case "minute":
    case "minutes":
      t[`${prefix}Seconds`](0);
    case "second":
    case "seconds":
      t[`${prefix}Milliseconds`](0);
  }
  return t;
}
function getDiff(t, sub, interval) {
  return (t.getTime() - t.getTimezoneOffset() * MILLISECONDS_IN_MINUTE - (sub.getTime() - sub.getTimezoneOffset() * MILLISECONDS_IN_MINUTE)) / interval;
}
function getDateDiff(date, subtract, unit = "days") {
  const t = new Date(date), sub = new Date(subtract);
  switch (unit) {
    case "years":
    case "year":
      return t.getFullYear() - sub.getFullYear();
    case "months":
    case "month":
      return (t.getFullYear() - sub.getFullYear()) * 12 + t.getMonth() - sub.getMonth();
    case "days":
    case "day":
    case "date":
      return getDiff(startOfDate(t, "day"), startOfDate(sub, "day"), MILLISECONDS_IN_DAY);
    case "hours":
    case "hour":
      return getDiff(startOfDate(t, "hour"), startOfDate(sub, "hour"), MILLISECONDS_IN_HOUR);
    case "minutes":
    case "minute":
      return getDiff(startOfDate(t, "minute"), startOfDate(sub, "minute"), MILLISECONDS_IN_MINUTE);
    case "seconds":
    case "second":
      return getDiff(startOfDate(t, "second"), startOfDate(sub, "second"), 1e3);
  }
}
function getDayOfYear(date) {
  return getDateDiff(date, startOfDate(date, "year"), "days") + 1;
}
function getOrdinal(n) {
  if (n >= 11 && n <= 13) {
    return `${n}th`;
  }
  switch (n % 10) {
    case 1:
      return `${n}st`;
    case 2:
      return `${n}nd`;
    case 3:
      return `${n}rd`;
  }
  return `${n}th`;
}
var formatter = {
  // Year: 00, 01, ..., 99
  YY(date, dateLocale, forcedYear) {
    const y = this.YYYY(date, dateLocale, forcedYear) % 100;
    return y >= 0 ? pad(y) : "-" + pad(Math.abs(y));
  },
  // Year: 1900, 1901, ..., 2099
  YYYY(date, _dateLocale, forcedYear) {
    return forcedYear !== void 0 && forcedYear !== null ? forcedYear : date.getFullYear();
  },
  // Month: 1, 2, ..., 12
  M(date) {
    return date.getMonth() + 1;
  },
  // Month: 1st, 2nd, ..., 12th
  Mo(date) {
    return getOrdinal(date.getMonth() + 1);
  },
  // Month: 01, 02, ..., 12
  MM(date) {
    return pad(date.getMonth() + 1);
  },
  // Month Short Name: Jan, Feb, ...
  MMM(date, dateLocale) {
    return dateLocale.monthsShort[date.getMonth()];
  },
  // Month Name: January, February, ...
  MMMM(date, dateLocale) {
    return dateLocale.months[date.getMonth()];
  },
  // Quarter: 1, 2, 3, 4
  Q(date) {
    return Math.ceil((date.getMonth() + 1) / 3);
  },
  // Quarter: 1st, 2nd, 3rd, 4th
  Qo(date) {
    return getOrdinal(this.Q(date));
  },
  // Day of month: 1, 2, ..., 31
  D(date) {
    return date.getDate();
  },
  // Day of month: 1st, 2nd, ..., 31st
  Do(date) {
    return getOrdinal(date.getDate());
  },
  // Day of month: 01, 02, ..., 31
  DD(date) {
    return pad(date.getDate());
  },
  // Day of year: 1, 2, ..., 366
  DDD(date) {
    return getDayOfYear(date);
  },
  // Day of year: 1st, 2nd, ..., 366th
  DDDo(date) {
    return getOrdinal(getDayOfYear(date));
  },
  // Day of year: 001, 002, ..., 366
  DDDD(date) {
    return pad(getDayOfYear(date), 3);
  },
  // Day of week: 0, 1, ..., 6
  d(date) {
    return date.getDay();
  },
  // Day of week: 0th, 1st, ..., 6th
  do(date) {
    return getOrdinal(date.getDay());
  },
  // Day of week: Su, Mo, ...
  dd(date, dateLocale) {
    return dateLocale.days[date.getDay()].slice(0, 2);
  },
  // Day of week: Sun, Mon, ...
  ddd(date, dateLocale) {
    return dateLocale.daysShort[date.getDay()];
  },
  // Day of week: Sunday, Monday, ...
  dddd(date, dateLocale) {
    return dateLocale.days[date.getDay()];
  },
  // Day of ISO week: 1, 2, ..., 7
  E(date) {
    return date.getDay() || 7;
  },
  // Week of Year: 1 2 ... 52 53
  w(date) {
    return getWeekOfYear(date);
  },
  // Week of Year: 1st 2nd ... 52nd 53rd
  wo(date) {
    return getOrdinal(getWeekOfYear(date));
  },
  // Week of Year: 01 02 ... 52 53
  ww(date) {
    return pad(getWeekOfYear(date));
  },
  // Hour: 0, 1, ... 23
  H(date) {
    return date.getHours();
  },
  // Hour: 00, 01, ..., 23
  HH(date) {
    return pad(date.getHours());
  },
  // Hour: 1, 2, ..., 12
  h(date) {
    const hours = date.getHours();
    return hours === 0 ? 12 : hours > 12 ? hours % 12 : hours;
  },
  // Hour: 01, 02, ..., 12
  hh(date) {
    return pad(this.h(date));
  },
  // Minute: 0, 1, ..., 59
  m(date) {
    return date.getMinutes();
  },
  // Minute: 00, 01, ..., 59
  mm(date) {
    return pad(date.getMinutes());
  },
  // Second: 0, 1, ..., 59
  s(date) {
    return date.getSeconds();
  },
  // Second: 00, 01, ..., 59
  ss(date) {
    return pad(date.getSeconds());
  },
  // 1/10 of second: 0, 1, ..., 9
  S(date) {
    return Math.floor(date.getMilliseconds() / 100);
  },
  // 1/100 of second: 00, 01, ..., 99
  SS(date) {
    return pad(Math.floor(date.getMilliseconds() / 10));
  },
  // Millisecond: 000, 001, ..., 999
  SSS(date) {
    return pad(date.getMilliseconds(), 3);
  },
  // Meridiem: AM, PM
  A(date) {
    return date.getHours() < 12 ? "AM" : "PM";
  },
  // Meridiem: am, pm
  a(date) {
    return date.getHours() < 12 ? "am" : "pm";
  },
  // Meridiem: a.m., p.m.
  aa(date) {
    return date.getHours() < 12 ? "a.m." : "p.m.";
  },
  // Timezone: -01:00, +00:00, ... +12:00
  Z(date, _dateLocale, _forcedYear, forcedTimezoneOffset) {
    const tzOffset = forcedTimezoneOffset === void 0 || forcedTimezoneOffset === null ? date.getTimezoneOffset() : forcedTimezoneOffset;
    return formatTimezone(tzOffset, ":");
  },
  // Timezone: -0100, +0000, ... +1200
  ZZ(date, _dateLocale, _forcedYear, forcedTimezoneOffset) {
    const tzOffset = forcedTimezoneOffset === void 0 || forcedTimezoneOffset === null ? date.getTimezoneOffset() : forcedTimezoneOffset;
    return formatTimezone(tzOffset);
  },
  // Seconds timestamp: 512969520
  X(date) {
    return Math.floor(date.getTime() / 1e3);
  },
  // Milliseconds timestamp: 512969520900
  x(date) {
    return date.getTime();
  }
};
function formatDate(val, mask, dateLocale, __forcedYear, __forcedTimezoneOffset) {
  if (val !== 0 && !val || val === Infinity || val === -Infinity) {
    return;
  }
  const date = new Date(val);
  if (isNaN(date)) {
    return;
  }
  if (mask === void 0) {
    mask = defaultMask;
  }
  const locale = getDateLocale(dateLocale, Lang_default.props);
  return mask.replace(
    token$1,
    (match, text) => match in formatter ? formatter[match](date, locale, __forcedYear, __forcedTimezoneOffset) : text === void 0 ? match : text.split("\\]").join("]")
  );
}
var yearsInterval = 20;
var views = ["Calendar", "Years", "Months"];
var viewIsValid = (v2) => views.includes(v2);
var yearMonthValidator = (v2) => /^-?[\d]+\/[0-1]\d$/.test(v2);
var lineStr = "  ";
function getMonthHash(date) {
  return date.year + "/" + pad(date.month);
}
createComponent({
  name: "QDate",
  props: {
    ...useDatetimeProps,
    ...useFormProps,
    ...useDarkProps,
    modelValue: {
      required: true,
      validator: (val) => typeof val === "string" || Array.isArray(val) === true || Object(val) === val || val === null
    },
    multiple: Boolean,
    range: Boolean,
    title: String,
    subtitle: String,
    mask: {
      ...useDatetimeProps.mask,
      // this mask is forced
      // when using persian calendar
      default: "YYYY/MM/DD"
    },
    defaultYearMonth: {
      type: String,
      validator: yearMonthValidator
    },
    yearsInMonthView: Boolean,
    events: [Array, Function],
    eventColor: [String, Function],
    emitImmediately: Boolean,
    options: [Array, Function],
    navigationMinYearMonth: {
      type: String,
      validator: yearMonthValidator
    },
    navigationMaxYearMonth: {
      type: String,
      validator: yearMonthValidator
    },
    noUnset: Boolean,
    firstDayOfWeek: [String, Number],
    todayBtn: Boolean,
    minimal: Boolean,
    defaultView: {
      type: String,
      default: "Calendar",
      validator: viewIsValid
    }
  },
  emits: [
    ...useDatetimeEmits,
    "rangeStart",
    "rangeEnd",
    "navigation"
  ],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = use_dark_default(props4, $q);
    const { getCache } = use_render_cache_default();
    const { tabindex, headerClass, getLocale: getLocale2, getCurrentDate } = use_datetime_default(props4, $q);
    let lastEmitValue;
    const formAttrs = useFormAttrs(props4);
    const injectFormInput = useFormInject(formAttrs);
    const blurTargetRef = ref(null);
    const innerMask = ref(getMask());
    const innerLocale = ref(getLocale2());
    const mask = computed(() => getMask());
    const locale = computed(() => getLocale2());
    const today = computed(() => getCurrentDate());
    const viewModel = ref(getViewModel(innerMask.value, innerLocale.value));
    const view = ref(props4.defaultView);
    const direction = computed(() => $q.lang.rtl === true ? "right" : "left");
    const monthDirection = ref(direction.value);
    const yearDirection = ref(direction.value);
    const year = viewModel.value.year;
    const startYear = ref(year - year % yearsInterval - (year < 0 ? yearsInterval : 0));
    const editRange = ref(null);
    const classes = computed(() => {
      const type = props4.landscape === true ? "landscape" : "portrait";
      return `q-date q-date--${type} q-date--${type}-${props4.minimal === true ? "minimal" : "standard"}` + (isDark.value === true ? " q-date--dark q-dark" : "") + (props4.bordered === true ? " q-date--bordered" : "") + (props4.square === true ? " q-date--square no-border-radius" : "") + (props4.flat === true ? " q-date--flat no-shadow" : "") + (props4.disable === true ? " disabled" : props4.readonly === true ? " q-date--readonly" : "");
    });
    const computedColor = computed(() => {
      return props4.color || "primary";
    });
    const computedTextColor = computed(() => {
      return props4.textColor || "white";
    });
    const isImmediate = computed(
      () => props4.emitImmediately === true && props4.multiple !== true && props4.range !== true
    );
    const normalizedModel = computed(() => Array.isArray(props4.modelValue) === true ? props4.modelValue : props4.modelValue !== null && props4.modelValue !== void 0 ? [props4.modelValue] : []);
    const daysModel = computed(
      () => normalizedModel.value.filter((date) => typeof date === "string").map((date) => decodeString(date, innerMask.value, innerLocale.value)).filter(
        (date) => date.dateHash !== null && date.day !== null && date.month !== null && date.year !== null
      )
    );
    const rangeModel = computed(() => {
      const fn = (date) => decodeString(date, innerMask.value, innerLocale.value);
      return normalizedModel.value.filter((date) => isObject(date) === true && date.from !== void 0 && date.to !== void 0).map((range) => ({ from: fn(range.from), to: fn(range.to) })).filter((range) => range.from.dateHash !== null && range.to.dateHash !== null && range.from.dateHash < range.to.dateHash);
    });
    const getNativeDateFn = computed(() => props4.calendar !== "persian" ? (model) => new Date(model.year, model.month - 1, model.day) : (model) => {
      const gDate = toGregorian(model.year, model.month, model.day);
      return new Date(gDate.gy, gDate.gm - 1, gDate.gd);
    });
    const encodeObjectFn = computed(() => props4.calendar === "persian" ? getDayHash : (date, mask2, locale2) => formatDate(
      new Date(
        date.year,
        date.month - 1,
        date.day,
        date.hour,
        date.minute,
        date.second,
        date.millisecond
      ),
      mask2 === void 0 ? innerMask.value : mask2,
      locale2 === void 0 ? innerLocale.value : locale2,
      date.year,
      date.timezoneOffset
    ));
    const daysInModel = computed(
      () => daysModel.value.length + rangeModel.value.reduce(
        (acc, range) => acc + 1 + getDateDiff(
          getNativeDateFn.value(range.to),
          getNativeDateFn.value(range.from)
        ),
        0
      )
    );
    const headerTitle = computed(() => {
      if (props4.title !== void 0 && props4.title !== null && props4.title.length !== 0) {
        return props4.title;
      }
      if (editRange.value !== null) {
        const model2 = editRange.value.init;
        const date2 = getNativeDateFn.value(model2);
        return innerLocale.value.daysShort[date2.getDay()] + ", " + innerLocale.value.monthsShort[model2.month - 1] + " " + model2.day + lineStr + "?";
      }
      if (daysInModel.value === 0) {
        return lineStr;
      }
      if (daysInModel.value > 1) {
        return `${daysInModel.value} ${innerLocale.value.pluralDay}`;
      }
      const model = daysModel.value[0];
      const date = getNativeDateFn.value(model);
      if (isNaN(date.valueOf()) === true) {
        return lineStr;
      }
      if (innerLocale.value.headerTitle !== void 0) {
        return innerLocale.value.headerTitle(date, model);
      }
      return innerLocale.value.daysShort[date.getDay()] + ", " + innerLocale.value.monthsShort[model.month - 1] + " " + model.day;
    });
    const minSelectedModel = computed(() => {
      const model = daysModel.value.concat(rangeModel.value.map((range) => range.from)).sort((a, b) => a.year - b.year || a.month - b.month);
      return model[0];
    });
    const maxSelectedModel = computed(() => {
      const model = daysModel.value.concat(rangeModel.value.map((range) => range.to)).sort((a, b) => b.year - a.year || b.month - a.month);
      return model[0];
    });
    const headerSubtitle = computed(() => {
      if (props4.subtitle !== void 0 && props4.subtitle !== null && props4.subtitle.length !== 0) {
        return props4.subtitle;
      }
      if (daysInModel.value === 0) {
        return lineStr;
      }
      if (daysInModel.value > 1) {
        const from = minSelectedModel.value;
        const to = maxSelectedModel.value;
        const month = innerLocale.value.monthsShort;
        return month[from.month - 1] + (from.year !== to.year ? " " + from.year + lineStr + month[to.month - 1] + " " : from.month !== to.month ? lineStr + month[to.month - 1] : "") + " " + to.year;
      }
      return daysModel.value[0].year;
    });
    const dateArrow = computed(() => {
      const val = [$q.iconSet.datetime.arrowLeft, $q.iconSet.datetime.arrowRight];
      return $q.lang.rtl === true ? val.reverse() : val;
    });
    const computedFirstDayOfWeek = computed(() => props4.firstDayOfWeek !== void 0 ? Number(props4.firstDayOfWeek) : innerLocale.value.firstDayOfWeek);
    const daysOfWeek = computed(() => {
      const days2 = innerLocale.value.daysShort, first = computedFirstDayOfWeek.value;
      return first > 0 ? days2.slice(first, 7).concat(days2.slice(0, first)) : days2;
    });
    const daysInMonth2 = computed(() => {
      const date = viewModel.value;
      return props4.calendar !== "persian" ? new Date(date.year, date.month, 0).getDate() : jalaaliMonthLength(date.year, date.month);
    });
    const evtColor = computed(() => typeof props4.eventColor === "function" ? props4.eventColor : () => props4.eventColor);
    const minNav = computed(() => {
      if (props4.navigationMinYearMonth === void 0) {
        return null;
      }
      const data = props4.navigationMinYearMonth.split("/");
      return { year: parseInt(data[0], 10), month: parseInt(data[1], 10) };
    });
    const maxNav = computed(() => {
      if (props4.navigationMaxYearMonth === void 0) {
        return null;
      }
      const data = props4.navigationMaxYearMonth.split("/");
      return { year: parseInt(data[0], 10), month: parseInt(data[1], 10) };
    });
    const navBoundaries = computed(() => {
      const data = {
        month: { prev: true, next: true },
        year: { prev: true, next: true }
      };
      if (minNav.value !== null && minNav.value.year >= viewModel.value.year) {
        data.year.prev = false;
        if (minNav.value.year === viewModel.value.year && minNav.value.month >= viewModel.value.month) {
          data.month.prev = false;
        }
      }
      if (maxNav.value !== null && maxNav.value.year <= viewModel.value.year) {
        data.year.next = false;
        if (maxNav.value.year === viewModel.value.year && maxNav.value.month <= viewModel.value.month) {
          data.month.next = false;
        }
      }
      return data;
    });
    const daysMap = computed(() => {
      const map = {};
      daysModel.value.forEach((entry) => {
        const hash = getMonthHash(entry);
        if (map[hash] === void 0) {
          map[hash] = [];
        }
        map[hash].push(entry.day);
      });
      return map;
    });
    const rangeMap = computed(() => {
      const map = {};
      rangeModel.value.forEach((entry) => {
        const hashFrom = getMonthHash(entry.from);
        const hashTo = getMonthHash(entry.to);
        if (map[hashFrom] === void 0) {
          map[hashFrom] = [];
        }
        map[hashFrom].push({
          from: entry.from.day,
          to: hashFrom === hashTo ? entry.to.day : void 0,
          range: entry
        });
        if (hashFrom < hashTo) {
          let hash;
          const { year: year2, month } = entry.from;
          const cur = month < 12 ? { year: year2, month: month + 1 } : { year: year2 + 1, month: 1 };
          while ((hash = getMonthHash(cur)) <= hashTo) {
            if (map[hash] === void 0) {
              map[hash] = [];
            }
            map[hash].push({
              from: void 0,
              to: hash === hashTo ? entry.to.day : void 0,
              range: entry
            });
            cur.month++;
            if (cur.month > 12) {
              cur.year++;
              cur.month = 1;
            }
          }
        }
      });
      return map;
    });
    const rangeView = computed(() => {
      if (editRange.value === null) {
        return;
      }
      const { init: init2, initHash, final, finalHash } = editRange.value;
      const [from, to] = initHash <= finalHash ? [init2, final] : [final, init2];
      const fromHash = getMonthHash(from);
      const toHash = getMonthHash(to);
      if (fromHash !== viewMonthHash.value && toHash !== viewMonthHash.value) {
        return;
      }
      const view2 = {};
      if (fromHash === viewMonthHash.value) {
        view2.from = from.day;
        view2.includeFrom = true;
      } else {
        view2.from = 1;
      }
      if (toHash === viewMonthHash.value) {
        view2.to = to.day;
        view2.includeTo = true;
      } else {
        view2.to = daysInMonth2.value;
      }
      return view2;
    });
    const viewMonthHash = computed(() => getMonthHash(viewModel.value));
    const selectionDaysMap = computed(() => {
      const map = {};
      if (props4.options === void 0) {
        for (let i = 1; i <= daysInMonth2.value; i++) {
          map[i] = true;
        }
        return map;
      }
      const fn = typeof props4.options === "function" ? props4.options : (date) => props4.options.includes(date);
      for (let i = 1; i <= daysInMonth2.value; i++) {
        const dayHash = viewMonthHash.value + "/" + pad(i);
        map[i] = fn(dayHash);
      }
      return map;
    });
    const eventDaysMap = computed(() => {
      const map = {};
      if (props4.events === void 0) {
        for (let i = 1; i <= daysInMonth2.value; i++) {
          map[i] = false;
        }
      } else {
        const fn = typeof props4.events === "function" ? props4.events : (date) => props4.events.includes(date);
        for (let i = 1; i <= daysInMonth2.value; i++) {
          const dayHash = viewMonthHash.value + "/" + pad(i);
          map[i] = fn(dayHash) === true && evtColor.value(dayHash);
        }
      }
      return map;
    });
    const viewDays = computed(() => {
      let date, endDay;
      const { year: year2, month } = viewModel.value;
      if (props4.calendar !== "persian") {
        date = new Date(year2, month - 1, 1);
        endDay = new Date(year2, month - 1, 0).getDate();
      } else {
        const gDate = toGregorian(year2, month, 1);
        date = new Date(gDate.gy, gDate.gm - 1, gDate.gd);
        let prevJM = month - 1;
        let prevJY = year2;
        if (prevJM === 0) {
          prevJM = 12;
          prevJY--;
        }
        endDay = jalaaliMonthLength(prevJY, prevJM);
      }
      return {
        days: date.getDay() - computedFirstDayOfWeek.value - 1,
        endDay
      };
    });
    const days = computed(() => {
      const res = [];
      const { days: days2, endDay } = viewDays.value;
      const len = days2 < 0 ? days2 + 7 : days2;
      if (len < 6) {
        for (let i = endDay - len; i <= endDay; i++) {
          res.push({ i, fill: true });
        }
      }
      const index = res.length;
      for (let i = 1; i <= daysInMonth2.value; i++) {
        const day = { i, event: eventDaysMap.value[i], classes: [] };
        if (selectionDaysMap.value[i] === true) {
          day.in = true;
          day.flat = true;
        }
        res.push(day);
      }
      if (daysMap.value[viewMonthHash.value] !== void 0) {
        daysMap.value[viewMonthHash.value].forEach((day) => {
          const i = index + day - 1;
          Object.assign(res[i], {
            selected: true,
            unelevated: true,
            flat: false,
            color: computedColor.value,
            textColor: computedTextColor.value
          });
        });
      }
      if (rangeMap.value[viewMonthHash.value] !== void 0) {
        rangeMap.value[viewMonthHash.value].forEach((entry) => {
          if (entry.from !== void 0) {
            const from = index + entry.from - 1;
            const to = index + (entry.to || daysInMonth2.value) - 1;
            for (let day = from; day <= to; day++) {
              Object.assign(res[day], {
                range: entry.range,
                unelevated: true,
                color: computedColor.value,
                textColor: computedTextColor.value
              });
            }
            Object.assign(res[from], {
              rangeFrom: true,
              flat: false
            });
            entry.to !== void 0 && Object.assign(res[to], {
              rangeTo: true,
              flat: false
            });
          } else if (entry.to !== void 0) {
            const to = index + entry.to - 1;
            for (let day = index; day <= to; day++) {
              Object.assign(res[day], {
                range: entry.range,
                unelevated: true,
                color: computedColor.value,
                textColor: computedTextColor.value
              });
            }
            Object.assign(res[to], {
              flat: false,
              rangeTo: true
            });
          } else {
            const to = index + daysInMonth2.value - 1;
            for (let day = index; day <= to; day++) {
              Object.assign(res[day], {
                range: entry.range,
                unelevated: true,
                color: computedColor.value,
                textColor: computedTextColor.value
              });
            }
          }
        });
      }
      if (rangeView.value !== void 0) {
        const from = index + rangeView.value.from - 1;
        const to = index + rangeView.value.to - 1;
        for (let day = from; day <= to; day++) {
          res[day].color = computedColor.value;
          res[day].editRange = true;
        }
        if (rangeView.value.includeFrom === true) {
          res[from].editRangeFrom = true;
        }
        if (rangeView.value.includeTo === true) {
          res[to].editRangeTo = true;
        }
      }
      if (viewModel.value.year === today.value.year && viewModel.value.month === today.value.month) {
        res[index + today.value.day - 1].today = true;
      }
      const left = res.length % 7;
      if (left > 0) {
        const afterDays = 7 - left;
        for (let i = 1; i <= afterDays; i++) {
          res.push({ i, fill: true });
        }
      }
      res.forEach((day) => {
        let cls = "q-date__calendar-item ";
        if (day.fill === true) {
          cls += "q-date__calendar-item--fill";
        } else {
          cls += `q-date__calendar-item--${day.in === true ? "in" : "out"}`;
          if (day.range !== void 0) {
            cls += ` q-date__range${day.rangeTo === true ? "-to" : day.rangeFrom === true ? "-from" : ""}`;
          }
          if (day.editRange === true) {
            cls += ` q-date__edit-range${day.editRangeFrom === true ? "-from" : ""}${day.editRangeTo === true ? "-to" : ""}`;
          }
          if (day.range !== void 0 || day.editRange === true) {
            cls += ` text-${day.color}`;
          }
        }
        day.classes = cls;
      });
      return res;
    });
    const attributes = computed(() => props4.disable === true ? { "aria-disabled": "true" } : {});
    watch(() => props4.modelValue, (v2) => {
      if (lastEmitValue === v2) {
        lastEmitValue = 0;
      } else {
        const model = getViewModel(innerMask.value, innerLocale.value);
        updateViewModel(model.year, model.month, model);
      }
    });
    watch(view, () => {
      if (blurTargetRef.value !== null && proxy.$el.contains(document.activeElement) === true) {
        blurTargetRef.value.focus();
      }
    });
    watch(() => viewModel.value.year + "|" + viewModel.value.month, () => {
      emit2("navigation", { year: viewModel.value.year, month: viewModel.value.month });
    });
    watch(mask, (val) => {
      updateValue2(val, innerLocale.value, "mask");
      innerMask.value = val;
    });
    watch(locale, (val) => {
      updateValue2(innerMask.value, val, "locale");
      innerLocale.value = val;
    });
    function setToday() {
      const { year: year2, month, day } = today.value;
      const date = {
        // contains more props than needed (hour, minute, second, millisecond)
        // but those aren't used in the processing of this "date" variable
        ...viewModel.value,
        // overwriting with today's date
        year: year2,
        month,
        day
      };
      const monthMap = daysMap.value[getMonthHash(date)];
      if (monthMap === void 0 || monthMap.includes(date.day) === false) {
        addToModel(date);
      }
      setCalendarTo(date.year, date.month);
    }
    function setView(viewMode) {
      if (viewIsValid(viewMode) === true) {
        view.value = viewMode;
      }
    }
    function offsetCalendar(type, descending) {
      if (["month", "year"].includes(type)) {
        const fn = type === "month" ? goToMonth : goToYear;
        fn(descending === true ? -1 : 1);
      }
    }
    function setCalendarTo(year2, month) {
      view.value = "Calendar";
      updateViewModel(year2, month);
    }
    function setEditingRange(from, to) {
      if (props4.range === false || !from) {
        editRange.value = null;
        return;
      }
      const init2 = Object.assign({ ...viewModel.value }, from);
      const final = to !== void 0 ? Object.assign({ ...viewModel.value }, to) : init2;
      editRange.value = {
        init: init2,
        initHash: getDayHash(init2),
        final,
        finalHash: getDayHash(final)
      };
      setCalendarTo(init2.year, init2.month);
    }
    function getMask() {
      return props4.calendar === "persian" ? "YYYY/MM/DD" : props4.mask;
    }
    function decodeString(date, mask2, locale2) {
      return __splitDate(
        date,
        mask2,
        locale2,
        props4.calendar,
        {
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0
        }
      );
    }
    function getViewModel(mask2, locale2) {
      const model = Array.isArray(props4.modelValue) === true ? props4.modelValue : props4.modelValue ? [props4.modelValue] : [];
      if (model.length === 0) {
        return getDefaultViewModel();
      }
      const target2 = model[model.length - 1];
      const decoded = decodeString(
        target2.from !== void 0 ? target2.from : target2,
        mask2,
        locale2
      );
      return decoded.dateHash === null ? getDefaultViewModel() : decoded;
    }
    function getDefaultViewModel() {
      let year2, month;
      if (props4.defaultYearMonth !== void 0) {
        const d = props4.defaultYearMonth.split("/");
        year2 = parseInt(d[0], 10);
        month = parseInt(d[1], 10);
      } else {
        const d = today.value !== void 0 ? today.value : getCurrentDate();
        year2 = d.year;
        month = d.month;
      }
      return {
        year: year2,
        month,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        dateHash: year2 + "/" + pad(month) + "/01"
      };
    }
    function goToMonth(offset2) {
      let year2 = viewModel.value.year;
      let month = Number(viewModel.value.month) + offset2;
      if (month === 13) {
        month = 1;
        year2++;
      } else if (month === 0) {
        month = 12;
        year2--;
      }
      updateViewModel(year2, month);
      isImmediate.value === true && emitImmediately("month");
    }
    function goToYear(offset2) {
      const year2 = Number(viewModel.value.year) + offset2;
      updateViewModel(year2, viewModel.value.month);
      isImmediate.value === true && emitImmediately("year");
    }
    function setYear(year2) {
      updateViewModel(year2, viewModel.value.month);
      view.value = props4.defaultView === "Years" ? "Months" : "Calendar";
      isImmediate.value === true && emitImmediately("year");
    }
    function setMonth(month) {
      updateViewModel(viewModel.value.year, month);
      view.value = "Calendar";
      isImmediate.value === true && emitImmediately("month");
    }
    function toggleDate(date, monthHash) {
      const month = daysMap.value[monthHash];
      const fn = month !== void 0 && month.includes(date.day) === true ? removeFromModel : addToModel;
      fn(date);
    }
    function getShortDate(date) {
      return { year: date.year, month: date.month, day: date.day };
    }
    function updateViewModel(year2, month, time) {
      if (minNav.value !== null && year2 <= minNav.value.year) {
        if (month < minNav.value.month || year2 < minNav.value.year) {
          month = minNav.value.month;
        }
        year2 = minNav.value.year;
      }
      if (maxNav.value !== null && year2 >= maxNav.value.year) {
        if (month > maxNav.value.month || year2 > maxNav.value.year) {
          month = maxNav.value.month;
        }
        year2 = maxNav.value.year;
      }
      if (time !== void 0) {
        const { hour, minute, second, millisecond, timezoneOffset, timeHash } = time;
        Object.assign(viewModel.value, { hour, minute, second, millisecond, timezoneOffset, timeHash });
      }
      const newHash = year2 + "/" + pad(month) + "/01";
      if (newHash !== viewModel.value.dateHash) {
        monthDirection.value = viewModel.value.dateHash < newHash === ($q.lang.rtl !== true) ? "left" : "right";
        if (year2 !== viewModel.value.year) {
          yearDirection.value = monthDirection.value;
        }
        nextTick(() => {
          startYear.value = year2 - year2 % yearsInterval - (year2 < 0 ? yearsInterval : 0);
          Object.assign(viewModel.value, {
            year: year2,
            month,
            day: 1,
            dateHash: newHash
          });
        });
      }
    }
    function emitValue(val, action, date) {
      const value2 = val !== null && val.length === 1 && props4.multiple === false ? val[0] : val;
      lastEmitValue = value2;
      const { reason, details } = getEmitParams(action, date);
      emit2("update:modelValue", value2, reason, details);
    }
    function emitImmediately(reason) {
      const date = daysModel.value[0] !== void 0 && daysModel.value[0].dateHash !== null ? { ...daysModel.value[0] } : { ...viewModel.value };
      nextTick(() => {
        date.year = viewModel.value.year;
        date.month = viewModel.value.month;
        const maxDay = props4.calendar !== "persian" ? new Date(date.year, date.month, 0).getDate() : jalaaliMonthLength(date.year, date.month);
        date.day = Math.min(Math.max(1, date.day), maxDay);
        const value2 = encodeEntry(date);
        lastEmitValue = value2;
        const { details } = getEmitParams("", date);
        emit2("update:modelValue", value2, reason, details);
      });
    }
    function getEmitParams(action, date) {
      return date.from !== void 0 ? {
        reason: `${action}-range`,
        details: {
          ...getShortDate(date.target),
          from: getShortDate(date.from),
          to: getShortDate(date.to)
        }
      } : {
        reason: `${action}-day`,
        details: getShortDate(date)
      };
    }
    function encodeEntry(date, mask2, locale2) {
      return date.from !== void 0 ? { from: encodeObjectFn.value(date.from, mask2, locale2), to: encodeObjectFn.value(date.to, mask2, locale2) } : encodeObjectFn.value(date, mask2, locale2);
    }
    function addToModel(date) {
      let value2;
      if (props4.multiple === true) {
        if (date.from !== void 0) {
          const fromHash = getDayHash(date.from);
          const toHash = getDayHash(date.to);
          const days2 = daysModel.value.filter((day) => day.dateHash < fromHash || day.dateHash > toHash);
          const ranges = rangeModel.value.filter(({ from, to }) => to.dateHash < fromHash || from.dateHash > toHash);
          value2 = days2.concat(ranges).concat(date).map((entry) => encodeEntry(entry));
        } else {
          const model = normalizedModel.value.slice();
          model.push(encodeEntry(date));
          value2 = model;
        }
      } else {
        value2 = encodeEntry(date);
      }
      emitValue(value2, "add", date);
    }
    function removeFromModel(date) {
      if (props4.noUnset === true) {
        return;
      }
      let model = null;
      if (props4.multiple === true && Array.isArray(props4.modelValue) === true) {
        const val = encodeEntry(date);
        if (date.from !== void 0) {
          model = props4.modelValue.filter(
            (date2) => date2.from !== void 0 ? date2.from !== val.from && date2.to !== val.to : true
          );
        } else {
          model = props4.modelValue.filter((date2) => date2 !== val);
        }
        if (model.length === 0) {
          model = null;
        }
      }
      emitValue(model, "remove", date);
    }
    function updateValue2(mask2, locale2, reason) {
      const model = daysModel.value.concat(rangeModel.value).map((entry) => encodeEntry(entry, mask2, locale2)).filter((entry) => {
        return entry.from !== void 0 ? entry.from.dateHash !== null && entry.to.dateHash !== null : entry.dateHash !== null;
      });
      emit2("update:modelValue", (props4.multiple === true ? model : model[0]) || null, reason);
    }
    function getHeader() {
      if (props4.minimal === true) return;
      return h("div", {
        class: "q-date__header " + headerClass.value
      }, [
        h("div", {
          class: "relative-position"
        }, [
          h(Transition, {
            name: "q-transition--fade"
          }, () => h("div", {
            key: "h-yr-" + headerSubtitle.value,
            class: "q-date__header-subtitle q-date__header-link " + (view.value === "Years" ? "q-date__header-link--active" : "cursor-pointer"),
            tabindex: tabindex.value,
            ...getCache("vY", {
              onClick() {
                view.value = "Years";
              },
              onKeyup(e) {
                e.keyCode === 13 && (view.value = "Years");
              }
            })
          }, [headerSubtitle.value]))
        ]),
        h("div", {
          class: "q-date__header-title relative-position flex no-wrap"
        }, [
          h("div", {
            class: "relative-position col"
          }, [
            h(Transition, {
              name: "q-transition--fade"
            }, () => h("div", {
              key: "h-sub" + headerTitle.value,
              class: "q-date__header-title-label q-date__header-link " + (view.value === "Calendar" ? "q-date__header-link--active" : "cursor-pointer"),
              tabindex: tabindex.value,
              ...getCache("vC", {
                onClick() {
                  view.value = "Calendar";
                },
                onKeyup(e) {
                  e.keyCode === 13 && (view.value = "Calendar");
                }
              })
            }, [headerTitle.value]))
          ]),
          props4.todayBtn === true ? h(QBtn_default, {
            class: "q-date__header-today self-start",
            icon: $q.iconSet.datetime.today,
            flat: true,
            size: "sm",
            round: true,
            tabindex: tabindex.value,
            onClick: setToday
          }) : null
        ])
      ]);
    }
    function getNavigation({ label: label2, type, key, dir, goTo, boundaries, cls }) {
      return [
        h("div", {
          class: "row items-center q-date__arrow"
        }, [
          h(QBtn_default, {
            round: true,
            dense: true,
            size: "sm",
            flat: true,
            icon: dateArrow.value[0],
            tabindex: tabindex.value,
            disable: boundaries.prev === false,
            ...getCache("go-#" + type, { onClick() {
              goTo(-1);
            } })
          })
        ]),
        h("div", {
          class: "relative-position overflow-hidden flex flex-center" + cls
        }, [
          h(Transition, {
            name: "q-transition--jump-" + dir
          }, () => h("div", { key }, [
            h(QBtn_default, {
              flat: true,
              dense: true,
              noCaps: true,
              label: label2,
              tabindex: tabindex.value,
              ...getCache("view#" + type, { onClick: () => {
                view.value = type;
              } })
            })
          ]))
        ]),
        h("div", {
          class: "row items-center q-date__arrow"
        }, [
          h(QBtn_default, {
            round: true,
            dense: true,
            size: "sm",
            flat: true,
            icon: dateArrow.value[1],
            tabindex: tabindex.value,
            disable: boundaries.next === false,
            ...getCache("go+#" + type, { onClick() {
              goTo(1);
            } })
          })
        ])
      ];
    }
    const renderViews = {
      Calendar: () => [
        h("div", {
          key: "calendar-view",
          class: "q-date__view q-date__calendar"
        }, [
          h("div", {
            class: "q-date__navigation row items-center no-wrap"
          }, getNavigation({
            label: innerLocale.value.months[viewModel.value.month - 1],
            type: "Months",
            key: viewModel.value.month,
            dir: monthDirection.value,
            goTo: goToMonth,
            boundaries: navBoundaries.value.month,
            cls: " col"
          }).concat(getNavigation({
            label: viewModel.value.year,
            type: "Years",
            key: viewModel.value.year,
            dir: yearDirection.value,
            goTo: goToYear,
            boundaries: navBoundaries.value.year,
            cls: ""
          }))),
          h("div", {
            class: "q-date__calendar-weekdays row items-center no-wrap"
          }, daysOfWeek.value.map((day) => h("div", { class: "q-date__calendar-item" }, [h("div", day)]))),
          h("div", {
            class: "q-date__calendar-days-container relative-position overflow-hidden"
          }, [
            h(Transition, {
              name: "q-transition--slide-" + monthDirection.value
            }, () => h("div", {
              key: viewMonthHash.value,
              class: "q-date__calendar-days fit"
            }, days.value.map((day) => h("div", { class: day.classes }, [
              day.in === true ? h(
                QBtn_default,
                {
                  class: day.today === true ? "q-date__today" : "",
                  dense: true,
                  flat: day.flat,
                  unelevated: day.unelevated,
                  color: day.color,
                  textColor: day.textColor,
                  label: day.i,
                  tabindex: tabindex.value,
                  ...getCache("day#" + day.i, {
                    onClick: () => {
                      onDayClick(day.i);
                    },
                    onMouseover: () => {
                      onDayMouseover(day.i);
                    }
                  })
                },
                day.event !== false ? () => h("div", { class: "q-date__event bg-" + day.event }) : null
              ) : h("div", "" + day.i)
            ]))))
          ])
        ])
      ],
      Months() {
        const currentYear = viewModel.value.year === today.value.year;
        const isDisabled = (month) => {
          return minNav.value !== null && viewModel.value.year === minNav.value.year && minNav.value.month > month || maxNav.value !== null && viewModel.value.year === maxNav.value.year && maxNav.value.month < month;
        };
        const content = innerLocale.value.monthsShort.map((month, i) => {
          const active = viewModel.value.month === i + 1;
          return h("div", {
            class: "q-date__months-item flex flex-center"
          }, [
            h(QBtn_default, {
              class: currentYear === true && today.value.month === i + 1 ? "q-date__today" : null,
              flat: active !== true,
              label: month,
              unelevated: active,
              color: active === true ? computedColor.value : null,
              textColor: active === true ? computedTextColor.value : null,
              tabindex: tabindex.value,
              disable: isDisabled(i + 1),
              ...getCache("month#" + i, { onClick: () => {
                setMonth(i + 1);
              } })
            })
          ]);
        });
        props4.yearsInMonthView === true && content.unshift(
          h("div", { class: "row no-wrap full-width" }, [
            getNavigation({
              label: viewModel.value.year,
              type: "Years",
              key: viewModel.value.year,
              dir: yearDirection.value,
              goTo: goToYear,
              boundaries: navBoundaries.value.year,
              cls: " col"
            })
          ])
        );
        return h("div", {
          key: "months-view",
          class: "q-date__view q-date__months flex flex-center"
        }, content);
      },
      Years() {
        const start = startYear.value, stop2 = start + yearsInterval, years = [];
        const isDisabled = (year2) => {
          return minNav.value !== null && minNav.value.year > year2 || maxNav.value !== null && maxNav.value.year < year2;
        };
        for (let i = start; i <= stop2; i++) {
          const active = viewModel.value.year === i;
          years.push(
            h("div", {
              class: "q-date__years-item flex flex-center"
            }, [
              h(QBtn_default, {
                key: "yr" + i,
                class: today.value.year === i ? "q-date__today" : null,
                flat: !active,
                label: i,
                dense: true,
                unelevated: active,
                color: active === true ? computedColor.value : null,
                textColor: active === true ? computedTextColor.value : null,
                tabindex: tabindex.value,
                disable: isDisabled(i),
                ...getCache("yr#" + i, { onClick: () => {
                  setYear(i);
                } })
              })
            ])
          );
        }
        return h("div", {
          class: "q-date__view q-date__years flex flex-center"
        }, [
          h("div", {
            class: "col-auto"
          }, [
            h(QBtn_default, {
              round: true,
              dense: true,
              flat: true,
              icon: dateArrow.value[0],
              tabindex: tabindex.value,
              disable: isDisabled(start),
              ...getCache("y-", { onClick: () => {
                startYear.value -= yearsInterval;
              } })
            })
          ]),
          h("div", {
            class: "q-date__years-content col self-stretch row items-center"
          }, years),
          h("div", {
            class: "col-auto"
          }, [
            h(QBtn_default, {
              round: true,
              dense: true,
              flat: true,
              icon: dateArrow.value[1],
              tabindex: tabindex.value,
              disable: isDisabled(stop2),
              ...getCache("y+", { onClick: () => {
                startYear.value += yearsInterval;
              } })
            })
          ])
        ]);
      }
    };
    function onDayClick(dayIndex) {
      const day = { ...viewModel.value, day: dayIndex };
      if (props4.range === false) {
        toggleDate(day, viewMonthHash.value);
        return;
      }
      if (editRange.value === null) {
        const dayProps = days.value.find((day2) => day2.fill !== true && day2.i === dayIndex);
        if (props4.noUnset !== true && dayProps.range !== void 0) {
          removeFromModel({ target: day, from: dayProps.range.from, to: dayProps.range.to });
          return;
        }
        if (dayProps.selected === true) {
          removeFromModel(day);
          return;
        }
        const initHash = getDayHash(day);
        editRange.value = {
          init: day,
          initHash,
          final: day,
          finalHash: initHash
        };
        emit2("rangeStart", getShortDate(day));
      } else {
        const initHash = editRange.value.initHash, finalHash = getDayHash(day), payload = initHash <= finalHash ? { from: editRange.value.init, to: day } : { from: day, to: editRange.value.init };
        editRange.value = null;
        addToModel(initHash === finalHash ? day : { target: day, ...payload });
        emit2("rangeEnd", {
          from: getShortDate(payload.from),
          to: getShortDate(payload.to)
        });
      }
    }
    function onDayMouseover(dayIndex) {
      if (editRange.value !== null) {
        const final = { ...viewModel.value, day: dayIndex };
        Object.assign(editRange.value, {
          final,
          finalHash: getDayHash(final)
        });
      }
    }
    Object.assign(proxy, {
      setToday,
      setView,
      offsetCalendar,
      setCalendarTo,
      setEditingRange
    });
    return () => {
      const content = [
        h("div", {
          class: "q-date__content col relative-position"
        }, [
          h(Transition, {
            name: "q-transition--fade"
          }, renderViews[view.value])
        ])
      ];
      const def2 = hSlot(slots.default);
      def2 !== void 0 && content.push(
        h("div", { class: "q-date__actions" }, def2)
      );
      if (props4.name !== void 0 && props4.disable !== true) {
        injectFormInput(content, "push");
      }
      return h("div", {
        class: classes.value,
        ...attributes.value
      }, [
        getHeader(),
        h("div", {
          ref: blurTargetRef,
          class: "q-date__main col column",
          tabindex: -1
        }, content)
      ]);
    };
  }
});
function use_history_default(showing, hide, hideOnRouteChange) {
  function removeFromHistory() {
  }
  onBeforeUnmount(() => {
    showing.value === true && removeFromHistory();
  });
  return {
    removeFromHistory,
    addToHistory() {
    }
  };
}
var registered = 0;
var scrollPositionX;
var scrollPositionY;
var maxScrollTop;
var vpPendingUpdate = false;
var bodyLeft;
var bodyTop;
var href;
var closeTimer = null;
function onWheel(e) {
  if (shouldPreventScroll(e)) {
    stopAndPrevent(e);
  }
}
function shouldPreventScroll(e) {
  if (e.target === document.body || e.target.classList.contains("q-layout__backdrop")) {
    return true;
  }
  const path = getEventPath(e), shift = e.shiftKey && !e.deltaX, scrollY = !shift && Math.abs(e.deltaX) <= Math.abs(e.deltaY), delta = shift || scrollY ? e.deltaY : e.deltaX;
  for (let index = 0; index < path.length; index++) {
    const el = path[index];
    if (hasScrollbar(el, scrollY)) {
      return scrollY ? delta < 0 && el.scrollTop === 0 ? true : delta > 0 && el.scrollTop + el.clientHeight === el.scrollHeight : delta < 0 && el.scrollLeft === 0 ? true : delta > 0 && el.scrollLeft + el.clientWidth === el.scrollWidth;
    }
  }
  return true;
}
function onAppleScroll(e) {
  if (e.target === document) {
    document.scrollingElement.scrollTop = document.scrollingElement.scrollTop;
  }
}
function onAppleResize(evt) {
  if (vpPendingUpdate === true) {
    return;
  }
  vpPendingUpdate = true;
  requestAnimationFrame(() => {
    vpPendingUpdate = false;
    const { height: height2 } = evt.target, { clientHeight, scrollTop } = document.scrollingElement;
    if (maxScrollTop === void 0 || height2 !== window.innerHeight) {
      maxScrollTop = clientHeight - height2;
      document.scrollingElement.scrollTop = scrollTop;
    }
    if (scrollTop > maxScrollTop) {
      document.scrollingElement.scrollTop -= Math.ceil((scrollTop - maxScrollTop) / 8);
    }
  });
}
function apply(action) {
  const body = document.body, hasViewport = window.visualViewport !== void 0;
  if (action === "add") {
    const { overflowY, overflowX } = window.getComputedStyle(body);
    scrollPositionX = getHorizontalScrollPosition(window);
    scrollPositionY = getVerticalScrollPosition(window);
    bodyLeft = body.style.left;
    bodyTop = body.style.top;
    href = window.location.href;
    body.style.left = `-${scrollPositionX}px`;
    body.style.top = `-${scrollPositionY}px`;
    if (overflowX !== "hidden" && (overflowX === "scroll" || body.scrollWidth > window.innerWidth)) {
      body.classList.add("q-body--force-scrollbar-x");
    }
    if (overflowY !== "hidden" && (overflowY === "scroll" || body.scrollHeight > window.innerHeight)) {
      body.classList.add("q-body--force-scrollbar-y");
    }
    body.classList.add("q-body--prevent-scroll");
    document.qScrollPrevented = true;
    if (client.is.ios === true) {
      if (hasViewport === true) {
        window.scrollTo(0, 0);
        window.visualViewport.addEventListener("resize", onAppleResize, listenOpts.passiveCapture);
        window.visualViewport.addEventListener("scroll", onAppleResize, listenOpts.passiveCapture);
        window.scrollTo(0, 0);
      } else {
        window.addEventListener("scroll", onAppleScroll, listenOpts.passiveCapture);
      }
    }
  }
  if (client.is.desktop === true && client.is.mac === true) {
    window[`${action}EventListener`]("wheel", onWheel, listenOpts.notPassive);
  }
  if (action === "remove") {
    if (client.is.ios === true) {
      if (hasViewport === true) {
        window.visualViewport.removeEventListener("resize", onAppleResize, listenOpts.passiveCapture);
        window.visualViewport.removeEventListener("scroll", onAppleResize, listenOpts.passiveCapture);
      } else {
        window.removeEventListener("scroll", onAppleScroll, listenOpts.passiveCapture);
      }
    }
    body.classList.remove("q-body--prevent-scroll");
    body.classList.remove("q-body--force-scrollbar-x");
    body.classList.remove("q-body--force-scrollbar-y");
    document.qScrollPrevented = false;
    body.style.left = bodyLeft;
    body.style.top = bodyTop;
    if (window.location.href === href) {
      window.scrollTo(scrollPositionX, scrollPositionY);
    }
    maxScrollTop = void 0;
  }
}
function prevent_scroll_default(state) {
  let action = "add";
  if (state === true) {
    registered++;
    if (closeTimer !== null) {
      clearTimeout(closeTimer);
      closeTimer = null;
      return;
    }
    if (registered > 1) {
      return;
    }
  } else {
    if (registered === 0) {
      return;
    }
    registered--;
    if (registered > 0) {
      return;
    }
    action = "remove";
    if (client.is.ios === true && client.is.nativeMobile === true) {
      closeTimer !== null && clearTimeout(closeTimer);
      closeTimer = setTimeout(() => {
        apply(action);
        closeTimer = null;
      }, 100);
      return;
    }
  }
  apply(action);
}
function use_prevent_scroll_default() {
  let currentState;
  return {
    preventBodyScroll(state) {
      if (state !== currentState && (currentState !== void 0 || state === true)) {
        currentState = state;
        prevent_scroll_default(state);
      }
    }
  };
}
var maximizedModals = 0;
var positionClass = {
  standard: "fixed-full flex-center",
  top: "fixed-top justify-center",
  bottom: "fixed-bottom justify-center",
  right: "fixed-right items-center",
  left: "fixed-left items-center"
};
var defaultTransitions = {
  standard: ["scale", "scale"],
  top: ["slide-down", "slide-up"],
  bottom: ["slide-up", "slide-down"],
  right: ["slide-left", "slide-right"],
  left: ["slide-right", "slide-left"]
};
var QDialog_default = createComponent({
  name: "QDialog",
  inheritAttrs: false,
  props: {
    ...useModelToggleProps,
    ...useTransitionProps,
    transitionShow: String,
    // override useTransitionProps
    transitionHide: String,
    // override useTransitionProps
    persistent: Boolean,
    autoClose: Boolean,
    allowFocusOutside: Boolean,
    noEscDismiss: Boolean,
    noBackdropDismiss: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    noShake: Boolean,
    seamless: Boolean,
    maximized: Boolean,
    fullWidth: Boolean,
    fullHeight: Boolean,
    square: Boolean,
    backdropFilter: String,
    position: {
      type: String,
      default: "standard",
      validator: (val) => ["standard", "top", "bottom", "left", "right"].includes(val)
    }
  },
  emits: [
    ...useModelToggleEmits,
    "shake",
    "click",
    "escapeKey"
  ],
  setup(props4, { slots, emit: emit2, attrs }) {
    const vm2 = getCurrentInstance();
    const innerRef = ref(null);
    const showing = ref(false);
    const animating = ref(false);
    let shakeTimeout = null, refocusTarget = null, isMaximized, avoidAutoClose;
    const hideOnRouteChange = computed(
      () => props4.persistent !== true && props4.noRouteDismiss !== true && props4.seamless !== true
    );
    const { preventBodyScroll } = use_prevent_scroll_default();
    const { registerTimeout } = use_timeout_default();
    const { registerTick, removeTick } = use_tick_default();
    const { transitionProps, transitionStyle } = use_transition_default(
      props4,
      () => defaultTransitions[props4.position][0],
      () => defaultTransitions[props4.position][1]
    );
    const backdropStyle = computed(() => transitionStyle.value + (props4.backdropFilter !== void 0 ? `;backdrop-filter:${props4.backdropFilter};-webkit-backdrop-filter:${props4.backdropFilter}` : ""));
    const { showPortal, hidePortal, portalIsAccessible, renderPortal } = use_portal_default(
      vm2,
      innerRef,
      renderPortalContent,
      "dialog"
    );
    const { hide } = use_model_toggle_default({
      showing,
      hideOnRouteChange,
      handleShow,
      handleHide,
      processOnMount: true
    });
    const { addToHistory, removeFromHistory } = use_history_default(showing);
    const classes = computed(
      () => `q-dialog__inner flex no-pointer-events q-dialog__inner--${props4.maximized === true ? "maximized" : "minimized"} q-dialog__inner--${props4.position} ${positionClass[props4.position]}` + (animating.value === true ? " q-dialog__inner--animating" : "") + (props4.fullWidth === true ? " q-dialog__inner--fullwidth" : "") + (props4.fullHeight === true ? " q-dialog__inner--fullheight" : "") + (props4.square === true ? " q-dialog__inner--square" : "")
    );
    const useBackdrop = computed(() => showing.value === true && props4.seamless !== true);
    const onEvents = computed(() => props4.autoClose === true ? { onClick: onAutoClose } : {});
    const rootClasses = computed(() => [
      `q-dialog fullscreen no-pointer-events q-dialog--${useBackdrop.value === true ? "modal" : "seamless"}`,
      attrs.class
    ]);
    watch(() => props4.maximized, (state) => {
      showing.value === true && updateMaximized(state);
    });
    watch(useBackdrop, (val) => {
      preventBodyScroll(val);
      if (val === true) {
        addFocusout(onFocusChange);
        addEscapeKey(onEscapeKey);
      } else {
        removeFocusout(onFocusChange);
        removeEscapeKey(onEscapeKey);
      }
    });
    function handleShow(evt) {
      addToHistory();
      refocusTarget = props4.noRefocus === false && document.activeElement !== null ? document.activeElement : null;
      updateMaximized(props4.maximized);
      showPortal();
      animating.value = true;
      if (props4.noFocus !== true) {
        document.activeElement !== null && document.activeElement.blur();
        registerTick(focus);
      } else {
        removeTick();
      }
      registerTimeout(() => {
        if (vm2.proxy.$q.platform.is.ios === true) {
          if (props4.seamless !== true && document.activeElement) {
            const { top, bottom } = document.activeElement.getBoundingClientRect(), { innerHeight } = window, height2 = window.visualViewport !== void 0 ? window.visualViewport.height : innerHeight;
            if (top > 0 && bottom > height2 / 2) {
              document.scrollingElement.scrollTop = Math.min(
                document.scrollingElement.scrollHeight - height2,
                bottom >= innerHeight ? Infinity : Math.ceil(document.scrollingElement.scrollTop + bottom - height2 / 2)
              );
            }
            document.activeElement.scrollIntoView();
          }
          avoidAutoClose = true;
          innerRef.value.click();
          avoidAutoClose = false;
        }
        showPortal(true);
        animating.value = false;
        emit2("show", evt);
      }, props4.transitionDuration);
    }
    function handleHide(evt) {
      removeTick();
      removeFromHistory();
      cleanup(true);
      animating.value = true;
      hidePortal();
      if (refocusTarget !== null) {
        ((evt && evt.type.indexOf("key") === 0 ? refocusTarget.closest('[tabindex]:not([tabindex^="-"])') : void 0) || refocusTarget).focus();
        refocusTarget = null;
      }
      registerTimeout(() => {
        hidePortal(true);
        animating.value = false;
        emit2("hide", evt);
      }, props4.transitionDuration);
    }
    function focus(selector) {
      addFocusFn(() => {
        let node = innerRef.value;
        if (node === null) return;
        if (selector !== void 0) {
          const target2 = node.querySelector(selector);
          if (target2 !== null) {
            target2.focus({ preventScroll: true });
            return;
          }
        }
        if (node.contains(document.activeElement) !== true) {
          node = node.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || node.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || node.querySelector("[autofocus], [data-autofocus]") || node;
          node.focus({ preventScroll: true });
        }
      });
    }
    function shake(focusTarget) {
      if (focusTarget && typeof focusTarget.focus === "function") {
        focusTarget.focus({ preventScroll: true });
      } else {
        focus();
      }
      emit2("shake");
      const node = innerRef.value;
      if (node !== null) {
        node.classList.remove("q-animate--scale");
        node.classList.add("q-animate--scale");
        shakeTimeout !== null && clearTimeout(shakeTimeout);
        shakeTimeout = setTimeout(() => {
          shakeTimeout = null;
          if (innerRef.value !== null) {
            node.classList.remove("q-animate--scale");
            focus();
          }
        }, 170);
      }
    }
    function onEscapeKey() {
      if (props4.seamless !== true) {
        if (props4.persistent === true || props4.noEscDismiss === true) {
          props4.maximized !== true && props4.noShake !== true && shake();
        } else {
          emit2("escapeKey");
          hide();
        }
      }
    }
    function cleanup(hiding) {
      if (shakeTimeout !== null) {
        clearTimeout(shakeTimeout);
        shakeTimeout = null;
      }
      if (hiding === true || showing.value === true) {
        updateMaximized(false);
        if (props4.seamless !== true) {
          preventBodyScroll(false);
          removeFocusout(onFocusChange);
          removeEscapeKey(onEscapeKey);
        }
      }
      if (hiding !== true) {
        refocusTarget = null;
      }
    }
    function updateMaximized(active) {
      if (active === true) {
        if (isMaximized !== true) {
          maximizedModals < 1 && document.body.classList.add("q-body--dialog");
          maximizedModals++;
          isMaximized = true;
        }
      } else if (isMaximized === true) {
        if (maximizedModals < 2) {
          document.body.classList.remove("q-body--dialog");
        }
        maximizedModals--;
        isMaximized = false;
      }
    }
    function onAutoClose(e) {
      if (avoidAutoClose !== true) {
        hide(e);
        emit2("click", e);
      }
    }
    function onBackdropClick(e) {
      if (props4.persistent !== true && props4.noBackdropDismiss !== true) {
        hide(e);
      } else if (props4.noShake !== true) {
        shake();
      }
    }
    function onFocusChange(evt) {
      if (props4.allowFocusOutside !== true && portalIsAccessible.value === true && childHasFocus(innerRef.value, evt.target) !== true) {
        focus('[tabindex]:not([tabindex="-1"])');
      }
    }
    Object.assign(vm2.proxy, {
      // expose public methods
      focus,
      shake,
      // private but needed by QSelect
      __updateRefocusTarget(target2) {
        refocusTarget = target2 || null;
      }
    });
    onBeforeUnmount(cleanup);
    function renderPortalContent() {
      return h("div", {
        role: "dialog",
        "aria-modal": useBackdrop.value === true ? "true" : "false",
        ...attrs,
        class: rootClasses.value
      }, [
        h(Transition, {
          name: "q-transition--fade",
          appear: true
        }, () => useBackdrop.value === true ? h("div", {
          class: "q-dialog__backdrop fixed-full",
          style: backdropStyle.value,
          "aria-hidden": "true",
          tabindex: -1,
          onClick: onBackdropClick
        }) : null),
        h(
          Transition,
          transitionProps.value,
          () => showing.value === true ? h("div", {
            ref: innerRef,
            class: classes.value,
            style: transitionStyle.value,
            tabindex: -1,
            ...onEvents.value
          }, hSlot(slots.default)) : null
        )
      ]);
    }
    return renderPortal;
  }
});
var duration = 150;
createComponent({
  name: "QDrawer",
  inheritAttrs: false,
  props: {
    ...useModelToggleProps,
    ...useDarkProps,
    side: {
      type: String,
      default: "left",
      validator: (v2) => ["left", "right"].includes(v2)
    },
    width: {
      type: Number,
      default: 300
    },
    mini: Boolean,
    miniToOverlay: Boolean,
    miniWidth: {
      type: Number,
      default: 57
    },
    noMiniAnimation: Boolean,
    breakpoint: {
      type: Number,
      default: 1023
    },
    showIfAbove: Boolean,
    behavior: {
      type: String,
      validator: (v2) => ["default", "desktop", "mobile"].includes(v2),
      default: "default"
    },
    bordered: Boolean,
    elevated: Boolean,
    overlay: Boolean,
    persistent: Boolean,
    noSwipeOpen: Boolean,
    noSwipeClose: Boolean,
    noSwipeBackdrop: Boolean
  },
  emits: [
    ...useModelToggleEmits,
    "onLayout",
    "miniState"
  ],
  setup(props4, { slots, emit: emit2, attrs }) {
    const vm2 = getCurrentInstance();
    const { proxy: { $q } } = vm2;
    const isDark = use_dark_default(props4, $q);
    const { preventBodyScroll } = use_prevent_scroll_default();
    const { registerTimeout, removeTimeout } = use_timeout_default();
    const $layout = inject(layoutKey, emptyRenderFn);
    if ($layout === emptyRenderFn) {
      console.error("QDrawer needs to be child of QLayout");
      return emptyRenderFn;
    }
    let lastDesktopState, timerMini = null, layoutTotalWidthWatcher;
    const belowBreakpoint = ref(
      props4.behavior === "mobile" || props4.behavior !== "desktop" && $layout.totalWidth.value <= props4.breakpoint
    );
    const isMini = computed(
      () => props4.mini === true && belowBreakpoint.value !== true
    );
    const size2 = computed(() => isMini.value === true ? props4.miniWidth : props4.width);
    const showing = ref(
      props4.showIfAbove === true && belowBreakpoint.value === false ? true : props4.modelValue === true
    );
    const hideOnRouteChange = computed(
      () => props4.persistent !== true && (belowBreakpoint.value === true || onScreenOverlay.value === true)
    );
    function handleShow(evt, noEvent) {
      addToHistory();
      evt !== false && $layout.animate();
      applyPosition(0);
      if (belowBreakpoint.value === true) {
        const otherInstance = $layout.instances[otherSide.value];
        if (otherInstance !== void 0 && otherInstance.belowBreakpoint === true) {
          otherInstance.hide(false);
        }
        applyBackdrop(1);
        $layout.isContainer.value !== true && preventBodyScroll(true);
      } else {
        applyBackdrop(0);
        evt !== false && setScrollable(false);
      }
      registerTimeout(() => {
        evt !== false && setScrollable(true);
        noEvent !== true && emit2("show", evt);
      }, duration);
    }
    function handleHide(evt, noEvent) {
      removeFromHistory();
      evt !== false && $layout.animate();
      applyBackdrop(0);
      applyPosition(stateDirection.value * size2.value);
      cleanup();
      if (noEvent !== true) {
        registerTimeout(() => {
          emit2("hide", evt);
        }, duration);
      } else {
        removeTimeout();
      }
    }
    const { show, hide } = use_model_toggle_default({
      showing,
      hideOnRouteChange,
      handleShow,
      handleHide
    });
    const { addToHistory, removeFromHistory } = use_history_default(showing);
    const instance = {
      belowBreakpoint,
      hide
    };
    const rightSide = computed(() => props4.side === "right");
    const stateDirection = computed(
      () => ($q.lang.rtl === true ? -1 : 1) * (rightSide.value === true ? 1 : -1)
    );
    const flagBackdropBg = ref(0);
    const flagPanning = ref(false);
    const flagMiniAnimate = ref(false);
    const flagContentPosition = ref(
      // starting with "hidden" for SSR
      size2.value * stateDirection.value
    );
    const otherSide = computed(() => rightSide.value === true ? "left" : "right");
    const offset2 = computed(() => showing.value === true && belowBreakpoint.value === false && props4.overlay === false ? props4.miniToOverlay === true ? props4.miniWidth : size2.value : 0);
    const fixed = computed(
      () => props4.overlay === true || props4.miniToOverlay === true || $layout.view.value.indexOf(rightSide.value ? "R" : "L") !== -1 || $q.platform.is.ios === true && $layout.isContainer.value === true
    );
    const onLayout = computed(
      () => props4.overlay === false && showing.value === true && belowBreakpoint.value === false
    );
    const onScreenOverlay = computed(
      () => props4.overlay === true && showing.value === true && belowBreakpoint.value === false
    );
    const backdropClass = computed(
      () => "fullscreen q-drawer__backdrop" + (showing.value === false && flagPanning.value === false ? " hidden" : "")
    );
    const backdropStyle = computed(() => ({
      backgroundColor: `rgba(0,0,0,${flagBackdropBg.value * 0.4})`
    }));
    const headerSlot = computed(() => rightSide.value === true ? $layout.rows.value.top[2] === "r" : $layout.rows.value.top[0] === "l");
    const footerSlot = computed(() => rightSide.value === true ? $layout.rows.value.bottom[2] === "r" : $layout.rows.value.bottom[0] === "l");
    const aboveStyle = computed(() => {
      const css2 = {};
      if ($layout.header.space === true && headerSlot.value === false) {
        if (fixed.value === true) {
          css2.top = `${$layout.header.offset}px`;
        } else if ($layout.header.space === true) {
          css2.top = `${$layout.header.size}px`;
        }
      }
      if ($layout.footer.space === true && footerSlot.value === false) {
        if (fixed.value === true) {
          css2.bottom = `${$layout.footer.offset}px`;
        } else if ($layout.footer.space === true) {
          css2.bottom = `${$layout.footer.size}px`;
        }
      }
      return css2;
    });
    const style2 = computed(() => {
      const style3 = {
        width: `${size2.value}px`,
        transform: `translateX(${flagContentPosition.value}px)`
      };
      return belowBreakpoint.value === true ? style3 : Object.assign(style3, aboveStyle.value);
    });
    const contentClass = computed(
      () => "q-drawer__content fit " + ($layout.isContainer.value !== true ? "scroll" : "overflow-auto")
    );
    const classes = computed(
      () => `q-drawer q-drawer--${props4.side}` + (flagMiniAnimate.value === true ? " q-drawer--mini-animate" : "") + (props4.bordered === true ? " q-drawer--bordered" : "") + (isDark.value === true ? " q-drawer--dark q-dark" : "") + (flagPanning.value === true ? " no-transition" : showing.value === true ? "" : " q-layout--prevent-focus") + (belowBreakpoint.value === true ? " fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding" : ` q-drawer--${isMini.value === true ? "mini" : "standard"}` + (fixed.value === true || onLayout.value !== true ? " fixed" : "") + (props4.overlay === true || props4.miniToOverlay === true ? " q-drawer--on-top" : "") + (headerSlot.value === true ? " q-drawer--top-padding" : ""))
    );
    const openDirective = computed(() => {
      const dir = $q.lang.rtl === true ? props4.side : otherSide.value;
      return [[
        TouchPan_default,
        onOpenPan,
        void 0,
        {
          [dir]: true,
          mouse: true
        }
      ]];
    });
    const contentCloseDirective = computed(() => {
      const dir = $q.lang.rtl === true ? otherSide.value : props4.side;
      return [[
        TouchPan_default,
        onClosePan,
        void 0,
        {
          [dir]: true,
          mouse: true
        }
      ]];
    });
    const backdropCloseDirective = computed(() => {
      const dir = $q.lang.rtl === true ? otherSide.value : props4.side;
      return [[
        TouchPan_default,
        onClosePan,
        void 0,
        {
          [dir]: true,
          mouse: true,
          mouseAllDir: true
        }
      ]];
    });
    function updateBelowBreakpoint() {
      updateLocal(belowBreakpoint, props4.behavior === "mobile" || props4.behavior !== "desktop" && $layout.totalWidth.value <= props4.breakpoint);
    }
    watch(belowBreakpoint, (val) => {
      if (val === true) {
        lastDesktopState = showing.value;
        showing.value === true && hide(false);
      } else if (props4.overlay === false && props4.behavior !== "mobile" && lastDesktopState !== false) {
        if (showing.value === true) {
          applyPosition(0);
          applyBackdrop(0);
          cleanup();
        } else {
          show(false);
        }
      }
    });
    watch(() => props4.side, (newSide, oldSide) => {
      if ($layout.instances[oldSide] === instance) {
        $layout.instances[oldSide] = void 0;
        $layout[oldSide].space = false;
        $layout[oldSide].offset = 0;
      }
      $layout.instances[newSide] = instance;
      $layout[newSide].size = size2.value;
      $layout[newSide].space = onLayout.value;
      $layout[newSide].offset = offset2.value;
    });
    watch($layout.totalWidth, () => {
      if ($layout.isContainer.value === true || document.qScrollPrevented !== true) {
        updateBelowBreakpoint();
      }
    });
    watch(
      () => props4.behavior + props4.breakpoint,
      updateBelowBreakpoint
    );
    watch($layout.isContainer, (val) => {
      showing.value === true && preventBodyScroll(val !== true);
      val === true && updateBelowBreakpoint();
    });
    watch($layout.scrollbarWidth, () => {
      applyPosition(showing.value === true ? 0 : void 0);
    });
    watch(offset2, (val) => {
      updateLayout("offset", val);
    });
    watch(onLayout, (val) => {
      emit2("onLayout", val);
      updateLayout("space", val);
    });
    watch(rightSide, () => {
      applyPosition();
    });
    watch(size2, (val) => {
      applyPosition();
      updateSizeOnLayout(props4.miniToOverlay, val);
    });
    watch(() => props4.miniToOverlay, (val) => {
      updateSizeOnLayout(val, size2.value);
    });
    watch(() => $q.lang.rtl, () => {
      applyPosition();
    });
    watch(() => props4.mini, () => {
      if (props4.noMiniAnimation) return;
      if (props4.modelValue === true) {
        animateMini();
        $layout.animate();
      }
    });
    watch(isMini, (val) => {
      emit2("miniState", val);
    });
    function applyPosition(position2) {
      if (position2 === void 0) {
        nextTick(() => {
          position2 = showing.value === true ? 0 : size2.value;
          applyPosition(stateDirection.value * position2);
        });
      } else {
        if ($layout.isContainer.value === true && rightSide.value === true && (belowBreakpoint.value === true || Math.abs(position2) === size2.value)) {
          position2 += stateDirection.value * $layout.scrollbarWidth.value;
        }
        flagContentPosition.value = position2;
      }
    }
    function applyBackdrop(x) {
      flagBackdropBg.value = x;
    }
    function setScrollable(v2) {
      const action = v2 === true ? "remove" : $layout.isContainer.value !== true ? "add" : "";
      action !== "" && document.body.classList[action]("q-body--drawer-toggle");
    }
    function animateMini() {
      timerMini !== null && clearTimeout(timerMini);
      if (vm2.proxy && vm2.proxy.$el) {
        vm2.proxy.$el.classList.add("q-drawer--mini-animate");
      }
      flagMiniAnimate.value = true;
      timerMini = setTimeout(() => {
        timerMini = null;
        flagMiniAnimate.value = false;
        if (vm2 && vm2.proxy && vm2.proxy.$el) {
          vm2.proxy.$el.classList.remove("q-drawer--mini-animate");
        }
      }, 150);
    }
    function onOpenPan(evt) {
      if (showing.value !== false) {
        return;
      }
      const width3 = size2.value, position2 = between(evt.distance.x, 0, width3);
      if (evt.isFinal === true) {
        const opened = position2 >= Math.min(75, width3);
        if (opened === true) {
          show();
        } else {
          $layout.animate();
          applyBackdrop(0);
          applyPosition(stateDirection.value * width3);
        }
        flagPanning.value = false;
        return;
      }
      applyPosition(
        ($q.lang.rtl === true ? rightSide.value !== true : rightSide.value) ? Math.max(width3 - position2, 0) : Math.min(0, position2 - width3)
      );
      applyBackdrop(
        between(position2 / width3, 0, 1)
      );
      if (evt.isFirst === true) {
        flagPanning.value = true;
      }
    }
    function onClosePan(evt) {
      if (showing.value !== true) {
        return;
      }
      const width3 = size2.value, dir = evt.direction === props4.side, position2 = ($q.lang.rtl === true ? dir !== true : dir) ? between(evt.distance.x, 0, width3) : 0;
      if (evt.isFinal === true) {
        const opened = Math.abs(position2) < Math.min(75, width3);
        if (opened === true) {
          $layout.animate();
          applyBackdrop(1);
          applyPosition(0);
        } else {
          hide();
        }
        flagPanning.value = false;
        return;
      }
      applyPosition(stateDirection.value * position2);
      applyBackdrop(between(1 - position2 / width3, 0, 1));
      if (evt.isFirst === true) {
        flagPanning.value = true;
      }
    }
    function cleanup() {
      preventBodyScroll(false);
      setScrollable(true);
    }
    function updateLayout(prop, val) {
      $layout.update(props4.side, prop, val);
    }
    function updateLocal(prop, val) {
      if (prop.value !== val) {
        prop.value = val;
      }
    }
    function updateSizeOnLayout(miniToOverlay, size3) {
      updateLayout("size", miniToOverlay === true ? props4.miniWidth : size3);
    }
    $layout.instances[props4.side] = instance;
    updateSizeOnLayout(props4.miniToOverlay, size2.value);
    updateLayout("space", onLayout.value);
    updateLayout("offset", offset2.value);
    if (props4.showIfAbove === true && props4.modelValue !== true && showing.value === true && props4["onUpdate:modelValue"] !== void 0) {
      emit2("update:modelValue", true);
    }
    onMounted(() => {
      emit2("onLayout", onLayout.value);
      emit2("miniState", isMini.value);
      lastDesktopState = props4.showIfAbove === true;
      const fn = () => {
        const action = showing.value === true ? handleShow : handleHide;
        action(false, true);
      };
      if ($layout.totalWidth.value !== 0) {
        nextTick(fn);
        return;
      }
      layoutTotalWidthWatcher = watch($layout.totalWidth, () => {
        layoutTotalWidthWatcher();
        layoutTotalWidthWatcher = void 0;
        if (showing.value === false && props4.showIfAbove === true && belowBreakpoint.value === false) {
          show(false);
        } else {
          fn();
        }
      });
    });
    onBeforeUnmount(() => {
      layoutTotalWidthWatcher !== void 0 && layoutTotalWidthWatcher();
      if (timerMini !== null) {
        clearTimeout(timerMini);
        timerMini = null;
      }
      showing.value === true && cleanup();
      if ($layout.instances[props4.side] === instance) {
        $layout.instances[props4.side] = void 0;
        updateLayout("size", 0);
        updateLayout("offset", 0);
        updateLayout("space", false);
      }
    });
    return () => {
      const child = [];
      if (belowBreakpoint.value === true) {
        props4.noSwipeOpen === false && child.push(
          withDirectives(
            h("div", {
              key: "open",
              class: `q-drawer__opener fixed-${props4.side}`,
              "aria-hidden": "true"
            }),
            openDirective.value
          )
        );
        child.push(
          hDir(
            "div",
            {
              ref: "backdrop",
              class: backdropClass.value,
              style: backdropStyle.value,
              "aria-hidden": "true",
              onClick: hide
            },
            void 0,
            "backdrop",
            props4.noSwipeBackdrop !== true && showing.value === true,
            () => backdropCloseDirective.value
          )
        );
      }
      const mini = isMini.value === true && slots.mini !== void 0;
      const content = [
        h(
          "div",
          {
            ...attrs,
            key: "" + mini,
            // required otherwise Vue will not diff correctly
            class: [
              contentClass.value,
              attrs.class
            ]
          },
          mini === true ? slots.mini() : hSlot(slots.default)
        )
      ];
      if (props4.elevated === true && showing.value === true) {
        content.push(
          h("div", {
            class: "q-layout__shadow absolute-full overflow-hidden no-pointer-events"
          })
        );
      }
      child.push(
        hDir(
          "aside",
          { ref: "content", class: classes.value, style: style2.value },
          content,
          "contentclose",
          props4.noSwipeClose !== true && belowBreakpoint.value === true,
          () => contentCloseDirective.value
        )
      );
      return h("div", { class: "q-drawer-container" }, child);
    };
  }
});
function getBlockElement(el, parent) {
  if (parent && el === parent) {
    return null;
  }
  const nodeName = el.nodeName.toLowerCase();
  if (["div", "li", "ul", "ol", "blockquote"].includes(nodeName) === true) {
    return el;
  }
  const style2 = window.getComputedStyle ? window.getComputedStyle(el) : el.currentStyle, display = style2.display;
  if (display === "block" || display === "table") {
    return el;
  }
  return getBlockElement(el.parentNode);
}
function isChildOf(el, parent, orSame) {
  return !el || el === document.body ? false : orSame === true && el === parent || (parent === document ? document.body : parent).contains(el.parentNode);
}
function createRange(node, chars, range) {
  if (!range) {
    range = document.createRange();
    range.selectNode(node);
    range.setStart(node, 0);
  }
  if (chars.count === 0) {
    range.setEnd(node, chars.count);
  } else if (chars.count > 0) {
    if (node.nodeType === Node.TEXT_NODE) {
      if (node.textContent.length < chars.count) {
        chars.count -= node.textContent.length;
      } else {
        range.setEnd(node, chars.count);
        chars.count = 0;
      }
    } else {
      for (let lp = 0; chars.count !== 0 && lp < node.childNodes.length; lp++) {
        range = createRange(node.childNodes[lp], chars, range);
      }
    }
  }
  return range;
}
var urlRegex = /^https?:\/\//;
var Caret = class {
  constructor(el, eVm) {
    this.el = el;
    this.eVm = eVm;
    this._range = null;
  }
  get selection() {
    if (this.el) {
      const sel = document.getSelection();
      if (isChildOf(sel.anchorNode, this.el, true) && isChildOf(sel.focusNode, this.el, true)) {
        return sel;
      }
    }
    return null;
  }
  get hasSelection() {
    return this.selection !== null ? this.selection.toString().length !== 0 : false;
  }
  get range() {
    const sel = this.selection;
    if (sel !== null && sel.rangeCount) {
      return sel.getRangeAt(0);
    }
    return this._range;
  }
  get parent() {
    const range = this.range;
    if (range !== null) {
      const node = range.startContainer;
      return node.nodeType === document.ELEMENT_NODE ? node : node.parentNode;
    }
    return null;
  }
  get blockParent() {
    const parent = this.parent;
    if (parent !== null) {
      return getBlockElement(parent, this.el);
    }
    return null;
  }
  save(range = this.range) {
    if (range !== null) {
      this._range = range;
    }
  }
  restore(range = this._range) {
    const r = document.createRange(), sel = document.getSelection();
    if (range !== null) {
      r.setStart(range.startContainer, range.startOffset);
      r.setEnd(range.endContainer, range.endOffset);
      sel.removeAllRanges();
      sel.addRange(r);
    } else {
      sel.selectAllChildren(this.el);
      sel.collapseToEnd();
    }
  }
  savePosition() {
    let charCount = -1, node;
    const selection = document.getSelection(), parentEl = this.el.parentNode;
    if (selection.focusNode && isChildOf(selection.focusNode, parentEl)) {
      node = selection.focusNode;
      charCount = selection.focusOffset;
      while (node && node !== parentEl) {
        if (node !== this.el && node.previousSibling) {
          node = node.previousSibling;
          charCount += node.textContent.length;
        } else {
          node = node.parentNode;
        }
      }
    }
    this.savedPos = charCount;
  }
  restorePosition(length = 0) {
    if (this.savedPos > 0 && this.savedPos < length) {
      const selection = window.getSelection(), range = createRange(this.el, { count: this.savedPos });
      if (range) {
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }
  }
  hasParent(name2, spanLevel) {
    const el = spanLevel ? this.parent : this.blockParent;
    return el !== null ? el.nodeName.toLowerCase() === name2.toLowerCase() : false;
  }
  hasParents(list, recursive, el = this.parent) {
    if (el === null) {
      return false;
    }
    if (list.includes(el.nodeName.toLowerCase()) === true) {
      return true;
    }
    return recursive === true ? this.hasParents(list, recursive, el.parentNode) : false;
  }
  is(cmd, param) {
    if (this.selection === null) {
      return false;
    }
    switch (cmd) {
      case "formatBlock":
        return param === "DIV" && this.parent === this.el || this.hasParent(param, param === "PRE");
      case "link":
        return this.hasParent("A", true);
      case "fontSize":
        return document.queryCommandValue(cmd) === param;
      case "fontName":
        const res = document.queryCommandValue(cmd);
        return res === `"${param}"` || res === param;
      case "fullscreen":
        return this.eVm.inFullscreen.value;
      case "viewsource":
        return this.eVm.isViewingSource.value;
      case void 0:
        return false;
      default:
        const state = document.queryCommandState(cmd);
        return param !== void 0 ? state === param : state;
    }
  }
  getParentAttribute(attrib) {
    if (this.parent !== null) {
      return this.parent.getAttribute(attrib);
    }
    return null;
  }
  can(name2) {
    if (name2 === "outdent") {
      return this.hasParents(["blockquote", "li"], true);
    }
    if (name2 === "indent") {
      return this.hasParents(["li"], true);
    }
    if (name2 === "link") {
      return this.selection !== null || this.is("link");
    }
  }
  apply(cmd, param, done = noop) {
    if (cmd === "formatBlock") {
      if (["BLOCKQUOTE", "H1", "H2", "H3", "H4", "H5", "H6"].includes(param) && this.is(cmd, param)) {
        cmd = "outdent";
        param = null;
      }
      if (param === "PRE" && this.is(cmd, "PRE")) {
        param = "P";
      }
    } else if (cmd === "print") {
      done();
      const win = window.open();
      win.document.write(`
        <!doctype html>
        <html>
          <head>
            <title>Print - ${document.title}</title>
          </head>
          <body>
            <div>${this.el.innerHTML}</div>
          </body>
        </html>
      `);
      win.print();
      win.close();
      return;
    } else if (cmd === "link") {
      const link = this.getParentAttribute("href");
      if (link === null) {
        const selection = this.selectWord(this.selection);
        const url = selection ? selection.toString() : "";
        if (!url.length) {
          if (!this.range || !this.range.cloneContents().querySelector("img")) {
            return;
          }
        }
        this.eVm.editLinkUrl.value = urlRegex.test(url) ? url : "https://";
        document.execCommand("createLink", false, this.eVm.editLinkUrl.value);
        this.save(selection.getRangeAt(0));
      } else {
        this.eVm.editLinkUrl.value = link;
        this.range.selectNodeContents(this.parent);
        this.save();
      }
      return;
    } else if (cmd === "fullscreen") {
      this.eVm.toggleFullscreen();
      done();
      return;
    } else if (cmd === "viewsource") {
      this.eVm.isViewingSource.value = this.eVm.isViewingSource.value === false;
      this.eVm.setContent(this.eVm.props.modelValue);
      done();
      return;
    }
    document.execCommand(cmd, false, param);
    done();
  }
  selectWord(sel) {
    if (sel === null || sel.isCollapsed !== true || /* IE 11 */
    sel.modify === void 0) {
      return sel;
    }
    const range = document.createRange();
    range.setStart(sel.anchorNode, sel.anchorOffset);
    range.setEnd(sel.focusNode, sel.focusOffset);
    const direction = range.collapsed ? ["backward", "forward"] : ["forward", "backward"];
    range.detach();
    const endNode = sel.focusNode, endOffset = sel.focusOffset;
    sel.collapse(sel.anchorNode, sel.anchorOffset);
    sel.modify("move", direction[0], "character");
    sel.modify("move", direction[1], "word");
    sel.extend(endNode, endOffset);
    sel.modify("extend", direction[1], "character");
    sel.modify("extend", direction[0], "word");
    return sel;
  }
};
var QTooltip_default = createComponent({
  name: "QTooltip",
  inheritAttrs: false,
  props: {
    ...useAnchorStaticProps,
    ...useModelToggleProps,
    ...useTransitionProps,
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    },
    transitionShow: {
      ...useTransitionProps.transitionShow,
      default: "jump-down"
    },
    transitionHide: {
      ...useTransitionProps.transitionHide,
      default: "jump-up"
    },
    anchor: {
      type: String,
      default: "bottom middle",
      validator: validatePosition
    },
    self: {
      type: String,
      default: "top middle",
      validator: validatePosition
    },
    offset: {
      type: Array,
      default: () => [14, 14],
      validator: validateOffset
    },
    scrollTarget: scrollTargetProp,
    delay: {
      type: Number,
      default: 0
    },
    hideDelay: {
      type: Number,
      default: 0
    },
    persistent: Boolean
  },
  emits: [
    ...useModelToggleEmits
  ],
  setup(props4, { slots, emit: emit2, attrs }) {
    let unwatchPosition, observer;
    const vm2 = getCurrentInstance();
    const { proxy: { $q } } = vm2;
    const innerRef = ref(null);
    const showing = ref(false);
    const anchorOrigin = computed(() => parsePosition(props4.anchor, $q.lang.rtl));
    const selfOrigin = computed(() => parsePosition(props4.self, $q.lang.rtl));
    const hideOnRouteChange = computed(() => props4.persistent !== true);
    const { registerTick, removeTick } = use_tick_default();
    const { registerTimeout } = use_timeout_default();
    const { transitionProps, transitionStyle } = use_transition_default(props4);
    const { localScrollTarget, changeScrollEvent, unconfigureScrollTarget } = use_scroll_target_default(props4, configureScrollTarget);
    const { anchorEl, canShow, anchorEvents } = use_anchor_default({ showing, configureAnchorEl });
    const { show, hide } = use_model_toggle_default({
      showing,
      canShow,
      handleShow,
      handleHide,
      hideOnRouteChange,
      processOnMount: true
    });
    Object.assign(anchorEvents, { delayShow, delayHide });
    const { showPortal, hidePortal, renderPortal } = use_portal_default(vm2, innerRef, renderPortalContent, "tooltip");
    if ($q.platform.is.mobile === true) {
      const clickOutsideProps = {
        anchorEl,
        innerRef,
        onClickOutside(e) {
          hide(e);
          if (e.target.classList.contains("q-dialog__backdrop")) {
            stopAndPrevent(e);
          }
          return true;
        }
      };
      const hasClickOutside = computed(
        () => (
          // it doesn't has external model
          // (null is the default value)
          props4.modelValue === null && props4.persistent !== true && showing.value === true
        )
      );
      watch(hasClickOutside, (val) => {
        const fn = val === true ? addClickOutside : removeClickOutside;
        fn(clickOutsideProps);
      });
      onBeforeUnmount(() => {
        removeClickOutside(clickOutsideProps);
      });
    }
    function handleShow(evt) {
      showPortal();
      registerTick(() => {
        observer = new MutationObserver(() => updatePosition());
        observer.observe(innerRef.value, { attributes: false, childList: true, characterData: true, subtree: true });
        updatePosition();
        configureScrollTarget();
      });
      if (unwatchPosition === void 0) {
        unwatchPosition = watch(
          () => $q.screen.width + "|" + $q.screen.height + "|" + props4.self + "|" + props4.anchor + "|" + $q.lang.rtl,
          updatePosition
        );
      }
      registerTimeout(() => {
        showPortal(true);
        emit2("show", evt);
      }, props4.transitionDuration);
    }
    function handleHide(evt) {
      removeTick();
      hidePortal();
      anchorCleanup();
      registerTimeout(() => {
        hidePortal(true);
        emit2("hide", evt);
      }, props4.transitionDuration);
    }
    function anchorCleanup() {
      if (observer !== void 0) {
        observer.disconnect();
        observer = void 0;
      }
      if (unwatchPosition !== void 0) {
        unwatchPosition();
        unwatchPosition = void 0;
      }
      unconfigureScrollTarget();
      cleanEvt(anchorEvents, "tooltipTemp");
    }
    function updatePosition() {
      setPosition({
        targetEl: innerRef.value,
        offset: props4.offset,
        anchorEl: anchorEl.value,
        anchorOrigin: anchorOrigin.value,
        selfOrigin: selfOrigin.value,
        maxHeight: props4.maxHeight,
        maxWidth: props4.maxWidth
      });
    }
    function delayShow(evt) {
      if ($q.platform.is.mobile === true) {
        clearSelection();
        document.body.classList.add("non-selectable");
        const target2 = anchorEl.value;
        const evts = ["touchmove", "touchcancel", "touchend", "click"].map((e) => [target2, e, "delayHide", "passiveCapture"]);
        addEvt(anchorEvents, "tooltipTemp", evts);
      }
      registerTimeout(() => {
        show(evt);
      }, props4.delay);
    }
    function delayHide(evt) {
      if ($q.platform.is.mobile === true) {
        cleanEvt(anchorEvents, "tooltipTemp");
        clearSelection();
        setTimeout(() => {
          document.body.classList.remove("non-selectable");
        }, 10);
      }
      registerTimeout(() => {
        hide(evt);
      }, props4.hideDelay);
    }
    function configureAnchorEl() {
      if (props4.noParentEvent === true || anchorEl.value === null) return;
      const evts = $q.platform.is.mobile === true ? [
        [anchorEl.value, "touchstart", "delayShow", "passive"]
      ] : [
        [anchorEl.value, "mouseenter", "delayShow", "passive"],
        [anchorEl.value, "mouseleave", "delayHide", "passive"]
      ];
      addEvt(anchorEvents, "anchor", evts);
    }
    function configureScrollTarget() {
      if (anchorEl.value !== null || props4.scrollTarget !== void 0) {
        localScrollTarget.value = getScrollTarget(anchorEl.value, props4.scrollTarget);
        const fn = props4.noParentEvent === true ? updatePosition : hide;
        changeScrollEvent(localScrollTarget.value, fn);
      }
    }
    function getTooltipContent() {
      return showing.value === true ? h("div", {
        ...attrs,
        ref: innerRef,
        class: [
          "q-tooltip q-tooltip--style q-position-engine no-pointer-events",
          attrs.class
        ],
        style: [
          attrs.style,
          transitionStyle.value
        ],
        role: "tooltip"
      }, hSlot(slots.default)) : null;
    }
    function renderPortalContent() {
      return h(Transition, transitionProps.value, getTooltipContent);
    }
    onBeforeUnmount(anchorCleanup);
    Object.assign(vm2.proxy, { updatePosition });
    return renderPortal;
  }
});
var QItem_default = createComponent({
  name: "QItem",
  props: {
    ...useDarkProps,
    ...useRouterLinkProps,
    tag: {
      type: String,
      default: "div"
    },
    active: {
      type: Boolean,
      default: null
    },
    clickable: Boolean,
    dense: Boolean,
    insetLevel: Number,
    tabindex: [String, Number],
    focused: Boolean,
    manualFocus: Boolean
  },
  emits: ["click", "keyup"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = use_dark_default(props4, $q);
    const { hasLink, linkAttrs, linkClass, linkTag, navigateOnClick } = use_router_link_default();
    const rootRef = ref(null);
    const blurTargetRef = ref(null);
    const isActionable = computed(
      () => props4.clickable === true || hasLink.value === true || props4.tag === "label"
    );
    const isClickable = computed(
      () => props4.disable !== true && isActionable.value === true
    );
    const classes = computed(
      () => "q-item q-item-type row no-wrap" + (props4.dense === true ? " q-item--dense" : "") + (isDark.value === true ? " q-item--dark" : "") + (hasLink.value === true && props4.active === null ? linkClass.value : props4.active === true ? ` q-item--active${props4.activeClass !== void 0 ? ` ${props4.activeClass}` : ""}` : "") + (props4.disable === true ? " disabled" : "") + (isClickable.value === true ? " q-item--clickable q-link cursor-pointer " + (props4.manualFocus === true ? "q-manual-focusable" : "q-focusable q-hoverable") + (props4.focused === true ? " q-manual-focusable--focused" : "") : "")
    );
    const style2 = computed(() => {
      if (props4.insetLevel === void 0) {
        return null;
      }
      const dir = $q.lang.rtl === true ? "Right" : "Left";
      return {
        ["padding" + dir]: 16 + props4.insetLevel * 56 + "px"
      };
    });
    function onClick(e) {
      if (isClickable.value === true) {
        if (blurTargetRef.value !== null) {
          if (e.qKeyEvent !== true && document.activeElement === rootRef.value) {
            blurTargetRef.value.focus();
          } else if (document.activeElement === blurTargetRef.value) {
            rootRef.value.focus();
          }
        }
        navigateOnClick(e);
      }
    }
    function onKeyup2(e) {
      if (isClickable.value === true && isKeyCode(e, [13, 32]) === true) {
        stopAndPrevent(e);
        e.qKeyEvent = true;
        const evt = new MouseEvent("click", e);
        evt.qKeyEvent = true;
        rootRef.value.dispatchEvent(evt);
      }
      emit2("keyup", e);
    }
    function getContent() {
      const child = hUniqueSlot(slots.default, []);
      isClickable.value === true && child.unshift(
        h("div", { class: "q-focus-helper", tabindex: -1, ref: blurTargetRef })
      );
      return child;
    }
    return () => {
      const data = {
        ref: rootRef,
        class: classes.value,
        style: style2.value,
        role: "listitem",
        onClick,
        onKeyup: onKeyup2
      };
      if (isClickable.value === true) {
        data.tabindex = props4.tabindex || "0";
        Object.assign(data, linkAttrs.value);
      } else if (isActionable.value === true) {
        data["aria-disabled"] = "true";
      }
      return h(
        linkTag.value,
        data,
        getContent()
      );
    };
  }
});
var QItemSection_default = createComponent({
  name: "QItemSection",
  props: {
    avatar: Boolean,
    thumbnail: Boolean,
    side: Boolean,
    top: Boolean,
    noWrap: Boolean
  },
  setup(props4, { slots }) {
    const classes = computed(
      () => `q-item__section column q-item__section--${props4.avatar === true || props4.side === true || props4.thumbnail === true ? "side" : "main"}` + (props4.top === true ? " q-item__section--top justify-start" : " justify-center") + (props4.avatar === true ? " q-item__section--avatar" : "") + (props4.thumbnail === true ? " q-item__section--thumbnail" : "") + (props4.noWrap === true ? " q-item__section--nowrap" : "")
    );
    return () => h("div", { class: classes.value }, hSlot(slots.default));
  }
});
function run(e, btn, eVm) {
  if (btn.handler) {
    btn.handler(e, eVm, eVm.caret);
  } else {
    eVm.runCmd(btn.cmd, btn.param);
  }
}
function getGroup(children) {
  return h("div", { class: "q-editor__toolbar-group" }, children);
}
function getBtn(eVm, btn, clickHandler, active = false) {
  const toggled = active || (btn.type === "toggle" ? btn.toggled ? btn.toggled(eVm) : btn.cmd && eVm.caret.is(btn.cmd, btn.param) : false), child = [];
  if (btn.tip && eVm.$q.platform.is.desktop) {
    const Key = btn.key ? h("div", [
      h("small", `(CTRL + ${String.fromCharCode(btn.key)})`)
    ]) : null;
    child.push(
      h(QTooltip_default, { delay: 1e3 }, () => [
        h("div", { innerHTML: btn.tip }),
        Key
      ])
    );
  }
  return h(QBtn_default, {
    ...eVm.buttonProps.value,
    icon: btn.icon !== null ? btn.icon : void 0,
    color: toggled ? btn.toggleColor || eVm.props.toolbarToggleColor : btn.color || eVm.props.toolbarColor,
    textColor: toggled && !eVm.props.toolbarPush ? null : btn.textColor || eVm.props.toolbarTextColor,
    label: btn.label,
    disable: btn.disable ? typeof btn.disable === "function" ? btn.disable(eVm) : true : false,
    size: "sm",
    onClick(e) {
      clickHandler && clickHandler();
      run(e, btn, eVm);
    }
  }, () => child);
}
function getDropdown(eVm, btn) {
  const onlyIcons = btn.list === "only-icons";
  let label2 = btn.label, icon2 = btn.icon !== null ? btn.icon : void 0, contentClass, Items;
  function closeDropdown() {
    Dropdown.component.proxy.hide();
  }
  if (onlyIcons) {
    Items = btn.options.map((btn2) => {
      const active = btn2.type === void 0 ? eVm.caret.is(btn2.cmd, btn2.param) : false;
      if (active) {
        label2 = btn2.tip;
        icon2 = btn2.icon !== null ? btn2.icon : void 0;
      }
      return getBtn(eVm, btn2, closeDropdown, active);
    });
    contentClass = eVm.toolbarBackgroundClass.value;
    Items = [
      getGroup(Items)
    ];
  } else {
    const activeClass = eVm.props.toolbarToggleColor !== void 0 ? `text-${eVm.props.toolbarToggleColor}` : null;
    const inactiveClass = eVm.props.toolbarTextColor !== void 0 ? `text-${eVm.props.toolbarTextColor}` : null;
    const noIcons = btn.list === "no-icons";
    Items = btn.options.map((btn2) => {
      const disable = btn2.disable ? btn2.disable(eVm) : false;
      const active = btn2.type === void 0 ? eVm.caret.is(btn2.cmd, btn2.param) : false;
      if (active) {
        label2 = btn2.tip;
        icon2 = btn2.icon !== null ? btn2.icon : void 0;
      }
      const htmlTip = btn2.htmlTip;
      return h(QItem_default, {
        active,
        activeClass,
        clickable: true,
        disable,
        dense: true,
        onClick(e) {
          closeDropdown();
          eVm.contentRef.value !== null && eVm.contentRef.value.focus();
          eVm.caret.restore();
          run(e, btn2, eVm);
        }
      }, () => [
        noIcons === true ? null : h(
          QItemSection_default,
          {
            class: active ? activeClass : inactiveClass,
            side: true
          },
          () => h(QIcon_default, { name: btn2.icon !== null ? btn2.icon : void 0 })
        ),
        h(
          QItemSection_default,
          htmlTip ? () => h("div", { class: "text-no-wrap", innerHTML: btn2.htmlTip }) : btn2.tip ? () => h("div", { class: "text-no-wrap" }, btn2.tip) : void 0
        )
      ]);
    });
    contentClass = [eVm.toolbarBackgroundClass.value, inactiveClass];
  }
  const highlight = btn.highlight && label2 !== btn.label;
  const Dropdown = h(QBtnDropdown_default, {
    ...eVm.buttonProps.value,
    noCaps: true,
    noWrap: true,
    color: highlight ? eVm.props.toolbarToggleColor : eVm.props.toolbarColor,
    textColor: highlight && !eVm.props.toolbarPush ? null : eVm.props.toolbarTextColor,
    label: btn.fixedLabel ? btn.label : label2,
    icon: btn.fixedIcon ? btn.icon !== null ? btn.icon : void 0 : icon2,
    contentClass,
    onShow: (evt) => eVm.emit("dropdownShow", evt),
    onHide: (evt) => eVm.emit("dropdownHide", evt),
    onBeforeShow: (evt) => eVm.emit("dropdownBeforeShow", evt),
    onBeforeHide: (evt) => eVm.emit("dropdownBeforeHide", evt)
  }, () => Items);
  return Dropdown;
}
function getToolbar(eVm) {
  if (eVm.caret) {
    return eVm.buttons.value.filter((f) => {
      return !eVm.isViewingSource.value || f.find((fb) => fb.cmd === "viewsource");
    }).map((group) => getGroup(
      group.map((btn) => {
        if (eVm.isViewingSource.value && btn.cmd !== "viewsource") {
          return false;
        }
        if (btn.type === "slot") {
          return hSlot(eVm.slots[btn.slot]);
        }
        if (btn.type === "dropdown") {
          return getDropdown(eVm, btn);
        }
        return getBtn(eVm, btn);
      })
    ));
  }
}
function getFonts(defaultFont, defaultFontLabel, defaultFontIcon, fonts = {}) {
  const aliases = Object.keys(fonts);
  if (aliases.length === 0) {
    return {};
  }
  const def2 = {
    default_font: {
      cmd: "fontName",
      param: defaultFont,
      icon: defaultFontIcon,
      tip: defaultFontLabel
    }
  };
  aliases.forEach((alias) => {
    const name2 = fonts[alias];
    def2[alias] = {
      cmd: "fontName",
      param: name2,
      icon: defaultFontIcon,
      tip: name2,
      htmlTip: `<font face="${name2}">${name2}</font>`
    };
  });
  return def2;
}
function getLinkEditor(eVm) {
  if (eVm.caret) {
    const color = eVm.props.toolbarColor || eVm.props.toolbarTextColor;
    let link = eVm.editLinkUrl.value;
    const updateLink = () => {
      eVm.caret.restore();
      if (link !== eVm.editLinkUrl.value) {
        document.execCommand("createLink", false, link === "" ? " " : link);
      }
      eVm.editLinkUrl.value = null;
    };
    return [
      h("div", { class: `q-mx-xs text-${color}` }, `${eVm.$q.lang.editor.url}: `),
      h("input", {
        key: "qedt_btm_input",
        class: "col q-editor__link-input",
        value: link,
        onInput: (evt) => {
          stop(evt);
          link = evt.target.value;
        },
        onKeydown: (evt) => {
          if (shouldIgnoreKey(evt) === true) {
            return;
          }
          switch (evt.keyCode) {
            case 13:
              prevent(evt);
              return updateLink();
            case 27:
              prevent(evt);
              eVm.caret.restore();
              if (!eVm.editLinkUrl.value || eVm.editLinkUrl.value === "https://") {
                document.execCommand("unlink");
              }
              eVm.editLinkUrl.value = null;
              break;
          }
        }
      }),
      getGroup([
        h(QBtn_default, {
          key: "qedt_btm_rem",
          tabindex: -1,
          ...eVm.buttonProps.value,
          label: eVm.$q.lang.label.remove,
          noCaps: true,
          onClick: () => {
            eVm.caret.restore();
            document.execCommand("unlink");
            eVm.editLinkUrl.value = null;
          }
        }),
        h(QBtn_default, {
          key: "qedt_btm_upd",
          ...eVm.buttonProps.value,
          label: eVm.$q.lang.label.update,
          noCaps: true,
          onClick: updateLink
        })
      ])
    ];
  }
}
var listenerRE = /^on[A-Z]/;
function use_split_attrs_default() {
  const { attrs, vnode } = getCurrentInstance();
  const acc = {
    listeners: ref({}),
    attributes: ref({})
  };
  function update6() {
    const attributes = {};
    const listeners = {};
    for (const key in attrs) {
      if (key !== "class" && key !== "style" && listenerRE.test(key) === false) {
        attributes[key] = attrs[key];
      }
    }
    for (const key in vnode.props) {
      if (listenerRE.test(key) === true) {
        listeners[key] = vnode.props[key];
      }
    }
    acc.attributes.value = attributes;
    acc.listeners.value = listeners;
  }
  onBeforeUpdate(update6);
  update6();
  return acc;
}
var toString = Object.prototype.toString;
var hasOwn = Object.prototype.hasOwnProperty;
var notPlainObject = new Set(
  ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp"].map((name2) => "[object " + name2 + "]")
);
function isPlainObject(obj) {
  if (obj !== Object(obj) || notPlainObject.has(toString.call(obj)) === true) {
    return false;
  }
  if (obj.constructor && hasOwn.call(obj, "constructor") === false && hasOwn.call(obj.constructor.prototype, "isPrototypeOf") === false) {
    return false;
  }
  let key;
  for (key in obj) {
  }
  return key === void 0 || hasOwn.call(obj, key);
}
function extend() {
  let options, name2, src, copy, copyIsArray, clone2, target2 = arguments[0] || {}, i = 1, deep = false;
  const length = arguments.length;
  if (typeof target2 === "boolean") {
    deep = target2;
    target2 = arguments[1] || {};
    i = 2;
  }
  if (Object(target2) !== target2 && typeof target2 !== "function") {
    target2 = {};
  }
  if (length === i) {
    target2 = this;
    i--;
  }
  for (; i < length; i++) {
    if ((options = arguments[i]) !== null) {
      for (name2 in options) {
        src = target2[name2];
        copy = options[name2];
        if (target2 === copy) {
          continue;
        }
        if (deep === true && copy && ((copyIsArray = Array.isArray(copy)) || isPlainObject(copy) === true)) {
          if (copyIsArray === true) {
            clone2 = Array.isArray(src) === true ? src : [];
          } else {
            clone2 = isPlainObject(src) === true ? src : {};
          }
          target2[name2] = extend(deep, clone2, copy);
        } else if (copy !== void 0) {
          target2[name2] = copy;
        }
      }
    }
  }
  return target2;
}
createComponent({
  name: "QEditor",
  props: {
    ...useDarkProps,
    ...useFullscreenProps,
    modelValue: {
      type: String,
      required: true
    },
    readonly: Boolean,
    disable: Boolean,
    minHeight: {
      type: String,
      default: "10rem"
    },
    maxHeight: String,
    height: String,
    definitions: Object,
    fonts: Object,
    placeholder: String,
    toolbar: {
      type: Array,
      validator: (v2) => v2.length === 0 || v2.every((group) => group.length),
      // long line on purpose for API validation purposes:
      default: () => [["left", "center", "right", "justify"], ["bold", "italic", "underline", "strike"], ["undo", "redo"]]
    },
    toolbarColor: String,
    toolbarBg: String,
    toolbarTextColor: String,
    toolbarToggleColor: {
      type: String,
      default: "primary"
    },
    toolbarOutline: Boolean,
    toolbarPush: Boolean,
    toolbarRounded: Boolean,
    paragraphTag: {
      type: String,
      validator: (v2) => ["div", "p"].includes(v2),
      default: "div"
    },
    contentStyle: Object,
    contentClass: [Object, Array, String],
    square: Boolean,
    flat: Boolean,
    dense: Boolean
  },
  emits: [
    ...useFullscreenEmits,
    "update:modelValue",
    "keydown",
    "click",
    "focus",
    "blur",
    "dropdownShow",
    "dropdownHide",
    "dropdownBeforeShow",
    "dropdownBeforeHide",
    "linkShow",
    "linkHide"
  ],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = use_dark_default(props4, $q);
    const { inFullscreen, toggleFullscreen } = use_fullscreen_default();
    const splitAttrs = use_split_attrs_default();
    const rootRef = ref(null);
    const contentRef = ref(null);
    const editLinkUrl = ref(null);
    const isViewingSource = ref(false);
    const editable = computed(() => !props4.readonly && !props4.disable);
    let defaultFont, offsetBottom;
    let lastEmit = props4.modelValue;
    {
      document.execCommand("defaultParagraphSeparator", false, props4.paragraphTag);
      defaultFont = window.getComputedStyle(document.body).fontFamily;
    }
    const toolbarBackgroundClass = computed(() => props4.toolbarBg ? ` bg-${props4.toolbarBg}` : "");
    const buttonProps = computed(() => {
      const flat = props4.toolbarOutline !== true && props4.toolbarPush !== true;
      return {
        type: "a",
        flat,
        noWrap: true,
        outline: props4.toolbarOutline,
        push: props4.toolbarPush,
        rounded: props4.toolbarRounded,
        dense: true,
        color: props4.toolbarColor,
        disable: !editable.value,
        size: "sm"
      };
    });
    const buttonDef = computed(() => {
      const e = $q.lang.editor, i = $q.iconSet.editor;
      return {
        bold: { cmd: "bold", icon: i.bold, tip: e.bold, key: 66 },
        italic: { cmd: "italic", icon: i.italic, tip: e.italic, key: 73 },
        strike: { cmd: "strikeThrough", icon: i.strikethrough, tip: e.strikethrough, key: 83 },
        underline: { cmd: "underline", icon: i.underline, tip: e.underline, key: 85 },
        unordered: { cmd: "insertUnorderedList", icon: i.unorderedList, tip: e.unorderedList },
        ordered: { cmd: "insertOrderedList", icon: i.orderedList, tip: e.orderedList },
        subscript: { cmd: "subscript", icon: i.subscript, tip: e.subscript, htmlTip: "x<subscript>2</subscript>" },
        superscript: { cmd: "superscript", icon: i.superscript, tip: e.superscript, htmlTip: "x<superscript>2</superscript>" },
        link: { cmd: "link", disable: (eVm2) => eVm2.caret && !eVm2.caret.can("link"), icon: i.hyperlink, tip: e.hyperlink, key: 76 },
        fullscreen: { cmd: "fullscreen", icon: i.toggleFullscreen, tip: e.toggleFullscreen, key: 70 },
        viewsource: { cmd: "viewsource", icon: i.viewSource, tip: e.viewSource },
        quote: { cmd: "formatBlock", param: "BLOCKQUOTE", icon: i.quote, tip: e.quote, key: 81 },
        left: { cmd: "justifyLeft", icon: i.left, tip: e.left },
        center: { cmd: "justifyCenter", icon: i.center, tip: e.center },
        right: { cmd: "justifyRight", icon: i.right, tip: e.right },
        justify: { cmd: "justifyFull", icon: i.justify, tip: e.justify },
        print: { type: "no-state", cmd: "print", icon: i.print, tip: e.print, key: 80 },
        outdent: { type: "no-state", disable: (eVm2) => eVm2.caret && !eVm2.caret.can("outdent"), cmd: "outdent", icon: i.outdent, tip: e.outdent },
        indent: { type: "no-state", disable: (eVm2) => eVm2.caret && !eVm2.caret.can("indent"), cmd: "indent", icon: i.indent, tip: e.indent },
        removeFormat: { type: "no-state", cmd: "removeFormat", icon: i.removeFormat, tip: e.removeFormat },
        hr: { type: "no-state", cmd: "insertHorizontalRule", icon: i.hr, tip: e.hr },
        undo: { type: "no-state", cmd: "undo", icon: i.undo, tip: e.undo, key: 90 },
        redo: { type: "no-state", cmd: "redo", icon: i.redo, tip: e.redo, key: 89 },
        h1: { cmd: "formatBlock", param: "H1", icon: i.heading1 || i.heading, tip: e.heading1, htmlTip: `<h1 class="q-ma-none">${e.heading1}</h1>` },
        h2: { cmd: "formatBlock", param: "H2", icon: i.heading2 || i.heading, tip: e.heading2, htmlTip: `<h2 class="q-ma-none">${e.heading2}</h2>` },
        h3: { cmd: "formatBlock", param: "H3", icon: i.heading3 || i.heading, tip: e.heading3, htmlTip: `<h3 class="q-ma-none">${e.heading3}</h3>` },
        h4: { cmd: "formatBlock", param: "H4", icon: i.heading4 || i.heading, tip: e.heading4, htmlTip: `<h4 class="q-ma-none">${e.heading4}</h4>` },
        h5: { cmd: "formatBlock", param: "H5", icon: i.heading5 || i.heading, tip: e.heading5, htmlTip: `<h5 class="q-ma-none">${e.heading5}</h5>` },
        h6: { cmd: "formatBlock", param: "H6", icon: i.heading6 || i.heading, tip: e.heading6, htmlTip: `<h6 class="q-ma-none">${e.heading6}</h6>` },
        p: { cmd: "formatBlock", param: props4.paragraphTag, icon: i.heading, tip: e.paragraph },
        code: { cmd: "formatBlock", param: "PRE", icon: i.code, htmlTip: `<code>${e.code}</code>` },
        "size-1": { cmd: "fontSize", param: "1", icon: i.size1 || i.size, tip: e.size1, htmlTip: `<font size="1">${e.size1}</font>` },
        "size-2": { cmd: "fontSize", param: "2", icon: i.size2 || i.size, tip: e.size2, htmlTip: `<font size="2">${e.size2}</font>` },
        "size-3": { cmd: "fontSize", param: "3", icon: i.size3 || i.size, tip: e.size3, htmlTip: `<font size="3">${e.size3}</font>` },
        "size-4": { cmd: "fontSize", param: "4", icon: i.size4 || i.size, tip: e.size4, htmlTip: `<font size="4">${e.size4}</font>` },
        "size-5": { cmd: "fontSize", param: "5", icon: i.size5 || i.size, tip: e.size5, htmlTip: `<font size="5">${e.size5}</font>` },
        "size-6": { cmd: "fontSize", param: "6", icon: i.size6 || i.size, tip: e.size6, htmlTip: `<font size="6">${e.size6}</font>` },
        "size-7": { cmd: "fontSize", param: "7", icon: i.size7 || i.size, tip: e.size7, htmlTip: `<font size="7">${e.size7}</font>` }
      };
    });
    const buttons = computed(() => {
      const userDef = props4.definitions || {};
      const def2 = props4.definitions || props4.fonts ? extend(
        true,
        {},
        buttonDef.value,
        userDef,
        getFonts(
          defaultFont,
          $q.lang.editor.defaultFont,
          $q.iconSet.editor.font,
          props4.fonts
        )
      ) : buttonDef.value;
      return props4.toolbar.map(
        (group) => group.map((token2) => {
          if (token2.options) {
            return {
              type: "dropdown",
              icon: token2.icon,
              label: token2.label,
              size: "sm",
              dense: true,
              fixedLabel: token2.fixedLabel,
              fixedIcon: token2.fixedIcon,
              highlight: token2.highlight,
              list: token2.list,
              options: token2.options.map((item) => def2[item])
            };
          }
          const obj = def2[token2];
          if (obj) {
            return obj.type === "no-state" || userDef[token2] && (obj.cmd === void 0 || buttonDef.value[obj.cmd] && buttonDef.value[obj.cmd].type === "no-state") ? obj : Object.assign({ type: "toggle" }, obj);
          } else {
            return {
              type: "slot",
              slot: token2
            };
          }
        })
      );
    });
    const eVm = {
      $q,
      props: props4,
      slots,
      emit: emit2,
      // caret (will get injected after mount)
      inFullscreen,
      toggleFullscreen,
      runCmd,
      isViewingSource,
      editLinkUrl,
      toolbarBackgroundClass,
      buttonProps,
      contentRef,
      buttons,
      setContent
    };
    watch(() => props4.modelValue, (v2) => {
      if (lastEmit !== v2) {
        lastEmit = v2;
        setContent(v2, true);
      }
    });
    watch(editLinkUrl, (v2) => {
      emit2(`link${v2 ? "Show" : "Hide"}`);
    });
    const hasToolbar = computed(() => props4.toolbar && props4.toolbar.length !== 0);
    const keys = computed(() => {
      const k = {}, add2 = (btn) => {
        if (btn.key) {
          k[btn.key] = {
            cmd: btn.cmd,
            param: btn.param
          };
        }
      };
      buttons.value.forEach((group) => {
        group.forEach((token2) => {
          if (token2.options) {
            token2.options.forEach(add2);
          } else {
            add2(token2);
          }
        });
      });
      return k;
    });
    const innerStyle = computed(() => inFullscreen.value ? props4.contentStyle : [
      {
        minHeight: props4.minHeight,
        height: props4.height,
        maxHeight: props4.maxHeight
      },
      props4.contentStyle
    ]);
    const classes = computed(
      () => `q-editor q-editor--${isViewingSource.value === true ? "source" : "default"}` + (props4.disable === true ? " disabled" : "") + (inFullscreen.value === true ? " fullscreen column" : "") + (props4.square === true ? " q-editor--square no-border-radius" : "") + (props4.flat === true ? " q-editor--flat" : "") + (props4.dense === true ? " q-editor--dense" : "") + (isDark.value === true ? " q-editor--dark q-dark" : "")
    );
    const innerClass = computed(() => [
      props4.contentClass,
      "q-editor__content",
      { col: inFullscreen.value, "overflow-auto": inFullscreen.value || props4.maxHeight }
    ]);
    const attributes = computed(() => props4.disable === true ? { "aria-disabled": "true" } : {});
    function onInput() {
      if (contentRef.value !== null) {
        const prop = `inner${isViewingSource.value === true ? "Text" : "HTML"}`;
        const val = contentRef.value[prop];
        if (val !== props4.modelValue) {
          lastEmit = val;
          emit2("update:modelValue", val);
        }
      }
    }
    function onKeydown2(e) {
      emit2("keydown", e);
      if (e.ctrlKey !== true || shouldIgnoreKey(e) === true) {
        refreshToolbar();
        return;
      }
      const key = e.keyCode;
      const target2 = keys.value[key];
      if (target2 !== void 0) {
        const { cmd, param } = target2;
        stopAndPrevent(e);
        runCmd(cmd, param, false);
      }
    }
    function onClick(e) {
      refreshToolbar();
      emit2("click", e);
    }
    function onBlur2(e) {
      if (contentRef.value !== null) {
        const { scrollTop, scrollHeight } = contentRef.value;
        offsetBottom = scrollHeight - scrollTop;
      }
      eVm.caret.save();
      emit2("blur", e);
    }
    function onFocus(e) {
      nextTick(() => {
        if (contentRef.value !== null && offsetBottom !== void 0) {
          contentRef.value.scrollTop = contentRef.value.scrollHeight - offsetBottom;
        }
      });
      emit2("focus", e);
    }
    function onFocusin(e) {
      const root = rootRef.value;
      if (root !== null && root.contains(e.target) === true && (e.relatedTarget === null || root.contains(e.relatedTarget) !== true)) {
        const prop = `inner${isViewingSource.value === true ? "Text" : "HTML"}`;
        eVm.caret.restorePosition(contentRef.value[prop].length);
        refreshToolbar();
      }
    }
    function onFocusout(e) {
      const root = rootRef.value;
      if (root !== null && root.contains(e.target) === true && (e.relatedTarget === null || root.contains(e.relatedTarget) !== true)) {
        eVm.caret.savePosition();
        refreshToolbar();
      }
    }
    function onPointerStart() {
      offsetBottom = void 0;
    }
    function onSelectionchange(e) {
      eVm.caret.save();
    }
    function setContent(v2, restorePosition) {
      if (contentRef.value !== null) {
        if (restorePosition === true) {
          eVm.caret.savePosition();
        }
        const prop = `inner${isViewingSource.value === true ? "Text" : "HTML"}`;
        contentRef.value[prop] = v2;
        if (restorePosition === true) {
          eVm.caret.restorePosition(contentRef.value[prop].length);
          refreshToolbar();
        }
      }
    }
    function runCmd(cmd, param, update6 = true) {
      focus();
      eVm.caret.restore();
      eVm.caret.apply(cmd, param, () => {
        focus();
        eVm.caret.save();
        if (update6) {
          refreshToolbar();
        }
      });
    }
    function refreshToolbar() {
      setTimeout(() => {
        editLinkUrl.value = null;
        proxy.$forceUpdate();
      }, 1);
    }
    function focus() {
      addFocusFn(() => {
        contentRef.value !== null && contentRef.value.focus({ preventScroll: true });
      });
    }
    function getContentEl() {
      return contentRef.value;
    }
    onMounted(() => {
      eVm.caret = proxy.caret = new Caret(contentRef.value, eVm);
      setContent(props4.modelValue);
      refreshToolbar();
      document.addEventListener("selectionchange", onSelectionchange);
    });
    onBeforeUnmount(() => {
      document.removeEventListener("selectionchange", onSelectionchange);
    });
    Object.assign(proxy, {
      runCmd,
      refreshToolbar,
      focus,
      getContentEl
    });
    return () => {
      let toolbars;
      if (hasToolbar.value) {
        const bars = [
          h("div", {
            key: "qedt_top",
            class: "q-editor__toolbar row no-wrap scroll-x" + toolbarBackgroundClass.value
          }, getToolbar(eVm))
        ];
        editLinkUrl.value !== null && bars.push(
          h("div", {
            key: "qedt_btm",
            class: "q-editor__toolbar row no-wrap items-center scroll-x" + toolbarBackgroundClass.value
          }, getLinkEditor(eVm))
        );
        toolbars = h("div", {
          key: "toolbar_ctainer",
          class: "q-editor__toolbars-container"
        }, bars);
      }
      return h("div", {
        ref: rootRef,
        class: classes.value,
        style: { height: inFullscreen.value === true ? "100%" : null },
        ...attributes.value,
        onFocusin,
        onFocusout
      }, [
        toolbars,
        h("div", {
          ref: contentRef,
          style: innerStyle.value,
          class: innerClass.value,
          contenteditable: editable.value,
          placeholder: props4.placeholder,
          ...{},
          ...splitAttrs.listeners.value,
          onInput,
          onKeydown: onKeydown2,
          onClick,
          onBlur: onBlur2,
          onFocus,
          // clean saved scroll position
          onMousedown: onPointerStart,
          onTouchstartPassive: onPointerStart
        })
      ]);
    };
  }
});
var QItemLabel_default = createComponent({
  name: "QItemLabel",
  props: {
    overline: Boolean,
    caption: Boolean,
    header: Boolean,
    lines: [Number, String]
  },
  setup(props4, { slots }) {
    const parsedLines = computed(() => parseInt(props4.lines, 10));
    const classes = computed(
      () => "q-item__label" + (props4.overline === true ? " q-item__label--overline text-overline" : "") + (props4.caption === true ? " q-item__label--caption text-caption" : "") + (props4.header === true ? " q-item__label--header" : "") + (parsedLines.value === 1 ? " ellipsis" : "")
    );
    const style2 = computed(() => {
      return props4.lines !== void 0 && parsedLines.value > 1 ? {
        overflow: "hidden",
        display: "-webkit-box",
        "-webkit-box-orient": "vertical",
        "-webkit-line-clamp": parsedLines.value
      } : null;
    });
    return () => h("div", {
      style: style2.value,
      class: classes.value
    }, hSlot(slots.default));
  }
});
var QSlideTransition_default = createComponent({
  name: "QSlideTransition",
  props: {
    appear: Boolean,
    duration: {
      type: Number,
      default: 300
    }
  },
  emits: ["show", "hide"],
  setup(props4, { slots, emit: emit2 }) {
    let animating = false, doneFn, element;
    let timer2 = null, timerFallback = null, animListener, lastEvent;
    function cleanup() {
      doneFn && doneFn();
      doneFn = null;
      animating = false;
      if (timer2 !== null) {
        clearTimeout(timer2);
        timer2 = null;
      }
      if (timerFallback !== null) {
        clearTimeout(timerFallback);
        timerFallback = null;
      }
      element !== void 0 && element.removeEventListener("transitionend", animListener);
      animListener = null;
    }
    function begin(el, height2, done) {
      if (height2 !== void 0) {
        el.style.height = `${height2}px`;
      }
      el.style.transition = `height ${props4.duration}ms cubic-bezier(.25, .8, .50, 1)`;
      animating = true;
      doneFn = done;
    }
    function end(el, event) {
      el.style.overflowY = null;
      el.style.height = null;
      el.style.transition = null;
      cleanup();
      event !== lastEvent && emit2(event);
    }
    function onEnter(el, done) {
      let pos = 0;
      element = el;
      if (animating === true) {
        cleanup();
        pos = el.offsetHeight === el.scrollHeight ? 0 : void 0;
      } else {
        lastEvent = "hide";
        el.style.overflowY = "hidden";
      }
      begin(el, pos, done);
      timer2 = setTimeout(() => {
        timer2 = null;
        el.style.height = `${el.scrollHeight}px`;
        animListener = (evt) => {
          timerFallback = null;
          if (Object(evt) !== evt || evt.target === el) {
            end(el, "show");
          }
        };
        el.addEventListener("transitionend", animListener);
        timerFallback = setTimeout(animListener, props4.duration * 1.1);
      }, 100);
    }
    function onLeave(el, done) {
      let pos;
      element = el;
      if (animating === true) {
        cleanup();
      } else {
        lastEvent = "show";
        el.style.overflowY = "hidden";
        pos = el.scrollHeight;
      }
      begin(el, pos, done);
      timer2 = setTimeout(() => {
        timer2 = null;
        el.style.height = 0;
        animListener = (evt) => {
          timerFallback = null;
          if (Object(evt) !== evt || evt.target === el) {
            end(el, "hide");
          }
        };
        el.addEventListener("transitionend", animListener);
        timerFallback = setTimeout(animListener, props4.duration * 1.1);
      }, 100);
    }
    onBeforeUnmount(() => {
      animating === true && cleanup();
    });
    return () => h(Transition, {
      css: false,
      appear: props4.appear,
      onEnter,
      onLeave
    }, slots.default);
  }
});
var insetMap = {
  true: "inset",
  item: "item-inset",
  "item-thumbnail": "item-thumbnail-inset"
};
var margins = {
  xs: 2,
  sm: 4,
  md: 8,
  lg: 16,
  xl: 24
};
var QSeparator_default = createComponent({
  name: "QSeparator",
  props: {
    ...useDarkProps,
    spaced: [Boolean, String],
    inset: [Boolean, String],
    vertical: Boolean,
    color: String,
    size: String
  },
  setup(props4) {
    const vm2 = getCurrentInstance();
    const isDark = use_dark_default(props4, vm2.proxy.$q);
    const orientation = computed(() => props4.vertical === true ? "vertical" : "horizontal");
    const orientClass = computed(() => ` q-separator--${orientation.value}`);
    const insetClass = computed(() => props4.inset !== false ? `${orientClass.value}-${insetMap[props4.inset]}` : "");
    const classes = computed(
      () => `q-separator${orientClass.value}${insetClass.value}` + (props4.color !== void 0 ? ` bg-${props4.color}` : "") + (isDark.value === true ? " q-separator--dark" : "")
    );
    const style2 = computed(() => {
      const acc = {};
      if (props4.size !== void 0) {
        acc[props4.vertical === true ? "width" : "height"] = props4.size;
      }
      if (props4.spaced !== false) {
        const size2 = props4.spaced === true ? `${margins.md}px` : props4.spaced in margins ? `${margins[props4.spaced]}px` : props4.spaced;
        const dir = props4.vertical === true ? ["Left", "Right"] : ["Top", "Bottom"];
        acc[`margin${dir[0]}`] = acc[`margin${dir[1]}`] = size2;
      }
      return acc;
    });
    return () => h("hr", {
      class: classes.value,
      style: style2.value,
      "aria-orientation": orientation.value
    });
  }
});
var itemGroups = shallowReactive({});
var LINK_PROPS = Object.keys(useRouterLinkProps);
createComponent({
  name: "QExpansionItem",
  props: {
    ...useRouterLinkProps,
    ...useModelToggleProps,
    ...useDarkProps,
    icon: String,
    label: String,
    labelLines: [Number, String],
    caption: String,
    captionLines: [Number, String],
    dense: Boolean,
    toggleAriaLabel: String,
    expandIcon: String,
    expandedIcon: String,
    expandIconClass: [Array, String, Object],
    duration: {},
    headerInsetLevel: Number,
    contentInsetLevel: Number,
    expandSeparator: Boolean,
    defaultOpened: Boolean,
    hideExpandIcon: Boolean,
    expandIconToggle: Boolean,
    switchToggleSide: Boolean,
    denseToggle: Boolean,
    group: String,
    popup: Boolean,
    headerStyle: [Array, String, Object],
    headerClass: [Array, String, Object]
  },
  emits: [
    ...useModelToggleEmits,
    "click",
    "afterShow",
    "afterHide"
  ],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = use_dark_default(props4, $q);
    const showing = ref(
      props4.modelValue !== null ? props4.modelValue : props4.defaultOpened
    );
    const blurTargetRef = ref(null);
    const targetUid = use_id_default();
    const { show, hide, toggle } = use_model_toggle_default({ showing });
    let uniqueId, exitGroup;
    const classes = computed(
      () => `q-expansion-item q-item-type q-expansion-item--${showing.value === true ? "expanded" : "collapsed"} q-expansion-item--${props4.popup === true ? "popup" : "standard"}`
    );
    const contentStyle = computed(() => {
      if (props4.contentInsetLevel === void 0) {
        return null;
      }
      const dir = $q.lang.rtl === true ? "Right" : "Left";
      return {
        ["padding" + dir]: props4.contentInsetLevel * 56 + "px"
      };
    });
    const hasLink = computed(
      () => props4.disable !== true && (props4.href !== void 0 || props4.to !== void 0 && props4.to !== null && props4.to !== "")
    );
    const linkProps = computed(() => {
      const acc = {};
      LINK_PROPS.forEach((key) => {
        acc[key] = props4[key];
      });
      return acc;
    });
    const isClickable = computed(
      () => hasLink.value === true || props4.expandIconToggle !== true
    );
    const expansionIcon = computed(() => props4.expandedIcon !== void 0 && showing.value === true ? props4.expandedIcon : props4.expandIcon || $q.iconSet.expansionItem[props4.denseToggle === true ? "denseIcon" : "icon"]);
    const activeToggleIcon = computed(
      () => props4.disable !== true && (hasLink.value === true || props4.expandIconToggle === true)
    );
    const headerSlotScope = computed(() => ({
      expanded: showing.value === true,
      detailsId: targetUid.value,
      toggle,
      show,
      hide
    }));
    const toggleAriaAttrs = computed(() => {
      const toggleAriaLabel = props4.toggleAriaLabel !== void 0 ? props4.toggleAriaLabel : $q.lang.label[showing.value === true ? "collapse" : "expand"](props4.label);
      return {
        role: "button",
        "aria-expanded": showing.value === true ? "true" : "false",
        "aria-controls": targetUid.value,
        "aria-label": toggleAriaLabel
      };
    });
    watch(() => props4.group, (name2) => {
      exitGroup !== void 0 && exitGroup();
      name2 !== void 0 && enterGroup();
    });
    function onHeaderClick(e) {
      hasLink.value !== true && toggle(e);
      emit2("click", e);
    }
    function toggleIconKeyboard(e) {
      e.keyCode === 13 && toggleIcon(e, true);
    }
    function toggleIcon(e, keyboard) {
      keyboard !== true && blurTargetRef.value !== null && blurTargetRef.value.focus();
      toggle(e);
      stopAndPrevent(e);
    }
    function onShow() {
      emit2("afterShow");
    }
    function onHide() {
      emit2("afterHide");
    }
    function enterGroup() {
      if (uniqueId === void 0) {
        uniqueId = uid_default();
      }
      if (showing.value === true) {
        itemGroups[props4.group] = uniqueId;
      }
      const show2 = watch(showing, (val) => {
        if (val === true) {
          itemGroups[props4.group] = uniqueId;
        } else if (itemGroups[props4.group] === uniqueId) {
          delete itemGroups[props4.group];
        }
      });
      const group = watch(
        () => itemGroups[props4.group],
        (val, oldVal) => {
          if (oldVal === uniqueId && val !== void 0 && val !== uniqueId) {
            hide();
          }
        }
      );
      exitGroup = () => {
        show2();
        group();
        if (itemGroups[props4.group] === uniqueId) {
          delete itemGroups[props4.group];
        }
        exitGroup = void 0;
      };
    }
    function getToggleIcon() {
      const data = {
        class: [
          `q-focusable relative-position cursor-pointer${props4.denseToggle === true && props4.switchToggleSide === true ? " items-end" : ""}`,
          props4.expandIconClass
        ],
        side: props4.switchToggleSide !== true,
        avatar: props4.switchToggleSide
      };
      const child = [
        h(QIcon_default, {
          class: "q-expansion-item__toggle-icon" + (props4.expandedIcon === void 0 && showing.value === true ? " q-expansion-item__toggle-icon--rotated" : ""),
          name: expansionIcon.value
        })
      ];
      if (activeToggleIcon.value === true) {
        Object.assign(data, {
          tabindex: 0,
          ...toggleAriaAttrs.value,
          onClick: toggleIcon,
          onKeyup: toggleIconKeyboard
        });
        child.unshift(
          h("div", {
            ref: blurTargetRef,
            class: "q-expansion-item__toggle-focus q-icon q-focus-helper q-focus-helper--rounded",
            tabindex: -1
          })
        );
      }
      return h(QItemSection_default, data, () => child);
    }
    function getHeaderChild() {
      let child;
      if (slots.header !== void 0) {
        child = [].concat(slots.header(headerSlotScope.value));
      } else {
        child = [
          h(QItemSection_default, () => [
            h(QItemLabel_default, { lines: props4.labelLines }, () => props4.label || ""),
            props4.caption ? h(QItemLabel_default, { lines: props4.captionLines, caption: true }, () => props4.caption) : null
          ])
        ];
        props4.icon && child[props4.switchToggleSide === true ? "push" : "unshift"](
          h(QItemSection_default, {
            side: props4.switchToggleSide === true,
            avatar: props4.switchToggleSide !== true
          }, () => h(QIcon_default, { name: props4.icon }))
        );
      }
      if (props4.disable !== true && props4.hideExpandIcon !== true) {
        child[props4.switchToggleSide === true ? "unshift" : "push"](
          getToggleIcon()
        );
      }
      return child;
    }
    function getHeader() {
      const data = {
        ref: "item",
        style: props4.headerStyle,
        class: props4.headerClass,
        dark: isDark.value,
        disable: props4.disable,
        dense: props4.dense,
        insetLevel: props4.headerInsetLevel
      };
      if (isClickable.value === true) {
        data.clickable = true;
        data.onClick = onHeaderClick;
        Object.assign(
          data,
          hasLink.value === true ? linkProps.value : toggleAriaAttrs.value
        );
      }
      return h(QItem_default, data, getHeaderChild);
    }
    function getTransitionChild() {
      return withDirectives(
        h("div", {
          key: "e-content",
          class: "q-expansion-item__content relative-position",
          style: contentStyle.value,
          id: targetUid.value
        }, hSlot(slots.default)),
        [[
          vShow,
          showing.value
        ]]
      );
    }
    function getContent() {
      const node = [
        getHeader(),
        h(QSlideTransition_default, {
          duration: props4.duration,
          onShow,
          onHide
        }, getTransitionChild)
      ];
      if (props4.expandSeparator === true) {
        node.push(
          h(QSeparator_default, {
            class: "q-expansion-item__border q-expansion-item__border--top absolute-top",
            dark: isDark.value
          }),
          h(QSeparator_default, {
            class: "q-expansion-item__border q-expansion-item__border--bottom absolute-bottom",
            dark: isDark.value
          })
        );
      }
      return node;
    }
    props4.group !== void 0 && enterGroup();
    onBeforeUnmount(() => {
      exitGroup !== void 0 && exitGroup();
    });
    return () => h("div", { class: classes.value }, [
      h("div", { class: "q-expansion-item__container relative-position" }, getContent())
    ]);
  }
});
var labelPositions = ["top", "right", "bottom", "left"];
var useFabProps = {
  type: {
    type: String,
    default: "a"
  },
  outline: Boolean,
  push: Boolean,
  flat: Boolean,
  unelevated: Boolean,
  color: String,
  textColor: String,
  glossy: Boolean,
  square: Boolean,
  padding: String,
  label: {
    type: [String, Number],
    default: ""
  },
  labelPosition: {
    type: String,
    default: "right",
    validator: (v2) => labelPositions.includes(v2)
  },
  externalLabel: Boolean,
  hideLabel: {
    type: Boolean
  },
  labelClass: [Array, String, Object],
  labelStyle: [Array, String, Object],
  disable: Boolean,
  tabindex: [Number, String]
};
function use_fab_default(props4, showing) {
  return {
    formClass: computed(
      () => `q-fab--form-${props4.square === true ? "square" : "rounded"}`
    ),
    stacked: computed(
      () => props4.externalLabel === false && ["top", "bottom"].includes(props4.labelPosition)
    ),
    labelProps: computed(() => {
      if (props4.externalLabel === true) {
        const hideLabel = props4.hideLabel === null ? showing.value === false : props4.hideLabel;
        return {
          action: "push",
          data: {
            class: [
              props4.labelClass,
              `q-fab__label q-tooltip--style q-fab__label--external q-fab__label--external-${props4.labelPosition}` + (hideLabel === true ? " q-fab__label--external-hidden" : "")
            ],
            style: props4.labelStyle
          }
        };
      }
      return {
        action: ["left", "top"].includes(props4.labelPosition) ? "unshift" : "push",
        data: {
          class: [
            props4.labelClass,
            `q-fab__label q-fab__label--internal q-fab__label--internal-${props4.labelPosition}` + (props4.hideLabel === true ? " q-fab__label--internal-hidden" : "")
          ],
          style: props4.labelStyle
        }
      };
    })
  };
}
var directions = ["up", "right", "down", "left"];
var alignValues4 = ["left", "center", "right"];
createComponent({
  name: "QFab",
  props: {
    ...useFabProps,
    ...useModelToggleProps,
    icon: String,
    activeIcon: String,
    hideIcon: Boolean,
    hideLabel: {
      ...useFabProps.hideLabel,
      default: null
    },
    direction: {
      type: String,
      default: "right",
      validator: (v2) => directions.includes(v2)
    },
    persistent: Boolean,
    verticalActionsAlign: {
      type: String,
      default: "center",
      validator: (v2) => alignValues4.includes(v2)
    }
  },
  emits: useModelToggleEmits,
  setup(props4, { slots }) {
    const triggerRef = ref(null);
    const showing = ref(props4.modelValue === true);
    const targetUid = use_id_default();
    const { proxy: { $q } } = getCurrentInstance();
    const { formClass, labelProps } = use_fab_default(props4, showing);
    const hideOnRouteChange = computed(() => props4.persistent !== true);
    const { hide, toggle } = use_model_toggle_default({
      showing,
      hideOnRouteChange
    });
    const slotScope = computed(() => ({ opened: showing.value }));
    const classes = computed(
      () => `q-fab z-fab row inline justify-center q-fab--align-${props4.verticalActionsAlign} ${formClass.value}` + (showing.value === true ? " q-fab--opened" : " q-fab--closed")
    );
    const actionClass = computed(
      () => `q-fab__actions flex no-wrap inline q-fab__actions--${props4.direction} q-fab__actions--${showing.value === true ? "opened" : "closed"}`
    );
    const actionAttrs = computed(() => {
      const attrs = {
        id: targetUid.value,
        role: "menu"
      };
      if (showing.value !== true) {
        attrs["aria-hidden"] = "true";
      }
      return attrs;
    });
    const iconHolderClass = computed(
      () => `q-fab__icon-holder  q-fab__icon-holder--${showing.value === true ? "opened" : "closed"}`
    );
    function getIcon(kebab, camel) {
      const slotFn = slots[kebab];
      const classes2 = `q-fab__${kebab} absolute-full`;
      return slotFn === void 0 ? h(QIcon_default, { class: classes2, name: props4[camel] || $q.iconSet.fab[camel] }) : h("div", { class: classes2 }, slotFn(slotScope.value));
    }
    function getTriggerContent() {
      const child = [];
      props4.hideIcon !== true && child.push(
        h("div", { class: iconHolderClass.value }, [
          getIcon("icon", "icon"),
          getIcon("active-icon", "activeIcon")
        ])
      );
      if (props4.label !== "" || slots.label !== void 0) {
        child[labelProps.value.action](
          h("div", labelProps.value.data, slots.label !== void 0 ? slots.label(slotScope.value) : [props4.label])
        );
      }
      return hMergeSlot(slots.tooltip, child);
    }
    provide(fabKey, {
      showing,
      onChildClick(evt) {
        hide(evt);
        if (triggerRef.value !== null) {
          triggerRef.value.$el.focus();
        }
      }
    });
    return () => h("div", {
      class: classes.value
    }, [
      h(QBtn_default, {
        ref: triggerRef,
        class: formClass.value,
        ...props4,
        noWrap: true,
        stack: props4.stacked,
        align: void 0,
        icon: void 0,
        label: void 0,
        noCaps: true,
        fab: true,
        "aria-expanded": showing.value === true ? "true" : "false",
        "aria-haspopup": "true",
        "aria-controls": targetUid.value,
        onClick: toggle
      }, getTriggerContent),
      h("div", { class: actionClass.value, ...actionAttrs.value }, hSlot(slots.default))
    ]);
  }
});
var anchorMap = {
  start: "self-end",
  center: "self-center",
  end: "self-start"
};
var anchorValues = Object.keys(anchorMap);
createComponent({
  name: "QFabAction",
  props: {
    ...useFabProps,
    icon: {
      type: String,
      default: ""
    },
    anchor: {
      type: String,
      validator: (v2) => anchorValues.includes(v2)
    },
    to: [String, Object],
    replace: Boolean
  },
  emits: ["click"],
  setup(props4, { slots, emit: emit2 }) {
    const $fab = inject(fabKey, () => ({
      showing: { value: true },
      onChildClick: noop
    }));
    const { formClass, labelProps } = use_fab_default(props4, $fab.showing);
    const classes = computed(() => {
      const align = anchorMap[props4.anchor];
      return formClass.value + (align !== void 0 ? ` ${align}` : "");
    });
    const isDisabled = computed(
      () => props4.disable === true || $fab.showing.value !== true
    );
    function click(e) {
      $fab.onChildClick(e);
      emit2("click", e);
    }
    function getContent() {
      const child = [];
      if (slots.icon !== void 0) {
        child.push(slots.icon());
      } else if (props4.icon !== "") {
        child.push(
          h(QIcon_default, { name: props4.icon })
        );
      }
      if (props4.label !== "" || slots.label !== void 0) {
        child[labelProps.value.action](
          h("div", labelProps.value.data, slots.label !== void 0 ? slots.label() : [props4.label])
        );
      }
      return hMergeSlot(slots.default, child);
    }
    const vm2 = getCurrentInstance();
    Object.assign(vm2.proxy, { click });
    return () => h(QBtn_default, {
      class: classes.value,
      ...props4,
      noWrap: true,
      stack: props4.stacked,
      icon: void 0,
      label: void 0,
      noCaps: true,
      fabMini: true,
      disable: isDisabled.value,
      onClick: click
    }, getContent);
  }
});
function use_form_child_default({ validate, resetValidation, requiresQForm }) {
  const $form = inject(formKey, false);
  if ($form !== false) {
    const { props: props4, proxy } = getCurrentInstance();
    Object.assign(proxy, { validate, resetValidation });
    watch(() => props4.disable, (val) => {
      if (val === true) {
        typeof resetValidation === "function" && resetValidation();
        $form.unbindComponent(proxy);
      } else {
        $form.bindComponent(proxy);
      }
    });
    onMounted(() => {
      props4.disable !== true && $form.bindComponent(proxy);
    });
    onBeforeUnmount(() => {
      props4.disable !== true && $form.unbindComponent(proxy);
    });
  } else if (requiresQForm === true) {
    console.error("Parent QForm not found on useFormChild()!");
  }
}
var lazyRulesValues = [true, false, "ondemand"];
var useValidateProps = {
  modelValue: {},
  error: {
    type: Boolean,
    default: null
  },
  errorMessage: String,
  noErrorIcon: Boolean,
  rules: Array,
  reactiveRules: Boolean,
  lazyRules: {
    type: [Boolean, String],
    default: false,
    // statement unneeded but avoids future vue implementation changes
    validator: (v2) => lazyRulesValues.includes(v2)
  }
};
function use_validate_default(focused, innerLoading) {
  const { props: props4, proxy } = getCurrentInstance();
  const innerError = ref(false);
  const innerErrorMessage = ref(null);
  const isDirtyModel = ref(false);
  use_form_child_default({ validate, resetValidation });
  let validateIndex = 0, unwatchRules;
  const hasRules = computed(
    () => props4.rules !== void 0 && props4.rules !== null && props4.rules.length !== 0
  );
  const canDebounceValidate = computed(() => props4.disable !== true && hasRules.value === true && innerLoading.value === false);
  const hasError = computed(
    () => props4.error === true || innerError.value === true
  );
  const errorMessage = computed(() => typeof props4.errorMessage === "string" && props4.errorMessage.length !== 0 ? props4.errorMessage : innerErrorMessage.value);
  watch(() => props4.modelValue, () => {
    isDirtyModel.value = true;
    if (canDebounceValidate.value === true && props4.lazyRules === false) {
      debouncedValidate();
    }
  });
  function onRulesChange() {
    if (props4.lazyRules !== "ondemand" && canDebounceValidate.value === true && isDirtyModel.value === true) {
      debouncedValidate();
    }
  }
  watch(() => props4.reactiveRules, (val) => {
    if (val === true) {
      if (unwatchRules === void 0) {
        unwatchRules = watch(() => props4.rules, onRulesChange, { immediate: true, deep: true });
      }
    } else if (unwatchRules !== void 0) {
      unwatchRules();
      unwatchRules = void 0;
    }
  }, { immediate: true });
  watch(() => props4.lazyRules, onRulesChange);
  watch(focused, (val) => {
    if (val === true) {
      isDirtyModel.value = true;
    } else if (canDebounceValidate.value === true && props4.lazyRules !== "ondemand") {
      debouncedValidate();
    }
  });
  function resetValidation() {
    validateIndex++;
    innerLoading.value = false;
    isDirtyModel.value = false;
    innerError.value = false;
    innerErrorMessage.value = null;
    debouncedValidate.cancel();
  }
  function validate(val = props4.modelValue) {
    if (props4.disable === true || hasRules.value === false) {
      return true;
    }
    const index = ++validateIndex;
    const setDirty = innerLoading.value !== true ? () => {
      isDirtyModel.value = true;
    } : () => {
    };
    const update6 = (err, msg) => {
      err === true && setDirty();
      innerError.value = err;
      innerErrorMessage.value = msg || null;
      innerLoading.value = false;
    };
    const promises = [];
    for (let i = 0; i < props4.rules.length; i++) {
      const rule = props4.rules[i];
      let res;
      if (typeof rule === "function") {
        res = rule(val, testPattern);
      } else if (typeof rule === "string" && testPattern[rule] !== void 0) {
        res = testPattern[rule](val);
      }
      if (res === false || typeof res === "string") {
        update6(true, res);
        return false;
      } else if (res !== true && res !== void 0) {
        promises.push(res);
      }
    }
    if (promises.length === 0) {
      update6(false);
      return true;
    }
    innerLoading.value = true;
    return Promise.all(promises).then(
      (res) => {
        if (res === void 0 || Array.isArray(res) === false || res.length === 0) {
          index === validateIndex && update6(false);
          return true;
        }
        const msg = res.find((r) => r === false || typeof r === "string");
        index === validateIndex && update6(msg !== void 0, msg);
        return msg === void 0;
      },
      (e) => {
        if (index === validateIndex) {
          console.error(e);
          update6(true);
        }
        return false;
      }
    );
  }
  const debouncedValidate = debounce_default(validate, 0);
  onBeforeUnmount(() => {
    unwatchRules !== void 0 && unwatchRules();
    debouncedValidate.cancel();
  });
  Object.assign(proxy, { resetValidation, validate });
  injectProp(proxy, "hasError", () => hasError.value);
  return {
    isDirtyModel,
    hasRules,
    hasError,
    errorMessage,
    validate,
    resetValidation
  };
}
function fieldValueIsFilled(val) {
  return val !== void 0 && val !== null && ("" + val).length !== 0;
}
var useNonInputFieldProps = {
  ...useDarkProps,
  ...useValidateProps,
  label: String,
  stackLabel: Boolean,
  hint: String,
  hideHint: Boolean,
  prefix: String,
  suffix: String,
  labelColor: String,
  color: String,
  bgColor: String,
  filled: Boolean,
  outlined: Boolean,
  borderless: Boolean,
  standout: [Boolean, String],
  square: Boolean,
  loading: Boolean,
  labelSlot: Boolean,
  bottomSlots: Boolean,
  hideBottomSpace: Boolean,
  rounded: Boolean,
  dense: Boolean,
  itemAligned: Boolean,
  counter: Boolean,
  clearable: Boolean,
  clearIcon: String,
  disable: Boolean,
  readonly: Boolean,
  autofocus: Boolean,
  for: String
};
var useFieldProps = {
  ...useNonInputFieldProps,
  maxlength: [Number, String]
};
var useFieldEmits = ["update:modelValue", "clear", "focus", "blur"];
function useFieldState({ requiredForAttr = true, tagProp, changeEvent = false } = {}) {
  const { props: props4, proxy } = getCurrentInstance();
  const isDark = use_dark_default(props4, proxy.$q);
  const targetUid = use_id_default({
    required: requiredForAttr,
    getValue: () => props4.for
  });
  return {
    requiredForAttr,
    changeEvent,
    tag: tagProp === true ? computed(() => props4.tag) : { value: "label" },
    isDark,
    editable: computed(
      () => props4.disable !== true && props4.readonly !== true
    ),
    innerLoading: ref(false),
    focused: ref(false),
    hasPopupOpen: false,
    splitAttrs: use_split_attrs_default(),
    targetUid,
    rootRef: ref(null),
    targetRef: ref(null),
    controlRef: ref(null)
    /**
         * user supplied additionals:
    
         * innerValue - computed
         * floatingLabel - computed
         * inputRef - computed
    
         * fieldClass - computed
         * hasShadow - computed
    
         * controlEvents - Object with fn(e)
    
         * getControl - fn
         * getInnerAppend - fn
         * getControlChild - fn
         * getShadowControl - fn
         * showPopup - fn
         */
  };
}
function use_field_default(state) {
  const { props: props4, emit: emit2, slots, attrs, proxy } = getCurrentInstance();
  const { $q } = proxy;
  let focusoutTimer = null;
  if (state.hasValue === void 0) {
    state.hasValue = computed(() => fieldValueIsFilled(props4.modelValue));
  }
  if (state.emitValue === void 0) {
    state.emitValue = (value2) => {
      emit2("update:modelValue", value2);
    };
  }
  if (state.controlEvents === void 0) {
    state.controlEvents = {
      onFocusin: onControlFocusin,
      onFocusout: onControlFocusout
    };
  }
  Object.assign(state, {
    clearValue,
    onControlFocusin,
    onControlFocusout,
    focus
  });
  if (state.computedCounter === void 0) {
    state.computedCounter = computed(() => {
      if (props4.counter !== false) {
        const len = typeof props4.modelValue === "string" || typeof props4.modelValue === "number" ? ("" + props4.modelValue).length : Array.isArray(props4.modelValue) === true ? props4.modelValue.length : 0;
        const max = props4.maxlength !== void 0 ? props4.maxlength : props4.maxValues;
        return len + (max !== void 0 ? " / " + max : "");
      }
    });
  }
  const {
    isDirtyModel,
    hasRules,
    hasError,
    errorMessage,
    resetValidation
  } = use_validate_default(state.focused, state.innerLoading);
  const floatingLabel = state.floatingLabel !== void 0 ? computed(() => props4.stackLabel === true || state.focused.value === true || state.floatingLabel.value === true) : computed(() => props4.stackLabel === true || state.focused.value === true || state.hasValue.value === true);
  const shouldRenderBottom = computed(
    () => props4.bottomSlots === true || props4.hint !== void 0 || hasRules.value === true || props4.counter === true || props4.error !== null
  );
  const styleType = computed(() => {
    if (props4.filled === true) {
      return "filled";
    }
    if (props4.outlined === true) {
      return "outlined";
    }
    if (props4.borderless === true) {
      return "borderless";
    }
    if (props4.standout) {
      return "standout";
    }
    return "standard";
  });
  const classes = computed(
    () => `q-field row no-wrap items-start q-field--${styleType.value}` + (state.fieldClass !== void 0 ? ` ${state.fieldClass.value}` : "") + (props4.rounded === true ? " q-field--rounded" : "") + (props4.square === true ? " q-field--square" : "") + (floatingLabel.value === true ? " q-field--float" : "") + (hasLabel.value === true ? " q-field--labeled" : "") + (props4.dense === true ? " q-field--dense" : "") + (props4.itemAligned === true ? " q-field--item-aligned q-item-type" : "") + (state.isDark.value === true ? " q-field--dark" : "") + (state.getControl === void 0 ? " q-field--auto-height" : "") + (state.focused.value === true ? " q-field--focused" : "") + (hasError.value === true ? " q-field--error" : "") + (hasError.value === true || state.focused.value === true ? " q-field--highlighted" : "") + (props4.hideBottomSpace !== true && shouldRenderBottom.value === true ? " q-field--with-bottom" : "") + (props4.disable === true ? " q-field--disabled" : props4.readonly === true ? " q-field--readonly" : "")
  );
  const contentClass = computed(
    () => "q-field__control relative-position row no-wrap" + (props4.bgColor !== void 0 ? ` bg-${props4.bgColor}` : "") + (hasError.value === true ? " text-negative" : typeof props4.standout === "string" && props4.standout.length !== 0 && state.focused.value === true ? ` ${props4.standout}` : props4.color !== void 0 ? ` text-${props4.color}` : "")
  );
  const hasLabel = computed(
    () => props4.labelSlot === true || props4.label !== void 0
  );
  const labelClass = computed(
    () => "q-field__label no-pointer-events absolute ellipsis" + (props4.labelColor !== void 0 && hasError.value !== true ? ` text-${props4.labelColor}` : "")
  );
  const controlSlotScope = computed(() => ({
    id: state.targetUid.value,
    editable: state.editable.value,
    focused: state.focused.value,
    floatingLabel: floatingLabel.value,
    modelValue: props4.modelValue,
    emitValue: state.emitValue
  }));
  const attributes = computed(() => {
    const acc = {};
    if (state.targetUid.value) {
      acc.for = state.targetUid.value;
    }
    if (props4.disable === true) {
      acc["aria-disabled"] = "true";
    }
    return acc;
  });
  function focusHandler() {
    const el = document.activeElement;
    let target2 = state.targetRef !== void 0 && state.targetRef.value;
    if (target2 && (el === null || el.id !== state.targetUid.value)) {
      target2.hasAttribute("tabindex") === true || (target2 = target2.querySelector("[tabindex]"));
      if (target2 && target2 !== el) {
        target2.focus({ preventScroll: true });
      }
    }
  }
  function focus() {
    addFocusFn(focusHandler);
  }
  function blur() {
    removeFocusFn(focusHandler);
    const el = document.activeElement;
    if (el !== null && state.rootRef.value.contains(el)) {
      el.blur();
    }
  }
  function onControlFocusin(e) {
    if (focusoutTimer !== null) {
      clearTimeout(focusoutTimer);
      focusoutTimer = null;
    }
    if (state.editable.value === true && state.focused.value === false) {
      state.focused.value = true;
      emit2("focus", e);
    }
  }
  function onControlFocusout(e, then) {
    focusoutTimer !== null && clearTimeout(focusoutTimer);
    focusoutTimer = setTimeout(() => {
      focusoutTimer = null;
      if (document.hasFocus() === true && (state.hasPopupOpen === true || state.controlRef === void 0 || state.controlRef.value === null || state.controlRef.value.contains(document.activeElement) !== false)) {
        return;
      }
      if (state.focused.value === true) {
        state.focused.value = false;
        emit2("blur", e);
      }
      then !== void 0 && then();
    });
  }
  function clearValue(e) {
    stopAndPrevent(e);
    if ($q.platform.is.mobile !== true) {
      const el = state.targetRef !== void 0 && state.targetRef.value || state.rootRef.value;
      el.focus();
    } else if (state.rootRef.value.contains(document.activeElement) === true) {
      document.activeElement.blur();
    }
    if (props4.type === "file") {
      state.inputRef.value.value = null;
    }
    emit2("update:modelValue", null);
    state.changeEvent === true && emit2("change", null);
    emit2("clear", props4.modelValue);
    nextTick(() => {
      const isDirty2 = isDirtyModel.value;
      resetValidation();
      isDirtyModel.value = isDirty2;
    });
  }
  function onClearableKeyup(evt) {
    [13, 32].includes(evt.keyCode) && clearValue(evt);
  }
  function getContent() {
    const node = [];
    slots.prepend !== void 0 && node.push(
      h("div", {
        class: "q-field__prepend q-field__marginal row no-wrap items-center",
        key: "prepend",
        onClick: prevent
      }, slots.prepend())
    );
    node.push(
      h("div", {
        class: "q-field__control-container col relative-position row no-wrap q-anchor--skip"
      }, getControlContainer())
    );
    hasError.value === true && props4.noErrorIcon === false && node.push(
      getInnerAppendNode("error", [
        h(QIcon_default, { name: $q.iconSet.field.error, color: "negative" })
      ])
    );
    if (props4.loading === true || state.innerLoading.value === true) {
      node.push(
        getInnerAppendNode(
          "inner-loading-append",
          slots.loading !== void 0 ? slots.loading() : [h(QSpinner_default, { color: props4.color })]
        )
      );
    } else if (props4.clearable === true && state.hasValue.value === true && state.editable.value === true) {
      node.push(
        getInnerAppendNode("inner-clearable-append", [
          h(QIcon_default, {
            class: "q-field__focusable-action",
            name: props4.clearIcon || $q.iconSet.field.clear,
            tabindex: 0,
            role: "button",
            "aria-hidden": "false",
            "aria-label": $q.lang.label.clear,
            onKeyup: onClearableKeyup,
            onClick: clearValue
          })
        ])
      );
    }
    slots.append !== void 0 && node.push(
      h("div", {
        class: "q-field__append q-field__marginal row no-wrap items-center",
        key: "append",
        onClick: prevent
      }, slots.append())
    );
    state.getInnerAppend !== void 0 && node.push(
      getInnerAppendNode("inner-append", state.getInnerAppend())
    );
    state.getControlChild !== void 0 && node.push(
      state.getControlChild()
    );
    return node;
  }
  function getControlContainer() {
    const node = [];
    props4.prefix !== void 0 && props4.prefix !== null && node.push(
      h("div", {
        class: "q-field__prefix no-pointer-events row items-center"
      }, props4.prefix)
    );
    if (state.getShadowControl !== void 0 && state.hasShadow.value === true) {
      node.push(
        state.getShadowControl()
      );
    }
    if (state.getControl !== void 0) {
      node.push(state.getControl());
    } else if (slots.rawControl !== void 0) {
      node.push(slots.rawControl());
    } else if (slots.control !== void 0) {
      node.push(
        h("div", {
          ref: state.targetRef,
          class: "q-field__native row",
          tabindex: -1,
          ...state.splitAttrs.attributes.value,
          "data-autofocus": props4.autofocus === true || void 0
        }, slots.control(controlSlotScope.value))
      );
    }
    hasLabel.value === true && node.push(
      h("div", {
        class: labelClass.value
      }, hSlot(slots.label, props4.label))
    );
    props4.suffix !== void 0 && props4.suffix !== null && node.push(
      h("div", {
        class: "q-field__suffix no-pointer-events row items-center"
      }, props4.suffix)
    );
    return node.concat(hSlot(slots.default));
  }
  function getBottom() {
    let msg, key;
    if (hasError.value === true) {
      if (errorMessage.value !== null) {
        msg = [h("div", { role: "alert" }, errorMessage.value)];
        key = `q--slot-error-${errorMessage.value}`;
      } else {
        msg = hSlot(slots.error);
        key = "q--slot-error";
      }
    } else if (props4.hideHint !== true || state.focused.value === true) {
      if (props4.hint !== void 0) {
        msg = [h("div", props4.hint)];
        key = `q--slot-hint-${props4.hint}`;
      } else {
        msg = hSlot(slots.hint);
        key = "q--slot-hint";
      }
    }
    const hasCounter = props4.counter === true || slots.counter !== void 0;
    if (props4.hideBottomSpace === true && hasCounter === false && msg === void 0) {
      return;
    }
    const main = h("div", {
      key,
      class: "q-field__messages col"
    }, msg);
    return h("div", {
      class: "q-field__bottom row items-start q-field__bottom--" + (props4.hideBottomSpace !== true ? "animated" : "stale"),
      onClick: prevent
    }, [
      props4.hideBottomSpace === true ? main : h(Transition, { name: "q-transition--field-message" }, () => main),
      hasCounter === true ? h("div", {
        class: "q-field__counter"
      }, slots.counter !== void 0 ? slots.counter() : state.computedCounter.value) : null
    ]);
  }
  function getInnerAppendNode(key, content) {
    return content === null ? null : h("div", {
      key,
      class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip"
    }, content);
  }
  let shouldActivate = false;
  onDeactivated(() => {
    shouldActivate = true;
  });
  onActivated(() => {
    shouldActivate === true && props4.autofocus === true && proxy.focus();
  });
  props4.autofocus === true && onMounted(() => {
    proxy.focus();
  });
  onBeforeUnmount(() => {
    focusoutTimer !== null && clearTimeout(focusoutTimer);
  });
  Object.assign(proxy, { focus, blur });
  return function renderField() {
    const labelAttrs = state.getControl === void 0 && slots.control === void 0 ? {
      ...state.splitAttrs.attributes.value,
      "data-autofocus": props4.autofocus === true || void 0,
      ...attributes.value
    } : attributes.value;
    return h(state.tag.value, {
      ref: state.rootRef,
      class: [
        classes.value,
        attrs.class
      ],
      style: attrs.style,
      ...labelAttrs
    }, [
      slots.before !== void 0 ? h("div", {
        class: "q-field__before q-field__marginal row no-wrap items-center",
        onClick: prevent
      }, slots.before()) : null,
      h("div", {
        class: "q-field__inner relative-position col self-stretch"
      }, [
        h("div", {
          ref: state.controlRef,
          class: contentClass.value,
          tabindex: -1,
          ...state.controlEvents
        }, getContent()),
        shouldRenderBottom.value === true ? getBottom() : null
      ]),
      slots.after !== void 0 ? h("div", {
        class: "q-field__after q-field__marginal row no-wrap items-center",
        onClick: prevent
      }, slots.after()) : null
    ]);
  };
}
var QField_default = createComponent({
  name: "QField",
  inheritAttrs: false,
  props: {
    ...useFieldProps,
    tag: {
      type: String,
      default: "label"
    }
  },
  emits: useFieldEmits,
  setup() {
    return use_field_default(
      useFieldState({ tagProp: true })
    );
  }
});
function filterFiles(files, rejectedFiles, failedPropValidation, filterFn) {
  const acceptedFiles = [];
  files.forEach((file) => {
    if (filterFn(file) === true) {
      acceptedFiles.push(file);
    } else {
      rejectedFiles.push({ failedPropValidation, file });
    }
  });
  return acceptedFiles;
}
function stopAndPreventDrag(e) {
  e && e.dataTransfer && (e.dataTransfer.dropEffect = "copy");
  stopAndPrevent(e);
}
var useFileProps = {
  multiple: Boolean,
  accept: String,
  capture: String,
  maxFileSize: [Number, String],
  maxTotalSize: [Number, String],
  maxFiles: [Number, String],
  filter: Function
};
var useFileEmits = ["rejected"];
function use_file_default({
  editable,
  dnd,
  getFileInput,
  addFilesToQueue
}) {
  const { props: props4, emit: emit2, proxy } = getCurrentInstance();
  const dndRef = ref(null);
  const extensions = computed(() => props4.accept !== void 0 ? props4.accept.split(",").map((ext) => {
    ext = ext.trim();
    if (ext === "*") {
      return "*/";
    } else if (ext.endsWith("/*")) {
      ext = ext.slice(0, ext.length - 1);
    }
    return ext.toUpperCase();
  }) : null);
  const maxFilesNumber = computed(() => parseInt(props4.maxFiles, 10));
  const maxTotalSizeNumber = computed(() => parseInt(props4.maxTotalSize, 10));
  function pickFiles(e) {
    if (editable.value) {
      if (e !== Object(e)) {
        e = { target: null };
      }
      if (e.target !== null && e.target.matches('input[type="file"]') === true) {
        e.clientX === 0 && e.clientY === 0 && stop(e);
      } else {
        const input = getFileInput();
        input && input !== e.target && input.click(e);
      }
    }
  }
  function addFiles(files) {
    if (editable.value && files) {
      addFilesToQueue(null, files);
    }
  }
  function processFiles(e, filesToProcess, currentFileList, append) {
    let files = Array.from(filesToProcess || e.target.files);
    const rejectedFiles = [];
    const done = () => {
      if (rejectedFiles.length !== 0) {
        emit2("rejected", rejectedFiles);
      }
    };
    if (props4.accept !== void 0 && extensions.value.indexOf("*/") === -1) {
      files = filterFiles(files, rejectedFiles, "accept", (file) => {
        return extensions.value.some((ext) => file.type.toUpperCase().startsWith(ext) || file.name.toUpperCase().endsWith(ext));
      });
      if (files.length === 0) {
        return done();
      }
    }
    if (props4.maxFileSize !== void 0) {
      const maxFileSize = parseInt(props4.maxFileSize, 10);
      files = filterFiles(files, rejectedFiles, "max-file-size", (file) => {
        return file.size <= maxFileSize;
      });
      if (files.length === 0) {
        return done();
      }
    }
    if (props4.multiple !== true && files.length !== 0) {
      files = [files[0]];
    }
    files.forEach((file) => {
      file.__key = file.webkitRelativePath + file.lastModified + file.name + file.size;
    });
    if (append === true) {
      const filenameMap = currentFileList.map((entry) => entry.__key);
      files = filterFiles(files, rejectedFiles, "duplicate", (file) => {
        return filenameMap.includes(file.__key) === false;
      });
    }
    if (files.length === 0) {
      return done();
    }
    if (props4.maxTotalSize !== void 0) {
      let size2 = append === true ? currentFileList.reduce((total, file) => total + file.size, 0) : 0;
      files = filterFiles(files, rejectedFiles, "max-total-size", (file) => {
        size2 += file.size;
        return size2 <= maxTotalSizeNumber.value;
      });
      if (files.length === 0) {
        return done();
      }
    }
    if (typeof props4.filter === "function") {
      const filteredFiles = props4.filter(files);
      files = filterFiles(files, rejectedFiles, "filter", (file) => {
        return filteredFiles.includes(file);
      });
    }
    if (props4.maxFiles !== void 0) {
      let filesNumber = append === true ? currentFileList.length : 0;
      files = filterFiles(files, rejectedFiles, "max-files", () => {
        filesNumber++;
        return filesNumber <= maxFilesNumber.value;
      });
      if (files.length === 0) {
        return done();
      }
    }
    done();
    if (files.length !== 0) {
      return files;
    }
  }
  function onDragover(e) {
    stopAndPreventDrag(e);
    dnd.value !== true && (dnd.value = true);
  }
  function onDragleave(e) {
    stopAndPrevent(e);
    const gone = e.relatedTarget !== null || client.is.safari !== true ? e.relatedTarget !== dndRef.value : document.elementsFromPoint(e.clientX, e.clientY).includes(dndRef.value) === false;
    gone === true && (dnd.value = false);
  }
  function onDrop(e) {
    stopAndPreventDrag(e);
    const files = e.dataTransfer.files;
    if (files.length !== 0) {
      addFilesToQueue(null, files);
    }
    dnd.value = false;
  }
  function getDndNode(type) {
    if (dnd.value === true) {
      return h("div", {
        ref: dndRef,
        class: `q-${type}__dnd absolute-full`,
        onDragenter: stopAndPreventDrag,
        onDragover: stopAndPreventDrag,
        onDragleave,
        onDrop
      });
    }
  }
  Object.assign(proxy, { pickFiles, addFiles });
  return {
    pickFiles,
    addFiles,
    onDragover,
    onDragleave,
    processFiles,
    getDndNode,
    maxFilesNumber,
    maxTotalSizeNumber
  };
}
function use_file_dom_props_default(props4, typeGuard) {
  function getFormDomProps() {
    const model = props4.modelValue;
    try {
      const dt = "DataTransfer" in window ? new DataTransfer() : "ClipboardEvent" in window ? new ClipboardEvent("").clipboardData : void 0;
      if (Object(model) === model) {
        ("length" in model ? Array.from(model) : [model]).forEach((file) => {
          dt.items.add(file);
        });
      }
      return {
        files: dt.files
      };
    } catch (e) {
      return {
        files: void 0
      };
    }
  }
  return typeGuard === true ? computed(() => {
    if (props4.type !== "file") {
      return;
    }
    return getFormDomProps();
  }) : computed(getFormDomProps);
}
createComponent({
  name: "QFile",
  inheritAttrs: false,
  props: {
    ...useNonInputFieldProps,
    ...useFormProps,
    ...useFileProps,
    /* SSR does not know about File & FileList */
    modelValue: [File, FileList, Array],
    append: Boolean,
    useChips: Boolean,
    displayValue: [String, Number],
    tabindex: {
      type: [String, Number],
      default: 0
    },
    counterLabel: Function,
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  emits: [
    ...useFieldEmits,
    ...useFileEmits
  ],
  setup(props4, { slots, emit: emit2, attrs }) {
    const { proxy } = getCurrentInstance();
    const state = useFieldState();
    const inputRef = ref(null);
    const dnd = ref(false);
    const nameProp = useFormInputNameAttr(props4);
    const {
      pickFiles,
      onDragover,
      onDragleave,
      processFiles,
      getDndNode
    } = use_file_default({ editable: state.editable, dnd, getFileInput, addFilesToQueue });
    const formDomProps = use_file_dom_props_default(props4);
    const innerValue = computed(() => Object(props4.modelValue) === props4.modelValue ? "length" in props4.modelValue ? Array.from(props4.modelValue) : [props4.modelValue] : []);
    const hasValue = computed(() => fieldValueIsFilled(innerValue.value));
    const selectedString = computed(
      () => innerValue.value.map((file) => file.name).join(", ")
    );
    const totalSize = computed(
      () => humanStorageSize(
        innerValue.value.reduce((acc, file) => acc + file.size, 0)
      )
    );
    const counterProps = computed(() => ({
      totalSize: totalSize.value,
      filesNumber: innerValue.value.length,
      maxFiles: props4.maxFiles
    }));
    const inputAttrs = computed(() => ({
      tabindex: -1,
      type: "file",
      title: "",
      // try to remove default tooltip,
      accept: props4.accept,
      capture: props4.capture,
      name: nameProp.value,
      ...attrs,
      id: state.targetUid.value,
      disabled: state.editable.value !== true
    }));
    const fieldClass = computed(
      () => "q-file q-field--auto-height" + (dnd.value === true ? " q-file--dnd" : "")
    );
    const isAppending = computed(
      () => props4.multiple === true && props4.append === true
    );
    function removeAtIndex(index) {
      const files = innerValue.value.slice();
      files.splice(index, 1);
      emitValue(files);
    }
    function removeFile(file) {
      const index = innerValue.value.indexOf(file);
      if (index !== -1) {
        removeAtIndex(index);
      }
    }
    function emitValue(files) {
      emit2("update:modelValue", props4.multiple === true ? files : files[0]);
    }
    function onKeydown2(e) {
      e.keyCode === 13 && prevent(e);
    }
    function onKeyup2(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        pickFiles(e);
      }
    }
    function getFileInput() {
      return inputRef.value;
    }
    function addFilesToQueue(e, fileList) {
      const files = processFiles(e, fileList, innerValue.value, isAppending.value);
      const fileInput = getFileInput();
      if (fileInput !== void 0 && fileInput !== null) {
        fileInput.value = "";
      }
      if (files === void 0) return;
      if (props4.multiple === true ? props4.modelValue && files.every((f) => innerValue.value.includes(f)) : props4.modelValue === files[0]) {
        return;
      }
      emitValue(
        isAppending.value === true ? innerValue.value.concat(files) : files
      );
    }
    function getFiller() {
      return [
        h("input", {
          class: [props4.inputClass, "q-file__filler"],
          style: props4.inputStyle
        })
      ];
    }
    function getSelection() {
      if (slots.file !== void 0) {
        return innerValue.value.length === 0 ? getFiller() : innerValue.value.map(
          (file, index) => slots.file({ index, file, ref: this })
        );
      }
      if (slots.selected !== void 0) {
        return innerValue.value.length === 0 ? getFiller() : slots.selected({ files: innerValue.value, ref: this });
      }
      if (props4.useChips === true) {
        return innerValue.value.length === 0 ? getFiller() : innerValue.value.map((file, i) => h(QChip_default, {
          key: "file-" + i,
          removable: state.editable.value,
          dense: true,
          textColor: props4.color,
          tabindex: props4.tabindex,
          onRemove: () => {
            removeAtIndex(i);
          }
        }, () => h("span", {
          class: "ellipsis",
          textContent: file.name
        })));
      }
      const textContent = props4.displayValue !== void 0 ? props4.displayValue : selectedString.value;
      return textContent.length !== 0 ? [
        h("div", {
          class: props4.inputClass,
          style: props4.inputStyle,
          textContent
        })
      ] : getFiller();
    }
    function getInput() {
      const data = {
        ref: inputRef,
        ...inputAttrs.value,
        ...formDomProps.value,
        class: "q-field__input fit absolute-full cursor-pointer",
        onChange: addFilesToQueue
      };
      if (props4.multiple === true) {
        data.multiple = true;
      }
      return h("input", data);
    }
    Object.assign(state, {
      fieldClass,
      emitValue,
      hasValue,
      inputRef,
      innerValue,
      floatingLabel: computed(
        () => hasValue.value === true || fieldValueIsFilled(props4.displayValue)
      ),
      computedCounter: computed(() => {
        if (props4.counterLabel !== void 0) {
          return props4.counterLabel(counterProps.value);
        }
        const max = props4.maxFiles;
        return `${innerValue.value.length}${max !== void 0 ? " / " + max : ""} (${totalSize.value})`;
      }),
      getControlChild: () => getDndNode("file"),
      getControl: () => {
        const data = {
          ref: state.targetRef,
          class: "q-field__native row items-center cursor-pointer",
          tabindex: props4.tabindex
        };
        if (state.editable.value === true) {
          Object.assign(data, { onDragover, onDragleave, onKeydown: onKeydown2, onKeyup: onKeyup2 });
        }
        return h("div", data, [getInput()].concat(getSelection()));
      }
    });
    Object.assign(proxy, {
      removeAtIndex,
      removeFile,
      getNativeElement: () => inputRef.value
      // deprecated
    });
    injectProp(proxy, "nativeEl", () => inputRef.value);
    return use_field_default(state);
  }
});
createComponent({
  name: "QFooter",
  props: {
    modelValue: {
      type: Boolean,
      default: true
    },
    reveal: Boolean,
    bordered: Boolean,
    elevated: Boolean,
    heightHint: {
      type: [String, Number],
      default: 50
    }
  },
  emits: ["reveal", "focusin"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const $layout = inject(layoutKey, emptyRenderFn);
    if ($layout === emptyRenderFn) {
      console.error("QFooter needs to be child of QLayout");
      return emptyRenderFn;
    }
    const size2 = ref(parseInt(props4.heightHint, 10));
    const revealed = ref(true);
    const windowHeight = ref(
      isRuntimeSsrPreHydration.value === true || $layout.isContainer.value === true ? 0 : window.innerHeight
    );
    const fixed = computed(
      () => props4.reveal === true || $layout.view.value.indexOf("F") !== -1 || $q.platform.is.ios && $layout.isContainer.value === true
    );
    const containerHeight = computed(() => $layout.isContainer.value === true ? $layout.containerHeight.value : windowHeight.value);
    const offset2 = computed(() => {
      if (props4.modelValue !== true) {
        return 0;
      }
      if (fixed.value === true) {
        return revealed.value === true ? size2.value : 0;
      }
      const offset3 = $layout.scroll.value.position + containerHeight.value + size2.value - $layout.height.value;
      return offset3 > 0 ? offset3 : 0;
    });
    const hidden = computed(
      () => props4.modelValue !== true || fixed.value === true && revealed.value !== true
    );
    const revealOnFocus = computed(
      () => props4.modelValue === true && hidden.value === true && props4.reveal === true
    );
    const classes = computed(
      () => "q-footer q-layout__section--marginal " + (fixed.value === true ? "fixed" : "absolute") + "-bottom" + (props4.bordered === true ? " q-footer--bordered" : "") + (hidden.value === true ? " q-footer--hidden" : "") + (props4.modelValue !== true ? " q-layout--prevent-focus" + (fixed.value !== true ? " hidden" : "") : "")
    );
    const style2 = computed(() => {
      const view = $layout.rows.value.bottom, css2 = {};
      if (view[0] === "l" && $layout.left.space === true) {
        css2[$q.lang.rtl === true ? "right" : "left"] = `${$layout.left.size}px`;
      }
      if (view[2] === "r" && $layout.right.space === true) {
        css2[$q.lang.rtl === true ? "left" : "right"] = `${$layout.right.size}px`;
      }
      return css2;
    });
    function updateLayout(prop, val) {
      $layout.update("footer", prop, val);
    }
    function updateLocal(prop, val) {
      if (prop.value !== val) {
        prop.value = val;
      }
    }
    function onResize({ height: height2 }) {
      updateLocal(size2, height2);
      updateLayout("size", height2);
    }
    function updateRevealed() {
      if (props4.reveal !== true) return;
      const { direction, position: position2, inflectionPoint } = $layout.scroll.value;
      updateLocal(revealed, direction === "up" || position2 - inflectionPoint < 100 || $layout.height.value - containerHeight.value - position2 - size2.value < 300);
    }
    function onFocusin(evt) {
      if (revealOnFocus.value === true) {
        updateLocal(revealed, true);
      }
      emit2("focusin", evt);
    }
    watch(() => props4.modelValue, (val) => {
      updateLayout("space", val);
      updateLocal(revealed, true);
      $layout.animate();
    });
    watch(offset2, (val) => {
      updateLayout("offset", val);
    });
    watch(() => props4.reveal, (val) => {
      val === false && updateLocal(revealed, props4.modelValue);
    });
    watch(revealed, (val) => {
      $layout.animate();
      emit2("reveal", val);
    });
    watch([size2, $layout.scroll, $layout.height], updateRevealed);
    watch(() => $q.screen.height, (val) => {
      $layout.isContainer.value !== true && updateLocal(windowHeight, val);
    });
    const instance = {};
    $layout.instances.footer = instance;
    props4.modelValue === true && updateLayout("size", size2.value);
    updateLayout("space", props4.modelValue);
    updateLayout("offset", offset2.value);
    onBeforeUnmount(() => {
      if ($layout.instances.footer === instance) {
        $layout.instances.footer = void 0;
        updateLayout("size", 0);
        updateLayout("offset", 0);
        updateLayout("space", false);
      }
    });
    return () => {
      const child = hMergeSlot(slots.default, [
        h(QResizeObserver_default, {
          debounce: 0,
          onResize
        })
      ]);
      props4.elevated === true && child.push(
        h("div", {
          class: "q-layout__shadow absolute-full overflow-hidden no-pointer-events"
        })
      );
      return h("footer", {
        class: classes.value,
        style: style2.value,
        onFocusin
      }, child);
    };
  }
});
createComponent({
  name: "QForm",
  props: {
    autofocus: Boolean,
    noErrorFocus: Boolean,
    noResetFocus: Boolean,
    greedy: Boolean,
    onSubmit: Function
  },
  emits: ["reset", "validationSuccess", "validationError"],
  setup(props4, { slots, emit: emit2 }) {
    const vm2 = getCurrentInstance();
    const rootRef = ref(null);
    let validateIndex = 0;
    const registeredComponents = [];
    function validate(shouldFocus) {
      const focus2 = typeof shouldFocus === "boolean" ? shouldFocus : props4.noErrorFocus !== true;
      const index = ++validateIndex;
      const emitEvent = (res, ref73) => {
        emit2(`validation${res === true ? "Success" : "Error"}`, ref73);
      };
      const validateComponent = (comp) => {
        const valid = comp.validate();
        return typeof valid.then === "function" ? valid.then(
          (valid2) => ({ valid: valid2, comp }),
          (err) => ({ valid: false, comp, err })
        ) : Promise.resolve({ valid, comp });
      };
      const errorsPromise = props4.greedy === true ? Promise.all(registeredComponents.map(validateComponent)).then((res) => res.filter((r) => r.valid !== true)) : registeredComponents.reduce(
        (acc, comp) => acc.then(() => {
          return validateComponent(comp).then((r) => {
            if (r.valid === false) {
              return Promise.reject(r);
            }
          });
        }),
        Promise.resolve()
      ).catch((error2) => [error2]);
      return errorsPromise.then((errors) => {
        if (errors === void 0 || errors.length === 0) {
          index === validateIndex && emitEvent(true);
          return true;
        }
        if (index === validateIndex) {
          const { comp, err } = errors[0];
          err !== void 0 && console.error(err);
          emitEvent(false, comp);
          if (focus2 === true) {
            const activeError = errors.find(({ comp: comp2 }) => typeof comp2.focus === "function" && vmIsDestroyed(comp2.$) === false);
            if (activeError !== void 0) {
              activeError.comp.focus();
            }
          }
        }
        return false;
      });
    }
    function resetValidation() {
      validateIndex++;
      registeredComponents.forEach((comp) => {
        typeof comp.resetValidation === "function" && comp.resetValidation();
      });
    }
    function submit(evt) {
      evt !== void 0 && stopAndPrevent(evt);
      const index = validateIndex + 1;
      validate().then((val) => {
        if (index === validateIndex && val === true) {
          if (props4.onSubmit !== void 0) {
            emit2("submit", evt);
          } else if (evt !== void 0 && evt.target !== void 0 && typeof evt.target.submit === "function") {
            evt.target.submit();
          }
        }
      });
    }
    function reset(evt) {
      evt !== void 0 && stopAndPrevent(evt);
      emit2("reset");
      nextTick(() => {
        resetValidation();
        if (props4.autofocus === true && props4.noResetFocus !== true) {
          focus();
        }
      });
    }
    function focus() {
      addFocusFn(() => {
        if (rootRef.value === null) return;
        const target2 = rootRef.value.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || rootRef.value.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || rootRef.value.querySelector("[autofocus], [data-autofocus]") || Array.prototype.find.call(rootRef.value.querySelectorAll("[tabindex]"), (el) => el.tabIndex !== -1);
        target2 !== null && target2 !== void 0 && target2.focus({ preventScroll: true });
      });
    }
    provide(formKey, {
      bindComponent(vmProxy) {
        registeredComponents.push(vmProxy);
      },
      unbindComponent(vmProxy) {
        const index = registeredComponents.indexOf(vmProxy);
        if (index !== -1) {
          registeredComponents.splice(index, 1);
        }
      }
    });
    let shouldActivate = false;
    onDeactivated(() => {
      shouldActivate = true;
    });
    onActivated(() => {
      shouldActivate === true && props4.autofocus === true && focus();
    });
    onMounted(() => {
      props4.autofocus === true && focus();
    });
    Object.assign(vm2.proxy, {
      validate,
      resetValidation,
      submit,
      reset,
      focus,
      getValidationComponents: () => registeredComponents
    });
    return () => h("form", {
      class: "q-form",
      ref: rootRef,
      onSubmit: submit,
      onReset: reset
    }, hSlot(slots.default));
  }
});
createComponent({
  name: "QHeader",
  props: {
    modelValue: {
      type: Boolean,
      default: true
    },
    reveal: Boolean,
    revealOffset: {
      type: Number,
      default: 250
    },
    bordered: Boolean,
    elevated: Boolean,
    heightHint: {
      type: [String, Number],
      default: 50
    }
  },
  emits: ["reveal", "focusin"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const $layout = inject(layoutKey, emptyRenderFn);
    if ($layout === emptyRenderFn) {
      console.error("QHeader needs to be child of QLayout");
      return emptyRenderFn;
    }
    const size2 = ref(parseInt(props4.heightHint, 10));
    const revealed = ref(true);
    const fixed = computed(
      () => props4.reveal === true || $layout.view.value.indexOf("H") !== -1 || $q.platform.is.ios && $layout.isContainer.value === true
    );
    const offset2 = computed(() => {
      if (props4.modelValue !== true) {
        return 0;
      }
      if (fixed.value === true) {
        return revealed.value === true ? size2.value : 0;
      }
      const offset3 = size2.value - $layout.scroll.value.position;
      return offset3 > 0 ? offset3 : 0;
    });
    const hidden = computed(
      () => props4.modelValue !== true || fixed.value === true && revealed.value !== true
    );
    const revealOnFocus = computed(
      () => props4.modelValue === true && hidden.value === true && props4.reveal === true
    );
    const classes = computed(
      () => "q-header q-layout__section--marginal " + (fixed.value === true ? "fixed" : "absolute") + "-top" + (props4.bordered === true ? " q-header--bordered" : "") + (hidden.value === true ? " q-header--hidden" : "") + (props4.modelValue !== true ? " q-layout--prevent-focus" : "")
    );
    const style2 = computed(() => {
      const view = $layout.rows.value.top, css2 = {};
      if (view[0] === "l" && $layout.left.space === true) {
        css2[$q.lang.rtl === true ? "right" : "left"] = `${$layout.left.size}px`;
      }
      if (view[2] === "r" && $layout.right.space === true) {
        css2[$q.lang.rtl === true ? "left" : "right"] = `${$layout.right.size}px`;
      }
      return css2;
    });
    function updateLayout(prop, val) {
      $layout.update("header", prop, val);
    }
    function updateLocal(prop, val) {
      if (prop.value !== val) {
        prop.value = val;
      }
    }
    function onResize({ height: height2 }) {
      updateLocal(size2, height2);
      updateLayout("size", height2);
    }
    function onFocusin(evt) {
      if (revealOnFocus.value === true) {
        updateLocal(revealed, true);
      }
      emit2("focusin", evt);
    }
    watch(() => props4.modelValue, (val) => {
      updateLayout("space", val);
      updateLocal(revealed, true);
      $layout.animate();
    });
    watch(offset2, (val) => {
      updateLayout("offset", val);
    });
    watch(() => props4.reveal, (val) => {
      val === false && updateLocal(revealed, props4.modelValue);
    });
    watch(revealed, (val) => {
      $layout.animate();
      emit2("reveal", val);
    });
    watch($layout.scroll, (scroll) => {
      props4.reveal === true && updateLocal(
        revealed,
        scroll.direction === "up" || scroll.position <= props4.revealOffset || scroll.position - scroll.inflectionPoint < 100
      );
    });
    const instance = {};
    $layout.instances.header = instance;
    props4.modelValue === true && updateLayout("size", size2.value);
    updateLayout("space", props4.modelValue);
    updateLayout("offset", offset2.value);
    onBeforeUnmount(() => {
      if ($layout.instances.header === instance) {
        $layout.instances.header = void 0;
        updateLayout("size", 0);
        updateLayout("offset", 0);
        updateLayout("space", false);
      }
    });
    return () => {
      const child = hUniqueSlot(slots.default, []);
      props4.elevated === true && child.push(
        h("div", {
          class: "q-layout__shadow absolute-full overflow-hidden no-pointer-events"
        })
      );
      child.push(
        h(QResizeObserver_default, {
          debounce: 0,
          onResize
        })
      );
      return h("header", {
        class: classes.value,
        style: style2.value,
        onFocusin
      }, child);
    };
  }
});
var useRatioProps = {
  ratio: [String, Number]
};
function use_ratio_default(props4, naturalRatio) {
  return computed(() => {
    const ratio = Number(
      props4.ratio || (naturalRatio !== void 0 ? naturalRatio.value : void 0)
    );
    return isNaN(ratio) !== true && ratio > 0 ? { paddingBottom: `${100 / ratio}%` } : null;
  });
}
var defaultRatio = 1.7778;
createComponent({
  name: "QImg",
  props: {
    ...useRatioProps,
    src: String,
    srcset: String,
    sizes: String,
    alt: String,
    crossorigin: String,
    decoding: String,
    referrerpolicy: String,
    draggable: Boolean,
    loading: {
      type: String,
      default: "lazy"
    },
    loadingShowDelay: {
      type: [Number, String],
      default: 0
    },
    fetchpriority: {
      type: String,
      default: "auto"
    },
    width: String,
    height: String,
    initialRatio: {
      type: [Number, String],
      default: defaultRatio
    },
    placeholderSrc: String,
    errorSrc: String,
    fit: {
      type: String,
      default: "cover"
    },
    position: {
      type: String,
      default: "50% 50%"
    },
    imgClass: String,
    imgStyle: Object,
    noSpinner: Boolean,
    noNativeMenu: Boolean,
    noTransition: Boolean,
    spinnerColor: String,
    spinnerSize: String
  },
  emits: ["load", "error"],
  setup(props4, { slots, emit: emit2 }) {
    const naturalRatio = ref(props4.initialRatio);
    const ratioStyle = use_ratio_default(props4, naturalRatio);
    const vm2 = getCurrentInstance();
    const { registerTimeout: registerLoadTimeout, removeTimeout: removeLoadTimeout } = use_timeout_default();
    const { registerTimeout: registerLoadShowTimeout, removeTimeout: removeLoadShowTimeout } = use_timeout_default();
    const placeholderImg = computed(() => props4.placeholderSrc !== void 0 ? { src: props4.placeholderSrc } : null);
    const errorImg = computed(() => props4.errorSrc !== void 0 ? { src: props4.errorSrc, __qerror: true } : null);
    const images = [
      ref(null),
      ref(placeholderImg.value)
    ];
    const position2 = ref(0);
    const isLoading = ref(false);
    const hasError = ref(false);
    const classes = computed(
      () => `q-img q-img--${props4.noNativeMenu === true ? "no-" : ""}menu`
    );
    const style2 = computed(() => ({
      width: props4.width,
      height: props4.height
    }));
    const imgClass = computed(
      () => `q-img__image ${props4.imgClass !== void 0 ? props4.imgClass + " " : ""}q-img__image--with${props4.noTransition === true ? "out" : ""}-transition q-img__image--`
    );
    const imgStyle = computed(() => ({
      ...props4.imgStyle,
      objectFit: props4.fit,
      objectPosition: props4.position
    }));
    function setLoading() {
      removeLoadShowTimeout();
      if (props4.loadingShowDelay === 0) {
        isLoading.value = true;
        return;
      }
      registerLoadShowTimeout(() => {
        isLoading.value = true;
      }, props4.loadingShowDelay);
    }
    function clearLoading() {
      removeLoadShowTimeout();
      isLoading.value = false;
    }
    function onLoad({ target: target2 }) {
      if (vmIsDestroyed(vm2) === false) {
        removeLoadTimeout();
        naturalRatio.value = target2.naturalHeight === 0 ? 0.5 : target2.naturalWidth / target2.naturalHeight;
        waitForCompleteness(target2, 1);
      }
    }
    function waitForCompleteness(target2, count) {
      if (count === 1e3 || vmIsDestroyed(vm2) === true) return;
      if (target2.complete === true) {
        onReady(target2);
      } else {
        registerLoadTimeout(() => {
          waitForCompleteness(target2, count + 1);
        }, 50);
      }
    }
    function onReady(target2) {
      if (vmIsDestroyed(vm2) === true) return;
      position2.value = position2.value ^ 1;
      images[position2.value].value = null;
      clearLoading();
      if (target2.getAttribute("__qerror") !== "true") {
        hasError.value = false;
      }
      emit2("load", target2.currentSrc || target2.src);
    }
    function onError(err) {
      removeLoadTimeout();
      clearLoading();
      hasError.value = true;
      images[position2.value].value = errorImg.value;
      images[position2.value ^ 1].value = placeholderImg.value;
      emit2("error", err);
    }
    function getImage(index) {
      const img = images[index].value;
      const data = {
        key: "img_" + index,
        class: imgClass.value,
        style: imgStyle.value,
        alt: props4.alt,
        crossorigin: props4.crossorigin,
        decoding: props4.decoding,
        referrerpolicy: props4.referrerpolicy,
        height: props4.height,
        width: props4.width,
        loading: props4.loading,
        fetchpriority: props4.fetchpriority,
        "aria-hidden": "true",
        draggable: props4.draggable,
        ...img
      };
      if (position2.value === index) {
        Object.assign(data, {
          class: data.class + "current",
          onLoad,
          onError
        });
      } else {
        data.class += "loaded";
      }
      return h(
        "div",
        { class: "q-img__container absolute-full", key: "img" + index },
        h("img", data)
      );
    }
    function getContent() {
      if (isLoading.value === false) {
        return h("div", {
          key: "content",
          class: "q-img__content absolute-full q-anchor--skip"
        }, hSlot(slots[hasError.value === true ? "error" : "default"]));
      }
      return h("div", {
        key: "loading",
        class: "q-img__loading absolute-full flex flex-center"
      }, slots.loading !== void 0 ? slots.loading() : props4.noSpinner === true ? void 0 : [
        h(QSpinner_default, {
          color: props4.spinnerColor,
          size: props4.spinnerSize
        })
      ]);
    }
    {
      let watchSrc = function() {
        watch(
          () => props4.src || props4.srcset || props4.sizes ? {
            src: props4.src,
            srcset: props4.srcset,
            sizes: props4.sizes
          } : null,
          (imgProps) => {
            removeLoadTimeout();
            hasError.value = false;
            if (imgProps === null) {
              clearLoading();
              images[position2.value ^ 1].value = placeholderImg.value;
            } else {
              setLoading();
            }
            images[position2.value].value = imgProps;
          },
          { immediate: true }
        );
      };
      if (isRuntimeSsrPreHydration.value === true) {
        onMounted(watchSrc);
      } else {
        watchSrc();
      }
    }
    return () => {
      const content = [];
      if (ratioStyle.value !== null) {
        content.push(
          h("div", { key: "filler", style: ratioStyle.value })
        );
      }
      if (images[0].value !== null) {
        content.push(
          getImage(0)
        );
      }
      if (images[1].value !== null) {
        content.push(
          getImage(1)
        );
      }
      content.push(
        h(Transition, { name: "q-transition--fade" }, getContent)
      );
      return h("div", {
        key: "main",
        class: classes.value,
        style: style2.value,
        role: "img",
        "aria-label": props4.alt
      }, content);
    };
  }
});
var { passive: passive2 } = listenOpts;
createComponent({
  name: "QInfiniteScroll",
  props: {
    offset: {
      type: Number,
      default: 500
    },
    debounce: {
      type: [String, Number],
      default: 100
    },
    scrollTarget: scrollTargetProp,
    initialIndex: {
      type: Number,
      default: 0
    },
    disable: Boolean,
    reverse: Boolean
  },
  emits: ["load"],
  setup(props4, { slots, emit: emit2 }) {
    const isFetching = ref(false);
    const isWorking = ref(true);
    const rootRef = ref(null);
    const loadingRef = ref(null);
    let index = props4.initialIndex;
    let localScrollTarget, poll;
    const classes = computed(
      () => "q-infinite-scroll__loading" + (isFetching.value === true ? "" : " invisible")
    );
    function immediatePoll() {
      if (props4.disable === true || isFetching.value === true || isWorking.value === false) {
        return;
      }
      const scrollHeight = getScrollHeight(localScrollTarget), scrollPosition = getVerticalScrollPosition(localScrollTarget), containerHeight = height(localScrollTarget);
      if (props4.reverse === false) {
        if (Math.round(scrollPosition + containerHeight + props4.offset) >= Math.round(scrollHeight)) {
          trigger3();
        }
      } else if (Math.round(scrollPosition) <= props4.offset) {
        trigger3();
      }
    }
    function trigger3() {
      if (props4.disable === true || isFetching.value === true || isWorking.value === false) {
        return;
      }
      index++;
      isFetching.value = true;
      const heightBefore = getScrollHeight(localScrollTarget);
      emit2("load", index, (isDone) => {
        if (isWorking.value === true) {
          isFetching.value = false;
          nextTick(() => {
            if (props4.reverse === true) {
              const heightAfter = getScrollHeight(localScrollTarget), scrollPosition = getVerticalScrollPosition(localScrollTarget), heightDifference = heightAfter - heightBefore;
              setVerticalScrollPosition(localScrollTarget, scrollPosition + heightDifference);
            }
            if (isDone === true) {
              stop2();
            } else if (rootRef.value) {
              rootRef.value.closest("body") && poll();
            }
          });
        }
      });
    }
    function reset() {
      index = 0;
    }
    function resume() {
      if (isWorking.value === false) {
        isWorking.value = true;
        localScrollTarget.addEventListener("scroll", poll, passive2);
      }
      immediatePoll();
    }
    function stop2() {
      if (isWorking.value === true) {
        isWorking.value = false;
        isFetching.value = false;
        localScrollTarget.removeEventListener("scroll", poll, passive2);
        if (poll !== void 0 && poll.cancel !== void 0) {
          poll.cancel();
        }
      }
    }
    function updateScrollTarget() {
      if (localScrollTarget && isWorking.value === true) {
        localScrollTarget.removeEventListener("scroll", poll, passive2);
      }
      localScrollTarget = getScrollTarget(rootRef.value, props4.scrollTarget);
      if (isWorking.value === true) {
        localScrollTarget.addEventListener("scroll", poll, passive2);
        if (props4.reverse === true) {
          const scrollHeight = getScrollHeight(localScrollTarget), containerHeight = height(localScrollTarget);
          setVerticalScrollPosition(localScrollTarget, scrollHeight - containerHeight);
        }
        immediatePoll();
      }
    }
    function setIndex(newIndex) {
      index = newIndex;
    }
    function setDebounce(val) {
      val = parseInt(val, 10);
      const oldPoll = poll;
      poll = val <= 0 ? immediatePoll : debounce_default(immediatePoll, isNaN(val) === true ? 100 : val);
      if (localScrollTarget && isWorking.value === true) {
        if (oldPoll !== void 0) {
          localScrollTarget.removeEventListener("scroll", oldPoll, passive2);
        }
        localScrollTarget.addEventListener("scroll", poll, passive2);
      }
    }
    function updateSvgAnimations(isRetry) {
      if (renderLoadingSlot.value === true) {
        if (loadingRef.value === null) {
          isRetry !== true && nextTick(() => {
            updateSvgAnimations(true);
          });
          return;
        }
        const action = `${isFetching.value === true ? "un" : ""}pauseAnimations`;
        Array.from(loadingRef.value.getElementsByTagName("svg")).forEach((el) => {
          el[action]();
        });
      }
    }
    const renderLoadingSlot = computed(() => props4.disable !== true && isWorking.value === true);
    watch([isFetching, renderLoadingSlot], () => {
      updateSvgAnimations();
    });
    watch(() => props4.disable, (val) => {
      if (val === true) {
        stop2();
      } else {
        resume();
      }
    });
    watch(() => props4.reverse, () => {
      if (isFetching.value === false && isWorking.value === true) {
        immediatePoll();
      }
    });
    watch(() => props4.scrollTarget, updateScrollTarget);
    watch(() => props4.debounce, setDebounce);
    let scrollPos = false;
    onActivated(() => {
      if (scrollPos !== false && localScrollTarget) {
        setVerticalScrollPosition(localScrollTarget, scrollPos);
      }
    });
    onDeactivated(() => {
      scrollPos = localScrollTarget ? getVerticalScrollPosition(localScrollTarget) : false;
    });
    onBeforeUnmount(() => {
      if (isWorking.value === true) {
        localScrollTarget.removeEventListener("scroll", poll, passive2);
      }
    });
    onMounted(() => {
      setDebounce(props4.debounce);
      updateScrollTarget();
      isFetching.value === false && updateSvgAnimations();
    });
    const vm2 = getCurrentInstance();
    Object.assign(vm2.proxy, {
      poll: () => {
        poll !== void 0 && poll();
      },
      trigger: trigger3,
      stop: stop2,
      reset,
      resume,
      setIndex,
      updateScrollTarget
    });
    return () => {
      const child = hUniqueSlot(slots.default, []);
      if (renderLoadingSlot.value === true) {
        child[props4.reverse === false ? "push" : "unshift"](
          h("div", { ref: loadingRef, class: classes.value }, hSlot(slots.loading))
        );
      }
      return h("div", {
        class: "q-infinite-scroll",
        ref: rootRef
      }, child);
    };
  }
});
createComponent({
  name: "QInnerLoading",
  props: {
    ...useDarkProps,
    ...useTransitionProps,
    showing: Boolean,
    color: String,
    size: {
      type: [String, Number],
      default: "42px"
    },
    label: String,
    labelClass: String,
    labelStyle: [String, Array, Object]
  },
  setup(props4, { slots }) {
    const vm2 = getCurrentInstance();
    const isDark = use_dark_default(props4, vm2.proxy.$q);
    const { transitionProps, transitionStyle } = use_transition_default(props4);
    const classes = computed(
      () => "q-inner-loading q--avoid-card-border absolute-full column flex-center" + (isDark.value === true ? " q-inner-loading--dark" : "")
    );
    const labelClass = computed(
      () => "q-inner-loading__label" + (props4.labelClass !== void 0 ? ` ${props4.labelClass}` : "")
    );
    function getInner() {
      const child = [
        h(QSpinner_default, {
          size: props4.size,
          color: props4.color
        })
      ];
      if (props4.label !== void 0) {
        child.push(
          h("div", {
            class: labelClass.value,
            style: props4.labelStyle
          }, [props4.label])
        );
      }
      return child;
    }
    function getContent() {
      return props4.showing === true ? h(
        "div",
        { class: classes.value, style: transitionStyle.value },
        slots.default !== void 0 ? slots.default() : getInner()
      ) : null;
    }
    return () => h(Transition, transitionProps.value, getContent);
  }
});
var NAMED_MASKS = {
  date: "####/##/##",
  datetime: "####/##/## ##:##",
  time: "##:##",
  fulltime: "##:##:##",
  phone: "(###) ### - ####",
  card: "#### #### #### ####"
};
var TOKENS = {
  "#": { pattern: "[\\d]", negate: "[^\\d]" },
  S: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]" },
  N: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]" },
  A: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (v2) => v2.toLocaleUpperCase() },
  a: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (v2) => v2.toLocaleLowerCase() },
  X: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (v2) => v2.toLocaleUpperCase() },
  x: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (v2) => v2.toLocaleLowerCase() }
};
var KEYS = Object.keys(TOKENS);
KEYS.forEach((key) => {
  TOKENS[key].regex = new RegExp(TOKENS[key].pattern);
});
var tokenRegexMask = new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([" + KEYS.join("") + "])|(.)", "g");
var escRegex = /[.*+?^${}()|[\]\\]/g;
var MARKER = String.fromCharCode(1);
var useMaskProps = {
  mask: String,
  reverseFillMask: Boolean,
  fillMask: [Boolean, String],
  unmaskedValue: Boolean
};
function use_mask_default(props4, emit2, emitValue, inputRef) {
  let maskMarked, maskReplaced, computedMask, computedUnmask, pastedTextStart, selectionAnchor;
  const hasMask = ref(null);
  const innerValue = ref(getInitialMaskedValue());
  function getIsTypeText() {
    return props4.autogrow === true || ["textarea", "text", "search", "url", "tel", "password"].includes(props4.type);
  }
  watch(() => props4.type + props4.autogrow, updateMaskInternals);
  watch(() => props4.mask, (v2) => {
    if (v2 !== void 0) {
      updateMaskValue(innerValue.value, true);
    } else {
      const val = unmaskValue(innerValue.value);
      updateMaskInternals();
      props4.modelValue !== val && emit2("update:modelValue", val);
    }
  });
  watch(() => props4.fillMask + props4.reverseFillMask, () => {
    hasMask.value === true && updateMaskValue(innerValue.value, true);
  });
  watch(() => props4.unmaskedValue, () => {
    hasMask.value === true && updateMaskValue(innerValue.value);
  });
  function getInitialMaskedValue() {
    updateMaskInternals();
    if (hasMask.value === true) {
      const masked = maskValue(unmaskValue(props4.modelValue));
      return props4.fillMask !== false ? fillWithMask(masked) : masked;
    }
    return props4.modelValue;
  }
  function getPaddedMaskMarked(size2) {
    if (size2 < maskMarked.length) {
      return maskMarked.slice(-size2);
    }
    let pad2 = "", localMaskMarked = maskMarked;
    const padPos = localMaskMarked.indexOf(MARKER);
    if (padPos !== -1) {
      for (let i = size2 - localMaskMarked.length; i > 0; i--) {
        pad2 += MARKER;
      }
      localMaskMarked = localMaskMarked.slice(0, padPos) + pad2 + localMaskMarked.slice(padPos);
    }
    return localMaskMarked;
  }
  function updateMaskInternals() {
    hasMask.value = props4.mask !== void 0 && props4.mask.length !== 0 && getIsTypeText();
    if (hasMask.value === false) {
      computedUnmask = void 0;
      maskMarked = "";
      maskReplaced = "";
      return;
    }
    const localComputedMask = NAMED_MASKS[props4.mask] === void 0 ? props4.mask : NAMED_MASKS[props4.mask], fillChar = typeof props4.fillMask === "string" && props4.fillMask.length !== 0 ? props4.fillMask.slice(0, 1) : "_", fillCharEscaped = fillChar.replace(escRegex, "\\$&"), unmask = [], extract = [], mask = [];
    let firstMatch = props4.reverseFillMask === true, unmaskChar = "", negateChar = "";
    localComputedMask.replace(tokenRegexMask, (_, char1, esc, token2, char2) => {
      if (token2 !== void 0) {
        const c = TOKENS[token2];
        mask.push(c);
        negateChar = c.negate;
        if (firstMatch === true) {
          extract.push("(?:" + negateChar + "+)?(" + c.pattern + "+)?(?:" + negateChar + "+)?(" + c.pattern + "+)?");
          firstMatch = false;
        }
        extract.push("(?:" + negateChar + "+)?(" + c.pattern + ")?");
      } else if (esc !== void 0) {
        unmaskChar = "\\" + (esc === "\\" ? "" : esc);
        mask.push(esc);
        unmask.push("([^" + unmaskChar + "]+)?" + unmaskChar + "?");
      } else {
        const c = char1 !== void 0 ? char1 : char2;
        unmaskChar = c === "\\" ? "\\\\\\\\" : c.replace(escRegex, "\\\\$&");
        mask.push(c);
        unmask.push("([^" + unmaskChar + "]+)?" + unmaskChar + "?");
      }
    });
    const unmaskMatcher = new RegExp(
      "^" + unmask.join("") + "(" + (unmaskChar === "" ? "." : "[^" + unmaskChar + "]") + "+)?" + (unmaskChar === "" ? "" : "[" + unmaskChar + "]*") + "$"
    ), extractLast = extract.length - 1, extractMatcher = extract.map((re, index) => {
      if (index === 0 && props4.reverseFillMask === true) {
        return new RegExp("^" + fillCharEscaped + "*" + re);
      } else if (index === extractLast) {
        return new RegExp(
          "^" + re + "(" + (negateChar === "" ? "." : negateChar) + "+)?" + (props4.reverseFillMask === true ? "$" : fillCharEscaped + "*")
        );
      }
      return new RegExp("^" + re);
    });
    computedMask = mask;
    computedUnmask = (val) => {
      const unmaskMatch = unmaskMatcher.exec(props4.reverseFillMask === true ? val : val.slice(0, mask.length + 1));
      if (unmaskMatch !== null) {
        val = unmaskMatch.slice(1).join("");
      }
      const extractMatch = [], extractMatcherLength = extractMatcher.length;
      for (let i = 0, str = val; i < extractMatcherLength; i++) {
        const m2 = extractMatcher[i].exec(str);
        if (m2 === null) {
          break;
        }
        str = str.slice(m2.shift().length);
        extractMatch.push(...m2);
      }
      if (extractMatch.length !== 0) {
        return extractMatch.join("");
      }
      return val;
    };
    maskMarked = mask.map((v2) => typeof v2 === "string" ? v2 : MARKER).join("");
    maskReplaced = maskMarked.split(MARKER).join(fillChar);
  }
  function updateMaskValue(rawVal, updateMaskInternalsFlag, inputType) {
    const inp = inputRef.value, end = inp.selectionEnd, endReverse = inp.value.length - end, unmasked = unmaskValue(rawVal);
    updateMaskInternalsFlag === true && updateMaskInternals();
    const preMasked = maskValue(unmasked), masked = props4.fillMask !== false ? fillWithMask(preMasked) : preMasked, changed2 = innerValue.value !== masked;
    inp.value !== masked && (inp.value = masked);
    changed2 === true && (innerValue.value = masked);
    document.activeElement === inp && nextTick(() => {
      if (masked === maskReplaced) {
        const cursor = props4.reverseFillMask === true ? maskReplaced.length : 0;
        inp.setSelectionRange(cursor, cursor, "forward");
        return;
      }
      if (inputType === "insertFromPaste" && props4.reverseFillMask !== true) {
        const maxEnd = inp.selectionEnd;
        let cursor = end - 1;
        for (let i = pastedTextStart; i <= cursor && i < maxEnd; i++) {
          if (maskMarked[i] !== MARKER) {
            cursor++;
          }
        }
        moveCursor.right(inp, cursor);
        return;
      }
      if (["deleteContentBackward", "deleteContentForward"].indexOf(inputType) !== -1) {
        const cursor = props4.reverseFillMask === true ? end === 0 ? masked.length > preMasked.length ? 1 : 0 : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1 : end;
        inp.setSelectionRange(cursor, cursor, "forward");
        return;
      }
      if (props4.reverseFillMask === true) {
        if (changed2 === true) {
          const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));
          if (cursor === 1 && end === 1) {
            inp.setSelectionRange(cursor, cursor, "forward");
          } else {
            moveCursor.rightReverse(inp, cursor);
          }
        } else {
          const cursor = masked.length - endReverse;
          inp.setSelectionRange(cursor, cursor, "backward");
        }
      } else {
        if (changed2 === true) {
          const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);
          moveCursor.right(inp, cursor);
        } else {
          const cursor = end - 1;
          moveCursor.right(inp, cursor);
        }
      }
    });
    const val = props4.unmaskedValue === true ? unmaskValue(masked) : masked;
    if (String(props4.modelValue) !== val && (props4.modelValue !== null || val !== "")) {
      emitValue(val, true);
    }
  }
  function moveCursorForPaste(inp, start, end) {
    const preMasked = maskValue(unmaskValue(inp.value));
    start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));
    pastedTextStart = start;
    inp.setSelectionRange(start, end, "forward");
  }
  const moveCursor = {
    left(inp, cursor) {
      const noMarkBefore = maskMarked.slice(cursor - 1).indexOf(MARKER) === -1;
      let i = Math.max(0, cursor - 1);
      for (; i >= 0; i--) {
        if (maskMarked[i] === MARKER) {
          cursor = i;
          noMarkBefore === true && cursor++;
          break;
        }
      }
      if (i < 0 && maskMarked[cursor] !== void 0 && maskMarked[cursor] !== MARKER) {
        return moveCursor.right(inp, 0);
      }
      cursor >= 0 && inp.setSelectionRange(cursor, cursor, "backward");
    },
    right(inp, cursor) {
      const limit = inp.value.length;
      let i = Math.min(limit, cursor + 1);
      for (; i <= limit; i++) {
        if (maskMarked[i] === MARKER) {
          cursor = i;
          break;
        } else if (maskMarked[i - 1] === MARKER) {
          cursor = i;
        }
      }
      if (i > limit && maskMarked[cursor - 1] !== void 0 && maskMarked[cursor - 1] !== MARKER) {
        return moveCursor.left(inp, limit);
      }
      inp.setSelectionRange(cursor, cursor, "forward");
    },
    leftReverse(inp, cursor) {
      const localMaskMarked = getPaddedMaskMarked(inp.value.length);
      let i = Math.max(0, cursor - 1);
      for (; i >= 0; i--) {
        if (localMaskMarked[i - 1] === MARKER) {
          cursor = i;
          break;
        } else if (localMaskMarked[i] === MARKER) {
          cursor = i;
          if (i === 0) {
            break;
          }
        }
      }
      if (i < 0 && localMaskMarked[cursor] !== void 0 && localMaskMarked[cursor] !== MARKER) {
        return moveCursor.rightReverse(inp, 0);
      }
      cursor >= 0 && inp.setSelectionRange(cursor, cursor, "backward");
    },
    rightReverse(inp, cursor) {
      const limit = inp.value.length, localMaskMarked = getPaddedMaskMarked(limit), noMarkBefore = localMaskMarked.slice(0, cursor + 1).indexOf(MARKER) === -1;
      let i = Math.min(limit, cursor + 1);
      for (; i <= limit; i++) {
        if (localMaskMarked[i - 1] === MARKER) {
          cursor = i;
          cursor > 0 && noMarkBefore === true && cursor--;
          break;
        }
      }
      if (i > limit && localMaskMarked[cursor - 1] !== void 0 && localMaskMarked[cursor - 1] !== MARKER) {
        return moveCursor.leftReverse(inp, limit);
      }
      inp.setSelectionRange(cursor, cursor, "forward");
    }
  };
  function onMaskedClick(e) {
    emit2("click", e);
    selectionAnchor = void 0;
  }
  function onMaskedKeydown(e) {
    emit2("keydown", e);
    if (shouldIgnoreKey(e) === true || e.altKey === true) {
      return;
    }
    const inp = inputRef.value, start = inp.selectionStart, end = inp.selectionEnd;
    if (!e.shiftKey) {
      selectionAnchor = void 0;
    }
    if (e.keyCode === 37 || e.keyCode === 39) {
      if (e.shiftKey && selectionAnchor === void 0) {
        selectionAnchor = inp.selectionDirection === "forward" ? start : end;
      }
      const fn = moveCursor[(e.keyCode === 39 ? "right" : "left") + (props4.reverseFillMask === true ? "Reverse" : "")];
      e.preventDefault();
      fn(inp, selectionAnchor === start ? end : start);
      if (e.shiftKey) {
        const cursor = inp.selectionStart;
        inp.setSelectionRange(Math.min(selectionAnchor, cursor), Math.max(selectionAnchor, cursor), "forward");
      }
    } else if (e.keyCode === 8 && props4.reverseFillMask !== true && start === end) {
      moveCursor.left(inp, start);
      inp.setSelectionRange(inp.selectionStart, end, "backward");
    } else if (e.keyCode === 46 && props4.reverseFillMask === true && start === end) {
      moveCursor.rightReverse(inp, end);
      inp.setSelectionRange(start, inp.selectionEnd, "forward");
    }
  }
  function maskValue(val) {
    if (val === void 0 || val === null || val === "") {
      return "";
    }
    if (props4.reverseFillMask === true) {
      return maskValueReverse(val);
    }
    const mask = computedMask;
    let valIndex = 0, output = "";
    for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {
      const valChar = val[valIndex], maskDef = mask[maskIndex];
      if (typeof maskDef === "string") {
        output += maskDef;
        valChar === maskDef && valIndex++;
      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
        output += maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar;
        valIndex++;
      } else {
        return output;
      }
    }
    return output;
  }
  function maskValueReverse(val) {
    const mask = computedMask, firstTokenIndex = maskMarked.indexOf(MARKER);
    let valIndex = val.length - 1, output = "";
    for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex !== -1; maskIndex--) {
      const maskDef = mask[maskIndex];
      let valChar = val[valIndex];
      if (typeof maskDef === "string") {
        output = maskDef + output;
        valChar === maskDef && valIndex--;
      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
        do {
          output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;
          valIndex--;
          valChar = val[valIndex];
        } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar));
      } else {
        return output;
      }
    }
    return output;
  }
  function unmaskValue(val) {
    return typeof val !== "string" || computedUnmask === void 0 ? typeof val === "number" ? computedUnmask("" + val) : val : computedUnmask(val);
  }
  function fillWithMask(val) {
    if (maskReplaced.length - val.length <= 0) {
      return val;
    }
    return props4.reverseFillMask === true && val.length !== 0 ? maskReplaced.slice(0, -val.length) + val : val + maskReplaced.slice(val.length);
  }
  return {
    innerValue,
    hasMask,
    moveCursorForPaste,
    updateMaskValue,
    onMaskedKeydown,
    onMaskedClick
  };
}
var isJapanese = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/;
var isChinese = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u;
var isKorean = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/;
var isPlainText = /[a-z0-9_ -]$/i;
function use_key_composition_default(onInput) {
  return function onComposition(e) {
    if (e.type === "compositionend" || e.type === "change") {
      if (e.target.qComposing !== true) return;
      e.target.qComposing = false;
      onInput(e);
    } else if (e.type === "compositionupdate" && e.target.qComposing !== true && typeof e.data === "string") {
      const isComposing = client.is.firefox === true ? isPlainText.test(e.data) === false : isJapanese.test(e.data) === true || isChinese.test(e.data) === true || isKorean.test(e.data) === true;
      if (isComposing === true) {
        e.target.qComposing = true;
      }
    }
  };
}
var QInput_default = createComponent({
  name: "QInput",
  inheritAttrs: false,
  props: {
    ...useFieldProps,
    ...useMaskProps,
    ...useFormProps,
    // override of useFieldProps > modelValue
    modelValue: [String, Number, FileList],
    shadowText: String,
    type: {
      type: String,
      default: "text"
    },
    debounce: [String, Number],
    autogrow: Boolean,
    // makes a textarea
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  emits: [
    ...useFieldEmits,
    "paste",
    "change",
    "keydown",
    "click",
    "animationend"
  ],
  setup(props4, { emit: emit2, attrs }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const temp = {};
    let emitCachedValue = NaN, typedNumber, stopValueWatcher, emitTimer = null, emitValueFn;
    const inputRef = ref(null);
    const nameProp = useFormInputNameAttr(props4);
    const {
      innerValue,
      hasMask,
      moveCursorForPaste,
      updateMaskValue,
      onMaskedKeydown,
      onMaskedClick
    } = use_mask_default(props4, emit2, emitValue, inputRef);
    const formDomProps = use_file_dom_props_default(
      props4,
      /* type guard */
      true
    );
    const hasValue = computed(() => fieldValueIsFilled(innerValue.value));
    const onComposition = use_key_composition_default(onInput);
    const state = useFieldState({ changeEvent: true });
    const isTextarea = computed(
      () => props4.type === "textarea" || props4.autogrow === true
    );
    const isTypeText = computed(
      () => isTextarea.value === true || ["text", "search", "url", "tel", "password"].includes(props4.type)
    );
    const onEvents = computed(() => {
      const evt = {
        ...state.splitAttrs.listeners.value,
        onInput,
        onPaste,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        onChange,
        onBlur: onFinishEditing,
        onFocus: stop
      };
      evt.onCompositionstart = evt.onCompositionupdate = evt.onCompositionend = onComposition;
      if (hasMask.value === true) {
        evt.onKeydown = onMaskedKeydown;
        evt.onClick = onMaskedClick;
      }
      if (props4.autogrow === true) {
        evt.onAnimationend = onAnimationend;
      }
      return evt;
    });
    const inputAttrs = computed(() => {
      const attrs2 = {
        tabindex: 0,
        "data-autofocus": props4.autofocus === true || void 0,
        rows: props4.type === "textarea" ? 6 : void 0,
        "aria-label": props4.label,
        name: nameProp.value,
        ...state.splitAttrs.attributes.value,
        id: state.targetUid.value,
        maxlength: props4.maxlength,
        disabled: props4.disable === true,
        readonly: props4.readonly === true
      };
      if (isTextarea.value === false) {
        attrs2.type = props4.type;
      }
      if (props4.autogrow === true) {
        attrs2.rows = 1;
      }
      return attrs2;
    });
    watch(() => props4.type, () => {
      if (inputRef.value) {
        inputRef.value.value = props4.modelValue;
      }
    });
    watch(() => props4.modelValue, (v2) => {
      if (hasMask.value === true) {
        if (stopValueWatcher === true) {
          stopValueWatcher = false;
          if (String(v2) === emitCachedValue) {
            return;
          }
        }
        updateMaskValue(v2);
      } else if (innerValue.value !== v2) {
        innerValue.value = v2;
        if (props4.type === "number" && temp.hasOwnProperty("value") === true) {
          if (typedNumber === true) {
            typedNumber = false;
          } else {
            delete temp.value;
          }
        }
      }
      props4.autogrow === true && nextTick(adjustHeight);
    });
    watch(() => props4.autogrow, (val) => {
      if (val === true) {
        nextTick(adjustHeight);
      } else if (inputRef.value !== null && attrs.rows > 0) {
        inputRef.value.style.height = "auto";
      }
    });
    watch(() => props4.dense, () => {
      props4.autogrow === true && nextTick(adjustHeight);
    });
    function focus() {
      addFocusFn(() => {
        const el = document.activeElement;
        if (inputRef.value !== null && inputRef.value !== el && (el === null || el.id !== state.targetUid.value)) {
          inputRef.value.focus({ preventScroll: true });
        }
      });
    }
    function select() {
      inputRef.value !== null && inputRef.value.select();
    }
    function onPaste(e) {
      if (hasMask.value === true && props4.reverseFillMask !== true) {
        const inp = e.target;
        moveCursorForPaste(inp, inp.selectionStart, inp.selectionEnd);
      }
      emit2("paste", e);
    }
    function onInput(e) {
      if (!e || !e.target) {
        return;
      }
      if (props4.type === "file") {
        emit2("update:modelValue", e.target.files);
        return;
      }
      const val = e.target.value;
      if (e.target.qComposing === true) {
        temp.value = val;
        return;
      }
      if (hasMask.value === true) {
        updateMaskValue(val, false, e.inputType);
      } else {
        emitValue(val);
        if (isTypeText.value === true && e.target === document.activeElement) {
          const { selectionStart, selectionEnd } = e.target;
          if (selectionStart !== void 0 && selectionEnd !== void 0) {
            nextTick(() => {
              if (e.target === document.activeElement && val.indexOf(e.target.value) === 0) {
                e.target.setSelectionRange(selectionStart, selectionEnd);
              }
            });
          }
        }
      }
      props4.autogrow === true && adjustHeight();
    }
    function onAnimationend(e) {
      emit2("animationend", e);
      adjustHeight();
    }
    function emitValue(val, stopWatcher) {
      emitValueFn = () => {
        emitTimer = null;
        if (props4.type !== "number" && temp.hasOwnProperty("value") === true) {
          delete temp.value;
        }
        if (props4.modelValue !== val && emitCachedValue !== val) {
          emitCachedValue = val;
          stopWatcher === true && (stopValueWatcher = true);
          emit2("update:modelValue", val);
          nextTick(() => {
            emitCachedValue === val && (emitCachedValue = NaN);
          });
        }
        emitValueFn = void 0;
      };
      if (props4.type === "number") {
        typedNumber = true;
        temp.value = val;
      }
      if (props4.debounce !== void 0) {
        emitTimer !== null && clearTimeout(emitTimer);
        temp.value = val;
        emitTimer = setTimeout(emitValueFn, props4.debounce);
      } else {
        emitValueFn();
      }
    }
    function adjustHeight() {
      requestAnimationFrame(() => {
        const inp = inputRef.value;
        if (inp !== null) {
          const parentStyle = inp.parentNode.style;
          const { scrollTop } = inp;
          const { overflowY, maxHeight } = $q.platform.is.firefox === true ? {} : window.getComputedStyle(inp);
          const changeOverflow = overflowY !== void 0 && overflowY !== "scroll";
          changeOverflow === true && (inp.style.overflowY = "hidden");
          parentStyle.marginBottom = inp.scrollHeight - 1 + "px";
          inp.style.height = "1px";
          inp.style.height = inp.scrollHeight + "px";
          changeOverflow === true && (inp.style.overflowY = parseInt(maxHeight, 10) < inp.scrollHeight ? "auto" : "hidden");
          parentStyle.marginBottom = "";
          inp.scrollTop = scrollTop;
        }
      });
    }
    function onChange(e) {
      onComposition(e);
      if (emitTimer !== null) {
        clearTimeout(emitTimer);
        emitTimer = null;
      }
      emitValueFn !== void 0 && emitValueFn();
      emit2("change", e.target.value);
    }
    function onFinishEditing(e) {
      e !== void 0 && stop(e);
      if (emitTimer !== null) {
        clearTimeout(emitTimer);
        emitTimer = null;
      }
      emitValueFn !== void 0 && emitValueFn();
      typedNumber = false;
      stopValueWatcher = false;
      delete temp.value;
      props4.type !== "file" && setTimeout(() => {
        if (inputRef.value !== null) {
          inputRef.value.value = innerValue.value !== void 0 ? innerValue.value : "";
        }
      });
    }
    function getCurValue() {
      return temp.hasOwnProperty("value") === true ? temp.value : innerValue.value !== void 0 ? innerValue.value : "";
    }
    onBeforeUnmount(() => {
      onFinishEditing();
    });
    onMounted(() => {
      props4.autogrow === true && adjustHeight();
    });
    Object.assign(state, {
      innerValue,
      fieldClass: computed(
        () => `q-${isTextarea.value === true ? "textarea" : "input"}` + (props4.autogrow === true ? " q-textarea--autogrow" : "")
      ),
      hasShadow: computed(
        () => props4.type !== "file" && typeof props4.shadowText === "string" && props4.shadowText.length !== 0
      ),
      inputRef,
      emitValue,
      hasValue,
      floatingLabel: computed(
        () => hasValue.value === true && (props4.type !== "number" || isNaN(innerValue.value) === false) || fieldValueIsFilled(props4.displayValue)
      ),
      getControl: () => {
        return h(isTextarea.value === true ? "textarea" : "input", {
          ref: inputRef,
          class: [
            "q-field__native q-placeholder",
            props4.inputClass
          ],
          style: props4.inputStyle,
          ...inputAttrs.value,
          ...onEvents.value,
          ...props4.type !== "file" ? { value: getCurValue() } : formDomProps.value
        });
      },
      getShadowControl: () => {
        return h("div", {
          class: "q-field__native q-field__shadow absolute-bottom no-pointer-events" + (isTextarea.value === true ? "" : " text-no-wrap")
        }, [
          h("span", { class: "invisible" }, getCurValue()),
          h("span", props4.shadowText)
        ]);
      }
    });
    const renderFn = use_field_default(state);
    Object.assign(proxy, {
      focus,
      select,
      getNativeElement: () => inputRef.value
      // deprecated
    });
    injectProp(proxy, "nativeEl", () => inputRef.value);
    return renderFn;
  }
});
var defaultCfg = {
  threshold: 0,
  root: null,
  rootMargin: "0px"
};
function update2(el, ctx, value2) {
  let handler, cfg, changed2;
  if (typeof value2 === "function") {
    handler = value2;
    cfg = defaultCfg;
    changed2 = ctx.cfg === void 0;
  } else {
    handler = value2.handler;
    cfg = Object.assign({}, defaultCfg, value2.cfg);
    changed2 = ctx.cfg === void 0 || isDeepEqual(ctx.cfg, cfg) === false;
  }
  if (ctx.handler !== handler) {
    ctx.handler = handler;
  }
  if (changed2 === true) {
    ctx.cfg = cfg;
    ctx.observer !== void 0 && ctx.observer.unobserve(el);
    ctx.observer = new IntersectionObserver(([entry]) => {
      if (typeof ctx.handler === "function") {
        if (entry.rootBounds === null && document.body.contains(el) === true) {
          ctx.observer.unobserve(el);
          ctx.observer.observe(el);
          return;
        }
        const res = ctx.handler(entry, ctx.observer);
        if (res === false || ctx.once === true && entry.isIntersecting === true) {
          destroy(el);
        }
      }
    }, cfg);
    ctx.observer.observe(el);
  }
}
function destroy(el) {
  const ctx = el.__qvisible;
  if (ctx !== void 0) {
    ctx.observer !== void 0 && ctx.observer.unobserve(el);
    delete el.__qvisible;
  }
}
var Intersection_default = createDirective(
  {
    name: "intersection",
    mounted(el, { modifiers, value: value2 }) {
      const ctx = {
        once: modifiers.once === true
      };
      update2(el, ctx, value2);
      el.__qvisible = ctx;
    },
    updated(el, binding) {
      const ctx = el.__qvisible;
      ctx !== void 0 && update2(el, ctx, binding.value);
    },
    beforeUnmount: destroy
  }
);
createComponent({
  name: "QIntersection",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    once: Boolean,
    transition: String,
    transitionDuration: {
      type: [String, Number],
      default: 300
    },
    ssrPrerender: Boolean,
    margin: String,
    threshold: [Number, Array],
    root: {
      default: null
    },
    disable: Boolean,
    onVisibility: Function
  },
  setup(props4, { slots, emit: emit2 }) {
    const showing = ref(isRuntimeSsrPreHydration.value === true ? props4.ssrPrerender : false);
    const intersectionProps = computed(() => props4.root !== void 0 || props4.margin !== void 0 || props4.threshold !== void 0 ? {
      handler: trigger3,
      cfg: {
        root: props4.root,
        rootMargin: props4.margin,
        threshold: props4.threshold
      }
    } : trigger3);
    const hasDirective = computed(
      () => props4.disable !== true && (isRuntimeSsrPreHydration.value !== true || props4.once !== true || props4.ssrPrerender !== true)
    );
    const directives = computed(() => {
      return [[
        Intersection_default,
        intersectionProps.value,
        void 0,
        { once: props4.once }
      ]];
    });
    const transitionStyle = computed(
      () => `--q-transition-duration: ${props4.transitionDuration}ms`
    );
    function trigger3(entry) {
      if (showing.value !== entry.isIntersecting) {
        showing.value = entry.isIntersecting;
        props4.onVisibility !== void 0 && emit2("visibility", showing.value);
      }
    }
    function getContent() {
      if (showing.value === true) {
        return [h("div", { key: "content", style: transitionStyle.value }, hSlot(slots.default))];
      }
      if (slots.hidden !== void 0) {
        return [h("div", { key: "hidden", style: transitionStyle.value }, slots.hidden())];
      }
    }
    return () => {
      const child = props4.transition ? [
        h(Transition, {
          name: "q-transition--" + props4.transition
        }, getContent)
      ] : getContent();
      return hDir(
        props4.tag,
        { class: "q-intersection" },
        child,
        "main",
        hasDirective.value,
        () => directives.value
      );
    };
  }
});
var roleAttrExceptions = ["ul", "ol"];
var QList_default = createComponent({
  name: "QList",
  props: {
    ...useDarkProps,
    bordered: Boolean,
    dense: Boolean,
    separator: Boolean,
    padding: Boolean,
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(props4, { slots }) {
    const vm2 = getCurrentInstance();
    const isDark = use_dark_default(props4, vm2.proxy.$q);
    const role = computed(
      () => roleAttrExceptions.includes(props4.tag) ? null : "list"
    );
    const classes = computed(
      () => "q-list" + (props4.bordered === true ? " q-list--bordered" : "") + (props4.dense === true ? " q-list--dense" : "") + (props4.separator === true ? " q-list--separator" : "") + (isDark.value === true ? " q-list--dark" : "") + (props4.padding === true ? " q-list--padding" : "")
    );
    return () => h(props4.tag, { class: classes.value, role: role.value }, hSlot(slots.default));
  }
});
var keyCodes2 = [34, 37, 40, 33, 39, 38];
var commonPropsName = Object.keys(useCircularCommonProps);
createComponent({
  name: "QKnob",
  props: {
    ...useFormProps,
    ...useCircularCommonProps,
    modelValue: {
      type: Number,
      required: true
    },
    innerMin: Number,
    innerMax: Number,
    step: {
      type: Number,
      default: 1,
      validator: (v2) => v2 >= 0
    },
    tabindex: {
      type: [Number, String],
      default: 0
    },
    disable: Boolean,
    readonly: Boolean
  },
  emits: ["update:modelValue", "change", "dragValue"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const model = ref(props4.modelValue);
    const dragging = ref(false);
    const innerMin = computed(() => isNaN(props4.innerMin) === true || props4.innerMin < props4.min ? props4.min : props4.innerMin);
    const innerMax = computed(() => isNaN(props4.innerMax) === true || props4.innerMax > props4.max ? props4.max : props4.innerMax);
    let centerPosition;
    function normalizeModel() {
      model.value = props4.modelValue === null ? innerMin.value : between(props4.modelValue, innerMin.value, innerMax.value);
      updateValue2(true);
    }
    watch(
      () => `${props4.modelValue}|${innerMin.value}|${innerMax.value}`,
      normalizeModel
    );
    normalizeModel();
    const editable = computed(() => props4.disable === false && props4.readonly === false);
    const classes = computed(
      () => "q-knob non-selectable" + (editable.value === true ? " q-knob--editable" : props4.disable === true ? " disabled" : "")
    );
    const decimals = computed(() => (String(props4.step).trim().split(".")[1] || "").length);
    const step = computed(() => props4.step === 0 ? 1 : props4.step);
    const instantFeedback = computed(() => props4.instantFeedback === true || dragging.value === true);
    const onEvents = $q.platform.is.mobile === true ? computed(() => editable.value === true ? { onClick } : {}) : computed(() => editable.value === true ? {
      onMousedown,
      onClick,
      onKeydown: onKeydown2,
      onKeyup: onKeyup2
    } : {});
    const attrs = computed(() => editable.value === true ? { tabindex: props4.tabindex } : { [`aria-${props4.disable === true ? "disabled" : "readonly"}`]: "true" });
    const circularProps = computed(() => {
      const agg = {};
      commonPropsName.forEach((name2) => {
        agg[name2] = props4[name2];
      });
      return agg;
    });
    function pan(event) {
      if (event.isFinal) {
        updatePosition(event.evt, true);
        dragging.value = false;
      } else if (event.isFirst) {
        updateCenterPosition();
        dragging.value = true;
        updatePosition(event.evt);
      } else {
        updatePosition(event.evt);
      }
    }
    const directives = computed(() => {
      return [[
        TouchPan_default,
        pan,
        void 0,
        { prevent: true, stop: true, mouse: true }
      ]];
    });
    function updateCenterPosition() {
      const { top, left, width: width3, height: height2 } = proxy.$el.getBoundingClientRect();
      centerPosition = {
        top: top + height2 / 2,
        left: left + width3 / 2
      };
    }
    function onMousedown(evt) {
      updateCenterPosition();
      updatePosition(evt);
    }
    function onClick(evt) {
      updateCenterPosition();
      updatePosition(evt, true);
    }
    function onKeydown2(evt) {
      if (!keyCodes2.includes(evt.keyCode)) {
        return;
      }
      stopAndPrevent(evt);
      const stepVal = ([34, 33].includes(evt.keyCode) ? 10 : 1) * step.value, offset2 = [34, 37, 40].includes(evt.keyCode) ? -stepVal : stepVal;
      model.value = between(
        parseFloat((model.value + offset2).toFixed(decimals.value)),
        innerMin.value,
        innerMax.value
      );
      updateValue2();
    }
    function updatePosition(evt, change) {
      const pos = position(evt), height2 = Math.abs(pos.top - centerPosition.top), distance = Math.sqrt(
        height2 ** 2 + Math.abs(pos.left - centerPosition.left) ** 2
      );
      let angle = Math.asin(height2 / distance) * (180 / Math.PI);
      if (pos.top < centerPosition.top) {
        angle = centerPosition.left < pos.left ? 90 - angle : 270 + angle;
      } else {
        angle = centerPosition.left < pos.left ? angle + 90 : 270 - angle;
      }
      if ($q.lang.rtl === true) {
        angle = normalizeToInterval(-angle - props4.angle, 0, 360);
      } else if (props4.angle) {
        angle = normalizeToInterval(angle - props4.angle, 0, 360);
      }
      if (props4.reverse === true) {
        angle = 360 - angle;
      }
      let newModel = props4.min + angle / 360 * (props4.max - props4.min);
      if (step.value !== 0) {
        const modulo = newModel % step.value;
        newModel = newModel - modulo + (Math.abs(modulo) >= step.value / 2 ? (modulo < 0 ? -1 : 1) * step.value : 0);
        newModel = parseFloat(newModel.toFixed(decimals.value));
      }
      newModel = between(newModel, innerMin.value, innerMax.value);
      emit2("dragValue", newModel);
      if (model.value !== newModel) {
        model.value = newModel;
      }
      updateValue2(change);
    }
    function onKeyup2(evt) {
      if (keyCodes2.includes(evt.keyCode)) {
        updateValue2(true);
      }
    }
    function updateValue2(change) {
      props4.modelValue !== model.value && emit2("update:modelValue", model.value);
      change === true && emit2("change", model.value);
    }
    const formAttrs = useFormAttrs(props4);
    function getNameInput() {
      return h("input", formAttrs.value);
    }
    return () => {
      const data = {
        class: classes.value,
        role: "slider",
        "aria-valuemin": innerMin.value,
        "aria-valuemax": innerMax.value,
        "aria-valuenow": props4.modelValue,
        ...attrs.value,
        ...circularProps.value,
        value: model.value,
        instantFeedback: instantFeedback.value,
        ...onEvents.value
      };
      const child = {
        default: slots.default
      };
      if (editable.value === true && props4.name !== void 0) {
        child.internal = getNameInput;
      }
      return hDir(
        QCircularProgress_default,
        data,
        child,
        "knob",
        editable.value,
        () => directives.value
      );
    };
  }
});
var { passive: passive3 } = listenOpts;
var axisValues = ["both", "horizontal", "vertical"];
var QScrollObserver_default = createComponent({
  name: "QScrollObserver",
  props: {
    axis: {
      type: String,
      validator: (v2) => axisValues.includes(v2),
      default: "vertical"
    },
    debounce: [String, Number],
    scrollTarget: scrollTargetProp
  },
  emits: ["scroll"],
  setup(props4, { emit: emit2 }) {
    const scroll = {
      position: {
        top: 0,
        left: 0
      },
      direction: "down",
      directionChanged: false,
      delta: {
        top: 0,
        left: 0
      },
      inflectionPoint: {
        top: 0,
        left: 0
      }
    };
    let clearTimer = null, localScrollTarget, parentEl;
    watch(() => props4.scrollTarget, () => {
      unconfigureScrollTarget();
      configureScrollTarget();
    });
    function emitEvent() {
      clearTimer !== null && clearTimer();
      const top = Math.max(0, getVerticalScrollPosition(localScrollTarget));
      const left = getHorizontalScrollPosition(localScrollTarget);
      const delta = {
        top: top - scroll.position.top,
        left: left - scroll.position.left
      };
      if (props4.axis === "vertical" && delta.top === 0 || props4.axis === "horizontal" && delta.left === 0) {
        return;
      }
      const curDir = Math.abs(delta.top) >= Math.abs(delta.left) ? delta.top < 0 ? "up" : "down" : delta.left < 0 ? "left" : "right";
      scroll.position = { top, left };
      scroll.directionChanged = scroll.direction !== curDir;
      scroll.delta = delta;
      if (scroll.directionChanged === true) {
        scroll.direction = curDir;
        scroll.inflectionPoint = scroll.position;
      }
      emit2("scroll", { ...scroll });
    }
    function configureScrollTarget() {
      localScrollTarget = getScrollTarget(parentEl, props4.scrollTarget);
      localScrollTarget.addEventListener("scroll", trigger3, passive3);
      trigger3(true);
    }
    function unconfigureScrollTarget() {
      if (localScrollTarget !== void 0) {
        localScrollTarget.removeEventListener("scroll", trigger3, passive3);
        localScrollTarget = void 0;
      }
    }
    function trigger3(immediately) {
      if (immediately === true || props4.debounce === 0 || props4.debounce === "0") {
        emitEvent();
      } else if (clearTimer === null) {
        const [timer2, fn] = props4.debounce ? [setTimeout(emitEvent, props4.debounce), clearTimeout] : [requestAnimationFrame(emitEvent), cancelAnimationFrame];
        clearTimer = () => {
          fn(timer2);
          clearTimer = null;
        };
      }
    }
    const { proxy } = getCurrentInstance();
    watch(() => proxy.$q.lang.rtl, emitEvent);
    onMounted(() => {
      parentEl = proxy.$el.parentNode;
      configureScrollTarget();
    });
    onBeforeUnmount(() => {
      clearTimer !== null && clearTimer();
      unconfigureScrollTarget();
    });
    Object.assign(proxy, {
      trigger: trigger3,
      getPosition: () => scroll
    });
    return noop;
  }
});
createComponent({
  name: "QLayout",
  props: {
    container: Boolean,
    view: {
      type: String,
      default: "hhh lpr fff",
      validator: (v2) => /^(h|l)h(h|r) lpr (f|l)f(f|r)$/.test(v2.toLowerCase())
    },
    onScroll: Function,
    onScrollHeight: Function,
    onResize: Function
  },
  setup(props4, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const rootRef = ref(null);
    const height2 = ref($q.screen.height);
    const width3 = ref(props4.container === true ? 0 : $q.screen.width);
    const scroll = ref({ position: 0, direction: "down", inflectionPoint: 0 });
    const containerHeight = ref(0);
    const scrollbarWidth = ref(isRuntimeSsrPreHydration.value === true ? 0 : getScrollbarWidth());
    const classes = computed(
      () => "q-layout q-layout--" + (props4.container === true ? "containerized" : "standard")
    );
    const style2 = computed(() => props4.container === false ? { minHeight: $q.screen.height + "px" } : null);
    const targetStyle = computed(() => scrollbarWidth.value !== 0 ? { [$q.lang.rtl === true ? "left" : "right"]: `${scrollbarWidth.value}px` } : null);
    const targetChildStyle = computed(() => scrollbarWidth.value !== 0 ? {
      [$q.lang.rtl === true ? "right" : "left"]: 0,
      [$q.lang.rtl === true ? "left" : "right"]: `-${scrollbarWidth.value}px`,
      width: `calc(100% + ${scrollbarWidth.value}px)`
    } : null);
    function onPageScroll(data) {
      if (props4.container === true || document.qScrollPrevented !== true) {
        const info = {
          position: data.position.top,
          direction: data.direction,
          directionChanged: data.directionChanged,
          inflectionPoint: data.inflectionPoint.top,
          delta: data.delta.top
        };
        scroll.value = info;
        props4.onScroll !== void 0 && emit2("scroll", info);
      }
    }
    function onPageResize(data) {
      const { height: newHeight, width: newWidth } = data;
      let resized = false;
      if (height2.value !== newHeight) {
        resized = true;
        height2.value = newHeight;
        props4.onScrollHeight !== void 0 && emit2("scrollHeight", newHeight);
        updateScrollbarWidth();
      }
      if (width3.value !== newWidth) {
        resized = true;
        width3.value = newWidth;
      }
      if (resized === true && props4.onResize !== void 0) {
        emit2("resize", data);
      }
    }
    function onContainerResize({ height: height3 }) {
      if (containerHeight.value !== height3) {
        containerHeight.value = height3;
        updateScrollbarWidth();
      }
    }
    function updateScrollbarWidth() {
      if (props4.container === true) {
        const width4 = height2.value > containerHeight.value ? getScrollbarWidth() : 0;
        if (scrollbarWidth.value !== width4) {
          scrollbarWidth.value = width4;
        }
      }
    }
    let animateTimer = null;
    const $layout = {
      instances: {},
      view: computed(() => props4.view),
      isContainer: computed(() => props4.container),
      rootRef,
      height: height2,
      containerHeight,
      scrollbarWidth,
      totalWidth: computed(() => width3.value + scrollbarWidth.value),
      rows: computed(() => {
        const rows = props4.view.toLowerCase().split(" ");
        return {
          top: rows[0].split(""),
          middle: rows[1].split(""),
          bottom: rows[2].split("")
        };
      }),
      header: reactive({ size: 0, offset: 0, space: false }),
      right: reactive({ size: 300, offset: 0, space: false }),
      footer: reactive({ size: 0, offset: 0, space: false }),
      left: reactive({ size: 300, offset: 0, space: false }),
      scroll,
      animate() {
        if (animateTimer !== null) {
          clearTimeout(animateTimer);
        } else {
          document.body.classList.add("q-body--layout-animate");
        }
        animateTimer = setTimeout(() => {
          animateTimer = null;
          document.body.classList.remove("q-body--layout-animate");
        }, 155);
      },
      update(part, prop, val) {
        $layout[part][prop] = val;
      }
    };
    provide(layoutKey, $layout);
    if (getScrollbarWidth() > 0) {
      let restoreScrollbar = function() {
        timer2 = null;
        el.classList.remove("hide-scrollbar");
      }, hideScrollbar = function() {
        if (timer2 === null) {
          if (el.scrollHeight > $q.screen.height) {
            return;
          }
          el.classList.add("hide-scrollbar");
        } else {
          clearTimeout(timer2);
        }
        timer2 = setTimeout(restoreScrollbar, 300);
      }, updateScrollEvent = function(action) {
        if (timer2 !== null && action === "remove") {
          clearTimeout(timer2);
          restoreScrollbar();
        }
        window[`${action}EventListener`]("resize", hideScrollbar);
      };
      let timer2 = null;
      const el = document.body;
      watch(
        () => props4.container !== true ? "add" : "remove",
        updateScrollEvent
      );
      props4.container !== true && updateScrollEvent("add");
      onUnmounted(() => {
        updateScrollEvent("remove");
      });
    }
    return () => {
      const content = hMergeSlot(slots.default, [
        h(QScrollObserver_default, { onScroll: onPageScroll }),
        h(QResizeObserver_default, { onResize: onPageResize })
      ]);
      const layout = h("div", {
        class: classes.value,
        style: style2.value,
        ref: props4.container === true ? void 0 : rootRef,
        tabindex: -1
      }, content);
      if (props4.container === true) {
        return h("div", {
          class: "q-layout-container overflow-hidden",
          ref: rootRef
        }, [
          h(QResizeObserver_default, { onResize: onContainerResize }),
          h("div", {
            class: "absolute-full",
            style: targetStyle.value
          }, [
            h("div", {
              class: "scroll",
              style: targetChildStyle.value
            }, [layout])
          ])
        ]);
      }
      return layout;
    };
  }
});
var separatorValues = ["horizontal", "vertical", "cell", "none"];
var QMarkupTable_default = createComponent({
  name: "QMarkupTable",
  props: {
    ...useDarkProps,
    dense: Boolean,
    flat: Boolean,
    bordered: Boolean,
    square: Boolean,
    wrapCells: Boolean,
    separator: {
      type: String,
      default: "horizontal",
      validator: (v2) => separatorValues.includes(v2)
    }
  },
  setup(props4, { slots }) {
    const vm2 = getCurrentInstance();
    const isDark = use_dark_default(props4, vm2.proxy.$q);
    const classes = computed(
      () => `q-markup-table q-table__container q-table__card q-table--${props4.separator}-separator` + (isDark.value === true ? " q-table--dark q-table__card--dark q-dark" : "") + (props4.dense === true ? " q-table--dense" : "") + (props4.flat === true ? " q-table--flat" : "") + (props4.bordered === true ? " q-table--bordered" : "") + (props4.square === true ? " q-table--square" : "") + (props4.wrapCells === false ? " q-table--no-wrap" : "")
    );
    return () => h("div", {
      class: classes.value
    }, [
      h("table", { class: "q-table" }, hSlot(slots.default))
    ]);
  }
});
createComponent({
  name: "QNoSsr",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    placeholder: String
  },
  setup(props4, { slots }) {
    const { isHydrated } = use_hydration_default();
    return () => {
      if (isHydrated.value === true) {
        const node2 = hSlot(slots.default);
        return node2 === void 0 ? node2 : node2.length > 1 ? h(props4.tag, {}, node2) : node2[0];
      }
      const data = {
        class: "q-no-ssr-placeholder"
      };
      const node = hSlot(slots.placeholder);
      if (node !== void 0) {
        return node.length > 1 ? h(props4.tag, data, node) : node[0];
      }
      if (props4.placeholder !== void 0) {
        return h(props4.tag, data, props4.placeholder);
      }
    };
  }
});
var createSvg = () => h("svg", {
  key: "svg",
  class: "q-radio__bg absolute non-selectable",
  viewBox: "0 0 24 24"
}, [
  h("path", {
    d: "M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12"
  }),
  h("path", {
    class: "q-radio__check",
    d: "M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6"
  })
]);
var QRadio_default = createComponent({
  name: "QRadio",
  props: {
    ...useDarkProps,
    ...useSizeProps,
    ...useFormProps,
    modelValue: { required: true },
    val: { required: true },
    label: String,
    leftLabel: Boolean,
    checkedIcon: String,
    uncheckedIcon: String,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  emits: ["update:modelValue"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const isDark = use_dark_default(props4, proxy.$q);
    const sizeStyle = use_size_default(props4, option_sizes_default);
    const rootRef = ref(null);
    const { refocusTargetEl, refocusTarget } = use_refocus_target_default(props4, rootRef);
    const isTrue = computed(() => toRaw(props4.modelValue) === toRaw(props4.val));
    const classes = computed(
      () => "q-radio cursor-pointer no-outline row inline no-wrap items-center" + (props4.disable === true ? " disabled" : "") + (isDark.value === true ? " q-radio--dark" : "") + (props4.dense === true ? " q-radio--dense" : "") + (props4.leftLabel === true ? " reverse" : "")
    );
    const innerClass = computed(() => {
      const color = props4.color !== void 0 && (props4.keepColor === true || isTrue.value === true) ? ` text-${props4.color}` : "";
      return `q-radio__inner relative-position q-radio__inner--${isTrue.value === true ? "truthy" : "falsy"}${color}`;
    });
    const icon2 = computed(
      () => (isTrue.value === true ? props4.checkedIcon : props4.uncheckedIcon) || null
    );
    const tabindex = computed(() => props4.disable === true ? -1 : props4.tabindex || 0);
    const formAttrs = computed(() => {
      const prop = { type: "radio" };
      props4.name !== void 0 && Object.assign(prop, {
        // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
        ".checked": isTrue.value === true,
        "^checked": isTrue.value === true ? "checked" : void 0,
        name: props4.name,
        value: props4.val
      });
      return prop;
    });
    const injectFormInput = useFormInject(formAttrs);
    function onClick(e) {
      if (e !== void 0) {
        stopAndPrevent(e);
        refocusTarget(e);
      }
      if (props4.disable !== true && isTrue.value !== true) {
        emit2("update:modelValue", props4.val, e);
      }
    }
    function onKeydown2(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        stopAndPrevent(e);
      }
    }
    function onKeyup2(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        onClick(e);
      }
    }
    Object.assign(proxy, { set: onClick });
    const svg = createSvg();
    return () => {
      const content = icon2.value !== null ? [
        h("div", {
          key: "icon",
          class: "q-radio__icon-container absolute-full flex flex-center no-wrap"
        }, [
          h(QIcon_default, {
            class: "q-radio__icon",
            name: icon2.value
          })
        ])
      ] : [svg];
      props4.disable !== true && injectFormInput(
        content,
        "unshift",
        " q-radio__native q-ma-none q-pa-none"
      );
      const child = [
        h("div", {
          class: innerClass.value,
          style: sizeStyle.value,
          "aria-hidden": "true"
        }, content)
      ];
      if (refocusTargetEl.value !== null) {
        child.push(refocusTargetEl.value);
      }
      const label2 = props4.label !== void 0 ? hMergeSlot(slots.default, [props4.label]) : hSlot(slots.default);
      label2 !== void 0 && child.push(
        h("div", {
          class: "q-radio__label q-anchor--skip"
        }, label2)
      );
      return h("div", {
        ref: rootRef,
        class: classes.value,
        tabindex: tabindex.value,
        role: "radio",
        "aria-label": props4.label,
        "aria-checked": isTrue.value === true ? "true" : "false",
        "aria-disabled": props4.disable === true ? "true" : void 0,
        onClick,
        onKeydown: onKeydown2,
        onKeyup: onKeyup2
      }, child);
    };
  }
});
var QToggle_default = createComponent({
  name: "QToggle",
  props: {
    ...useCheckboxProps,
    icon: String,
    iconColor: String
  },
  emits: useCheckboxEmits,
  setup(props4) {
    function getInner(isTrue, isIndeterminate) {
      const icon2 = computed(
        () => (isTrue.value === true ? props4.checkedIcon : isIndeterminate.value === true ? props4.indeterminateIcon : props4.uncheckedIcon) || props4.icon
      );
      const color = computed(() => isTrue.value === true ? props4.iconColor : null);
      return () => [
        h("div", { class: "q-toggle__track" }),
        h(
          "div",
          {
            class: "q-toggle__thumb absolute flex flex-center no-wrap"
          },
          icon2.value !== void 0 ? [
            h(QIcon_default, {
              name: icon2.value,
              color: color.value
            })
          ] : void 0
        )
      ];
    }
    return use_checkbox_default("toggle", getInner);
  }
});
var components = {
  radio: QRadio_default,
  checkbox: QCheckbox_default,
  toggle: QToggle_default
};
var typeValues = Object.keys(components);
function getPropValueFn(userPropName, defaultPropName) {
  if (typeof userPropName === "function") return userPropName;
  const propName = userPropName !== void 0 ? userPropName : defaultPropName;
  return (opt) => opt[propName];
}
var QOptionGroup_default = createComponent({
  name: "QOptionGroup",
  props: {
    ...useDarkProps,
    modelValue: {
      required: true
    },
    options: {
      type: Array,
      validator: (opts) => opts.every(isObject),
      default: () => []
    },
    optionValue: [Function, String],
    optionLabel: [Function, String],
    optionDisable: [Function, String],
    name: String,
    type: {
      type: String,
      default: "radio",
      validator: (v2) => typeValues.includes(v2)
    },
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    size: String,
    leftLabel: Boolean,
    inline: Boolean,
    disable: Boolean
  },
  emits: ["update:modelValue"],
  setup(props4, { emit: emit2, slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const arrayModel = Array.isArray(props4.modelValue);
    if (props4.type === "radio") {
      if (arrayModel === true) {
        console.error("q-option-group: model should not be array");
      }
    } else if (arrayModel === false) {
      console.error("q-option-group: model should be array in your case");
    }
    const isDark = use_dark_default(props4, $q);
    const component = computed(() => components[props4.type]);
    const getOptionValue = computed(() => getPropValueFn(props4.optionValue, "value"));
    const getOptionLabel = computed(() => getPropValueFn(props4.optionLabel, "label"));
    const getOptionDisable = computed(() => getPropValueFn(props4.optionDisable, "disable"));
    const innerOptions = computed(() => props4.options.map((opt) => ({
      val: getOptionValue.value(opt),
      name: opt.name === void 0 ? props4.name : opt.name,
      disable: props4.disable || getOptionDisable.value(opt),
      leftLabel: opt.leftLabel === void 0 ? props4.leftLabel : opt.leftLabel,
      color: opt.color === void 0 ? props4.color : opt.color,
      checkedIcon: opt.checkedIcon,
      uncheckedIcon: opt.uncheckedIcon,
      dark: opt.dark === void 0 ? isDark.value : opt.dark,
      size: opt.size === void 0 ? props4.size : opt.size,
      dense: props4.dense,
      keepColor: opt.keepColor === void 0 ? props4.keepColor : opt.keepColor
    })));
    const classes = computed(
      () => "q-option-group q-gutter-x-sm" + (props4.inline === true ? " q-option-group--inline" : "")
    );
    const attrs = computed(() => {
      const attrs2 = { role: "group" };
      if (props4.type === "radio") {
        attrs2.role = "radiogroup";
        if (props4.disable === true) {
          attrs2["aria-disabled"] = "true";
        }
      }
      return attrs2;
    });
    function onUpdateModelValue(value2) {
      emit2("update:modelValue", value2);
    }
    return () => h("div", {
      class: classes.value,
      ...attrs.value
    }, props4.options.map((opt, i) => {
      const child = slots["label-" + i] !== void 0 ? () => slots["label-" + i](opt) : slots.label !== void 0 ? () => slots.label(opt) : void 0;
      return h("div", [
        h(component.value, {
          label: child === void 0 ? getOptionLabel.value(opt) : null,
          modelValue: props4.modelValue,
          "onUpdate:modelValue": onUpdateModelValue,
          ...innerOptions.value[i]
        }, child)
      ]);
    }));
  }
});
createComponent({
  name: "QPage",
  props: {
    padding: Boolean,
    styleFn: Function
  },
  setup(props4, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const $layout = inject(layoutKey, emptyRenderFn);
    if ($layout === emptyRenderFn) {
      console.error("QPage needs to be a deep child of QLayout");
      return emptyRenderFn;
    }
    const $pageContainer = inject(pageContainerKey, emptyRenderFn);
    if ($pageContainer === emptyRenderFn) {
      console.error("QPage needs to be child of QPageContainer");
      return emptyRenderFn;
    }
    const style2 = computed(() => {
      const offset2 = ($layout.header.space === true ? $layout.header.size : 0) + ($layout.footer.space === true ? $layout.footer.size : 0);
      if (typeof props4.styleFn === "function") {
        const height2 = $layout.isContainer.value === true ? $layout.containerHeight.value : $q.screen.height;
        return props4.styleFn(offset2, height2);
      }
      return {
        minHeight: $layout.isContainer.value === true ? $layout.containerHeight.value - offset2 + "px" : $q.screen.height === 0 ? offset2 !== 0 ? `calc(100vh - ${offset2}px)` : "100vh" : $q.screen.height - offset2 + "px"
      };
    });
    const classes = computed(
      () => `q-page${props4.padding === true ? " q-layout-padding" : ""}`
    );
    return () => h("main", {
      class: classes.value,
      style: style2.value
    }, hSlot(slots.default));
  }
});
createComponent({
  name: "QPageContainer",
  setup(_, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const $layout = inject(layoutKey, emptyRenderFn);
    if ($layout === emptyRenderFn) {
      console.error("QPageContainer needs to be child of QLayout");
      return emptyRenderFn;
    }
    provide(pageContainerKey, true);
    const style2 = computed(() => {
      const css2 = {};
      if ($layout.header.space === true) {
        css2.paddingTop = `${$layout.header.size}px`;
      }
      if ($layout.right.space === true) {
        css2[`padding${$q.lang.rtl === true ? "Left" : "Right"}`] = `${$layout.right.size}px`;
      }
      if ($layout.footer.space === true) {
        css2.paddingBottom = `${$layout.footer.size}px`;
      }
      if ($layout.left.space === true) {
        css2[`padding${$q.lang.rtl === true ? "Right" : "Left"}`] = `${$layout.left.size}px`;
      }
      return css2;
    });
    return () => h("div", {
      class: "q-page-container",
      style: style2.value
    }, hSlot(slots.default));
  }
});
var usePageStickyProps = {
  position: {
    type: String,
    default: "bottom-right",
    validator: (v2) => [
      "top-right",
      "top-left",
      "bottom-right",
      "bottom-left",
      "top",
      "right",
      "bottom",
      "left"
    ].includes(v2)
  },
  offset: {
    type: Array,
    validator: (v2) => v2.length === 2
  },
  expand: Boolean
};
function use_page_sticky_default() {
  const { props: props4, proxy: { $q } } = getCurrentInstance();
  const $layout = inject(layoutKey, emptyRenderFn);
  if ($layout === emptyRenderFn) {
    console.error("QPageSticky needs to be child of QLayout");
    return emptyRenderFn;
  }
  const attach = computed(() => {
    const pos = props4.position;
    return {
      top: pos.indexOf("top") !== -1,
      right: pos.indexOf("right") !== -1,
      bottom: pos.indexOf("bottom") !== -1,
      left: pos.indexOf("left") !== -1,
      vertical: pos === "top" || pos === "bottom",
      horizontal: pos === "left" || pos === "right"
    };
  });
  const top = computed(() => $layout.header.offset);
  const right = computed(() => $layout.right.offset);
  const bottom = computed(() => $layout.footer.offset);
  const left = computed(() => $layout.left.offset);
  const style2 = computed(() => {
    let posX = 0, posY = 0;
    const side = attach.value;
    const dir = $q.lang.rtl === true ? -1 : 1;
    if (side.top === true && top.value !== 0) {
      posY = `${top.value}px`;
    } else if (side.bottom === true && bottom.value !== 0) {
      posY = `${-bottom.value}px`;
    }
    if (side.left === true && left.value !== 0) {
      posX = `${dir * left.value}px`;
    } else if (side.right === true && right.value !== 0) {
      posX = `${-dir * right.value}px`;
    }
    const css2 = { transform: `translate(${posX}, ${posY})` };
    if (props4.offset) {
      css2.margin = `${props4.offset[1]}px ${props4.offset[0]}px`;
    }
    if (side.vertical === true) {
      if (left.value !== 0) {
        css2[$q.lang.rtl === true ? "right" : "left"] = `${left.value}px`;
      }
      if (right.value !== 0) {
        css2[$q.lang.rtl === true ? "left" : "right"] = `${right.value}px`;
      }
    } else if (side.horizontal === true) {
      if (top.value !== 0) {
        css2.top = `${top.value}px`;
      }
      if (bottom.value !== 0) {
        css2.bottom = `${bottom.value}px`;
      }
    }
    return css2;
  });
  const classes = computed(
    () => `q-page-sticky row flex-center fixed-${props4.position} q-page-sticky--${props4.expand === true ? "expand" : "shrink"}`
  );
  function getStickyContent(slots) {
    const content = hSlot(slots.default);
    return h(
      "div",
      {
        class: classes.value,
        style: style2.value
      },
      props4.expand === true ? content : [h("div", content)]
    );
  }
  return {
    $layout,
    getStickyContent
  };
}
createComponent({
  name: "QPageScroller",
  props: {
    ...usePageStickyProps,
    scrollOffset: {
      type: Number,
      default: 1e3
    },
    reverse: Boolean,
    duration: {
      type: Number,
      default: 300
    },
    offset: {
      ...usePageStickyProps.offset,
      default: () => [18, 18]
    }
  },
  emits: ["click"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const { $layout, getStickyContent } = use_page_sticky_default();
    const rootRef = ref(null);
    let heightWatcher;
    const scrollHeight = computed(() => $layout.height.value - ($layout.isContainer.value === true ? $layout.containerHeight.value : $q.screen.height));
    function isVisible() {
      return props4.reverse === true ? scrollHeight.value - $layout.scroll.value.position > props4.scrollOffset : $layout.scroll.value.position > props4.scrollOffset;
    }
    const showing = ref(isVisible());
    function updateVisibility() {
      const newVal = isVisible();
      if (showing.value !== newVal) {
        showing.value = newVal;
      }
    }
    function updateReverse() {
      if (props4.reverse === true) {
        if (heightWatcher === void 0) {
          heightWatcher = watch(scrollHeight, updateVisibility);
        }
      } else {
        cleanup();
      }
    }
    watch($layout.scroll, updateVisibility);
    watch(() => props4.reverse, updateReverse);
    function cleanup() {
      if (heightWatcher !== void 0) {
        heightWatcher();
        heightWatcher = void 0;
      }
    }
    function onClick(e) {
      const target2 = getScrollTarget(
        $layout.isContainer.value === true ? rootRef.value : $layout.rootRef.value
      );
      setVerticalScrollPosition(
        target2,
        props4.reverse === true ? $layout.height.value : 0,
        props4.duration
      );
      emit2("click", e);
    }
    function getContent() {
      return showing.value === true ? h("div", {
        ref: rootRef,
        class: "q-page-scroller",
        onClick
      }, getStickyContent(slots)) : null;
    }
    updateReverse();
    onBeforeUnmount(cleanup);
    return () => h(
      Transition,
      { name: "q-transition--fade" },
      getContent
    );
  }
});
createComponent({
  name: "QPageSticky",
  props: usePageStickyProps,
  setup(_, { slots }) {
    const { getStickyContent } = use_page_sticky_default();
    return () => getStickyContent(slots);
  }
});
function getBool(val, otherwise) {
  return [true, false].includes(val) ? val : otherwise;
}
createComponent({
  name: "QPagination",
  props: {
    ...useDarkProps,
    modelValue: {
      type: Number,
      required: true
    },
    min: {
      type: [Number, String],
      default: 1
    },
    max: {
      type: [Number, String],
      required: true
    },
    maxPages: {
      type: [Number, String],
      default: 0,
      validator: (v2) => (typeof v2 === "string" ? parseInt(v2, 10) : v2) >= 0
    },
    inputStyle: [Array, String, Object],
    inputClass: [Array, String, Object],
    size: String,
    disable: Boolean,
    input: Boolean,
    iconPrev: String,
    iconNext: String,
    iconFirst: String,
    iconLast: String,
    toFn: Function,
    boundaryLinks: {
      type: Boolean,
      default: null
    },
    boundaryNumbers: {
      type: Boolean,
      default: null
    },
    directionLinks: {
      type: Boolean,
      default: null
    },
    ellipses: {
      type: Boolean,
      default: null
    },
    ripple: {
      type: [Boolean, Object],
      default: null
    },
    round: Boolean,
    rounded: Boolean,
    flat: Boolean,
    outline: Boolean,
    unelevated: Boolean,
    push: Boolean,
    glossy: Boolean,
    color: {
      type: String,
      default: "primary"
    },
    textColor: String,
    activeDesign: {
      type: String,
      default: "",
      values: (v2) => v2 === "" || btnDesignOptions.includes(v2)
    },
    activeColor: String,
    activeTextColor: String,
    gutter: String,
    padding: {
      type: String,
      default: "3px 2px"
    }
  },
  emits: ["update:modelValue"],
  setup(props4, { emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = use_dark_default(props4, $q);
    const minProp = computed(() => parseInt(props4.min, 10));
    const maxProp = computed(() => parseInt(props4.max, 10));
    const maxPagesProp = computed(() => parseInt(props4.maxPages, 10));
    const inputPlaceholder = computed(() => model.value + " / " + maxProp.value);
    const boundaryLinksProp = computed(() => getBool(props4.boundaryLinks, props4.input));
    const boundaryNumbersProp = computed(() => getBool(props4.boundaryNumbers, !props4.input));
    const directionLinksProp = computed(() => getBool(props4.directionLinks, props4.input));
    const ellipsesProp = computed(() => getBool(props4.ellipses, !props4.input));
    const newPage = ref(null);
    const model = computed({
      get: () => props4.modelValue,
      set: (val) => {
        val = parseInt(val, 10);
        if (props4.disable || isNaN(val)) {
          return;
        }
        const value2 = between(val, minProp.value, maxProp.value);
        if (props4.modelValue !== value2) {
          emit2("update:modelValue", value2);
        }
      }
    });
    watch(() => `${minProp.value}|${maxProp.value}`, () => {
      model.value = props4.modelValue;
    });
    const classes = computed(
      () => "q-pagination row no-wrap items-center" + (props4.disable === true ? " disabled" : "")
    );
    const gutterProp = computed(() => props4.gutter in btnPadding ? `${btnPadding[props4.gutter]}px` : props4.gutter || null);
    const gutterStyle = computed(() => gutterProp.value !== null ? `--q-pagination-gutter-parent:-${gutterProp.value};--q-pagination-gutter-child:${gutterProp.value}` : null);
    const icons = computed(() => {
      const ico = [
        props4.iconFirst || $q.iconSet.pagination.first,
        props4.iconPrev || $q.iconSet.pagination.prev,
        props4.iconNext || $q.iconSet.pagination.next,
        props4.iconLast || $q.iconSet.pagination.last
      ];
      return $q.lang.rtl === true ? ico.reverse() : ico;
    });
    const attrs = computed(() => ({
      "aria-disabled": props4.disable === true ? "true" : "false",
      role: "navigation"
    }));
    const btnDesignProp = computed(() => getBtnDesign(props4, "flat"));
    const btnProps = computed(() => ({
      [btnDesignProp.value]: true,
      round: props4.round,
      rounded: props4.rounded,
      padding: props4.padding,
      color: props4.color,
      textColor: props4.textColor,
      size: props4.size,
      ripple: props4.ripple !== null ? props4.ripple : true
    }));
    const btnActiveDesignProp = computed(() => {
      const acc = { [btnDesignProp.value]: false };
      if (props4.activeDesign !== "") {
        acc[props4.activeDesign] = true;
      }
      return acc;
    });
    const activeBtnProps = computed(() => ({
      ...btnActiveDesignProp.value,
      color: props4.activeColor || props4.color,
      textColor: props4.activeTextColor || props4.textColor
    }));
    const btnConfig = computed(() => {
      let maxPages = Math.max(
        maxPagesProp.value,
        1 + (ellipsesProp.value ? 2 : 0) + (boundaryNumbersProp.value ? 2 : 0)
      );
      const acc = {
        pgFrom: minProp.value,
        pgTo: maxProp.value,
        ellipsesStart: false,
        ellipsesEnd: false,
        boundaryStart: false,
        boundaryEnd: false,
        marginalStyle: {
          minWidth: `${Math.max(2, String(maxProp.value).length)}em`
        }
      };
      if (maxPagesProp.value && maxPages < maxProp.value - minProp.value + 1) {
        maxPages = 1 + Math.floor(maxPages / 2) * 2;
        acc.pgFrom = Math.max(minProp.value, Math.min(maxProp.value - maxPages + 1, props4.modelValue - Math.floor(maxPages / 2)));
        acc.pgTo = Math.min(maxProp.value, acc.pgFrom + maxPages - 1);
        if (boundaryNumbersProp.value) {
          acc.boundaryStart = true;
          acc.pgFrom++;
        }
        if (ellipsesProp.value && acc.pgFrom > minProp.value + (boundaryNumbersProp.value ? 1 : 0)) {
          acc.ellipsesStart = true;
          acc.pgFrom++;
        }
        if (boundaryNumbersProp.value) {
          acc.boundaryEnd = true;
          acc.pgTo--;
        }
        if (ellipsesProp.value && acc.pgTo < maxProp.value - (boundaryNumbersProp.value ? 1 : 0)) {
          acc.ellipsesEnd = true;
          acc.pgTo--;
        }
      }
      return acc;
    });
    function set2(value2) {
      model.value = value2;
    }
    function setByOffset(offset2) {
      model.value = model.value + offset2;
    }
    const inputEvents = computed(() => {
      function updateModel2() {
        model.value = newPage.value;
        newPage.value = null;
      }
      return {
        "onUpdate:modelValue": (val) => {
          newPage.value = val;
        },
        onKeyup: (e) => {
          isKeyCode(e, 13) === true && updateModel2();
        },
        onBlur: updateModel2
      };
    });
    function getBtn2(cfg, page, active) {
      const data = {
        "aria-label": page,
        "aria-current": "false",
        ...btnProps.value,
        ...cfg
      };
      if (active === true) {
        Object.assign(data, {
          "aria-current": "true",
          ...activeBtnProps.value
        });
      }
      if (page !== void 0) {
        if (props4.toFn !== void 0) {
          data.to = props4.toFn(page);
        } else {
          data.onClick = () => {
            set2(page);
          };
        }
      }
      return h(QBtn_default, data);
    }
    Object.assign(proxy, { set: set2, setByOffset });
    return () => {
      const contentStart = [];
      const contentEnd = [];
      let contentMiddle;
      if (boundaryLinksProp.value === true) {
        contentStart.push(
          getBtn2({
            key: "bls",
            disable: props4.disable || props4.modelValue <= minProp.value,
            icon: icons.value[0]
          }, minProp.value)
        );
        contentEnd.unshift(
          getBtn2({
            key: "ble",
            disable: props4.disable || props4.modelValue >= maxProp.value,
            icon: icons.value[3]
          }, maxProp.value)
        );
      }
      if (directionLinksProp.value === true) {
        contentStart.push(
          getBtn2({
            key: "bdp",
            disable: props4.disable || props4.modelValue <= minProp.value,
            icon: icons.value[1]
          }, props4.modelValue - 1)
        );
        contentEnd.unshift(
          getBtn2({
            key: "bdn",
            disable: props4.disable || props4.modelValue >= maxProp.value,
            icon: icons.value[2]
          }, props4.modelValue + 1)
        );
      }
      if (props4.input !== true) {
        contentMiddle = [];
        const { pgFrom, pgTo, marginalStyle: style2 } = btnConfig.value;
        if (btnConfig.value.boundaryStart === true) {
          const active = minProp.value === props4.modelValue;
          contentStart.push(
            getBtn2({
              key: "bns",
              style: style2,
              disable: props4.disable,
              label: minProp.value
            }, minProp.value, active)
          );
        }
        if (btnConfig.value.boundaryEnd === true) {
          const active = maxProp.value === props4.modelValue;
          contentEnd.unshift(
            getBtn2({
              key: "bne",
              style: style2,
              disable: props4.disable,
              label: maxProp.value
            }, maxProp.value, active)
          );
        }
        if (btnConfig.value.ellipsesStart === true) {
          contentStart.push(
            getBtn2({
              key: "bes",
              style: style2,
              disable: props4.disable,
              label: "",
              ripple: false
            }, pgFrom - 1)
          );
        }
        if (btnConfig.value.ellipsesEnd === true) {
          contentEnd.unshift(
            getBtn2({
              key: "bee",
              style: style2,
              disable: props4.disable,
              label: "",
              ripple: false
            }, pgTo + 1)
          );
        }
        for (let i = pgFrom; i <= pgTo; i++) {
          contentMiddle.push(
            getBtn2({
              key: `bpg${i}`,
              style: style2,
              disable: props4.disable,
              label: i
            }, i, i === props4.modelValue)
          );
        }
      }
      return h("div", {
        class: classes.value,
        ...attrs.value
      }, [
        h("div", {
          class: "q-pagination__content row no-wrap items-center",
          style: gutterStyle.value
        }, [
          ...contentStart,
          props4.input === true ? h(QInput_default, {
            class: "inline",
            style: { width: `${inputPlaceholder.value.length / 1.5}em` },
            type: "number",
            dense: true,
            value: newPage.value,
            disable: props4.disable,
            dark: isDark.value,
            borderless: true,
            inputClass: props4.inputClass,
            inputStyle: props4.inputStyle,
            placeholder: inputPlaceholder.value,
            min: minProp.value,
            max: maxProp.value,
            ...inputEvents.value
          }) : h("div", {
            class: "q-pagination__middle row justify-center"
          }, contentMiddle),
          ...contentEnd
        ])
      ]);
    };
  }
});
function frame_debounce_default(fn) {
  let wait = false, frame, callArgs;
  function debounced() {
    callArgs = arguments;
    if (wait === true) return;
    wait = true;
    frame = window.requestAnimationFrame(() => {
      fn.apply(this, callArgs);
      callArgs = void 0;
      wait = false;
    });
  }
  debounced.cancel = () => {
    window.cancelAnimationFrame(frame);
    wait = false;
  };
  return debounced;
}
var { passive: passive4 } = listenOpts;
createComponent({
  name: "QParallax",
  props: {
    src: String,
    height: {
      type: Number,
      default: 500
    },
    speed: {
      type: Number,
      default: 1,
      validator: (v2) => v2 >= 0 && v2 <= 1
    },
    scrollTarget: scrollTargetProp,
    onScroll: Function
  },
  setup(props4, { slots, emit: emit2 }) {
    const percentScrolled = ref(0);
    const rootRef = ref(null);
    const mediaParentRef = ref(null);
    const mediaRef = ref(null);
    let isWorking, mediaEl, mediaHeight, resizeHandler, observer, localScrollTarget;
    watch(() => props4.height, () => {
      isWorking === true && updatePos();
    });
    watch(() => props4.scrollTarget, () => {
      if (isWorking === true) {
        stop2();
        start();
      }
    });
    let update6 = (percentage) => {
      percentScrolled.value = percentage;
      props4.onScroll !== void 0 && emit2("scroll", percentage);
    };
    function updatePos() {
      let containerTop, containerHeight, containerBottom;
      if (localScrollTarget === window) {
        containerTop = 0;
        containerBottom = containerHeight = window.innerHeight;
      } else {
        containerTop = offset(localScrollTarget).top;
        containerHeight = height(localScrollTarget);
        containerBottom = containerTop + containerHeight;
      }
      const top = offset(rootRef.value).top;
      const bottom = top + props4.height;
      if (observer !== void 0 || bottom > containerTop && top < containerBottom) {
        const percent = (containerBottom - top) / (props4.height + containerHeight);
        setPos((mediaHeight - props4.height) * percent * props4.speed);
        update6(percent);
      }
    }
    let setPos = (offset2) => {
      mediaEl.style.transform = `translate3d(-50%,${Math.round(offset2)}px,0)`;
    };
    function onResize() {
      mediaHeight = mediaEl.naturalHeight || mediaEl.videoHeight || height(mediaEl);
      isWorking === true && updatePos();
    }
    function start() {
      isWorking = true;
      localScrollTarget = getScrollTarget(rootRef.value, props4.scrollTarget);
      localScrollTarget.addEventListener("scroll", updatePos, passive4);
      window.addEventListener("resize", resizeHandler, passive4);
      updatePos();
    }
    function stop2() {
      if (isWorking === true) {
        isWorking = false;
        localScrollTarget.removeEventListener("scroll", updatePos, passive4);
        window.removeEventListener("resize", resizeHandler, passive4);
        localScrollTarget = void 0;
        setPos.cancel();
        update6.cancel();
        resizeHandler.cancel();
      }
    }
    onMounted(() => {
      setPos = frame_debounce_default(setPos);
      update6 = frame_debounce_default(update6);
      resizeHandler = frame_debounce_default(onResize);
      mediaEl = slots.media !== void 0 ? mediaParentRef.value.children[0] : mediaRef.value;
      mediaEl.onload = mediaEl.onloadstart = mediaEl.loadedmetadata = onResize;
      onResize();
      mediaEl.style.display = "initial";
      if (window.IntersectionObserver !== void 0) {
        observer = new IntersectionObserver((entries) => {
          const fn = entries[0].isIntersecting === true ? start : stop2;
          fn();
        });
        observer.observe(rootRef.value);
      } else {
        start();
      }
    });
    onBeforeUnmount(() => {
      stop2();
      observer !== void 0 && observer.disconnect();
      mediaEl.onload = mediaEl.onloadstart = mediaEl.loadedmetadata = null;
    });
    return () => {
      return h("div", {
        ref: rootRef,
        class: "q-parallax",
        style: { height: `${props4.height}px` }
      }, [
        h("div", {
          ref: mediaParentRef,
          class: "q-parallax__media absolute-full"
        }, slots.media !== void 0 ? slots.media() : [
          h("img", {
            ref: mediaRef,
            src: props4.src
          })
        ]),
        h(
          "div",
          { class: "q-parallax__content absolute-full column flex-center" },
          slots.content !== void 0 ? slots.content({ percentScrolled: percentScrolled.value }) : hSlot(slots.default)
        )
      ]);
    };
  }
});
function cloneDeep(data, hash = /* @__PURE__ */ new WeakMap()) {
  if (Object(data) !== data) return data;
  if (hash.has(data)) return hash.get(data);
  const result = data instanceof Date ? new Date(data) : data instanceof RegExp ? new RegExp(data.source, data.flags) : data instanceof Set ? /* @__PURE__ */ new Set() : data instanceof Map ? /* @__PURE__ */ new Map() : typeof data.constructor !== "function" ? /* @__PURE__ */ Object.create(null) : data.prototype !== void 0 && typeof data.prototype.constructor === "function" ? data : new data.constructor();
  if (typeof data.constructor === "function" && typeof data.valueOf === "function") {
    const val = data.valueOf();
    if (Object(val) !== val) {
      const result2 = new data.constructor(val);
      hash.set(data, result2);
      return result2;
    }
  }
  hash.set(data, result);
  if (data instanceof Set) {
    data.forEach((val) => {
      result.add(cloneDeep(val, hash));
    });
  } else if (data instanceof Map) {
    data.forEach((val, key) => {
      result.set(key, cloneDeep(val, hash));
    });
  }
  return Object.assign(
    result,
    ...Object.keys(data).map((key) => ({ [key]: cloneDeep(data[key], hash) }))
  );
}
createComponent({
  name: "QPopupEdit",
  props: {
    modelValue: {
      required: true
    },
    title: String,
    buttons: Boolean,
    labelSet: String,
    labelCancel: String,
    color: {
      type: String,
      default: "primary"
    },
    validate: {
      type: Function,
      default: () => true
    },
    autoSave: Boolean,
    /* menu props overrides */
    cover: {
      type: Boolean,
      default: true
    },
    /* end of menu props */
    disable: Boolean
  },
  emits: [
    "update:modelValue",
    "save",
    "cancel",
    "beforeShow",
    "show",
    "beforeHide",
    "hide"
  ],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const menuRef = ref(null);
    const initialValue = ref("");
    const currentModel = ref("");
    let validated = false;
    const scope = computed(() => {
      return injectProp({
        initialValue: initialValue.value,
        validate: props4.validate,
        set: set2,
        cancel,
        updatePosition
      }, "value", () => currentModel.value, (val) => {
        currentModel.value = val;
      });
    });
    function set2() {
      if (props4.validate(currentModel.value) === false) {
        return;
      }
      if (hasModelChanged() === true) {
        emit2("save", currentModel.value, initialValue.value);
        emit2("update:modelValue", currentModel.value);
      }
      closeMenu();
    }
    function cancel() {
      if (hasModelChanged() === true) {
        emit2("cancel", currentModel.value, initialValue.value);
      }
      closeMenu();
    }
    function updatePosition() {
      nextTick(() => {
        menuRef.value.updatePosition();
      });
    }
    function hasModelChanged() {
      return isDeepEqual(currentModel.value, initialValue.value) === false;
    }
    function closeMenu() {
      validated = true;
      menuRef.value.hide();
    }
    function onBeforeShow() {
      validated = false;
      initialValue.value = cloneDeep(props4.modelValue);
      currentModel.value = cloneDeep(props4.modelValue);
      emit2("beforeShow");
    }
    function onShow() {
      emit2("show");
    }
    function onBeforeHide() {
      if (validated === false && hasModelChanged() === true) {
        if (props4.autoSave === true && props4.validate(currentModel.value) === true) {
          emit2("save", currentModel.value, initialValue.value);
          emit2("update:modelValue", currentModel.value);
        } else {
          emit2("cancel", currentModel.value, initialValue.value);
        }
      }
      emit2("beforeHide");
    }
    function onHide() {
      emit2("hide");
    }
    function getContent() {
      const child = slots.default !== void 0 ? [].concat(slots.default(scope.value)) : [];
      props4.title && child.unshift(
        h("div", { class: "q-dialog__title q-mt-sm q-mb-sm" }, props4.title)
      );
      props4.buttons === true && child.push(
        h("div", { class: "q-popup-edit__buttons row justify-center no-wrap" }, [
          h(QBtn_default, {
            flat: true,
            color: props4.color,
            label: props4.labelCancel || $q.lang.label.cancel,
            onClick: cancel
          }),
          h(QBtn_default, {
            flat: true,
            color: props4.color,
            label: props4.labelSet || $q.lang.label.set,
            onClick: set2
          })
        ])
      );
      return child;
    }
    Object.assign(proxy, {
      set: set2,
      cancel,
      show(e) {
        menuRef.value !== null && menuRef.value.show(e);
      },
      hide(e) {
        menuRef.value !== null && menuRef.value.hide(e);
      },
      updatePosition
    });
    return () => {
      if (props4.disable === true) return;
      return h(QMenu_default, {
        ref: menuRef,
        class: "q-popup-edit",
        cover: props4.cover,
        onBeforeShow,
        onShow,
        onBeforeHide,
        onHide,
        onEscapeKey: cancel
      }, getContent);
    };
  }
});
createComponent({
  name: "QPopupProxy",
  props: {
    ...useAnchorProps,
    breakpoint: {
      type: [String, Number],
      default: 450
    }
  },
  emits: ["show", "hide"],
  setup(props4, { slots, emit: emit2, attrs }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const showing = ref(false);
    const popupRef = ref(null);
    const breakpoint = computed(() => parseInt(props4.breakpoint, 10));
    const { canShow } = use_anchor_default({ showing });
    function getType() {
      return $q.screen.width < breakpoint.value || $q.screen.height < breakpoint.value ? "dialog" : "menu";
    }
    const type = ref(getType());
    const popupProps = computed(
      () => type.value === "menu" ? { maxHeight: "99vh" } : {}
    );
    watch(() => getType(), (val) => {
      if (showing.value !== true) {
        type.value = val;
      }
    });
    function onShow(evt) {
      showing.value = true;
      emit2("show", evt);
    }
    function onHide(evt) {
      showing.value = false;
      type.value = getType();
      emit2("hide", evt);
    }
    Object.assign(proxy, {
      show(evt) {
        canShow(evt) === true && popupRef.value.show(evt);
      },
      hide(evt) {
        popupRef.value.hide(evt);
      },
      toggle(evt) {
        popupRef.value.toggle(evt);
      }
    });
    injectProp(proxy, "currentComponent", () => ({
      type: type.value,
      ref: popupRef.value
    }));
    return () => {
      const data = {
        ref: popupRef,
        ...popupProps.value,
        ...attrs,
        onShow,
        onHide
      };
      let component;
      if (type.value === "dialog") {
        component = QDialog_default;
      } else {
        component = QMenu_default;
        Object.assign(data, {
          target: props4.target,
          contextMenu: props4.contextMenu,
          noParentEvent: true,
          separateClosePopup: true
        });
      }
      return h(component, data, slots.default);
    };
  }
});
var defaultSizes3 = {
  xs: 2,
  sm: 4,
  md: 6,
  lg: 10,
  xl: 14
};
function width2(val, reverse, $q) {
  return {
    transform: reverse === true ? `translateX(${$q.lang.rtl === true ? "-" : ""}100%) scale3d(${-val},1,1)` : `scale3d(${val},1,1)`
  };
}
var QLinearProgress_default = createComponent({
  name: "QLinearProgress",
  props: {
    ...useDarkProps,
    ...useSizeProps,
    value: {
      type: Number,
      default: 0
    },
    buffer: Number,
    color: String,
    trackColor: String,
    reverse: Boolean,
    stripe: Boolean,
    indeterminate: Boolean,
    query: Boolean,
    rounded: Boolean,
    animationSpeed: {
      type: [String, Number],
      default: 2100
    },
    instantFeedback: Boolean
  },
  setup(props4, { slots }) {
    const { proxy } = getCurrentInstance();
    const isDark = use_dark_default(props4, proxy.$q);
    const sizeStyle = use_size_default(props4, defaultSizes3);
    const motion = computed(() => props4.indeterminate === true || props4.query === true);
    const widthReverse = computed(() => props4.reverse !== props4.query);
    const style2 = computed(() => ({
      ...sizeStyle.value !== null ? sizeStyle.value : {},
      "--q-linear-progress-speed": `${props4.animationSpeed}ms`
    }));
    const classes = computed(
      () => "q-linear-progress" + (props4.color !== void 0 ? ` text-${props4.color}` : "") + (props4.reverse === true || props4.query === true ? " q-linear-progress--reverse" : "") + (props4.rounded === true ? " rounded-borders" : "")
    );
    const trackStyle = computed(() => width2(props4.buffer !== void 0 ? props4.buffer : 1, widthReverse.value, proxy.$q));
    const transitionSuffix = computed(() => `with${props4.instantFeedback === true ? "out" : ""}-transition`);
    const trackClass = computed(
      () => `q-linear-progress__track absolute-full q-linear-progress__track--${transitionSuffix.value} q-linear-progress__track--${isDark.value === true ? "dark" : "light"}` + (props4.trackColor !== void 0 ? ` bg-${props4.trackColor}` : "")
    );
    const modelStyle = computed(() => width2(motion.value === true ? 1 : props4.value, widthReverse.value, proxy.$q));
    const modelClass = computed(
      () => `q-linear-progress__model absolute-full q-linear-progress__model--${transitionSuffix.value} q-linear-progress__model--${motion.value === true ? "in" : ""}determinate`
    );
    const stripeStyle = computed(() => ({ width: `${props4.value * 100}%` }));
    const stripeClass = computed(
      () => `q-linear-progress__stripe absolute-${props4.reverse === true ? "right" : "left"} q-linear-progress__stripe--${transitionSuffix.value}`
    );
    return () => {
      const child = [
        h("div", {
          class: trackClass.value,
          style: trackStyle.value
        }),
        h("div", {
          class: modelClass.value,
          style: modelStyle.value
        })
      ];
      props4.stripe === true && motion.value === false && child.push(
        h("div", {
          class: stripeClass.value,
          style: stripeStyle.value
        })
      );
      return h("div", {
        class: classes.value,
        style: style2.value,
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 1,
        "aria-valuenow": props4.indeterminate === true ? void 0 : props4.value
      }, hMergeSlot(slots.default, child));
    };
  }
});
var PULLER_HEIGHT = 40;
var OFFSET_TOP = 20;
createComponent({
  name: "QPullToRefresh",
  props: {
    color: String,
    bgColor: String,
    icon: String,
    noMouse: Boolean,
    disable: Boolean,
    scrollTarget: scrollTargetProp
  },
  emits: ["refresh"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const state = ref("pull");
    const pullRatio = ref(0);
    const pulling = ref(false);
    const pullPosition = ref(-PULLER_HEIGHT);
    const animating = ref(false);
    const positionCSS = ref({});
    const style2 = computed(() => ({
      opacity: pullRatio.value,
      transform: `translateY(${pullPosition.value}px) rotate(${pullRatio.value * 360}deg)`
    }));
    const classes = computed(
      () => "q-pull-to-refresh__puller row flex-center" + (animating.value === true ? " q-pull-to-refresh__puller--animating" : "") + (props4.bgColor !== void 0 ? ` bg-${props4.bgColor}` : "")
    );
    function pull(event) {
      if (event.isFinal === true) {
        if (pulling.value === true) {
          pulling.value = false;
          if (state.value === "pulled") {
            state.value = "refreshing";
            animateTo({ pos: OFFSET_TOP });
            trigger3();
          } else if (state.value === "pull") {
            animateTo({ pos: -PULLER_HEIGHT, ratio: 0 });
          }
        }
        return;
      }
      if (animating.value === true || state.value === "refreshing") {
        return false;
      }
      if (event.isFirst === true) {
        if (getVerticalScrollPosition(localScrollTarget) !== 0 || event.direction !== "down") {
          if (pulling.value === true) {
            pulling.value = false;
            state.value = "pull";
            animateTo({ pos: -PULLER_HEIGHT, ratio: 0 });
          }
          return false;
        }
        pulling.value = true;
        const { top, left } = $el.getBoundingClientRect();
        positionCSS.value = {
          top: top + "px",
          left: left + "px",
          width: window.getComputedStyle($el).getPropertyValue("width")
        };
      }
      prevent(event.evt);
      const distance = Math.min(140, Math.max(0, event.distance.y));
      pullPosition.value = distance - PULLER_HEIGHT;
      pullRatio.value = between(distance / (OFFSET_TOP + PULLER_HEIGHT), 0, 1);
      const newState = pullPosition.value > OFFSET_TOP ? "pulled" : "pull";
      if (state.value !== newState) {
        state.value = newState;
      }
    }
    const directives = computed(() => {
      const modifiers = { down: true };
      if (props4.noMouse !== true) {
        modifiers.mouse = true;
      }
      return [[
        TouchPan_default,
        pull,
        void 0,
        modifiers
      ]];
    });
    const contentClass = computed(
      () => `q-pull-to-refresh__content${pulling.value === true ? " no-pointer-events" : ""}`
    );
    function trigger3() {
      emit2("refresh", () => {
        animateTo({ pos: -PULLER_HEIGHT, ratio: 0 }, () => {
          state.value = "pull";
        });
      });
    }
    let $el, localScrollTarget, timer2 = null;
    function animateTo({ pos, ratio }, done) {
      animating.value = true;
      pullPosition.value = pos;
      if (ratio !== void 0) {
        pullRatio.value = ratio;
      }
      timer2 !== null && clearTimeout(timer2);
      timer2 = setTimeout(() => {
        timer2 = null;
        animating.value = false;
        done && done();
      }, 300);
    }
    function updateScrollTarget() {
      localScrollTarget = getScrollTarget($el, props4.scrollTarget);
    }
    watch(() => props4.scrollTarget, updateScrollTarget);
    onMounted(() => {
      $el = proxy.$el;
      updateScrollTarget();
    });
    onBeforeUnmount(() => {
      timer2 !== null && clearTimeout(timer2);
    });
    Object.assign(proxy, { trigger: trigger3, updateScrollTarget });
    return () => {
      const child = [
        h("div", { class: contentClass.value }, hSlot(slots.default)),
        h("div", {
          class: "q-pull-to-refresh__puller-container fixed row flex-center no-pointer-events z-top",
          style: positionCSS.value
        }, [
          h("div", {
            class: classes.value,
            style: style2.value
          }, [
            state.value !== "refreshing" ? h(QIcon_default, {
              name: props4.icon || $q.iconSet.pullToRefresh.icon,
              color: props4.color,
              size: "32px"
            }) : h(QSpinner_default, {
              size: "24px",
              color: props4.color
            })
          ])
        ])
      ];
      return hDir(
        "div",
        { class: "q-pull-to-refresh" },
        child,
        "main",
        props4.disable === false,
        () => directives.value
      );
    };
  }
});
var dragType = {
  MIN: 0,
  RANGE: 1,
  MAX: 2
};
createComponent({
  name: "QRange",
  props: {
    ...useSliderProps,
    modelValue: {
      type: Object,
      default: () => ({ min: null, max: null }),
      validator: (v2) => "min" in v2 && "max" in v2
    },
    dragRange: Boolean,
    dragOnlyRange: Boolean,
    leftLabelColor: String,
    leftLabelTextColor: String,
    rightLabelColor: String,
    rightLabelTextColor: String,
    leftLabelValue: [String, Number],
    rightLabelValue: [String, Number],
    leftThumbColor: String,
    rightThumbColor: String
  },
  emits: useSliderEmits,
  setup(props4, { emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const { state, methods } = use_slider_default({
      updateValue: updateValue2,
      updatePosition,
      getDragging,
      formAttrs: computed(() => ({
        type: "hidden",
        name: props4.name,
        value: `${props4.modelValue.min}|${props4.modelValue.max}`
      }))
    });
    const rootRef = ref(null);
    const curMinRatio = ref(0);
    const curMaxRatio = ref(0);
    const model = ref({ min: 0, max: 0 });
    function normalizeModel() {
      model.value.min = props4.modelValue.min === null ? state.innerMin.value : between(props4.modelValue.min, state.innerMin.value, state.innerMax.value);
      model.value.max = props4.modelValue.max === null ? state.innerMax.value : between(props4.modelValue.max, state.innerMin.value, state.innerMax.value);
    }
    watch(
      () => `${props4.modelValue.min}|${props4.modelValue.max}|${state.innerMin.value}|${state.innerMax.value}`,
      normalizeModel
    );
    normalizeModel();
    const modelMinRatio = computed(() => methods.convertModelToRatio(model.value.min));
    const modelMaxRatio = computed(() => methods.convertModelToRatio(model.value.max));
    const ratioMin = computed(() => state.active.value === true ? curMinRatio.value : modelMinRatio.value);
    const ratioMax = computed(() => state.active.value === true ? curMaxRatio.value : modelMaxRatio.value);
    const selectionBarStyle = computed(() => {
      const acc = {
        [state.positionProp.value]: `${100 * ratioMin.value}%`,
        [state.sizeProp.value]: `${100 * (ratioMax.value - ratioMin.value)}%`
      };
      if (props4.selectionImg !== void 0) {
        acc.backgroundImage = `url(${props4.selectionImg}) !important`;
      }
      return acc;
    });
    const trackContainerEvents = computed(() => {
      if (state.editable.value !== true) {
        return {};
      }
      if ($q.platform.is.mobile === true) {
        return { onClick: methods.onMobileClick };
      }
      const evt = { onMousedown: methods.onActivate };
      if (props4.dragRange === true || props4.dragOnlyRange === true) {
        Object.assign(evt, {
          onFocus: () => {
            state.focus.value = "both";
          },
          onBlur: methods.onBlur,
          onKeydown: onKeydown2,
          onKeyup: methods.onKeyup
        });
      }
      return evt;
    });
    function getEvents(side) {
      return $q.platform.is.mobile !== true && state.editable.value === true && props4.dragOnlyRange !== true ? {
        onFocus: () => {
          state.focus.value = side;
        },
        onBlur: methods.onBlur,
        onKeydown: onKeydown2,
        onKeyup: methods.onKeyup
      } : {};
    }
    const thumbTabindex = computed(() => props4.dragOnlyRange !== true ? state.tabindex.value : null);
    const trackContainerTabindex = computed(() => $q.platform.is.mobile !== true && (props4.dragRange || props4.dragOnlyRange === true) ? state.tabindex.value : null);
    const minThumbRef = ref(null);
    const minEvents = computed(() => getEvents("min"));
    const getMinThumb = methods.getThumbRenderFn({
      focusValue: "min",
      getNodeData: () => ({
        ref: minThumbRef,
        key: "tmin",
        ...minEvents.value,
        tabindex: thumbTabindex.value
      }),
      ratio: ratioMin,
      label: computed(() => props4.leftLabelValue !== void 0 ? props4.leftLabelValue : model.value.min),
      thumbColor: computed(() => props4.leftThumbColor || props4.thumbColor || props4.color),
      labelColor: computed(() => props4.leftLabelColor || props4.labelColor),
      labelTextColor: computed(() => props4.leftLabelTextColor || props4.labelTextColor)
    });
    const maxEvents = computed(() => getEvents("max"));
    const getMaxThumb = methods.getThumbRenderFn({
      focusValue: "max",
      getNodeData: () => ({
        ...maxEvents.value,
        key: "tmax",
        tabindex: thumbTabindex.value
      }),
      ratio: ratioMax,
      label: computed(() => props4.rightLabelValue !== void 0 ? props4.rightLabelValue : model.value.max),
      thumbColor: computed(() => props4.rightThumbColor || props4.thumbColor || props4.color),
      labelColor: computed(() => props4.rightLabelColor || props4.labelColor),
      labelTextColor: computed(() => props4.rightLabelTextColor || props4.labelTextColor)
    });
    function updateValue2(change) {
      if (model.value.min !== props4.modelValue.min || model.value.max !== props4.modelValue.max) {
        emit2("update:modelValue", { ...model.value });
      }
      change === true && emit2("change", { ...model.value });
    }
    function getDragging(event) {
      const { left, top, width: width3, height: height2 } = rootRef.value.getBoundingClientRect(), sensitivity = props4.dragOnlyRange === true ? 0 : props4.vertical === true ? minThumbRef.value.offsetHeight / (2 * height2) : minThumbRef.value.offsetWidth / (2 * width3);
      const dragging = {
        left,
        top,
        width: width3,
        height: height2,
        valueMin: model.value.min,
        valueMax: model.value.max,
        ratioMin: modelMinRatio.value,
        ratioMax: modelMaxRatio.value
      };
      const ratio = methods.getDraggingRatio(event, dragging);
      if (props4.dragOnlyRange !== true && ratio < dragging.ratioMin + sensitivity) {
        dragging.type = dragType.MIN;
      } else if (props4.dragOnlyRange === true || ratio < dragging.ratioMax - sensitivity) {
        if (props4.dragRange === true || props4.dragOnlyRange === true) {
          dragging.type = dragType.RANGE;
          Object.assign(dragging, {
            offsetRatio: ratio,
            offsetModel: methods.convertRatioToModel(ratio),
            rangeValue: dragging.valueMax - dragging.valueMin,
            rangeRatio: dragging.ratioMax - dragging.ratioMin
          });
        } else {
          dragging.type = dragging.ratioMax - ratio < ratio - dragging.ratioMin ? dragType.MAX : dragType.MIN;
        }
      } else {
        dragging.type = dragType.MAX;
      }
      return dragging;
    }
    function updatePosition(event, dragging = state.dragging.value) {
      let pos;
      const ratio = methods.getDraggingRatio(event, dragging);
      const localModel = methods.convertRatioToModel(ratio);
      switch (dragging.type) {
        case dragType.MIN:
          if (ratio <= dragging.ratioMax) {
            pos = {
              minR: ratio,
              maxR: dragging.ratioMax,
              min: localModel,
              max: dragging.valueMax
            };
            state.focus.value = "min";
          } else {
            pos = {
              minR: dragging.ratioMax,
              maxR: ratio,
              min: dragging.valueMax,
              max: localModel
            };
            state.focus.value = "max";
          }
          break;
        case dragType.MAX:
          if (ratio >= dragging.ratioMin) {
            pos = {
              minR: dragging.ratioMin,
              maxR: ratio,
              min: dragging.valueMin,
              max: localModel
            };
            state.focus.value = "max";
          } else {
            pos = {
              minR: ratio,
              maxR: dragging.ratioMin,
              min: localModel,
              max: dragging.valueMin
            };
            state.focus.value = "min";
          }
          break;
        case dragType.RANGE:
          const ratioDelta = ratio - dragging.offsetRatio, minR = between(dragging.ratioMin + ratioDelta, state.innerMinRatio.value, state.innerMaxRatio.value - dragging.rangeRatio), modelDelta = localModel - dragging.offsetModel, min = between(dragging.valueMin + modelDelta, state.innerMin.value, state.innerMax.value - dragging.rangeValue);
          pos = {
            minR,
            maxR: minR + dragging.rangeRatio,
            min: state.roundValueFn.value(min),
            max: state.roundValueFn.value(min + dragging.rangeValue)
          };
          state.focus.value = "both";
          break;
      }
      model.value = model.value.min === null || model.value.max === null ? { min: pos.min || props4.min, max: pos.max || props4.max } : { min: pos.min, max: pos.max };
      if (props4.snap !== true || props4.step === 0) {
        curMinRatio.value = pos.minR;
        curMaxRatio.value = pos.maxR;
      } else {
        curMinRatio.value = methods.convertModelToRatio(model.value.min);
        curMaxRatio.value = methods.convertModelToRatio(model.value.max);
      }
    }
    function onKeydown2(evt) {
      if (!keyCodes.includes(evt.keyCode)) {
        return;
      }
      stopAndPrevent(evt);
      const stepVal = ([34, 33].includes(evt.keyCode) ? 10 : 1) * state.keyStep.value, offset2 = ([34, 37, 40].includes(evt.keyCode) ? -1 : 1) * (state.isReversed.value === true ? -1 : 1) * (props4.vertical === true ? -1 : 1) * stepVal;
      if (state.focus.value === "both") {
        const interval = model.value.max - model.value.min;
        const min = between(
          state.roundValueFn.value(model.value.min + offset2),
          state.innerMin.value,
          state.innerMax.value - interval
        );
        model.value = {
          min,
          max: state.roundValueFn.value(min + interval)
        };
      } else if (state.focus.value === false) {
        return;
      } else {
        const which = state.focus.value;
        model.value = {
          ...model.value,
          [which]: between(
            state.roundValueFn.value(model.value[which] + offset2),
            which === "min" ? state.innerMin.value : model.value.min,
            which === "max" ? state.innerMax.value : model.value.max
          )
        };
      }
      updateValue2();
    }
    return () => {
      const content = methods.getContent(
        selectionBarStyle,
        trackContainerTabindex,
        trackContainerEvents,
        (node) => {
          node.push(
            getMinThumb(),
            getMaxThumb()
          );
        }
      );
      return h("div", {
        ref: rootRef,
        class: "q-range " + state.classes.value + (props4.modelValue.min === null || props4.modelValue.max === null ? " q-slider--no-value" : ""),
        ...state.attributes.value,
        "aria-valuenow": props4.modelValue.min + "|" + props4.modelValue.max
      }, content);
    };
  }
});
createComponent({
  name: "QRating",
  props: {
    ...useSizeProps,
    ...useFormProps,
    modelValue: {
      type: Number,
      required: true
    },
    max: {
      type: [String, Number],
      default: 5
    },
    icon: [String, Array],
    iconHalf: [String, Array],
    iconSelected: [String, Array],
    iconAriaLabel: [String, Array],
    color: [String, Array],
    colorHalf: [String, Array],
    colorSelected: [String, Array],
    noReset: Boolean,
    noDimming: Boolean,
    readonly: Boolean,
    disable: Boolean
  },
  emits: ["update:modelValue"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const sizeStyle = use_size_default(props4);
    const formAttrs = useFormAttrs(props4);
    const injectFormInput = useFormInject(formAttrs);
    const mouseModel = ref(0);
    let iconRefs = {};
    const editable = computed(
      () => props4.readonly !== true && props4.disable !== true
    );
    const classes = computed(
      () => `q-rating row inline items-center q-rating--${editable.value === true ? "" : "non-"}editable` + (props4.noDimming === true ? " q-rating--no-dimming" : "") + (props4.disable === true ? " disabled" : "") + (props4.color !== void 0 && Array.isArray(props4.color) === false ? ` text-${props4.color}` : "")
    );
    const iconData = computed(() => {
      const iconLen = Array.isArray(props4.icon) === true ? props4.icon.length : 0, selIconLen = Array.isArray(props4.iconSelected) === true ? props4.iconSelected.length : 0, halfIconLen = Array.isArray(props4.iconHalf) === true ? props4.iconHalf.length : 0, colorLen = Array.isArray(props4.color) === true ? props4.color.length : 0, selColorLen = Array.isArray(props4.colorSelected) === true ? props4.colorSelected.length : 0, halfColorLen = Array.isArray(props4.colorHalf) === true ? props4.colorHalf.length : 0;
      return {
        iconLen,
        icon: iconLen > 0 ? props4.icon[iconLen - 1] : props4.icon,
        selIconLen,
        selIcon: selIconLen > 0 ? props4.iconSelected[selIconLen - 1] : props4.iconSelected,
        halfIconLen,
        halfIcon: halfIconLen > 0 ? props4.iconHalf[selIconLen - 1] : props4.iconHalf,
        colorLen,
        color: colorLen > 0 ? props4.color[colorLen - 1] : props4.color,
        selColorLen,
        selColor: selColorLen > 0 ? props4.colorSelected[selColorLen - 1] : props4.colorSelected,
        halfColorLen,
        halfColor: halfColorLen > 0 ? props4.colorHalf[halfColorLen - 1] : props4.colorHalf
      };
    });
    const iconLabel = computed(() => {
      if (typeof props4.iconAriaLabel === "string") {
        const label2 = props4.iconAriaLabel.length !== 0 ? `${props4.iconAriaLabel} ` : "";
        return (i) => `${label2}${i}`;
      }
      if (Array.isArray(props4.iconAriaLabel) === true) {
        const iMax = props4.iconAriaLabel.length;
        if (iMax > 0) {
          return (i) => props4.iconAriaLabel[Math.min(i, iMax) - 1];
        }
      }
      return (i, label2) => `${label2} ${i}`;
    });
    const stars = computed(() => {
      const acc = [], icons = iconData.value, ceil = Math.ceil(props4.modelValue), tabindex = editable.value === true ? 0 : null;
      const halfIndex = props4.iconHalf === void 0 || ceil === props4.modelValue ? -1 : ceil;
      for (let i = 1; i <= props4.max; i++) {
        const active = mouseModel.value === 0 && props4.modelValue >= i || mouseModel.value > 0 && mouseModel.value >= i, half = halfIndex === i && mouseModel.value < i, exSelected = mouseModel.value > 0 && (half === true ? ceil : props4.modelValue) >= i && mouseModel.value < i, color = half === true ? i <= icons.halfColorLen ? props4.colorHalf[i - 1] : icons.halfColor : icons.selColor !== void 0 && active === true ? i <= icons.selColorLen ? props4.colorSelected[i - 1] : icons.selColor : i <= icons.colorLen ? props4.color[i - 1] : icons.color, name2 = (half === true ? i <= icons.halfIconLen ? props4.iconHalf[i - 1] : icons.halfIcon : icons.selIcon !== void 0 && (active === true || exSelected === true) ? i <= icons.selIconLen ? props4.iconSelected[i - 1] : icons.selIcon : i <= icons.iconLen ? props4.icon[i - 1] : icons.icon) || $q.iconSet.rating.icon;
        acc.push({
          name: (half === true ? i <= icons.halfIconLen ? props4.iconHalf[i - 1] : icons.halfIcon : icons.selIcon !== void 0 && (active === true || exSelected === true) ? i <= icons.selIconLen ? props4.iconSelected[i - 1] : icons.selIcon : i <= icons.iconLen ? props4.icon[i - 1] : icons.icon) || $q.iconSet.rating.icon,
          attrs: {
            tabindex,
            role: "radio",
            "aria-checked": props4.modelValue === i ? "true" : "false",
            "aria-label": iconLabel.value(i, name2)
          },
          iconClass: "q-rating__icon" + (active === true || half === true ? " q-rating__icon--active" : "") + (exSelected === true ? " q-rating__icon--exselected" : "") + (mouseModel.value === i ? " q-rating__icon--hovered" : "") + (color !== void 0 ? ` text-${color}` : "")
        });
      }
      return acc;
    });
    const attributes = computed(() => {
      const attrs = { role: "radiogroup" };
      if (props4.disable === true) {
        attrs["aria-disabled"] = "true";
      }
      if (props4.readonly === true) {
        attrs["aria-readonly"] = "true";
      }
      return attrs;
    });
    function set2(value2) {
      if (editable.value === true) {
        const model = between(parseInt(value2, 10), 1, parseInt(props4.max, 10)), newVal = props4.noReset !== true && props4.modelValue === model ? 0 : model;
        newVal !== props4.modelValue && emit2("update:modelValue", newVal);
        mouseModel.value = 0;
      }
    }
    function setHoverValue(value2) {
      if (editable.value === true) {
        mouseModel.value = value2;
      }
    }
    function onKeyup2(e, i) {
      switch (e.keyCode) {
        case 13:
        case 32:
          set2(i);
          return stopAndPrevent(e);
        case 37:
        case 40:
          if (iconRefs[`rt${i - 1}`]) {
            iconRefs[`rt${i - 1}`].focus();
          }
          return stopAndPrevent(e);
        case 39:
        case 38:
          if (iconRefs[`rt${i + 1}`]) {
            iconRefs[`rt${i + 1}`].focus();
          }
          return stopAndPrevent(e);
      }
    }
    function resetMouseModel() {
      mouseModel.value = 0;
    }
    onBeforeUpdate(() => {
      iconRefs = {};
    });
    return () => {
      const child = [];
      stars.value.forEach(({ iconClass, name: name2, attrs }, index) => {
        const i = index + 1;
        child.push(
          h("div", {
            key: i,
            ref: (el) => {
              iconRefs[`rt${i}`] = el;
            },
            class: "q-rating__icon-container flex flex-center",
            ...attrs,
            onClick() {
              set2(i);
            },
            onMouseover() {
              setHoverValue(i);
            },
            onMouseout: resetMouseModel,
            onFocus() {
              setHoverValue(i);
            },
            onBlur: resetMouseModel,
            onKeyup(e) {
              onKeyup2(e, i);
            }
          }, hMergeSlot(
            slots[`tip-${i}`],
            [h(QIcon_default, { class: iconClass, name: name2 })]
          ))
        );
      });
      if (props4.name !== void 0 && props4.disable !== true) {
        injectFormInput(child, "push");
      }
      return h("div", {
        class: classes.value,
        style: sizeStyle.value,
        ...attributes.value
      }, child);
    };
  }
});
createComponent({
  name: "QResponsive",
  props: useRatioProps,
  setup(props4, { slots }) {
    const ratioStyle = use_ratio_default(props4);
    return () => h("div", {
      class: "q-responsive"
    }, [
      h("div", {
        class: "q-responsive__filler overflow-hidden"
      }, [
        h("div", { style: ratioStyle.value })
      ]),
      h("div", {
        class: "q-responsive__content absolute-full fit"
      }, hSlot(slots.default))
    ]);
  }
});
var ScrollAreaControls_default = createComponent({
  props: [
    "store",
    "barStyle",
    "verticalBarStyle",
    "horizontalBarStyle"
  ],
  setup(props4) {
    return () => [
      h("div", {
        class: props4.store.scroll.vertical.barClass.value,
        style: [props4.barStyle, props4.verticalBarStyle],
        "aria-hidden": "true",
        onMousedown: props4.store.onVerticalMousedown
      }),
      h("div", {
        class: props4.store.scroll.horizontal.barClass.value,
        style: [props4.barStyle, props4.horizontalBarStyle],
        "aria-hidden": "true",
        onMousedown: props4.store.onHorizontalMousedown
      }),
      withDirectives(
        h("div", {
          ref: props4.store.scroll.vertical.ref,
          class: props4.store.scroll.vertical.thumbClass.value,
          style: props4.store.scroll.vertical.style.value,
          "aria-hidden": "true"
        }),
        props4.store.thumbVertDir
      ),
      withDirectives(
        h("div", {
          ref: props4.store.scroll.horizontal.ref,
          class: props4.store.scroll.horizontal.thumbClass.value,
          style: props4.store.scroll.horizontal.style.value,
          "aria-hidden": "true"
        }),
        props4.store.thumbHorizDir
      )
    ];
  }
});
var axisList = ["vertical", "horizontal"];
var dirProps = {
  vertical: { offset: "offsetY", scroll: "scrollTop", dir: "down", dist: "y" },
  horizontal: { offset: "offsetX", scroll: "scrollLeft", dir: "right", dist: "x" }
};
var panOpts = {
  prevent: true,
  mouse: true,
  mouseAllDir: true
};
var getMinThumbSize = (size2) => size2 >= 250 ? 50 : Math.ceil(size2 / 5);
createComponent({
  name: "QScrollArea",
  props: {
    ...useDarkProps,
    thumbStyle: Object,
    verticalThumbStyle: Object,
    horizontalThumbStyle: Object,
    barStyle: [Array, String, Object],
    verticalBarStyle: [Array, String, Object],
    horizontalBarStyle: [Array, String, Object],
    verticalOffset: {
      type: Array,
      default: [0, 0]
    },
    horizontalOffset: {
      type: Array,
      default: [0, 0]
    },
    contentStyle: [Array, String, Object],
    contentActiveStyle: [Array, String, Object],
    delay: {
      type: [String, Number],
      default: 1e3
    },
    visible: {
      type: Boolean,
      default: null
    },
    tabindex: [String, Number],
    onScroll: Function
  },
  setup(props4, { slots, emit: emit2 }) {
    const tempShowing = ref(false);
    const panning = ref(false);
    const hover = ref(false);
    const container = {
      vertical: ref(0),
      horizontal: ref(0)
    };
    const scroll = {
      vertical: {
        ref: ref(null),
        position: ref(0),
        size: ref(0)
      },
      horizontal: {
        ref: ref(null),
        position: ref(0),
        size: ref(0)
      }
    };
    const { proxy } = getCurrentInstance();
    const isDark = use_dark_default(props4, proxy.$q);
    let timer2 = null, panRefPos;
    const targetRef = ref(null);
    const classes = computed(
      () => "q-scrollarea" + (isDark.value === true ? " q-scrollarea--dark" : "")
    );
    Object.assign(container, {
      verticalInner: computed(() => container.vertical.value - props4.verticalOffset[0] - props4.verticalOffset[1]),
      horizontalInner: computed(() => container.horizontal.value - props4.horizontalOffset[0] - props4.horizontalOffset[1])
    });
    scroll.vertical.percentage = computed(() => {
      const diff2 = scroll.vertical.size.value - container.vertical.value;
      if (diff2 <= 0) {
        return 0;
      }
      const p2 = between(scroll.vertical.position.value / diff2, 0, 1);
      return Math.round(p2 * 1e4) / 1e4;
    });
    scroll.vertical.thumbHidden = computed(() => (props4.visible === null ? hover.value : props4.visible) !== true && tempShowing.value === false && panning.value === false || scroll.vertical.size.value <= container.vertical.value + 1);
    scroll.vertical.thumbStart = computed(() => props4.verticalOffset[0] + scroll.vertical.percentage.value * (container.verticalInner.value - scroll.vertical.thumbSize.value));
    scroll.vertical.thumbSize = computed(
      () => Math.round(
        between(
          container.verticalInner.value * container.verticalInner.value / scroll.vertical.size.value,
          getMinThumbSize(container.verticalInner.value),
          container.verticalInner.value
        )
      )
    );
    scroll.vertical.style = computed(() => ({
      ...props4.thumbStyle,
      ...props4.verticalThumbStyle,
      top: `${scroll.vertical.thumbStart.value}px`,
      height: `${scroll.vertical.thumbSize.value}px`,
      right: `${props4.horizontalOffset[1]}px`
    }));
    scroll.vertical.thumbClass = computed(() => "q-scrollarea__thumb q-scrollarea__thumb--v absolute-right" + (scroll.vertical.thumbHidden.value === true ? " q-scrollarea__thumb--invisible" : ""));
    scroll.vertical.barClass = computed(() => "q-scrollarea__bar q-scrollarea__bar--v absolute-right" + (scroll.vertical.thumbHidden.value === true ? " q-scrollarea__bar--invisible" : ""));
    scroll.horizontal.percentage = computed(() => {
      const diff2 = scroll.horizontal.size.value - container.horizontal.value;
      if (diff2 <= 0) {
        return 0;
      }
      const p2 = between(Math.abs(scroll.horizontal.position.value) / diff2, 0, 1);
      return Math.round(p2 * 1e4) / 1e4;
    });
    scroll.horizontal.thumbHidden = computed(() => (props4.visible === null ? hover.value : props4.visible) !== true && tempShowing.value === false && panning.value === false || scroll.horizontal.size.value <= container.horizontal.value + 1);
    scroll.horizontal.thumbStart = computed(() => props4.horizontalOffset[0] + scroll.horizontal.percentage.value * (container.horizontalInner.value - scroll.horizontal.thumbSize.value));
    scroll.horizontal.thumbSize = computed(
      () => Math.round(
        between(
          container.horizontalInner.value * container.horizontalInner.value / scroll.horizontal.size.value,
          getMinThumbSize(container.horizontalInner.value),
          container.horizontalInner.value
        )
      )
    );
    scroll.horizontal.style = computed(() => ({
      ...props4.thumbStyle,
      ...props4.horizontalThumbStyle,
      [proxy.$q.lang.rtl === true ? "right" : "left"]: `${scroll.horizontal.thumbStart.value}px`,
      width: `${scroll.horizontal.thumbSize.value}px`,
      bottom: `${props4.verticalOffset[1]}px`
    }));
    scroll.horizontal.thumbClass = computed(() => "q-scrollarea__thumb q-scrollarea__thumb--h absolute-bottom" + (scroll.horizontal.thumbHidden.value === true ? " q-scrollarea__thumb--invisible" : ""));
    scroll.horizontal.barClass = computed(() => "q-scrollarea__bar q-scrollarea__bar--h absolute-bottom" + (scroll.horizontal.thumbHidden.value === true ? " q-scrollarea__bar--invisible" : ""));
    const mainStyle = computed(() => scroll.vertical.thumbHidden.value === true && scroll.horizontal.thumbHidden.value === true ? props4.contentStyle : props4.contentActiveStyle);
    function getScroll() {
      const info = {};
      axisList.forEach((axis) => {
        const data = scroll[axis];
        Object.assign(info, {
          [axis + "Position"]: data.position.value,
          [axis + "Percentage"]: data.percentage.value,
          [axis + "Size"]: data.size.value,
          [axis + "ContainerSize"]: container[axis].value,
          [axis + "ContainerInnerSize"]: container[axis + "Inner"].value
        });
      });
      return info;
    }
    const emitScroll = debounce_default(() => {
      const info = getScroll();
      info.ref = proxy;
      emit2("scroll", info);
    }, 0);
    function localSetScrollPosition(axis, offset2, duration2) {
      if (axisList.includes(axis) === false) {
        console.error("[QScrollArea]: wrong first param of setScrollPosition (vertical/horizontal)");
        return;
      }
      const fn = axis === "vertical" ? setVerticalScrollPosition : setHorizontalScrollPosition;
      fn(targetRef.value, offset2, duration2);
    }
    function updateContainer({ height: height2, width: width3 }) {
      let change = false;
      if (container.vertical.value !== height2) {
        container.vertical.value = height2;
        change = true;
      }
      if (container.horizontal.value !== width3) {
        container.horizontal.value = width3;
        change = true;
      }
      change === true && startTimer();
    }
    function updateScroll({ position: position2 }) {
      let change = false;
      if (scroll.vertical.position.value !== position2.top) {
        scroll.vertical.position.value = position2.top;
        change = true;
      }
      if (scroll.horizontal.position.value !== position2.left) {
        scroll.horizontal.position.value = position2.left;
        change = true;
      }
      change === true && startTimer();
    }
    function updateScrollSize({ height: height2, width: width3 }) {
      if (scroll.horizontal.size.value !== width3) {
        scroll.horizontal.size.value = width3;
        startTimer();
      }
      if (scroll.vertical.size.value !== height2) {
        scroll.vertical.size.value = height2;
        startTimer();
      }
    }
    function onPanThumb(e, axis) {
      const data = scroll[axis];
      if (e.isFirst === true) {
        if (data.thumbHidden.value === true) {
          return;
        }
        panRefPos = data.position.value;
        panning.value = true;
      } else if (panning.value !== true) {
        return;
      }
      if (e.isFinal === true) {
        panning.value = false;
      }
      const dProp = dirProps[axis];
      const multiplier = (data.size.value - container[axis].value) / (container[axis + "Inner"].value - data.thumbSize.value);
      const distance = e.distance[dProp.dist];
      const pos = panRefPos + (e.direction === dProp.dir ? 1 : -1) * distance * multiplier;
      setScroll3(pos, axis);
    }
    function onMousedown(evt, axis) {
      const data = scroll[axis];
      if (data.thumbHidden.value !== true) {
        const startOffset = axis === "vertical" ? props4.verticalOffset[0] : props4.horizontalOffset[0];
        const offset2 = evt[dirProps[axis].offset] - startOffset;
        const thumbStart = data.thumbStart.value - startOffset;
        if (offset2 < thumbStart || offset2 > thumbStart + data.thumbSize.value) {
          const targetThumbStart = offset2 - data.thumbSize.value / 2;
          const percentage = between(targetThumbStart / (container[axis + "Inner"].value - data.thumbSize.value), 0, 1);
          setScroll3(percentage * Math.max(0, data.size.value - container[axis].value), axis);
        }
        if (data.ref.value !== null) {
          data.ref.value.dispatchEvent(new MouseEvent(evt.type, evt));
        }
      }
    }
    function startTimer() {
      tempShowing.value = true;
      timer2 !== null && clearTimeout(timer2);
      timer2 = setTimeout(() => {
        timer2 = null;
        tempShowing.value = false;
      }, props4.delay);
      props4.onScroll !== void 0 && emitScroll();
    }
    function setScroll3(offset2, axis) {
      targetRef.value[dirProps[axis].scroll] = offset2;
    }
    let mouseEventTimer = null;
    function onMouseenter() {
      if (mouseEventTimer !== null) {
        clearTimeout(mouseEventTimer);
      }
      mouseEventTimer = setTimeout(() => {
        mouseEventTimer = null;
        hover.value = true;
      }, proxy.$q.platform.is.ios ? 50 : 0);
    }
    function onMouseleave() {
      if (mouseEventTimer !== null) {
        clearTimeout(mouseEventTimer);
        mouseEventTimer = null;
      }
      hover.value = false;
    }
    let scrollPosition = null;
    watch(() => proxy.$q.lang.rtl, (rtl) => {
      if (targetRef.value !== null) {
        setHorizontalScrollPosition(
          targetRef.value,
          Math.abs(scroll.horizontal.position.value) * (rtl === true ? -1 : 1)
        );
      }
    });
    onDeactivated(() => {
      scrollPosition = {
        top: scroll.vertical.position.value,
        left: scroll.horizontal.position.value
      };
    });
    onActivated(() => {
      if (scrollPosition === null) return;
      const scrollTarget = targetRef.value;
      if (scrollTarget !== null) {
        setHorizontalScrollPosition(scrollTarget, scrollPosition.left);
        setVerticalScrollPosition(scrollTarget, scrollPosition.top);
      }
    });
    onBeforeUnmount(emitScroll.cancel);
    Object.assign(proxy, {
      getScrollTarget: () => targetRef.value,
      getScroll,
      getScrollPosition: () => ({
        top: scroll.vertical.position.value,
        left: scroll.horizontal.position.value
      }),
      getScrollPercentage: () => ({
        top: scroll.vertical.percentage.value,
        left: scroll.horizontal.percentage.value
      }),
      setScrollPosition: localSetScrollPosition,
      setScrollPercentage(axis, percentage, duration2) {
        localSetScrollPosition(
          axis,
          percentage * (scroll[axis].size.value - container[axis].value) * (axis === "horizontal" && proxy.$q.lang.rtl === true ? -1 : 1),
          duration2
        );
      }
    });
    const store = {
      scroll,
      thumbVertDir: [[
        TouchPan_default,
        (e) => {
          onPanThumb(e, "vertical");
        },
        void 0,
        { vertical: true, ...panOpts }
      ]],
      thumbHorizDir: [[
        TouchPan_default,
        (e) => {
          onPanThumb(e, "horizontal");
        },
        void 0,
        { horizontal: true, ...panOpts }
      ]],
      onVerticalMousedown(evt) {
        onMousedown(evt, "vertical");
      },
      onHorizontalMousedown(evt) {
        onMousedown(evt, "horizontal");
      }
    };
    return () => {
      return h("div", {
        class: classes.value,
        onMouseenter,
        onMouseleave
      }, [
        h("div", {
          ref: targetRef,
          class: "q-scrollarea__container scroll relative-position fit hide-scrollbar",
          tabindex: props4.tabindex !== void 0 ? props4.tabindex : void 0
        }, [
          h("div", {
            class: "q-scrollarea__content absolute",
            style: mainStyle.value
          }, hMergeSlot(slots.default, [
            h(QResizeObserver_default, {
              debounce: 0,
              onResize: updateScrollSize
            })
          ])),
          h(QScrollObserver_default, {
            axis: "both",
            onScroll: updateScroll
          })
        ]),
        h(QResizeObserver_default, {
          debounce: 0,
          onResize: updateContainer
        }),
        h(ScrollAreaControls_default, {
          store,
          barStyle: props4.barStyle,
          verticalBarStyle: props4.verticalBarStyle,
          horizontalBarStyle: props4.horizontalBarStyle
        })
      ]);
    };
  }
});
var aggBucketSize = 1e3;
var scrollToEdges = [
  "start",
  "center",
  "end",
  "start-force",
  "center-force",
  "end-force"
];
var filterProto = Array.prototype.filter;
var setOverflowAnchor = window.getComputedStyle(document.body).overflowAnchor === void 0 ? noop : function(contentEl, index) {
  if (contentEl === null) {
    return;
  }
  if (contentEl._qOverflowAnimationFrame !== void 0) {
    cancelAnimationFrame(contentEl._qOverflowAnimationFrame);
  }
  contentEl._qOverflowAnimationFrame = requestAnimationFrame(() => {
    if (contentEl === null) {
      return;
    }
    contentEl._qOverflowAnimationFrame = void 0;
    const children = contentEl.children || [];
    filterProto.call(children, (el2) => el2.dataset && el2.dataset.qVsAnchor !== void 0).forEach((el2) => {
      delete el2.dataset.qVsAnchor;
    });
    const el = children[index];
    if (el && el.dataset) {
      el.dataset.qVsAnchor = "";
    }
  });
};
function sumFn(acc, h138) {
  return acc + h138;
}
function getScrollDetails(parent, child, beforeRef, afterRef, horizontal, rtl, stickyStart, stickyEnd) {
  const parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent, propElSize = horizontal === true ? "offsetWidth" : "offsetHeight", details = {
    scrollStart: 0,
    scrollViewSize: -stickyStart - stickyEnd,
    scrollMaxSize: 0,
    offsetStart: -stickyStart,
    offsetEnd: -stickyEnd
  };
  if (horizontal === true) {
    if (parent === window) {
      details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0;
      details.scrollViewSize += document.documentElement.clientWidth;
    } else {
      details.scrollStart = parentCalc.scrollLeft;
      details.scrollViewSize += parentCalc.clientWidth;
    }
    details.scrollMaxSize = parentCalc.scrollWidth;
    if (rtl === true) {
      details.scrollStart = (rtlHasScrollBug === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart;
    }
  } else {
    if (parent === window) {
      details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0;
      details.scrollViewSize += document.documentElement.clientHeight;
    } else {
      details.scrollStart = parentCalc.scrollTop;
      details.scrollViewSize += parentCalc.clientHeight;
    }
    details.scrollMaxSize = parentCalc.scrollHeight;
  }
  if (beforeRef !== null) {
    for (let el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {
      if (el.classList.contains("q-virtual-scroll--skip") === false) {
        details.offsetStart += el[propElSize];
      }
    }
  }
  if (afterRef !== null) {
    for (let el = afterRef.nextElementSibling; el !== null; el = el.nextElementSibling) {
      if (el.classList.contains("q-virtual-scroll--skip") === false) {
        details.offsetEnd += el[propElSize];
      }
    }
  }
  if (child !== parent) {
    const parentRect = parentCalc.getBoundingClientRect(), childRect = child.getBoundingClientRect();
    if (horizontal === true) {
      details.offsetStart += childRect.left - parentRect.left;
      details.offsetEnd -= childRect.width;
    } else {
      details.offsetStart += childRect.top - parentRect.top;
      details.offsetEnd -= childRect.height;
    }
    if (parent !== window) {
      details.offsetStart += details.scrollStart;
    }
    details.offsetEnd += details.scrollMaxSize - details.offsetStart;
  }
  return details;
}
function setScroll2(parent, scroll, horizontal, rtl) {
  if (scroll === "end") {
    scroll = (parent === window ? document.body : parent)[horizontal === true ? "scrollWidth" : "scrollHeight"];
  }
  if (parent === window) {
    if (horizontal === true) {
      if (rtl === true) {
        scroll = (rtlHasScrollBug === true ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - scroll;
      }
      window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
    } else {
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll);
    }
  } else if (horizontal === true) {
    if (rtl === true) {
      scroll = (rtlHasScrollBug === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll;
    }
    parent.scrollLeft = scroll;
  } else {
    parent.scrollTop = scroll;
  }
}
function sumSize(sizeAgg, size2, from, to) {
  if (from >= to) {
    return 0;
  }
  const lastTo = size2.length, fromAgg = Math.floor(from / aggBucketSize), toAgg = Math.floor((to - 1) / aggBucketSize) + 1;
  let total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0);
  if (from % aggBucketSize !== 0) {
    total -= size2.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0);
  }
  if (to % aggBucketSize !== 0 && to !== lastTo) {
    total -= size2.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0);
  }
  return total;
}
var commonVirtScrollProps = {
  virtualScrollSliceSize: {
    type: [Number, String],
    default: 10
  },
  virtualScrollSliceRatioBefore: {
    type: [Number, String],
    default: 1
  },
  virtualScrollSliceRatioAfter: {
    type: [Number, String],
    default: 1
  },
  virtualScrollItemSize: {
    type: [Number, String],
    default: 24
  },
  virtualScrollStickySizeStart: {
    type: [Number, String],
    default: 0
  },
  virtualScrollStickySizeEnd: {
    type: [Number, String],
    default: 0
  },
  tableColspan: [Number, String]
};
var commonVirtScrollPropsList = Object.keys(commonVirtScrollProps);
var useVirtualScrollProps = {
  virtualScrollHorizontal: Boolean,
  onVirtualScroll: Function,
  ...commonVirtScrollProps
};
function useVirtualScroll({
  virtualScrollLength,
  getVirtualScrollTarget,
  getVirtualScrollEl,
  virtualScrollItemSizeComputed
  // optional
}) {
  const vm2 = getCurrentInstance();
  const { props: props4, emit: emit2, proxy } = vm2;
  const { $q } = proxy;
  let prevScrollStart, prevToIndex, localScrollViewSize, virtualScrollSizesAgg = [], virtualScrollSizes;
  const virtualScrollPaddingBefore = ref(0);
  const virtualScrollPaddingAfter = ref(0);
  const virtualScrollSliceSizeComputed = ref({});
  const beforeRef = ref(null);
  const afterRef = ref(null);
  const contentRef = ref(null);
  const virtualScrollSliceRange = ref({ from: 0, to: 0 });
  const colspanAttr = computed(() => props4.tableColspan !== void 0 ? props4.tableColspan : 100);
  if (virtualScrollItemSizeComputed === void 0) {
    virtualScrollItemSizeComputed = computed(() => props4.virtualScrollItemSize);
  }
  const needsReset = computed(() => virtualScrollItemSizeComputed.value + ";" + props4.virtualScrollHorizontal);
  const needsSliceRecalc = computed(
    () => needsReset.value + ";" + props4.virtualScrollSliceRatioBefore + ";" + props4.virtualScrollSliceRatioAfter
  );
  watch(needsSliceRecalc, () => {
    setVirtualScrollSize();
  });
  watch(needsReset, reset);
  function reset() {
    localResetVirtualScroll(prevToIndex, true);
  }
  function refresh(toIndex) {
    localResetVirtualScroll(toIndex === void 0 ? prevToIndex : toIndex);
  }
  function scrollTo(toIndex, edge) {
    const scrollEl = getVirtualScrollTarget();
    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
      return;
    }
    const scrollDetails = getScrollDetails(
      scrollEl,
      getVirtualScrollEl(),
      beforeRef.value,
      afterRef.value,
      props4.virtualScrollHorizontal,
      $q.lang.rtl,
      props4.virtualScrollStickySizeStart,
      props4.virtualScrollStickySizeEnd
    );
    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);
    setVirtualScrollSliceRange(
      scrollEl,
      scrollDetails,
      Math.min(virtualScrollLength.value - 1, Math.max(0, parseInt(toIndex, 10) || 0)),
      0,
      scrollToEdges.indexOf(edge) !== -1 ? edge : prevToIndex !== -1 && toIndex > prevToIndex ? "end" : "start"
    );
  }
  function localOnVirtualScrollEvt() {
    const scrollEl = getVirtualScrollTarget();
    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
      return;
    }
    const scrollDetails = getScrollDetails(
      scrollEl,
      getVirtualScrollEl(),
      beforeRef.value,
      afterRef.value,
      props4.virtualScrollHorizontal,
      $q.lang.rtl,
      props4.virtualScrollStickySizeStart,
      props4.virtualScrollStickySizeEnd
    ), listLastIndex = virtualScrollLength.value - 1, listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - virtualScrollPaddingAfter.value;
    if (prevScrollStart === scrollDetails.scrollStart) {
      return;
    }
    if (scrollDetails.scrollMaxSize <= 0) {
      setVirtualScrollSliceRange(scrollEl, scrollDetails, 0, 0);
      return;
    }
    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);
    updateVirtualScrollSizes(virtualScrollSliceRange.value.from);
    const scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize - Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd) - Math.min(virtualScrollSizes[listLastIndex], scrollDetails.scrollViewSize / 2));
    if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {
      setVirtualScrollSliceRange(
        scrollEl,
        scrollDetails,
        listLastIndex,
        scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - virtualScrollSizesAgg.reduce(sumFn, 0)
      );
      return;
    }
    let toIndex = 0, listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart, offset2 = listOffset;
    if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= virtualScrollPaddingBefore.value) {
      listOffset -= virtualScrollPaddingBefore.value;
      toIndex = virtualScrollSliceRange.value.from;
      offset2 = listOffset;
    } else {
      for (let j = 0; listOffset >= virtualScrollSizesAgg[j] && toIndex < listLastIndex; j++) {
        listOffset -= virtualScrollSizesAgg[j];
        toIndex += aggBucketSize;
      }
    }
    while (listOffset > 0 && toIndex < listLastIndex) {
      listOffset -= virtualScrollSizes[toIndex];
      if (listOffset > -scrollDetails.scrollViewSize) {
        toIndex++;
        offset2 = listOffset;
      } else {
        offset2 = virtualScrollSizes[toIndex] + listOffset;
      }
    }
    setVirtualScrollSliceRange(
      scrollEl,
      scrollDetails,
      toIndex,
      offset2
    );
  }
  function setVirtualScrollSliceRange(scrollEl, scrollDetails, toIndex, offset2, align) {
    const alignForce = typeof align === "string" && align.indexOf("-force") !== -1;
    const alignEnd = alignForce === true ? align.replace("-force", "") : align;
    const alignRange = alignEnd !== void 0 ? alignEnd : "start";
    let from = Math.max(0, toIndex - virtualScrollSliceSizeComputed.value[alignRange]), to = from + virtualScrollSliceSizeComputed.value.total;
    if (to > virtualScrollLength.value) {
      to = virtualScrollLength.value;
      from = Math.max(0, to - virtualScrollSliceSizeComputed.value.total);
    }
    prevScrollStart = scrollDetails.scrollStart;
    const rangeChanged = from !== virtualScrollSliceRange.value.from || to !== virtualScrollSliceRange.value.to;
    if (rangeChanged === false && alignEnd === void 0) {
      emitScroll(toIndex);
      return;
    }
    const { activeElement } = document;
    const contentEl = contentRef.value;
    if (rangeChanged === true && contentEl !== null && contentEl !== activeElement && contentEl.contains(activeElement) === true) {
      contentEl.addEventListener("focusout", onBlurRefocusFn);
      setTimeout(() => {
        contentEl !== null && contentEl.removeEventListener("focusout", onBlurRefocusFn);
      });
    }
    setOverflowAnchor(contentEl, toIndex - from);
    const sizeBefore = alignEnd !== void 0 ? virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0;
    if (rangeChanged === true) {
      const tempTo = to >= virtualScrollSliceRange.value.from && from <= virtualScrollSliceRange.value.to ? virtualScrollSliceRange.value.to : to;
      virtualScrollSliceRange.value = { from, to: tempTo };
      virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, from);
      virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);
      requestAnimationFrame(() => {
        if (virtualScrollSliceRange.value.to !== to && prevScrollStart === scrollDetails.scrollStart) {
          virtualScrollSliceRange.value = { from: virtualScrollSliceRange.value.from, to };
          virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);
        }
      });
    }
    requestAnimationFrame(() => {
      if (prevScrollStart !== scrollDetails.scrollStart) {
        return;
      }
      if (rangeChanged === true) {
        updateVirtualScrollSizes(from);
      }
      const sizeAfter = virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0), posStart = sizeAfter + scrollDetails.offsetStart + virtualScrollPaddingBefore.value, posEnd = posStart + virtualScrollSizes[toIndex];
      let scrollPosition = posStart + offset2;
      if (alignEnd !== void 0) {
        const sizeDiff = sizeAfter - sizeBefore;
        const scrollStart = scrollDetails.scrollStart + sizeDiff;
        scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize ? scrollStart : alignEnd === "end" ? posEnd - scrollDetails.scrollViewSize : posStart - (alignEnd === "start" ? 0 : Math.round((scrollDetails.scrollViewSize - virtualScrollSizes[toIndex]) / 2));
      }
      prevScrollStart = scrollPosition;
      setScroll2(
        scrollEl,
        scrollPosition,
        props4.virtualScrollHorizontal,
        $q.lang.rtl
      );
      emitScroll(toIndex);
    });
  }
  function updateVirtualScrollSizes(from) {
    const contentEl = contentRef.value;
    if (contentEl) {
      const children = filterProto.call(
        contentEl.children,
        (el) => el.classList && el.classList.contains("q-virtual-scroll--skip") === false
      ), childrenLength = children.length, sizeFn = props4.virtualScrollHorizontal === true ? (el) => el.getBoundingClientRect().width : (el) => el.offsetHeight;
      let index = from, size2, diff2;
      for (let i = 0; i < childrenLength; ) {
        size2 = sizeFn(children[i]);
        i++;
        while (i < childrenLength && children[i].classList.contains("q-virtual-scroll--with-prev") === true) {
          size2 += sizeFn(children[i]);
          i++;
        }
        diff2 = size2 - virtualScrollSizes[index];
        if (diff2 !== 0) {
          virtualScrollSizes[index] += diff2;
          virtualScrollSizesAgg[Math.floor(index / aggBucketSize)] += diff2;
        }
        index++;
      }
    }
  }
  function onBlurRefocusFn() {
    contentRef.value !== null && contentRef.value !== void 0 && contentRef.value.focus();
  }
  function localResetVirtualScroll(toIndex, fullReset) {
    const defaultSize = 1 * virtualScrollItemSizeComputed.value;
    if (fullReset === true || Array.isArray(virtualScrollSizes) === false) {
      virtualScrollSizes = [];
    }
    const oldVirtualScrollSizesLength = virtualScrollSizes.length;
    virtualScrollSizes.length = virtualScrollLength.value;
    for (let i = virtualScrollLength.value - 1; i >= oldVirtualScrollSizesLength; i--) {
      virtualScrollSizes[i] = defaultSize;
    }
    const jMax = Math.floor((virtualScrollLength.value - 1) / aggBucketSize);
    virtualScrollSizesAgg = [];
    for (let j = 0; j <= jMax; j++) {
      let size2 = 0;
      const iMax = Math.min((j + 1) * aggBucketSize, virtualScrollLength.value);
      for (let i = j * aggBucketSize; i < iMax; i++) {
        size2 += virtualScrollSizes[i];
      }
      virtualScrollSizesAgg.push(size2);
    }
    prevToIndex = -1;
    prevScrollStart = void 0;
    virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, virtualScrollSliceRange.value.from);
    virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, virtualScrollSliceRange.value.to, virtualScrollLength.value);
    if (toIndex >= 0) {
      updateVirtualScrollSizes(virtualScrollSliceRange.value.from);
      nextTick(() => {
        scrollTo(toIndex);
      });
    } else {
      onVirtualScrollEvt();
    }
  }
  function setVirtualScrollSize(scrollViewSize) {
    if (scrollViewSize === void 0 && typeof window !== "undefined") {
      const scrollEl = getVirtualScrollTarget();
      if (scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {
        scrollViewSize = getScrollDetails(
          scrollEl,
          getVirtualScrollEl(),
          beforeRef.value,
          afterRef.value,
          props4.virtualScrollHorizontal,
          $q.lang.rtl,
          props4.virtualScrollStickySizeStart,
          props4.virtualScrollStickySizeEnd
        ).scrollViewSize;
      }
    }
    localScrollViewSize = scrollViewSize;
    const virtualScrollSliceRatioBefore = parseFloat(props4.virtualScrollSliceRatioBefore) || 0;
    const virtualScrollSliceRatioAfter = parseFloat(props4.virtualScrollSliceRatioAfter) || 0;
    const multiplier = 1 + virtualScrollSliceRatioBefore + virtualScrollSliceRatioAfter;
    const view = scrollViewSize === void 0 || scrollViewSize <= 0 ? 1 : Math.ceil(scrollViewSize / virtualScrollItemSizeComputed.value);
    const baseSize = Math.max(
      1,
      view,
      Math.ceil((props4.virtualScrollSliceSize > 0 ? props4.virtualScrollSliceSize : 10) / multiplier)
    );
    virtualScrollSliceSizeComputed.value = {
      total: Math.ceil(baseSize * multiplier),
      start: Math.ceil(baseSize * virtualScrollSliceRatioBefore),
      center: Math.ceil(baseSize * (0.5 + virtualScrollSliceRatioBefore)),
      end: Math.ceil(baseSize * (1 + virtualScrollSliceRatioBefore)),
      view
    };
  }
  function padVirtualScroll(tag, content) {
    const paddingSize = props4.virtualScrollHorizontal === true ? "width" : "height";
    const style2 = {
      ["--q-virtual-scroll-item-" + paddingSize]: virtualScrollItemSizeComputed.value + "px"
    };
    return [
      tag === "tbody" ? h(tag, {
        class: "q-virtual-scroll__padding",
        key: "before",
        ref: beforeRef
      }, [
        h("tr", [
          h("td", {
            style: { [paddingSize]: `${virtualScrollPaddingBefore.value}px`, ...style2 },
            colspan: colspanAttr.value
          })
        ])
      ]) : h(tag, {
        class: "q-virtual-scroll__padding",
        key: "before",
        ref: beforeRef,
        style: { [paddingSize]: `${virtualScrollPaddingBefore.value}px`, ...style2 }
      }),
      h(tag, {
        class: "q-virtual-scroll__content",
        key: "content",
        ref: contentRef,
        tabindex: -1
      }, content.flat()),
      tag === "tbody" ? h(tag, {
        class: "q-virtual-scroll__padding",
        key: "after",
        ref: afterRef
      }, [
        h("tr", [
          h("td", {
            style: { [paddingSize]: `${virtualScrollPaddingAfter.value}px`, ...style2 },
            colspan: colspanAttr.value
          })
        ])
      ]) : h(tag, {
        class: "q-virtual-scroll__padding",
        key: "after",
        ref: afterRef,
        style: { [paddingSize]: `${virtualScrollPaddingAfter.value}px`, ...style2 }
      })
    ];
  }
  function emitScroll(index) {
    if (prevToIndex !== index) {
      props4.onVirtualScroll !== void 0 && emit2("virtualScroll", {
        index,
        from: virtualScrollSliceRange.value.from,
        to: virtualScrollSliceRange.value.to - 1,
        direction: index < prevToIndex ? "decrease" : "increase",
        ref: proxy
      });
      prevToIndex = index;
    }
  }
  setVirtualScrollSize();
  const onVirtualScrollEvt = debounce_default(
    localOnVirtualScrollEvt,
    $q.platform.is.ios === true ? 120 : 35
  );
  onBeforeMount(() => {
    setVirtualScrollSize();
  });
  let shouldActivate = false;
  onDeactivated(() => {
    shouldActivate = true;
  });
  onActivated(() => {
    if (shouldActivate !== true) return;
    const scrollEl = getVirtualScrollTarget();
    if (prevScrollStart !== void 0 && scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {
      setScroll2(
        scrollEl,
        prevScrollStart,
        props4.virtualScrollHorizontal,
        $q.lang.rtl
      );
    } else {
      scrollTo(prevToIndex);
    }
  });
  onBeforeUnmount(() => {
    onVirtualScrollEvt.cancel();
  });
  Object.assign(proxy, { scrollTo, reset, refresh });
  return {
    virtualScrollSliceRange,
    virtualScrollSliceSizeComputed,
    setVirtualScrollSize,
    onVirtualScrollEvt,
    localResetVirtualScroll,
    padVirtualScroll,
    scrollTo,
    reset,
    refresh
  };
}
var validateNewValueMode = (v2) => ["add", "add-unique", "toggle"].includes(v2);
var reEscapeList = ".*+?^${}()|[]\\";
var fieldPropsList = Object.keys(useFieldProps);
function getPropValueFn2(userPropName, defaultPropName) {
  if (typeof userPropName === "function") return userPropName;
  const propName = userPropName !== void 0 ? userPropName : defaultPropName;
  return (opt) => opt !== null && typeof opt === "object" && propName in opt ? opt[propName] : opt;
}
var QSelect_default = createComponent({
  name: "QSelect",
  inheritAttrs: false,
  props: {
    ...useVirtualScrollProps,
    ...useFormProps,
    ...useFieldProps,
    // override of useFieldProps > modelValue
    modelValue: {
      required: true
    },
    multiple: Boolean,
    displayValue: [String, Number],
    displayValueHtml: Boolean,
    dropdownIcon: String,
    options: {
      type: Array,
      default: () => []
    },
    optionValue: [Function, String],
    optionLabel: [Function, String],
    optionDisable: [Function, String],
    hideSelected: Boolean,
    hideDropdownIcon: Boolean,
    fillInput: Boolean,
    maxValues: [Number, String],
    optionsDense: Boolean,
    optionsDark: {
      type: Boolean,
      default: null
    },
    optionsSelectedClass: String,
    optionsHtml: Boolean,
    optionsCover: Boolean,
    menuShrink: Boolean,
    menuAnchor: String,
    menuSelf: String,
    menuOffset: Array,
    popupContentClass: String,
    popupContentStyle: [String, Array, Object],
    popupNoRouteDismiss: Boolean,
    useInput: Boolean,
    useChips: Boolean,
    newValueMode: {
      type: String,
      validator: validateNewValueMode
    },
    mapOptions: Boolean,
    emitValue: Boolean,
    disableTabSelection: Boolean,
    inputDebounce: {
      type: [Number, String],
      default: 500
    },
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object],
    tabindex: {
      type: [String, Number],
      default: 0
    },
    autocomplete: String,
    transitionShow: {},
    transitionHide: {},
    transitionDuration: {},
    behavior: {
      type: String,
      validator: (v2) => ["default", "menu", "dialog"].includes(v2),
      default: "default"
    },
    // override of useVirtualScrollProps > virtualScrollItemSize (no default)
    virtualScrollItemSize: useVirtualScrollProps.virtualScrollItemSize.type,
    onNewValue: Function,
    onFilter: Function
  },
  emits: [
    ...useFieldEmits,
    "add",
    "remove",
    "inputValue",
    "keyup",
    "keypress",
    "keydown",
    "popupShow",
    "popupHide",
    "filterAbort"
  ],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const menu2 = ref(false);
    const dialog = ref(false);
    const optionIndex = ref(-1);
    const inputValue = ref("");
    const dialogFieldFocused = ref(false);
    const innerLoadingIndicator = ref(false);
    let filterTimer = null, inputValueTimer = null, innerValueCache, hasDialog, userInputValue, filterId = null, defaultInputValue, transitionShowComputed, searchBuffer, searchBufferExp;
    const inputRef = ref(null);
    const targetRef = ref(null);
    const menuRef = ref(null);
    const dialogRef = ref(null);
    const menuContentRef = ref(null);
    const nameProp = useFormInputNameAttr(props4);
    const onComposition = use_key_composition_default(onInput);
    const virtualScrollLength = computed(() => props4.options.length);
    const virtualScrollItemSizeComputed = computed(() => props4.virtualScrollItemSize === void 0 ? props4.optionsDense === true ? 24 : 48 : props4.virtualScrollItemSize);
    const {
      virtualScrollSliceRange,
      virtualScrollSliceSizeComputed,
      localResetVirtualScroll,
      padVirtualScroll,
      onVirtualScrollEvt,
      scrollTo,
      setVirtualScrollSize
    } = useVirtualScroll({
      virtualScrollLength,
      getVirtualScrollTarget,
      getVirtualScrollEl,
      virtualScrollItemSizeComputed
    });
    const state = useFieldState();
    const innerValue = computed(() => {
      const mapNull = props4.mapOptions === true && props4.multiple !== true, val = props4.modelValue !== void 0 && (props4.modelValue !== null || mapNull === true) ? props4.multiple === true && Array.isArray(props4.modelValue) ? props4.modelValue : [props4.modelValue] : [];
      if (props4.mapOptions === true) {
        const cache2 = props4.mapOptions === true && innerValueCache !== void 0 ? innerValueCache : [];
        const values = val.map((v2) => getOption(v2, cache2));
        return props4.modelValue === null && mapNull === true ? values.filter((v2) => v2 !== null) : values;
      }
      return val;
    });
    const innerFieldProps = computed(() => {
      const acc = {};
      fieldPropsList.forEach((key) => {
        const val = props4[key];
        if (val !== void 0) {
          acc[key] = val;
        }
      });
      return acc;
    });
    const isOptionsDark = computed(() => props4.optionsDark === null ? state.isDark.value : props4.optionsDark);
    const hasValue = computed(() => fieldValueIsFilled(innerValue.value));
    const computedInputClass = computed(() => {
      let cls = "q-field__input q-placeholder col";
      if (props4.hideSelected === true || innerValue.value.length === 0) {
        return [cls, props4.inputClass];
      }
      cls += " q-field__input--padding";
      return props4.inputClass === void 0 ? cls : [cls, props4.inputClass];
    });
    const menuContentClass = computed(
      () => (props4.virtualScrollHorizontal === true ? "q-virtual-scroll--horizontal" : "") + (props4.popupContentClass ? " " + props4.popupContentClass : "")
    );
    const noOptions = computed(() => virtualScrollLength.value === 0);
    const selectedString = computed(
      () => innerValue.value.map((opt) => getOptionLabel.value(opt)).join(", ")
    );
    const ariaCurrentValue = computed(() => props4.displayValue !== void 0 ? props4.displayValue : selectedString.value);
    const needsHtmlFn = computed(() => props4.optionsHtml === true ? () => true : (opt) => opt !== void 0 && opt !== null && opt.html === true);
    const valueAsHtml = computed(() => props4.displayValueHtml === true || props4.displayValue === void 0 && (props4.optionsHtml === true || innerValue.value.some(needsHtmlFn.value)));
    const tabindex = computed(() => state.focused.value === true ? props4.tabindex : -1);
    const comboboxAttrs = computed(() => {
      const attrs = {
        tabindex: props4.tabindex,
        role: "combobox",
        "aria-label": props4.label,
        "aria-readonly": props4.readonly === true ? "true" : "false",
        "aria-autocomplete": props4.useInput === true ? "list" : "none",
        "aria-expanded": menu2.value === true ? "true" : "false",
        "aria-controls": `${state.targetUid.value}_lb`
      };
      if (optionIndex.value >= 0) {
        attrs["aria-activedescendant"] = `${state.targetUid.value}_${optionIndex.value}`;
      }
      return attrs;
    });
    const listboxAttrs = computed(() => ({
      id: `${state.targetUid.value}_lb`,
      role: "listbox",
      "aria-multiselectable": props4.multiple === true ? "true" : "false"
    }));
    const selectedScope = computed(() => {
      return innerValue.value.map((opt, i) => ({
        index: i,
        opt,
        html: needsHtmlFn.value(opt),
        selected: true,
        removeAtIndex: removeAtIndexAndFocus,
        toggleOption,
        tabindex: tabindex.value
      }));
    });
    const optionScope = computed(() => {
      if (virtualScrollLength.value === 0) {
        return [];
      }
      const { from, to } = virtualScrollSliceRange.value;
      return props4.options.slice(from, to).map((opt, i) => {
        const disable = isOptionDisabled.value(opt) === true;
        const active = isOptionSelected(opt) === true;
        const index = from + i;
        const itemProps = {
          clickable: true,
          active,
          activeClass: computedOptionsSelectedClass.value,
          manualFocus: true,
          focused: false,
          disable,
          tabindex: -1,
          dense: props4.optionsDense,
          dark: isOptionsDark.value,
          role: "option",
          "aria-selected": active === true ? "true" : "false",
          id: `${state.targetUid.value}_${index}`,
          onClick: () => {
            toggleOption(opt);
          }
        };
        if (disable !== true) {
          optionIndex.value === index && (itemProps.focused = true);
          if ($q.platform.is.desktop === true) {
            itemProps.onMousemove = () => {
              menu2.value === true && setOptionIndex(index);
            };
          }
        }
        return {
          index,
          opt,
          html: needsHtmlFn.value(opt),
          label: getOptionLabel.value(opt),
          selected: itemProps.active,
          focused: itemProps.focused,
          toggleOption,
          setOptionIndex,
          itemProps
        };
      });
    });
    const dropdownArrowIcon = computed(() => props4.dropdownIcon !== void 0 ? props4.dropdownIcon : $q.iconSet.arrow.dropdown);
    const squaredMenu = computed(
      () => props4.optionsCover === false && props4.outlined !== true && props4.standout !== true && props4.borderless !== true && props4.rounded !== true
    );
    const computedOptionsSelectedClass = computed(() => props4.optionsSelectedClass !== void 0 ? props4.optionsSelectedClass : props4.color !== void 0 ? `text-${props4.color}` : "");
    const getOptionValue = computed(() => getPropValueFn2(props4.optionValue, "value"));
    const getOptionLabel = computed(() => getPropValueFn2(props4.optionLabel, "label"));
    const isOptionDisabled = computed(() => getPropValueFn2(props4.optionDisable, "disable"));
    const innerOptionsValue = computed(() => innerValue.value.map(getOptionValue.value));
    const inputControlEvents = computed(() => {
      const evt = {
        onInput,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        onChange: onComposition,
        onKeydown: onTargetKeydown,
        onKeyup: onTargetAutocomplete,
        onKeypress: onTargetKeypress,
        onFocus: selectInputText,
        onClick(e) {
          hasDialog === true && stop(e);
        }
      };
      evt.onCompositionstart = evt.onCompositionupdate = evt.onCompositionend = onComposition;
      return evt;
    });
    watch(innerValue, (val) => {
      innerValueCache = val;
      if (props4.useInput === true && props4.fillInput === true && props4.multiple !== true && state.innerLoading.value !== true && (dialog.value !== true && menu2.value !== true || hasValue.value !== true)) {
        userInputValue !== true && resetInputValue();
        if (dialog.value === true || menu2.value === true) {
          filter("");
        }
      }
    }, { immediate: true });
    watch(() => props4.fillInput, resetInputValue);
    watch(menu2, updateMenu);
    watch(virtualScrollLength, rerenderMenu);
    function getEmittingOptionValue(opt) {
      return props4.emitValue === true ? getOptionValue.value(opt) : opt;
    }
    function removeAtIndex(index) {
      if (index !== -1 && index < innerValue.value.length) {
        if (props4.multiple === true) {
          const model = props4.modelValue.slice();
          emit2("remove", { index, value: model.splice(index, 1)[0] });
          emit2("update:modelValue", model);
        } else {
          emit2("update:modelValue", null);
        }
      }
    }
    function removeAtIndexAndFocus(index) {
      removeAtIndex(index);
      state.focus();
    }
    function add2(opt, unique) {
      const val = getEmittingOptionValue(opt);
      if (props4.multiple !== true) {
        props4.fillInput === true && updateInputValue(
          getOptionLabel.value(opt),
          true,
          true
        );
        emit2("update:modelValue", val);
        return;
      }
      if (innerValue.value.length === 0) {
        emit2("add", { index: 0, value: val });
        emit2("update:modelValue", props4.multiple === true ? [val] : val);
        return;
      }
      if (unique === true && isOptionSelected(opt) === true) {
        return;
      }
      if (props4.maxValues !== void 0 && props4.modelValue.length >= props4.maxValues) {
        return;
      }
      const model = props4.modelValue.slice();
      emit2("add", { index: model.length, value: val });
      model.push(val);
      emit2("update:modelValue", model);
    }
    function toggleOption(opt, keepOpen) {
      if (state.editable.value !== true || opt === void 0 || isOptionDisabled.value(opt) === true) {
        return;
      }
      const optValue = getOptionValue.value(opt);
      if (props4.multiple !== true) {
        if (keepOpen !== true) {
          updateInputValue(
            props4.fillInput === true ? getOptionLabel.value(opt) : "",
            true,
            true
          );
          hidePopup();
        }
        targetRef.value !== null && targetRef.value.focus();
        if (innerValue.value.length === 0 || isDeepEqual(getOptionValue.value(innerValue.value[0]), optValue) !== true) {
          emit2("update:modelValue", props4.emitValue === true ? optValue : opt);
        }
        return;
      }
      (hasDialog !== true || dialogFieldFocused.value === true) && state.focus();
      selectInputText();
      if (innerValue.value.length === 0) {
        const val = props4.emitValue === true ? optValue : opt;
        emit2("add", { index: 0, value: val });
        emit2("update:modelValue", props4.multiple === true ? [val] : val);
        return;
      }
      const model = props4.modelValue.slice(), index = innerOptionsValue.value.findIndex((v2) => isDeepEqual(v2, optValue));
      if (index !== -1) {
        emit2("remove", { index, value: model.splice(index, 1)[0] });
      } else {
        if (props4.maxValues !== void 0 && model.length >= props4.maxValues) {
          return;
        }
        const val = props4.emitValue === true ? optValue : opt;
        emit2("add", { index: model.length, value: val });
        model.push(val);
      }
      emit2("update:modelValue", model);
    }
    function setOptionIndex(index) {
      if ($q.platform.is.desktop !== true) return;
      const val = index !== -1 && index < virtualScrollLength.value ? index : -1;
      if (optionIndex.value !== val) {
        optionIndex.value = val;
      }
    }
    function moveOptionSelection(offset2 = 1, skipInputValue) {
      if (menu2.value === true) {
        let index = optionIndex.value;
        do {
          index = normalizeToInterval(
            index + offset2,
            -1,
            virtualScrollLength.value - 1
          );
        } while (index !== -1 && index !== optionIndex.value && isOptionDisabled.value(props4.options[index]) === true);
        if (optionIndex.value !== index) {
          setOptionIndex(index);
          scrollTo(index);
          if (skipInputValue !== true && props4.useInput === true && props4.fillInput === true) {
            setInputValue(
              index >= 0 ? getOptionLabel.value(props4.options[index]) : defaultInputValue,
              true
            );
          }
        }
      }
    }
    function getOption(value2, valueCache) {
      const fn = (opt) => isDeepEqual(getOptionValue.value(opt), value2);
      return props4.options.find(fn) || valueCache.find(fn) || value2;
    }
    function isOptionSelected(opt) {
      const val = getOptionValue.value(opt);
      return innerOptionsValue.value.find((v2) => isDeepEqual(v2, val)) !== void 0;
    }
    function selectInputText(e) {
      if (props4.useInput === true && targetRef.value !== null && (e === void 0 || targetRef.value === e.target && e.target.value === selectedString.value)) {
        targetRef.value.select();
      }
    }
    function onTargetKeyup(e) {
      if (isKeyCode(e, 27) === true && menu2.value === true) {
        stop(e);
        hidePopup();
        resetInputValue();
      }
      emit2("keyup", e);
    }
    function onTargetAutocomplete(e) {
      const { value: value2 } = e.target;
      if (e.keyCode !== void 0) {
        onTargetKeyup(e);
        return;
      }
      e.target.value = "";
      if (filterTimer !== null) {
        clearTimeout(filterTimer);
        filterTimer = null;
      }
      if (inputValueTimer !== null) {
        clearTimeout(inputValueTimer);
        inputValueTimer = null;
      }
      resetInputValue();
      if (typeof value2 === "string" && value2.length !== 0) {
        const needle = value2.toLocaleLowerCase();
        const findFn = (extractFn) => {
          const option = props4.options.find((opt) => extractFn.value(opt).toLocaleLowerCase() === needle);
          if (option === void 0) {
            return false;
          }
          if (innerValue.value.indexOf(option) === -1) {
            toggleOption(option);
          } else {
            hidePopup();
          }
          return true;
        };
        const fillFn = (afterFilter) => {
          if (findFn(getOptionValue) === true) {
            return;
          }
          if (findFn(getOptionLabel) === true || afterFilter === true) {
            return;
          }
          filter(value2, true, () => fillFn(true));
        };
        fillFn();
      } else {
        state.clearValue(e);
      }
    }
    function onTargetKeypress(e) {
      emit2("keypress", e);
    }
    function onTargetKeydown(e) {
      emit2("keydown", e);
      if (shouldIgnoreKey(e) === true) {
        return;
      }
      const newValueModeValid = inputValue.value.length !== 0 && (props4.newValueMode !== void 0 || props4.onNewValue !== void 0);
      const tabShouldSelect = e.shiftKey !== true && props4.disableTabSelection !== true && props4.multiple !== true && (optionIndex.value !== -1 || newValueModeValid === true);
      if (e.keyCode === 27) {
        prevent(e);
        return;
      }
      if (e.keyCode === 9 && tabShouldSelect === false) {
        closeMenu();
        return;
      }
      if (e.target === void 0 || e.target.id !== state.targetUid.value || state.editable.value !== true) return;
      if (e.keyCode === 40 && state.innerLoading.value !== true && menu2.value === false) {
        stopAndPrevent(e);
        showPopup();
        return;
      }
      if (e.keyCode === 8 && (props4.useChips === true || props4.clearable === true) && props4.hideSelected !== true && inputValue.value.length === 0) {
        if (props4.multiple === true && Array.isArray(props4.modelValue) === true) {
          removeAtIndex(props4.modelValue.length - 1);
        } else if (props4.multiple !== true && props4.modelValue !== null) {
          emit2("update:modelValue", null);
        }
        return;
      }
      if ((e.keyCode === 35 || e.keyCode === 36) && (typeof inputValue.value !== "string" || inputValue.value.length === 0)) {
        stopAndPrevent(e);
        optionIndex.value = -1;
        moveOptionSelection(e.keyCode === 36 ? 1 : -1, props4.multiple);
      }
      if ((e.keyCode === 33 || e.keyCode === 34) && virtualScrollSliceSizeComputed.value !== void 0) {
        stopAndPrevent(e);
        optionIndex.value = Math.max(
          -1,
          Math.min(
            virtualScrollLength.value,
            optionIndex.value + (e.keyCode === 33 ? -1 : 1) * virtualScrollSliceSizeComputed.value.view
          )
        );
        moveOptionSelection(e.keyCode === 33 ? 1 : -1, props4.multiple);
      }
      if (e.keyCode === 38 || e.keyCode === 40) {
        stopAndPrevent(e);
        moveOptionSelection(e.keyCode === 38 ? -1 : 1, props4.multiple);
      }
      const optionsLength = virtualScrollLength.value;
      if (searchBuffer === void 0 || searchBufferExp < Date.now()) {
        searchBuffer = "";
      }
      if (optionsLength > 0 && props4.useInput !== true && e.key !== void 0 && e.key.length === 1 && e.altKey === false && e.ctrlKey === false && e.metaKey === false && (e.keyCode !== 32 || searchBuffer.length !== 0)) {
        menu2.value !== true && showPopup(e);
        const char = e.key.toLocaleLowerCase(), keyRepeat = searchBuffer.length === 1 && searchBuffer[0] === char;
        searchBufferExp = Date.now() + 1500;
        if (keyRepeat === false) {
          stopAndPrevent(e);
          searchBuffer += char;
        }
        const searchRe = new RegExp("^" + searchBuffer.split("").map((l) => reEscapeList.indexOf(l) !== -1 ? "\\" + l : l).join(".*"), "i");
        let index = optionIndex.value;
        if (keyRepeat === true || index < 0 || searchRe.test(getOptionLabel.value(props4.options[index])) !== true) {
          do {
            index = normalizeToInterval(index + 1, -1, optionsLength - 1);
          } while (index !== optionIndex.value && (isOptionDisabled.value(props4.options[index]) === true || searchRe.test(getOptionLabel.value(props4.options[index])) !== true));
        }
        if (optionIndex.value !== index) {
          nextTick(() => {
            setOptionIndex(index);
            scrollTo(index);
            if (index >= 0 && props4.useInput === true && props4.fillInput === true) {
              setInputValue(getOptionLabel.value(props4.options[index]), true);
            }
          });
        }
        return;
      }
      if (e.keyCode !== 13 && (e.keyCode !== 32 || props4.useInput === true || searchBuffer !== "") && (e.keyCode !== 9 || tabShouldSelect === false)) return;
      e.keyCode !== 9 && stopAndPrevent(e);
      if (optionIndex.value !== -1 && optionIndex.value < optionsLength) {
        toggleOption(props4.options[optionIndex.value]);
        return;
      }
      if (newValueModeValid === true) {
        const done = (val, mode) => {
          if (mode) {
            if (validateNewValueMode(mode) !== true) {
              return;
            }
          } else {
            mode = props4.newValueMode;
          }
          updateInputValue("", props4.multiple !== true, true);
          if (val === void 0 || val === null) {
            return;
          }
          const fn = mode === "toggle" ? toggleOption : add2;
          fn(val, mode === "add-unique");
          if (props4.multiple !== true) {
            targetRef.value !== null && targetRef.value.focus();
            hidePopup();
          }
        };
        if (props4.onNewValue !== void 0) {
          emit2("newValue", inputValue.value, done);
        } else {
          done(inputValue.value);
        }
        if (props4.multiple !== true) {
          return;
        }
      }
      if (menu2.value === true) {
        closeMenu();
      } else if (state.innerLoading.value !== true) {
        showPopup();
      }
    }
    function getVirtualScrollEl() {
      return hasDialog === true ? menuContentRef.value : menuRef.value !== null && menuRef.value.contentEl !== null ? menuRef.value.contentEl : void 0;
    }
    function getVirtualScrollTarget() {
      return getVirtualScrollEl();
    }
    function getSelection() {
      if (props4.hideSelected === true) {
        return [];
      }
      if (slots["selected-item"] !== void 0) {
        return selectedScope.value.map((scope) => slots["selected-item"](scope)).slice();
      }
      if (slots.selected !== void 0) {
        return [].concat(slots.selected());
      }
      if (props4.useChips === true) {
        return selectedScope.value.map((scope, i) => h(QChip_default, {
          key: "option-" + i,
          removable: state.editable.value === true && isOptionDisabled.value(scope.opt) !== true,
          dense: true,
          textColor: props4.color,
          tabindex: tabindex.value,
          onRemove() {
            scope.removeAtIndex(i);
          }
        }, () => h("span", {
          class: "ellipsis",
          [scope.html === true ? "innerHTML" : "textContent"]: getOptionLabel.value(scope.opt)
        })));
      }
      return [
        h("span", {
          [valueAsHtml.value === true ? "innerHTML" : "textContent"]: ariaCurrentValue.value
        })
      ];
    }
    function getAllOptions() {
      if (noOptions.value === true) {
        return slots["no-option"] !== void 0 ? slots["no-option"]({ inputValue: inputValue.value }) : void 0;
      }
      const fn = slots.option !== void 0 ? slots.option : (scope) => {
        return h(QItem_default, {
          key: scope.index,
          ...scope.itemProps
        }, () => {
          return h(
            QItemSection_default,
            () => h(
              QItemLabel_default,
              () => h("span", {
                [scope.html === true ? "innerHTML" : "textContent"]: scope.label
              })
            )
          );
        });
      };
      let options = padVirtualScroll("div", optionScope.value.map(fn));
      if (slots["before-options"] !== void 0) {
        options = slots["before-options"]().concat(options);
      }
      return hMergeSlot(slots["after-options"], options);
    }
    function getInput(fromDialog, isTarget) {
      const attrs = isTarget === true ? { ...comboboxAttrs.value, ...state.splitAttrs.attributes.value } : void 0;
      const data = {
        ref: isTarget === true ? targetRef : void 0,
        key: "i_t",
        class: computedInputClass.value,
        style: props4.inputStyle,
        value: inputValue.value !== void 0 ? inputValue.value : "",
        // required for Android in order to show ENTER key when in form
        type: "search",
        ...attrs,
        id: isTarget === true ? state.targetUid.value : void 0,
        maxlength: props4.maxlength,
        autocomplete: props4.autocomplete,
        "data-autofocus": fromDialog === true || props4.autofocus === true || void 0,
        disabled: props4.disable === true,
        readonly: props4.readonly === true,
        ...inputControlEvents.value
      };
      if (fromDialog !== true && hasDialog === true) {
        if (Array.isArray(data.class) === true) {
          data.class = [...data.class, "no-pointer-events"];
        } else {
          data.class += " no-pointer-events";
        }
      }
      return h("input", data);
    }
    function onInput(e) {
      if (filterTimer !== null) {
        clearTimeout(filterTimer);
        filterTimer = null;
      }
      if (inputValueTimer !== null) {
        clearTimeout(inputValueTimer);
        inputValueTimer = null;
      }
      if (e && e.target && e.target.qComposing === true) {
        return;
      }
      setInputValue(e.target.value || "");
      userInputValue = true;
      defaultInputValue = inputValue.value;
      if (state.focused.value !== true && (hasDialog !== true || dialogFieldFocused.value === true)) {
        state.focus();
      }
      if (props4.onFilter !== void 0) {
        filterTimer = setTimeout(() => {
          filterTimer = null;
          filter(inputValue.value);
        }, props4.inputDebounce);
      }
    }
    function setInputValue(val, emitImmediately) {
      if (inputValue.value !== val) {
        inputValue.value = val;
        if (emitImmediately === true || props4.inputDebounce === 0 || props4.inputDebounce === "0") {
          emit2("inputValue", val);
        } else {
          inputValueTimer = setTimeout(() => {
            inputValueTimer = null;
            emit2("inputValue", val);
          }, props4.inputDebounce);
        }
      }
    }
    function updateInputValue(val, noFiltering, internal) {
      userInputValue = internal !== true;
      if (props4.useInput === true) {
        setInputValue(val, true);
        if (noFiltering === true || internal !== true) {
          defaultInputValue = val;
        }
        noFiltering !== true && filter(val);
      }
    }
    function filter(val, keepClosed, afterUpdateFn) {
      if (props4.onFilter === void 0 || keepClosed !== true && state.focused.value !== true) {
        return;
      }
      if (state.innerLoading.value === true) {
        emit2("filterAbort");
      } else {
        state.innerLoading.value = true;
        innerLoadingIndicator.value = true;
      }
      if (val !== "" && props4.multiple !== true && innerValue.value.length !== 0 && userInputValue !== true && val === getOptionLabel.value(innerValue.value[0])) {
        val = "";
      }
      const localFilterId = setTimeout(() => {
        menu2.value === true && (menu2.value = false);
      }, 10);
      filterId !== null && clearTimeout(filterId);
      filterId = localFilterId;
      emit2(
        "filter",
        val,
        (fn, afterFn) => {
          if ((keepClosed === true || state.focused.value === true) && filterId === localFilterId) {
            clearTimeout(filterId);
            typeof fn === "function" && fn();
            innerLoadingIndicator.value = false;
            nextTick(() => {
              state.innerLoading.value = false;
              if (state.editable.value === true) {
                if (keepClosed === true) {
                  menu2.value === true && hidePopup();
                } else if (menu2.value === true) {
                  updateMenu(true);
                } else {
                  menu2.value = true;
                }
              }
              typeof afterFn === "function" && nextTick(() => {
                afterFn(proxy);
              });
              typeof afterUpdateFn === "function" && nextTick(() => {
                afterUpdateFn(proxy);
              });
            });
          }
        },
        () => {
          if (state.focused.value === true && filterId === localFilterId) {
            clearTimeout(filterId);
            state.innerLoading.value = false;
            innerLoadingIndicator.value = false;
          }
          menu2.value === true && (menu2.value = false);
        }
      );
    }
    function getMenu() {
      return h(QMenu_default, {
        ref: menuRef,
        class: menuContentClass.value,
        style: props4.popupContentStyle,
        modelValue: menu2.value,
        fit: props4.menuShrink !== true,
        cover: props4.optionsCover === true && noOptions.value !== true && props4.useInput !== true,
        anchor: props4.menuAnchor,
        self: props4.menuSelf,
        offset: props4.menuOffset,
        dark: isOptionsDark.value,
        noParentEvent: true,
        noRefocus: true,
        noFocus: true,
        noRouteDismiss: props4.popupNoRouteDismiss,
        square: squaredMenu.value,
        transitionShow: props4.transitionShow,
        transitionHide: props4.transitionHide,
        transitionDuration: props4.transitionDuration,
        separateClosePopup: true,
        ...listboxAttrs.value,
        onScrollPassive: onVirtualScrollEvt,
        onBeforeShow: onControlPopupShow,
        onBeforeHide: onMenuBeforeHide,
        onShow: onMenuShow
      }, getAllOptions);
    }
    function onMenuBeforeHide(e) {
      onControlPopupHide(e);
      closeMenu();
    }
    function onMenuShow() {
      setVirtualScrollSize();
    }
    function onDialogFieldFocus(e) {
      stop(e);
      targetRef.value !== null && targetRef.value.focus();
      dialogFieldFocused.value = true;
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0);
    }
    function onDialogFieldBlur(e) {
      stop(e);
      nextTick(() => {
        dialogFieldFocused.value = false;
      });
    }
    function getDialog() {
      const content = [
        h(QField_default, {
          class: `col-auto ${state.fieldClass.value}`,
          ...innerFieldProps.value,
          for: state.targetUid.value,
          dark: isOptionsDark.value,
          square: true,
          loading: innerLoadingIndicator.value,
          itemAligned: false,
          filled: true,
          stackLabel: inputValue.value.length !== 0,
          ...state.splitAttrs.listeners.value,
          onFocus: onDialogFieldFocus,
          onBlur: onDialogFieldBlur
        }, {
          ...slots,
          rawControl: () => state.getControl(true),
          before: void 0,
          after: void 0
        })
      ];
      menu2.value === true && content.push(
        h("div", {
          ref: menuContentRef,
          class: menuContentClass.value + " scroll",
          style: props4.popupContentStyle,
          ...listboxAttrs.value,
          onClick: prevent,
          onScrollPassive: onVirtualScrollEvt
        }, getAllOptions())
      );
      return h(QDialog_default, {
        ref: dialogRef,
        modelValue: dialog.value,
        position: props4.useInput === true ? "top" : void 0,
        transitionShow: transitionShowComputed,
        transitionHide: props4.transitionHide,
        transitionDuration: props4.transitionDuration,
        noRouteDismiss: props4.popupNoRouteDismiss,
        onBeforeShow: onControlPopupShow,
        onBeforeHide: onDialogBeforeHide,
        onHide: onDialogHide,
        onShow: onDialogShow
      }, () => h("div", {
        class: "q-select__dialog" + (isOptionsDark.value === true ? " q-select__dialog--dark q-dark" : "") + (dialogFieldFocused.value === true ? " q-select__dialog--focused" : "")
      }, content));
    }
    function onDialogBeforeHide(e) {
      onControlPopupHide(e);
      if (dialogRef.value !== null) {
        dialogRef.value.__updateRefocusTarget(
          state.rootRef.value.querySelector(".q-field__native > [tabindex]:last-child")
        );
      }
      state.focused.value = false;
    }
    function onDialogHide(e) {
      hidePopup();
      state.focused.value === false && emit2("blur", e);
      resetInputValue();
    }
    function onDialogShow() {
      const el = document.activeElement;
      if ((el === null || el.id !== state.targetUid.value) && targetRef.value !== null && targetRef.value !== el) {
        targetRef.value.focus();
      }
      setVirtualScrollSize();
    }
    function closeMenu() {
      if (dialog.value === true) {
        return;
      }
      optionIndex.value = -1;
      if (menu2.value === true) {
        menu2.value = false;
      }
      if (state.focused.value === false) {
        if (filterId !== null) {
          clearTimeout(filterId);
          filterId = null;
        }
        if (state.innerLoading.value === true) {
          emit2("filterAbort");
          state.innerLoading.value = false;
          innerLoadingIndicator.value = false;
        }
      }
    }
    function showPopup(e) {
      if (state.editable.value !== true) {
        return;
      }
      if (hasDialog === true) {
        state.onControlFocusin(e);
        dialog.value = true;
        nextTick(() => {
          state.focus();
        });
      } else {
        state.focus();
      }
      if (props4.onFilter !== void 0) {
        filter(inputValue.value);
      } else if (noOptions.value !== true || slots["no-option"] !== void 0) {
        menu2.value = true;
      }
    }
    function hidePopup() {
      dialog.value = false;
      closeMenu();
    }
    function resetInputValue() {
      props4.useInput === true && updateInputValue(
        props4.multiple !== true && props4.fillInput === true && innerValue.value.length !== 0 ? getOptionLabel.value(innerValue.value[0]) || "" : "",
        true,
        true
      );
    }
    function updateMenu(show) {
      let optionIndex2 = -1;
      if (show === true) {
        if (innerValue.value.length !== 0) {
          const val = getOptionValue.value(innerValue.value[0]);
          optionIndex2 = props4.options.findIndex((v2) => isDeepEqual(getOptionValue.value(v2), val));
        }
        localResetVirtualScroll(optionIndex2);
      }
      setOptionIndex(optionIndex2);
    }
    function rerenderMenu(newLength, oldLength) {
      if (menu2.value === true && state.innerLoading.value === false) {
        localResetVirtualScroll(-1, true);
        nextTick(() => {
          if (menu2.value === true && state.innerLoading.value === false) {
            if (newLength > oldLength) {
              localResetVirtualScroll();
            } else {
              updateMenu(true);
            }
          }
        });
      }
    }
    function updateMenuPosition() {
      if (dialog.value === false && menuRef.value !== null) {
        menuRef.value.updatePosition();
      }
    }
    function onControlPopupShow(e) {
      e !== void 0 && stop(e);
      emit2("popupShow", e);
      state.hasPopupOpen = true;
      state.onControlFocusin(e);
    }
    function onControlPopupHide(e) {
      e !== void 0 && stop(e);
      emit2("popupHide", e);
      state.hasPopupOpen = false;
      state.onControlFocusout(e);
    }
    function updatePreState() {
      hasDialog = $q.platform.is.mobile !== true && props4.behavior !== "dialog" ? false : props4.behavior !== "menu" && (props4.useInput === true ? slots["no-option"] !== void 0 || props4.onFilter !== void 0 || noOptions.value === false : true);
      transitionShowComputed = $q.platform.is.ios === true && hasDialog === true && props4.useInput === true ? "fade" : props4.transitionShow;
    }
    onBeforeUpdate(updatePreState);
    onUpdated(updateMenuPosition);
    updatePreState();
    onBeforeUnmount(() => {
      filterTimer !== null && clearTimeout(filterTimer);
      inputValueTimer !== null && clearTimeout(inputValueTimer);
    });
    Object.assign(proxy, {
      showPopup,
      hidePopup,
      removeAtIndex,
      add: add2,
      toggleOption,
      getOptionIndex: () => optionIndex.value,
      setOptionIndex,
      moveOptionSelection,
      filter,
      updateMenuPosition,
      updateInputValue,
      isOptionSelected,
      getEmittingOptionValue,
      isOptionDisabled: (...args) => isOptionDisabled.value.apply(null, args) === true,
      getOptionValue: (...args) => getOptionValue.value.apply(null, args),
      getOptionLabel: (...args) => getOptionLabel.value.apply(null, args)
    });
    Object.assign(state, {
      innerValue,
      fieldClass: computed(
        () => `q-select q-field--auto-height q-select--with${props4.useInput !== true ? "out" : ""}-input q-select--with${props4.useChips !== true ? "out" : ""}-chips q-select--${props4.multiple === true ? "multiple" : "single"}`
      ),
      inputRef,
      targetRef,
      hasValue,
      showPopup,
      floatingLabel: computed(
        () => props4.hideSelected !== true && hasValue.value === true || typeof inputValue.value === "number" || inputValue.value.length !== 0 || fieldValueIsFilled(props4.displayValue)
      ),
      getControlChild: () => {
        if (state.editable.value !== false && (dialog.value === true || noOptions.value !== true || slots["no-option"] !== void 0)) {
          return hasDialog === true ? getDialog() : getMenu();
        } else if (state.hasPopupOpen === true) {
          state.hasPopupOpen = false;
        }
      },
      controlEvents: {
        onFocusin(e) {
          state.onControlFocusin(e);
        },
        onFocusout(e) {
          state.onControlFocusout(e, () => {
            resetInputValue();
            closeMenu();
          });
        },
        onClick(e) {
          prevent(e);
          if (hasDialog !== true && menu2.value === true) {
            closeMenu();
            targetRef.value !== null && targetRef.value.focus();
            return;
          }
          showPopup(e);
        }
      },
      getControl: (fromDialog) => {
        const child = getSelection();
        const isTarget = fromDialog === true || dialog.value !== true || hasDialog !== true;
        if (props4.useInput === true) {
          child.push(getInput(fromDialog, isTarget));
        } else if (state.editable.value === true) {
          const attrs2 = isTarget === true ? comboboxAttrs.value : void 0;
          child.push(
            h("input", {
              ref: isTarget === true ? targetRef : void 0,
              key: "d_t",
              class: "q-select__focus-target",
              id: isTarget === true ? state.targetUid.value : void 0,
              value: ariaCurrentValue.value,
              readonly: true,
              "data-autofocus": fromDialog === true || props4.autofocus === true || void 0,
              ...attrs2,
              onKeydown: onTargetKeydown,
              onKeyup: onTargetKeyup,
              onKeypress: onTargetKeypress
            })
          );
          if (isTarget === true && typeof props4.autocomplete === "string" && props4.autocomplete.length !== 0) {
            child.push(
              h("input", {
                class: "q-select__autocomplete-input",
                autocomplete: props4.autocomplete,
                tabindex: -1,
                onKeyup: onTargetAutocomplete
              })
            );
          }
        }
        if (nameProp.value !== void 0 && props4.disable !== true && innerOptionsValue.value.length !== 0) {
          const opts = innerOptionsValue.value.map((value2) => h("option", { value: value2, selected: true }));
          child.push(
            h("select", {
              class: "hidden",
              name: nameProp.value,
              multiple: props4.multiple
            }, opts)
          );
        }
        const attrs = props4.useInput === true || isTarget !== true ? void 0 : state.splitAttrs.attributes.value;
        return h("div", {
          class: "q-field__native row items-center",
          ...attrs,
          ...state.splitAttrs.listeners.value
        }, child);
      },
      getInnerAppend: () => props4.loading !== true && innerLoadingIndicator.value !== true && props4.hideDropdownIcon !== true ? [
        h(QIcon_default, {
          class: "q-select__dropdown-icon" + (menu2.value === true ? " rotate-180" : ""),
          name: dropdownArrowIcon.value
        })
      ] : null
    });
    return use_field_default(state);
  }
});
var skeletonTypes = [
  "text",
  "rect",
  "circle",
  "QBtn",
  "QBadge",
  "QChip",
  "QToolbar",
  "QCheckbox",
  "QRadio",
  "QToggle",
  "QSlider",
  "QRange",
  "QInput",
  "QAvatar"
];
var skeletonAnimations = [
  "wave",
  "pulse",
  "pulse-x",
  "pulse-y",
  "fade",
  "blink",
  "none"
];
createComponent({
  name: "QSkeleton",
  props: {
    ...useDarkProps,
    tag: {
      type: String,
      default: "div"
    },
    type: {
      type: String,
      validator: (v2) => skeletonTypes.includes(v2),
      default: "rect"
    },
    animation: {
      type: String,
      validator: (v2) => skeletonAnimations.includes(v2),
      default: "wave"
    },
    animationSpeed: {
      type: [String, Number],
      default: 1500
    },
    square: Boolean,
    bordered: Boolean,
    size: String,
    width: String,
    height: String
  },
  setup(props4, { slots }) {
    const vm2 = getCurrentInstance();
    const isDark = use_dark_default(props4, vm2.proxy.$q);
    const style2 = computed(() => {
      const size2 = props4.size !== void 0 ? [props4.size, props4.size] : [props4.width, props4.height];
      return {
        "--q-skeleton-speed": `${props4.animationSpeed}ms`,
        width: size2[0],
        height: size2[1]
      };
    });
    const classes = computed(
      () => `q-skeleton q-skeleton--${isDark.value === true ? "dark" : "light"} q-skeleton--type-${props4.type}` + (props4.animation !== "none" ? ` q-skeleton--anim q-skeleton--anim-${props4.animation}` : "") + (props4.square === true ? " q-skeleton--square" : "") + (props4.bordered === true ? " q-skeleton--bordered" : "")
    );
    return () => h(props4.tag, {
      class: classes.value,
      style: style2.value
    }, hSlot(slots.default));
  }
});
var slotsDef = [
  ["left", "center", "start", "width"],
  ["right", "center", "end", "width"],
  ["top", "start", "center", "height"],
  ["bottom", "end", "center", "height"]
];
createComponent({
  name: "QSlideItem",
  props: {
    ...useDarkProps,
    leftColor: String,
    rightColor: String,
    topColor: String,
    bottomColor: String,
    onSlide: Function
  },
  emits: ["action", "top", "right", "bottom", "left"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = use_dark_default(props4, $q);
    const { getCache } = use_render_cache_default();
    const contentRef = ref(null);
    let timer2 = null, pan = {}, dirRefs = {}, dirContentRefs = {};
    const langDir = computed(() => $q.lang.rtl === true ? { left: "right", right: "left" } : { left: "left", right: "right" });
    const classes = computed(
      () => "q-slide-item q-item-type overflow-hidden" + (isDark.value === true ? " q-slide-item--dark q-dark" : "")
    );
    function reset() {
      contentRef.value.style.transform = "translate(0,0)";
    }
    function emitSlide(side, ratio, isReset) {
      props4.onSlide !== void 0 && emit2("slide", { side, ratio, isReset });
    }
    function onPan(evt) {
      const node = contentRef.value;
      if (evt.isFirst) {
        pan = {
          dir: null,
          size: { left: 0, right: 0, top: 0, bottom: 0 },
          scale: 0
        };
        node.classList.add("no-transition");
        slotsDef.forEach((slotName) => {
          if (slots[slotName[0]] !== void 0) {
            const node2 = dirContentRefs[slotName[0]];
            node2.style.transform = "scale(1)";
            pan.size[slotName[0]] = node2.getBoundingClientRect()[slotName[3]];
          }
        });
        pan.axis = evt.direction === "up" || evt.direction === "down" ? "Y" : "X";
      } else if (evt.isFinal) {
        node.classList.remove("no-transition");
        if (pan.scale === 1) {
          node.style.transform = `translate${pan.axis}(${pan.dir * 100}%)`;
          timer2 !== null && clearTimeout(timer2);
          timer2 = setTimeout(() => {
            timer2 = null;
            emit2(pan.showing, { reset });
            emit2("action", { side: pan.showing, reset });
          }, 230);
        } else {
          node.style.transform = "translate(0,0)";
          emitSlide(pan.showing, 0, true);
        }
        return;
      } else {
        evt.direction = pan.axis === "X" ? evt.offset.x < 0 ? "left" : "right" : evt.offset.y < 0 ? "up" : "down";
      }
      if (slots.left === void 0 && evt.direction === langDir.value.right || slots.right === void 0 && evt.direction === langDir.value.left || slots.top === void 0 && evt.direction === "down" || slots.bottom === void 0 && evt.direction === "up") {
        node.style.transform = "translate(0,0)";
        return;
      }
      let showing, dir, dist2;
      if (pan.axis === "X") {
        dir = evt.direction === "left" ? -1 : 1;
        showing = dir === 1 ? langDir.value.left : langDir.value.right;
        dist2 = evt.distance.x;
      } else {
        dir = evt.direction === "up" ? -2 : 2;
        showing = dir === 2 ? "top" : "bottom";
        dist2 = evt.distance.y;
      }
      if (pan.dir !== null && Math.abs(dir) !== Math.abs(pan.dir)) {
        return;
      }
      if (pan.dir !== dir) {
        ["left", "right", "top", "bottom"].forEach((d) => {
          if (dirRefs[d]) {
            dirRefs[d].style.visibility = showing === d ? "visible" : "hidden";
          }
        });
        pan.showing = showing;
        pan.dir = dir;
      }
      pan.scale = Math.max(0, Math.min(1, (dist2 - 40) / pan.size[showing]));
      node.style.transform = `translate${pan.axis}(${dist2 * dir / Math.abs(dir)}px)`;
      dirContentRefs[showing].style.transform = `scale(${pan.scale})`;
      emitSlide(showing, pan.scale, false);
    }
    onBeforeUpdate(() => {
      dirRefs = {};
      dirContentRefs = {};
    });
    onBeforeUnmount(() => {
      timer2 !== null && clearTimeout(timer2);
    });
    Object.assign(proxy, { reset });
    return () => {
      const content = [], slotsList = {
        left: slots[langDir.value.right] !== void 0,
        right: slots[langDir.value.left] !== void 0,
        up: slots.bottom !== void 0,
        down: slots.top !== void 0
      }, dirs = Object.keys(slotsList).filter((key) => slotsList[key] === true);
      slotsDef.forEach((slotName) => {
        const dir = slotName[0];
        if (slots[dir] !== void 0) {
          content.push(
            h("div", {
              key: dir,
              ref: (el) => {
                dirRefs[dir] = el;
              },
              class: `q-slide-item__${dir} absolute-full row no-wrap items-${slotName[1]} justify-${slotName[2]}` + (props4[dir + "Color"] !== void 0 ? ` bg-${props4[dir + "Color"]}` : "")
            }, [
              h("div", { ref: (el) => {
                dirContentRefs[dir] = el;
              } }, slots[dir]())
            ])
          );
        }
      });
      const node = h("div", {
        key: `${dirs.length === 0 ? "only-" : ""} content`,
        ref: contentRef,
        class: "q-slide-item__content"
      }, hSlot(slots.default));
      if (dirs.length === 0) {
        content.push(node);
      } else {
        content.push(
          withDirectives(node, getCache("dir#" + dirs.join(""), () => {
            const modifiers = {
              prevent: true,
              stop: true,
              mouse: true
            };
            dirs.forEach((dir) => {
              modifiers[dir] = true;
            });
            return [[
              TouchPan_default,
              onPan,
              void 0,
              modifiers
            ]];
          }))
        );
      }
      return h("div", { class: classes.value }, content);
    };
  }
});
createComponent({
  name: "QSpace",
  setup() {
    const space = h("div", { class: "q-space" });
    return () => space;
  }
});
var innerHTML = '<g transform="matrix(1 0 0 -1 0 80)"><rect width="10" height="20" rx="3"><animate attributeName="height" begin="0s" dur="4.3s" values="20;45;57;80;64;32;66;45;64;23;66;13;64;56;34;34;2;23;76;79;20" calcMode="linear" repeatCount="indefinite"></animate></rect><rect x="15" width="10" height="80" rx="3"><animate attributeName="height" begin="0s" dur="2s" values="80;55;33;5;75;23;73;33;12;14;60;80" calcMode="linear" repeatCount="indefinite"></animate></rect><rect x="30" width="10" height="50" rx="3"><animate attributeName="height" begin="0s" dur="1.4s" values="50;34;78;23;56;23;34;76;80;54;21;50" calcMode="linear" repeatCount="indefinite"></animate></rect><rect x="45" width="10" height="30" rx="3"><animate attributeName="height" begin="0s" dur="2s" values="30;45;13;80;56;72;45;76;34;23;67;30" calcMode="linear" repeatCount="indefinite"></animate></rect></g>';
createComponent({
  name: "QSpinnerAudio",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      fill: "currentColor",
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 55 80",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML
    });
  }
});
var innerHTML2 = '<g transform="translate(1 1)" stroke-width="2" fill="none" fill-rule="evenodd"><circle cx="5" cy="50" r="5"><animate attributeName="cy" begin="0s" dur="2.2s" values="50;5;50;50" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="cx" begin="0s" dur="2.2s" values="5;27;49;5" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="27" cy="5" r="5"><animate attributeName="cy" begin="0s" dur="2.2s" from="5" to="5" values="5;50;50;5" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="cx" begin="0s" dur="2.2s" from="27" to="27" values="27;49;5;27" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="49" cy="50" r="5"><animate attributeName="cy" begin="0s" dur="2.2s" values="50;50;5;50" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="cx" from="49" to="49" begin="0s" dur="2.2s" values="49;5;27;49" calcMode="linear" repeatCount="indefinite"></animate></circle></g>';
createComponent({
  name: "QSpinnerBall",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      stroke: "currentColor",
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 57 57",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML2
    });
  }
});
var innerHTML3 = '<rect y="10" width="15" height="120" rx="6"><animate attributeName="height" begin="0.5s" dur="1s" values="120;110;100;90;80;70;60;50;40;140;120" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="y" begin="0.5s" dur="1s" values="10;15;20;25;30;35;40;45;50;0;10" calcMode="linear" repeatCount="indefinite"></animate></rect><rect x="30" y="10" width="15" height="120" rx="6"><animate attributeName="height" begin="0.25s" dur="1s" values="120;110;100;90;80;70;60;50;40;140;120" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="y" begin="0.25s" dur="1s" values="10;15;20;25;30;35;40;45;50;0;10" calcMode="linear" repeatCount="indefinite"></animate></rect><rect x="60" width="15" height="140" rx="6"><animate attributeName="height" begin="0s" dur="1s" values="120;110;100;90;80;70;60;50;40;140;120" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="y" begin="0s" dur="1s" values="10;15;20;25;30;35;40;45;50;0;10" calcMode="linear" repeatCount="indefinite"></animate></rect><rect x="90" y="10" width="15" height="120" rx="6"><animate attributeName="height" begin="0.25s" dur="1s" values="120;110;100;90;80;70;60;50;40;140;120" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="y" begin="0.25s" dur="1s" values="10;15;20;25;30;35;40;45;50;0;10" calcMode="linear" repeatCount="indefinite"></animate></rect><rect x="120" y="10" width="15" height="120" rx="6"><animate attributeName="height" begin="0.5s" dur="1s" values="120;110;100;90;80;70;60;50;40;140;120" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="y" begin="0.5s" dur="1s" values="10;15;20;25;30;35;40;45;50;0;10" calcMode="linear" repeatCount="indefinite"></animate></rect>';
createComponent({
  name: "QSpinnerBars",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      fill: "currentColor",
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 135 140",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML3
    });
  }
});
var innerHTML4 = '<rect x="25" y="25" width="50" height="50" fill="none" stroke-width="4" stroke="currentColor"><animateTransform id="spinnerBox" attributeName="transform" type="rotate" from="0 50 50" to="180 50 50" dur="0.5s" begin="rectBox.end"></animateTransform></rect><rect x="27" y="27" width="46" height="50" fill="currentColor"><animate id="rectBox" attributeName="height" begin="0s;spinnerBox.end" dur="1.3s" from="50" to="0" fill="freeze"></animate></rect>';
createComponent({
  name: "QSpinnerBox",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML4
    });
  }
});
var innerHTML5 = '<circle cx="50" cy="50" r="48" fill="none" stroke-width="4" stroke-miterlimit="10" stroke="currentColor"></circle><line stroke-linecap="round" stroke-width="4" stroke-miterlimit="10" stroke="currentColor" x1="50" y1="50" x2="85" y2="50.5"><animateTransform attributeName="transform" type="rotate" from="0 50 50" to="360 50 50" dur="2s" repeatCount="indefinite"></animateTransform></line><line stroke-linecap="round" stroke-width="4" stroke-miterlimit="10" stroke="currentColor" x1="50" y1="50" x2="49.5" y2="74"><animateTransform attributeName="transform" type="rotate" from="0 50 50" to="360 50 50" dur="15s" repeatCount="indefinite"></animateTransform></line>';
createComponent({
  name: "QSpinnerClock",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML5
    });
  }
});
var innerHTML6 = '<rect x="0" y="0" width="100" height="100" fill="none"></rect><path d="M78,19H22c-6.6,0-12,5.4-12,12v31c0,6.6,5.4,12,12,12h37.2c0.4,3,1.8,5.6,3.7,7.6c2.4,2.5,5.1,4.1,9.1,4 c-1.4-2.1-2-7.2-2-10.3c0-0.4,0-0.8,0-1.3h8c6.6,0,12-5.4,12-12V31C90,24.4,84.6,19,78,19z" fill="currentColor"></path><circle cx="30" cy="47" r="5" fill="#fff"><animate attributeName="opacity" from="0" to="1" values="0;1;1" keyTimes="0;0.2;1" dur="1s" repeatCount="indefinite"></animate></circle><circle cx="50" cy="47" r="5" fill="#fff"><animate attributeName="opacity" from="0" to="1" values="0;0;1;1" keyTimes="0;0.2;0.4;1" dur="1s" repeatCount="indefinite"></animate></circle><circle cx="70" cy="47" r="5" fill="#fff"><animate attributeName="opacity" from="0" to="1" values="0;0;1;1" keyTimes="0;0.4;0.6;1" dur="1s" repeatCount="indefinite"></animate></circle>';
createComponent({
  name: "QSpinnerComment",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      innerHTML: innerHTML6
    });
  }
});
var innerHTML7 = '<rect x="0" y="0" width="100" height="100" fill="none"></rect><g transform="translate(25 25)"><rect x="-20" y="-20" width="40" height="40" fill="currentColor" opacity="0.9"><animateTransform attributeName="transform" type="scale" from="1.5" to="1" repeatCount="indefinite" begin="0s" dur="1s" calcMode="spline" keySplines="0.2 0.8 0.2 0.8" keyTimes="0;1"></animateTransform></rect></g><g transform="translate(75 25)"><rect x="-20" y="-20" width="40" height="40" fill="currentColor" opacity="0.8"><animateTransform attributeName="transform" type="scale" from="1.5" to="1" repeatCount="indefinite" begin="0.1s" dur="1s" calcMode="spline" keySplines="0.2 0.8 0.2 0.8" keyTimes="0;1"></animateTransform></rect></g><g transform="translate(25 75)"><rect x="-20" y="-20" width="40" height="40" fill="currentColor" opacity="0.7"><animateTransform attributeName="transform" type="scale" from="1.5" to="1" repeatCount="indefinite" begin="0.3s" dur="1s" calcMode="spline" keySplines="0.2 0.8 0.2 0.8" keyTimes="0;1"></animateTransform></rect></g><g transform="translate(75 75)"><rect x="-20" y="-20" width="40" height="40" fill="currentColor" opacity="0.6"><animateTransform attributeName="transform" type="scale" from="1.5" to="1" repeatCount="indefinite" begin="0.2s" dur="1s" calcMode="spline" keySplines="0.2 0.8 0.2 0.8" keyTimes="0;1"></animateTransform></rect></g>';
createComponent({
  name: "QSpinnerCube",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      innerHTML: innerHTML7
    });
  }
});
var innerHTML8 = '<circle cx="15" cy="15" r="15"><animate attributeName="r" from="15" to="15" begin="0s" dur="0.8s" values="15;9;15" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="fill-opacity" from="1" to="1" begin="0s" dur="0.8s" values="1;.5;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="60" cy="15" r="9" fill-opacity=".3"><animate attributeName="r" from="9" to="9" begin="0s" dur="0.8s" values="9;15;9" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="fill-opacity" from=".5" to=".5" begin="0s" dur="0.8s" values=".5;1;.5" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="105" cy="15" r="15"><animate attributeName="r" from="15" to="15" begin="0s" dur="0.8s" values="15;9;15" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="fill-opacity" from="1" to="1" begin="0s" dur="0.8s" values="1;.5;1" calcMode="linear" repeatCount="indefinite"></animate></circle>';
createComponent({
  name: "QSpinnerDots",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      fill: "currentColor",
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 120 30",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML8
    });
  }
});
var innerHTML9 = '<g transform="translate(20 50)"><rect x="-10" y="-30" width="20" height="60" fill="currentColor" opacity="0.6"><animateTransform attributeName="transform" type="scale" from="2" to="1" begin="0s" repeatCount="indefinite" dur="1s" calcMode="spline" keySplines="0.1 0.9 0.4 1" keyTimes="0;1" values="2;1"></animateTransform></rect></g><g transform="translate(50 50)"><rect x="-10" y="-30" width="20" height="60" fill="currentColor" opacity="0.8"><animateTransform attributeName="transform" type="scale" from="2" to="1" begin="0.1s" repeatCount="indefinite" dur="1s" calcMode="spline" keySplines="0.1 0.9 0.4 1" keyTimes="0;1" values="2;1"></animateTransform></rect></g><g transform="translate(80 50)"><rect x="-10" y="-30" width="20" height="60" fill="currentColor" opacity="0.9"><animateTransform attributeName="transform" type="scale" from="2" to="1" begin="0.2s" repeatCount="indefinite" dur="1s" calcMode="spline" keySplines="0.1 0.9 0.4 1" keyTimes="0;1" values="2;1"></animateTransform></rect></g>';
createComponent({
  name: "QSpinnerFacebook",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 100 100",
      xmlns: "http://www.w3.org/2000/svg",
      preserveAspectRatio: "xMidYMid",
      innerHTML: innerHTML9
    });
  }
});
var innerHTML10 = '<g transform="translate(-20,-20)"><path d="M79.9,52.6C80,51.8,80,50.9,80,50s0-1.8-0.1-2.6l-5.1-0.4c-0.3-2.4-0.9-4.6-1.8-6.7l4.2-2.9c-0.7-1.6-1.6-3.1-2.6-4.5 L70,35c-1.4-1.9-3.1-3.5-4.9-4.9l2.2-4.6c-1.4-1-2.9-1.9-4.5-2.6L59.8,27c-2.1-0.9-4.4-1.5-6.7-1.8l-0.4-5.1C51.8,20,50.9,20,50,20 s-1.8,0-2.6,0.1l-0.4,5.1c-2.4,0.3-4.6,0.9-6.7,1.8l-2.9-4.1c-1.6,0.7-3.1,1.6-4.5,2.6l2.1,4.6c-1.9,1.4-3.5,3.1-5,4.9l-4.5-2.1 c-1,1.4-1.9,2.9-2.6,4.5l4.1,2.9c-0.9,2.1-1.5,4.4-1.8,6.8l-5,0.4C20,48.2,20,49.1,20,50s0,1.8,0.1,2.6l5,0.4 c0.3,2.4,0.9,4.7,1.8,6.8l-4.1,2.9c0.7,1.6,1.6,3.1,2.6,4.5l4.5-2.1c1.4,1.9,3.1,3.5,5,4.9l-2.1,4.6c1.4,1,2.9,1.9,4.5,2.6l2.9-4.1 c2.1,0.9,4.4,1.5,6.7,1.8l0.4,5.1C48.2,80,49.1,80,50,80s1.8,0,2.6-0.1l0.4-5.1c2.3-0.3,4.6-0.9,6.7-1.8l2.9,4.2 c1.6-0.7,3.1-1.6,4.5-2.6L65,69.9c1.9-1.4,3.5-3,4.9-4.9l4.6,2.2c1-1.4,1.9-2.9,2.6-4.5L73,59.8c0.9-2.1,1.5-4.4,1.8-6.7L79.9,52.6 z M50,65c-8.3,0-15-6.7-15-15c0-8.3,6.7-15,15-15s15,6.7,15,15C65,58.3,58.3,65,50,65z" fill="currentColor"><animateTransform attributeName="transform" type="rotate" from="90 50 50" to="0 50 50" dur="1s" repeatCount="indefinite"></animateTransform></path></g><g transform="translate(20,20) rotate(15 50 50)"><path d="M79.9,52.6C80,51.8,80,50.9,80,50s0-1.8-0.1-2.6l-5.1-0.4c-0.3-2.4-0.9-4.6-1.8-6.7l4.2-2.9c-0.7-1.6-1.6-3.1-2.6-4.5 L70,35c-1.4-1.9-3.1-3.5-4.9-4.9l2.2-4.6c-1.4-1-2.9-1.9-4.5-2.6L59.8,27c-2.1-0.9-4.4-1.5-6.7-1.8l-0.4-5.1C51.8,20,50.9,20,50,20 s-1.8,0-2.6,0.1l-0.4,5.1c-2.4,0.3-4.6,0.9-6.7,1.8l-2.9-4.1c-1.6,0.7-3.1,1.6-4.5,2.6l2.1,4.6c-1.9,1.4-3.5,3.1-5,4.9l-4.5-2.1 c-1,1.4-1.9,2.9-2.6,4.5l4.1,2.9c-0.9,2.1-1.5,4.4-1.8,6.8l-5,0.4C20,48.2,20,49.1,20,50s0,1.8,0.1,2.6l5,0.4 c0.3,2.4,0.9,4.7,1.8,6.8l-4.1,2.9c0.7,1.6,1.6,3.1,2.6,4.5l4.5-2.1c1.4,1.9,3.1,3.5,5,4.9l-2.1,4.6c1.4,1,2.9,1.9,4.5,2.6l2.9-4.1 c2.1,0.9,4.4,1.5,6.7,1.8l0.4,5.1C48.2,80,49.1,80,50,80s1.8,0,2.6-0.1l0.4-5.1c2.3-0.3,4.6-0.9,6.7-1.8l2.9,4.2 c1.6-0.7,3.1-1.6,4.5-2.6L65,69.9c1.9-1.4,3.5-3,4.9-4.9l4.6,2.2c1-1.4,1.9-2.9,2.6-4.5L73,59.8c0.9-2.1,1.5-4.4,1.8-6.7L79.9,52.6 z M50,65c-8.3,0-15-6.7-15-15c0-8.3,6.7-15,15-15s15,6.7,15,15C65,58.3,58.3,65,50,65z" fill="currentColor"><animateTransform attributeName="transform" type="rotate" from="0 50 50" to="90 50 50" dur="1s" repeatCount="indefinite"></animateTransform></path></g>';
createComponent({
  name: "QSpinnerGears",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML10
    });
  }
});
var innerHTML11 = '<circle cx="12.5" cy="12.5" r="12.5"><animate attributeName="fill-opacity" begin="0s" dur="1s" values="1;.2;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="12.5" cy="52.5" r="12.5" fill-opacity=".5"><animate attributeName="fill-opacity" begin="100ms" dur="1s" values="1;.2;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="52.5" cy="12.5" r="12.5"><animate attributeName="fill-opacity" begin="300ms" dur="1s" values="1;.2;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="52.5" cy="52.5" r="12.5"><animate attributeName="fill-opacity" begin="600ms" dur="1s" values="1;.2;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="92.5" cy="12.5" r="12.5"><animate attributeName="fill-opacity" begin="800ms" dur="1s" values="1;.2;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="92.5" cy="52.5" r="12.5"><animate attributeName="fill-opacity" begin="400ms" dur="1s" values="1;.2;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="12.5" cy="92.5" r="12.5"><animate attributeName="fill-opacity" begin="700ms" dur="1s" values="1;.2;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="52.5" cy="92.5" r="12.5"><animate attributeName="fill-opacity" begin="500ms" dur="1s" values="1;.2;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="92.5" cy="92.5" r="12.5"><animate attributeName="fill-opacity" begin="200ms" dur="1s" values="1;.2;1" calcMode="linear" repeatCount="indefinite"></animate></circle>';
createComponent({
  name: "QSpinnerGrid",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      fill: "currentColor",
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 105 105",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML11
    });
  }
});
var innerHTML12 = '<path d="M30.262 57.02L7.195 40.723c-5.84-3.976-7.56-12.06-3.842-18.063 3.715-6 11.467-7.65 17.306-3.68l4.52 3.76 2.6-5.274c3.716-6.002 11.47-7.65 17.304-3.68 5.84 3.97 7.56 12.054 3.842 18.062L34.49 56.118c-.897 1.512-2.793 1.915-4.228.9z" fill-opacity=".5"><animate attributeName="fill-opacity" begin="0s" dur="1.4s" values="0.5;1;0.5" calcMode="linear" repeatCount="indefinite"></animate></path><path d="M105.512 56.12l-14.44-24.272c-3.716-6.008-1.996-14.093 3.843-18.062 5.835-3.97 13.588-2.322 17.306 3.68l2.6 5.274 4.52-3.76c5.84-3.97 13.593-2.32 17.308 3.68 3.718 6.003 1.998 14.088-3.842 18.064L109.74 57.02c-1.434 1.014-3.33.61-4.228-.9z" fill-opacity=".5"><animate attributeName="fill-opacity" begin="0.7s" dur="1.4s" values="0.5;1;0.5" calcMode="linear" repeatCount="indefinite"></animate></path><path d="M67.408 57.834l-23.01-24.98c-5.864-6.15-5.864-16.108 0-22.248 5.86-6.14 15.37-6.14 21.234 0L70 16.168l4.368-5.562c5.863-6.14 15.375-6.14 21.235 0 5.863 6.14 5.863 16.098 0 22.247l-23.007 24.98c-1.43 1.556-3.757 1.556-5.188 0z"></path>';
createComponent({
  name: "QSpinnerHearts",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      fill: "currentColor",
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 140 64",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML12
    });
  }
});
var innerHTML13 = '<g><path fill="none" stroke="currentColor" stroke-width="5" stroke-miterlimit="10" d="M58.4,51.7c-0.9-0.9-1.4-2-1.4-2.3s0.5-0.4,1.4-1.4 C70.8,43.8,79.8,30.5,80,15.5H70H30H20c0.2,15,9.2,28.1,21.6,32.3c0.9,0.9,1.4,1.2,1.4,1.5s-0.5,1.6-1.4,2.5 C29.2,56.1,20.2,69.5,20,85.5h10h40h10C79.8,69.5,70.8,55.9,58.4,51.7z"></path><clipPath id="uil-hourglass-clip1"><rect x="15" y="20" width="70" height="25"><animate attributeName="height" from="25" to="0" dur="1s" repeatCount="indefinite" values="25;0;0" keyTimes="0;0.5;1"></animate><animate attributeName="y" from="20" to="45" dur="1s" repeatCount="indefinite" values="20;45;45" keyTimes="0;0.5;1"></animate></rect></clipPath><clipPath id="uil-hourglass-clip2"><rect x="15" y="55" width="70" height="25"><animate attributeName="height" from="0" to="25" dur="1s" repeatCount="indefinite" values="0;25;25" keyTimes="0;0.5;1"></animate><animate attributeName="y" from="80" to="55" dur="1s" repeatCount="indefinite" values="80;55;55" keyTimes="0;0.5;1"></animate></rect></clipPath><path d="M29,23c3.1,11.4,11.3,19.5,21,19.5S67.9,34.4,71,23H29z" clip-path="url(#uil-hourglass-clip1)" fill="currentColor"></path><path d="M71.6,78c-3-11.6-11.5-20-21.5-20s-18.5,8.4-21.5,20H71.6z" clip-path="url(#uil-hourglass-clip2)" fill="currentColor"></path><animateTransform attributeName="transform" type="rotate" from="0 50 50" to="180 50 50" repeatCount="indefinite" dur="1s" values="0 50 50;0 50 50;180 50 50" keyTimes="0;0.7;1"></animateTransform></g>';
createComponent({
  name: "QSpinnerHourglass",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML13
    });
  }
});
var innerHTML14 = '<path d="M24.3,30C11.4,30,5,43.3,5,50s6.4,20,19.3,20c19.3,0,32.1-40,51.4-40C88.6,30,95,43.3,95,50s-6.4,20-19.3,20C56.4,70,43.6,30,24.3,30z" fill="none" stroke="currentColor" stroke-width="8" stroke-dasharray="10.691205342610678 10.691205342610678" stroke-dashoffset="0"><animate attributeName="stroke-dashoffset" from="0" to="21.382410685221355" begin="0" dur="2s" repeatCount="indefinite" fill="freeze"></animate></path>';
createComponent({
  name: "QSpinnerInfinity",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      innerHTML: innerHTML14
    });
  }
});
var innerHTML15 = '<g stroke-width="4" stroke-linecap="round"><line y1="17" y2="29" transform="translate(32,32) rotate(180)"><animate attributeName="stroke-opacity" dur="750ms" values="1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(210)"><animate attributeName="stroke-opacity" dur="750ms" values="0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(240)"><animate attributeName="stroke-opacity" dur="750ms" values=".1;0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(270)"><animate attributeName="stroke-opacity" dur="750ms" values=".15;.1;0;1;.85;.7;.65;.55;.45;.35;.25;.15" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(300)"><animate attributeName="stroke-opacity" dur="750ms" values=".25;.15;.1;0;1;.85;.7;.65;.55;.45;.35;.25" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(330)"><animate attributeName="stroke-opacity" dur="750ms" values=".35;.25;.15;.1;0;1;.85;.7;.65;.55;.45;.35" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(0)"><animate attributeName="stroke-opacity" dur="750ms" values=".45;.35;.25;.15;.1;0;1;.85;.7;.65;.55;.45" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(30)"><animate attributeName="stroke-opacity" dur="750ms" values=".55;.45;.35;.25;.15;.1;0;1;.85;.7;.65;.55" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(60)"><animate attributeName="stroke-opacity" dur="750ms" values=".65;.55;.45;.35;.25;.15;.1;0;1;.85;.7;.65" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(90)"><animate attributeName="stroke-opacity" dur="750ms" values=".7;.65;.55;.45;.35;.25;.15;.1;0;1;.85;.7" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(120)"><animate attributeName="stroke-opacity" dur="750ms" values=".85;.7;.65;.55;.45;.35;.25;.15;.1;0;1;.85" repeatCount="indefinite"></animate></line><line y1="17" y2="29" transform="translate(32,32) rotate(150)"><animate attributeName="stroke-opacity" dur="750ms" values="1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1" repeatCount="indefinite"></animate></line></g>';
createComponent({
  name: "QSpinnerIos",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      stroke: "currentColor",
      fill: "currentColor",
      viewBox: "0 0 64 64",
      innerHTML: innerHTML15
    });
  }
});
var innerHTML16 = '<circle cx="50" cy="50" r="44" fill="none" stroke-width="4" stroke-opacity=".5" stroke="currentColor"></circle><circle cx="8" cy="54" r="6" fill="currentColor" stroke-width="3" stroke="currentColor"><animateTransform attributeName="transform" type="rotate" from="0 50 48" to="360 50 52" dur="2s" repeatCount="indefinite"></animateTransform></circle>';
createComponent({
  name: "QSpinnerOrbit",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML16
    });
  }
});
var innerHTML17 = '<g transform="translate(1 1)" stroke-width="2" fill="none" fill-rule="evenodd"><circle stroke-opacity=".5" cx="18" cy="18" r="18"></circle><path d="M36 18c0-9.94-8.06-18-18-18"><animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="1s" repeatCount="indefinite"></animateTransform></path></g>';
createComponent({
  name: "QSpinnerOval",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      stroke: "currentColor",
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 38 38",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML17
    });
  }
});
var innerHTML18 = '<path d="M0 50A50 50 0 0 1 50 0L50 50L0 50" fill="currentColor" opacity="0.5"><animateTransform attributeName="transform" type="rotate" from="0 50 50" to="360 50 50" dur="0.8s" repeatCount="indefinite"></animateTransform></path><path d="M50 0A50 50 0 0 1 100 50L50 50L50 0" fill="currentColor" opacity="0.5"><animateTransform attributeName="transform" type="rotate" from="0 50 50" to="360 50 50" dur="1.6s" repeatCount="indefinite"></animateTransform></path><path d="M100 50A50 50 0 0 1 50 100L50 50L100 50" fill="currentColor" opacity="0.5"><animateTransform attributeName="transform" type="rotate" from="0 50 50" to="360 50 50" dur="2.4s" repeatCount="indefinite"></animateTransform></path><path d="M50 100A50 50 0 0 1 0 50L50 50L50 100" fill="currentColor" opacity="0.5"><animateTransform attributeName="transform" type="rotate" from="0 50 50" to="360 50 50" dur="3.2s" repeatCount="indefinite"></animateTransform></path>';
createComponent({
  name: "QSpinnerPie",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML18
    });
  }
});
var innerHTML19 = '<g fill="none" fill-rule="evenodd" stroke-width="2"><circle cx="22" cy="22" r="1"><animate attributeName="r" begin="0s" dur="1.8s" values="1; 20" calcMode="spline" keyTimes="0; 1" keySplines="0.165, 0.84, 0.44, 1" repeatCount="indefinite"></animate><animate attributeName="stroke-opacity" begin="0s" dur="1.8s" values="1; 0" calcMode="spline" keyTimes="0; 1" keySplines="0.3, 0.61, 0.355, 1" repeatCount="indefinite"></animate></circle><circle cx="22" cy="22" r="1"><animate attributeName="r" begin="-0.9s" dur="1.8s" values="1; 20" calcMode="spline" keyTimes="0; 1" keySplines="0.165, 0.84, 0.44, 1" repeatCount="indefinite"></animate><animate attributeName="stroke-opacity" begin="-0.9s" dur="1.8s" values="1; 0" calcMode="spline" keyTimes="0; 1" keySplines="0.3, 0.61, 0.355, 1" repeatCount="indefinite"></animate></circle></g>';
createComponent({
  name: "QSpinnerPuff",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      stroke: "currentColor",
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 44 44",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML19
    });
  }
});
var innerHTML20 = '<g transform="scale(0.55)"><circle cx="30" cy="150" r="30" fill="currentColor"><animate attributeName="opacity" from="0" to="1" dur="1s" begin="0" repeatCount="indefinite" keyTimes="0;0.5;1" values="0;1;1"></animate></circle><path d="M90,150h30c0-49.7-40.3-90-90-90v30C63.1,90,90,116.9,90,150z" fill="currentColor"><animate attributeName="opacity" from="0" to="1" dur="1s" begin="0.1" repeatCount="indefinite" keyTimes="0;0.5;1" values="0;1;1"></animate></path><path d="M150,150h30C180,67.2,112.8,0,30,0v30C96.3,30,150,83.7,150,150z" fill="currentColor"><animate attributeName="opacity" from="0" to="1" dur="1s" begin="0.2" repeatCount="indefinite" keyTimes="0;0.5;1" values="0;1;1"></animate></path></g>';
createComponent({
  name: "QSpinnerRadio",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML20
    });
  }
});
var innerHTML21 = '<g fill="none" fill-rule="evenodd" transform="translate(1 1)" stroke-width="2"><circle cx="22" cy="22" r="6"><animate attributeName="r" begin="1.5s" dur="3s" values="6;22" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="stroke-opacity" begin="1.5s" dur="3s" values="1;0" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="stroke-width" begin="1.5s" dur="3s" values="2;0" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="22" cy="22" r="6"><animate attributeName="r" begin="3s" dur="3s" values="6;22" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="stroke-opacity" begin="3s" dur="3s" values="1;0" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="stroke-width" begin="3s" dur="3s" values="2;0" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="22" cy="22" r="8"><animate attributeName="r" begin="0s" dur="1.5s" values="6;1;2;3;4;5;6" calcMode="linear" repeatCount="indefinite"></animate></circle></g>';
createComponent({
  name: "QSpinnerRings",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      stroke: "currentColor",
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 45 45",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML21
    });
  }
});
var innerHTML22 = '<defs><linearGradient x1="8.042%" y1="0%" x2="65.682%" y2="23.865%" id="a"><stop stop-color="currentColor" stop-opacity="0" offset="0%"></stop><stop stop-color="currentColor" stop-opacity=".631" offset="63.146%"></stop><stop stop-color="currentColor" offset="100%"></stop></linearGradient></defs><g transform="translate(1 1)" fill="none" fill-rule="evenodd"><path d="M36 18c0-9.94-8.06-18-18-18" stroke="url(#a)" stroke-width="2"><animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="0.9s" repeatCount="indefinite"></animateTransform></path><circle fill="currentColor" cx="36" cy="18" r="1"><animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="0.9s" repeatCount="indefinite"></animateTransform></circle></g>';
createComponent({
  name: "QSpinnerTail",
  props: useSpinnerProps,
  setup(props4) {
    const { cSize, classes } = useSpinner(props4);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 38 38",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: innerHTML22
    });
  }
});
createComponent({
  name: "QSplitter",
  props: {
    ...useDarkProps,
    modelValue: {
      type: Number,
      required: true
    },
    reverse: Boolean,
    unit: {
      type: String,
      default: "%",
      validator: (v2) => ["%", "px"].includes(v2)
    },
    limits: {
      type: Array,
      validator: (v2) => {
        if (v2.length !== 2) return false;
        if (typeof v2[0] !== "number" || typeof v2[1] !== "number") return false;
        return v2[0] >= 0 && v2[0] <= v2[1];
      }
    },
    emitImmediately: Boolean,
    horizontal: Boolean,
    disable: Boolean,
    beforeClass: [Array, String, Object],
    afterClass: [Array, String, Object],
    separatorClass: [Array, String, Object],
    separatorStyle: [Array, String, Object]
  },
  emits: ["update:modelValue"],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = use_dark_default(props4, $q);
    const rootRef = ref(null);
    const sideRefs = {
      before: ref(null),
      after: ref(null)
    };
    const classes = computed(
      () => `q-splitter no-wrap ${props4.horizontal === true ? "q-splitter--horizontal column" : "q-splitter--vertical row"} q-splitter--${props4.disable === true ? "disabled" : "workable"}` + (isDark.value === true ? " q-splitter--dark" : "")
    );
    const propName = computed(() => props4.horizontal === true ? "height" : "width");
    const side = computed(() => props4.reverse !== true ? "before" : "after");
    const computedLimits = computed(() => props4.limits !== void 0 ? props4.limits : props4.unit === "%" ? [10, 90] : [50, Infinity]);
    function getCSSValue(value2) {
      return (props4.unit === "%" ? value2 : Math.round(value2)) + props4.unit;
    }
    const styles = computed(() => ({
      [side.value]: {
        [propName.value]: getCSSValue(props4.modelValue)
      }
    }));
    let __dir, __maxValue, __value, __multiplier, __normalized;
    function pan(evt) {
      if (evt.isFirst === true) {
        const size2 = rootRef.value.getBoundingClientRect()[propName.value];
        __dir = props4.horizontal === true ? "up" : "left";
        __maxValue = props4.unit === "%" ? 100 : size2;
        __value = Math.min(__maxValue, computedLimits.value[1], Math.max(computedLimits.value[0], props4.modelValue));
        __multiplier = (props4.reverse !== true ? 1 : -1) * (props4.horizontal === true ? 1 : $q.lang.rtl === true ? -1 : 1) * (props4.unit === "%" ? size2 === 0 ? 0 : 100 / size2 : 1);
        rootRef.value.classList.add("q-splitter--active");
        return;
      }
      if (evt.isFinal === true) {
        if (__normalized !== props4.modelValue) {
          emit2("update:modelValue", __normalized);
        }
        rootRef.value.classList.remove("q-splitter--active");
        return;
      }
      const val = __value + __multiplier * (evt.direction === __dir ? -1 : 1) * evt.distance[props4.horizontal === true ? "y" : "x"];
      __normalized = Math.min(__maxValue, computedLimits.value[1], Math.max(computedLimits.value[0], val));
      sideRefs[side.value].value.style[propName.value] = getCSSValue(__normalized);
      if (props4.emitImmediately === true && props4.modelValue !== __normalized) {
        emit2("update:modelValue", __normalized);
      }
    }
    const sepDirective = computed(() => {
      return [[
        TouchPan_default,
        pan,
        void 0,
        {
          [props4.horizontal === true ? "vertical" : "horizontal"]: true,
          prevent: true,
          stop: true,
          mouse: true,
          mouseAllDir: true
        }
      ]];
    });
    function normalize2(val, limits) {
      if (val < limits[0]) {
        emit2("update:modelValue", limits[0]);
      } else if (val > limits[1]) {
        emit2("update:modelValue", limits[1]);
      }
    }
    watch(() => props4.modelValue, (v2) => {
      normalize2(v2, computedLimits.value);
    });
    watch(() => props4.limits, () => {
      nextTick(() => {
        normalize2(props4.modelValue, computedLimits.value);
      });
    });
    return () => {
      const child = [
        h("div", {
          ref: sideRefs.before,
          class: [
            "q-splitter__panel q-splitter__before" + (props4.reverse === true ? " col" : ""),
            props4.beforeClass
          ],
          style: styles.value.before
        }, hSlot(slots.before)),
        h("div", {
          class: [
            "q-splitter__separator",
            props4.separatorClass
          ],
          style: props4.separatorStyle,
          "aria-disabled": props4.disable === true ? "true" : void 0
        }, [
          hDir(
            "div",
            { class: "q-splitter__separator-area absolute-full" },
            hSlot(slots.separator),
            "sep",
            props4.disable !== true,
            () => sepDirective.value
          )
        ]),
        h("div", {
          ref: sideRefs.after,
          class: [
            "q-splitter__panel q-splitter__after" + (props4.reverse === true ? "" : " col"),
            props4.afterClass
          ],
          style: styles.value.after
        }, hSlot(slots.after))
      ];
      return h("div", {
        class: classes.value,
        ref: rootRef
      }, hMergeSlot(slots.default, child));
    };
  }
});
var StepHeader_default = createComponent({
  name: "StepHeader",
  props: {
    stepper: {},
    step: {},
    goToPanel: Function
  },
  setup(props4, { attrs }) {
    const { proxy: { $q } } = getCurrentInstance();
    const blurRef = ref(null);
    const isActive = computed(() => props4.stepper.modelValue === props4.step.name);
    const isDisable = computed(() => {
      const opt = props4.step.disable;
      return opt === true || opt === "";
    });
    const isError = computed(() => {
      const opt = props4.step.error;
      return opt === true || opt === "";
    });
    const isDone = computed(() => {
      const opt = props4.step.done;
      return isDisable.value === false && (opt === true || opt === "");
    });
    const headerNav = computed(() => {
      const opt = props4.step.headerNav, nav = opt === true || opt === "" || opt === void 0;
      return isDisable.value === false && props4.stepper.headerNav && nav;
    });
    const hasPrefix = computed(() => {
      return props4.step.prefix && (isActive.value === false || props4.stepper.activeIcon === "none") && (isError.value === false || props4.stepper.errorIcon === "none") && (isDone.value === false || props4.stepper.doneIcon === "none");
    });
    const icon2 = computed(() => {
      const defaultIcon = props4.step.icon || props4.stepper.inactiveIcon;
      if (isActive.value === true) {
        const icon22 = props4.step.activeIcon || props4.stepper.activeIcon;
        return icon22 === "none" ? defaultIcon : icon22 || $q.iconSet.stepper.active;
      }
      if (isError.value === true) {
        const icon22 = props4.step.errorIcon || props4.stepper.errorIcon;
        return icon22 === "none" ? defaultIcon : icon22 || $q.iconSet.stepper.error;
      }
      if (isDisable.value === false && isDone.value === true) {
        const icon22 = props4.step.doneIcon || props4.stepper.doneIcon;
        return icon22 === "none" ? defaultIcon : icon22 || $q.iconSet.stepper.done;
      }
      return defaultIcon;
    });
    const color = computed(() => {
      const errorColor = isError.value === true ? props4.step.errorColor || props4.stepper.errorColor : void 0;
      if (isActive.value === true) {
        const color2 = props4.step.activeColor || props4.stepper.activeColor || props4.step.color;
        return color2 !== void 0 ? color2 : errorColor;
      }
      if (errorColor !== void 0) {
        return errorColor;
      }
      if (isDisable.value === false && isDone.value === true) {
        return props4.step.doneColor || props4.stepper.doneColor || props4.step.color || props4.stepper.inactiveColor;
      }
      return props4.step.color || props4.stepper.inactiveColor;
    });
    const classes = computed(() => {
      return "q-stepper__tab col-grow flex items-center no-wrap relative-position" + (color.value !== void 0 ? ` text-${color.value}` : "") + (isError.value === true ? " q-stepper__tab--error q-stepper__tab--error-with-" + (hasPrefix.value === true ? "prefix" : "icon") : "") + (isActive.value === true ? " q-stepper__tab--active" : "") + (isDone.value === true ? " q-stepper__tab--done" : "") + (headerNav.value === true ? " q-stepper__tab--navigation q-focusable q-hoverable" : "") + (isDisable.value === true ? " q-stepper__tab--disabled" : "");
    });
    const ripple = computed(() => props4.stepper.headerNav !== true ? false : headerNav.value);
    function onActivate() {
      blurRef.value !== null && blurRef.value.focus();
      isActive.value === false && props4.goToPanel(props4.step.name);
    }
    function onKeyup2(e) {
      if (e.keyCode === 13 && isActive.value === false) {
        props4.goToPanel(props4.step.name);
      }
    }
    return () => {
      const data = { class: classes.value };
      if (headerNav.value === true) {
        data.onClick = onActivate;
        data.onKeyup = onKeyup2;
        Object.assign(
          data,
          isDisable.value === true ? { tabindex: -1, "aria-disabled": "true" } : { tabindex: attrs.tabindex || 0 }
        );
      }
      const child = [
        h("div", { class: "q-focus-helper", tabindex: -1, ref: blurRef }),
        h("div", { class: "q-stepper__dot row flex-center q-stepper__line relative-position" }, [
          h("span", { class: "row flex-center" }, [
            hasPrefix.value === true ? props4.step.prefix : h(QIcon_default, { name: icon2.value })
          ])
        ])
      ];
      if (props4.step.title !== void 0 && props4.step.title !== null) {
        const content = [
          h("div", { class: "q-stepper__title" }, props4.step.title)
        ];
        if (props4.step.caption !== void 0 && props4.step.caption !== null) {
          content.push(
            h("div", { class: "q-stepper__caption" }, props4.step.caption)
          );
        }
        child.push(
          h("div", {
            class: "q-stepper__label q-stepper__line relative-position"
          }, content)
        );
      }
      return withDirectives(
        h("div", data, child),
        [[Ripple_default, ripple.value]]
      );
    };
  }
});
function getStepWrapper(slots) {
  return h("div", {
    class: "q-stepper__step-content"
  }, [
    h("div", {
      class: "q-stepper__step-inner"
    }, hSlot(slots.default))
  ]);
}
var PanelWrapper2 = {
  setup(_, { slots }) {
    return () => getStepWrapper(slots);
  }
};
createComponent({
  name: "QStep",
  props: {
    ...usePanelChildProps,
    icon: String,
    color: String,
    title: {
      type: String,
      required: true
    },
    caption: String,
    prefix: [String, Number],
    doneIcon: String,
    doneColor: String,
    activeIcon: String,
    activeColor: String,
    errorIcon: String,
    errorColor: String,
    headerNav: {
      type: Boolean,
      default: true
    },
    done: Boolean,
    error: Boolean,
    onScroll: [Function, Array]
  },
  setup(props4, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const $stepper = inject(stepperKey, emptyRenderFn);
    if ($stepper === emptyRenderFn) {
      console.error("QStep needs to be a child of QStepper");
      return emptyRenderFn;
    }
    const { getCache } = use_render_cache_default();
    const rootRef = ref(null);
    const isActive = computed(() => $stepper.value.modelValue === props4.name);
    const scrollEvent = computed(() => $q.platform.is.ios !== true && $q.platform.is.chrome === true || isActive.value !== true || $stepper.value.vertical !== true ? {} : {
      onScroll(e) {
        const { target: target2 } = e;
        if (target2.scrollTop > 0) {
          target2.scrollTop = 0;
        }
        props4.onScroll !== void 0 && emit2("scroll", e);
      }
    });
    const contentKey = computed(() => typeof props4.name === "string" || typeof props4.name === "number" ? props4.name : String(props4.name));
    function getStepContent() {
      const vertical = $stepper.value.vertical;
      if (vertical === true && $stepper.value.keepAlive === true) {
        return h(
          KeepAlive,
          $stepper.value.keepAliveProps.value,
          isActive.value === true ? [
            h(
              $stepper.value.needsUniqueKeepAliveWrapper.value === true ? getCache(contentKey.value, () => ({ ...PanelWrapper2, name: contentKey.value })) : PanelWrapper2,
              { key: contentKey.value },
              slots.default
            )
          ] : void 0
        );
      }
      return vertical !== true || isActive.value === true ? getStepWrapper(slots) : void 0;
    }
    return () => h(
      "div",
      { ref: rootRef, class: "q-stepper__step", role: "tabpanel", ...scrollEvent.value },
      $stepper.value.vertical === true ? [
        h(StepHeader_default, {
          stepper: $stepper.value,
          step: props4,
          goToPanel: $stepper.value.goToPanel
        }),
        $stepper.value.animated === true ? h(QSlideTransition_default, getStepContent) : getStepContent()
      ] : [getStepContent()]
    );
  }
});
var camelRE = /(-\w)/g;
function camelizeProps(props4) {
  const acc = {};
  for (const key in props4) {
    const newKey = key.replace(camelRE, (m2) => m2[1].toUpperCase());
    acc[newKey] = props4[key];
  }
  return acc;
}
createComponent({
  name: "QStepper",
  props: {
    ...useDarkProps,
    ...usePanelProps,
    flat: Boolean,
    bordered: Boolean,
    alternativeLabels: Boolean,
    headerNav: Boolean,
    contracted: Boolean,
    headerClass: String,
    inactiveColor: String,
    inactiveIcon: String,
    doneIcon: String,
    doneColor: String,
    activeIcon: String,
    activeColor: String,
    errorIcon: String,
    errorColor: String
  },
  emits: usePanelEmits,
  setup(props4, { slots }) {
    const vm2 = getCurrentInstance();
    const isDark = use_dark_default(props4, vm2.proxy.$q);
    const {
      updatePanelsList,
      isValidPanelName,
      updatePanelIndex,
      getPanelContent,
      getPanels,
      panelDirectives,
      goToPanel,
      keepAliveProps,
      needsUniqueKeepAliveWrapper
    } = use_panel_default();
    provide(stepperKey, computed(() => ({
      goToPanel,
      keepAliveProps,
      needsUniqueKeepAliveWrapper,
      ...props4
    })));
    const classes = computed(
      () => `q-stepper q-stepper--${props4.vertical === true ? "vertical" : "horizontal"}` + (props4.flat === true ? " q-stepper--flat" : "") + (props4.bordered === true ? " q-stepper--bordered" : "") + (isDark.value === true ? " q-stepper--dark q-dark" : "")
    );
    const headerClasses = computed(
      () => `q-stepper__header row items-stretch justify-between q-stepper__header--${props4.alternativeLabels === true ? "alternative" : "standard"}-labels` + (props4.flat === false || props4.bordered === true ? " q-stepper__header--border" : "") + (props4.contracted === true ? " q-stepper__header--contracted" : "") + (props4.headerClass !== void 0 ? ` ${props4.headerClass}` : "")
    );
    function getContent() {
      const top = hSlot(slots.message, []);
      if (props4.vertical === true) {
        isValidPanelName(props4.modelValue) && updatePanelIndex();
        const content = h("div", {
          class: "q-stepper__content"
        }, hSlot(slots.default));
        return top === void 0 ? [content] : top.concat(content);
      }
      return [
        h(
          "div",
          { class: headerClasses.value },
          getPanels().map((panel) => {
            const step = camelizeProps(panel.props);
            return h(StepHeader_default, {
              key: step.name,
              stepper: props4,
              step,
              goToPanel
            });
          })
        ),
        top,
        hDir(
          "div",
          { class: "q-stepper__content q-panel-parent" },
          getPanelContent(),
          "cont",
          props4.swipeable,
          () => panelDirectives.value
        )
      ];
    }
    return () => {
      updatePanelsList(slots);
      return h("div", {
        class: classes.value
      }, hMergeSlot(slots.navigation, getContent()));
    };
  }
});
createComponent({
  name: "QStepperNavigation",
  setup(_, { slots }) {
    return () => h("div", { class: "q-stepper__nav" }, hSlot(slots.default));
  }
});
var QTh_default = createComponent({
  name: "QTh",
  props: {
    props: Object,
    autoWidth: Boolean
  },
  emits: ["click"],
  setup(props4, { slots, emit: emit2 }) {
    const vm2 = getCurrentInstance();
    const { proxy: { $q } } = vm2;
    const onClick = (evt) => {
      emit2("click", evt);
    };
    return () => {
      if (props4.props === void 0) {
        return h("th", {
          class: props4.autoWidth === true ? "q-table--col-auto-width" : "",
          onClick
        }, hSlot(slots.default));
      }
      let col, child;
      const name2 = vm2.vnode.key;
      if (name2) {
        col = props4.props.colsMap[name2];
        if (col === void 0) return;
      } else {
        col = props4.props.col;
      }
      if (col.sortable === true) {
        const action = col.align === "right" ? "unshift" : "push";
        child = hUniqueSlot(slots.default, []);
        child[action](
          h(QIcon_default, {
            class: col.__iconClass,
            name: $q.iconSet.table.arrowUp
          })
        );
      } else {
        child = hSlot(slots.default);
      }
      const data = {
        class: col.__thClass + (props4.autoWidth === true ? " q-table--col-auto-width" : ""),
        style: col.headerStyle,
        onClick: (evt) => {
          col.sortable === true && props4.props.sort(col);
          onClick(evt);
        }
      };
      return h("th", data, child);
    };
  }
});
function get_table_middle_default(props4, content) {
  return h("div", props4, [
    h("table", { class: "q-table" }, content)
  ]);
}
var comps = {
  list: QList_default,
  table: QMarkupTable_default
};
var typeOptions = ["list", "table", "__qtable"];
var QVirtualScroll_default = createComponent({
  name: "QVirtualScroll",
  props: {
    ...useVirtualScrollProps,
    type: {
      type: String,
      default: "list",
      validator: (v2) => typeOptions.includes(v2)
    },
    items: {
      type: Array,
      default: () => []
    },
    itemsFn: Function,
    itemsSize: Number,
    scrollTarget: scrollTargetProp
  },
  setup(props4, { slots, attrs }) {
    let localScrollTarget;
    const rootRef = ref(null);
    const virtualScrollLength = computed(() => props4.itemsSize >= 0 && props4.itemsFn !== void 0 ? parseInt(props4.itemsSize, 10) : Array.isArray(props4.items) ? props4.items.length : 0);
    const {
      virtualScrollSliceRange,
      localResetVirtualScroll,
      padVirtualScroll,
      onVirtualScrollEvt
    } = useVirtualScroll({
      virtualScrollLength,
      getVirtualScrollTarget,
      getVirtualScrollEl
    });
    const virtualScrollScope = computed(() => {
      if (virtualScrollLength.value === 0) {
        return [];
      }
      const mapFn = (item, i) => ({
        index: virtualScrollSliceRange.value.from + i,
        item
      });
      return props4.itemsFn === void 0 ? props4.items.slice(virtualScrollSliceRange.value.from, virtualScrollSliceRange.value.to).map(mapFn) : props4.itemsFn(virtualScrollSliceRange.value.from, virtualScrollSliceRange.value.to - virtualScrollSliceRange.value.from).map(mapFn);
    });
    const classes = computed(
      () => "q-virtual-scroll q-virtual-scroll" + (props4.virtualScrollHorizontal === true ? "--horizontal" : "--vertical") + (props4.scrollTarget !== void 0 ? "" : " scroll")
    );
    const attributes = computed(() => props4.scrollTarget !== void 0 ? {} : { tabindex: 0 });
    watch(virtualScrollLength, () => {
      localResetVirtualScroll();
    });
    watch(() => props4.scrollTarget, () => {
      unconfigureScrollTarget();
      configureScrollTarget();
    });
    function getVirtualScrollEl() {
      return rootRef.value.$el || rootRef.value;
    }
    function getVirtualScrollTarget() {
      return localScrollTarget;
    }
    function configureScrollTarget() {
      localScrollTarget = getScrollTarget(getVirtualScrollEl(), props4.scrollTarget);
      localScrollTarget.addEventListener("scroll", onVirtualScrollEvt, listenOpts.passive);
    }
    function unconfigureScrollTarget() {
      if (localScrollTarget !== void 0) {
        localScrollTarget.removeEventListener("scroll", onVirtualScrollEvt, listenOpts.passive);
        localScrollTarget = void 0;
      }
    }
    function __getVirtualChildren() {
      let child = padVirtualScroll(
        props4.type === "list" ? "div" : "tbody",
        virtualScrollScope.value.map(slots.default)
      );
      if (slots.before !== void 0) {
        child = slots.before().concat(child);
      }
      return hMergeSlot(slots.after, child);
    }
    onBeforeMount(() => {
      localResetVirtualScroll();
    });
    onMounted(() => {
      configureScrollTarget();
    });
    onActivated(() => {
      configureScrollTarget();
    });
    onDeactivated(() => {
      unconfigureScrollTarget();
    });
    onBeforeUnmount(() => {
      unconfigureScrollTarget();
    });
    return () => {
      if (slots.default === void 0) {
        console.error("QVirtualScroll: default scoped slot is required for rendering");
        return;
      }
      return props4.type === "__qtable" ? get_table_middle_default(
        { ref: rootRef, class: "q-table__middle " + classes.value },
        __getVirtualChildren()
      ) : h(comps[props4.type], {
        ...attrs,
        ref: rootRef,
        class: [attrs.class, classes.value],
        ...attributes.value
      }, __getVirtualChildren);
    };
  }
});
function sortDate(a, b) {
  return new Date(a) - new Date(b);
}
var useTableSortProps = {
  sortMethod: Function,
  binaryStateSort: Boolean,
  columnSortOrder: {
    type: String,
    validator: (v2) => v2 === "ad" || v2 === "da",
    default: "ad"
  }
};
function useTableSort(props4, computedPagination, colList, setPagination) {
  const columnToSort = computed(() => {
    const { sortBy } = computedPagination.value;
    return sortBy ? colList.value.find((def2) => def2.name === sortBy) || null : null;
  });
  const computedSortMethod = computed(() => props4.sortMethod !== void 0 ? props4.sortMethod : (data, sortBy, descending) => {
    const col = colList.value.find((def2) => def2.name === sortBy);
    if (col === void 0 || col.field === void 0) {
      return data;
    }
    const dir = descending === true ? -1 : 1, val = typeof col.field === "function" ? (v2) => col.field(v2) : (v2) => v2[col.field];
    return data.sort((a, b) => {
      let A = val(a), B = val(b);
      if (col.rawSort !== void 0) {
        return col.rawSort(A, B, a, b) * dir;
      }
      if (A === null || A === void 0) {
        return -1 * dir;
      }
      if (B === null || B === void 0) {
        return 1 * dir;
      }
      if (col.sort !== void 0) {
        return col.sort(A, B, a, b) * dir;
      }
      if (isNumber(A) === true && isNumber(B) === true) {
        return (A - B) * dir;
      }
      if (isDate(A) === true && isDate(B) === true) {
        return sortDate(A, B) * dir;
      }
      if (typeof A === "boolean" && typeof B === "boolean") {
        return (A - B) * dir;
      }
      [A, B] = [A, B].map((s) => (s + "").toLocaleString().toLowerCase());
      return A < B ? -1 * dir : A === B ? 0 : dir;
    });
  });
  function sort(col) {
    let sortOrder = props4.columnSortOrder;
    if (isObject(col) === true) {
      if (col.sortOrder) {
        sortOrder = col.sortOrder;
      }
      col = col.name;
    } else {
      const def2 = colList.value.find((def22) => def22.name === col);
      if (def2 !== void 0 && def2.sortOrder) {
        sortOrder = def2.sortOrder;
      }
    }
    let { sortBy, descending } = computedPagination.value;
    if (sortBy !== col) {
      sortBy = col;
      descending = sortOrder === "da";
    } else if (props4.binaryStateSort === true) {
      descending = !descending;
    } else if (descending === true) {
      if (sortOrder === "ad") {
        sortBy = null;
      } else {
        descending = false;
      }
    } else {
      if (sortOrder === "ad") {
        descending = true;
      } else {
        sortBy = null;
      }
    }
    setPagination({ sortBy, descending, page: 1 });
  }
  return {
    columnToSort,
    computedSortMethod,
    sort
  };
}
var useTableFilterProps = {
  filter: [String, Object],
  filterMethod: Function
};
function useTableFilter(props4, setPagination) {
  const computedFilterMethod = computed(() => props4.filterMethod !== void 0 ? props4.filterMethod : (rows, terms, cols, cellValue) => {
    const lowerTerms = terms ? terms.toLowerCase() : "";
    return rows.filter(
      (row) => cols.some((col) => {
        const val = cellValue(col, row) + "";
        const haystack = val === "undefined" || val === "null" ? "" : val.toLowerCase();
        return haystack.indexOf(lowerTerms) !== -1;
      })
    );
  });
  watch(
    () => props4.filter,
    () => {
      nextTick(() => {
        setPagination({ page: 1 }, true);
      });
    },
    { deep: true }
  );
  return { computedFilterMethod };
}
function samePagination(oldPag, newPag) {
  for (const prop in newPag) {
    if (newPag[prop] !== oldPag[prop]) {
      return false;
    }
  }
  return true;
}
function fixPagination(p2) {
  if (p2.page < 1) {
    p2.page = 1;
  }
  if (p2.rowsPerPage !== void 0 && p2.rowsPerPage < 1) {
    p2.rowsPerPage = 0;
  }
  return p2;
}
var useTablePaginationProps = {
  pagination: Object,
  rowsPerPageOptions: {
    type: Array,
    default: () => [5, 7, 10, 15, 20, 25, 50, 0]
  },
  "onUpdate:pagination": [Function, Array]
};
function useTablePaginationState(vm2, getCellValue) {
  const { props: props4, emit: emit2 } = vm2;
  const innerPagination = ref(
    Object.assign({
      sortBy: null,
      descending: false,
      page: 1,
      rowsPerPage: props4.rowsPerPageOptions.length !== 0 ? props4.rowsPerPageOptions[0] : 5
    }, props4.pagination)
  );
  const computedPagination = computed(() => {
    const pag = props4["onUpdate:pagination"] !== void 0 ? { ...innerPagination.value, ...props4.pagination } : innerPagination.value;
    return fixPagination(pag);
  });
  const isServerSide = computed(() => computedPagination.value.rowsNumber !== void 0);
  function sendServerRequest(pagination) {
    requestServerInteraction({
      pagination,
      filter: props4.filter
    });
  }
  function requestServerInteraction(prop = {}) {
    nextTick(() => {
      emit2("request", {
        pagination: prop.pagination || computedPagination.value,
        filter: prop.filter || props4.filter,
        getCellValue
      });
    });
  }
  function setPagination(val, forceServerRequest) {
    const newPagination = fixPagination({
      ...computedPagination.value,
      ...val
    });
    if (samePagination(computedPagination.value, newPagination) === true) {
      if (isServerSide.value === true && forceServerRequest === true) {
        sendServerRequest(newPagination);
      }
      return;
    }
    if (isServerSide.value === true) {
      sendServerRequest(newPagination);
      return;
    }
    if (props4.pagination !== void 0 && props4["onUpdate:pagination"] !== void 0) {
      emit2("update:pagination", newPagination);
    } else {
      innerPagination.value = newPagination;
    }
  }
  return {
    innerPagination,
    computedPagination,
    isServerSide,
    requestServerInteraction,
    setPagination
  };
}
function useTablePagination(vm2, innerPagination, computedPagination, isServerSide, setPagination, filteredSortedRowsNumber) {
  const { props: props4, emit: emit2, proxy: { $q } } = vm2;
  const computedRowsNumber = computed(() => isServerSide.value === true ? computedPagination.value.rowsNumber || 0 : filteredSortedRowsNumber.value);
  const firstRowIndex = computed(() => {
    const { page, rowsPerPage } = computedPagination.value;
    return (page - 1) * rowsPerPage;
  });
  const lastRowIndex = computed(() => {
    const { page, rowsPerPage } = computedPagination.value;
    return page * rowsPerPage;
  });
  const isFirstPage = computed(() => computedPagination.value.page === 1);
  const pagesNumber = computed(() => computedPagination.value.rowsPerPage === 0 ? 1 : Math.max(
    1,
    Math.ceil(computedRowsNumber.value / computedPagination.value.rowsPerPage)
  ));
  const isLastPage = computed(() => lastRowIndex.value === 0 ? true : computedPagination.value.page >= pagesNumber.value);
  const computedRowsPerPageOptions = computed(() => {
    const opts = props4.rowsPerPageOptions.includes(innerPagination.value.rowsPerPage) ? props4.rowsPerPageOptions : [innerPagination.value.rowsPerPage].concat(props4.rowsPerPageOptions);
    return opts.map((count) => ({
      label: count === 0 ? $q.lang.table.allRows : "" + count,
      value: count
    }));
  });
  watch(pagesNumber, (lastPage2, oldLastPage) => {
    if (lastPage2 === oldLastPage) {
      return;
    }
    const currentPage = computedPagination.value.page;
    if (lastPage2 && !currentPage) {
      setPagination({ page: 1 });
    } else if (lastPage2 < currentPage) {
      setPagination({ page: lastPage2 });
    }
  });
  function firstPage() {
    setPagination({ page: 1 });
  }
  function prevPage() {
    const { page } = computedPagination.value;
    if (page > 1) {
      setPagination({ page: page - 1 });
    }
  }
  function nextPage() {
    const { page, rowsPerPage } = computedPagination.value;
    if (lastRowIndex.value > 0 && page * rowsPerPage < computedRowsNumber.value) {
      setPagination({ page: page + 1 });
    }
  }
  function lastPage() {
    setPagination({ page: pagesNumber.value });
  }
  if (props4["onUpdate:pagination"] !== void 0) {
    emit2("update:pagination", { ...computedPagination.value });
  }
  return {
    firstRowIndex,
    lastRowIndex,
    isFirstPage,
    isLastPage,
    pagesNumber,
    computedRowsPerPageOptions,
    computedRowsNumber,
    firstPage,
    prevPage,
    nextPage,
    lastPage
  };
}
var useTableRowSelectionProps = {
  selection: {
    type: String,
    default: "none",
    validator: (v2) => ["single", "multiple", "none"].includes(v2)
  },
  selected: {
    type: Array,
    default: () => []
  }
};
var useTableRowSelectionEmits = ["update:selected", "selection"];
function useTableRowSelection(props4, emit2, computedRows, getRowKey) {
  const selectedKeys = computed(() => {
    const keys = {};
    props4.selected.map(getRowKey.value).forEach((key) => {
      keys[key] = true;
    });
    return keys;
  });
  const hasSelectionMode = computed(() => {
    return props4.selection !== "none";
  });
  const singleSelection = computed(() => {
    return props4.selection === "single";
  });
  const multipleSelection = computed(() => {
    return props4.selection === "multiple";
  });
  const allRowsSelected = computed(
    () => computedRows.value.length !== 0 && computedRows.value.every(
      (row) => selectedKeys.value[getRowKey.value(row)] === true
    )
  );
  const someRowsSelected = computed(
    () => allRowsSelected.value !== true && computedRows.value.some((row) => selectedKeys.value[getRowKey.value(row)] === true)
  );
  const rowsSelectedNumber = computed(() => props4.selected.length);
  function isRowSelected(key) {
    return selectedKeys.value[key] === true;
  }
  function clearSelection2() {
    emit2("update:selected", []);
  }
  function updateSelection(keys, rows, added, evt) {
    emit2("selection", { rows, added, keys, evt });
    const payload = singleSelection.value === true ? added === true ? rows : [] : added === true ? props4.selected.concat(rows) : props4.selected.filter(
      (row) => keys.includes(getRowKey.value(row)) === false
    );
    emit2("update:selected", payload);
  }
  return {
    hasSelectionMode,
    singleSelection,
    multipleSelection,
    allRowsSelected,
    someRowsSelected,
    rowsSelectedNumber,
    isRowSelected,
    clearSelection: clearSelection2,
    updateSelection
  };
}
function getVal(val) {
  return Array.isArray(val) ? val.slice() : [];
}
var useTableRowExpandProps = {
  expanded: Array
  // v-model:expanded
};
var useTableRowExpandEmits = ["update:expanded"];
function useTableRowExpand(props4, emit2) {
  const innerExpanded = ref(getVal(props4.expanded));
  watch(() => props4.expanded, (val) => {
    innerExpanded.value = getVal(val);
  });
  function isRowExpanded(key) {
    return innerExpanded.value.includes(key);
  }
  function setExpanded(val) {
    if (props4.expanded !== void 0) {
      emit2("update:expanded", val);
    } else {
      innerExpanded.value = val;
    }
  }
  function updateExpanded(key, add2) {
    const target2 = innerExpanded.value.slice();
    const index = target2.indexOf(key);
    if (add2 === true) {
      if (index === -1) {
        target2.push(key);
        setExpanded(target2);
      }
    } else if (index !== -1) {
      target2.splice(index, 1);
      setExpanded(target2);
    }
  }
  return {
    isRowExpanded,
    setExpanded,
    updateExpanded
  };
}
var useTableColumnSelectionProps = {
  visibleColumns: Array
};
function useTableColumnSelection(props4, computedPagination, hasSelectionMode) {
  const colList = computed(() => {
    if (props4.columns !== void 0) {
      return props4.columns;
    }
    const row = props4.rows[0];
    return row !== void 0 ? Object.keys(row).map((name2) => ({
      name: name2,
      label: name2.toUpperCase(),
      field: name2,
      align: isNumber(row[name2]) ? "right" : "left",
      sortable: true
    })) : [];
  });
  const computedCols = computed(() => {
    const { sortBy, descending } = computedPagination.value;
    const cols = props4.visibleColumns !== void 0 ? colList.value.filter((col) => col.required === true || props4.visibleColumns.includes(col.name) === true) : colList.value;
    return cols.map((col) => {
      const align = col.align || "right";
      const alignClass = `text-${align}`;
      return {
        ...col,
        align,
        __iconClass: `q-table__sort-icon q-table__sort-icon--${align}`,
        __thClass: alignClass + (col.headerClasses !== void 0 ? " " + col.headerClasses : "") + (col.sortable === true ? " sortable" : "") + (col.name === sortBy ? ` sorted ${descending === true ? "sort-desc" : ""}` : ""),
        __tdStyle: col.style !== void 0 ? typeof col.style !== "function" ? () => col.style : col.style : () => null,
        __tdClass: col.classes !== void 0 ? typeof col.classes !== "function" ? () => alignClass + " " + col.classes : (row) => alignClass + " " + col.classes(row) : () => alignClass
      };
    });
  });
  const computedColsMap = computed(() => {
    const names = {};
    computedCols.value.forEach((col) => {
      names[col.name] = col;
    });
    return names;
  });
  const computedColspan = computed(() => {
    return props4.tableColspan !== void 0 ? props4.tableColspan : computedCols.value.length + (hasSelectionMode.value === true ? 1 : 0);
  });
  return {
    colList,
    computedCols,
    computedColsMap,
    computedColspan
  };
}
var bottomClass = "q-table__bottom row items-center";
var virtScrollPassthroughProps = {};
commonVirtScrollPropsList.forEach((p2) => {
  virtScrollPassthroughProps[p2] = {};
});
createComponent({
  name: "QTable",
  props: {
    rows: {
      type: Array,
      required: true
    },
    rowKey: {
      type: [String, Function],
      default: "id"
    },
    columns: Array,
    loading: Boolean,
    iconFirstPage: String,
    iconPrevPage: String,
    iconNextPage: String,
    iconLastPage: String,
    title: String,
    hideHeader: Boolean,
    grid: Boolean,
    gridHeader: Boolean,
    dense: Boolean,
    flat: Boolean,
    bordered: Boolean,
    square: Boolean,
    separator: {
      type: String,
      default: "horizontal",
      validator: (v2) => ["horizontal", "vertical", "cell", "none"].includes(v2)
    },
    wrapCells: Boolean,
    virtualScroll: Boolean,
    virtualScrollTarget: {},
    ...virtScrollPassthroughProps,
    noDataLabel: String,
    noResultsLabel: String,
    loadingLabel: String,
    selectedRowsLabel: Function,
    rowsPerPageLabel: String,
    paginationLabel: Function,
    color: {
      type: String,
      default: "grey-8"
    },
    titleClass: [String, Array, Object],
    tableStyle: [String, Array, Object],
    tableClass: [String, Array, Object],
    tableHeaderStyle: [String, Array, Object],
    tableHeaderClass: [String, Array, Object],
    cardContainerClass: [String, Array, Object],
    cardContainerStyle: [String, Array, Object],
    cardStyle: [String, Array, Object],
    cardClass: [String, Array, Object],
    hideBottom: Boolean,
    hideSelectedBanner: Boolean,
    hideNoData: Boolean,
    hidePagination: Boolean,
    onRowClick: Function,
    onRowDblclick: Function,
    onRowContextmenu: Function,
    ...useDarkProps,
    ...useFullscreenProps,
    ...useTableColumnSelectionProps,
    ...useTableFilterProps,
    ...useTablePaginationProps,
    ...useTableRowExpandProps,
    ...useTableRowSelectionProps,
    ...useTableSortProps
  },
  emits: [
    "request",
    "virtualScroll",
    ...useFullscreenEmits,
    ...useTableRowExpandEmits,
    ...useTableRowSelectionEmits
  ],
  setup(props4, { slots, emit: emit2 }) {
    const vm2 = getCurrentInstance();
    const { proxy: { $q } } = vm2;
    const isDark = use_dark_default(props4, $q);
    const { inFullscreen, toggleFullscreen } = use_fullscreen_default();
    const getRowKey = computed(() => typeof props4.rowKey === "function" ? props4.rowKey : (row) => row[props4.rowKey]);
    const rootRef = ref(null);
    const virtScrollRef = ref(null);
    const hasVirtScroll = computed(() => props4.grid !== true && props4.virtualScroll === true);
    const cardDefaultClass = computed(
      () => " q-table__card" + (isDark.value === true ? " q-table__card--dark q-dark" : "") + (props4.square === true ? " q-table--square" : "") + (props4.flat === true ? " q-table--flat" : "") + (props4.bordered === true ? " q-table--bordered" : "")
    );
    const __containerClass = computed(
      () => `q-table__container q-table--${props4.separator}-separator column no-wrap` + (props4.grid === true ? " q-table--grid" : cardDefaultClass.value) + (isDark.value === true ? " q-table--dark" : "") + (props4.dense === true ? " q-table--dense" : "") + (props4.wrapCells === false ? " q-table--no-wrap" : "") + (inFullscreen.value === true ? " fullscreen scroll" : "")
    );
    const containerClass = computed(
      () => __containerClass.value + (props4.loading === true ? " q-table--loading" : "")
    );
    watch(
      () => props4.tableStyle + props4.tableClass + props4.tableHeaderStyle + props4.tableHeaderClass + __containerClass.value,
      () => {
        hasVirtScroll.value === true && virtScrollRef.value !== null && virtScrollRef.value.reset();
      }
    );
    const {
      innerPagination,
      computedPagination,
      isServerSide,
      requestServerInteraction,
      setPagination
    } = useTablePaginationState(vm2, getCellValue);
    const { computedFilterMethod } = useTableFilter(props4, setPagination);
    const { isRowExpanded, setExpanded, updateExpanded } = useTableRowExpand(props4, emit2);
    const filteredSortedRows = computed(() => {
      let rows = props4.rows;
      if (isServerSide.value === true || rows.length === 0) {
        return rows;
      }
      const { sortBy, descending } = computedPagination.value;
      if (props4.filter) {
        rows = computedFilterMethod.value(rows, props4.filter, computedCols.value, getCellValue);
      }
      if (columnToSort.value !== null) {
        rows = computedSortMethod.value(
          props4.rows === rows ? rows.slice() : rows,
          sortBy,
          descending
        );
      }
      return rows;
    });
    const filteredSortedRowsNumber = computed(() => filteredSortedRows.value.length);
    const computedRows = computed(() => {
      let rows = filteredSortedRows.value;
      if (isServerSide.value === true) {
        return rows;
      }
      const { rowsPerPage } = computedPagination.value;
      if (rowsPerPage !== 0) {
        if (firstRowIndex.value === 0 && props4.rows !== rows) {
          if (rows.length > lastRowIndex.value) {
            rows = rows.slice(0, lastRowIndex.value);
          }
        } else {
          rows = rows.slice(firstRowIndex.value, lastRowIndex.value);
        }
      }
      return rows;
    });
    const {
      hasSelectionMode,
      singleSelection,
      multipleSelection,
      allRowsSelected,
      someRowsSelected,
      rowsSelectedNumber,
      isRowSelected,
      clearSelection: clearSelection2,
      updateSelection
    } = useTableRowSelection(props4, emit2, computedRows, getRowKey);
    const { colList, computedCols, computedColsMap, computedColspan } = useTableColumnSelection(props4, computedPagination, hasSelectionMode);
    const { columnToSort, computedSortMethod, sort } = useTableSort(props4, computedPagination, colList, setPagination);
    const {
      firstRowIndex,
      lastRowIndex,
      isFirstPage,
      isLastPage,
      pagesNumber,
      computedRowsPerPageOptions,
      computedRowsNumber,
      firstPage,
      prevPage,
      nextPage,
      lastPage
    } = useTablePagination(vm2, innerPagination, computedPagination, isServerSide, setPagination, filteredSortedRowsNumber);
    const nothingToDisplay = computed(() => computedRows.value.length === 0);
    const virtProps = computed(() => {
      const acc = {};
      commonVirtScrollPropsList.forEach((p2) => {
        acc[p2] = props4[p2];
      });
      if (acc.virtualScrollItemSize === void 0) {
        acc.virtualScrollItemSize = props4.dense === true ? 28 : 48;
      }
      return acc;
    });
    function resetVirtualScroll() {
      hasVirtScroll.value === true && virtScrollRef.value.reset();
    }
    function getBody() {
      if (props4.grid === true) {
        return getGridBody();
      }
      const header2 = props4.hideHeader !== true ? getTHead : null;
      if (hasVirtScroll.value === true) {
        const topRow = slots["top-row"];
        const bottomRow = slots["bottom-row"];
        const virtSlots = {
          default: (props5) => getTBodyTR(props5.item, slots.body, props5.index)
        };
        if (topRow !== void 0) {
          const topContent = h("tbody", topRow({ cols: computedCols.value }));
          virtSlots.before = header2 === null ? () => topContent : () => [header2()].concat(topContent);
        } else if (header2 !== null) {
          virtSlots.before = header2;
        }
        if (bottomRow !== void 0) {
          virtSlots.after = () => h("tbody", bottomRow({ cols: computedCols.value }));
        }
        return h(QVirtualScroll_default, {
          ref: virtScrollRef,
          class: props4.tableClass,
          style: props4.tableStyle,
          ...virtProps.value,
          scrollTarget: props4.virtualScrollTarget,
          items: computedRows.value,
          type: "__qtable",
          tableColspan: computedColspan.value,
          onVirtualScroll: onVScroll
        }, virtSlots);
      }
      const child = [
        getTBody()
      ];
      if (header2 !== null) {
        child.unshift(header2());
      }
      return get_table_middle_default({
        class: ["q-table__middle scroll", props4.tableClass],
        style: props4.tableStyle
      }, child);
    }
    function scrollTo(toIndex, edge) {
      if (virtScrollRef.value !== null) {
        virtScrollRef.value.scrollTo(toIndex, edge);
        return;
      }
      toIndex = parseInt(toIndex, 10);
      const rowEl = rootRef.value.querySelector(`tbody tr:nth-of-type(${toIndex + 1})`);
      if (rowEl !== null) {
        const scrollTarget = rootRef.value.querySelector(".q-table__middle.scroll");
        const offsetTop = rowEl.offsetTop - props4.virtualScrollStickySizeStart;
        const direction = offsetTop < scrollTarget.scrollTop ? "decrease" : "increase";
        scrollTarget.scrollTop = offsetTop;
        emit2("virtualScroll", {
          index: toIndex,
          from: 0,
          to: innerPagination.value.rowsPerPage - 1,
          direction
        });
      }
    }
    function onVScroll(info) {
      emit2("virtualScroll", info);
    }
    function getProgress() {
      return [
        h(QLinearProgress_default, {
          class: "q-table__linear-progress",
          color: props4.color,
          dark: isDark.value,
          indeterminate: true,
          trackColor: "transparent"
        })
      ];
    }
    function getTBodyTR(row, bodySlot, pageIndex) {
      const key = getRowKey.value(row), selected = isRowSelected(key);
      if (bodySlot !== void 0) {
        return bodySlot(
          getBodyScope({
            key,
            row,
            pageIndex,
            __trClass: selected ? "selected" : ""
          })
        );
      }
      const bodyCell = slots["body-cell"], child = computedCols.value.map((col) => {
        const bodyCellCol = slots[`body-cell-${col.name}`], slot = bodyCellCol !== void 0 ? bodyCellCol : bodyCell;
        return slot !== void 0 ? slot(getBodyCellScope({ key, row, pageIndex, col })) : h("td", {
          class: col.__tdClass(row),
          style: col.__tdStyle(row)
        }, getCellValue(col, row));
      });
      if (hasSelectionMode.value === true) {
        const slot = slots["body-selection"];
        const content = slot !== void 0 ? slot(getBodySelectionScope({ key, row, pageIndex })) : [
          h(QCheckbox_default, {
            modelValue: selected,
            color: props4.color,
            dark: isDark.value,
            dense: props4.dense,
            "onUpdate:modelValue": (adding, evt) => {
              updateSelection([key], [row], adding, evt);
            }
          })
        ];
        child.unshift(
          h("td", { class: "q-table--col-auto-width" }, content)
        );
      }
      const data = { key, class: { selected } };
      if (props4.onRowClick !== void 0) {
        data.class["cursor-pointer"] = true;
        data.onClick = (evt) => {
          emit2("rowClick", evt, row, pageIndex);
        };
      }
      if (props4.onRowDblclick !== void 0) {
        data.class["cursor-pointer"] = true;
        data.onDblclick = (evt) => {
          emit2("rowDblclick", evt, row, pageIndex);
        };
      }
      if (props4.onRowContextmenu !== void 0) {
        data.class["cursor-pointer"] = true;
        data.onContextmenu = (evt) => {
          emit2("rowContextmenu", evt, row, pageIndex);
        };
      }
      return h("tr", data, child);
    }
    function getTBody() {
      const body = slots.body, topRow = slots["top-row"], bottomRow = slots["bottom-row"];
      let child = computedRows.value.map(
        (row, pageIndex) => getTBodyTR(row, body, pageIndex)
      );
      if (topRow !== void 0) {
        child = topRow({ cols: computedCols.value }).concat(child);
      }
      if (bottomRow !== void 0) {
        child = child.concat(bottomRow({ cols: computedCols.value }));
      }
      return h("tbody", child);
    }
    function getBodyScope(data) {
      injectBodyCommonScope(data);
      data.cols = data.cols.map(
        (col) => injectProp({ ...col }, "value", () => getCellValue(col, data.row))
      );
      return data;
    }
    function getBodyCellScope(data) {
      injectBodyCommonScope(data);
      injectProp(data, "value", () => getCellValue(data.col, data.row));
      return data;
    }
    function getBodySelectionScope(data) {
      injectBodyCommonScope(data);
      return data;
    }
    function injectBodyCommonScope(data) {
      Object.assign(data, {
        cols: computedCols.value,
        colsMap: computedColsMap.value,
        sort,
        rowIndex: firstRowIndex.value + data.pageIndex,
        color: props4.color,
        dark: isDark.value,
        dense: props4.dense
      });
      hasSelectionMode.value === true && injectProp(
        data,
        "selected",
        () => isRowSelected(data.key),
        (adding, evt) => {
          updateSelection([data.key], [data.row], adding, evt);
        }
      );
      injectProp(
        data,
        "expand",
        () => isRowExpanded(data.key),
        (adding) => {
          updateExpanded(data.key, adding);
        }
      );
    }
    function getCellValue(col, row) {
      const val = typeof col.field === "function" ? col.field(row) : row[col.field];
      return col.format !== void 0 ? col.format(val, row) : val;
    }
    const marginalsScope = computed(() => ({
      pagination: computedPagination.value,
      pagesNumber: pagesNumber.value,
      isFirstPage: isFirstPage.value,
      isLastPage: isLastPage.value,
      firstPage,
      prevPage,
      nextPage,
      lastPage,
      inFullscreen: inFullscreen.value,
      toggleFullscreen
    }));
    function getTopDiv() {
      const top = slots.top, topLeft = slots["top-left"], topRight = slots["top-right"], topSelection = slots["top-selection"], hasSelection = hasSelectionMode.value === true && topSelection !== void 0 && rowsSelectedNumber.value > 0, topClass = "q-table__top relative-position row items-center";
      if (top !== void 0) {
        return h("div", { class: topClass }, [top(marginalsScope.value)]);
      }
      let child;
      if (hasSelection === true) {
        child = topSelection(marginalsScope.value).slice();
      } else {
        child = [];
        if (topLeft !== void 0) {
          child.push(
            h("div", { class: "q-table__control" }, [
              topLeft(marginalsScope.value)
            ])
          );
        } else if (props4.title) {
          child.push(
            h("div", { class: "q-table__control" }, [
              h("div", {
                class: ["q-table__title", props4.titleClass]
              }, props4.title)
            ])
          );
        }
      }
      if (topRight !== void 0) {
        child.push(
          h("div", { class: "q-table__separator col" })
        );
        child.push(
          h("div", { class: "q-table__control" }, [
            topRight(marginalsScope.value)
          ])
        );
      }
      if (child.length === 0) {
        return;
      }
      return h("div", { class: topClass }, child);
    }
    const headerSelectedValue = computed(() => someRowsSelected.value === true ? null : allRowsSelected.value);
    function getTHead() {
      const child = getTHeadTR();
      if (props4.loading === true && slots.loading === void 0) {
        child.push(
          h("tr", { class: "q-table__progress" }, [
            h("th", {
              class: "relative-position",
              colspan: computedColspan.value
            }, getProgress())
          ])
        );
      }
      return h("thead", child);
    }
    function getTHeadTR() {
      const header2 = slots.header, headerCell = slots["header-cell"];
      if (header2 !== void 0) {
        return header2(
          getHeaderScope({ header: true })
        ).slice();
      }
      const child = computedCols.value.map((col) => {
        const headerCellCol = slots[`header-cell-${col.name}`], slot = headerCellCol !== void 0 ? headerCellCol : headerCell, props5 = getHeaderScope({ col });
        return slot !== void 0 ? slot(props5) : h(QTh_default, {
          key: col.name,
          props: props5
        }, () => col.label);
      });
      if (singleSelection.value === true && props4.grid !== true) {
        child.unshift(
          h("th", { class: "q-table--col-auto-width" }, " ")
        );
      } else if (multipleSelection.value === true) {
        const slot = slots["header-selection"];
        const content = slot !== void 0 ? slot(getHeaderScope({})) : [
          h(QCheckbox_default, {
            color: props4.color,
            modelValue: headerSelectedValue.value,
            dark: isDark.value,
            dense: props4.dense,
            "onUpdate:modelValue": onMultipleSelectionSet
          })
        ];
        child.unshift(
          h("th", { class: "q-table--col-auto-width" }, content)
        );
      }
      return [
        h("tr", {
          class: props4.tableHeaderClass,
          style: props4.tableHeaderStyle
        }, child)
      ];
    }
    function getHeaderScope(data) {
      Object.assign(data, {
        cols: computedCols.value,
        sort,
        colsMap: computedColsMap.value,
        color: props4.color,
        dark: isDark.value,
        dense: props4.dense
      });
      if (multipleSelection.value === true) {
        injectProp(
          data,
          "selected",
          () => headerSelectedValue.value,
          onMultipleSelectionSet
        );
      }
      return data;
    }
    function onMultipleSelectionSet(val) {
      if (someRowsSelected.value === true) {
        val = false;
      }
      updateSelection(
        computedRows.value.map(getRowKey.value),
        computedRows.value,
        val
      );
    }
    const navIcon = computed(() => {
      const ico = [
        props4.iconFirstPage || $q.iconSet.table.firstPage,
        props4.iconPrevPage || $q.iconSet.table.prevPage,
        props4.iconNextPage || $q.iconSet.table.nextPage,
        props4.iconLastPage || $q.iconSet.table.lastPage
      ];
      return $q.lang.rtl === true ? ico.reverse() : ico;
    });
    function getBottomDiv() {
      if (props4.hideBottom === true) {
        return;
      }
      if (nothingToDisplay.value === true) {
        if (props4.hideNoData === true) {
          return;
        }
        const message2 = props4.loading === true ? props4.loadingLabel || $q.lang.table.loading : props4.filter ? props4.noResultsLabel || $q.lang.table.noResults : props4.noDataLabel || $q.lang.table.noData;
        const noData = slots["no-data"];
        const children = noData !== void 0 ? [noData({ message: message2, icon: $q.iconSet.table.warning, filter: props4.filter })] : [
          h(QIcon_default, {
            class: "q-table__bottom-nodata-icon",
            name: $q.iconSet.table.warning
          }),
          message2
        ];
        return h("div", { class: bottomClass + " q-table__bottom--nodata" }, children);
      }
      const bottom = slots.bottom;
      if (bottom !== void 0) {
        return h("div", { class: bottomClass }, [bottom(marginalsScope.value)]);
      }
      const child = props4.hideSelectedBanner !== true && hasSelectionMode.value === true && rowsSelectedNumber.value > 0 ? [
        h("div", { class: "q-table__control" }, [
          h("div", [
            (props4.selectedRowsLabel || $q.lang.table.selectedRecords)(rowsSelectedNumber.value)
          ])
        ])
      ] : [];
      if (props4.hidePagination !== true) {
        return h("div", {
          class: bottomClass + " justify-end"
        }, getPaginationDiv(child));
      }
      if (child.length !== 0) {
        return h("div", { class: bottomClass }, child);
      }
    }
    function onPagSelection(pag) {
      setPagination({
        page: 1,
        rowsPerPage: pag.value
      });
    }
    function getPaginationDiv(child) {
      let control;
      const { rowsPerPage } = computedPagination.value, paginationLabel = props4.paginationLabel || $q.lang.table.pagination, paginationSlot = slots.pagination, hasOpts = props4.rowsPerPageOptions.length > 1;
      child.push(
        h("div", { class: "q-table__separator col" })
      );
      if (hasOpts === true) {
        child.push(
          h("div", { class: "q-table__control" }, [
            h("span", { class: "q-table__bottom-item" }, [
              props4.rowsPerPageLabel || $q.lang.table.recordsPerPage
            ]),
            h(QSelect_default, {
              class: "q-table__select inline q-table__bottom-item",
              color: props4.color,
              modelValue: rowsPerPage,
              options: computedRowsPerPageOptions.value,
              displayValue: rowsPerPage === 0 ? $q.lang.table.allRows : rowsPerPage,
              dark: isDark.value,
              borderless: true,
              dense: true,
              optionsDense: true,
              optionsCover: true,
              "onUpdate:modelValue": onPagSelection
            })
          ])
        );
      }
      if (paginationSlot !== void 0) {
        control = paginationSlot(marginalsScope.value);
      } else {
        control = [
          h("span", rowsPerPage !== 0 ? { class: "q-table__bottom-item" } : {}, [
            rowsPerPage ? paginationLabel(firstRowIndex.value + 1, Math.min(lastRowIndex.value, computedRowsNumber.value), computedRowsNumber.value) : paginationLabel(1, filteredSortedRowsNumber.value, computedRowsNumber.value)
          ])
        ];
        if (rowsPerPage !== 0 && pagesNumber.value > 1) {
          const btnProps = {
            color: props4.color,
            round: true,
            dense: true,
            flat: true
          };
          if (props4.dense === true) {
            btnProps.size = "sm";
          }
          pagesNumber.value > 2 && control.push(
            h(QBtn_default, {
              key: "pgFirst",
              ...btnProps,
              icon: navIcon.value[0],
              disable: isFirstPage.value,
              onClick: firstPage
            })
          );
          control.push(
            h(QBtn_default, {
              key: "pgPrev",
              ...btnProps,
              icon: navIcon.value[1],
              disable: isFirstPage.value,
              onClick: prevPage
            }),
            h(QBtn_default, {
              key: "pgNext",
              ...btnProps,
              icon: navIcon.value[2],
              disable: isLastPage.value,
              onClick: nextPage
            })
          );
          pagesNumber.value > 2 && control.push(
            h(QBtn_default, {
              key: "pgLast",
              ...btnProps,
              icon: navIcon.value[3],
              disable: isLastPage.value,
              onClick: lastPage
            })
          );
        }
      }
      child.push(
        h("div", { class: "q-table__control" }, control)
      );
      return child;
    }
    function getGridHeader() {
      const child = props4.gridHeader === true ? [
        h("table", { class: "q-table" }, [
          getTHead()
        ])
      ] : props4.loading === true && slots.loading === void 0 ? getProgress() : void 0;
      return h("div", { class: "q-table__middle" }, child);
    }
    function getGridBody() {
      const item = slots.item !== void 0 ? slots.item : (scope) => {
        const child = scope.cols.map(
          (col) => h("div", { class: "q-table__grid-item-row" }, [
            h("div", { class: "q-table__grid-item-title" }, [col.label]),
            h("div", { class: "q-table__grid-item-value" }, [col.value])
          ])
        );
        if (hasSelectionMode.value === true) {
          const slot = slots["body-selection"];
          const content = slot !== void 0 ? slot(scope) : [
            h(QCheckbox_default, {
              modelValue: scope.selected,
              color: props4.color,
              dark: isDark.value,
              dense: props4.dense,
              "onUpdate:modelValue": (adding, evt) => {
                updateSelection([scope.key], [scope.row], adding, evt);
              }
            })
          ];
          child.unshift(
            h("div", { class: "q-table__grid-item-row" }, content),
            h(QSeparator_default, { dark: isDark.value })
          );
        }
        const data = {
          class: [
            "q-table__grid-item-card" + cardDefaultClass.value,
            props4.cardClass
          ],
          style: props4.cardStyle
        };
        if (props4.onRowClick !== void 0 || props4.onRowDblclick !== void 0) {
          data.class[0] += " cursor-pointer";
          if (props4.onRowClick !== void 0) {
            data.onClick = (evt) => {
              emit2("RowClick", evt, scope.row, scope.pageIndex);
            };
          }
          if (props4.onRowDblclick !== void 0) {
            data.onDblclick = (evt) => {
              emit2("RowDblclick", evt, scope.row, scope.pageIndex);
            };
          }
        }
        return h("div", {
          class: "q-table__grid-item col-xs-12 col-sm-6 col-md-4 col-lg-3" + (scope.selected === true ? " q-table__grid-item--selected" : "")
        }, [
          h("div", data, child)
        ]);
      };
      return h("div", {
        class: [
          "q-table__grid-content row",
          props4.cardContainerClass
        ],
        style: props4.cardContainerStyle
      }, computedRows.value.map((row, pageIndex) => {
        return item(getBodyScope({
          key: getRowKey.value(row),
          row,
          pageIndex
        }));
      }));
    }
    Object.assign(vm2.proxy, {
      requestServerInteraction,
      setPagination,
      firstPage,
      prevPage,
      nextPage,
      lastPage,
      isRowSelected,
      clearSelection: clearSelection2,
      isRowExpanded,
      setExpanded,
      sort,
      resetVirtualScroll,
      scrollTo,
      getCellValue
    });
    injectMultipleProps(vm2.proxy, {
      filteredSortedRows: () => filteredSortedRows.value,
      computedRows: () => computedRows.value,
      computedRowsNumber: () => computedRowsNumber.value
    });
    return () => {
      const child = [getTopDiv()];
      const data = { ref: rootRef, class: containerClass.value };
      if (props4.grid === true) {
        child.push(getGridHeader());
      } else {
        Object.assign(data, {
          class: [data.class, props4.cardClass],
          style: props4.cardStyle
        });
      }
      child.push(
        getBody(),
        getBottomDiv()
      );
      if (props4.loading === true && slots.loading !== void 0) {
        child.push(
          slots.loading()
        );
      }
      return h("div", data, child);
    };
  }
});
createComponent({
  name: "QTr",
  props: {
    props: Object,
    noHover: Boolean
  },
  setup(props4, { slots }) {
    const classes = computed(
      () => "q-tr" + (props4.props === void 0 || props4.props.header === true ? "" : " " + props4.props.__trClass) + (props4.noHover === true ? " q-tr--no-hover" : "")
    );
    return () => h("tr", { class: classes.value }, hSlot(slots.default));
  }
});
createComponent({
  name: "QTd",
  props: {
    props: Object,
    autoWidth: Boolean,
    noHover: Boolean
  },
  setup(props4, { slots }) {
    const vm2 = getCurrentInstance();
    const classes = computed(
      () => "q-td" + (props4.autoWidth === true ? " q-table--col-auto-width" : "") + (props4.noHover === true ? " q-td--no-hover" : "") + " "
    );
    return () => {
      if (props4.props === void 0) {
        return h("td", { class: classes.value }, hSlot(slots.default));
      }
      const name2 = vm2.vnode.key;
      const col = (props4.props.colsMap !== void 0 ? props4.props.colsMap[name2] : null) || props4.props.col;
      if (col === void 0) return;
      const { row } = props4.props;
      return h("td", {
        class: classes.value + col.__tdClass(row),
        style: col.__tdStyle(row)
      }, hSlot(slots.default));
    };
  }
});
createComponent({
  name: "QRouteTab",
  props: {
    ...useRouterLinkProps,
    ...useTabProps
  },
  emits: useTabEmits,
  setup(props4, { slots, emit: emit2 }) {
    const routeData = use_router_link_default({
      useDisableForRouterLinkProps: false
    });
    const { renderTab, $tabs } = use_tab_default(
      props4,
      slots,
      emit2,
      {
        exact: computed(() => props4.exact),
        ...routeData
      }
    );
    watch(
      () => `${props4.name} | ${props4.exact} | ${(routeData.resolvedLink.value || {}).href}`,
      $tabs.verifyRouteModel
    );
    return () => renderTab(routeData.linkTag.value, routeData.linkAttrs.value);
  }
});
function getViewByModel(model, withSeconds) {
  if (model.hour !== null) {
    if (model.minute === null) {
      return "minute";
    }
  }
  return "hour";
}
function getCurrentTime() {
  const d = /* @__PURE__ */ new Date();
  return {
    hour: d.getHours(),
    minute: d.getMinutes(),
    second: d.getSeconds(),
    millisecond: d.getMilliseconds()
  };
}
createComponent({
  name: "QTime",
  props: {
    ...useDarkProps,
    ...useFormProps,
    ...useDatetimeProps,
    modelValue: {
      required: true,
      validator: (val) => typeof val === "string" || val === null
    },
    mask: {
      ...useDatetimeProps.mask,
      default: null
    },
    format24h: {
      type: Boolean,
      default: null
    },
    defaultDate: {
      type: String,
      validator: (v2) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v2)
    },
    options: Function,
    hourOptions: Array,
    minuteOptions: Array,
    secondOptions: Array,
    withSeconds: Boolean,
    nowBtn: Boolean
  },
  emits: useDatetimeEmits,
  setup(props4, { slots, emit: emit2 }) {
    const vm2 = getCurrentInstance();
    const { $q } = vm2.proxy;
    const isDark = use_dark_default(props4, $q);
    const { tabindex, headerClass, getLocale: getLocale2, getCurrentDate } = use_datetime_default(props4, $q);
    const formAttrs = useFormAttrs(props4);
    const injectFormInput = useFormInject(formAttrs);
    let draggingClockRect, dragCache;
    const clockRef = ref(null);
    const mask = computed(() => getMask());
    const locale = computed(() => getLocale2());
    const defaultDateModel = computed(() => getDefaultDateModel());
    const model = __splitDate(
      props4.modelValue,
      mask.value,
      // initial mask
      locale.value,
      // initial locale
      props4.calendar,
      defaultDateModel.value
    );
    const view = ref(getViewByModel(model));
    const innerModel = ref(model);
    const isAM = ref(model.hour === null || model.hour < 12);
    const classes = computed(
      () => `q-time q-time--${props4.landscape === true ? "landscape" : "portrait"}` + (isDark.value === true ? " q-time--dark q-dark" : "") + (props4.disable === true ? " disabled" : props4.readonly === true ? " q-time--readonly" : "") + (props4.bordered === true ? " q-time--bordered" : "") + (props4.square === true ? " q-time--square no-border-radius" : "") + (props4.flat === true ? " q-time--flat no-shadow" : "")
    );
    const stringModel = computed(() => {
      const time = innerModel.value;
      return {
        hour: time.hour === null ? "--" : computedFormat24h.value === true ? pad(time.hour) : String(
          isAM.value === true ? time.hour === 0 ? 12 : time.hour : time.hour > 12 ? time.hour - 12 : time.hour
        ),
        minute: time.minute === null ? "--" : pad(time.minute),
        second: time.second === null ? "--" : pad(time.second)
      };
    });
    const computedFormat24h = computed(() => props4.format24h !== null ? props4.format24h : $q.lang.date.format24h);
    const pointerStyle = computed(() => {
      const forHour = view.value === "hour", divider = forHour === true ? 12 : 60, amount = innerModel.value[view.value], degrees = Math.round(amount * (360 / divider)) - 180;
      let transform2 = `rotate(${degrees}deg) translateX(-50%)`;
      if (forHour === true && computedFormat24h.value === true && innerModel.value.hour >= 12) {
        transform2 += " scale(.7)";
      }
      return { transform: transform2 };
    });
    const minLink = computed(() => innerModel.value.hour !== null);
    const secLink = computed(() => minLink.value === true && innerModel.value.minute !== null);
    const hourInSelection = computed(() => props4.hourOptions !== void 0 ? (val) => props4.hourOptions.includes(val) : props4.options !== void 0 ? (val) => props4.options(val, null, null) : null);
    const minuteInSelection = computed(() => props4.minuteOptions !== void 0 ? (val) => props4.minuteOptions.includes(val) : props4.options !== void 0 ? (val) => props4.options(innerModel.value.hour, val, null) : null);
    const secondInSelection = computed(() => props4.secondOptions !== void 0 ? (val) => props4.secondOptions.includes(val) : props4.options !== void 0 ? (val) => props4.options(innerModel.value.hour, innerModel.value.minute, val) : null);
    const validHours = computed(() => {
      if (hourInSelection.value === null) {
        return null;
      }
      const am = getValidValues(0, 11, hourInSelection.value);
      const pm = getValidValues(12, 11, hourInSelection.value);
      return { am, pm, values: am.values.concat(pm.values) };
    });
    const validMinutes = computed(() => minuteInSelection.value !== null ? getValidValues(0, 59, minuteInSelection.value) : null);
    const validSeconds = computed(() => secondInSelection.value !== null ? getValidValues(0, 59, secondInSelection.value) : null);
    const viewValidOptions = computed(() => {
      switch (view.value) {
        case "hour":
          return validHours.value;
        case "minute":
          return validMinutes.value;
        case "second":
          return validSeconds.value;
      }
    });
    const positions = computed(() => {
      let start, end, offset2 = 0, step = 1;
      const values = viewValidOptions.value !== null ? viewValidOptions.value.values : void 0;
      if (view.value === "hour") {
        if (computedFormat24h.value === true) {
          start = 0;
          end = 23;
        } else {
          start = 0;
          end = 11;
          if (isAM.value === false) {
            offset2 = 12;
          }
        }
      } else {
        start = 0;
        end = 55;
        step = 5;
      }
      const pos = [];
      for (let val = start, index = start; val <= end; val += step, index++) {
        const actualVal = val + offset2, disable = values !== void 0 && values.includes(actualVal) === false, label2 = view.value === "hour" && val === 0 ? computedFormat24h.value === true ? "00" : "12" : val;
        pos.push({ val: actualVal, index, disable, label: label2 });
      }
      return pos;
    });
    const clockDirectives = computed(() => {
      return [[
        TouchPan_default,
        onPan,
        void 0,
        {
          stop: true,
          prevent: true,
          mouse: true
        }
      ]];
    });
    watch(() => props4.modelValue, (v2) => {
      const model2 = __splitDate(
        v2,
        mask.value,
        locale.value,
        props4.calendar,
        defaultDateModel.value
      );
      if (model2.dateHash !== innerModel.value.dateHash || model2.timeHash !== innerModel.value.timeHash) {
        innerModel.value = model2;
        if (model2.hour === null) {
          view.value = "hour";
        } else {
          isAM.value = model2.hour < 12;
        }
      }
    });
    watch([mask, locale], () => {
      nextTick(() => {
        updateValue2();
      });
    });
    function setNow() {
      const date = {
        ...getCurrentDate(),
        ...getCurrentTime()
      };
      updateValue2(date);
      Object.assign(innerModel.value, date);
      view.value = "hour";
    }
    function getValidValues(start, count, testFn) {
      const values = Array.apply(null, { length: count + 1 }).map((_, index) => {
        const i = index + start;
        return {
          index: i,
          val: testFn(i) === true
          // force boolean
        };
      }).filter((v2) => v2.val === true).map((v2) => v2.index);
      return {
        min: values[0],
        max: values[values.length - 1],
        values,
        threshold: count + 1
      };
    }
    function getWheelDist(a, b, threshold) {
      const diff2 = Math.abs(a - b);
      return Math.min(diff2, threshold - diff2);
    }
    function getNormalizedClockValue(val, { min, max, values, threshold }) {
      if (val === min) {
        return min;
      }
      if (val < min || val > max) {
        return getWheelDist(val, min, threshold) <= getWheelDist(val, max, threshold) ? min : max;
      }
      const index = values.findIndex((v2) => val <= v2), before = values[index - 1], after = values[index];
      return val - before <= after - val ? before : after;
    }
    function getMask() {
      return props4.calendar !== "persian" && props4.mask !== null ? props4.mask : `HH:mm${props4.withSeconds === true ? ":ss" : ""}`;
    }
    function getDefaultDateModel() {
      if (typeof props4.defaultDate !== "string") {
        const date = getCurrentDate(true);
        date.dateHash = getDayHash(date);
        return date;
      }
      return __splitDate(props4.defaultDate, "YYYY/MM/DD", void 0, props4.calendar);
    }
    function shouldAbortInteraction() {
      return vmIsDestroyed(vm2) === true || viewValidOptions.value !== null && (viewValidOptions.value.values.length === 0 || view.value === "hour" && computedFormat24h.value !== true && validHours.value[isAM.value === true ? "am" : "pm"].values.length === 0);
    }
    function getClockRect() {
      const clock = clockRef.value, { top, left, width: width3 } = clock.getBoundingClientRect(), dist2 = width3 / 2;
      return {
        top: top + dist2,
        left: left + dist2,
        dist: dist2 * 0.7
      };
    }
    function onPan(event) {
      if (shouldAbortInteraction() === true) {
        return;
      }
      if (event.isFirst === true) {
        draggingClockRect = getClockRect();
        dragCache = updateClock(event.evt, draggingClockRect);
        return;
      }
      dragCache = updateClock(event.evt, draggingClockRect, dragCache);
      if (event.isFinal === true) {
        draggingClockRect = false;
        dragCache = null;
        goToNextView();
      }
    }
    function goToNextView() {
      if (view.value === "hour") {
        view.value = "minute";
      } else if (props4.withSeconds && view.value === "minute") {
        view.value = "second";
      }
    }
    function updateClock(evt, clockRect, cacheVal) {
      const pos = position(evt), height2 = Math.abs(pos.top - clockRect.top), distance = Math.sqrt(
        Math.pow(Math.abs(pos.top - clockRect.top), 2) + Math.pow(Math.abs(pos.left - clockRect.left), 2)
      );
      let val, angle = Math.asin(height2 / distance) * (180 / Math.PI);
      if (pos.top < clockRect.top) {
        angle = clockRect.left < pos.left ? 90 - angle : 270 + angle;
      } else {
        angle = clockRect.left < pos.left ? angle + 90 : 270 - angle;
      }
      if (view.value === "hour") {
        val = angle / 30;
        if (validHours.value !== null) {
          const am = computedFormat24h.value !== true ? isAM.value === true : validHours.value.am.values.length !== 0 && validHours.value.pm.values.length !== 0 ? distance >= clockRect.dist : validHours.value.am.values.length !== 0;
          val = getNormalizedClockValue(
            val + (am === true ? 0 : 12),
            validHours.value[am === true ? "am" : "pm"]
          );
        } else {
          val = Math.round(val);
          if (computedFormat24h.value === true) {
            if (distance < clockRect.dist) {
              if (val < 12) {
                val += 12;
              }
            } else if (val === 12) {
              val = 0;
            }
          } else if (isAM.value === true && val === 12) {
            val = 0;
          } else if (isAM.value === false && val !== 12) {
            val += 12;
          }
        }
        if (computedFormat24h.value === true) {
          isAM.value = val < 12;
        }
      } else {
        val = Math.round(angle / 6) % 60;
        if (view.value === "minute" && validMinutes.value !== null) {
          val = getNormalizedClockValue(val, validMinutes.value);
        } else if (view.value === "second" && validSeconds.value !== null) {
          val = getNormalizedClockValue(val, validSeconds.value);
        }
      }
      if (cacheVal !== val) {
        setModel[view.value](val);
      }
      return val;
    }
    const setView = {
      hour() {
        view.value = "hour";
      },
      minute() {
        view.value = "minute";
      },
      second() {
        view.value = "second";
      }
    };
    function setAmOnKey(e) {
      e.keyCode === 13 && setAm();
    }
    function setPmOnKey(e) {
      e.keyCode === 13 && setPm();
    }
    function onClick(evt) {
      if (shouldAbortInteraction() !== true) {
        if ($q.platform.is.desktop !== true) {
          updateClock(evt, getClockRect());
        }
        goToNextView();
      }
    }
    function onMousedown(evt) {
      if (shouldAbortInteraction() !== true) {
        updateClock(evt, getClockRect());
      }
    }
    function onKeyupHour(e) {
      if (e.keyCode === 13) {
        view.value = "hour";
      } else if ([37, 39].includes(e.keyCode)) {
        const payload = e.keyCode === 37 ? -1 : 1;
        if (validHours.value !== null) {
          const values = computedFormat24h.value === true ? validHours.value.values : validHours.value[isAM.value === true ? "am" : "pm"].values;
          if (values.length === 0) return;
          if (innerModel.value.hour === null) {
            setHour(values[0]);
          } else {
            const index = (values.length + values.indexOf(innerModel.value.hour) + payload) % values.length;
            setHour(values[index]);
          }
        } else {
          const wrap = computedFormat24h.value === true ? 24 : 12, offset2 = computedFormat24h.value !== true && isAM.value === false ? 12 : 0, val = innerModel.value.hour === null ? -payload : innerModel.value.hour;
          setHour(offset2 + (24 + val + payload) % wrap);
        }
      }
    }
    function onKeyupMinute(e) {
      if (e.keyCode === 13) {
        view.value = "minute";
      } else if ([37, 39].includes(e.keyCode)) {
        const payload = e.keyCode === 37 ? -1 : 1;
        if (validMinutes.value !== null) {
          const values = validMinutes.value.values;
          if (values.length === 0) return;
          if (innerModel.value.minute === null) {
            setMinute(values[0]);
          } else {
            const index = (values.length + values.indexOf(innerModel.value.minute) + payload) % values.length;
            setMinute(values[index]);
          }
        } else {
          const val = innerModel.value.minute === null ? -payload : innerModel.value.minute;
          setMinute((60 + val + payload) % 60);
        }
      }
    }
    function onKeyupSecond(e) {
      if (e.keyCode === 13) {
        view.value = "second";
      } else if ([37, 39].includes(e.keyCode)) {
        const payload = e.keyCode === 37 ? -1 : 1;
        if (validSeconds.value !== null) {
          const values = validSeconds.value.values;
          if (values.length === 0) return;
          if (innerModel.value.seconds === null) {
            setSecond(values[0]);
          } else {
            const index = (values.length + values.indexOf(innerModel.value.second) + payload) % values.length;
            setSecond(values[index]);
          }
        } else {
          const val = innerModel.value.second === null ? -payload : innerModel.value.second;
          setSecond((60 + val + payload) % 60);
        }
      }
    }
    function setHour(hour) {
      if (innerModel.value.hour !== hour) {
        innerModel.value.hour = hour;
        verifyAndUpdate();
      }
    }
    function setMinute(minute) {
      if (innerModel.value.minute !== minute) {
        innerModel.value.minute = minute;
        verifyAndUpdate();
      }
    }
    function setSecond(second) {
      if (innerModel.value.second !== second) {
        innerModel.value.second = second;
        verifyAndUpdate();
      }
    }
    const setModel = {
      hour: setHour,
      minute: setMinute,
      second: setSecond
    };
    function setAm() {
      if (isAM.value === false) {
        isAM.value = true;
        if (innerModel.value.hour !== null) {
          innerModel.value.hour -= 12;
          verifyAndUpdate();
        }
      }
    }
    function setPm() {
      if (isAM.value === true) {
        isAM.value = false;
        if (innerModel.value.hour !== null) {
          innerModel.value.hour += 12;
          verifyAndUpdate();
        }
      }
    }
    function goToViewWhenHasModel(newView) {
      const model2 = props4.modelValue;
      if (view.value !== newView && model2 !== void 0 && model2 !== null && model2 !== "" && typeof model2 !== "string") {
        view.value = newView;
      }
    }
    function verifyAndUpdate() {
      if (hourInSelection.value !== null && hourInSelection.value(innerModel.value.hour) !== true) {
        innerModel.value = __splitDate();
        goToViewWhenHasModel("hour");
        return;
      }
      if (minuteInSelection.value !== null && minuteInSelection.value(innerModel.value.minute) !== true) {
        innerModel.value.minute = null;
        innerModel.value.second = null;
        goToViewWhenHasModel("minute");
        return;
      }
      if (props4.withSeconds === true && secondInSelection.value !== null && secondInSelection.value(innerModel.value.second) !== true) {
        innerModel.value.second = null;
        goToViewWhenHasModel("second");
        return;
      }
      if (innerModel.value.hour === null || innerModel.value.minute === null || props4.withSeconds === true && innerModel.value.second === null) {
        return;
      }
      updateValue2();
    }
    function updateValue2(obj) {
      const date = Object.assign({ ...innerModel.value }, obj);
      const val = props4.calendar === "persian" ? pad(date.hour) + ":" + pad(date.minute) + (props4.withSeconds === true ? ":" + pad(date.second) : "") : formatDate(
        new Date(
          date.year,
          date.month === null ? null : date.month - 1,
          date.day,
          date.hour,
          date.minute,
          date.second,
          date.millisecond
        ),
        mask.value,
        locale.value,
        date.year,
        date.timezoneOffset
      );
      date.changed = val !== props4.modelValue;
      emit2("update:modelValue", val, date);
    }
    function getHeader() {
      const label2 = [
        h("div", {
          class: "q-time__link " + (view.value === "hour" ? "q-time__link--active" : "cursor-pointer"),
          tabindex: tabindex.value,
          onClick: setView.hour,
          onKeyup: onKeyupHour
        }, stringModel.value.hour),
        h("div", ":"),
        h(
          "div",
          minLink.value === true ? {
            class: "q-time__link " + (view.value === "minute" ? "q-time__link--active" : "cursor-pointer"),
            tabindex: tabindex.value,
            onKeyup: onKeyupMinute,
            onClick: setView.minute
          } : { class: "q-time__link" },
          stringModel.value.minute
        )
      ];
      if (props4.withSeconds === true) {
        label2.push(
          h("div", ":"),
          h(
            "div",
            secLink.value === true ? {
              class: "q-time__link " + (view.value === "second" ? "q-time__link--active" : "cursor-pointer"),
              tabindex: tabindex.value,
              onKeyup: onKeyupSecond,
              onClick: setView.second
            } : { class: "q-time__link" },
            stringModel.value.second
          )
        );
      }
      const child = [
        h("div", {
          class: "q-time__header-label row items-center no-wrap",
          dir: "ltr"
        }, label2)
      ];
      computedFormat24h.value === false && child.push(
        h("div", {
          class: "q-time__header-ampm column items-between no-wrap"
        }, [
          h("div", {
            class: "q-time__link " + (isAM.value === true ? "q-time__link--active" : "cursor-pointer"),
            tabindex: tabindex.value,
            onClick: setAm,
            onKeyup: setAmOnKey
          }, "AM"),
          h("div", {
            class: "q-time__link " + (isAM.value !== true ? "q-time__link--active" : "cursor-pointer"),
            tabindex: tabindex.value,
            onClick: setPm,
            onKeyup: setPmOnKey
          }, "PM")
        ])
      );
      return h("div", {
        class: "q-time__header flex flex-center no-wrap " + headerClass.value
      }, child);
    }
    function getClock() {
      const current = innerModel.value[view.value];
      return h("div", {
        class: "q-time__content col relative-position"
      }, [
        h(Transition, {
          name: "q-transition--scale"
        }, () => h("div", {
          key: "clock" + view.value,
          class: "q-time__container-parent absolute-full"
        }, [
          h("div", {
            ref: clockRef,
            class: "q-time__container-child fit overflow-hidden"
          }, [
            withDirectives(
              h("div", {
                class: "q-time__clock cursor-pointer non-selectable",
                onClick,
                onMousedown
              }, [
                h("div", { class: "q-time__clock-circle fit" }, [
                  h("div", {
                    class: "q-time__clock-pointer" + (innerModel.value[view.value] === null ? " hidden" : props4.color !== void 0 ? ` text-${props4.color}` : ""),
                    style: pointerStyle.value
                  }),
                  positions.value.map((pos) => h("div", {
                    class: `q-time__clock-position row flex-center q-time__clock-pos-${pos.index}` + (pos.val === current ? " q-time__clock-position--active " + headerClass.value : pos.disable === true ? " q-time__clock-position--disable" : "")
                  }, [h("span", pos.label)]))
                ])
              ]),
              clockDirectives.value
            )
          ])
        ])),
        props4.nowBtn === true ? h(QBtn_default, {
          class: "q-time__now-button absolute",
          icon: $q.iconSet.datetime.now,
          unelevated: true,
          size: "sm",
          round: true,
          color: props4.color,
          textColor: props4.textColor,
          tabindex: tabindex.value,
          onClick: setNow
        }) : null
      ]);
    }
    vm2.proxy.setNow = setNow;
    return () => {
      const child = [getClock()];
      const def2 = hSlot(slots.default);
      def2 !== void 0 && child.push(
        h("div", { class: "q-time__actions" }, def2)
      );
      if (props4.name !== void 0 && props4.disable !== true) {
        injectFormInput(child, "push");
      }
      return h("div", {
        class: classes.value,
        tabindex: -1
      }, [
        getHeader(),
        h("div", { class: "q-time__main col overflow-auto" }, child)
      ]);
    };
  }
});
createComponent({
  name: "QTimeline",
  props: {
    ...useDarkProps,
    color: {
      type: String,
      default: "primary"
    },
    side: {
      type: String,
      default: "right",
      validator: (v2) => ["left", "right"].includes(v2)
    },
    layout: {
      type: String,
      default: "dense",
      validator: (v2) => ["dense", "comfortable", "loose"].includes(v2)
    }
  },
  setup(props4, { slots }) {
    const vm2 = getCurrentInstance();
    const isDark = use_dark_default(props4, vm2.proxy.$q);
    provide(timelineKey, props4);
    const classes = computed(
      () => `q-timeline q-timeline--${props4.layout} q-timeline--${props4.layout}--${props4.side}` + (isDark.value === true ? " q-timeline--dark" : "")
    );
    return () => h("ul", { class: classes.value }, hSlot(slots.default));
  }
});
createComponent({
  name: "QTimelineEntry",
  props: {
    heading: Boolean,
    tag: {
      type: String,
      default: "h3"
    },
    side: {
      type: String,
      default: "right",
      validator: (v2) => ["left", "right"].includes(v2)
    },
    icon: String,
    avatar: String,
    color: String,
    title: String,
    subtitle: String,
    body: String
  },
  setup(props4, { slots }) {
    const $timeline = inject(timelineKey, emptyRenderFn);
    if ($timeline === emptyRenderFn) {
      console.error("QTimelineEntry needs to be child of QTimeline");
      return emptyRenderFn;
    }
    const classes = computed(
      () => `q-timeline__entry q-timeline__entry--${props4.side}` + (props4.icon !== void 0 || props4.avatar !== void 0 ? " q-timeline__entry--icon" : "")
    );
    const dotClass = computed(
      () => `q-timeline__dot text-${props4.color || $timeline.color}`
    );
    const reverse = computed(
      () => $timeline.layout === "comfortable" && $timeline.side === "left"
    );
    return () => {
      const child = hUniqueSlot(slots.default, []);
      if (props4.body !== void 0) {
        child.unshift(props4.body);
      }
      if (props4.heading === true) {
        const content2 = [
          h("div"),
          h("div"),
          h(
            props4.tag,
            { class: "q-timeline__heading-title" },
            child
          )
        ];
        return h("div", {
          class: "q-timeline__heading"
        }, reverse.value === true ? content2.reverse() : content2);
      }
      let dot;
      if (props4.icon !== void 0) {
        dot = [
          h(QIcon_default, {
            class: "row items-center justify-center",
            name: props4.icon
          })
        ];
      } else if (props4.avatar !== void 0) {
        dot = [
          h("img", {
            class: "q-timeline__dot-img",
            src: props4.avatar
          })
        ];
      }
      const content = [
        h("div", { class: "q-timeline__subtitle" }, [
          h("span", {}, hSlot(slots.subtitle, [props4.subtitle]))
        ]),
        h("div", { class: dotClass.value }, dot),
        h("div", { class: "q-timeline__content" }, [
          h("h6", { class: "q-timeline__title" }, hSlot(slots.title, [props4.title]))
        ].concat(child))
      ];
      return h("li", {
        class: classes.value
      }, reverse.value === true ? content.reverse() : content);
    };
  }
});
createComponent({
  name: "QToolbar",
  props: {
    inset: Boolean
  },
  setup(props4, { slots }) {
    const classes = computed(
      () => "q-toolbar row no-wrap items-center" + (props4.inset === true ? " q-toolbar--inset" : "")
    );
    return () => h("div", { class: classes.value, role: "toolbar" }, hSlot(slots.default));
  }
});
createComponent({
  name: "QToolbarTitle",
  props: {
    shrink: Boolean
  },
  setup(props4, { slots }) {
    const classes = computed(
      () => "q-toolbar__title ellipsis" + (props4.shrink === true ? " col-shrink" : "")
    );
    return () => h("div", { class: classes.value }, hSlot(slots.default));
  }
});
var tickStrategyOptions = ["none", "strict", "leaf", "leaf-filtered"];
createComponent({
  name: "QTree",
  props: {
    ...useDarkProps,
    nodes: {
      type: Array,
      required: true
    },
    nodeKey: {
      type: String,
      required: true
    },
    labelKey: {
      type: String,
      default: "label"
    },
    childrenKey: {
      type: String,
      default: "children"
    },
    dense: Boolean,
    color: String,
    controlColor: String,
    textColor: String,
    selectedColor: String,
    icon: String,
    tickStrategy: {
      type: String,
      default: "none",
      validator: (v2) => tickStrategyOptions.includes(v2)
    },
    ticked: Array,
    // v-model:ticked
    expanded: Array,
    // v-model:expanded
    selected: {},
    // v-model:selected
    noSelectionUnset: Boolean,
    defaultExpandAll: Boolean,
    accordion: Boolean,
    filter: String,
    filterMethod: Function,
    duration: {},
    noConnectors: Boolean,
    noTransition: Boolean,
    noNodesLabel: String,
    noResultsLabel: String
  },
  emits: [
    "update:expanded",
    "update:ticked",
    "update:selected",
    "lazyLoad",
    "afterShow",
    "afterHide"
  ],
  setup(props4, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = use_dark_default(props4, $q);
    const lazy = ref({});
    const innerTicked = ref(props4.ticked || []);
    const innerExpanded = ref(props4.expanded || []);
    let blurTargets = {};
    onBeforeUpdate(() => {
      blurTargets = {};
    });
    const classes = computed(
      () => `q-tree q-tree--${props4.dense === true ? "dense" : "standard"}` + (props4.noConnectors === true ? " q-tree--no-connectors" : "") + (isDark.value === true ? " q-tree--dark" : "") + (props4.color !== void 0 ? ` text-${props4.color}` : "")
    );
    const hasSelection = computed(() => props4.selected !== void 0);
    const computedIcon = computed(() => props4.icon || $q.iconSet.tree.icon);
    const computedControlColor = computed(() => props4.controlColor || props4.color);
    const textColorClass = computed(() => props4.textColor !== void 0 ? ` text-${props4.textColor}` : "");
    const selectedColorClass = computed(() => {
      const color = props4.selectedColor || props4.color;
      return color ? ` text-${color}` : "";
    });
    const computedFilterMethod = computed(() => props4.filterMethod !== void 0 ? props4.filterMethod : (node, filter) => {
      const filt = filter.toLowerCase();
      return node[props4.labelKey] && node[props4.labelKey].toLowerCase().indexOf(filt) !== -1;
    });
    const meta = computed(() => {
      const meta2 = {};
      const travel = (node, parent) => {
        const tickStrategy = node.tickStrategy || (parent ? parent.tickStrategy : props4.tickStrategy);
        const key = node[props4.nodeKey], isParent = node[props4.childrenKey] && Array.isArray(node[props4.childrenKey]) && node[props4.childrenKey].length !== 0, selectable = node.disabled !== true && hasSelection.value === true && node.selectable !== false, expandable = node.disabled !== true && node.expandable !== false, hasTicking = tickStrategy !== "none", strictTicking = tickStrategy === "strict", leafFilteredTicking = tickStrategy === "leaf-filtered", leafTicking = tickStrategy === "leaf" || tickStrategy === "leaf-filtered";
        let tickable = node.disabled !== true && node.tickable !== false;
        if (leafTicking === true && tickable === true && parent && parent.tickable !== true) {
          tickable = false;
        }
        let localLazy = node.lazy;
        if (localLazy === true && lazy.value[key] !== void 0 && Array.isArray(node[props4.childrenKey]) === true) {
          localLazy = lazy.value[key];
        }
        const m2 = {
          key,
          parent,
          isParent,
          lazy: localLazy,
          disabled: node.disabled,
          link: node.disabled !== true && (selectable === true || expandable === true && (isParent === true || localLazy === true)),
          children: [],
          matchesFilter: props4.filter ? computedFilterMethod.value(node, props4.filter) : true,
          selected: key === props4.selected && selectable === true,
          selectable,
          expanded: isParent === true ? innerExpanded.value.includes(key) : false,
          expandable,
          noTick: node.noTick === true || strictTicking !== true && localLazy && localLazy !== "loaded",
          tickable,
          tickStrategy,
          hasTicking,
          strictTicking,
          leafFilteredTicking,
          leafTicking,
          ticked: strictTicking === true ? innerTicked.value.includes(key) : isParent === true ? false : innerTicked.value.includes(key)
        };
        meta2[key] = m2;
        if (isParent === true) {
          m2.children = node[props4.childrenKey].map((n) => travel(n, m2));
          if (props4.filter) {
            if (m2.matchesFilter !== true) {
              m2.matchesFilter = m2.children.some((n) => n.matchesFilter);
            } else if (m2.noTick !== true && m2.disabled !== true && m2.tickable === true && leafFilteredTicking === true && m2.children.every((n) => n.matchesFilter !== true || n.noTick === true || n.tickable !== true) === true) {
              m2.tickable = false;
            }
          }
          if (m2.matchesFilter === true) {
            if (m2.noTick !== true && strictTicking !== true && m2.children.every((n) => n.noTick) === true) {
              m2.noTick = true;
            }
            if (leafTicking) {
              m2.ticked = false;
              m2.indeterminate = m2.children.some((node2) => node2.indeterminate === true);
              m2.tickable = m2.tickable === true && m2.children.some((node2) => node2.tickable);
              if (m2.indeterminate !== true) {
                const sel = m2.children.reduce((acc, meta3) => meta3.ticked === true ? acc + 1 : acc, 0);
                if (sel === m2.children.length) {
                  m2.ticked = true;
                } else if (sel > 0) {
                  m2.indeterminate = true;
                }
              }
              if (m2.indeterminate === true) {
                m2.indeterminateNextState = m2.children.every((meta3) => meta3.tickable !== true || meta3.ticked !== true);
              }
            }
          }
        }
        return m2;
      };
      props4.nodes.forEach((node) => travel(node, null));
      return meta2;
    });
    watch(() => props4.ticked, (val) => {
      innerTicked.value = val;
    });
    watch(() => props4.expanded, (val) => {
      innerExpanded.value = val;
    });
    function getNodeByKey(key) {
      const reduce2 = [].reduce;
      const find = (result, node) => {
        if (result || !node) {
          return result;
        }
        if (Array.isArray(node) === true) {
          return reduce2.call(Object(node), find, result);
        }
        if (node[props4.nodeKey] === key) {
          return node;
        }
        if (node[props4.childrenKey]) {
          return find(null, node[props4.childrenKey]);
        }
      };
      return find(null, props4.nodes);
    }
    function getTickedNodes() {
      return innerTicked.value.map((key) => getNodeByKey(key));
    }
    function getExpandedNodes() {
      return innerExpanded.value.map((key) => getNodeByKey(key));
    }
    function isExpanded(key) {
      return key && meta.value[key] ? meta.value[key].expanded : false;
    }
    function collapseAll() {
      if (props4.expanded !== void 0) {
        emit2("update:expanded", []);
      } else {
        innerExpanded.value = [];
      }
    }
    function expandAll() {
      const expanded = [];
      const travel = (node) => {
        if (node[props4.childrenKey] && node[props4.childrenKey].length !== 0) {
          if (node.expandable !== false && node.disabled !== true) {
            expanded.push(node[props4.nodeKey]);
            node[props4.childrenKey].forEach(travel);
          }
        }
      };
      props4.nodes.forEach(travel);
      if (props4.expanded !== void 0) {
        emit2("update:expanded", expanded);
      } else {
        innerExpanded.value = expanded;
      }
    }
    function setExpanded(key, state, node = getNodeByKey(key), m2 = meta.value[key]) {
      if (m2.lazy && m2.lazy !== "loaded") {
        if (m2.lazy === "loading") {
          return;
        }
        lazy.value[key] = "loading";
        if (Array.isArray(node[props4.childrenKey]) !== true) {
          node[props4.childrenKey] = [];
        }
        emit2("lazyLoad", {
          node,
          key,
          done: (children) => {
            lazy.value[key] = "loaded";
            node[props4.childrenKey] = Array.isArray(children) === true ? children : [];
            nextTick(() => {
              const localMeta = meta.value[key];
              if (localMeta && localMeta.isParent === true) {
                localSetExpanded(key, true);
              }
            });
          },
          fail: () => {
            delete lazy.value[key];
            if (node[props4.childrenKey].length === 0) {
              delete node[props4.childrenKey];
            }
          }
        });
      } else if (m2.isParent === true && m2.expandable === true) {
        localSetExpanded(key, state);
      }
    }
    function localSetExpanded(key, state) {
      let target2 = innerExpanded.value;
      const shouldEmit = props4.expanded !== void 0;
      if (shouldEmit === true) {
        target2 = target2.slice();
      }
      if (state) {
        if (props4.accordion) {
          if (meta.value[key]) {
            const collapse = [];
            if (meta.value[key].parent) {
              meta.value[key].parent.children.forEach((m2) => {
                if (m2.key !== key && m2.expandable === true) {
                  collapse.push(m2.key);
                }
              });
            } else {
              props4.nodes.forEach((node) => {
                const k = node[props4.nodeKey];
                if (k !== key) {
                  collapse.push(k);
                }
              });
            }
            if (collapse.length !== 0) {
              target2 = target2.filter((k) => collapse.includes(k) === false);
            }
          }
        }
        target2 = target2.concat([key]).filter((key2, index, self2) => self2.indexOf(key2) === index);
      } else {
        target2 = target2.filter((k) => k !== key);
      }
      if (shouldEmit === true) {
        emit2("update:expanded", target2);
      } else {
        innerExpanded.value = target2;
      }
    }
    function isTicked(key) {
      return key && meta.value[key] ? meta.value[key].ticked : false;
    }
    function setTicked(keys, state) {
      let target2 = innerTicked.value;
      const shouldEmit = props4.ticked !== void 0;
      if (shouldEmit === true) {
        target2 = target2.slice();
      }
      if (state) {
        target2 = target2.concat(keys).filter((key, index, self2) => self2.indexOf(key) === index);
      } else {
        target2 = target2.filter((k) => keys.includes(k) === false);
      }
      if (shouldEmit === true) {
        emit2("update:ticked", target2);
      }
    }
    function getSlotScope(node, meta2, key) {
      const scope = { tree: proxy, node, key, color: props4.color, dark: isDark.value };
      injectProp(
        scope,
        "expanded",
        () => {
          return meta2.expanded;
        },
        (val) => {
          val !== meta2.expanded && setExpanded(key, val);
        }
      );
      injectProp(
        scope,
        "ticked",
        () => {
          return meta2.ticked;
        },
        (val) => {
          val !== meta2.ticked && setTicked([key], val);
        }
      );
      return scope;
    }
    function getChildren(nodes) {
      return (props4.filter ? nodes.filter((n) => meta.value[n[props4.nodeKey]].matchesFilter) : nodes).map((child) => getNode(child));
    }
    function getNodeMedia(node) {
      if (node.icon !== void 0) {
        return h(QIcon_default, {
          class: "q-tree__icon q-mr-sm",
          name: node.icon,
          color: node.iconColor
        });
      }
      const src = node.img || node.avatar;
      if (src) {
        return h("img", {
          class: `q-tree__${node.img ? "img" : "avatar"} q-mr-sm`,
          src
        });
      }
    }
    function onShow() {
      emit2("afterShow");
    }
    function onHide() {
      emit2("afterHide");
    }
    function getNode(node) {
      const key = node[props4.nodeKey], m2 = meta.value[key], header2 = node.header ? slots[`header-${node.header}`] || slots["default-header"] : slots["default-header"];
      const children = m2.isParent === true ? getChildren(node[props4.childrenKey]) : [];
      const isParent = children.length !== 0 || m2.lazy && m2.lazy !== "loaded";
      let body = node.body ? slots[`body-${node.body}`] || slots["default-body"] : slots["default-body"];
      const slotScope = header2 !== void 0 || body !== void 0 ? getSlotScope(node, m2, key) : null;
      if (body !== void 0) {
        body = h("div", { class: "q-tree__node-body relative-position" }, [
          h("div", { class: textColorClass.value }, [
            body(slotScope)
          ])
        ]);
      }
      return h("div", {
        key,
        class: `q-tree__node relative-position q-tree__node--${isParent === true ? "parent" : "child"}`
      }, [
        h("div", {
          class: "q-tree__node-header relative-position row no-wrap items-center" + (m2.link === true ? " q-tree__node--link q-hoverable q-focusable" : "") + (m2.selected === true ? " q-tree__node--selected" : "") + (m2.disabled === true ? " q-tree__node--disabled" : ""),
          tabindex: m2.link === true ? 0 : -1,
          ariaExpanded: children.length > 0 ? m2.expanded : null,
          role: "treeitem",
          onClick: (e) => {
            onClick(node, m2, e);
          },
          onKeypress(e) {
            if (shouldIgnoreKey(e) !== true) {
              if (e.keyCode === 13) {
                onClick(node, m2, e, true);
              } else if (e.keyCode === 32) {
                onExpandClick(node, m2, e, true);
              }
            }
          }
        }, [
          h("div", {
            class: "q-focus-helper",
            tabindex: -1,
            ref: (el) => {
              blurTargets[m2.key] = el;
            }
          }),
          m2.lazy === "loading" ? h(QSpinner_default, {
            class: "q-tree__spinner",
            color: computedControlColor.value
          }) : isParent === true ? h(QIcon_default, {
            class: "q-tree__arrow" + (m2.expanded === true ? " q-tree__arrow--rotate" : ""),
            name: computedIcon.value,
            onClick(e) {
              onExpandClick(node, m2, e);
            }
          }) : null,
          m2.hasTicking === true && m2.noTick !== true ? h(QCheckbox_default, {
            class: "q-tree__tickbox",
            modelValue: m2.indeterminate === true ? null : m2.ticked,
            color: computedControlColor.value,
            dark: isDark.value,
            dense: true,
            keepColor: true,
            disable: m2.tickable !== true,
            onKeydown: stopAndPrevent,
            "onUpdate:modelValue": (v2) => {
              onTickedClick(m2, v2);
            }
          }) : null,
          h("div", {
            class: "q-tree__node-header-content col row no-wrap items-center" + (m2.selected === true ? selectedColorClass.value : textColorClass.value)
          }, [
            header2 ? header2(slotScope) : [
              getNodeMedia(node),
              h("div", node[props4.labelKey])
            ]
          ])
        ]),
        isParent === true ? props4.noTransition === true ? m2.expanded === true ? h("div", {
          class: "q-tree__node-collapsible" + textColorClass.value,
          key: `${key}__q`
        }, [
          body,
          h("div", {
            class: "q-tree__children" + (m2.disabled === true ? " q-tree__node--disabled" : ""),
            role: "group"
          }, children)
        ]) : null : h(QSlideTransition_default, {
          duration: props4.duration,
          onShow,
          onHide
        }, () => withDirectives(
          h("div", {
            class: "q-tree__node-collapsible" + textColorClass.value,
            key: `${key}__q`
          }, [
            body,
            h("div", {
              class: "q-tree__children" + (m2.disabled === true ? " q-tree__node--disabled" : ""),
              role: "group"
            }, children)
          ]),
          [[vShow, m2.expanded]]
        )) : body
      ]);
    }
    function blur(key) {
      const blurTarget = blurTargets[key];
      blurTarget && blurTarget.focus();
    }
    function onClick(node, meta2, e, keyboard) {
      keyboard !== true && meta2.selectable !== false && blur(meta2.key);
      if (hasSelection.value && meta2.selectable) {
        if (props4.noSelectionUnset === false) {
          emit2("update:selected", meta2.key !== props4.selected ? meta2.key : null);
        } else if (meta2.key !== props4.selected) {
          emit2("update:selected", meta2.key === void 0 ? null : meta2.key);
        }
      } else {
        onExpandClick(node, meta2, e, keyboard);
      }
      if (typeof node.handler === "function") {
        node.handler(node);
      }
    }
    function onExpandClick(node, meta2, e, keyboard) {
      if (e !== void 0) {
        stopAndPrevent(e);
      }
      keyboard !== true && meta2.selectable !== false && blur(meta2.key);
      setExpanded(meta2.key, !meta2.expanded, node, meta2);
    }
    function onTickedClick(meta2, state) {
      if (meta2.indeterminate === true) {
        state = meta2.indeterminateNextState;
      }
      if (meta2.strictTicking) {
        setTicked([meta2.key], state);
      } else if (meta2.leafTicking) {
        const keys = [];
        const travel = (meta3) => {
          if (meta3.isParent) {
            if (state !== true && meta3.noTick !== true && meta3.tickable === true) {
              keys.push(meta3.key);
            }
            if (meta3.leafTicking === true) {
              meta3.children.forEach(travel);
            }
          } else if (meta3.noTick !== true && meta3.tickable === true && (meta3.leafFilteredTicking !== true || meta3.matchesFilter === true)) {
            keys.push(meta3.key);
          }
        };
        travel(meta2);
        setTicked(keys, state);
      }
    }
    props4.defaultExpandAll === true && expandAll();
    Object.assign(proxy, {
      getNodeByKey,
      getTickedNodes,
      getExpandedNodes,
      isExpanded,
      collapseAll,
      expandAll,
      setExpanded,
      isTicked,
      setTicked
    });
    return () => {
      const children = getChildren(props4.nodes);
      return h(
        "div",
        {
          class: classes.value,
          role: "tree"
        },
        children.length === 0 ? props4.filter ? props4.noResultsLabel || $q.lang.tree.noResults : props4.noNodesLabel || $q.lang.tree.noNodes : children
      );
    };
  }
});
function getProgressLabel(p2) {
  return (p2 * 100).toFixed(2) + "%";
}
var coreProps = {
  ...useDarkProps,
  ...useFileProps,
  label: String,
  color: String,
  textColor: String,
  square: Boolean,
  flat: Boolean,
  bordered: Boolean,
  noThumbnails: Boolean,
  thumbnailFit: {
    type: String,
    default: "cover"
  },
  autoUpload: Boolean,
  hideUploadBtn: Boolean,
  disable: Boolean,
  readonly: Boolean
};
var coreEmits = [
  ...useFileEmits,
  "start",
  "finish",
  "added",
  "removed"
];
function getRenderer(getPlugin, expose) {
  const vm2 = getCurrentInstance();
  const { props: props4, slots, emit: emit2, proxy } = vm2;
  const { $q } = proxy;
  const isDark = use_dark_default(props4, $q);
  function updateFileStatus(file, status2, uploadedSize) {
    file.__status = status2;
    if (status2 === "idle") {
      file.__uploaded = 0;
      file.__progress = 0;
      file.__sizeLabel = humanStorageSize(file.size);
      file.__progressLabel = "0.00%";
      return;
    }
    if (status2 === "failed") {
      proxy.$forceUpdate();
      return;
    }
    file.__uploaded = status2 === "uploaded" ? file.size : uploadedSize;
    file.__progress = status2 === "uploaded" ? 1 : Math.min(0.9999, file.__uploaded / file.size);
    file.__progressLabel = getProgressLabel(file.__progress);
    proxy.$forceUpdate();
  }
  const editable = computed(() => props4.disable !== true && props4.readonly !== true);
  const dnd = ref(false);
  const rootRef = ref(null);
  const inputRef = ref(null);
  const state = {
    files: ref([]),
    queuedFiles: ref([]),
    uploadedFiles: ref([]),
    uploadedSize: ref(0),
    updateFileStatus,
    isAlive: () => vmIsDestroyed(vm2) === false
  };
  const {
    pickFiles,
    addFiles,
    onDragover,
    onDragleave,
    processFiles,
    getDndNode,
    maxFilesNumber,
    maxTotalSizeNumber
  } = use_file_default({ editable, dnd, getFileInput, addFilesToQueue });
  Object.assign(state, getPlugin({
    props: props4,
    slots,
    emit: emit2,
    helpers: state,
    exposeApi: (obj) => {
      Object.assign(state, obj);
    }
  }));
  if (state.isBusy === void 0) {
    state.isBusy = ref(false);
  }
  const uploadSize = ref(0);
  const uploadProgress = computed(() => uploadSize.value === 0 ? 0 : state.uploadedSize.value / uploadSize.value);
  const uploadProgressLabel = computed(() => getProgressLabel(uploadProgress.value));
  const uploadSizeLabel = computed(() => humanStorageSize(uploadSize.value));
  const canAddFiles = computed(
    () => editable.value === true && state.isUploading.value !== true && (props4.multiple === true || state.queuedFiles.value.length === 0) && (props4.maxFiles === void 0 || state.files.value.length < maxFilesNumber.value) && (props4.maxTotalSize === void 0 || uploadSize.value < maxTotalSizeNumber.value)
  );
  const canUpload = computed(
    () => editable.value === true && state.isBusy.value !== true && state.isUploading.value !== true && state.queuedFiles.value.length !== 0
  );
  provide(uploaderKey, renderInput);
  const classes = computed(
    () => "q-uploader column no-wrap" + (isDark.value === true ? " q-uploader--dark q-dark" : "") + (props4.bordered === true ? " q-uploader--bordered" : "") + (props4.square === true ? " q-uploader--square no-border-radius" : "") + (props4.flat === true ? " q-uploader--flat no-shadow" : "") + (props4.disable === true ? " disabled q-uploader--disable" : "") + (dnd.value === true ? " q-uploader--dnd" : "")
  );
  const colorClass = computed(
    () => "q-uploader__header" + (props4.color !== void 0 ? ` bg-${props4.color}` : "") + (props4.textColor !== void 0 ? ` text-${props4.textColor}` : "")
  );
  watch(state.isUploading, (newVal, oldVal) => {
    if (oldVal === false && newVal === true) {
      emit2("start");
    } else if (oldVal === true && newVal === false) {
      emit2("finish");
    }
  });
  function reset() {
    if (props4.disable === false) {
      state.abort();
      state.uploadedSize.value = 0;
      uploadSize.value = 0;
      revokeImgURLs();
      state.files.value = [];
      state.queuedFiles.value = [];
      state.uploadedFiles.value = [];
    }
  }
  function removeUploadedFiles() {
    if (props4.disable === false) {
      batchRemoveFiles(["uploaded"], () => {
        state.uploadedFiles.value = [];
      });
    }
  }
  function removeQueuedFiles() {
    batchRemoveFiles(["idle", "failed"], ({ size: size2 }) => {
      uploadSize.value -= size2;
      state.queuedFiles.value = [];
    });
  }
  function batchRemoveFiles(statusList, cb) {
    if (props4.disable === true) {
      return;
    }
    const removed = {
      files: [],
      size: 0
    };
    const localFiles = state.files.value.filter((f) => {
      if (statusList.indexOf(f.__status) === -1) {
        return true;
      }
      removed.size += f.size;
      removed.files.push(f);
      f.__img !== void 0 && window.URL.revokeObjectURL(f.__img.src);
      return false;
    });
    if (removed.files.length !== 0) {
      state.files.value = localFiles;
      cb(removed);
      emit2("removed", removed.files);
    }
  }
  function removeFile(file) {
    if (props4.disable) return;
    if (file.__status === "uploaded") {
      state.uploadedFiles.value = state.uploadedFiles.value.filter((f) => f.__key !== file.__key);
    } else if (file.__status === "uploading") {
      file.__abort();
    } else {
      uploadSize.value -= file.size;
    }
    state.files.value = state.files.value.filter((f) => {
      if (f.__key !== file.__key) {
        return true;
      }
      f.__img !== void 0 && window.URL.revokeObjectURL(f.__img.src);
      return false;
    });
    state.queuedFiles.value = state.queuedFiles.value.filter((f) => f.__key !== file.__key);
    emit2("removed", [file]);
  }
  function revokeImgURLs() {
    state.files.value.forEach((f) => {
      f.__img !== void 0 && window.URL.revokeObjectURL(f.__img.src);
    });
  }
  function getFileInput() {
    return inputRef.value || rootRef.value.getElementsByClassName("q-uploader__input")[0];
  }
  function addFilesToQueue(e, fileList) {
    const localFiles = processFiles(e, fileList, state.files.value, true);
    const fileInput = getFileInput();
    if (fileInput !== void 0 && fileInput !== null) {
      fileInput.value = "";
    }
    if (localFiles === void 0) return;
    localFiles.forEach((file) => {
      state.updateFileStatus(file, "idle");
      uploadSize.value += file.size;
      if (props4.noThumbnails !== true && file.type.toUpperCase().startsWith("IMAGE")) {
        const img = new Image();
        img.src = window.URL.createObjectURL(file);
        file.__img = img;
      }
    });
    state.files.value = state.files.value.concat(localFiles);
    state.queuedFiles.value = state.queuedFiles.value.concat(localFiles);
    emit2("added", localFiles);
    props4.autoUpload === true && state.upload();
  }
  function upload() {
    canUpload.value === true && state.upload();
  }
  function getBtn2(show, icon2, fn) {
    if (show === true) {
      const data = {
        type: "a",
        key: icon2,
        icon: $q.iconSet.uploader[icon2],
        flat: true,
        dense: true
      };
      let child = void 0;
      if (icon2 === "add") {
        data.onClick = pickFiles;
        child = renderInput;
      } else {
        data.onClick = fn;
      }
      return h(QBtn_default, data, child);
    }
  }
  function renderInput() {
    return h("input", {
      ref: inputRef,
      class: "q-uploader__input overflow-hidden absolute-full",
      tabindex: -1,
      type: "file",
      title: "",
      // try to remove default tooltip
      accept: props4.accept,
      multiple: props4.multiple === true ? "multiple" : void 0,
      capture: props4.capture,
      onMousedown: stop,
      // need to stop refocus from QBtn
      onClick: pickFiles,
      onChange: addFilesToQueue
    });
  }
  function getHeader() {
    if (slots.header !== void 0) {
      return slots.header(publicApi);
    }
    return [
      h("div", {
        class: "q-uploader__header-content column"
      }, [
        h("div", {
          class: "flex flex-center no-wrap q-gutter-xs"
        }, [
          getBtn2(state.queuedFiles.value.length !== 0, "removeQueue", removeQueuedFiles),
          getBtn2(state.uploadedFiles.value.length !== 0, "removeUploaded", removeUploadedFiles),
          state.isUploading.value === true ? h(QSpinner_default, { class: "q-uploader__spinner" }) : null,
          h("div", { class: "col column justify-center" }, [
            props4.label !== void 0 ? h("div", { class: "q-uploader__title" }, [props4.label]) : null,
            h("div", { class: "q-uploader__subtitle" }, [
              uploadSizeLabel.value + " / " + uploadProgressLabel.value
            ])
          ]),
          getBtn2(canAddFiles.value, "add"),
          getBtn2(props4.hideUploadBtn === false && canUpload.value === true, "upload", state.upload),
          getBtn2(state.isUploading.value, "clear", state.abort)
        ])
      ])
    ];
  }
  function getList() {
    if (slots.list !== void 0) {
      return slots.list(publicApi);
    }
    return state.files.value.map((file) => h("div", {
      key: file.__key,
      class: "q-uploader__file relative-position" + (props4.noThumbnails !== true && file.__img !== void 0 ? " q-uploader__file--img" : "") + (file.__status === "failed" ? " q-uploader__file--failed" : file.__status === "uploaded" ? " q-uploader__file--uploaded" : ""),
      style: props4.noThumbnails !== true && file.__img !== void 0 ? { backgroundImage: 'url("' + file.__img.src + '")', backgroundSize: props4.thumbnailFit } : null
    }, [
      h("div", {
        class: "q-uploader__file-header row flex-center no-wrap"
      }, [
        file.__status === "failed" ? h(QIcon_default, {
          class: "q-uploader__file-status",
          name: $q.iconSet.type.negative,
          color: "negative"
        }) : null,
        h("div", { class: "q-uploader__file-header-content col" }, [
          h("div", { class: "q-uploader__title" }, [file.name]),
          h("div", {
            class: "q-uploader__subtitle row items-center no-wrap"
          }, [
            file.__sizeLabel + " / " + file.__progressLabel
          ])
        ]),
        file.__status === "uploading" ? h(QCircularProgress_default, {
          value: file.__progress,
          min: 0,
          max: 1,
          indeterminate: file.__progress === 0
        }) : h(QBtn_default, {
          round: true,
          dense: true,
          flat: true,
          icon: $q.iconSet.uploader[file.__status === "uploaded" ? "done" : "clear"],
          onClick: () => {
            removeFile(file);
          }
        })
      ])
    ]));
  }
  onBeforeUnmount(() => {
    state.isUploading.value === true && state.abort();
    state.files.value.length !== 0 && revokeImgURLs();
  });
  const publicApi = {};
  for (const key in state) {
    if (isRef(state[key]) === true) {
      injectProp(publicApi, key, () => state[key].value);
    } else {
      publicApi[key] = state[key];
    }
  }
  Object.assign(publicApi, {
    upload,
    reset,
    removeUploadedFiles,
    removeQueuedFiles,
    removeFile,
    pickFiles,
    addFiles
  });
  injectMultipleProps(publicApi, {
    canAddFiles: () => canAddFiles.value,
    canUpload: () => canUpload.value,
    uploadSizeLabel: () => uploadSizeLabel.value,
    uploadProgressLabel: () => uploadProgressLabel.value
  });
  expose({
    ...state,
    upload,
    reset,
    removeUploadedFiles,
    removeQueuedFiles,
    removeFile,
    pickFiles,
    addFiles,
    canAddFiles,
    canUpload,
    uploadSizeLabel,
    uploadProgressLabel
  });
  return () => {
    const children = [
      h("div", { class: colorClass.value }, getHeader()),
      h("div", { class: "q-uploader__list scroll" }, getList()),
      getDndNode("uploader")
    ];
    state.isBusy.value === true && children.push(
      h("div", {
        class: "q-uploader__overlay absolute-full flex flex-center"
      }, [h(QSpinner_default)])
    );
    const data = { ref: rootRef, class: classes.value };
    if (canAddFiles.value === true) {
      Object.assign(data, { onDragover, onDragleave });
    }
    return h("div", data, children);
  };
}
var trueFn = () => true;
function get_emits_object_default(emitsArray) {
  const emitsObject = {};
  emitsArray.forEach((val) => {
    emitsObject[val] = trueFn;
  });
  return emitsObject;
}
var coreEmitsObject = get_emits_object_default(coreEmits);
var create_uploader_component_default = ({ name: name2, props: props4, emits: emits3, injectPlugin: injectPlugin2 }) => createComponent({
  name: name2,
  props: {
    ...coreProps,
    ...props4
  },
  emits: isObject(emits3) === true ? { ...coreEmitsObject, ...emits3 } : [...coreEmits, ...emits3],
  setup(_, { expose }) {
    return getRenderer(injectPlugin2, expose);
  }
});
function getFn(prop) {
  return typeof prop === "function" ? prop : () => prop;
}
var name = "QUploader";
var props = {
  url: [Function, String],
  method: {
    type: [Function, String],
    default: "POST"
  },
  fieldName: {
    type: [Function, String],
    default: () => (file) => file.name
  },
  headers: [Function, Array],
  formFields: [Function, Array],
  withCredentials: [Function, Boolean],
  sendRaw: [Function, Boolean],
  batch: [Function, Boolean],
  factory: Function
};
var emits = ["factoryFailed", "uploaded", "failed", "uploading"];
function injectPlugin({ props: props4, emit: emit2, helpers }) {
  const xhrs = ref([]);
  const promises = ref([]);
  const workingThreads = ref(0);
  const xhrProps = computed(() => ({
    url: getFn(props4.url),
    method: getFn(props4.method),
    headers: getFn(props4.headers),
    formFields: getFn(props4.formFields),
    fieldName: getFn(props4.fieldName),
    withCredentials: getFn(props4.withCredentials),
    sendRaw: getFn(props4.sendRaw),
    batch: getFn(props4.batch)
  }));
  const isUploading = computed(() => workingThreads.value > 0);
  const isBusy = computed(() => promises.value.length !== 0);
  let abortPromises;
  function abort() {
    xhrs.value.forEach((x) => {
      x.abort();
    });
    if (promises.value.length !== 0) {
      abortPromises = true;
    }
  }
  function upload() {
    const queue2 = helpers.queuedFiles.value.slice(0);
    helpers.queuedFiles.value = [];
    if (xhrProps.value.batch(queue2)) {
      runFactory(queue2);
    } else {
      queue2.forEach((file) => {
        runFactory([file]);
      });
    }
  }
  function runFactory(files) {
    workingThreads.value++;
    if (typeof props4.factory !== "function") {
      performUpload(files, {});
      return;
    }
    const res = props4.factory(files);
    if (!res) {
      emit2(
        "factoryFailed",
        new Error("QUploader: factory() does not return properly"),
        files
      );
      workingThreads.value--;
    } else if (typeof res.catch === "function" && typeof res.then === "function") {
      promises.value.push(res);
      const failed = (err) => {
        if (helpers.isAlive() === true) {
          promises.value = promises.value.filter((p2) => p2 !== res);
          if (promises.value.length === 0) {
            abortPromises = false;
          }
          helpers.queuedFiles.value = helpers.queuedFiles.value.concat(files);
          files.forEach((f) => {
            helpers.updateFileStatus(f, "failed");
          });
          emit2("factoryFailed", err, files);
          workingThreads.value--;
        }
      };
      res.then((factory) => {
        if (abortPromises === true) {
          failed(new Error("Aborted"));
        } else if (helpers.isAlive() === true) {
          promises.value = promises.value.filter((p2) => p2 !== res);
          performUpload(files, factory);
        }
      }).catch(failed);
    } else {
      performUpload(files, res || {});
    }
  }
  function performUpload(files, factory) {
    const form2 = new FormData(), xhr2 = new XMLHttpRequest();
    const getProp2 = (name2, arg) => {
      return factory[name2] !== void 0 ? getFn(factory[name2])(arg) : xhrProps.value[name2](arg);
    };
    const url = getProp2("url", files);
    if (!url) {
      console.error("q-uploader: invalid or no URL specified");
      workingThreads.value--;
      return;
    }
    const fields = getProp2("formFields", files);
    fields !== void 0 && fields.forEach((field) => {
      form2.append(field.name, field.value);
    });
    let uploadIndex = 0, uploadIndexSize = 0, localUploadedSize = 0, maxUploadSize = 0, aborted;
    xhr2.upload.addEventListener("progress", (e) => {
      if (aborted === true) return;
      const loaded = Math.min(maxUploadSize, e.loaded);
      helpers.uploadedSize.value += loaded - localUploadedSize;
      localUploadedSize = loaded;
      let size2 = localUploadedSize - uploadIndexSize;
      for (let i = uploadIndex; size2 > 0 && i < files.length; i++) {
        const file = files[i], uploaded = size2 > file.size;
        if (uploaded) {
          size2 -= file.size;
          uploadIndex++;
          uploadIndexSize += file.size;
          helpers.updateFileStatus(file, "uploading", file.size);
        } else {
          helpers.updateFileStatus(file, "uploading", size2);
          return;
        }
      }
    }, false);
    xhr2.onreadystatechange = () => {
      if (xhr2.readyState < 4) {
        return;
      }
      if (xhr2.status && xhr2.status < 400) {
        helpers.uploadedFiles.value = helpers.uploadedFiles.value.concat(files);
        files.forEach((f) => {
          helpers.updateFileStatus(f, "uploaded");
        });
        emit2("uploaded", { files, xhr: xhr2 });
      } else {
        aborted = true;
        helpers.uploadedSize.value -= localUploadedSize;
        helpers.queuedFiles.value = helpers.queuedFiles.value.concat(files);
        files.forEach((f) => {
          helpers.updateFileStatus(f, "failed");
        });
        emit2("failed", { files, xhr: xhr2 });
      }
      workingThreads.value--;
      xhrs.value = xhrs.value.filter((x) => x !== xhr2);
    };
    xhr2.open(
      getProp2("method", files),
      url
    );
    if (getProp2("withCredentials", files) === true) {
      xhr2.withCredentials = true;
    }
    const headers = getProp2("headers", files);
    headers !== void 0 && headers.forEach((head) => {
      xhr2.setRequestHeader(head.name, head.value);
    });
    const sendRaw = getProp2("sendRaw", files);
    files.forEach((file) => {
      helpers.updateFileStatus(file, "uploading", 0);
      if (sendRaw !== true) {
        form2.append(getProp2("fieldName", file), file, file.name);
      }
      file.xhr = xhr2;
      file.__abort = () => {
        xhr2.abort();
      };
      maxUploadSize += file.size;
    });
    emit2("uploading", { files, xhr: xhr2 });
    xhrs.value.push(xhr2);
    if (sendRaw === true) {
      xhr2.send(new Blob(files));
    } else {
      xhr2.send(form2);
    }
  }
  return {
    isUploading,
    isBusy,
    abort,
    upload
  };
}
var xhr_uploader_plugin_default = {
  name,
  props,
  emits,
  injectPlugin
};
create_uploader_component_default(xhr_uploader_plugin_default);
createComponent({
  name: "QUploaderAddTrigger",
  setup() {
    const $trigger = inject(uploaderKey, emptyRenderFn);
    if ($trigger === emptyRenderFn) {
      console.error("QUploaderAddTrigger needs to be child of QUploader");
    }
    return $trigger;
  }
});
createComponent({
  name: "QVideo",
  props: {
    ...useRatioProps,
    src: {
      type: String,
      required: true
    },
    title: String,
    fetchpriority: {
      type: String,
      default: "auto"
    },
    loading: {
      type: String,
      default: "eager"
    },
    referrerpolicy: {
      type: String,
      default: "strict-origin-when-cross-origin"
    }
  },
  setup(props4) {
    const ratioStyle = use_ratio_default(props4);
    const classes = computed(
      () => "q-video" + (props4.ratio !== void 0 ? " q-video--responsive" : "")
    );
    return () => h("div", {
      class: classes.value,
      style: ratioStyle.value
    }, [
      h("iframe", {
        src: props4.src,
        title: props4.title,
        fetchpriority: props4.fetchpriority,
        loading: props4.loading,
        referrerpolicy: props4.referrerpolicy,
        frameborder: "0",
        allowfullscreen: true
      })
    ]);
  }
});
function getDepth(value2) {
  if (value2 === false) {
    return 0;
  }
  if (value2 === true || value2 === void 0) {
    return 1;
  }
  const depth = parseInt(value2, 10);
  return isNaN(depth) ? 0 : depth;
}
createDirective(
  {
    name: "close-popup",
    beforeMount(el, { value: value2 }) {
      const ctx = {
        depth: getDepth(value2),
        handler(evt) {
          ctx.depth !== 0 && setTimeout(() => {
            const proxy = getPortalProxy(el);
            if (proxy !== void 0) {
              closePortals(proxy, evt, ctx.depth);
            }
          });
        },
        handlerKey(evt) {
          isKeyCode(evt, 13) === true && ctx.handler(evt);
        }
      };
      el.__qclosepopup = ctx;
      el.addEventListener("click", ctx.handler);
      el.addEventListener("keyup", ctx.handlerKey);
    },
    updated(el, { value: value2, oldValue }) {
      if (value2 !== oldValue) {
        el.__qclosepopup.depth = getDepth(value2);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qclosepopup;
      el.removeEventListener("click", ctx.handler);
      el.removeEventListener("keyup", ctx.handlerKey);
      delete el.__qclosepopup;
    }
  }
);
var id2 = 0;
var offsetBase = void 0;
function getAbsolutePosition(el, resize) {
  if (offsetBase === void 0) {
    offsetBase = document.createElement("div");
    offsetBase.style.cssText = "position: absolute; left: 0; top: 0";
    document.body.appendChild(offsetBase);
  }
  const boundingRect = el.getBoundingClientRect();
  const baseRect = offsetBase.getBoundingClientRect();
  const { marginLeft, marginRight, marginTop, marginBottom } = window.getComputedStyle(el);
  const marginH = parseInt(marginLeft, 10) + parseInt(marginRight, 10);
  const marginV = parseInt(marginTop, 10) + parseInt(marginBottom, 10);
  return {
    left: boundingRect.left - baseRect.left,
    top: boundingRect.top - baseRect.top,
    width: boundingRect.right - boundingRect.left,
    height: boundingRect.bottom - boundingRect.top,
    widthM: boundingRect.right - boundingRect.left + (resize === true ? 0 : marginH),
    heightM: boundingRect.bottom - boundingRect.top + (resize === true ? 0 : marginV),
    marginH: resize === true ? marginH : 0,
    marginV: resize === true ? marginV : 0
  };
}
function getAbsoluteSize(el) {
  return {
    width: el.scrollWidth,
    height: el.scrollHeight
  };
}
var styleEdges = ["Top", "Right", "Bottom", "Left"];
var styleBorderRadiuses = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"];
var reStyleSkipKey = /-block|-inline|block-|inline-/;
var reStyleSkipRule = /(-block|-inline|block-|inline-).*:/;
function getComputedStyle2(el, props4) {
  const style2 = window.getComputedStyle(el);
  const fixed = {};
  for (let i = 0; i < props4.length; i++) {
    const prop = props4[i];
    if (style2[prop] === "") {
      if (prop === "cssText") {
        const styleLen = style2.length;
        let val = "";
        for (let i2 = 0; i2 < styleLen; i2++) {
          if (reStyleSkipKey.test(style2[i2]) !== true) {
            val += style2[i2] + ": " + style2[style2[i2]] + "; ";
          }
        }
        fixed[prop] = val;
      } else if (["borderWidth", "borderStyle", "borderColor"].indexOf(prop) !== -1) {
        const suffix = prop.replace("border", "");
        let val = "";
        for (let j = 0; j < styleEdges.length; j++) {
          const subProp = "border" + styleEdges[j] + suffix;
          val += style2[subProp] + " ";
        }
        fixed[prop] = val;
      } else if (prop === "borderRadius") {
        let val1 = "";
        let val2 = "";
        for (let j = 0; j < styleBorderRadiuses.length; j++) {
          const val = style2[styleBorderRadiuses[j]].split(" ");
          val1 += val[0] + " ";
          val2 += (val[1] === void 0 ? val[0] : val[1]) + " ";
        }
        fixed[prop] = val1 + "/ " + val2;
      } else {
        fixed[prop] = style2[prop];
      }
    } else {
      if (prop === "cssText") {
        fixed[prop] = style2[prop].split(";").filter((val) => reStyleSkipRule.test(val) !== true).join(";");
      } else {
        fixed[prop] = style2[prop];
      }
    }
  }
  return fixed;
}
var zIndexPositions = ["absolute", "fixed", "relative", "sticky"];
function getMaxZIndex(elStart) {
  let el = elStart;
  let maxIndex = 0;
  while (el !== null && el !== document) {
    const { position: position2, zIndex } = window.getComputedStyle(el);
    const zIndexNum = Number(zIndex);
    if (zIndexNum > maxIndex && (el === elStart || zIndexPositions.includes(position2) === true)) {
      maxIndex = zIndexNum;
    }
    el = el.parentNode;
  }
  return maxIndex;
}
function normalizeElements(opts) {
  return {
    from: opts.from,
    to: opts.to !== void 0 ? opts.to : opts.from
  };
}
function normalizeOptions(options) {
  if (typeof options === "number") {
    options = {
      duration: options
    };
  } else if (typeof options === "function") {
    options = {
      onEnd: options
    };
  }
  return {
    ...options,
    waitFor: options.waitFor === void 0 ? 0 : options.waitFor,
    duration: isNaN(options.duration) === true ? 300 : parseInt(options.duration, 10),
    easing: typeof options.easing === "string" && options.easing.length !== 0 ? options.easing : "ease-in-out",
    delay: isNaN(options.delay) === true ? 0 : parseInt(options.delay, 10),
    fill: typeof options.fill === "string" && options.fill.length !== 0 ? options.fill : "none",
    resize: options.resize === true,
    // account for UMD too where modifiers will be lowercased to work
    useCSS: options.useCSS === true || options.usecss === true,
    // account for UMD too where modifiers will be lowercased to work
    hideFromClone: options.hideFromClone === true || options.hidefromclone === true,
    // account for UMD too where modifiers will be lowercased to work
    keepToClone: options.keepToClone === true || options.keeptoclone === true,
    tween: options.tween === true,
    tweenFromOpacity: isNaN(options.tweenFromOpacity) === true ? 0.6 : parseFloat(options.tweenFromOpacity),
    tweenToOpacity: isNaN(options.tweenToOpacity) === true ? 0.5 : parseFloat(options.tweenToOpacity)
  };
}
function getElement2(element) {
  const type = typeof element;
  return type === "function" ? element() : type === "string" ? document.querySelector(element) : element;
}
function isValidElement(element) {
  return element && element.ownerDocument === document && element.parentNode !== null;
}
function morph(_options) {
  let cancel = () => false;
  let cancelStatus = false;
  let endElementTo = true;
  const elements = normalizeElements(_options);
  const options = normalizeOptions(_options);
  const elFrom = getElement2(elements.from);
  if (isValidElement(elFrom) !== true) {
    return cancel;
  }
  typeof elFrom.qMorphCancel === "function" && elFrom.qMorphCancel();
  let animationFromClone = void 0;
  let animationFromTween = void 0;
  let animationToClone = void 0;
  let animationTo = void 0;
  const elFromParent = elFrom.parentNode;
  const elFromNext = elFrom.nextElementSibling;
  const elFromPosition = getAbsolutePosition(elFrom, options.resize);
  const {
    width: elFromParentWidthBefore,
    height: elFromParentHeightBefore
  } = getAbsoluteSize(elFromParent);
  const {
    borderWidth: elFromBorderWidth,
    borderStyle: elFromBorderStyle,
    borderColor: elFromBorderColor,
    borderRadius: elFromBorderRadius,
    backgroundColor: elFromBackground,
    transform: elFromTransform,
    position: elFromPositioningType,
    cssText: elFromCssText
  } = getComputedStyle2(elFrom, ["borderWidth", "borderStyle", "borderColor", "borderRadius", "backgroundColor", "transform", "position", "cssText"]);
  const elFromClassSaved = elFrom.classList.toString();
  const elFromStyleSaved = elFrom.style.cssText;
  const elFromClone = elFrom.cloneNode(true);
  const elFromTween = options.tween === true ? elFrom.cloneNode(true) : void 0;
  if (elFromTween !== void 0) {
    elFromTween.className = elFromTween.classList.toString().split(" ").filter((c) => /^bg-/.test(c) === false).join(" ");
  }
  options.hideFromClone === true && elFromClone.classList.add("q-morph--internal");
  elFromClone.setAttribute("aria-hidden", "true");
  elFromClone.style.transition = "none";
  elFromClone.style.animation = "none";
  elFromClone.style.pointerEvents = "none";
  elFromParent.insertBefore(elFromClone, elFromNext);
  elFrom.qMorphCancel = () => {
    cancelStatus = true;
    elFromClone.remove();
    elFromTween !== void 0 && elFromTween.remove();
    options.hideFromClone === true && elFromClone.classList.remove("q-morph--internal");
    elFrom.qMorphCancel = void 0;
  };
  const calculateFinalState = () => {
    const elTo = getElement2(elements.to);
    if (cancelStatus === true || isValidElement(elTo) !== true) {
      typeof elFrom.qMorphCancel === "function" && elFrom.qMorphCancel();
      return;
    }
    elFrom !== elTo && typeof elTo.qMorphCancel === "function" && elTo.qMorphCancel();
    options.keepToClone !== true && elTo.classList.add("q-morph--internal");
    elFromClone.classList.add("q-morph--internal");
    const {
      width: elFromParentWidthAfter,
      height: elFromParentHeightAfter
    } = getAbsoluteSize(elFromParent);
    const {
      width: elToParentWidthBefore,
      height: elToParentHeightBefore
    } = getAbsoluteSize(elTo.parentNode);
    options.hideFromClone !== true && elFromClone.classList.remove("q-morph--internal");
    elTo.qMorphCancel = () => {
      cancelStatus = true;
      elFromClone.remove();
      elFromTween !== void 0 && elFromTween.remove();
      options.hideFromClone === true && elFromClone.classList.remove("q-morph--internal");
      options.keepToClone !== true && elTo.classList.remove("q-morph--internal");
      elFrom.qMorphCancel = void 0;
      elTo.qMorphCancel = void 0;
    };
    const animate = () => {
      if (cancelStatus === true) {
        typeof elTo.qMorphCancel === "function" && elTo.qMorphCancel();
        return;
      }
      if (options.hideFromClone !== true) {
        elFromClone.classList.add("q-morph--internal");
        elFromClone.innerHTML = "";
        elFromClone.style.left = 0;
        elFromClone.style.right = "unset";
        elFromClone.style.top = 0;
        elFromClone.style.bottom = "unset";
        elFromClone.style.transform = "none";
      }
      if (options.keepToClone !== true) {
        elTo.classList.remove("q-morph--internal");
      }
      const elToParent = elTo.parentNode;
      const {
        width: elToParentWidthAfter,
        height: elToParentHeightAfter
      } = getAbsoluteSize(elToParent);
      const elToClone = elTo.cloneNode(options.keepToClone);
      elToClone.setAttribute("aria-hidden", "true");
      if (options.keepToClone !== true) {
        elToClone.style.left = 0;
        elToClone.style.right = "unset";
        elToClone.style.top = 0;
        elToClone.style.bottom = "unset";
        elToClone.style.transform = "none";
        elToClone.style.pointerEvents = "none";
      }
      elToClone.classList.add("q-morph--internal");
      const elToNext = elTo === elFrom && elFromParent === elToParent ? elFromClone : elTo.nextElementSibling;
      elToParent.insertBefore(elToClone, elToNext);
      const {
        borderWidth: elToBorderWidth,
        borderStyle: elToBorderStyle,
        borderColor: elToBorderColor,
        borderRadius: elToBorderRadius,
        backgroundColor: elToBackground,
        transform: elToTransform,
        position: elToPositioningType,
        cssText: elToCssText
      } = getComputedStyle2(elTo, ["borderWidth", "borderStyle", "borderColor", "borderRadius", "backgroundColor", "transform", "position", "cssText"]);
      const elToClassSaved = elTo.classList.toString();
      const elToStyleSaved = elTo.style.cssText;
      elTo.style.cssText = elToCssText;
      elTo.style.transform = "none";
      elTo.style.animation = "none";
      elTo.style.transition = "none";
      elTo.className = elToClassSaved.split(" ").filter((c) => /^bg-/.test(c) === false).join(" ");
      const elToPosition = getAbsolutePosition(elTo, options.resize);
      const deltaX = elFromPosition.left - elToPosition.left;
      const deltaY = elFromPosition.top - elToPosition.top;
      const scaleX = elFromPosition.width / (elToPosition.width > 0 ? elToPosition.width : 10);
      const scaleY = elFromPosition.height / (elToPosition.height > 0 ? elToPosition.height : 100);
      const elFromParentWidthDiff = elFromParentWidthBefore - elFromParentWidthAfter;
      const elFromParentHeightDiff = elFromParentHeightBefore - elFromParentHeightAfter;
      const elToParentWidthDiff = elToParentWidthAfter - elToParentWidthBefore;
      const elToParentHeightDiff = elToParentHeightAfter - elToParentHeightBefore;
      const elFromCloneWidth = Math.max(elFromPosition.widthM, elFromParentWidthDiff);
      const elFromCloneHeight = Math.max(elFromPosition.heightM, elFromParentHeightDiff);
      const elToCloneWidth = Math.max(elToPosition.widthM, elToParentWidthDiff);
      const elToCloneHeight = Math.max(elToPosition.heightM, elToParentHeightDiff);
      const elSharedSize = elFrom === elTo && ["absolute", "fixed"].includes(elToPositioningType) === false && ["absolute", "fixed"].includes(elFromPositioningType) === false;
      let elToNeedsFixedPosition = elToPositioningType === "fixed";
      let parent = elToParent;
      while (elToNeedsFixedPosition !== true && parent !== document) {
        elToNeedsFixedPosition = window.getComputedStyle(parent).position === "fixed";
        parent = parent.parentNode;
      }
      if (options.hideFromClone !== true) {
        elFromClone.style.display = "block";
        elFromClone.style.flex = "0 0 auto";
        elFromClone.style.opacity = 0;
        elFromClone.style.minWidth = "unset";
        elFromClone.style.maxWidth = "unset";
        elFromClone.style.minHeight = "unset";
        elFromClone.style.maxHeight = "unset";
        elFromClone.classList.remove("q-morph--internal");
      }
      if (options.keepToClone !== true) {
        elToClone.style.display = "block";
        elToClone.style.flex = "0 0 auto";
        elToClone.style.opacity = 0;
        elToClone.style.minWidth = "unset";
        elToClone.style.maxWidth = "unset";
        elToClone.style.minHeight = "unset";
        elToClone.style.maxHeight = "unset";
      }
      elToClone.classList.remove("q-morph--internal");
      if (typeof options.classes === "string") {
        elTo.className += " " + options.classes;
      }
      if (typeof options.style === "string") {
        elTo.style.cssText += " " + options.style;
      } else if (isObject(options.style) === true) {
        for (const prop in options.style) {
          elTo.style[prop] = options.style[prop];
        }
      }
      const elFromZIndex = getMaxZIndex(elFromClone);
      const elToZIndex = getMaxZIndex(elTo);
      const documentScroll = elToNeedsFixedPosition === true ? document.documentElement : { scrollLeft: 0, scrollTop: 0 };
      elTo.style.position = elToNeedsFixedPosition === true ? "fixed" : "absolute";
      elTo.style.left = `${elToPosition.left - documentScroll.scrollLeft}px`;
      elTo.style.right = "unset";
      elTo.style.top = `${elToPosition.top - documentScroll.scrollTop}px`;
      elTo.style.margin = 0;
      if (options.resize === true) {
        elTo.style.minWidth = "unset";
        elTo.style.maxWidth = "unset";
        elTo.style.minHeight = "unset";
        elTo.style.maxHeight = "unset";
        elTo.style.overflow = "hidden";
        elTo.style.overflowX = "hidden";
        elTo.style.overflowY = "hidden";
      }
      document.body.appendChild(elTo);
      if (elFromTween !== void 0) {
        elFromTween.style.cssText = elFromCssText;
        elFromTween.style.transform = "none";
        elFromTween.style.animation = "none";
        elFromTween.style.transition = "none";
        elFromTween.style.position = elTo.style.position;
        elFromTween.style.left = `${elFromPosition.left - documentScroll.scrollLeft}px`;
        elFromTween.style.right = "unset";
        elFromTween.style.top = `${elFromPosition.top - documentScroll.scrollTop}px`;
        elFromTween.style.margin = 0;
        elFromTween.style.pointerEvents = "none";
        if (options.resize === true) {
          elFromTween.style.minWidth = "unset";
          elFromTween.style.maxWidth = "unset";
          elFromTween.style.minHeight = "unset";
          elFromTween.style.maxHeight = "unset";
          elFromTween.style.overflow = "hidden";
          elFromTween.style.overflowX = "hidden";
          elFromTween.style.overflowY = "hidden";
        }
        document.body.appendChild(elFromTween);
      }
      const commonCleanup = (aborted) => {
        if (elFrom === elTo && endElementTo !== true) {
          elTo.style.cssText = elFromStyleSaved;
          elTo.className = elFromClassSaved;
        } else {
          elTo.style.cssText = elToStyleSaved;
          elTo.className = elToClassSaved;
        }
        elToClone.parentNode === elToParent && elToParent.insertBefore(elTo, elToClone);
        elFromClone.remove();
        elToClone.remove();
        elFromTween !== void 0 && elFromTween.remove();
        cancel = () => false;
        elFrom.qMorphCancel = void 0;
        elTo.qMorphCancel = void 0;
        if (typeof options.onEnd === "function") {
          options.onEnd(endElementTo === true ? "to" : "from", aborted === true);
        }
      };
      if (options.useCSS !== true && typeof elTo.animate === "function") {
        const resizeFrom = options.resize === true ? {
          transform: `translate(${deltaX}px, ${deltaY}px)`,
          width: `${elFromCloneWidth}px`,
          height: `${elFromCloneHeight}px`
        } : {
          transform: `translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`
        };
        const resizeTo = options.resize === true ? {
          width: `${elToCloneWidth}px`,
          height: `${elToCloneHeight}px`
        } : {};
        const resizeFromTween = options.resize === true ? {
          width: `${elFromCloneWidth}px`,
          height: `${elFromCloneHeight}px`
        } : {};
        const resizeToTween = options.resize === true ? {
          transform: `translate(${-1 * deltaX}px, ${-1 * deltaY}px)`,
          width: `${elToCloneWidth}px`,
          height: `${elToCloneHeight}px`
        } : {
          transform: `translate(${-1 * deltaX}px, ${-1 * deltaY}px) scale(${1 / scaleX}, ${1 / scaleY})`
        };
        const tweenFrom = elFromTween !== void 0 ? { opacity: options.tweenToOpacity } : { backgroundColor: elFromBackground };
        const tweenTo = elFromTween !== void 0 ? { opacity: 1 } : { backgroundColor: elToBackground };
        animationTo = elTo.animate([
          {
            margin: 0,
            borderWidth: elFromBorderWidth,
            borderStyle: elFromBorderStyle,
            borderColor: elFromBorderColor,
            borderRadius: elFromBorderRadius,
            zIndex: elFromZIndex,
            transformOrigin: "0 0",
            ...resizeFrom,
            ...tweenFrom
          },
          {
            margin: 0,
            borderWidth: elToBorderWidth,
            borderStyle: elToBorderStyle,
            borderColor: elToBorderColor,
            borderRadius: elToBorderRadius,
            zIndex: elToZIndex,
            transformOrigin: "0 0",
            transform: elToTransform,
            ...resizeTo,
            ...tweenTo
          }
        ], {
          duration: options.duration,
          easing: options.easing,
          fill: options.fill,
          delay: options.delay
        });
        animationFromTween = elFromTween === void 0 ? void 0 : elFromTween.animate([
          {
            opacity: options.tweenFromOpacity,
            margin: 0,
            borderWidth: elFromBorderWidth,
            borderStyle: elFromBorderStyle,
            borderColor: elFromBorderColor,
            borderRadius: elFromBorderRadius,
            zIndex: elFromZIndex,
            transformOrigin: "0 0",
            transform: elFromTransform,
            ...resizeFromTween
          },
          {
            opacity: 0,
            margin: 0,
            borderWidth: elToBorderWidth,
            borderStyle: elToBorderStyle,
            borderColor: elToBorderColor,
            borderRadius: elToBorderRadius,
            zIndex: elToZIndex,
            transformOrigin: "0 0",
            ...resizeToTween
          }
        ], {
          duration: options.duration,
          easing: options.easing,
          fill: options.fill,
          delay: options.delay
        });
        animationFromClone = options.hideFromClone === true || elSharedSize === true ? void 0 : elFromClone.animate([
          {
            margin: `${elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0}px ${elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0}px`,
            width: `${elFromCloneWidth + elFromPosition.marginH}px`,
            height: `${elFromCloneHeight + elFromPosition.marginV}px`
          },
          {
            margin: 0,
            width: 0,
            height: 0
          }
        ], {
          duration: options.duration,
          easing: options.easing,
          fill: options.fill,
          delay: options.delay
        });
        animationToClone = options.keepToClone === true ? void 0 : elToClone.animate([
          elSharedSize === true ? {
            margin: `${elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0}px ${elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0}px`,
            width: `${elFromCloneWidth + elFromPosition.marginH}px`,
            height: `${elFromCloneHeight + elFromPosition.marginV}px`
          } : {
            margin: 0,
            width: 0,
            height: 0
          },
          {
            margin: `${elToParentHeightDiff < 0 ? elToParentHeightDiff / 2 : 0}px ${elToParentWidthDiff < 0 ? elToParentWidthDiff / 2 : 0}px`,
            width: `${elToCloneWidth + elToPosition.marginH}px`,
            height: `${elToCloneHeight + elToPosition.marginV}px`
          }
        ], {
          duration: options.duration,
          easing: options.easing,
          fill: options.fill,
          delay: options.delay
        });
        const cleanup = (abort) => {
          animationFromClone !== void 0 && animationFromClone.cancel();
          animationFromTween !== void 0 && animationFromTween.cancel();
          animationToClone !== void 0 && animationToClone.cancel();
          animationTo.cancel();
          animationTo.removeEventListener("finish", cleanup);
          animationTo.removeEventListener("cancel", cleanup);
          commonCleanup(abort);
          animationFromClone = void 0;
          animationFromTween = void 0;
          animationToClone = void 0;
          animationTo = void 0;
        };
        elFrom.qMorphCancel = () => {
          elFrom.qMorphCancel = void 0;
          cancelStatus = true;
          cleanup();
        };
        elTo.qMorphCancel = () => {
          elTo.qMorphCancel = void 0;
          cancelStatus = true;
          cleanup();
        };
        animationTo.addEventListener("finish", cleanup);
        animationTo.addEventListener("cancel", cleanup);
        cancel = (abort) => {
          if (cancelStatus === true || animationTo === void 0) {
            return false;
          }
          if (abort === true) {
            cleanup(true);
            return true;
          }
          endElementTo = endElementTo !== true;
          animationFromClone !== void 0 && animationFromClone.reverse();
          animationFromTween !== void 0 && animationFromTween.reverse();
          animationToClone !== void 0 && animationToClone.reverse();
          animationTo.reverse();
          return true;
        };
      } else {
        const qAnimId = `q-morph-anim-${++id2}`;
        const style2 = document.createElement("style");
        const resizeFrom = options.resize === true ? `
            transform: translate(${deltaX}px, ${deltaY}px);
            width: ${elFromCloneWidth}px;
            height: ${elFromCloneHeight}px;
          ` : `transform: translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY});`;
        const resizeTo = options.resize === true ? `
            width: ${elToCloneWidth}px;
            height: ${elToCloneHeight}px;
          ` : "";
        const resizeFromTween = options.resize === true ? `
            width: ${elFromCloneWidth}px;
            height: ${elFromCloneHeight}px;
          ` : "";
        const resizeToTween = options.resize === true ? `
            transform: translate(${-1 * deltaX}px, ${-1 * deltaY}px);
            width: ${elToCloneWidth}px;
            height: ${elToCloneHeight}px;
          ` : `transform: translate(${-1 * deltaX}px, ${-1 * deltaY}px) scale(${1 / scaleX}, ${1 / scaleY});`;
        const tweenFrom = elFromTween !== void 0 ? `opacity: ${options.tweenToOpacity};` : `background-color: ${elFromBackground};`;
        const tweenTo = elFromTween !== void 0 ? "opacity: 1;" : `background-color: ${elToBackground};`;
        const keyframesFromTween = elFromTween === void 0 ? "" : `
            @keyframes ${qAnimId}-from-tween {
              0% {
                opacity: ${options.tweenFromOpacity};
                margin: 0;
                border-width: ${elFromBorderWidth};
                border-style: ${elFromBorderStyle};
                border-color: ${elFromBorderColor};
                border-radius: ${elFromBorderRadius};
                z-index: ${elFromZIndex};
                transform-origin: 0 0;
                transform: ${elFromTransform};
                ${resizeFromTween}
              }

              100% {
                opacity: 0;
                margin: 0;
                border-width: ${elToBorderWidth};
                border-style: ${elToBorderStyle};
                border-color: ${elToBorderColor};
                border-radius: ${elToBorderRadius};
                z-index: ${elToZIndex};
                transform-origin: 0 0;
                ${resizeToTween}
              }
            }
          `;
        const keyframesFrom = options.hideFromClone === true || elSharedSize === true ? "" : `
            @keyframes ${qAnimId}-from {
              0% {
                margin: ${elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0}px ${elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0}px;
                width: ${elFromCloneWidth + elFromPosition.marginH}px;
                height: ${elFromCloneHeight + elFromPosition.marginV}px;
              }

              100% {
                margin: 0;
                width: 0;
                height: 0;
              }
            }
          `;
        const keyframeToStart = elSharedSize === true ? `
            margin: ${elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0}px ${elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0}px;
            width: ${elFromCloneWidth + elFromPosition.marginH}px;
            height: ${elFromCloneHeight + elFromPosition.marginV}px;
          ` : `
            margin: 0;
            width: 0;
            height: 0;
          `;
        const keyframesTo = options.keepToClone === true ? "" : `
            @keyframes ${qAnimId}-to {
              0% {
                ${keyframeToStart}
              }

              100% {
                margin: ${elToParentHeightDiff < 0 ? elToParentHeightDiff / 2 : 0}px ${elToParentWidthDiff < 0 ? elToParentWidthDiff / 2 : 0}px;
                width: ${elToCloneWidth + elToPosition.marginH}px;
                height: ${elToCloneHeight + elToPosition.marginV}px;
              }
            }
          `;
        style2.innerHTML = `
          @keyframes ${qAnimId} {
            0% {
              margin: 0;
              border-width: ${elFromBorderWidth};
              border-style: ${elFromBorderStyle};
              border-color: ${elFromBorderColor};
              border-radius: ${elFromBorderRadius};
              background-color: ${elFromBackground};
              z-index: ${elFromZIndex};
              transform-origin: 0 0;
              ${resizeFrom}
              ${tweenFrom}
            }

            100% {
              margin: 0;
              border-width: ${elToBorderWidth};
              border-style: ${elToBorderStyle};
              border-color: ${elToBorderColor};
              border-radius: ${elToBorderRadius};
              background-color: ${elToBackground};
              z-index: ${elToZIndex};
              transform-origin: 0 0;
              transform: ${elToTransform};
              ${resizeTo}
              ${tweenTo}
            }
          }

          ${keyframesFrom}

          ${keyframesFromTween}

          ${keyframesTo}
        `;
        document.head.appendChild(style2);
        let animationDirection = "normal";
        elFromClone.style.animation = `${options.duration}ms ${options.easing} ${options.delay}ms ${animationDirection} ${options.fill} ${qAnimId}-from`;
        if (elFromTween !== void 0) {
          elFromTween.style.animation = `${options.duration}ms ${options.easing} ${options.delay}ms ${animationDirection} ${options.fill} ${qAnimId}-from-tween`;
        }
        elToClone.style.animation = `${options.duration}ms ${options.easing} ${options.delay}ms ${animationDirection} ${options.fill} ${qAnimId}-to`;
        elTo.style.animation = `${options.duration}ms ${options.easing} ${options.delay}ms ${animationDirection} ${options.fill} ${qAnimId}`;
        const cleanup = (evt) => {
          if (evt === Object(evt) && evt.animationName !== qAnimId) {
            return;
          }
          elTo.removeEventListener("animationend", cleanup);
          elTo.removeEventListener("animationcancel", cleanup);
          commonCleanup();
          style2.remove();
        };
        elFrom.qMorphCancel = () => {
          elFrom.qMorphCancel = void 0;
          cancelStatus = true;
          cleanup();
        };
        elTo.qMorphCancel = () => {
          elTo.qMorphCancel = void 0;
          cancelStatus = true;
          cleanup();
        };
        elTo.addEventListener("animationend", cleanup);
        elTo.addEventListener("animationcancel", cleanup);
        cancel = (abort) => {
          if (cancelStatus === true || !elTo || !elFromClone || !elToClone) {
            return false;
          }
          if (abort === true) {
            cleanup();
            return true;
          }
          endElementTo = endElementTo !== true;
          animationDirection = animationDirection === "normal" ? "reverse" : "normal";
          elFromClone.style.animationDirection = animationDirection;
          elFromTween.style.animationDirection = animationDirection;
          elToClone.style.animationDirection = animationDirection;
          elTo.style.animationDirection = animationDirection;
          return true;
        };
      }
    };
    if (options.waitFor > 0 || options.waitFor === "transitionend" || options.waitFor === Object(options.waitFor) && typeof options.waitFor.then === "function") {
      const delayPromise = options.waitFor > 0 ? new Promise((resolve) => setTimeout(resolve, options.waitFor)) : options.waitFor === "transitionend" ? new Promise((resolve) => {
        const endFn = () => {
          if (timer2 !== null) {
            clearTimeout(timer2);
            timer2 = null;
          }
          if (elTo) {
            elTo.removeEventListener("transitionend", endFn);
            elTo.removeEventListener("transitioncancel", endFn);
          }
          resolve();
        };
        let timer2 = setTimeout(endFn, 400);
        elTo.addEventListener("transitionend", endFn);
        elTo.addEventListener("transitioncancel", endFn);
      }) : options.waitFor;
      delayPromise.then(animate).catch(() => {
        typeof elTo.qMorphCancel === "function" && elTo.qMorphCancel();
      });
    } else {
      animate();
    }
  };
  typeof _options.onToggle === "function" && _options.onToggle();
  requestAnimationFrame(calculateFinalState);
  return (abort) => cancel(abort);
}
var morphGroups = {};
var props2 = [
  "duration",
  "delay",
  "easing",
  "fill",
  "classes",
  "style",
  "duration",
  "resize",
  "useCSS",
  "hideFromClone",
  "keepToClone",
  "tween",
  "tweenFromOpacity",
  "tweenToOpacity",
  "waitFor",
  "onEnd"
];
var mods = [
  "resize",
  "useCSS",
  "hideFromClone",
  "keepToClone",
  "tween"
];
function changeClass(ctx, action) {
  if (ctx.clsAction !== action) {
    ctx.clsAction = action;
    ctx.el.classList[action]("q-morph--invisible");
  }
}
function trigger2(group) {
  if (group.animating === true || group.queue.length < 2) {
    return;
  }
  const [from, to] = group.queue;
  group.animating = true;
  from.animating = true;
  to.animating = true;
  changeClass(from, "remove");
  changeClass(to, "remove");
  const cancelFn = morph({
    from: from.el,
    to: to.el,
    onToggle() {
      changeClass(from, "add");
      changeClass(to, "remove");
    },
    ...to.opts,
    onEnd(dir, aborted) {
      to.opts.onEnd !== void 0 && to.opts.onEnd(dir, aborted);
      if (aborted === true) {
        return;
      }
      from.animating = false;
      to.animating = false;
      group.animating = false;
      group.cancel = void 0;
      group.queue.shift();
      trigger2(group);
    }
  });
  group.cancel = () => {
    cancelFn(true);
    group.cancel = void 0;
  };
}
function updateModifiers2(mod2, ctx) {
  const opts = ctx.opts;
  mods.forEach((name2) => {
    opts[name2] = mod2[name2] === true;
  });
}
function insertArgs(arg, ctx) {
  const opts = typeof arg === "string" && arg.length !== 0 ? arg.split(":") : [];
  ctx.name = opts[0];
  ctx.group = opts[1];
  Object.assign(ctx.opts, {
    duration: isNaN(opts[2]) === true ? 300 : parseFloat(opts[2]),
    waitFor: opts[3]
  });
}
function updateArgs(arg, ctx) {
  if (arg.group !== void 0) {
    ctx.group = arg.group;
  }
  if (arg.name !== void 0) {
    ctx.name = arg.name;
  }
  const opts = ctx.opts;
  props2.forEach((name2) => {
    if (arg[name2] !== void 0) {
      opts[name2] = arg[name2];
    }
  });
}
function updateModel(name2, ctx) {
  if (ctx.name === name2) {
    const group = morphGroups[ctx.group];
    if (group === void 0) {
      morphGroups[ctx.group] = {
        name: ctx.group,
        model: name2,
        queue: [ctx],
        animating: false
      };
      changeClass(ctx, "remove");
    } else if (group.model !== name2) {
      group.model = name2;
      group.queue.push(ctx);
      if (group.animating === false && group.queue.length === 2) {
        trigger2(group);
      }
    }
    return;
  }
  if (ctx.animating === false) {
    changeClass(ctx, "add");
  }
}
function updateValue(ctx, value2) {
  let model;
  if (Object(value2) === value2) {
    model = "" + value2.model;
    updateArgs(value2, ctx);
    updateModifiers2(value2, ctx);
  } else {
    model = "" + value2;
  }
  if (model !== ctx.model) {
    ctx.model = model;
    updateModel(model, ctx);
  } else if (ctx.animating === false && ctx.clsAction !== void 0) {
    ctx.el.classList[ctx.clsAction]("q-morph--invisible");
  }
}
createDirective(
  {
    name: "morph",
    mounted(el, binding) {
      const ctx = {
        el,
        animating: false,
        opts: {}
      };
      updateModifiers2(binding.modifiers, ctx);
      insertArgs(binding.arg, ctx);
      updateValue(ctx, binding.value);
      el.__qmorph = ctx;
    },
    updated(el, binding) {
      updateValue(el.__qmorph, binding.value);
    },
    beforeUnmount(el) {
      const ctx = el.__qmorph;
      const group = morphGroups[ctx.group];
      if (group !== void 0) {
        const index = group.queue.indexOf(ctx);
        if (index !== -1) {
          group.queue = group.queue.filter((item) => item !== ctx);
          if (group.queue.length === 0) {
            group.cancel !== void 0 && group.cancel();
            delete morphGroups[ctx.group];
          }
        }
      }
      if (ctx.clsAction === "add") {
        el.classList.remove("q-morph--invisible");
      }
      delete el.__qmorph;
    }
  }
);
var defaultCfg2 = {
  childList: true,
  subtree: true,
  attributes: true,
  characterData: true,
  attributeOldValue: true,
  characterDataOldValue: true
};
function update3(el, ctx, value2) {
  ctx.handler = value2;
  ctx.observer !== void 0 && ctx.observer.disconnect();
  ctx.observer = new MutationObserver((list) => {
    if (typeof ctx.handler === "function") {
      const res = ctx.handler(list);
      if (res === false || ctx.once === true) {
        destroy2(el);
      }
    }
  });
  ctx.observer.observe(el, ctx.opts);
}
function destroy2(el) {
  const ctx = el.__qmutation;
  if (ctx !== void 0) {
    ctx.observer !== void 0 && ctx.observer.disconnect();
    delete el.__qmutation;
  }
}
createDirective(
  {
    name: "mutation",
    mounted(el, { modifiers: { once, ...mod2 }, value: value2 }) {
      const ctx = {
        once,
        opts: Object.keys(mod2).length === 0 ? defaultCfg2 : mod2
      };
      update3(el, ctx, value2);
      el.__qmutation = ctx;
    },
    updated(el, { oldValue, value: value2 }) {
      const ctx = el.__qmutation;
      if (ctx !== void 0 && oldValue !== value2) {
        update3(el, ctx, value2);
      }
    },
    beforeUnmount: destroy2
  }
);
var { passive: passive5 } = listenOpts;
function update4(ctx, { value: value2, oldValue }) {
  if (typeof value2 !== "function") {
    ctx.scrollTarget.removeEventListener("scroll", ctx.scroll, passive5);
    return;
  }
  ctx.handler = value2;
  if (typeof oldValue !== "function") {
    ctx.scrollTarget.addEventListener("scroll", ctx.scroll, passive5);
    ctx.scroll();
  }
}
createDirective(
  {
    name: "scroll-fire",
    mounted(el, binding) {
      const ctx = {
        scrollTarget: getScrollTarget(el),
        scroll: debounce_default(() => {
          let containerBottom, elBottom;
          if (ctx.scrollTarget === window) {
            elBottom = el.getBoundingClientRect().bottom;
            containerBottom = window.innerHeight;
          } else {
            elBottom = offset(el).top + height(el);
            containerBottom = offset(ctx.scrollTarget).top + height(ctx.scrollTarget);
          }
          if (elBottom > 0 && elBottom < containerBottom) {
            ctx.scrollTarget.removeEventListener("scroll", ctx.scroll, passive5);
            ctx.handler(el);
          }
        }, 25)
      };
      update4(ctx, binding);
      el.__qscrollfire = ctx;
    },
    updated(el, binding) {
      if (binding.value !== binding.oldValue) {
        update4(el.__qscrollfire, binding);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qscrollfire;
      ctx.scrollTarget.removeEventListener("scroll", ctx.scroll, passive5);
      ctx.scroll.cancel();
      delete el.__qscrollfire;
    }
  }
);
function update5(ctx, { value: value2, oldValue }) {
  if (typeof value2 !== "function") {
    ctx.scrollTarget.removeEventListener("scroll", ctx.scroll, listenOpts.passive);
    return;
  }
  ctx.handler = value2;
  if (typeof oldValue !== "function") {
    ctx.scrollTarget.addEventListener("scroll", ctx.scroll, listenOpts.passive);
  }
}
createDirective(
  {
    name: "scroll",
    mounted(el, binding) {
      const ctx = {
        scrollTarget: getScrollTarget(el),
        scroll() {
          ctx.handler(
            getVerticalScrollPosition(ctx.scrollTarget),
            getHorizontalScrollPosition(ctx.scrollTarget)
          );
        }
      };
      update5(ctx, binding);
      el.__qscroll = ctx;
    },
    updated(el, binding) {
      if (el.__qscroll !== void 0 && binding.oldValue !== binding.value) {
        update5(el.__qscroll, binding);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qscroll;
      ctx.scrollTarget.removeEventListener("scroll", ctx.scroll, listenOpts.passive);
      delete el.__qscroll;
    }
  }
);
createDirective(
  {
    name: "touch-hold",
    beforeMount(el, binding) {
      const { modifiers } = binding;
      if (modifiers.mouse !== true && client.has.touch !== true) {
        return;
      }
      const ctx = {
        handler: binding.value,
        noop,
        mouseStart(evt) {
          if (typeof ctx.handler === "function" && leftClick(evt) === true) {
            addEvt(ctx, "temp", [
              [document, "mousemove", "move", "passiveCapture"],
              [document, "click", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt, true);
          }
        },
        touchStart(evt) {
          if (evt.target !== void 0 && typeof ctx.handler === "function") {
            const target2 = evt.target;
            addEvt(ctx, "temp", [
              [target2, "touchmove", "move", "passiveCapture"],
              [target2, "touchcancel", "end", "notPassiveCapture"],
              [target2, "touchend", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt);
          }
        },
        start(evt, mouseEvent) {
          ctx.origin = position(evt);
          const startTime = Date.now();
          if (client.is.mobile === true) {
            document.body.classList.add("non-selectable");
            clearSelection();
            ctx.styleCleanup = (withDelay) => {
              ctx.styleCleanup = void 0;
              const remove2 = () => {
                document.body.classList.remove("non-selectable");
              };
              if (withDelay === true) {
                clearSelection();
                setTimeout(remove2, 10);
              } else {
                remove2();
              }
            };
          }
          ctx.triggered = false;
          ctx.sensitivity = mouseEvent === true ? ctx.mouseSensitivity : ctx.touchSensitivity;
          ctx.timer = setTimeout(() => {
            ctx.timer = void 0;
            clearSelection();
            ctx.triggered = true;
            ctx.handler({
              evt,
              touch: mouseEvent !== true,
              mouse: mouseEvent === true,
              position: ctx.origin,
              duration: Date.now() - startTime
            });
          }, ctx.duration);
        },
        move(evt) {
          const { top, left } = position(evt);
          if (ctx.timer !== void 0 && (Math.abs(left - ctx.origin.left) >= ctx.sensitivity || Math.abs(top - ctx.origin.top) >= ctx.sensitivity)) {
            clearTimeout(ctx.timer);
            ctx.timer = void 0;
          }
        },
        end(evt) {
          cleanEvt(ctx, "temp");
          ctx.styleCleanup !== void 0 && ctx.styleCleanup(ctx.triggered);
          if (ctx.triggered === true) {
            evt !== void 0 && stopAndPrevent(evt);
          } else if (ctx.timer !== void 0) {
            clearTimeout(ctx.timer);
            ctx.timer = void 0;
          }
        }
      };
      const data = [600, 5, 7];
      if (typeof binding.arg === "string" && binding.arg.length !== 0) {
        binding.arg.split(":").forEach((val, index) => {
          const v2 = parseInt(val, 10);
          v2 && (data[index] = v2);
        });
      }
      [ctx.duration, ctx.touchSensitivity, ctx.mouseSensitivity] = data;
      el.__qtouchhold = ctx;
      if (modifiers.mouse === true) {
        const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true ? "Capture" : "";
        addEvt(ctx, "main", [
          [el, "mousedown", "mouseStart", `passive${capture}`]
        ]);
      }
      client.has.touch === true && addEvt(ctx, "main", [
        [el, "touchstart", "touchStart", `passive${modifiers.capture === true ? "Capture" : ""}`],
        [el, "touchend", "noop", "notPassiveCapture"]
      ]);
    },
    updated(el, binding) {
      const ctx = el.__qtouchhold;
      if (ctx !== void 0 && binding.oldValue !== binding.value) {
        typeof binding.value !== "function" && ctx.end();
        ctx.handler = binding.value;
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qtouchhold;
      if (ctx !== void 0) {
        cleanEvt(ctx, "main");
        cleanEvt(ctx, "temp");
        ctx.timer !== void 0 && clearTimeout(ctx.timer);
        ctx.styleCleanup !== void 0 && ctx.styleCleanup();
        delete el.__qtouchhold;
      }
    }
  }
);
var keyCodes3 = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  delete: [8, 46]
};
var keyRegex = new RegExp(`^([\\d+]+|${Object.keys(keyCodes3).join("|")})$`, "i");
function shouldEnd(evt, origin) {
  const { top, left } = position(evt);
  return Math.abs(left - origin.left) >= 7 || Math.abs(top - origin.top) >= 7;
}
createDirective(
  {
    name: "touch-repeat",
    beforeMount(el, { modifiers, value: value2, arg }) {
      const keyboard = Object.keys(modifiers).reduce((acc, key) => {
        if (keyRegex.test(key) === true) {
          const keyCode = isNaN(parseInt(key, 10)) ? keyCodes3[key.toLowerCase()] : parseInt(key, 10);
          keyCode >= 0 && acc.push(keyCode);
        }
        return acc;
      }, []);
      if (modifiers.mouse !== true && client.has.touch !== true && keyboard.length === 0) {
        return;
      }
      const durations = typeof arg === "string" && arg.length !== 0 ? arg.split(":").map((val) => parseInt(val, 10)) : [0, 600, 300];
      const durationsLast = durations.length - 1;
      const ctx = {
        keyboard,
        handler: value2,
        noop,
        mouseStart(evt) {
          if (ctx.event === void 0 && typeof ctx.handler === "function" && leftClick(evt) === true) {
            addEvt(ctx, "temp", [
              [document, "mousemove", "move", "passiveCapture"],
              [document, "click", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt, true);
          }
        },
        keyboardStart(evt) {
          if (typeof ctx.handler === "function" && isKeyCode(evt, keyboard) === true) {
            if (durations[0] === 0 || ctx.event !== void 0) {
              stopAndPrevent(evt);
              el.focus();
              if (ctx.event !== void 0) {
                return;
              }
            }
            addEvt(ctx, "temp", [
              [document, "keyup", "end", "notPassiveCapture"],
              [document, "click", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt, false, true);
          }
        },
        touchStart(evt) {
          if (evt.target !== void 0 && typeof ctx.handler === "function") {
            const target2 = evt.target;
            addEvt(ctx, "temp", [
              [target2, "touchmove", "move", "passiveCapture"],
              [target2, "touchcancel", "end", "notPassiveCapture"],
              [target2, "touchend", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt);
          }
        },
        start(evt, mouseEvent, keyboardEvent) {
          if (keyboardEvent !== true) {
            ctx.origin = position(evt);
          }
          function styleCleanup(withDelay) {
            ctx.styleCleanup = void 0;
            document.documentElement.style.cursor = "";
            const remove2 = () => {
              document.body.classList.remove("non-selectable");
            };
            if (withDelay === true) {
              clearSelection();
              setTimeout(remove2, 10);
            } else {
              remove2();
            }
          }
          if (client.is.mobile === true) {
            document.body.classList.add("non-selectable");
            clearSelection();
            ctx.styleCleanup = styleCleanup;
          }
          ctx.event = {
            touch: mouseEvent !== true && keyboardEvent !== true,
            mouse: mouseEvent === true,
            keyboard: keyboardEvent === true,
            startTime: Date.now(),
            repeatCount: 0
          };
          const fn = () => {
            ctx.timer = void 0;
            if (ctx.event === void 0) {
              return;
            }
            if (ctx.event.repeatCount === 0) {
              ctx.event.evt = evt;
              if (keyboardEvent === true) {
                ctx.event.keyCode = evt.keyCode;
              } else {
                ctx.event.position = position(evt);
              }
              if (client.is.mobile !== true) {
                document.documentElement.style.cursor = "pointer";
                document.body.classList.add("non-selectable");
                clearSelection();
                ctx.styleCleanup = styleCleanup;
              }
            }
            ctx.event.duration = Date.now() - ctx.event.startTime;
            ctx.event.repeatCount += 1;
            ctx.handler(ctx.event);
            const index = durationsLast < ctx.event.repeatCount ? durationsLast : ctx.event.repeatCount;
            ctx.timer = setTimeout(fn, durations[index]);
          };
          if (durations[0] === 0) {
            fn();
          } else {
            ctx.timer = setTimeout(fn, durations[0]);
          }
        },
        move(evt) {
          if (ctx.event !== void 0 && ctx.timer !== void 0 && shouldEnd(evt, ctx.origin) === true) {
            clearTimeout(ctx.timer);
            ctx.timer = void 0;
          }
        },
        end(evt) {
          if (ctx.event === void 0) {
            return;
          }
          ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);
          evt !== void 0 && ctx.event.repeatCount > 0 && stopAndPrevent(evt);
          cleanEvt(ctx, "temp");
          if (ctx.timer !== void 0) {
            clearTimeout(ctx.timer);
            ctx.timer = void 0;
          }
          ctx.event = void 0;
        }
      };
      el.__qtouchrepeat = ctx;
      if (modifiers.mouse === true) {
        const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true ? "Capture" : "";
        addEvt(ctx, "main", [
          [el, "mousedown", "mouseStart", `passive${capture}`]
        ]);
      }
      client.has.touch === true && addEvt(ctx, "main", [
        [el, "touchstart", "touchStart", `passive${modifiers.capture === true ? "Capture" : ""}`],
        [el, "touchend", "noop", "passiveCapture"]
      ]);
      if (keyboard.length !== 0) {
        const capture = modifiers.keyCapture === true || modifiers.keycapture === true ? "Capture" : "";
        addEvt(ctx, "main", [
          [el, "keydown", "keyboardStart", `notPassive${capture}`]
        ]);
      }
    },
    updated(el, { oldValue, value: value2 }) {
      const ctx = el.__qtouchrepeat;
      if (ctx !== void 0 && oldValue !== value2) {
        typeof value2 !== "function" && ctx.end();
        ctx.handler = value2;
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qtouchrepeat;
      if (ctx !== void 0) {
        ctx.timer !== void 0 && clearTimeout(ctx.timer);
        cleanEvt(ctx, "main");
        cleanEvt(ctx, "temp");
        ctx.styleCleanup !== void 0 && ctx.styleCleanup();
        delete el.__qtouchrepeat;
      }
    }
  }
);
function getCssVar(propName, element = document.body) {
  if (!(element instanceof Element)) {
    throw new TypeError("Expected a DOM element");
  }
  return getComputedStyle(element).getPropertyValue(`--q-${propName}`).trim() || null;
}
var metaValue;
function getProp() {
  return client.is.winphone ? "msapplication-navbutton-color" : client.is.safari ? "apple-mobile-web-app-status-bar-style" : "theme-color";
}
function getMetaTag(v2) {
  const els = document.getElementsByTagName("META");
  for (const i in els) {
    if (els[i].name === v2) {
      return els[i];
    }
  }
}
function setColor(hexColor) {
  if (metaValue === void 0) {
    metaValue = getProp();
  }
  let metaTag = getMetaTag(metaValue);
  const newTag = metaTag === void 0;
  if (newTag) {
    metaTag = document.createElement("meta");
    metaTag.setAttribute("name", metaValue);
  }
  metaTag.setAttribute("content", hexColor);
  if (newTag) {
    document.head.appendChild(metaTag);
  }
}
({
  set: client.is.mobile === true && (client.is.nativeMobile === true || client.is.winphone === true || client.is.safari === true || client.is.webkit === true || client.is.vivaldi === true) ? (hexColor) => {
    const val = hexColor || getCssVar("primary");
    if (client.is.nativeMobile === true && window.StatusBar) {
      window.StatusBar.backgroundColorByHexString(val);
    } else {
      setColor(val);
    }
  } : noop,
  install({ $q }) {
    $q.addressbarColor = this;
    $q.config.addressbarColor && this.set($q.config.addressbarColor);
  }
});
var prefixes = {};
function assignFn(fn) {
  Object.assign(Plugin4, {
    request: fn,
    exit: fn,
    toggle: fn
  });
}
function getFullscreenElement() {
  return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement || null;
}
function updateEl() {
  const newEl = Plugin4.activeEl = Plugin4.isActive === false ? null : getFullscreenElement();
  changeGlobalNodesTarget(
    newEl === null || newEl === document.documentElement ? document.body : newEl
  );
}
function togglePluginState() {
  Plugin4.isActive = Plugin4.isActive === false;
  updateEl();
}
function promisify(target2, fn) {
  try {
    const res = target2[fn]();
    return res === void 0 ? Promise.resolve() : res;
  } catch (err) {
    return Promise.reject(err);
  }
}
var Plugin4 = createReactivePlugin({
  isActive: false,
  activeEl: null
}, {
  isCapable: false,
  install({ $q }) {
    $q.fullscreen = this;
  }
});
{
  prefixes.request = [
    "requestFullscreen",
    "msRequestFullscreen",
    "mozRequestFullScreen",
    "webkitRequestFullscreen"
  ].find((request) => document.documentElement[request] !== void 0);
  Plugin4.isCapable = prefixes.request !== void 0;
  if (Plugin4.isCapable === false) {
    assignFn(() => Promise.reject("Not capable"));
  } else {
    Object.assign(Plugin4, {
      request(target2) {
        const el = target2 || document.documentElement;
        const { activeEl } = Plugin4;
        if (el === activeEl) {
          return Promise.resolve();
        }
        const queue2 = activeEl !== null && el.contains(activeEl) === true ? Plugin4.exit() : Promise.resolve();
        return queue2.finally(() => promisify(el, prefixes.request));
      },
      exit() {
        return Plugin4.isActive === true ? promisify(document, prefixes.exit) : Promise.resolve();
      },
      toggle(target2) {
        return Plugin4.isActive === true ? Plugin4.exit() : Plugin4.request(target2);
      }
    });
    prefixes.exit = [
      "exitFullscreen",
      "msExitFullscreen",
      "mozCancelFullScreen",
      "webkitExitFullscreen"
    ].find((exit) => document[exit]);
    Plugin4.isActive = Boolean(getFullscreenElement());
    Plugin4.isActive === true && updateEl();
    [
      "onfullscreenchange",
      "onmsfullscreenchange",
      "onwebkitfullscreenchange"
    ].forEach((evt) => {
      document[evt] = togglePluginState;
    });
  }
}
var Plugin5 = createReactivePlugin({
  appVisible: true
}, {
  install({ $q }) {
    injectProp($q, "appVisible", () => this.appVisible);
  }
});
{
  let prop, evt;
  if (typeof document.hidden !== "undefined") {
    prop = "hidden";
    evt = "visibilitychange";
  } else if (typeof document.msHidden !== "undefined") {
    prop = "msHidden";
    evt = "msvisibilitychange";
  } else if (typeof document.webkitHidden !== "undefined") {
    prop = "webkitHidden";
    evt = "webkitvisibilitychange";
  }
  if (evt && typeof document[prop] !== "undefined") {
    const update6 = () => {
      Plugin5.appVisible = !document[prop];
    };
    document.addEventListener(evt, update6, false);
  }
}
createComponent({
  name: "BottomSheetComponent",
  props: {
    ...useDarkProps,
    title: String,
    message: String,
    actions: Array,
    grid: Boolean,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  emits: ["ok", "hide"],
  setup(props4, { emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const isDark = use_dark_default(props4, proxy.$q);
    const dialogRef = ref(null);
    function show() {
      dialogRef.value.show();
    }
    function hide() {
      dialogRef.value.hide();
    }
    function onOk(action) {
      emit2("ok", action);
      hide();
    }
    function onHide() {
      emit2("hide");
    }
    function getGrid() {
      return props4.actions.map((action) => {
        const img = action.avatar || action.img;
        return action.label === void 0 ? h(QSeparator_default, {
          class: "col-all",
          dark: isDark.value
        }) : h("div", {
          class: [
            "q-bottom-sheet__item q-hoverable q-focusable cursor-pointer relative-position",
            action.class
          ],
          style: action.style,
          tabindex: 0,
          role: "listitem",
          onClick() {
            onOk(action);
          },
          onKeyup(e) {
            e.keyCode === 13 && onOk(action);
          }
        }, [
          h("div", { class: "q-focus-helper" }),
          action.icon ? h(QIcon_default, { name: action.icon, color: action.color }) : img ? h("img", {
            class: action.avatar ? "q-bottom-sheet__avatar" : "",
            src: img
          }) : h("div", { class: "q-bottom-sheet__empty-icon" }),
          h("div", action.label)
        ]);
      });
    }
    function getList() {
      return props4.actions.map((action) => {
        const img = action.avatar || action.img;
        return action.label === void 0 ? h(QSeparator_default, { spaced: true, dark: isDark.value }) : h(QItem_default, {
          class: ["q-bottom-sheet__item", action.classes],
          style: action.style,
          tabindex: 0,
          clickable: true,
          dark: isDark.value,
          onClick() {
            onOk(action);
          }
        }, () => [
          h(
            QItemSection_default,
            { avatar: true },
            () => action.icon ? h(QIcon_default, { name: action.icon, color: action.color }) : img ? h("img", {
              class: action.avatar ? "q-bottom-sheet__avatar" : "",
              src: img
            }) : null
          ),
          h(QItemSection_default, () => action.label)
        ]);
      });
    }
    function getCardContent() {
      const child = [];
      props4.title && child.push(
        h(QCardSection_default, {
          class: "q-dialog__title"
        }, () => props4.title)
      );
      props4.message && child.push(
        h(QCardSection_default, {
          class: "q-dialog__message"
        }, () => props4.message)
      );
      child.push(
        props4.grid === true ? h("div", {
          class: "row items-stretch justify-start",
          role: "list"
        }, getGrid()) : h("div", {
          role: "list"
        }, getList())
      );
      return child;
    }
    function getContent() {
      return [
        h(QCard_default, {
          class: [
            `q-bottom-sheet q-bottom-sheet--${props4.grid === true ? "grid" : "list"}` + (isDark.value === true ? " q-bottom-sheet--dark q-dark" : ""),
            props4.cardClass
          ],
          style: props4.cardStyle
        }, getCardContent)
      ];
    }
    Object.assign(proxy, { show, hide });
    return () => h(QDialog_default, {
      ref: dialogRef,
      position: "bottom",
      onHide
    }, getContent);
  }
});
function encode(string) {
  return encodeURIComponent(string);
}
function decode(string) {
  return decodeURIComponent(string);
}
function stringifyCookieValue(value2) {
  return encode(value2 === Object(value2) ? JSON.stringify(value2) : "" + value2);
}
function read(string) {
  if (string === "") {
    return string;
  }
  if (string.indexOf('"') === 0) {
    string = string.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, "\\");
  }
  string = decode(string.replace(/\+/g, " "));
  try {
    const parsed = JSON.parse(string);
    if (parsed === Object(parsed) || Array.isArray(parsed) === true) {
      string = parsed;
    }
  } catch (_) {
  }
  return string;
}
function getString(msOffset) {
  const time = /* @__PURE__ */ new Date();
  time.setMilliseconds(time.getMilliseconds() + msOffset);
  return time.toUTCString();
}
function parseExpireString(str) {
  let timestamp = 0;
  const days = str.match(/(\d+)d/);
  const hours = str.match(/(\d+)h/);
  const minutes = str.match(/(\d+)m/);
  const seconds = str.match(/(\d+)s/);
  if (days) {
    timestamp += days[1] * 864e5;
  }
  if (hours) {
    timestamp += hours[1] * 36e5;
  }
  if (minutes) {
    timestamp += minutes[1] * 6e4;
  }
  if (seconds) {
    timestamp += seconds[1] * 1e3;
  }
  return timestamp === 0 ? str : getString(timestamp);
}
function set(key, val, opts = {}, ssr) {
  let expire, expireValue;
  if (opts.expires !== void 0) {
    if (Object.prototype.toString.call(opts.expires) === "[object Date]") {
      expire = opts.expires.toUTCString();
    } else if (typeof opts.expires === "string") {
      expire = parseExpireString(opts.expires);
    } else {
      expireValue = parseFloat(opts.expires);
      expire = isNaN(expireValue) === false ? getString(expireValue * 864e5) : opts.expires;
    }
  }
  const keyValue = `${encode(key)}=${stringifyCookieValue(val)}`;
  const cookie = [
    keyValue,
    expire !== void 0 ? "; Expires=" + expire : "",
    // use expires attribute, max-age is not supported by IE
    opts.path ? "; Path=" + opts.path : "",
    opts.domain ? "; Domain=" + opts.domain : "",
    opts.sameSite ? "; SameSite=" + opts.sameSite : "",
    opts.httpOnly ? "; HttpOnly" : "",
    opts.secure ? "; Secure" : "",
    opts.other ? "; " + opts.other : ""
  ].join("");
  {
    document.cookie = cookie;
  }
}
function get(key, ssr) {
  const cookieSource = document, cookies = cookieSource.cookie ? cookieSource.cookie.split("; ") : [], l = cookies.length;
  let result = key ? null : {}, i = 0, parts, name2, cookie;
  for (; i < l; i++) {
    parts = cookies[i].split("=");
    name2 = decode(parts.shift());
    cookie = parts.join("=");
    if (!key) {
      result[name2] = cookie;
    } else if (key === name2) {
      result = read(cookie);
      break;
    }
  }
  return result;
}
function remove(key, options, ssr) {
  set(
    key,
    "",
    { expires: -1, ...options }
  );
}
function has(key, ssr) {
  return get(key) !== null;
}
function getObject(ssr) {
  return {
    get: (key) => get(key),
    set: (key, val, opts) => set(key, val, opts),
    has: (key) => has(key),
    remove: (key, options) => remove(key, options),
    getAll: () => get(null)
  };
}
var Plugin6 = {
  install({ $q, ssrContext }) {
    $q.cookies = this;
  }
};
{
  Object.assign(Plugin6, getObject());
}
createComponent({
  name: "DialogPluginComponent",
  props: {
    ...useDarkProps,
    title: String,
    message: String,
    prompt: Object,
    options: Object,
    progress: [Boolean, Object],
    html: Boolean,
    ok: {
      type: [String, Object, Boolean],
      default: true
    },
    cancel: [String, Object, Boolean],
    focus: {
      type: String,
      default: "ok",
      validator: (v2) => ["ok", "cancel", "none"].includes(v2)
    },
    stackButtons: Boolean,
    color: String,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  emits: ["ok", "hide"],
  setup(props4, { emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = use_dark_default(props4, $q);
    const dialogRef = ref(null);
    const model = ref(
      props4.prompt !== void 0 ? props4.prompt.model : props4.options !== void 0 ? props4.options.model : void 0
    );
    const classes = computed(
      () => "q-dialog-plugin" + (isDark.value === true ? " q-dialog-plugin--dark q-dark" : "") + (props4.progress !== false ? " q-dialog-plugin--progress" : "")
    );
    const vmColor = computed(
      () => props4.color || (isDark.value === true ? "amber" : "primary")
    );
    const spinner = computed(() => props4.progress === false ? null : isObject(props4.progress) === true ? {
      component: props4.progress.spinner || QSpinner_default,
      props: { color: props4.progress.color || vmColor.value }
    } : {
      component: QSpinner_default,
      props: { color: vmColor.value }
    });
    const hasForm = computed(
      () => props4.prompt !== void 0 || props4.options !== void 0
    );
    const formProps = computed(() => {
      if (hasForm.value !== true) {
        return {};
      }
      const { model: model2, isValid: isValid2, items, ...formProps2 } = props4.prompt !== void 0 ? props4.prompt : props4.options;
      return formProps2;
    });
    const okLabel = computed(() => isObject(props4.ok) === true ? $q.lang.label.ok : props4.ok === true ? $q.lang.label.ok : props4.ok);
    const cancelLabel = computed(() => isObject(props4.cancel) === true ? $q.lang.label.cancel : props4.cancel === true ? $q.lang.label.cancel : props4.cancel);
    const okDisabled = computed(() => {
      if (props4.prompt !== void 0) {
        return props4.prompt.isValid !== void 0 && props4.prompt.isValid(model.value) !== true;
      }
      if (props4.options !== void 0) {
        return props4.options.isValid !== void 0 && props4.options.isValid(model.value) !== true;
      }
      return false;
    });
    const okProps = computed(() => ({
      color: vmColor.value,
      label: okLabel.value,
      ripple: false,
      disable: okDisabled.value,
      ...isObject(props4.ok) === true ? props4.ok : { flat: true },
      "data-autofocus": props4.focus === "ok" && hasForm.value !== true || void 0,
      onClick: onOk
    }));
    const cancelProps = computed(() => ({
      color: vmColor.value,
      label: cancelLabel.value,
      ripple: false,
      ...isObject(props4.cancel) === true ? props4.cancel : { flat: true },
      "data-autofocus": props4.focus === "cancel" && hasForm.value !== true || void 0,
      onClick: onCancel
    }));
    watch(() => props4.prompt && props4.prompt.model, onUpdateModel);
    watch(() => props4.options && props4.options.model, onUpdateModel);
    function show() {
      dialogRef.value.show();
    }
    function hide() {
      dialogRef.value.hide();
    }
    function onOk() {
      emit2("ok", toRaw(model.value));
      hide();
    }
    function onCancel() {
      hide();
    }
    function onDialogHide() {
      emit2("hide");
    }
    function onUpdateModel(val) {
      model.value = val;
    }
    function onInputKeyup(evt) {
      if (okDisabled.value !== true && props4.prompt.type !== "textarea" && isKeyCode(evt, 13) === true) {
        onOk();
      }
    }
    function getSection(classes2, text) {
      return props4.html === true ? h(QCardSection_default, {
        class: classes2,
        innerHTML: text
      }) : h(QCardSection_default, { class: classes2 }, () => text);
    }
    function getPrompt() {
      return [
        h(QInput_default, {
          color: vmColor.value,
          dense: true,
          autofocus: true,
          dark: isDark.value,
          ...formProps.value,
          modelValue: model.value,
          "onUpdate:modelValue": onUpdateModel,
          onKeyup: onInputKeyup
        })
      ];
    }
    function getOptions() {
      return [
        h(QOptionGroup_default, {
          color: vmColor.value,
          options: props4.options.items,
          dark: isDark.value,
          ...formProps.value,
          modelValue: model.value,
          "onUpdate:modelValue": onUpdateModel
        })
      ];
    }
    function getButtons() {
      const child = [];
      props4.cancel && child.push(
        h(QBtn_default, cancelProps.value)
      );
      props4.ok && child.push(
        h(QBtn_default, okProps.value)
      );
      return h(QCardActions_default, {
        class: props4.stackButtons === true ? "items-end" : "",
        vertical: props4.stackButtons,
        align: "right"
      }, () => child);
    }
    function getCardContent() {
      const child = [];
      props4.title && child.push(
        getSection("q-dialog__title", props4.title)
      );
      props4.progress !== false && child.push(
        h(
          QCardSection_default,
          { class: "q-dialog__progress" },
          () => h(spinner.value.component, spinner.value.props)
        )
      );
      props4.message && child.push(
        getSection("q-dialog__message", props4.message)
      );
      if (props4.prompt !== void 0) {
        child.push(
          h(
            QCardSection_default,
            { class: "scroll q-dialog-plugin__form" },
            getPrompt
          )
        );
      } else if (props4.options !== void 0) {
        child.push(
          h(QSeparator_default, { dark: isDark.value }),
          h(
            QCardSection_default,
            { class: "scroll q-dialog-plugin__form" },
            getOptions
          ),
          h(QSeparator_default, { dark: isDark.value })
        );
      }
      if (props4.ok || props4.cancel) {
        child.push(getButtons());
      }
      return child;
    }
    function getContent() {
      return [
        h(QCard_default, {
          class: [
            classes.value,
            props4.cardClass
          ],
          style: props4.cardStyle,
          dark: isDark.value
        }, getCardContent)
      ];
    }
    Object.assign(proxy, { show, hide });
    return () => h(QDialog_default, {
      ref: dialogRef,
      onHide: onDialogHide
    }, getContent);
  }
});
var app$1;
var vm;
var uid2 = 0;
var timeout = null;
var props3 = {};
var activeGroups = {};
var originalDefaults = {
  group: "__default_quasar_group__",
  delay: 0,
  message: false,
  html: false,
  spinnerSize: 80,
  spinnerColor: "",
  messageColor: "",
  backgroundColor: "",
  boxClass: "",
  spinner: QSpinner_default,
  customClass: ""
};
var defaults = { ...originalDefaults };
function registerProps(opts) {
  if (opts && opts.group !== void 0 && activeGroups[opts.group] !== void 0) {
    return Object.assign(activeGroups[opts.group], opts);
  }
  const newProps = isObject(opts) === true && opts.ignoreDefaults === true ? { ...originalDefaults, ...opts } : { ...defaults, ...opts };
  activeGroups[newProps.group] = newProps;
  return newProps;
}
var Plugin7 = createReactivePlugin({
  isActive: false
}, {
  show(opts) {
    props3 = registerProps(opts);
    const { group } = props3;
    Plugin7.isActive = true;
    if (app$1 !== void 0) {
      props3.uid = uid2;
      vm.$forceUpdate();
    } else {
      props3.uid = ++uid2;
      timeout !== null && clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = null;
        const el = createGlobalNode("q-loading");
        app$1 = createChildApp({
          name: "QLoading",
          setup() {
            onMounted(() => {
              prevent_scroll_default(true);
            });
            function onAfterLeave() {
              if (Plugin7.isActive !== true && app$1 !== void 0) {
                prevent_scroll_default(false);
                app$1.unmount(el);
                removeGlobalNode(el);
                app$1 = void 0;
                vm = void 0;
              }
            }
            function getContent() {
              if (Plugin7.isActive !== true) {
                return null;
              }
              const content = [
                h(props3.spinner, {
                  class: "q-loading__spinner",
                  color: props3.spinnerColor,
                  size: props3.spinnerSize
                })
              ];
              props3.message && content.push(
                h("div", {
                  class: "q-loading__message" + (props3.messageColor ? ` text-${props3.messageColor}` : ""),
                  [props3.html === true ? "innerHTML" : "textContent"]: props3.message
                })
              );
              return h("div", {
                class: "q-loading fullscreen flex flex-center z-max " + props3.customClass.trim(),
                key: props3.uid
              }, [
                h("div", {
                  class: "q-loading__backdrop" + (props3.backgroundColor ? ` bg-${props3.backgroundColor}` : "")
                }),
                h("div", {
                  class: "q-loading__box column items-center " + props3.boxClass
                }, content)
              ]);
            }
            return () => h(Transition, {
              name: "q-transition--fade",
              appear: true,
              onAfterLeave
            }, getContent);
          }
        }, Plugin7.__parentApp);
        vm = app$1.mount(el);
      }, props3.delay);
    }
    return (paramProps) => {
      if (paramProps === void 0 || Object(paramProps) !== paramProps) {
        Plugin7.hide(group);
        return;
      }
      Plugin7.show({ ...paramProps, group });
    };
  },
  hide(group) {
    if (Plugin7.isActive === true) {
      if (group === void 0) {
        activeGroups = {};
      } else if (activeGroups[group] === void 0) {
        return;
      } else {
        delete activeGroups[group];
        const keys = Object.keys(activeGroups);
        if (keys.length !== 0) {
          const lastGroup = keys[keys.length - 1];
          Plugin7.show({ group: lastGroup });
          return;
        }
      }
      if (timeout !== null) {
        clearTimeout(timeout);
        timeout = null;
      }
      Plugin7.isActive = false;
    }
  },
  setDefaults(opts) {
    {
      isObject(opts) === true && Object.assign(defaults, opts);
    }
  },
  install({ $q, parentApp }) {
    $q.loading = this;
    {
      Plugin7.__parentApp = parentApp;
      if ($q.config.loading !== void 0) {
        this.setDefaults($q.config.loading);
      }
    }
  }
});
var barRef = ref(null);
var Plugin8 = createReactivePlugin({
  isActive: false
}, {
  start: noop,
  stop: noop,
  increment: noop,
  setDefaults: noop,
  install({ $q, parentApp }) {
    $q.loadingBar = this;
    if (this.__installed === true) {
      if ($q.config.loadingBar !== void 0) {
        this.setDefaults($q.config.loadingBar);
      }
      return;
    }
    const props4 = ref(
      $q.config.loadingBar !== void 0 ? { ...$q.config.loadingBar } : {}
    );
    function onStart() {
      Plugin8.isActive = true;
    }
    function onStop() {
      Plugin8.isActive = false;
    }
    const el = createGlobalNode("q-loading-bar");
    createChildApp({
      name: "LoadingBar",
      // hide App from Vue devtools
      devtools: { hide: true },
      setup: () => () => h(QAjaxBar_default, { ...props4.value, onStart, onStop, ref: barRef })
    }, parentApp).mount(el);
    Object.assign(this, {
      start(speed) {
        barRef.value.start(speed);
      },
      stop() {
        barRef.value.stop();
      },
      increment() {
        barRef.value.increment.apply(null, arguments);
      },
      setDefaults(opts) {
        if (isObject(opts) === true) {
          Object.assign(props4.value, opts);
        }
      }
    });
  }
});
function encode2(value2) {
  if (isDate(value2) === true) {
    return "__q_date|" + value2.getTime();
  }
  if (isRegexp(value2) === true) {
    return "__q_expr|" + value2.source;
  }
  if (typeof value2 === "number") {
    return "__q_numb|" + value2;
  }
  if (typeof value2 === "boolean") {
    return "__q_bool|" + (value2 ? "1" : "0");
  }
  if (typeof value2 === "string") {
    return "__q_strn|" + value2;
  }
  if (typeof value2 === "function") {
    return "__q_strn|" + value2.toString();
  }
  if (value2 === Object(value2)) {
    return "__q_objt|" + JSON.stringify(value2);
  }
  return value2;
}
function decode2(value2) {
  const length = value2.length;
  if (length < 9) {
    return value2;
  }
  const type = value2.substring(0, 8);
  const source = value2.substring(9);
  switch (type) {
    case "__q_date":
      const number2 = Number(source);
      return new Date(Number.isNaN(number2) === true ? source : number2);
    case "__q_expr":
      return new RegExp(source);
    case "__q_numb":
      return Number(source);
    case "__q_bool":
      return Boolean(source === "1");
    case "__q_strn":
      return "" + source;
    case "__q_objt":
      return JSON.parse(source);
    default:
      return value2;
  }
}
function getEmptyStorage() {
  const getVal2 = () => null;
  return {
    has: () => false,
    // alias for hasItem; TODO: remove in Qv3
    hasItem: () => false,
    getLength: () => 0,
    getItem: getVal2,
    getIndex: getVal2,
    getKey: getVal2,
    getAll: () => {
    },
    getAllKeys: () => [],
    set: noop,
    // alias for setItem; TODO: remove in Qv3
    setItem: noop,
    remove: noop,
    // alias for removeItem; TODO: remove in Qv3
    removeItem: noop,
    clear: noop,
    isEmpty: () => true
  };
}
function getStorage(type) {
  const webStorage = window[type + "Storage"], get2 = (key) => {
    const item = webStorage.getItem(key);
    return item ? decode2(item) : null;
  };
  const hasItem = (key) => webStorage.getItem(key) !== null;
  const setItem = (key, value2) => {
    webStorage.setItem(key, encode2(value2));
  };
  const removeItem = (key) => {
    webStorage.removeItem(key);
  };
  return {
    has: hasItem,
    // TODO: remove in Qv3
    hasItem,
    getLength: () => webStorage.length,
    getItem: get2,
    getIndex: (index) => {
      return index < webStorage.length ? get2(webStorage.key(index)) : null;
    },
    getKey: (index) => {
      return index < webStorage.length ? webStorage.key(index) : null;
    },
    getAll: () => {
      let key;
      const result = {}, len = webStorage.length;
      for (let i = 0; i < len; i++) {
        key = webStorage.key(i);
        result[key] = get2(key);
      }
      return result;
    },
    getAllKeys: () => {
      const result = [], len = webStorage.length;
      for (let i = 0; i < len; i++) {
        result.push(webStorage.key(i));
      }
      return result;
    },
    set: setItem,
    // TODO: remove in Qv3
    setItem,
    remove: removeItem,
    // TODO: remove in Qv3
    removeItem,
    clear: () => {
      webStorage.clear();
    },
    isEmpty: () => webStorage.length === 0
  };
}
var storage = client.has.webStorage === false ? getEmptyStorage() : getStorage("local");
var Plugin9 = {
  install({ $q }) {
    $q.localStorage = storage;
  }
};
Object.assign(Plugin9, storage);
var storage2 = client.has.webStorage === false ? getEmptyStorage() : getStorage("session");
var Plugin10 = {
  install({ $q }) {
    $q.sessionStorage = storage2;
  }
};
Object.assign(Plugin10, storage2);
var emits2 = ["ok", "hide"];
get_emits_object_default(emits2);
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "Tooltip",
  props: {
    tooltipCSS: { type: String, required: false, default: "" },
    anchor: { type: String, required: false },
    self: { type: String, required: false },
    transitionShow: { type: String, required: false },
    transitionHide: { type: String, required: false },
    offset: { type: Array, required: false },
    target: { type: Object, required: false, default: void 0 },
    autoHide: { type: Boolean, required: false, default: false }
  },
  setup(__props) {
    const props4 = __props;
    const tt2 = ref(null);
    const onShow = () => {
      if (props4.autoHide) {
        setTimeout(() => {
          var _a;
          (_a = tt2.value) == null ? void 0 : _a.hide();
        }, 4e3);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(QTooltip_default, {
        class: normalizeClass("py-0.5 px-2 text-xs " + __props.tooltipCSS),
        anchor: __props.anchor,
        self: __props.self,
        "transition-show": __props.transitionShow,
        "transition-hide": __props.transitionHide,
        offset: __props.offset,
        delay: 550,
        target: __props.target,
        ref_key: "tt",
        ref: tt2,
        onShow
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "anchor", "self", "transition-show", "transition-hide", "offset", "target"]);
    };
  }
});
const _hoisted_1$3 = ["innerHTML"];
const _hoisted_2$3 = {
  key: 1,
  class: "col-span-12 flex flex-row flex-nowrap justify-start whitespace-pre-wrap"
};
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "GridText",
  props: {
    text: { type: String },
    html: { type: Boolean, required: false }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return __props.html ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "col-span-12 flex flex-row flex-nowrap justify-start whitespace-pre-wrap",
        innerHTML: __props.text
      }, null, 8, _hoisted_1$3)) : (openBlock(), createElementBlock("div", _hoisted_2$3, toDisplayString$1(__props.text), 1));
    };
  }
});
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "GridHeadline",
  props: {
    label: { type: String },
    dense: { type: Boolean, default: false },
    doCapitalize: { type: Boolean, default: true }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$7, {
        text: __props.label,
        class: normalizeClass(["cc-text-bold", __props.doCapitalize ? "capitalize" : ""])
      }, null, 8, ["text", "class"]);
    };
  }
});
const _hoisted_1$2 = { class: "w-full grid grid-cols-12 gap-1.5 cc-text-sz" };
const _hoisted_2$2 = {
  key: 0,
  class: "col-span-12 flex flex-row flex-nowrap justify-start items-start space-x-1"
};
const _hoisted_3$2 = ["innerHTML"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "GridTextArea",
  props: {
    label: { type: String, default: "" },
    text: { type: String, default: "" },
    isInfo: { type: Boolean, default: false },
    startCollapsed: { type: Boolean, default: false },
    infoHover: { type: String, default: "" },
    css: { type: String, default: "cc-bg-txdetails" },
    textCSS: { type: String, default: "flex-1 pr-1 flex items-center text-justify" },
    labelCss: { type: String, default: "" },
    icon: { type: String, default: null },
    animation: { type: String, default: null },
    error: { type: Boolean, default: false },
    dense: { type: Boolean, default: false },
    html: { type: Boolean, default: false },
    nopadding: { type: Boolean, default: false }
  },
  setup(__props) {
    const props4 = __props;
    const showInfo = ref(true);
    if (props4.isInfo && props4.startCollapsed) {
      showInfo.value = false;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        __props.isInfo ? (openBlock(), createElementBlock("div", _hoisted_2$2, [
          createBaseVNode("button", {
            type: "button",
            onClick: _cache[0] || (_cache[0] = withModifiers(($event) => showInfo.value = !showInfo.value, ["prevent", "stop"])),
            class: "flex flex-row"
          }, [
            __props.label ? (openBlock(), createBlock(_sfc_main$6, {
              key: 0,
              class: normalizeClass(__props.labelCss),
              label: __props.label,
              dense: ""
            }, null, 8, ["class", "label"])) : createCommentVNode("", true),
            createBaseVNode("i", {
              class: normalizeClass(["mt-px", showInfo.value ? "mdi mdi-chevron-down" : "mdi mdi-chevron-right"])
            }, [
              __props.infoHover ? (openBlock(), createBlock(_sfc_main$8, {
                key: 0,
                "transition-show": "scale",
                "transition-hide": "scale"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(__props.infoHover), 1)
                ]),
                _: 1
              })) : createCommentVNode("", true)
            ], 2)
          ])
        ])) : createCommentVNode("", true),
        showInfo.value ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["overflow-auto col-span-12 space-x-2.5 flex flex-row flex-nowrap whitespace-pre-wrap", __props.css + " " + (__props.nopadding ? "" : !__props.dense ? " px-2.5 py-2 sm:py-3 " : " px-2.5 py-1.5 ")])
        }, [
          __props.icon ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["cc-flex-fixed", __props.animation])
          }, [
            __props.icon ? (openBlock(), createElementBlock("i", {
              key: 0,
              class: normalizeClass(["text-xl sm:text-2xl", __props.icon])
            }, null, 2)) : createCommentVNode("", true)
          ], 2)) : createCommentVNode("", true),
          __props.html ? (openBlock(), createElementBlock("div", {
            key: 1,
            innerHTML: __props.text,
            class: normalizeClass(["w-full", __props.textCSS])
          }, null, 10, _hoisted_3$2)) : (openBlock(), createElementBlock("div", {
            key: 2,
            class: normalizeClass(["w-full", __props.textCSS])
          }, toDisplayString$1(__props.text), 3))
        ], 2)) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$1 = ["type", "form", "disabled"];
const _hoisted_2$1 = {
  key: 2,
  class: "flex flex-col flex-nowrap"
};
const _hoisted_3$1 = {
  key: 0,
  class: "text-xs sm:text-sm cc-text-normal cc-text-color-caption mt-0.5 sm:mt-1"
};
const _hoisted_4$1 = {
  key: 3,
  class: "mdi mdi-information-outline"
};
const _hoisted_5$1 = {
  key: 4,
  class: "absolute top-0 left-0 w-full h-full"
};
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "GridButton",
  props: {
    label: { type: String },
    caption: { type: String },
    icon: { type: String },
    iconClickable: { type: Boolean, default: false },
    type: { type: String, required: false, default: "button" },
    form: { type: String, required: false, default: "" },
    link: { type: Function, default: null },
    capitalize: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    disableTooltip: { type: String, required: false }
  },
  emits: ["iconClick"],
  setup(__props, { emit: __emit }) {
    const props4 = __props;
    const emit2 = __emit;
    useTranslation();
    const onIconClick = () => {
      if (props4.iconClickable) {
        emit2("iconClick");
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        class: normalizeClass(["relative cc-flex-fixed cursor-pointer min-w-0 focus:outline-none flex flex-row flex-nowrap justify-center items-center space-x-2", __props.disabled ? __props.disableTooltip ? "" : "cc-btn-disabled" : ""]),
        onClick: _cache[0] || (_cache[0] = withModifiers(($event) => {
          var _a;
          return (_a = __props.link) == null ? void 0 : _a.call(__props);
        }, ["stop"])),
        type: __props.type,
        form: __props.form,
        disabled: __props.disabled
      }, [
        __props.icon && __props.iconClickable ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: normalizeClass(["", __props.icon + (__props.iconClickable ? " hover:cc-text-color" : "")]),
          onClick: withModifiers(onIconClick, ["stop", "prevent"])
        }, null, 2)) : __props.icon ? (openBlock(), createElementBlock("i", {
          key: 1,
          class: normalizeClass(["", __props.icon])
        }, null, 2)) : createCommentVNode("", true),
        __props.label ? (openBlock(), createElementBlock("span", _hoisted_2$1, [
          createBaseVNode("span", {
            class: normalizeClass(__props.capitalize ? "capitalize" : "")
          }, toDisplayString$1(__props.label), 3),
          __props.caption ? (openBlock(), createElementBlock("span", _hoisted_3$1, toDisplayString$1(__props.caption), 1)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        __props.disableTooltip ? (openBlock(), createElementBlock("i", _hoisted_4$1)) : createCommentVNode("", true),
        __props.disableTooltip ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
          createVNode(_sfc_main$8, {
            "transition-show": "scale",
            "transition-hide": "scale"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString$1(__props.disableTooltip), 1)
            ]),
            _: 1
          })
        ])) : createCommentVNode("", true)
      ], 10, _hoisted_1$1);
    };
  }
});
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "GridButtonSecondary",
  props: {
    label: { type: String },
    caption: { type: String },
    icon: { type: String },
    iconClickable: { type: Boolean, default: false },
    type: { type: String, required: false, default: "button" },
    form: { type: String, required: false, default: "" },
    link: { type: Function, default: null },
    capitalize: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    disableTooltip: { type: String, required: false },
    active: { type: Boolean, required: false, default: false }
  },
  emits: ["iconClick"],
  setup(__props, { emit: __emit }) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$4, {
        label: __props.label,
        caption: __props.caption,
        icon: __props.icon,
        link: __props.link,
        type: __props.type,
        form: __props.form,
        disabled: __props.disabled,
        capitalize: __props.capitalize,
        disableTooltip: __props.disableTooltip,
        "icon-clickable": __props.iconClickable,
        class: normalizeClass(["py-2 text-center cc-text-md cc-text-semi-bold", __props.active ? "cc-btn-secondary-active" : "cc-btn-secondary"]),
        onIconClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("iconClick"))
      }, null, 8, ["label", "caption", "icon", "link", "type", "form", "disabled", "capitalize", "disableTooltip", "icon-clickable", "class"]);
    };
  }
});
const GridButtonSecondary = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-86e7ef96"]]);
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "GridButtonPrimary",
  props: {
    label: { type: String },
    caption: { type: String },
    icon: { type: String },
    iconClickable: { type: Boolean, default: false },
    type: { type: String, required: false, default: "button" },
    form: { type: String, required: false, default: "" },
    link: { type: Function, default: null },
    capitalize: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false }
  },
  emits: ["iconClick"],
  setup(__props, { emit: __emit }) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$4, {
        label: __props.label,
        caption: __props.caption,
        icon: __props.icon,
        link: __props.link,
        type: __props.type,
        form: __props.form,
        disabled: __props.disabled,
        capitalize: __props.capitalize,
        "icon-clickable": __props.iconClickable,
        class: "py-2 text-center cc-text-md cc-text-bold cc-btn-primary",
        onIconClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("iconClick"))
      }, null, 8, ["label", "caption", "icon", "link", "type", "form", "disabled", "capitalize", "icon-clickable"]);
    };
  }
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "GridButtonCountdown",
  props: {
    duration: { type: Number, default: 1 },
    label: { type: String },
    caption: { type: String },
    icon: { type: String },
    type: { type: String, required: false, default: "button" },
    form: { type: String, required: false, default: "" },
    link: { type: Function, default: null },
    capitalize: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false }
  },
  setup(__props) {
    const props4 = __props;
    const countDownFinished = ref(false);
    let secondsLeft = ref(10);
    secondsLeft.value = props4.duration;
    const id3 = setInterval(() => {
      secondsLeft.value -= 1;
      if (secondsLeft.value < 1) {
        secondsLeft.value = 0;
        countDownFinished.value = true;
        clearInterval(id3);
      }
    }, 1e3);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$2, {
        label: __props.label + (unref(secondsLeft) > 0 ? " (" + unref(secondsLeft) + ")" : ""),
        caption: __props.caption,
        icon: __props.icon,
        link: __props.link,
        type: __props.type,
        form: __props.form,
        capitalize: __props.capitalize,
        disabled: __props.disabled || !countDownFinished.value
      }, null, 8, ["label", "caption", "icon", "link", "type", "form", "capitalize", "disabled"]);
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "enable-layout w-full h-full flex flex-col flex-nowrap justify-between p-2 space-y-2"
};
const _hoisted_2 = { class: "cc-bg-white-0 cc-rounded h-full w-full p-4 flex flex-col flex-nowrap justify-between items-start space-y-2" };
const _hoisted_3 = {
  key: 0,
  class: "w-full flex justify-center items-center mt-4"
};
const _hoisted_4 = {
  key: 1,
  class: "cc-text-extra-bold cc-text-red-light text-3xl w-full flex justify-center items-center"
};
const _hoisted_5 = {
  key: 2,
  class: "text-xl"
};
const _hoisted_6 = ["innerHTML"];
const _hoisted_7 = {
  key: 3,
  class: "text-xl flex flex-col h-full justify-center items-center w-full text-center"
};
const _hoisted_8 = { class: "w-full flex flex-row justify-end items-end grow" };
const _hoisted_9 = {
  key: 1,
  class: "w-full h-full flex flex-col flex-nowrap space-y-4"
};
const _hoisted_10 = {
  key: 1,
  class: "space-y-2"
};
const _hoisted_11 = {
  key: 2,
  class: "w-full cc-flex-fixed grid grid-cols-12 cc-gap"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "EnableLayout",
  setup(__props) {
    const { it } = useTranslation();
    const initialized = ref(false);
    const reqId = window.location.search.split("=")[1];
    console.warn("reqId", reqId);
    const dappOrigin = ref("");
    const isHTTPS = ref(false);
    const extensionRequest = ref([]);
    const dAppAccountSet = computed(() => !!dappAccountId.value);
    const { isDomainOnBlockList } = useGuard();
    const isScam = ref(false);
    const ackScam = ref(false);
    let port = null;
    let _req = null;
    const handlePortMessage = async (req) => {
      var _a;
      _req = req;
      console.log("enable:handlePortMessage", req, dappAccountId.value);
      if (req.channel !== ApiChannel.bgToEnable) {
        return;
      }
      dappOrigin.value = req.payload.origin;
      isHTTPS.value = ((_a = dappOrigin.value) == null ? void 0 : _a.startsWith("https")) ?? false;
      extensionRequest.value = req.payload.extensions;
      isScam.value = await isDomainOnBlockList(dappOrigin.value);
      ackScam.value = !isScam.value;
      initialized.value = true;
    };
    const onConnect = () => {
      port == null ? void 0 : port.onMessage.removeListener(handlePortMessage);
      if (_req) {
        _req.channel = ApiChannel.enableToBg;
        _req.response = { success: true, isEnabled: true };
        addConnectedOrigin(_req.payload.origin, _req.payload.extensions);
        port == null ? void 0 : port.postMessage(_req);
      }
    };
    const onCancel = () => {
      port == null ? void 0 : port.onMessage.removeListener(handlePortMessage);
      if (_req) {
        _req.channel = ApiChannel.enableToBg;
        _req.response = errorConnectionRefused();
        port == null ? void 0 : port.postMessage(_req);
      }
    };
    const init2 = async () => {
      await sleep(200);
      port = chrome.runtime.connect({ name: ApiChannel.enableToBg + ":" + reqId });
      port.onMessage.addListener(handlePortMessage);
    };
    init2();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$a, null, {
        default: withCtx(() => [
          initialized.value ? (openBlock(), createElementBlock("div", _hoisted_1, [
            isScam.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass([!ackScam.value ? "absolute inset-2" : "relative h-1/3", "is-scam hazard-border cc-rounded flex flex-col flex-nowrap justify-center items-center p-4"])
            }, [
              createBaseVNode("div", _hoisted_2, [
                !ackScam.value ? (openBlock(), createElementBlock("div", _hoisted_3, _cache[0] || (_cache[0] = [
                  createBaseVNode("img", {
                    alt: "Eternl logo",
                    width: "128",
                    height: "128",
                    src: _imports_0$1
                  }, null, -1)
                ]))) : createCommentVNode("", true),
                !ackScam.value ? (openBlock(), createElementBlock("div", _hoisted_4, toDisplayString$1(unref(it)("common.scam.guard.warning")), 1)) : createCommentVNode("", true),
                !ackScam.value ? (openBlock(), createElementBlock("div", _hoisted_5, [
                  createTextVNode(toDisplayString$1(unref(it)("common.scam.app.description")) + " ", 1),
                  _cache[1] || (_cache[1] = createBaseVNode("br", null, null, -1)),
                  _cache[2] || (_cache[2] = createBaseVNode("br", null, null, -1)),
                  createBaseVNode("span", {
                    innerHTML: unref(it)("common.scam.app.description2")
                  }, null, 8, _hoisted_6)
                ])) : createCommentVNode("", true),
                ackScam.value ? (openBlock(), createElementBlock("div", _hoisted_7, toDisplayString$1(unref(it)("common.scam.app.ownRisk")), 1)) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_8, [
                  !ackScam.value ? (openBlock(), createBlock(_sfc_main$1, {
                    key: 0,
                    class: "px-4 py-2 h-12",
                    label: "Confirm risk!",
                    link: () => ackScam.value = true,
                    duration: 10
                  }, null, 8, ["link"])) : createCommentVNode("", true)
                ])
              ])
            ], 2)) : createCommentVNode("", true),
            ackScam.value ? (openBlock(), createElementBlock("div", _hoisted_9, [
              !dAppAccountSet.value ? (openBlock(), createBlock(_sfc_main$5, {
                key: 0,
                class: "cc-flex-fixed col-span-12 w-full",
                css: "cc-text-semi-bold cc-rounded cc-banner-warning",
                "text-c-s-s": "",
                text: unref(it)("wallet.bex.activateAccount"),
                icon: unref(it)("dapps.enable.access.info.icon")
              }, null, 8, ["text", "icon"])) : createCommentVNode("", true),
              dAppAccountSet.value ? (openBlock(), createBlock(_sfc_main$5, {
                key: 1,
                class: "cc-flex-fixed col-span-12 w-full",
                css: "cc-text-semi-bold cc-rounded cc-banner-blue",
                "text-c-s-s": "",
                html: "",
                text: unref(it)("dapps.enable.access.info.text"),
                icon: unref(it)("dapps.enable.access.info.icon") + " relative -top-1"
              }, null, 8, ["text", "icon"])) : createCommentVNode("", true),
              dAppAccountSet.value ? (openBlock(), createBlock(GridSpace, {
                key: 2,
                hr: "",
                label: unref(it)("dapps.enable.access.access.url"),
                "label-c-s-s": "cc-text-bold cc-text-sz",
                class: "w-full mb-4"
              }, null, 8, ["label"])) : createCommentVNode("", true),
              dAppAccountSet.value ? (openBlock(), createBlock(_sfc_main$5, {
                key: 3,
                class: "cc-flex-fixed col-span-12 w-full",
                "text-c-s-s": "cc-text-bold flex justify-start items-center",
                css: "cc-rounded " + (isHTTPS.value ? "cc-banner-green" : "cc-banner-warning"),
                text: dappOrigin.value + (!isHTTPS.value ? " (not secure)" : ""),
                icon: unref(it)("dapps.enable.access.url.icon")
              }, null, 8, ["css", "text", "icon"])) : createCommentVNode("", true),
              createBaseVNode("div", null, [
                dAppAccountSet.value ? (openBlock(), createBlock(GridSpace, {
                  key: 0,
                  hr: "",
                  label: unref(it)("dapps.enable.access.access.label"),
                  "label-c-s-s": "cc-text-bold cc-text-sz mb-0",
                  class: "w-full mb-4"
                }, null, 8, ["label"])) : createCommentVNode("", true),
                dAppAccountSet.value ? (openBlock(), createElementBlock("div", _hoisted_10, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(extensionRequest.value, (extension) => {
                    return openBlock(), createBlock(_sfc_main$5, {
                      key: extension.cip,
                      class: "cc-flex-fixed col-span-12 w-full",
                      css: "cc-text-semi-bold cc-rounded cc-banner-gray",
                      "text-c-s-s": "",
                      html: "",
                      text: "<b>" + unref(it)(`dapps.enable.access.cip${extension.cip}.label`) + "</b><br>" + unref(it)(`dapps.enable.access.cip${extension.cip}.description`),
                      icon: unref(it)(`dapps.enable.access.cip${extension.cip}.icon`) + " relative -top-1"
                    }, null, 8, ["text", "icon"]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ])
            ])) : createCommentVNode("", true),
            ackScam.value ? (openBlock(), createElementBlock("div", _hoisted_11, [
              createVNode(GridButtonSecondary, {
                label: "Cancel",
                link: onCancel,
                class: "col-span-6"
              }),
              isScam.value ? (openBlock(), createBlock(_sfc_main$1, {
                key: 0,
                class: "col-span-6",
                label: "Grant Access",
                link: onConnect,
                disabled: !dAppAccountSet.value,
                duration: 10
              }, null, 8, ["disabled"])) : (openBlock(), createBlock(_sfc_main$2, {
                key: 1,
                label: "Grant Access",
                link: onConnect,
                disabled: !dAppAccountSet.value,
                class: "col-span-6"
              }, null, 8, ["disabled"]))
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        _: 1
      });
    };
  }
});
const label = {
  project: "Eternl",
  name: "name",
  noname: "No Name",
  comment: "comment",
  key: "key",
  type: "type",
  address: "address",
  contract: "contract",
  pool: "pool",
  receiveAddress: "Receive Address",
  copyAddress: "Copy address",
  copyCred: "Copy payment credential",
  copyTx: "Copy Transaction Id",
  copied: "Copied:",
  exportAsCsv: "Export as CSV",
  notice: "Notice",
  pleaseNote: "Please note",
  privacyNotice: "Privacy Notice",
  action: "action",
  fullscreen: "fullscreen",
  addrbook: "Address Book",
  quickaccess: "Quick Access",
  resolve: "Resolve",
  minutes: "minutes",
  add: "add",
  max: "max",
  apply: "apply",
  edit: "edit",
  back: "back",
  next: "next",
  save: "save",
  sign: "sign",
  discover: "discover",
  dismiss: "dismiss",
  delete: "delete",
  retry: "retry",
  close: "close",
  cancel: "cancel",
  reset: "reset",
  clear: "clear",
  default: "default",
  confirm: "confirm",
  activate: "activate",
  activeAccount: "active account",
  remove: "remove",
  submit: "submit",
  continue: "continue",
  password: "password",
  finish: "finish",
  send: "send",
  sendAll: "send all",
  download: "download",
  import: "import",
  importWallet: "import wallet",
  select: "select",
  selectFile: "Select file",
  clickToSelect: "Click to Select",
  generate: "generate",
  register: "register",
  mint: "mint",
  burn: "burn",
  build: "build",
  overwrite: "overwrite",
  swap: "swap",
  refresh: "refresh",
  preview: "Preview",
  detailedmode: "Detailed Mode",
  simplemode: "Simple Mode",
  verifiedmode: "Only Verified",
  removeCurrentImage: "Remove current image",
  regenerateIcon: "Regenerate icon",
  enable: "enable",
  disable: "disable",
  transaction: "transaction",
  account: "account",
  transactions: "transactions",
  staking: "staking",
  receive: "receive",
  voting: "voting",
  settings: "Wallet settings",
  stakingvault: "Staking Vault",
  accountShort: "Acc.",
  transactionsShort: "Trans.",
  stakingShort: "Stake",
  sendShort: "Send",
  receiveShort: "Rec.",
  votingShort: "Vote",
  settingsShort: "Sett.",
  stakingvaultShort: "Vault",
  lockperiod: "Lock Period",
  adalock: "Lock ADA",
  message: "message",
  summary: "summary",
  tokenList: "Token List",
  utxoList: "UTxO List",
  accountList: "Account List",
  transactionHistory: "history",
  pendingTransactions: "pending",
  instructions: "instructions",
  transport: "Ledger Transport",
  shelleySupport: "Only Shelley era wallets supported.",
  rewardsHistory: "Rewards History",
  recoveryPhrase: "recovery phrase",
  walletPhrase: "wallet recovery phrase",
  attention: "attention!",
  warning: "warning!",
  disabled: "disabled",
  epoch: "Epoch",
  token: "Token",
  block: "Block",
  fee: "Fee",
  milkomedaFee: "Milkomeda Fee",
  deposit: "Deposit",
  donation: "Donation",
  metadata: "Metadata",
  size: "Size",
  all: "All",
  done: "Done",
  ft: "FT",
  ftlong: "Fungible Token (non-unique)",
  nft: "NFT",
  nftlong: "Non-Fungible Token (unique)",
  hint: "hint",
  phrase: "phrase",
  expand: "expand",
  collapse: "collapse",
  share: "share",
  shareAddress: "share address",
  balance: "balance",
  rewards: "rewards",
  controlledStake: "controlled stake",
  notStaked: "not staked",
  lock: "Lock wallet",
  removeLock: "Remove Access password",
  removeAll: "Remove All Non-Pending",
  unlockWallet: "Unlock Wallet",
  unlock: "Unlock",
  decrypt: "Decrypt",
  url: "URL",
  yes: "Yes",
  no: "No",
  connectDApp: "Connect dApp",
  disconnect: "Disconnect",
  anchor: "anchor"
};
const status = {
  syncing: "syncing",
  invalid: "invalid",
  locked: "locked",
  claimable: "claimable",
  redeemed: "redeemed",
  building: "building transaction",
  loading: "loading",
  waiting: "waiting"
};
const network = {
  label: "Switch Network",
  status: "status",
  offline: "offline",
  noconnection: "no connection",
  newEpoch: "A new epoch started: Updating databases.",
  networks: {
    test: "Test Networks",
    other: "Other Networks"
  },
  mainnet: {
    label: "Cardano Mainnet",
    badge: "Mainnet",
    description: "The official Cardano network launched by IOG in 2017.",
    link: "",
    icon: "",
    // default if empty
    hover: "A Cardano Mainnet address starts with addr1 while a Cardano Testnet address starts with addr_test1."
  },
  guild: {
    label: "Guild Network",
    badge: "Guild",
    description: "A testnet created and operated by Guild Operators community group with a short epoch for rapid development and testing.",
    link: "https://cardano-community.github.io/guild-operators/#/",
    icon: "data:image/webp;base64,UklGRuALAABXRUJQVlA4TNQLAAAvP8APAFVZsfZ/nSUnzMzMzMzMzMzMyeW6t6puwWW+t2GgmZmZmekyd5iZGRvq96+qvh2wdG1cFKkshIZsz6mT6DllwzuYBUzc3cCgC/x9oGTgt4bZQNxPRWVQpWsCdk7KBr46sIXRYUY15x+QVLbXkA3MFkbVDup0+TkNauRV7XoNsaPajWuy4ahZQHQ2kC1Et7ruL0MqqqNaBX3PHq5s1a5VwM8ZH04s6z7DFSwbhi0wMzPKgeun7wLCuTqgOD6K43KabKA0BNt200aZ/S/JMkkWue0wMzMz5VSCbdtq2whsmVGyyAz/wf8KzX8UjRnDzMxV/yG4kaRIcizvwWLDF5YxaKfb2tJVZR+bDatZ96DLnd3thRt4yrc92zmz/ZE9CcXCApUCVU7CPkhOJtbzmms7nuyqMIlQwc63MohdBP8Xwb8xuWzXt0SCfoUPttJZ0X8i7q3sL2m91PVFFqsQGAhNNIlHUTAOi/PBuqC4cdauo6GzYrrCuz7w49oedv2AKp0FRCqEBvZdhcAqFBaBaZMWFFckJC4jYM5zUohMuDH5IG7+phKXtnJVfYQbI7DAM86PRgRMA9M6KK4ZhiHhMC9ef7guQWQDkYEXkaAP1vKRjivrfM2IbdAVaACw96hOuuzJIAXHZeN4zPEtAGCdVPhX3v96azlzMy6sYDQPvNrxqyxWoAEAgNO3GsWT4LhCkdNLAMu6CDxxJ0e1NrfLA++JvwEaAJsV4OCqSnkYjgqJywWUgM1mABbcmTwbbeK+1GY2e1vyJnJnBADAXJNcZ28JhS44PeIbZWQ7JowIcq7L2rImnrO9Sy9pOFtvQTMA/SGfSg7T3mq/LPmt8SvNnwy8kT7EAgA2FKs/MWGsi4VhjXzDc7Lt2xXqSxRMiNFIImFSI9/a+ba9q+wtExWmuhgYNUonTtZLBQDaSSGg8j626stY0OWzrEHf73rTv0oa/Sf9iuKfjhjJ4KUNC+alxMzRYRQdxpEwK0SxwZSJi+9h0gLjGvm/AACuDCO3e2rLY12vuSd2B/SIp3wWYRiGPDAjV/lOgzgeuWnbXVspGpwSGDd6wjBp0+QnQ4sA+IGgi2UsaDKt6TOTIUugZvbWUIe8XeEwK4C6FrDZjGns4DIWxsgbEBoXfVUUtIugiwqZfiBWAGBTVZwejdYoFHRsGCEn02RrWZPZvqE1sRWyLRFPAAwRMEMMLo4/GjOHqfUD4QkCgHvDPe02ZNjKlf0DAFbpI36l/DRHvXxerP526tS3Zr4enMAQ/ZmnvASHofZl+Zjf5olG45Cv6SzrdUuUmmL4e3sjQ0jzsO9qba4QR7DuRemY34kTjfohXtKZ1hvDACBdlcudG9JZL3aHwHPjC2H8niR9CCwnfaCHNkzTN07H/5l0mqgw8dK6g7LLtN9i0JCCbvMHI5VSPd+1m3Sa62ZqBY4ot2kvGanJbcECGYNHw61dVqXzIwK6U0axY8OQGAlD9N2mFBgaMkq1ABnzTGmyQkqmVOKg5sBo8FMvP5m5yBLaoJ8VUTKlIge+gyB03/N2XbpZAPo3SGeLI2+XcZrczdLiToNMmMtYeN+jajH8T2RTtVqBA5eh2IFHdYp5bIESXAT3utWQzg8l4C/EwJgwSMMrlUf07bVrFHRboEoW9IFAAXkgofd5KQ+Er0Jg0H0v2w2ZHEzGwISqUnmmCL7LSyHyPirsPieFowo5QHyjdKxHhcdZPjK1iPmLH7hSJGKJiUod1qhaDHEiKwdTJi7EhJGRYRgSDMsHTo8RQhXWjajKn9j2jOgDsWlEVfq4NhHIgTWUrF+X6BkMK30YzK/go0EnzBW0IR72wqVm5wt4z9qo5s8ZiyqxSRmv1GKeoM9yBxX9lLWorJAH4AUzsF0j3w5tGg/L1HfaJDTx7vw7weHerROPxtG/ElXOqtZEjgp/4Zlodls8yb+22JG/rHy7wR+xnUdjc6l6vmucjuqkywGjL3wTvovA28JJRm2xI31aebeDg6HCIAesmsDR0abvxMfHc40FBorEQ7+lkGfXYv5/UYGKqe2Yhr3Jhugv2FA930XDqKe+5zSB8ZDvKHAUiPjFsDdZtMjStoUOdj0yyYZTStXPGBjFhuEdnbUrGZo4jepclpLRjvdnvhuzwAJoiuLv7YmRMRpD47x+Ol/w0wCasbgUDvMYGN57LC5PKZOmMP6Pggkhw0NhNRqDwrpxMrWx15pXBwDADs7RMCHoJzoaxr7iPxQe6iXhwcO/pwamDZnVS8PvyhKv1zNMmi69OKnAV0i/3JKi2rm9lMRDLxUVxgzapAO0oPn+OGkMGad0/RCKkmnxoQxDdJdpLf1KW4rq5xWUrwa3p8rbkq39axyGYeSgmerlxNgzHBaSKzZMUmTZqPMEkStcpyugV0gPf/FSIdVXvIOHfWIks15K5hVF3wrlORZGMWEYmA7ctJWKWfoXDW+KFCf+1xMVNFawoCpZP6dJkByHz7EgprEqa8tFh8lf/zOPSvYfUigdDVy0a9X3bPruFzgulakKS+SjfiZQwj6Y+Kf/tiC2Zhy4lCKlTr58YM+h+mlCYflP80OVHFdfOJ+Nb7tpZ7RWns8tjW19K2dLT/jx59XK195aV83+7uIH3tG/zBZDfII/o95l2VaQL3gVz8Xe4V6t5ORTDnG108qjzQs+qSPTMJ0UIm0CRyeNuzarl7somH58pgHXxiAPfK9q5V6nJ6Rn+0ytoFHMb0080BqJw3grLmPmjUYy0rG+jYEK7eiU/hpsSs92+1BYEKK/fUcDloc2F1m6hDSGMZLYMKTNrEgH7KfBfNNkSnWuyhcHABoUfMMLEMIwxHj7gqRp5JEyoR59dyctjLEGkGGi3LEjc9zQ5qHkNJSJPAyWz8RyfO++cF3quFU131PGrZCHvBROvT+1hKpsfU+i6PFphRxeFg1Tqkr5SWIu4DRseluUgqdgBhZA8/1xKD7ON8CyjGRBWStf9UQf1O1ztIwpVWnob+Ix5N4KqO450KwypAwyjcVlHUrfKB7HQ3cZ47Y3I0DqY5uHIZEcewbHNacrlY8ENfO1/jrZW3bBxBP+6RQ5N0OOyAUq50fSOB0VRD1lwSbxCLlKOszXiXYV3MNuKN0B1lq/AVBl4sIlJh0+/PZ6sfW4rjJItTns9xwaAouYMPq+nUVcgZOOGqLcqWNJarwrJOn1t6+Tr2x929GhWTy4fdLwsDjvkJNSShZ+sNmbsnQbfir6IAOARmT9whTPW7E+f6XvUwwzP9XIpJE/eWiTr2SJVOTAi37OHuYt3fCm9GY7ImXHnoQhxgdmbvn7v2zOCvV53j87W6cfCzBSLSPupP8bABAYalQqLTbf95tplFFCwWWwbfSAs0yMv4BOKUnl6psKm1QqjRkAvIm3fe7IsuzB8CEaAkDDXABgdrN2DwbxSHTdANje5BVQZctbPwCapgHgBwddaatltpzBPK8X8WwAAAD45kP1DMOQ9s7WMw+6+Xsl6xZl9XybxDAMaffrToDkpBBQ5J5362p52tJ1xYf47YCU+tjrjrP48A4fVS044N7f/GYkTK9quLDIBt0mXbxnj0r1yYABgP2QN9EN1/SZVsvZbvfD8w8BABq0ztYtV97qpfOq5X6+0YYK9UXHJMzUet32TEejV884sma6mXNBDABwDm/Czd5V1PK34v+k5XLHt7JYAYAGs0qp6tQpI1fbESIZrr+ZteVNAkeNUmnCAPCbuXd54KvbrPW95FxE/AAAgAWgVVXKo9R1KwALAE4qLnauFYymuo3b5oXjh3xNVta6mVk8HgAAZusqNrGu14w6TtrrVt2f5BCQvm7XL41wY/Ql2sq1rY6rVvVjcWa9u30IYFA+MinDzKQzaoAeMvdj1HHZRh+L5/BoCJJ9S0JrIXHRjW+I/+mLfNarqeO4HZ64AYW6m4U2+N9/JPsmZ+08ZZLXbfAxr477lj3X973ZmkWsuOBlCuP/L43J5RRnYf9K2zlz1G2nNX5l7Gc9P5SuLMUSObFyayqgqr1uh+dUt7VW+ZN8zaO2f+Js4r7Yaol+Oi01",
    hover: "A Guild Network address starts with addr_test1."
  },
  sancho: {
    label: "SanchoNet",
    badge: "SanchoNet",
    description: "SanchoNet is a Cardano testnet aimed to lead the way to on-chain governance.",
    link: "https://sancho.network/",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAApCSURBVHhe7VoJTJTbFf4GZp8BZlhkqUtUrHXBuD9q3PJErWkspjXuJlbr0qhoXFJ9D41BrVtdXquoWOSB1l3rEp/Rp3GpzzxNfdrkqY0aF4rWl4eIIgKy3J5z+Wc6Az8wMwxoAif5cv//3PvPzD33nnO+c//RABCEJisBSttkpdkASttkpdkASttkpdkASttkpdkASttkpdkASlunHApria/CWyMmQKtoPj5ZsWIFTp48iXHjximausWjWuBTgwWB1H5dUog7ke3wVXEhTBoNXleU45WowD9K3uH6+6LKwY0gYWFhSEhIQKdOnWC1WmE2m1FeXg4hBJKSknDgwAGPjeBxMbTJFokgTQCSXr1AkcsjMYFafKIzoZ/RjGDaUN+VFmNn4Sul13/Srl07zJgxA3a7HQ8fPsSFCxfw4MEDFBQUKCOA2bNno3v37ti7dy8uX76saOsWno3f0FVnENtsUWJdSAuhg0Z1jDcYOHCgyMjIEHPnzhWBgYGqY+oJVWWNmGIJERmhMWKO1a7a7wDtFpFqixYLrWGq/XUhODhYZGZmijFjxqj2u2Lfvn2Ctr0ICAhQ7a8NXp8HHKNg+OuXOUi3R6OQ/F8nY0GFvL5CseAywVV66Y1IDorAeHqm2MOvGj9+POLj4zFv3jxFUylRUVEYPny49H2TyQSdTofBgwcjLi4OMTExSExMxNatW5XRnonXBhhnDkZPnRH3yt4jozBf0QIhFB/6G8wYRLDSdfq7fNx8X6z0VhouKf8FcsrLFI26LF++HPfu3cPhw4cVDbBw4UJ07doVd+/exdmzZ3Hnzh0Z9Fg0tAC7du0CuQemT5+OsrLaP19NnNvBn5hgDhZ/C/2J6KjVO3WUSkVkQM1+nJKSIgYMGOC8T05OFjt27BAUAN3G+RmqSo/wJcWCv9qjRXuXSVbFkqBwsTokwnlPXMKt3wH2dYe/t27dWpw+fVp06NCh2jgH1q5dK2i7i9GjR6v2ewFVZZ34RG8SvzRa5fXdyPZiLUX9rRT9N1Dr0DvQLlAn/k6rz9ecGbLIcK79BoNBbN++XV6PGDFCrrprP+V9sXjxYrFt2zaRlpYmx65atUr27d+/322sD1BVeoQ/hUTKyeirpDuKA+ILW6RIo90Rq9U59Y7VXxQUKtOlQ797927Z8g5YsmSJU0+kRuzZs0csXbpUUJBz6hlz5swRhw4dEn369HHT+wBVpdeYSD5PEbWafoE1VOyhWBCm+P5RZSfsJR23FotFrm7nzp0FUVmpmzVrlqAgKCjwyXtXUHaQY6vq6wFVpVfYSSsdpzXI3aBT6WesJtf4jOKBiXbL0qAwZ1xIXr5chISEyK2t1Wql7/ft27fa84yxY8eKKVOmiDVr1oiePXuqjvEWXqdBNdkTGoPJec+x2x6Df1JNwB8YRRRZS59eQBzhHNUOTJGjqZBKCYnALUqPgZSBvy3Mw6DPP4PdbMH9+/cRGxuLZcuWgQgNKLihW7duMr3l5+fjzZs36N+/P9atW4d+/frh6dOnOHPmTOUPqIf4xQAU2PCH4DDsfPsKP1KB9HuLXbZHit7I/k+JG8TrzSijr/qOJs98YaTJipQfHmP6xYswUO4muitzOkV+vHjxAufOncOjR4/k8xTwsGXLFuTm5sp6gI3BBY8/xC8GcJW5VjsuEhtsH6jHAJrobVr5CvqK91Sp8apTykRnnQETadyE7O+xm/Q5SnFz+/Zt5OXlyVXX6/WS7EycOBGUGXDkyBG5K/wtfj8QuVv6HgNp4t31BpwqLpClMlPkb0qKcKesBCVEmd8R2PbM2dj6FeQmXNU9f/4c165dw5UrV3Dp0iUJrvh4yxcWFvLH+124zF9Reem7RJO/b6faILusFN9QDPiB6O41apkut6EV/5UxCMNMFoRSDLhKxmil1UFLUz9DVNrcowdyacvfuHEDL1++xIQJE0CpTboDU94TJ04gOjoaxAHkd23atAk96JmrV6/K+/qKX1zAUSARK6TAp8FLPpwgPRdI/yIX4CD4lq4HUBwYZQrCk/JSebaQXpCLmStXoqKkBNevX5dF0NSpU+Vncl3PhU7btm1RWloKyhQgmgzKEOjduzciIiJw8OBBOba+wr+1XlhPKW66xSZ2UTpU6zdQ6ttHef83xiDRMlArZtDYLUSUuG8MpbaOHTtKwsP3R48eFZMmTXJ73gFOfRQMJXFq06aN6hgfoKr0Gj9TqQcsGo1ItUeJzcQY+V5PcNDgVcH/rw82b94s7Ha7SE1NlfcJCQni+PHjqjw/PDxcWK3uVLueUFV6BJ7MQVpZyu9OXQtifAuJ/fGhyQqapFbRMxM8orDALLs7rZ0/f77k+0yAeIUd+iFDhoisrCxpmEGDBrk9s3LlSnkQMnLkSDe9D1BV1ol4KoZ+Yahcie+j2lMRFCmLoSSrXbSm4sd1LNcGRJLk9WC6nkYu4NrP4K3PLW9ztQInMTFRbNiwQRZEXAxx6cx6PgmqOtZLqCo9wp9pwszprZqaj6J4zO+UCYdrAskQ6nGCXcBRBRqNRnHs2DF5Hlh1nAMLFiyQRqttjIdQVdaKqtVfVVBuJb4fLmsEm2IcdoGDigvUBIruYv369c77yZMny21OPMBtnJ+hqqwRnweHywDmesjBBRCf/My02OWJ8B+pL8olLvDZQaYS/OpCXFycSE9Pd9Nxmcw6LoKGDRsmiydHX2goxZuMDOkKHCBdn/MEXvMACmQYTTk/kwqf5xVlKK4Q4Kz/kEjPt0R+OMe7CqVI/Id0f6E6wVOhElme823cuBE3b95UtJD0mLkAF0k0WfkiZOjQoZIvMFliyuwgTN5INavUhp/TanJAG2qwqPY7MJX8ns8EY1x2greYNm2aRzmfAyNDrc8DqCp9Akf/1eQeTIh66YyqY1zBvMBKXEGtzxV8MsTbnM8D1PrrA49dgLd8BY1Oef2j3ObE6BBLPL+X3oSfUltEVPffVAhlvcsnCuzRR2IOlc3xVDhNynumaGoXpsCjRo0C+T1KiD7funVLusizZ8/kmUFycjK0Wq3UnTp1SnmqdvHIAEMMFgTQyK+J09+KbIuMwteyossmQ3B9n0u1vy8yzWxDX4MJM1/9V9F4JxwLunTpIl+WtmjRAjabTb4cJbdx1hSeiHM71AYmOYdDW9Z45OULyAAyVar1+QKuITgbeHlmqKpsFPjbAL7A6zToq/zWYsOXVP+7fpmaCxgMBixatEimOAb7NB+S8IlRQ0ij/UVmpy1avkitS/gQhI/E+D0g/w+AzwnOnz8vA19DiduWaCjkRncU2iopT80FHj9+LFq1alVNV/XFiL/w0f1Jirc9v/p2Fd4RrG8Iaf6XmNI2WWk0A9Qd/irFaDRKVucqvP3ZDRpCGs0AeqKSnkwhLS1Nvhl68uQJsrOzJZjp5eTkKCP8L9UiY2PhYyBCzTFAaT+Q8CJ8WPmgBtBrAmDwgB02pHxQA/Cb47NFb5W7DyONVgx9rNIcBJW2yUqzAZS2yUqzAZS2iQrwP6nEeXh1nr2dAAAAAElFTkSuQmCC",
    // default if empty
    hover: "A SanchoNet address starts with addr_test1."
  },
  preprod: {
    label: "Pre-Production Testnet",
    badge: "Pre-Prod",
    description: "A pre-production testnet that mimics mainnet parameters. A good playground for newcomers as well as more experienced users when testing Cardano integrations or learning how to operate a stake pool.",
    link: "",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAApCSURBVHhe7VoJTJTbFf4GZp8BZlhkqUtUrHXBuD9q3PJErWkspjXuJlbr0qhoXFJ9D41BrVtdXquoWOSB1l3rEp/Rp3GpzzxNfdrkqY0aF4rWl4eIIgKy3J5z+Wc6Az8wMwxoAif5cv//3PvPzD33nnO+c//RABCEJisBSttkpdkASttkpdkASttkpdkASttkpdkASttkpdkASlunHApria/CWyMmQKtoPj5ZsWIFTp48iXHjximausWjWuBTgwWB1H5dUog7ke3wVXEhTBoNXleU45WowD9K3uH6+6LKwY0gYWFhSEhIQKdOnWC1WmE2m1FeXg4hBJKSknDgwAGPjeBxMbTJFokgTQCSXr1AkcsjMYFafKIzoZ/RjGDaUN+VFmNn4Sul13/Srl07zJgxA3a7HQ8fPsSFCxfw4MEDFBQUKCOA2bNno3v37ti7dy8uX76saOsWno3f0FVnENtsUWJdSAuhg0Z1jDcYOHCgyMjIEHPnzhWBgYGqY+oJVWWNmGIJERmhMWKO1a7a7wDtFpFqixYLrWGq/XUhODhYZGZmijFjxqj2u2Lfvn2Ctr0ICAhQ7a8NXp8HHKNg+OuXOUi3R6OQ/F8nY0GFvL5CseAywVV66Y1IDorAeHqm2MOvGj9+POLj4zFv3jxFUylRUVEYPny49H2TyQSdTofBgwcjLi4OMTExSExMxNatW5XRnonXBhhnDkZPnRH3yt4jozBf0QIhFB/6G8wYRLDSdfq7fNx8X6z0VhouKf8FcsrLFI26LF++HPfu3cPhw4cVDbBw4UJ07doVd+/exdmzZ3Hnzh0Z9Fg0tAC7du0CuQemT5+OsrLaP19NnNvBn5hgDhZ/C/2J6KjVO3WUSkVkQM1+nJKSIgYMGOC8T05OFjt27BAUAN3G+RmqSo/wJcWCv9qjRXuXSVbFkqBwsTokwnlPXMKt3wH2dYe/t27dWpw+fVp06NCh2jgH1q5dK2i7i9GjR6v2ewFVZZ34RG8SvzRa5fXdyPZiLUX9rRT9N1Dr0DvQLlAn/k6rz9ecGbLIcK79BoNBbN++XV6PGDFCrrprP+V9sXjxYrFt2zaRlpYmx65atUr27d+/322sD1BVeoQ/hUTKyeirpDuKA+ILW6RIo90Rq9U59Y7VXxQUKtOlQ797927Z8g5YsmSJU0+kRuzZs0csXbpUUJBz6hlz5swRhw4dEn369HHT+wBVpdeYSD5PEbWafoE1VOyhWBCm+P5RZSfsJR23FotFrm7nzp0FUVmpmzVrlqAgKCjwyXtXUHaQY6vq6wFVpVfYSSsdpzXI3aBT6WesJtf4jOKBiXbL0qAwZ1xIXr5chISEyK2t1Wql7/ft27fa84yxY8eKKVOmiDVr1oiePXuqjvEWXqdBNdkTGoPJec+x2x6Df1JNwB8YRRRZS59eQBzhHNUOTJGjqZBKCYnALUqPgZSBvy3Mw6DPP4PdbMH9+/cRGxuLZcuWgQgNKLihW7duMr3l5+fjzZs36N+/P9atW4d+/frh6dOnOHPmTOUPqIf4xQAU2PCH4DDsfPsKP1KB9HuLXbZHit7I/k+JG8TrzSijr/qOJs98YaTJipQfHmP6xYswUO4muitzOkV+vHjxAufOncOjR4/k8xTwsGXLFuTm5sp6gI3BBY8/xC8GcJW5VjsuEhtsH6jHAJrobVr5CvqK91Sp8apTykRnnQETadyE7O+xm/Q5SnFz+/Zt5OXlyVXX6/WS7EycOBGUGXDkyBG5K/wtfj8QuVv6HgNp4t31BpwqLpClMlPkb0qKcKesBCVEmd8R2PbM2dj6FeQmXNU9f/4c165dw5UrV3Dp0iUJrvh4yxcWFvLH+124zF9Reem7RJO/b6faILusFN9QDPiB6O41apkut6EV/5UxCMNMFoRSDLhKxmil1UFLUz9DVNrcowdyacvfuHEDL1++xIQJE0CpTboDU94TJ04gOjoaxAHkd23atAk96JmrV6/K+/qKX1zAUSARK6TAp8FLPpwgPRdI/yIX4CD4lq4HUBwYZQrCk/JSebaQXpCLmStXoqKkBNevX5dF0NSpU+Vncl3PhU7btm1RWloKyhQgmgzKEOjduzciIiJw8OBBOba+wr+1XlhPKW66xSZ2UTpU6zdQ6ttHef83xiDRMlArZtDYLUSUuG8MpbaOHTtKwsP3R48eFZMmTXJ73gFOfRQMJXFq06aN6hgfoKr0Gj9TqQcsGo1ItUeJzcQY+V5PcNDgVcH/rw82b94s7Ha7SE1NlfcJCQni+PHjqjw/PDxcWK3uVLueUFV6BJ7MQVpZyu9OXQtifAuJ/fGhyQqapFbRMxM8orDALLs7rZ0/f77k+0yAeIUd+iFDhoisrCxpmEGDBrk9s3LlSnkQMnLkSDe9D1BV1ol4KoZ+Yahcie+j2lMRFCmLoSSrXbSm4sd1LNcGRJLk9WC6nkYu4NrP4K3PLW9ztQInMTFRbNiwQRZEXAxx6cx6PgmqOtZLqCo9wp9pwszprZqaj6J4zO+UCYdrAskQ6nGCXcBRBRqNRnHs2DF5Hlh1nAMLFiyQRqttjIdQVdaKqtVfVVBuJb4fLmsEm2IcdoGDigvUBIruYv369c77yZMny21OPMBtnJ+hqqwRnweHywDmesjBBRCf/My02OWJ8B+pL8olLvDZQaYS/OpCXFycSE9Pd9Nxmcw6LoKGDRsmiydHX2goxZuMDOkKHCBdn/MEXvMACmQYTTk/kwqf5xVlKK4Q4Kz/kEjPt0R+OMe7CqVI/Id0f6E6wVOhElme823cuBE3b95UtJD0mLkAF0k0WfkiZOjQoZIvMFliyuwgTN5INavUhp/TanJAG2qwqPY7MJX8ns8EY1x2greYNm2aRzmfAyNDrc8DqCp9Akf/1eQeTIh66YyqY1zBvMBKXEGtzxV8MsTbnM8D1PrrA49dgLd8BY1Oef2j3ObE6BBLPL+X3oSfUltEVPffVAhlvcsnCuzRR2IOlc3xVDhNynumaGoXpsCjRo0C+T1KiD7funVLusizZ8/kmUFycjK0Wq3UnTp1SnmqdvHIAEMMFgTQyK+J09+KbIuMwteyossmQ3B9n0u1vy8yzWxDX4MJM1/9V9F4JxwLunTpIl+WtmjRAjabTb4cJbdx1hSeiHM71AYmOYdDW9Z45OULyAAyVar1+QKuITgbeHlmqKpsFPjbAL7A6zToq/zWYsOXVP+7fpmaCxgMBixatEimOAb7NB+S8IlRQ0ij/UVmpy1avkitS/gQhI/E+D0g/w+AzwnOnz8vA19DiduWaCjkRncU2iopT80FHj9+LFq1alVNV/XFiL/w0f1Jirc9v/p2Fd4RrG8Iaf6XmNI2WWk0A9Qd/irFaDRKVucqvP3ZDRpCGs0AeqKSnkwhLS1Nvhl68uQJsrOzJZjp5eTkKCP8L9UiY2PhYyBCzTFAaT+Q8CJ8WPmgBtBrAmDwgB02pHxQA/Cb47NFb5W7DyONVgx9rNIcBJW2yUqzAZS2yUqzAZS2iQrwP6nEeXh1nr2dAAAAAElFTkSuQmCC",
    // default if empty
    hover: "A Cardano Testnet address starts with addr_test1."
  },
  preview: {
    label: "Preview Testnet",
    badge: "Preview",
    description: "A network for testing release candidates and mainnet releases. Leads mainnet hard forks by at least 4 weeks. If you want to test the latest features, this is the place to do it.",
    link: "",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAApCSURBVHhe7VoJTJTbFf4GZp8BZlhkqUtUrHXBuD9q3PJErWkspjXuJlbr0qhoXFJ9D41BrVtdXquoWOSB1l3rEp/Rp3GpzzxNfdrkqY0aF4rWl4eIIgKy3J5z+Wc6Az8wMwxoAif5cv//3PvPzD33nnO+c//RABCEJisBSttkpdkASttkpdkASttkpdkASttkpdkASttkpdkASlunHApria/CWyMmQKtoPj5ZsWIFTp48iXHjximausWjWuBTgwWB1H5dUog7ke3wVXEhTBoNXleU45WowD9K3uH6+6LKwY0gYWFhSEhIQKdOnWC1WmE2m1FeXg4hBJKSknDgwAGPjeBxMbTJFokgTQCSXr1AkcsjMYFafKIzoZ/RjGDaUN+VFmNn4Sul13/Srl07zJgxA3a7HQ8fPsSFCxfw4MEDFBQUKCOA2bNno3v37ti7dy8uX76saOsWno3f0FVnENtsUWJdSAuhg0Z1jDcYOHCgyMjIEHPnzhWBgYGqY+oJVWWNmGIJERmhMWKO1a7a7wDtFpFqixYLrWGq/XUhODhYZGZmijFjxqj2u2Lfvn2Ctr0ICAhQ7a8NXp8HHKNg+OuXOUi3R6OQ/F8nY0GFvL5CseAywVV66Y1IDorAeHqm2MOvGj9+POLj4zFv3jxFUylRUVEYPny49H2TyQSdTofBgwcjLi4OMTExSExMxNatW5XRnonXBhhnDkZPnRH3yt4jozBf0QIhFB/6G8wYRLDSdfq7fNx8X6z0VhouKf8FcsrLFI26LF++HPfu3cPhw4cVDbBw4UJ07doVd+/exdmzZ3Hnzh0Z9Fg0tAC7du0CuQemT5+OsrLaP19NnNvBn5hgDhZ/C/2J6KjVO3WUSkVkQM1+nJKSIgYMGOC8T05OFjt27BAUAN3G+RmqSo/wJcWCv9qjRXuXSVbFkqBwsTokwnlPXMKt3wH2dYe/t27dWpw+fVp06NCh2jgH1q5dK2i7i9GjR6v2ewFVZZ34RG8SvzRa5fXdyPZiLUX9rRT9N1Dr0DvQLlAn/k6rz9ecGbLIcK79BoNBbN++XV6PGDFCrrprP+V9sXjxYrFt2zaRlpYmx65atUr27d+/322sD1BVeoQ/hUTKyeirpDuKA+ILW6RIo90Rq9U59Y7VXxQUKtOlQ797927Z8g5YsmSJU0+kRuzZs0csXbpUUJBz6hlz5swRhw4dEn369HHT+wBVpdeYSD5PEbWafoE1VOyhWBCm+P5RZSfsJR23FotFrm7nzp0FUVmpmzVrlqAgKCjwyXtXUHaQY6vq6wFVpVfYSSsdpzXI3aBT6WesJtf4jOKBiXbL0qAwZ1xIXr5chISEyK2t1Wql7/ft27fa84yxY8eKKVOmiDVr1oiePXuqjvEWXqdBNdkTGoPJec+x2x6Df1JNwB8YRRRZS59eQBzhHNUOTJGjqZBKCYnALUqPgZSBvy3Mw6DPP4PdbMH9+/cRGxuLZcuWgQgNKLihW7duMr3l5+fjzZs36N+/P9atW4d+/frh6dOnOHPmTOUPqIf4xQAU2PCH4DDsfPsKP1KB9HuLXbZHit7I/k+JG8TrzSijr/qOJs98YaTJipQfHmP6xYswUO4muitzOkV+vHjxAufOncOjR4/k8xTwsGXLFuTm5sp6gI3BBY8/xC8GcJW5VjsuEhtsH6jHAJrobVr5CvqK91Sp8apTykRnnQETadyE7O+xm/Q5SnFz+/Zt5OXlyVXX6/WS7EycOBGUGXDkyBG5K/wtfj8QuVv6HgNp4t31BpwqLpClMlPkb0qKcKesBCVEmd8R2PbM2dj6FeQmXNU9f/4c165dw5UrV3Dp0iUJrvh4yxcWFvLH+124zF9Reem7RJO/b6faILusFN9QDPiB6O41apkut6EV/5UxCMNMFoRSDLhKxmil1UFLUz9DVNrcowdyacvfuHEDL1++xIQJE0CpTboDU94TJ04gOjoaxAHkd23atAk96JmrV6/K+/qKX1zAUSARK6TAp8FLPpwgPRdI/yIX4CD4lq4HUBwYZQrCk/JSebaQXpCLmStXoqKkBNevX5dF0NSpU+Vncl3PhU7btm1RWloKyhQgmgzKEOjduzciIiJw8OBBOba+wr+1XlhPKW66xSZ2UTpU6zdQ6ttHef83xiDRMlArZtDYLUSUuG8MpbaOHTtKwsP3R48eFZMmTXJ73gFOfRQMJXFq06aN6hgfoKr0Gj9TqQcsGo1ItUeJzcQY+V5PcNDgVcH/rw82b94s7Ha7SE1NlfcJCQni+PHjqjw/PDxcWK3uVLueUFV6BJ7MQVpZyu9OXQtifAuJ/fGhyQqapFbRMxM8orDALLs7rZ0/f77k+0yAeIUd+iFDhoisrCxpmEGDBrk9s3LlSnkQMnLkSDe9D1BV1ol4KoZ+Yahcie+j2lMRFCmLoSSrXbSm4sd1LNcGRJLk9WC6nkYu4NrP4K3PLW9ztQInMTFRbNiwQRZEXAxx6cx6PgmqOtZLqCo9wp9pwszprZqaj6J4zO+UCYdrAskQ6nGCXcBRBRqNRnHs2DF5Hlh1nAMLFiyQRqttjIdQVdaKqtVfVVBuJb4fLmsEm2IcdoGDigvUBIruYv369c77yZMny21OPMBtnJ+hqqwRnweHywDmesjBBRCf/My02OWJ8B+pL8olLvDZQaYS/OpCXFycSE9Pd9Nxmcw6LoKGDRsmiydHX2goxZuMDOkKHCBdn/MEXvMACmQYTTk/kwqf5xVlKK4Q4Kz/kEjPt0R+OMe7CqVI/Id0f6E6wVOhElme823cuBE3b95UtJD0mLkAF0k0WfkiZOjQoZIvMFliyuwgTN5INavUhp/TanJAG2qwqPY7MJX8ns8EY1x2greYNm2aRzmfAyNDrc8DqCp9Akf/1eQeTIh66YyqY1zBvMBKXEGtzxV8MsTbnM8D1PrrA49dgLd8BY1Oef2j3ObE6BBLPL+X3oSfUltEVPffVAhlvcsnCuzRR2IOlc3xVDhNynumaGoXpsCjRo0C+T1KiD7funVLusizZ8/kmUFycjK0Wq3UnTp1SnmqdvHIAEMMFgTQyK+J09+KbIuMwteyossmQ3B9n0u1vy8yzWxDX4MJM1/9V9F4JxwLunTpIl+WtmjRAjabTb4cJbdx1hSeiHM71AYmOYdDW9Z45OULyAAyVar1+QKuITgbeHlmqKpsFPjbAL7A6zToq/zWYsOXVP+7fpmaCxgMBixatEimOAb7NB+S8IlRQ0ij/UVmpy1avkitS/gQhI/E+D0g/w+AzwnOnz8vA19DiduWaCjkRncU2iopT80FHj9+LFq1alVNV/XFiL/w0f1Jirc9v/p2Fd4RrG8Iaf6XmNI2WWk0A9Qd/irFaDRKVucqvP3ZDRpCGs0AeqKSnkwhLS1Nvhl68uQJsrOzJZjp5eTkKCP8L9UiY2PhYyBCzTFAaT+Q8CJ8WPmgBtBrAmDwgB02pHxQA/Cb47NFb5W7DyONVgx9rNIcBJW2yUqzAZS2yUqzAZS2iQrwP6nEeXh1nr2dAAAAAElFTkSuQmCC",
    // default if empty
    hover: "A Cardano Testnet address starts with addr_test1."
  },
  afvt: {
    label: "APEX Fusion Vector Testnet",
    badge: "AF Vector Testnet",
    description: "[Testnet] Performance optimised chain with low fees and fast transaction speeds.",
    link: "https://apexfusion.org/",
    icon: "data:image/webp;base64,UklGRrAEAABXRUJQVlA4IKQEAACwFQCdASpAAEAAPoU2lUelIyIhMfju2KAQiWgAuzNMB5yJrO4xP37ec9XHLHeu7n1PPJvn6zruEWLXohCx508wx6r53w10rk07ylvqvQAEi4QtqsPHDy43Bd+un3V8/sdfOLyhf8+YqNJHrif9TCyD122dFiqmhG7EHbNBGQ5b9woFV6HFqK1iu90o6ZDiPpEPIwKWpbiL0q9eLR/9XN3WO6rAQdNT/F6BCjeUyZ1zVYPLgARWAAD++Vylkb2AA4FLztmA+wgGzdSu49AYYgwcNaRKUQyQaO40tDup9lDJDhPm/aO7VhpQbzXSiu5X/N55KI6H9EoXps6wowBTnA9YyTZqq51EgwOSI2WdPDXkuYlhtw0G7BcCKChwBjdMuyiZ1Up4bnAgtpSeQHqDTWsMhSnrj8c3RNGgdGtgB60x2Lh3v8SyfNY7yjKOVgH7IoKyY6O5HX1xUnYw5Lcet+Q+yT/uREUiK7gHzxw8PF3q/D9IhF4MkfGkwcz/r3kos/Bg1Z5qf6DE+kd6mRZ6DlfCrAEiZPULuu4XIJq52YoIfG7aA13jee0GehqjZuHuvAofZQ+F6HZaGcvAbUPalT0Wfh8FI+WnJIBStXjL3H7KraRDXnC9hF9UZpn27e4BkCgvaz/binHfYgdrDHESQa8h2JUIAEWM+e71YAZcijeXS8UeRJDQNqMsohuPVSMdP3wrvlu+jyLYJxvXrYE3nWTiPn/+Ss3nJdIu+RoRFn9/N4g4g55l8dWQQ4tcCizADoeB7sCGxjXa/P0gwfp0XirIQSkL8IRY4ysKf5FViGCh2/TTvM5JAn7KMuOkRbEHfH8uTHgNKSHZnu2GY9m2+DGPiZfu0XC8LqkrJDThIQyNMownvjoQpwf3l+pHuWdh1dGIT1SbvjabG/u6PLC40FRqswJVQPZafD/Y6yBmTZQdnR6jOhApaJWv5ibWGwqEldhr5S5PAqHphfMmT8qczMzqXH7dHI4ST0j3l/T0RzanfF4Me8OzcOIxip9gJodrwTIt7ueNukt56h4czRB77qxTWST1/VuY5daTvk27IAKvCyM7BWsfXJZR1Qx6GYt7TjP6e236PUd40bwrgejpbTmdLyoasW8S9i6//34qQHCRBSuLWl9C/kbecHPTHA/giM+Lrk18/+9t+d//QAGmX2Yo+piJAtuxmIEV7HCIhCbBIYYIW0pkA8mBBX78MrX/7mOtX/lzg3ASwIdYYsnwJsiUJjCy4ztoiOIyr+7BSyR+IGDvf97ehQuH90532rfa+lluT1pK8+Tu5r6B9XYMI3HSdfmZkoZCpaI8eRCv019JlE6djeefNfIDdmPI729RAY3/VyQIvQRAjZAV7fLxFtX6D/NwWzyJQr89zZSJ0se/Q5FtxTjC4il9j+Bbw5wAy+rEZw9qSWiePLTV1cP4XGOAfiqKBXu7abFhN8P6a83UZmMSWCSaU2oWB8O0cQ0Wxh5hl0WCvErx9lxptzg9flp/9+5u+KlM+XDrIX7oLOXtaM2fIffdc6OpLoPei0v8lIXHR24iADJIP7zEompckiLkp8D9H871Zv5p+UZgzEpSnUrAAAA=",
    // default if empty
    hover: "A Testnet address starts with vector_test1."
  },
  afvm: {
    label: "APEX Fusion Vector Mainnet",
    badge: "AF Vector Mainnet",
    description: "Performance optimised chain with low fees and fast transaction speeds.",
    link: "https://apexfusion.org/",
    icon: "data:image/webp;base64,UklGRsAEAABXRUJQVlA4ILQEAADwFQCdASpAAEAAPpE6mEgloyKhLhbbiLASCWwArDKEfce8+YncusvFftr+hbbW+ZLzZvSl/lPRm6m/earPHbDasixTIq7TOtVWTVfKK9zQSrfrz8ZHH3xqf/NKRKaemZ5JSEOCFGR59Q28sy2vd5TgVqQ1SVMWPfrjlixLj/Kdykj7kad3DzhbAFkGkAykBTBKFRlIZo6yDOTlMhtdKGHg9Idjy4dMoe7KLXL+kkZbGr0LnMNBB88AAP7+TK7I/mpnCscMAtKs5WWrK+6QppnmaAQnsUqR6I/izX84Sw4m2hYtC+2/h1BCfJ4bHD6Q68eJ/i8E9GlZw4zr2uvefkykgUVK3j5sCSZ7g+7eQU5eLcjnbFGZ+jGk/FypUU/QHvJ+/Ey6WfFIl65n8FQkoqH4xkl0O59LlGpVjw1ay0e47N/J9F7QnfgZFJKHoQMwUAkjp43UuTNWzGsdDkhffmpviKctYeknYii11hHIeWRs9iHPotHKi2aoPv3/2SeCdhLr1eU+esvDHhffkGEQpIjd+VMoxRl/ZHU67p17NbxdGZTzT54nz3BiIUeNYYcnsw6njmQL/lOTGIX31IxfxmVPo9u3KFPo+/bYzNfnFzzhkf1vr+Hy/GJRZLirTdpSD12jxTsM4FVMcLAN/lTq1MyBLD65Xt5JS7zaO3A9mMT5D8BG9pIs66qN66NfFqGf+Ep+kZrdD9WUAJCTy9QkgEx0QWejbox2pibCRA4kCkhh/i2HBRl6TfKMJBN0I6evao7ctmavcwhKyrMlcshJ/LjM6ZjG5UwGWjGbPBvV8Fi79PoeWd+kni7g+KYaqKNPLrwFDXnQT9kLNVM6sAqtvY/deFsS74mnUwZoaMGeW2TmrjQsOBnnqwv8VS8XCxP23DucAIXbgzcZq6sTX/yyluW6+OXRF8yLb6FfETVpdEBEK8I4Sa5w7fzf+jT+UqDAd3ZOh0ANXEHn6yhghqFsq7C/KtjqHvSoLm0a4uN15pCEXjkZjJ9vhpxNNpe86ARZQzBh50Ymg9ZduhAv7iY8yVbrJo+62qDM2pqYJgOfYU8l/+6C+lh0rdJmic/fJZTgAgPHD85q6bq/CYlN8hK+issuKM1B/AtFon8TorQZ7R+UhyfcV3ivjECaH+sCDWAXdzH+XPQAYGzZY7VlV2Syi0PSwD48ELYtl3AQpGGFoJsQrx56wj2d5M7kB+iAOTW1xDMaL1O3rTY76+XerOVZTCdwDykK+xtlnl780cqrvVLrTveyXY4jbzoRwiYcAhFxDA8nw1IdkbU383KDKnv1bCZ5f4kOOUa7A2FyrpK9BPel9v8KLvEvtbO+V7PoHEl4YVRK8a6Tde8zxuEB+uOMnQI/OPxVf2K+W88aqqM1bWdP3hjo9EbFvASMQWPx7xLypa6YmHjrEB7yFj0yAD9EJrvBQDHaVjp5slRhX6UJvyBmnnSnoxzdfhHk/pNBG4bLKg2UpuuS2UFwc41Viw/dLAiTdSd3HjE22hNW+6t/VoPDoCwyifR4K0BKYq7ZkfXBImrddaNONa+zdHnW3TVRVHjbUTDaRwy253tBK3ldXUVkAekBdOr5L82M4FimVCAcrI+8AAAA",
    // default if empty
    hover: "A Vector address starts with vector1."
  },
  afpt: {
    label: "APEX Fusion Prime Testnet",
    badge: "AF Prime Testnet",
    description: "[Testnet] The decentralized backbone of Apex Fusion, securing the base layer utilizing Ouroboros liquid staking consensus protocol.",
    link: "https://apexfusion.org/",
    icon: "data:image/webp;base64,UklGRgAEAABXRUJQVlA4WAoAAAAQAAAAPwAAPwAAQUxQSCYAAAABH6CQbQTI3/VegTuNiIhjhZmGaQCPBGXTXAF7Ivo/ASs8i/6zIFZQOCC0AwAAcBIAnQEqQABAAD6RPphIJaOiISwYDMiwEglqAKknpki0m20986M9YA9ae3z8wHnM+kPead5stE2cGUjquUwD+vcrl8QfJNjebsGRxv86o7TDIKhB/CEfd1Z6A8cnvY/j3hD09M2qoA4FGrDW191W5aGz1+L13FeSHhIQilLOX2gpaNu83rf7jRBMkph202A1e8TOeTN/BV0GYqwwAP79ow8/M7/xT09e054u4eU+gV2bLDm5O2qhilp7DDB4v/L+6LY3PbHWDIsfjCM1A/UFmpD6Mo1fLB6YgKyN3l05JXh+P9oGEVtcrR+ayxMj2ggkB8/AAMwGUNlVefh4R/xNoUzVJxcJaAbh7+DU34mM9Dgh9ipxl/A5qnBiA8iSZbSZQOswKiMrjsWTQYZK4RBS3yZG4cw5IZzSdeLAjC32Hs+jdvZWJaAyYb8aPWExXWUpXSHuAJNun9pij//2AjQ2b6bAv//qft7PBJdyr0mec0WhwVZDpuy2s7Wsg5vhlzsYsEy8JtFX94Q3qVZleX20JUGbzCyI9YLooTCnC49B/XXEJwEMBhZszbD4ZBON2N87z/expn163QI/DNwwN/13y1YRvb8hbaCoYfLMXzK8GXEN+YmHg68tYc66aV5APWvOCwGJv5oeQyAZ3oL29KcwTz6Eh23OPYC4C0l1Sy5jGqopaRuNlrbmgqd5vCktf3zVj0DUfcd+nxa1mUk5TU0NKprhww4eBkmswd26s20XTQGDDIluIe0eZSnDb+RPlIXh1pd627q4EuWxF5nC28/8zNHFY3Cs5Y18jqpa8vKBrn0zVMSPYZzlOlmpneCMBQkvrTKj6//CAXBJ25eIjFb28T4Jwg49K1qj66E20zJsFNXMnUKTSfuePedC/hQoRkmuDS2hghm1e2FmdHmyKSI+gfWyC6qecJ7OR/49N8lUbFSBauDuRjc4qgTEXss3AnYzmf6ilKL3hoZFQ4QAC6Wm+e/FHJ7UFMnHd570MoKVuOpW+NU1OjcXH137Zekyr9V9LXmWqaNXuvW1CFZzlHsdFpf2dKL/50tZtIMkms6NX46MTp5Yed63o68vq5/xNvUc8UJdbtuA+gyYU+NLh7UVuT5PnxjQ02uWp3xXfXgePJO8d0poJrdpAv+ELb2dVvVh1dUts8+fU7Twatq1NP68vHgXat61OTfND3LGwge+iY9a26oZZcpIUpv9DJvAVylf5oI87x83MSAeHpmyHU/JCNLhoIYoZ771l9aA7j5dQAGIgAAA",
    // default if empty
    hover: "A Prime Testnet address starts with addr_test1."
  },
  afpm: {
    label: "APEX Fusion Prime Mainnet",
    badge: "AF Prime Mainnet",
    description: "The decentralized backbone of Apex Fusion, securing the base layer utilizing Ouroboros liquid staking consensus protocol.",
    link: "https://apexfusion.org/",
    icon: "data:image/webp;base64,UklGRtIDAABXRUJQVlA4IMYDAACwEACdASpAAEAAPpE6mEgloyIhLhkqqLASCWQArZuEV99m/V7ffnwNMd3ny0IJ+9nMwkHiya/yFiF3PPig4nToPoRmuMejl4Nh+b7vep/pgHQQSkFPJTZ9qwwm1Xk3eK/M9A+w8RPsaeAZry3r1fSJgftip5LAs/9QJhJA4sKAfyY0/5Q0sUkgtSdPvoj8AP750mmntD2vOl9J25ZZfQJEc2X8wPUl7zcuAiQTcrDqJ8IESA/3AqKT+Q1OuwwcVu8T9CC/wZH/Z38JTiidzeggnh8ssSem5IbrXESE9pg5bnN3JgMJ/e4Rt2ek6W02rjSdIsv0ue9+EYmlpg2Zed8lVAdj19NQoUDDeMPAQISRB7h90u8IlQffJl89u6twqbfaNF3+PoB0iuiu2R9nmmrFZ9XlTb3h9iXsS4mcvBEJ5zZ4377JnGATIf54/z0u0+af/tOmOX/zpHziq5zW3tbL5webGqjD0SZIbrX2B/acf4/rU2v0Nqjse3/RZMfSxPmUTdFtzx/lRrvrYzVmoO3upcVWuLtSfHt4ENDbrUGaENIPVPoDi86SphIC0gKDHtxHZRK8WJqhgBnBN1V4ie8BRcYP2CgoSnSAafKyIzuvGlOaANiVrw52FIyMN7ulzuJqaIAgq1vczP+ZDCrnjgNAtPvNFKgacQsRQo3NLak1KKjxns4C5Se70tH37u6DmHfdwLYVqb71OzfTDWmvfwPHACm8xwQtetNU4elr1vJYD6cuy80xpfhezLRFu7mLJkTBI0vlwm9S9z4tsuTe2oJe4n7ARGMIuvV9DIOqpRRQh13lYlGi4JY5rhwDVUYo9mmr7H+KqwOYhup9YCXluLaI6DzbxU9UvsYV6LLNJkZCivr/7Yf17wv8s+UyQjiTv/G49uq1GTVpk8Dt8JbBxUX13EJgyQrw0v6XoaMm3CI+vBlxFTsu0JSZMu1vMjnOpi0JZnc5MKKwzNsCklYqZXqyL6GFvJ3ZbQYCrbJTEdjrYocfNVcFYS8PiHwLN5cophxsMmFeC6hdCOL6ul1dYw1+HRhlx1MN/BAzFvRtbXs+u53sE93q8aEe5ZNe65fEbdodp0znkrgV/Gf83Rt3N3HsaSxJrZ2IrlQZfW6/mNLRtEp223WJKgeMFJ7FSbUZh9BNIs0faOwsWIqApOpdI9L4TzOxcW+7uJ5G69q3344kKhH7SDVL2M9sITa3oTp8fNg0wQx56l2NikD/5IkR5zEs3540K1+UyWVCYfu/Qf9hy3cDEoSnw2hSFAUJXYTrxfMG4E8KAAA=",
    // default if empty
    hover: "A Prime Mainnet address starts with addr1."
  },
  sendTo: {
    adahandleMainnet: {
      label: "ADA Handle",
      icon: "images/adahandle.svg"
    },
    milkomedaC1: {
      label: "Milkomeda C1",
      icon: "images/milkomeda.svg"
    }
  },
  epochModal: {
    header: "Possible fixes (no connection)",
    subHeader: "Please follow these steps, and keep in mind that after a new epoch starts, all servers need to catch up.",
    joinDiscord: "Join our Discord",
    joinTelegram: "Join our Telegram",
    steps: {
      1: {
        title: "Step 1",
        description: "Please click the following link to manually try to reconnect:"
      },
      2: {
        title: "Step 2",
        description: "Please check if you're on a restricted network, such as a work network."
      }
    }
  }
};
const balance = {
  total: "Total funds",
  balance: "@.capitalize:common.label.balance",
  lockedFunds: "Available Funds Breakdown",
  lockedTotal: "Est. locked",
  lockedAvailable: "Est. available",
  lockedFees: "Transaction fees",
  lockedInPendingInputs: "pending inputs",
  lockedInPendingCollateral: "pending collateral",
  lockedUtxos: "Locked UTxOs",
  lockedByTokens: "Currently bound to tokens",
  lockedByTokensTF: "Token Fragmentation",
  lockedByCollateral: "Collateral UTxO",
  lockedAsRewards: "Rewards (not a UTxO)",
  svActiveLocks: "Active locks",
  svLockedRewards: "Rewards locked",
  svRedeemableRewards: "Rewards redeemable",
  svExternal: "External funds",
  svRedeemable: "Redeemable",
  svRedeemableLocks: "Redeemable locks",
  info: {
    lockedInPendingInputs: {
      title: "@:common.balance.lockedInPendingInputs",
      caption: "These funds are being used in a pending transaction."
    },
    lockedInPendingCollateral: {
      title: "@:common.balance.lockedInPendingCollateral",
      caption: "Collateral funds being used in a pending transaction."
    },
    lockedUtxos: {
      title: "@:common.balance.lockedUtxos",
      caption: "Locked funds, not to be spent by @:common.label.project or dapps - Manually select utxos to be unlocked on page: Account > UTxO List."
    },
    lockedByTokens: {
      title: "@:common.balance.lockedByTokens",
      caption: "Within Cardano, any token/nft has some ADA attached, the locked by tokens amount tells you (estimate) how much this is for your current wallet.",
      linklabel: "Read more about minimum ada value requirement"
    },
    lockedByTokensTF: {
      title: "@:common.balance.lockedByTokensTF",
      caption: "Organizing all of your UTxOs using Token Fragmentation would bind this much ADA. ",
      linklabel: ""
    },
    lockedByCollateral: {
      title: "@:common.balance.lockedByCollateral",
      caption: "Reserved funds, to be used as collateral by @:common.label.project - These funds can however be spent at any time, and will be selected if no other funds are available for a transaction.",
      linklabel: "Read more about the collateral mechanism"
    },
    lockedAsRewards: {
      title: "@:common.balance.lockedAsRewards",
      caption: "Rewards are not spendable in dapps and must be withdrawn first. @:common.label.project can do this automatically, go to: Account > Wallet Settings > Auto Withdrawal, and enable it.",
      linklabel: "Read more about the rewards mechanism"
    },
    lockedFees: {
      title: "@:common.balance.lockedFees",
      caption: "Submitting transactions to the Cardano blockchain costs transaction fees.",
      linklabel: ""
    }
  },
  stake: {
    total: {
      label: "Stake breakdown",
      hover: "Total staked on this wallets stake key."
    },
    notstaked: {
      label: "@.capitalize:common.label.notStaked",
      hover: "ADA not staked, placed on enterprise addresses."
    },
    controlled: {
      label: "@.capitalize:common.label.controlledStake",
      hover: "ADA staked to the stake key of this account (either owned, external or in smart contracts)."
    },
    external: {
      label: "Staked externally",
      hover: "ADA from this account combined with any external staking keys."
    }
  },
  rewards: "@.capitalize:common.label.rewards"
};
const assets = {
  label: "Assets",
  caption: "Add funds and (optionally) tokens to send.",
  info: {
    default: "is the minimum amount required. This is the amount that must to be contained in every UTxO with no additional data/token. It's a protocol parameter of the Cardano network, called 'minUTxOValue'.",
    all: "All funds will be sent (including ALL tokens, rewards, collateral, locked UTxOs)",
    allRewards: "",
    tokens: "",
    collateral: "",
    lockedUtxos: ""
  },
  token: "@.capitalize:common.label.token",
  added: "Funds to send updated due to added token, new minimum amount: ",
  removed: "Funds to send updated due to token removal, new minimum amount: ",
  notFound: "Selected token not found, please retry or contact support."
};
const tx = {
  status: {
    verified: "Verified!",
    pending: "Successfully submitted",
    unknown: "unknown",
    signed: "Signed",
    onchain: "On chain",
    failed: "Failed"
  },
  included: "Included in transaction: ",
  submitting: "Submitting transaction...",
  waiting: "Successfully submitted, waiting for next block...",
  note: {
    missingkeys: {
      label: "No Account Keys Detected.",
      text: "This transaction does not need any witness from the currently selected account. Signing this transaction does nothing. Select the correct DApp account to be able to sign this transaction.",
      icon: "mdi mdi-information-outline"
    },
    ishwsigning: {
      label: "Follow the instructions on your HW device.",
      text: "Follow the instructions on your device to sign this transaction.",
      icon: "mdi mdi-sync",
      animation: "animate-spin-ccw"
    }
  }
};
const txtype = {
  uninitialized: "Uninitialized",
  sent: "Sent",
  received: "Received",
  withdrawal: "Withdrawal",
  deposit: "Deposit",
  intraWallet: "Internal Transfer",
  external: "External Transaction",
  catalyst: "Catalyst Voting Registration",
  builder: "Builder",
  ada: "Funds",
  and: "and",
  tokens: "Tokens",
  unknown: "Unknown"
};
const ledger = {
  transport: {
    label: "@:common.label.transport",
    caption: "Set @:common.label.transport communication protocol.",
    info: 'To communicate with a Ledger device, the transport protocol has to be set. The "Auto" default will attempt a connection using a probably supported protocol, eg. on the web via WebUSB. This setting can be manually overwritten be selecting a protocol explicitly.',
    warning: 'This is considered an advanced feature. If unsure, leave on "Auto".',
    button: {
      icon: "mdi mdi-transit-connection-variant"
    }
  }
};
const message = {
  faildb: "Error: wallet creation failed: Storing in indexedDB allowed?",
  failmnemonic: "Error: Entered recovery phrase is not valid.",
  copy: {
    notify: "Copied: ",
    pubKey: "Copy account public key",
    catalyst: "Copy Catalyst Hash"
  },
  important: "Important!",
  validAmount: "Enter a valid amount.",
  duplicate: "A wallet already exist with the same wallet id. Redirected to this wallet.",
  onchainfile: "Open On-Chain File",
  onchainfiles: "On-Chain File Types for Token",
  shelleySupport: "Only Shelley era wallets supported."
};
const error = {
  account: "Unable to get wallet account, please reload or contact support if recurring.",
  genesis: "Unable to get genesis object, please reload or contact support if recurring.",
  minUtxo: "Minimum UTxO value not met, please set at least ",
  fundsLow: "Insufficient funds.",
  knownScammer: {
    label: "Warning",
    text: "You entered a known scammer address. Your device might be infected by a malware or you wanted to send funds to a 1 for 2 scammer. If this is not the case, contact @:common.label.project",
    icon: "mdi mdi-alert-octagon-outline"
  }
};
const address = {
  label: "@.capitalize:common.label.address",
  enterReceive: "Enter the address of a recipient or an ADA handle",
  selectReceive: "Select a @:common.label.receiveAddress.",
  used: "Already used wallet addresses",
  invalid2: "invalid",
  invalid: "Not a valid address. Make sure it's an address for the current network and it is either a valid Shelley or Byron (legacy) address.",
  handle: {
    notFound: "ADA Handle not found."
  }
};
const accountkey = {
  headline: "Import Public Account Key (read-only wallet)",
  caption: "Enter a public account key (usually starts with 'acct_xvk' or 'xpub1') to create a 'read-only' wallet.",
  info: "Insert your public account key here. It usually starts with 'acct_xvk' or 'xpub1'. This will create a 'read-only' wallet. You will be able to inspect the wallet and its transaction and delegation history, but won't be able to spend any funds or delegate to stake pools.",
  hint: "acct_xvk...",
  error: "Not a valid public account key.",
  button: {
    label: "Start Import Process"
  }
};
const walletCreation = {
  success: "Wallet created successfully.",
  faildb: "Error: Wallet creation failed: Storing in indexedDB allowed?",
  failmnemonic: "Error: Entered @:common.label.recoveryPhrase is not valid.",
  duplicate: "A wallet with the same id already exists. Redirected to this wallet.",
  inProgress: "Wallet is being created, please wait a moment and don't close this window!",
  accounts: "Accounts are being created, please wait a moment and don't close this window!",
  restart: "@:common.label.project couldn't access your local storage/database, please restart your browser and try again."
};
const marketplace = {
  prices: {
    "description": "Price composition",
    "price": "Price",
    "avg": "Average",
    "min": "Minimum",
    "max": "Maximum",
    "count": "Queried ###COUNT### marketplaces",
    "updated": "Updated at"
  },
  "tokhun": {
    short: "tokhun.io"
  },
  "jpgstore": {
    short: "jpg.store"
  },
  "muesliswap": {
    short: "MuesliSwap"
  },
  "sundaeswap": {
    short: "SundaeSwap"
  },
  "minswap": {
    short: "Minswap"
  },
  "cnftjungle": {
    short: "CNFTJungle"
  },
  "wingriders_muesli": {
    short: "Wingriders"
  }
};
const scam = {
  guard: {
    warning: "Eternl Guard Warning"
  },
  token: {
    label: "SCAM",
    description: "This is a known SCAM token!<br>Website links shown here are scam!<br>If you connect to those websites and sign a transaction your wallet might be drained completely!",
    image: "Warning:\n\nDo not interact with any website that is mentioned in this image!",
    hover: "This transaction contains a known scam token. Please be cautious when interacting with it!"
  },
  app: {
    description: "This DApp is a known SCAM site! There is a very high chance it will steal your funds or try to scam you in other ways!",
    description2: 'We strongly advise you to <span class="cc-text-extra-bold">NOT INTERACT</span> with this page!',
    ownRisk: "Connect to this site on your own risk!"
  },
  address: {
    description: "This is a known SCAM address! There is a very high chance you do not want to send your funds there!",
    description2: 'We strongly advise you to <span class="cc-text-extra-bold">NOT SEND</span> funds to it!',
    hover: "This address was used to steal funds!"
  }
};
const common = {
  url: {
    project: "eternl.io",
    telegram: "https://t.me/eternlio",
    discord: "https://discord.gg/eternlwallet",
    twitter: "https://twitter.com/eternlwallet"
  },
  symbol: {
    ada: "",
    tada: "t",
    apex: "",
    tapex: "t"
  },
  time: {
    day: "d",
    remaining: "remaining"
  },
  label,
  status,
  message,
  error,
  network,
  address,
  balance,
  assets,
  tx,
  txtype,
  accountkey,
  walletCreation,
  ledger,
  marketplace,
  scam,
  spendingPassword: {
    label: "Spending Password",
    caption: "Geben Sie Ihr Ausgaben-Passwort ein oder unterschreiben Sie mit einem Hardware-Gert, um die Transaktion zu besttigen.",
    hint: "Ausgaben-Passwort fr die Wallet eingeben"
  },
  recoveryphrase: {
    caption: "Enter your @:common.label.walletPhrase word for word. Make sure you enter the words in the correct order. \nAlso ensure nobody is looking at your screen."
  },
  notify: {
    clipboard: "Copied to Clipboard!"
  }
};
const groupname = {
  label: "Wallet group",
  info: "Group wallets in wallet list by a common name, default: 'My Wallets'",
  hint: "eg. My Wallets",
  error: "A wallet group name requires at least 3 and at most 40 characters."
};
const entity = {
  label: "Reporting entity",
  info: "Group wallets in list for reporting purposes, default: 'personal'",
  hint: "eg. personal",
  error: "A wallet entity name requires at least 1 and at most 40 characters."
};
const accountname = {
  label: "Account name",
  info: "Choose a telling account name, eg. 'NFT Vault'",
  hint: "eg. Defi account",
  error: "An account name requires at least 1 and at most 40 characters."
};
const walletname = {
  label: "Wallet name",
  info: "Choose a telling wallet name, eg. 'Staking wallet'",
  hint: "eg. My shopping wallet",
  error: "A wallet name requires at least 3 and at most 40 characters.",
  duplicate: "A wallet with this name already exists."
};
const general = {
  enter: {
    label: "Password",
    info: "",
    hint: "Enter a password",
    error: ""
  },
  repeat: {
    label: "@:form.password.spending.repeat.label",
    info: "@:form.password.spending.repeat.info",
    hint: "Repeat the password",
    error: "@:form.password.spending.repeat.error"
  },
  current: {
    label: "",
    info: "",
    hint: "Enter password.",
    error: ""
  },
  encryptmsg: {
    label: "",
    info: "",
    hint: "cardano",
    error: ""
  }
};
const spending = {
  enter: {
    label: "Enter password",
    hint: "Enter a strong spending password",
    error: "The spending password requires at least 12 characters.",
    info: "A strong password contains lower and upper case letters, numbers, special characters and is at least 12 characters long.\n\nA password manager app (PMA) is highly recommended! Use your PMA to create unique long passwords for each wallet and\npaste them into the fields.\n\nNever reuse passwords.",
    weak: "This password is considered weak.",
    moderate: "This password is considered moderate.",
    strong: "This password is considered strong."
  },
  repeat: {
    label: "Repeat password",
    hint: "Repeat the spending password",
    error: "Passwords don't match.",
    info: "Both entered passwords must match."
  },
  current: {
    label: "Current Spending password",
    hint: "Enter the current spending password",
    error: "This password does not unlock the wallet keys. Please enter the correct password.",
    info: "Enter the current spending password."
  },
  sign: {
    label: "Sign",
    info: "Enter the spending password of your wallet. It's the password you entered when you created/restored this wallet.",
    hint: "Enter the spending password",
    error: "The entered password does not match the spending password of this wallet."
  },
  addAccount: {
    label: "Spending Password",
    info: "@:form.password.sign.info",
    hint: "Enter the spending password to add an account",
    error: "The entered password does not match the spending password of this wallet."
  }
};
const access = {
  enter: {
    label: "Wallet Access password",
    info: "The access password can be of any length.",
    hint: "Enter an access password",
    error: "The access password requires at least 4 characters."
  },
  repeat: {
    label: "@:form.password.spending.repeat.label",
    info: "@:form.password.spending.repeat.info",
    hint: "Repeat the access password",
    error: "@:form.password.spending.repeat.error"
  },
  current: {
    label: "Current Wallet Access Password",
    info: "Enter the current access password. If you have not set any password, leave this empty.",
    hint: "Enter the current access password.",
    error: "This password does not unlock the wallet. Enter the correct password, please."
  }
};
const password = {
  label: "@:common.label.password",
  general,
  spending,
  access
};
const mnemonic = {
  label: "@:common.label.recoveryPhrase",
  hint: {
    label: "@:common.label.attention",
    text: "Make sure you write down the 24 words of your @:common.label.walletPhrase on a piece of paper in the exact order shown here (take no shortcuts, those words are crucial!).",
    icon: "mdi mdi-alert-octagon-outline"
  },
  notice: "I understand that the only way to recover my wallet if my computer is lost, broken, stolen or stops working is to use my wallet recovery phrase.",
  toggle: {
    acknowledged: {
      label: "Write it down!",
      text: "Yes, I wrote it down carefully.",
      icon: "mdi mdi-checkbox-blank-outline -mt-0.5"
    }
  }
};
const mnemonichint = {
  label: "@:common.label.recoveryPhrase",
  text: "On the following page, you will be given a list of 24 words to write down on paper and keep in a safe place. This list of words is the @:common.label.walletPhrase for the wallet you are creating. It can be entered in any other wallet app in order to access your wallet's funds and private keys.",
  hint: "The simplest way to keep your @:common.label.walletPhrase secure is to never store it digitally or online. If you decide to use an online service, such as a password manager app with an encrypted database, it is your responsibility to make sure that you use it correctly.\n\nUsing your @:common.label.recoveryPhrase is the only way to recover your wallet if your computer is lost, broken, stolen or stops working.",
  icon: "mdi mdi-alert-octagon-outline",
  toggle: {
    acknowledged: {
      label: "@:common.message.important",
      text: "I confirm that nobody can see my screen, because anyone who knows my @:common.label.recoveryPhrase will be able to spend the funds in my wallet.",
      icon: "mdi mdi-checkbox-blank-outline -mt-0.5"
    }
  }
};
const mnemonicwordinput = {
  label: "enter word",
  info: "Enter a character to get suggestions.",
  hint: "",
  error: "The input doesn't match the current word.",
  errorKey: "The entered word list is not a valid word list. Please check all words carefully.",
  correct: {
    label: "Success",
    text: "The simplest way to keep your wallet recovery phrase secure is to never store it digitally or online. If you decide to use an online service, such as a password manager with an encrypted database, it is your responsibility to make sure that you use it correctly.",
    icon: "mdi mdi-information-outline"
  }
};
const mnemonicinput = {
  label: "@:common.label.recoveryPhrase",
  input: mnemonicwordinput,
  instructions: {
    label: "@:common.label.instructions",
    text: "@:common.recoveryphrase.caption",
    icon: "mdi mdi-information-outline"
  },
  hint: {
    label: "@:common.label.attention",
    text: "@:form.mnemonic.hint",
    icon: "mdi mdi-alert-octagon-outline"
  },
  toggle: {
    label: "@:common.message.important",
    text: "@:form.mnemonic.notice",
    icon: "mdi mdi-checkbox-blank-outline"
  },
  button: {
    continue: "@:common.label.continue"
  }
};
const mnemonicconfirm = {
  label: "Confirm @:common.label.recoveryPhrase",
  input: mnemonicwordinput,
  instructions: {
    label: "@:common.label.instructions",
    text: "@:common.recoveryphrase.caption",
    icon: "mdi mdi-information-outline"
  },
  hint: {
    label: "@:common.label.attention",
    text: "@:form.mnemonic.hint",
    icon: "mdi mdi-alert-octagon-outline"
  },
  toggle: {
    label: "@:common.message.important",
    text: "@:form.mnemonic.notice",
    icon: "mdi mdi-checkbox-blank-outline"
  },
  button: {
    continue: "@:common.label.continue"
  }
};
const form = {
  groupname,
  entity,
  accountname,
  walletname,
  password,
  mnemonic,
  mnemonichint,
  mnemonicinput,
  mnemonicconfirm
};
const addressbook = {
  label: {
    global: "@:common.label.addrbook"
  },
  caption: "Add, delete and edit @:common.label.addrbook entries.",
  table: {
    header: {
      name: "@:common.label.name",
      address: "@:common.label.address",
      action: "@:common.label.action"
    }
  },
  button: {
    addEntry: "+ Add Entry",
    edit: "@:common.label.edit",
    send: "@:common.label.send to @:common.label.address",
    save: "@:common.label.save",
    delete: "@:common.label.delete",
    cancel: "@:common.label.cancel",
    add: "@:common.label.add",
    global: "Add to @:common.label.addrbook",
    sync: "Sync handle address"
  },
  edit: {
    title: {
      global: {
        label: "Edit address book",
        caption: "Edit an entry of the address book"
      }
    }
  },
  sync: {
    update: "Handle address was updated",
    noupdate: "No change in handle address detected",
    error: "Can't get get handle address, please try again or contact support if recurring."
  },
  add: {
    title: {
      label: "Add to address book",
      caption: "Add an entry to the address book",
      success: "Successfully added ###name### to address book",
      error: "Could not add ###name### to address book"
    },
    name: {
      label: "Entry name",
      hint: "Enter a name for the bookmark.",
      error: {
        length: "An @:common.label.addrbook entry name requires at least 3 and at most 40 characters.",
        duplicate: "An @:common.label.addrbook entry with this name already exist, please choose another one.",
        handle: "@:common.address.handle.notFound"
      }
    },
    addr: {
      label: "@:common.label.address",
      hint: "Enter a valid Cardano address.",
      error: {
        format: "@:common.address.invalid",
        duplicate: "An @:common.label.addrbook entry with the name '###name###' already exist for this address, please choose another or edit/delete existing."
      }
    }
  },
  delete: {
    label: "@.capitalize:common.label.confirm",
    confirm: "Confirm deletion of @:common.label.addrbook entry with name '###name###'",
    local: {
      label: "Success. Delete Local Entry?",
      message: "Successfully added '###name###' to address book, do you want to delete local wallet entry?"
    }
  },
  globalsave: {
    success: "Saved to @:common.label.addrbook",
    error: "An entry with ###error### already exist in the @:common.label.addrbook"
  }
};
const reportlabels = {
  label: {
    global: "Report Entities"
  },
  caption: "Add, delete and edit report entities entries.",
  table: {
    header: {
      name: "@:common.label.name",
      address: "comment",
      action: "@:common.label.action"
    }
  },
  button: {
    addEntry: "+ Add Entity",
    edit: "@:common.label.edit",
    send: "@:common.label.send to @:common.label.address",
    save: "@:common.label.save",
    delete: "@:common.label.delete",
    cancel: "@:common.label.cancel",
    add: "@:common.label.add",
    global: "Add to Report Entities",
    sync: "Sync handle address"
  },
  edit: {
    title: {
      global: {
        label: "Edit Report Entities",
        caption: "Edit an entry of the Report Entities"
      }
    }
  },
  sync: {
    update: "Handle address was updated",
    noupdate: "No change in handle address detected",
    error: "Can't get get handle address, please try again or contact support if recurring."
  },
  add: {
    title: {
      label: "Add to Report Entities",
      caption: "Add an entry to the Report Entities",
      success: "Successfully added ###name### to Report Entities",
      error: "Could not add ###name### to Report Entities"
    },
    name: {
      label: "Entry name",
      hint: "Enter a name for the bookmark.",
      error: {
        length: "An Report Entities entry name requires at least 3 and at most 40 characters.",
        duplicate: "An Report Entities entry with this name already exist, please choose another one.",
        handle: "@:common.address.handle.notFound"
      }
    },
    addr: {
      label: "@:common.label.address",
      hint: "Enter a valid Cardano address.",
      error: {
        format: "@:common.address.invalid",
        duplicate: "An Report Entities entry with the name '###name###' already exist for this address, please choose another or edit/delete existing."
      }
    }
  },
  delete: {
    label: "@.capitalize:common.label.confirm",
    confirm: "Confirm deletion of Report Entities entry with name '###name###'",
    local: {
      label: "Success. Delete Local Entry?",
      message: "Successfully added '###name###' to Report Entities, do you want to delete local wallet entry?"
    }
  },
  globalsave: {
    success: "Saved to Report Entities",
    error: "An entry with ###error### already exist in the Report Entities"
  }
};
const reportEntity = {
  label: "Report Entity",
  caption: "Entities group wallet groups for reporting.",
  selectedWalletGroups: {
    label: "Selected Wallet Groups",
    caption: "Select the wallet groups you want to include in this report entity."
  },
  reportGeneration: {
    label: "Generate reports",
    caption: "Queue reports for generation."
  },
  reportRefinement: {
    label: "Balance Metadata",
    caption: ""
  },
  reportProcessing: {
    label: "Create Reports (day, month, year)",
    caption: ""
  },
  allEntityGroups: {
    label: "+ All Entity Groups"
  },
  reportLabels: {
    label: "Report Labels",
    caption: "Mark external addresses with a label.",
    table: {
      header: {
        entity: "entity",
        name: "@:common.label.name",
        address: "@:common.label.address",
        action: "@:common.label.action"
      }
    },
    add: {
      success: "Successfully added ###name### to address book",
      error: "Field cannot be empty.",
      label: {
        label: "Label",
        hint: "Enter a label for this address."
      },
      address: {
        label: "Address",
        hint: "Enter the address for this label."
      },
      entity: {
        label: "EntityId",
        hint: "Enter the entity for this label."
      }
    },
    delete: {
      title: "Delete a Report Label",
      caption: "Are you sure you want to delete this report label?",
      id: {
        label: "Name",
        hint: "e.g. a person's name or a company name",
        error: "Can't be empty."
      },
      comment: {
        label: "Comment (optional)",
        hint: 'e.g. "personal funds"',
        error: ""
      }
    },
    button: {
      add: "Add Label"
    }
  },
  button: {
    add: "Add",
    newEntity: "New Entity",
    export: "Export",
    import: "Import",
    edit: "Edit",
    delete: "Delete",
    cancel: "Cancel",
    save: "Save",
    send: "Send to",
    sync: "Sync handle address"
  },
  table: {
    header: {
      name: "@:common.label.name",
      comment: "@:common.label.comment",
      action: "@:common.label.action"
    }
  },
  add: {
    title: "Create new @:setting.reportEntity.label",
    caption: "Group wallets into entities for reporting.",
    id: {
      label: "Name",
      hint: "e.g. a person's name or a company name",
      error: "Can't be empty."
    },
    comment: {
      label: "Comment (optional)",
      hint: 'e.g. "personal funds"',
      error: ""
    }
  },
  edit: {
    title: "Edit comment for @:setting.reportEntity.label",
    caption: "",
    comment: {
      label: "Comment (optional)",
      hint: 'e.g. "personal funds"',
      error: ""
    }
  },
  delete: {
    title: "Delete a @:setting.reportEntity.label",
    caption: "Are you sure you want to delete this report entity with all it's current data?",
    id: {
      label: "Name",
      hint: "e.g. a person's name or a company name",
      error: "Can't be empty."
    },
    comment: {
      label: "Comment (optional)",
      hint: 'e.g. "personal funds"',
      error: ""
    }
  }
  // label: {
  //
  //   global:                   'Report Entities'
  // },
  //
  // caption:                    'Add, delete and edit report entities entries.',
  //
  // table: {
  //
  //   header: {
  //
  //     name:                   '@:common.label.name',
  //     address:                'comment',
  //     action:                 '@:common.label.action'
  //   },
  // },
  //
  // button: {
  //
  //   addEntry:                 '+ Add Entity',
  //   edit:                     '@:common.label.edit',
  //   send:                     '@:common.label.send to @:common.label.address',
  //   save:                     '@:common.label.save',
  //   delete:                   '@:common.label.delete',
  //   cancel:                   '@:common.label.cancel',
  //   add:                      '@:common.label.add',
  //   global:                   'Add to Report Entities',
  //   sync:                     'Sync handle address',
  // },
  //
  // edit: {
  //   title: {
  //
  //     global: {
  //
  //       label:                'Edit Report Entities',
  //       caption:              'Edit an entry of the Report Entities',
  //
  //     }
  //   },
  // },
  //
  // sync: {
  //
  //   update:                   'Handle address was updated',
  //   noupdate:                 'No change in handle address detected',
  //
  //   error:                    'Can\'t get get handle address, please try again or contact support if recurring.'
  //
  // },
  //
  // add: {
  //
  //   title: {
  //
  //     label:                  'Add to Report Entities',
  //     caption:                'Add an entry to the Report Entities',
  //
  //     success:                'Successfully added ###name### to Report Entities',
  //     error:                  'Could not add ###name### to Report Entities'
  //   },
  //
  //   id: {
  //
  //     label:                  'Entry name',
  //     hint:                   'Enter a name for the bookmark.',
  //
  //     error: {
  //
  //       length:               'An Report Entities entry name requires at least 3 and at most 40 characters.',
  //       duplicate:            'An Report Entities entry with this name already exist, please choose another one.',
  //       handle:               '@:common.address.handle.notFound',
  //     }
  //   },
  //
  //   addr: {
  //
  //     label:                  '@:common.label.address',
  //     hint:                   'Enter a valid Cardano address.',
  //
  //     error: {
  //
  //       format:               '@:common.address.invalid',
  //       duplicate:            'An Report Entities entry with the name \'###name###\' already exist for this address, please choose another or edit/delete existing.'
  //     }
  //   }
  // },
  //
  // delete: {
  //
  //   label:                    '@.capitalize:common.label.confirm',
  //   confirm:                  'Confirm deletion of Report Entities entry with name \'###name###\'',
  //
  //   local: {
  //
  //     label:                  'Success. Delete Local Entry?',
  //     message:                'Successfully added \'###name###\' to Report Entities, do you want to delete local wallet entry?'
  //   }
  // },
  //
  // globalsave: {
  //
  //   success:                  'Saved to Report Entities',
  //   error:                    'An entry with ###error### already exist in the Report Entities'
  // }
};
const explorer = {
  label: "Blockchain explorers",
  caption: "Select your favorite explorer for various link types.",
  types: {
    block: "Block Explorer",
    pool: "Pool Explorer",
    address: "Address Explorer",
    token: "Token Explorer",
    policy: "Policy Explorer",
    transaction: "Transaction Explorer",
    stake: "Stakekey Explorer"
  },
  list: {
    cardanoscan: "Cardanoscan",
    adapools: "ADApools"
  },
  cardanoscan: {
    label: "CardanoScan",
    hover: "Open in @:setting.explorer.cardanoscan.label explorer"
  },
  cardanoscanPreprod: {
    label: "CardanoScan Preprod",
    hover: "Open in @:setting.explorer.cardanoscanPreprod.label explorer"
  },
  cardanoscanPreview: {
    label: "CardanoScan Preview",
    hover: "Open in @:setting.explorer.cardanoscanPreview.label explorer"
  },
  cexplorer: {
    label: "Cexplorer.io",
    hover: "Open in @:setting.explorer.cexplorer.label explorer"
  },
  cexplorerPreprod: {
    label: "Cexplorer.io Preprod",
    hover: "Open in @:setting.explorer.cexplorerPreprod.label explorer"
  },
  cexplorerPreview: {
    label: "Cexplorer.io Preview",
    hover: "Open in @:setting.explorer.cexplorerPreview.label explorer"
  },
  adastat: {
    label: "adastat.net",
    hover: "Open in @:setting.explorer.adastat.label explorer"
  },
  poolpm: {
    label: "pool.pm",
    hover: "Open in @:setting.explorer.poolpm.label explorer"
  },
  pooltool: {
    label: "Pooltool.io",
    hover: "Open in @:setting.explorer.pooltool.label explorer"
  },
  cardano: {
    label: "Cardano.org",
    hover: "Open in @:setting.explorer.cardano.label explorer"
  },
  poolpeek: {
    label: "Poolpeek",
    hover: "Open in @:setting.explorer.poolpeek.label explorer"
  },
  CNFT: {
    me: {
      label: "CNFT.me",
      hover: "Open in @:setting.explorer.CNFT.me.label explorer"
    }
  }
};
const setting = {
  addressbook,
  reportEntity,
  reportlabels,
  explorer
};
const header = {
  label: "@:common.label.project",
  bextab: "Fullscreen",
  menu: {
    tooltip: "main menu",
    open: {
      icon: "mdi mdi-menu"
    },
    close: {
      icon: "mdi mdi-menu-open"
    }
  }
};
const footer = {
  label: "",
  imprint: "Imprint"
};
const menu = {
  main: {
    add: {
      label: "Add Wallet",
      caption: "Create or restore a wallet.",
      icon: "mdi mdi-wallet-plus-outline"
    },
    news: {
      label: "News",
      caption: "The latest @:common.label.project news.",
      icon: "mdi mdi-bullhorn-outline"
    },
    faq: {
      label: "FAQ",
      caption: "Learn more.",
      icon: "mdi mdi-lightbulb-on-outline"
    },
    prefs: {
      label: "Preferences",
      caption: "Global Settings for this app.",
      icon: "mdi mdi-cog-outline"
    },
    report: {
      label: "Tax Export",
      caption: "",
      icon: "mdi mdi-cash"
    },
    dappbrowser: {
      label: "DApp Browser",
      caption: "Connect to Cardano dApps.",
      icon: "mdi mdi-connection"
    },
    directconnect: {
      label: "CardanoConnect",
      caption: "P2P Connections to supported DApps.",
      icon: "mdi mdi-transit-connection-horizontal"
    },
    walletconnect: {
      label: "WalletConnect",
      caption: "Connect to dApps through WC.",
      icon: "mdi mdi-transit-connection-horizontal"
    }
  },
  wallet: {
    account: {
      label: "@:common.label.account",
      labelShort: "@:common.label.accountShort",
      icon: "mdi mdi-cash",
      submenu: {
        summary: "@.capitalize:common.label.summary",
        tokenList: "@.capitalize:common.label.tokenList",
        utxoList: "@.capitalize:common.label.utxoList",
        accountList: "@.capitalize:common.label.accountList",
        dappbrowser: "DApp Browser",
        report: "Tax Export"
      }
    },
    transactions: {
      label: "@:common.label.transactions",
      labelShort: "@:common.label.transactionsShort",
      icon: "mdi mdi-text-box-outline",
      submenu: {
        history: "@.capitalize:common.label.transactionHistory",
        pending: "@.capitalize:common.label.pendingTransactions"
      }
    },
    send: {
      label: "@:common.label.send",
      labelShort: "@:common.label.sendShort",
      icon: "mdi mdi-cube-send",
      submenu: {
        send: "@.capitalize:common.label.send",
        builder: "TxBuilder",
        import: "Import"
      }
    },
    swap: {
      label: "@:common.label.swap",
      labelShort: "@:common.label.swap",
      icon: "mdi mdi-swap-horizontal"
    },
    receive: {
      label: "@:common.label.receive",
      labelShort: "@:common.label.receiveShort",
      icon: "mdi mdi-import"
    },
    staking: {
      label: "@:common.label.staking",
      labelShort: "@:common.label.stakingShort",
      icon: "mdi mdi-bank-plus"
    },
    voting: {
      label: "@:common.label.voting",
      labelShort: "@:common.label.votingShort",
      icon: "mdi mdi-vote-outline"
    },
    settings: {
      label: "@:common.label.settings",
      labelShort: "@:common.label.settingsShort",
      icon: "mdi mdi-cog-outline"
    },
    stakingvault: {
      label: "@:common.label.stakingvault",
      labelShort: "@:common.label.stakingvaultShort",
      icon: "mdi mdi-piggy-bank-outline"
    }
  }
};
const banner = {
  webapp: {
    line0: {
      part0: "Welcome to the @:common.label.project web app!"
    },
    line1: {
      part0: "Use this integrated ",
      part1: "DApp Browser",
      part2: " to connect to your favorite DApps."
    },
    line2: {
      part0: "For more DApps, use the ",
      part1: "@:common.label.project",
      part2: " browser extension on your computer or Android phone!"
    }
  },
  moving: {
    line0: {
      part0: "CCVaultio is now: Eternl!"
    },
    line1: {
      part0: "We moved over to ",
      part1: "eternl.io",
      part2: ""
    },
    line2: {
      part0: "Click to download the ",
      part1: "@:common.label.project",
      part2: " extension!"
    },
    line3: {
      part0: "Use Preferences > Wallet export (.json) and import on the new URL.",
      part1: "",
      part2: ""
    }
  }
};
const landingpage = {
  headline: "@:common.label.project",
  caption: "A Cardano light wallet.",
  text: "Our Mission: Establish @:common.label.project as one of the major Cardano wallets by implementing features requested by the Cardano community.",
  extensions: {
    headline: "Browser Extension (DApp connector & DApp Browser)",
    visit: "For Chrome, Edge, Brave and Opera browser extensions visit: "
  },
  ios: {
    headline: "DApp Browser",
    visit: "To utilize the DApp Browser on iOS devices, restore your Cardano wallet using Safari on:"
  },
  mobile: {
    headline: "Mobile Apps (DApp Browser)",
    visit: 'Your Cardano wallet "to go", now with DApp support: '
  },
  button: {
    wallets: {
      label: "Open Wallet"
    },
    learnmore: {
      label: "Learn More"
    }
  }
};
const imprint = {
  headline: "Imprint",
  contact: "Contact",
  drepid: "DRep Id",
  edc: "Eternl DRep Committee",
  discord: {
    label: "discord",
    icon: "fa-brands fa-discord",
    text: "Click to join our @:common.label.project discord server (with support ticket system)"
  },
  telegram: {
    label: "telegram",
    icon: "fa-brands fa-telegram",
    text: "Click to join our @:common.label.project telegram channel."
  },
  github: {
    label: "github",
    icon: "fa-brands fa-github",
    text: "If you have a feature request, please use the GitHub issue tracker. Click to open it in a new page."
  },
  email: {
    label: "email",
    icon: "mdi mdi-email",
    text: "Write us an email at team{'@'}eternl.io"
  },
  emaildrep: {
    label: "email",
    icon: "mdi mdi-email",
    text: "Write us an email at drep{'@'}eternl.io"
  },
  imprint: "Impressum",
  address: {
    label: "Sitz der Gesellschaft",
    text: "Tastenkunst GmbH\nGrassistrasse 12\n04107 Leipzig\nGermany"
  },
  person: {
    label: "Vertretungsberechtigte Personen",
    text: "Marcel Baumberg (Geschftsfhrer)"
  },
  company: {
    label: "Angaben zum Unternehmen",
    text: "Umsatzsteuer Identifikationsnummer (USt-ID): DE264395179\nHandelsregister Amtsgericht Leipzig: HRB 24784"
  },
  legallabel: "Haftungs- und Schutzrechtshinweise",
  legal0: {
    label: "Haftungsausschluss",
    text: "Die Inhalte dieses Onlineangebotes wurden sorgfltig und nach unserem aktuellen Kenntnisstand erstellt, dienen jedoch nur der Information und entfalten keine rechtlich bindende Wirkung, sofern es sich nicht um gesetzlich verpflichtende Informationen (z.B. das Impressum, die Datenschutzerklrung, AGB oder verpflichtende Belehrungen von Verbrauchern) handelt. Wir behalten uns vor, die Inhalte vollstndig oder teilweise zu ndern oder zu lschen, soweit vertragliche Verpflichtungen unberhrt bleiben. Alle Angebote sind freibleibend und unverbindlich."
  },
  legal1: {
    label: "Links auf fremde Webseiten",
    text: "Die Inhalte fremder Webseiten, auf die wir direkt oder indirekt verweisen, liegen auerhalb unseres Verantwortungsbereiches und wir machen sie uns nicht zu Eigen. Fr alle Inhalte und Nachteile, die aus der Nutzung der in den verlinkten Webseiten aufrufbaren Informationen entstehen, bernehmen wir keine Verantwortung."
  },
  legal2: {
    label: "Urheberrechte und Markenrechte",
    text: "Alle auf dieser Website dargestellten Inhalte, wie Texte, Fotografien, Grafiken, Marken und Warenzeichen sind durch die jeweiligen Schutzrechte (Urheberrechte, Markenrechte) geschtzt. Die Verwendung, Vervielfltigung usw. unterliegen unseren Rechten oder den Rechten der jeweiligen Urheber bzw. Rechteverwalter."
  },
  legal3: {
    label: "Hinweise auf Rechtsverste",
    text: "Sollten Sie innerhalb unseres Internetauftritts Rechtsverste bemerken, bitten wir Sie uns auf diese hinzuweisen. Wir werden rechtswidrige Inhalte und Links nach Kenntnisnahme unverzglich entfernen."
  },
  button: {
    home: "home"
  }
};
const announcements = {
  openWiki: "Open in @:common.label.project wiki",
  headline: "Announcements",
  post: {
    p0_210624: {
      datetime: "2021-06-28",
      time: "Jun 28, 2021",
      headline: "Soft launch of ccwallet.io - <br>a Cardano Community Wallet",
      summary: `Welcome! We are happy to announce, that ccwallet.io is now available as a beta for family and friends. 
We've put a lot of hard work into this first MVP release and would love your feedback on 
<a href="https://github.com/ccwalletio/tracker/issues" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>GitHub</strong></a>. 
You can also reach us through our 
<a href="https://t.me/eternlio" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Telegram channel</strong></a>.
<br><br>
Our Mission:
<br><br>
Establish @:common.label.project as a major Cardano wallet by implementing features requested by the Cardano community.
<br><br>
The Team:
<br><br>
TITANstaking [TITAN] and AHLNET [AHL]`
    },
    p1_210808: {
      datetime: "2021-08-08",
      time: "Aug 08, 2021",
      headline: "Release of ccwallet v1.0.8 - tons of improvements",
      summary: "Since our soft launch in June we got a ton of feedback from the Cardano community, most of which around token loading and handling.<br><br>\nThanks to community members and their huge token collections and transactions, we were able to rewrite the wallet sync code and \noptimize it to handle even the largest wallets out there.<br><br>Upcoming:<br>Manual transaction building (advanced send page),<br>one click \ntoken wallet defragmentation<br>...and many more features<br> "
    },
    p2_210819: {
      datetime: "2021-08-19",
      time: "Aug 19, 2021",
      headline: "Cleanup your wallet! - burn unwanted tokens",
      summary: 'Have a useless token or NFT? Send it to the following address to "burn" it:<br><br>\n<span class="break-all" style="color: #2563EB"><strong>addr1qxnk9w6e3azattu87ythnnjt2vmtlskzcld0ptwa924j0znz7v4zyqfqapmueh24l2r8v848mya68nndvjy783m656kq0cxjsn</strong></span><br><br>\nThis helps us test different token data and it helps you keep your wallet in order.<br><br>'
    },
    p3_210819: {
      datetime: "2021-08-19",
      time: "Aug 19, 2021",
      headline: "Fund6 - submitted Catalyst proposal",
      summary: 'We need your help!<br><br>\nWe submitted a proposal for Fund6 and would love your support for our ongoing development.<br><br>\nIf you have an ideascale account, please kudo: <a href="https://cardano.ideascale.com/a/dtd/ccwallet-io-light-web-wallet/366822-48088" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>cardano.ideascale.com</strong></a><br><br>\nRegister for voting and consider voting for us!<br><br>\nThanks for your support!'
    },
    p4_210911: {
      datetime: "2021-09-11",
      time: "Sep 11, 2021",
      headline: "Release of ccwallet v1.1.0 - Alonzo hard fork",
      summary: `We are excited about Cardano's Alonzo hardfork, which is scheduled for tomorrow, 
12th Sept. 2021, 21:44:51 UTC. It will bring smart contract capabilities to the Cardano blockchain<br><br>
ccwallet.io is ready for this event. Not only did we update our backend software, 
we also added more dedicated server capacity to be able to handle the rising traffic.<br><br>
We would like to thank every single one, who's using our wallet. Let us know what we can improve in our <a href="https://t.me/ccwalletio" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Telegram channel</strong></a>.`
    },
    p5_211106: {
      datetime: "2021-11-06",
      time: "Nov 06, 2021",
      headline: "Release of @:common.label.project v1.2.0 - and<br>'The Mesmerizer'",
      summary: 'In this version we rewrote a lot of code regarding routing and internal data handling in preparation \nof the soon to be released browser extension of @:common.label.project. Yes, you read that correctly.\n<br><br> \nccwallet.io is now <b><i>@:common.label.project</i></b>!<br><br>\nThe rebranding is necessary because a BTC wallet with the name ccwallet exists on the Apple App Store.\n<br><br>\nAlso announcing: <b><i>The Mesmerizer</i></b> - collection: 2021.\n<br><br>\nWe want to grow the team and innovate faster. But a simple donation button would have been kind of lame. So \nwe decided to create a 10k NFT token series with rarities and a completely onchain animation, that will totally \nmesmerize you, if you stare at it too long, hence the name.\n<br><br>\nPlease consider supporting us by buying a token on <a href="https://mesmerizer.buffybot.io/" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>mesmerizer.buffybot.io</strong></a><br><br>\nThank you! '
    },
    p6_211208: {
      datetime: "2021-12-08",
      time: "Dec 08, 2021",
      headline: "Release of @:common.label.project v1.3.0 - multi-accounts",
      summary: `This feature has been on our list for a long time: add multiple accounts to the same wallet.<br><br> 
After creating/restoring/pairing, your wallet will start with a single account. 
To add more accounts to your wallet, click on "Account #0" or the wallet pattern icon. 
You can add up to 24 accounts.<br><br>
Each account will act independently, but your wallet balance will add up all account balances.<br><br>
With all those new accounts an upgraded address book would be nice. That's what we added: the global address book.<br><br>
You can transfer your wallet address book entries to the global address book or add new entries directly. Check it out on 
the Settings page via the main menu.
<br><br>
Please consider supporting us by buying a token on <a href="https://mesmerizer.buffybot.io/" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>mesmerizer.buffybot.io</strong></a><br><br>
Thank you! `
    },
    p7_220104: {
      datetime: "2022-01-04",
      time: "Jan 04, 2022",
      headline: "Release of @:common.label.project v1.3.5 - Happy New Year!",
      summary: 'A little bit of a clean up release.<br><br>+ new logo<br>+ new transaction details (smart contracts, scripts, delegations, certificates, registrations, deregistrations)<br>+ address book visible by default<br>+ accounts removable<br><br>+ fixed: add more than 10 accounts<br>+ fixed: race condition for wallet data save<br>+ fixed: dapps can use other accounts than #0<br><br>Also released in December: browser extensions for Chrome, Edge, Brave, Opera: <a href="https://chrome.google.com/webstore/detail/kmhcihpebfmpgmihbkipmjlmmioameka" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Chrome Web Store</strong></a><br><br>Firefox pulled our extension for now.<br><br>Please consider supporting us by buying a token on <a href="https://mesmerizer.buffybot.io/" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>mesmerizer.buffybot.io</strong></a><br><br>\nThank you! '
    },
    p8_220120: {
      datetime: "2022-01-20",
      time: "Jan 20, 2022",
      headline: "Release of @:common.label.project v1.4.0 - dApp refinement!",
      summary: `@:common.label.project is now home for almost 30.000 accounts.<br><br>This brings its own challenges. The launch of SundaeSwap brought a lot of users and a lot of questions regarding our dApp-connector.<br><br>Now you need to explicitly select the account that you want to connect to dApps with. The enable popup only shows the origin and a connect and cancel button. So dApp connections should now be clearer.<br><br>We also added a new wallet settings: collateral.<br><br>This feature will detect whether you have a small Ada only UTxO, if not, it creates one for you and keeps track of it, so it doesn't get spent. If you use your wallet in different apps, eg. in the browser extension and on a mobile device, make sure to enable the collateral setting in all apps.<br><br>There are now indicators for which app you are currently using in the footer.<br><br>Fixes as usual, mostly dApp-connector related.<br><br>Let's see who can spot the new hidden feature first.<br><br>We now have an offical <a href="https://linktr.ee/eternlwallet" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Linktree</strong></a>.<br><br>Please consider supporting us by buying a token on <a href="https://mesmerizer.buffybot.io/" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>mesmerizer.buffybot.io</strong></a><br><br>
Thank you! `
    },
    p9_220308: {
      datetime: "2022-03-08",
      time: "Mar 08, 2022",
      headline: "Release of @:common.label.project v1.5.1 - dark mode!",
      summary: `Dark Mode is here! And the pending transactions UI! And so much more.<br><br>This release also includes a lot of invisible changes, eg. a new transaction build system, that will allow future versions of @:common.label.project to send transactions in parallel and chain transactions together. But that's for a later release.<br><br>Our offical links are here: <a href="https://linktr.ee/eternlwallet" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Linktree</strong></a>.<br><br>We also added a donation checkbox. You can now send 1 additional Ada with your transaction to support us.<br><br>Thank you! `
    },
    p10_220322: {
      datetime: "2022-03-22",
      time: "Mar 22, 2022",
      headline: "Release v1.5.4 - Eternl!",
      summary: '<img src="images/twitter_post_eternl_logo.jpeg"><br><strong>The future of CCVaultio: A lot of change are coming.</strong><br><br>Today, were excited to announce a new name, a new partnership, and an upcoming simplified design.<br><br>As some of you may remember, last year we started this project as ccwallet, then renamed to ccvault.io with the addition of mobile to our suite of apps.<br><br>Since then, as weve been building & scaling with the rate of new apps launching on Cardano, weve been thinking a LOT about our brand and what a next generation wallet UI could look like to accommodate both power users & newcomers to blockchain.<br><br>CCVaultio becomes Eternl.<br><br>Blockchain is forever, and as it changes the world around us, we felt we needed a brand that speaks to what were about, where were headed, and has broader reach as the Cardano community grows.<br><br>Weve partnered with our friends at Artifct to take our vision to the next level. From the rebrand, to designing a best-in-class wallet experience across web & mobile, we want Cardano to lead the way & the best way to do that as a community is together.<br><br>Over the next few updates, our apps will have the new name & logo, and work on the new UI (more on that soon) will begin as soon as we release our latest feature: Staking Vault. Exciting times ahead.<br><br>#Cardano #ADA $ADA #eternl #community<br>'
    },
    p11_220405: {
      datetime: "2022-04-05",
      time: "Apr 05, 2022",
      headline: "Release v1.6.1 - Staking Vault!",
      summary: `<img src="images/twitter_post_sv_logo.jpg"><br><strong>What is Staking Vault?</strong><br><br>Staking Vault is Eternl's funding mechanism.<br><br>We are committed to providing a reliable wallet experience. At scale, this costs a lot of money each month.<br><br>But you can help us cover that cost, grow the team and continue to innovate.<br><br>TLDR; Lock your long-term HOLD ADA in Staking Vault to generate more rewards than on a regular public pool and help us fund Eternl.<br><br>Please read the Staking Vault FAQ section (Wallet > Staking Vault > FAQ) to learn more about this rewards mechanism and the risks involved.<br><br>Our offical links to apps and social media: <a href="https://linktr.ee/eternlwallet" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Linktree</strong></a>.<br><br>#Cardano #ADA $ADA #eternl #community<br>`
    },
    p12_220506: {
      datetime: "2022-05-06",
      time: "May 06, 2022",
      headline: "Release v1.7.0 - DApp Browser!",
      summary: `<img src="images/twitter_post_dapp_browser.jpg"><br><strong>What is the DApp Browser?</strong><br><br>Until today, only wallet browser extensions were able to connect to DApps on Cardano. Starting today, Eternl users can connect their wallets to DApps listed in Eternl's DApp Browser.<br><br>We'll start with four pioneers who helped us iron out implementation details. A huge thank you goes out to Artifct, JPGstore, Sundaeswap and Minswap. We also invite other DApps to join as well. Ping us on Discord.<br><br>This will be the first comfort feature of Eternl. Transactions using the Dapp Browser for purchase values of 100 ADA or more will have a convenience fee of 0.1% fee or 1 ADA, whichever is greater, added to the transaction to help fund Eternl development.<br><br>This release is the first iteration and marked as beta. Please report any issues on Discord.<br><br>Our offical links to apps and social media: <a href="https://linktr.ee/eternlwallet" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Linktree</strong></a>.<br><br>#Cardano #ADA $ADA #eternl #community<br>`
    },
    p12_220506_ios: {
      datetime: "2022-05-06",
      time: "May 06, 2022",
      headline: "Release v1.7.0 - DApp Browser!",
      summary: `<img src="images/twitter_post_dapp_browser.jpg"><br><strong>What is the DApp Browser?</strong><br><br>Until today, only wallet browser extensions were able to connect to DApps on Cardano. Starting today, Eternl users can connect their wallets to DApps listed in Eternl's DApp Browser.<br><br>We'll start with four pioneers who helped us iron out implementation details. A huge thank you goes out to Artifct, JPGstore, Sundaeswap and Minswap. We also invite other DApps to join as well. Ping us on Discord.<br><br>This release is the first iteration and marked as beta. Please report any issues on Discord.<br><br>Our offical links to apps and social media: <a href="https://linktr.ee/eternlwallet" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Linktree</strong></a>.<br><br>#Cardano #ADA $ADA #eternl #community<br>`
    },
    p13_220622: {
      datetime: "2022-06-22",
      time: "June 22, 2022",
      headline: "Catalyst Proposals",
      summary: '<img src="images/catalyst_fund9.jpg"><br><strong> Please support us in Fund9 of Catalyst!</strong><br><br>Thanks to the encouragement of our community, we submitted 3 proposals for Catalyst Fund9.<br><br>1 <a href="https://cardano.ideascale.com/c/idea/418778" target="_blank" rel="noopener noreferrer" style="color: #2563EB">Enable Eternl</a><br><br>2 <a href="https://cardano.ideascale.com/c/idea/418841" target="_blank" rel="noopener noreferrer" style="color: #2563EB">Evolve Eternl</a><br><br>2 <a href="https://cardano.ideascale.com/c/idea/418881" target="_blank" rel="noopener noreferrer" style="color: #2563EB">Translate Eternl</a><br><br>Thank you all for your continued support! We hope to receive your vote in Fund9 to continue offering a reliable Cardano light wallet. <br><br>Our offical links to apps and social media: <a href="https://linktr.ee/eternlwallet" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Linktree</strong></a>.<br><br>#cardano #ada $ada # # #catalyst<br>'
    },
    p14_220719: {
      datetime: "2022-07-20",
      time: "July 20, 2022",
      headline: "Release v1.8.1 - Babbage",
      summary: '<img src="images/220720_eternl_wallpaper_2120p.jpg"><br><strong> Happy Birthday, Eternl! </strong><br><br>And what a first year it was! The soft launch of ccwallet actually happended on the 04th July 2021, so we are a bit late.<br><br>But today we released v1.8.1 of Eternl with support for the upcoming Babbage/Vasil hard fork, as well as our new TxBuilder feature.<br><br>TxBuilder allows you to add multiple outputs to a transaction and choose which utxos you want to spend. It also has support for custom json metadata. This is the first iteration of TxBuilder and we have many ideas on how to improve it further.<br><br>We want to thank every single one of you who supported Eternl in its first year. Thank you so much! <br><br>Our offical links to apps and social media: <a href="https://linktr.ee/eternlwallet" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Linktree</strong></a>.<br><br>#Cardano #ADA $ADA #eternl #community #anniversary #happybirthday<br>'
    }
  }
};
const faq$1 = {
  headline: "FAQ",
  post: {
    faq0: {
      question: "What is Eternl?",
      answer: "A Cardano light wallet for the Cardano community."
    },
    faq1: {
      question: "Who is developing Eternl?",
      answer: "The team consists of developers of community stake pools <strong>[TITAN] TITANstaking</strong> and <strong>[AHL] AHLNET</strong>. "
    },
    faq2: {
      question: "Can I submit a feature request?",
      answer: `Sure. Head over to 
<a href="https://github.com/ccwalletio/tracker/issues" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>GitHub</strong></a> 
and tell us more about the feature you'd like to see added.`
    },
    faq3: {
      question: "Is there a support chat for quick questions?",
      answer: 'Our main support channel is our <a href="https://discord.gg/eternlwallet" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Discord server</strong></a> with support ticket system. We also operate a <a href="https://t.me/eternlio" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Telegram channel</strong></a> and a <a href="https://twitter.com/eternlwallet" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Twitter account</strong></a> with limited support.'
    },
    faq4: {
      question: "Are there browser extensions?",
      answer: 'For Chrome, Edge, Brave and Opera visit: <br><a href="https://chrome.google.com/webstore/detail/kmhcihpebfmpgmihbkipmjlmmioameka" target="_blank" rel="noopener noreferrer" style="color: #2563EB"><strong>Chrome Web Store</strong></a>'
    },
    faq5: {
      question: "Can I restore my Yoroi/Daedalus/Other wallet in Eternl?",
      answer: "@:common.label.project is compatible with all other Cardano wallets. You can even turn on 'Single Address Mode' to load your Nami wallet."
    },
    faq6: {
      question: "Does @:common.label.project support other networks?",
      answer: 'Yes. Click on the bottom right "Mainnet" button to switch to different testnet networks or other supported Cardano based networks.'
    }
    // faq7: {
    //
    //   question:               'Can I support your work?',
    //   answer:                 'Our fundraider <strong>\'The Mesmerizer\'</strong> sold out! A huge <strong>\'Thanks you!\'</strong> to all our supporters. ' +
    //     'We are already working on collector 2022.'
    // },
  }
};
const preferences = {
  headline: "App Settings",
  caption: "Global @:common.label.project settings and features. For wallet specific settings, visit the wallet settings page.",
  addressbook: {
    label: "@:setting.addressbook.label.global",
    caption: "@:setting.addressbook.caption"
  },
  reportentities: {
    label: "Reporting Entities",
    caption: 'A list of all reporting entities. "all" includes all wallets. Add more entities and select wallets that belong to them.'
  },
  localization: {
    label: "Currency and Regional Options",
    caption: "Customize formatting and regional settings.",
    formatting: {
      label: "Formatting",
      caption: "Set number formatting based on region.",
      timezone: "Use UTC instead of local timezone."
    },
    timezone: {
      caption: "Choose your reporting timezone."
    },
    currencyConversion: {
      label: "Currency Conversion",
      caption: "Select the preferred currency for conversion or 'disabled' to hide."
    }
  },
  explorer: {
    label: "@:setting.explorer.label",
    caption: "@:setting.explorer.caption"
  },
  autoSubmit: {
    label: "Transactions: auto submit",
    caption: "Automatically submit transactions after signing. Disable to allow downloading signed transaction cbor."
  },
  submitApi: {
    label: "Custom Submit API Endpoint",
    caption: "Send transactions through a custom cardano-node and cardano-submit-api.",
    inputHint: "URL or IP",
    add: {
      label: "Add new custom submit api endpoint to the list of endpoints."
    },
    note: {
      headline: "Please note!",
      caption: "This is an advanced setting and you should only use it if you fully understand its implications.",
      description: "Make sure the custom endpoint is trustworthy and fully synced.\n\nIf not, the node operator may withhold the broadcasting of your transactions for its gain or won't broadcast it at all, and all your transactions could fail.\nIf you are unsure, then deactivate this setting to send transaction through the @:common.label.project infrastructure.",
      cors: "Also, ensure your custom endpoint has set the correct CORS header to accept the request @:common.label.project is sending."
    }
  },
  storage: {
    label: "Persistent data",
    caption: "We ask you for permission to make your wallet data more persistent. Manually clearing the browser data will still remove all data from your local device.",
    description: {
      label: "Why should I persist data ?",
      caption: "We store a lot of blockchain data locally, eg. wallet data, cached transactions, NFT images, and more.\n\nThe browser allows us to do so without your permission. But if your device runs low on disk space, the browser might clear this data without informing you.\n\nIf the data is cleared, your wallet data and its settings will be lost. The Persistent data setting allows the application to store the data more permanently in the browser and prevents that data gets cleared, even with low disk space."
    },
    quota: {
      label: "Storage space used:",
      caption: "Your currently used browser storage quote.",
      unkown: "not available",
      lowOnSpace: "You are using over ###LIMIT###% of your storage quota. <br>@:preferences.storage.quota.delete",
      full: "Your browser storage is full. <br>You wont be able to create new wallets and existing wallets will fail to sync. <br>@:preferences.storage.quota.delete",
      delete: "Consider deleting unused data from your indexedDb storage."
    },
    status: {
      persisted: "Your storage is persisted, the browser will try to keep the wallet data intact.",
      notPersisted: "Storage is not persisted yet. Please click the button to allow storing data persistingly.",
      noSupport: "Your browser does not support persisting storage.",
      supportedBrowsers: "Please use one of these browsers: Chrome >=55, Chrome Android >=55, Edge >=79, Firefox >=57, Opera >=42",
      noActivated: 'Your browser storage is nearly full. Please allow persisting storage in "Preferences > Persistent data" to decrease the risk of clearing wallet data.'
    },
    button: {
      label: "Set storage allowance"
    },
    allow: {
      success: "Storage allowance successfully set.",
      fail: "Could not set storage allowance."
    },
    chrome: {
      notification: {
        title: "Storage manager permission request!",
        caption: "Storage manager is now active and your wallet data is safe.",
        denied: "Please allow to send notifications. You will need to remove the denied permission manually."
      },
      modal: {
        label: "Info regarding storage setting on Chrome browsers",
        caption: "Please read the description.",
        button: "Continue",
        info: `You are about to set the browser permission, which allows us to store your wallet data permanently.<br><br>When using the Chrome browser, the application also needs the "Notification permission" to access the storage permission.<br>Please select <span class="italic font-semibold">"Allow notifications"</span> to ensure your wallet data is safe.<br><br>Rest assured that we won't show you any further notifications without asking for permission.`
      }
    },
    brave: {
      modal: {
        label: "Info regarding storage setting on Brave browsers",
        caption: "Please read the description.",
        button: "Continue",
        info: `You are about to set the browser permission, which allows us to store your wallet data permanently.<br><br>When using the Brave browser, the application also needs the "Notification permission" to access the storage permission.<br>Once you click the "Continue" button, a dialog will ask you for how long you want to allow that permission.<br><br>Please select <span class="italic font-semibold">"Allow forever"</span> to ensure your wallet data is safe.<br><br>Rest assured that we won't show you any further notifications without asking for permission.`
      }
    }
  },
  exports: {
    label: "Wallet export (.json)",
    caption: "WAIT! This option will export all wallet AS IS.\n\nIf a wallet is open, it is exported being open. Before hitting the button, make sure to lock all wallets that you want exported in a locked state.\n\nExported @:common.label.project .json files can be imported in any other @:common.label.project app.",
    button: {
      label: "Export All Wallets",
      icon: "mdi mdi-export"
    },
    transactions: {
      modalHeader: "Export your transactions",
      modalSubHeader: "Export your transactions and rewards to use for book keeping",
      syncNote: {
        label: "Please enable history sync",
        caption: "To export the full history of this account, you have to enable the History Sync.\nPlease do so in the Account Settings or click `Sync history` below. Doing so can take some time, depending on the account's transaction history size.",
        progress: "Sync in progress, please wait.",
        ready: "Ready to export",
        button: {
          label: "Sync history",
          icon: "mdi mdi-sync"
        }
      }
    }
  },
  save: "Setting successfully saved to storage.",
  error: {
    networkid: "NetworkId not set, this shouldn't happen, contact support if recurring.",
    load: "Failure while loading setting from storage, please reload site and contact support if recurring.",
    save: "Failure while saving setting to storage, please reload site and contact support if recurring."
  },
  // portfolio: {
  //
  //   label:                    'Pool Portfolio',
  //   caption:                  'Manage pool portfolio entries for multi-delegation.',
  //
  //   input: {
  //
  //     name: {
  //
  //       label:                '@:common.name',
  //       hint:                 'Enter portfolio name.',
  //
  //       error: {
  //
  //         length:               'A pool portfolio name requires at least 3 and at most 40 characters.',
  //         duplicate:            'A pool portfolio entry with this name already exist, please choose another or edit/delete existing.'
  //       }
  //     },
  //
  //     desc: {
  //
  //       label:                'Description (optional)',
  //       hint:                 'Enter a portfolio description.',
  //
  //       error: {
  //
  //         length:             'Description field is limited to 100 characters.'
  //       }
  //     },
  //   },
  //
  //   table: {
  //
  //     header: {
  //
  //       name:                 '@:common.name',
  //       desc:                 'Description',
  //       pools:                'Pool List',
  //       action:               '@:common.action',
  //     }
  //   },
  //
  //   button: {
  //
  //     enable:                 '+ Add Portfolio',
  //     edit:                   'Edit',
  //     save:                   '@:common.label.save',
  //     delete:                 '@:common.label.delete',
  //     cancel:                 '@:common.label.cancel',
  //     add:                    '@:common.label.add',
  //     selected:               'Show Selected',
  //     all:                    'Show All',
  //     show:                   'Show Pools in Portfolio'
  //   },
  //
  //   confirm: {
  //
  //     label:                  '@:common.label.delete',
  //     message:                'Confirm deletion of pool portfolio entry with name \'###name###\''
  //   }
  // },
  dapp: {
    allowlist: {
      label: "DApp Allowlist",
      caption: "The list of websites/dApps that are allowed to connect to this @:common.label.project app.",
      empty: "No dApps allowed yet.",
      type: {
        cip30: {
          label: "@:dapps.enable.access.cip30.label",
          caption: "",
          icon: "@:dapps.enable.access.cip30.icon"
        },
        cip95: {
          label: "@:dapps.enable.access.cip95.label",
          caption: "",
          icon: "@:dapps.enable.access.cip95.icon"
        },
        cip104: {
          label: "@:dapps.enable.access.cip104.label",
          caption: "",
          icon: "@:dapps.enable.access.cip104.icon"
        }
      },
      table: {
        header: {
          site: "Site",
          access: "Access",
          action: "@.capitalize:common.label.action"
        }
      },
      button: {
        remove: "Remove site access"
      },
      confirm: {
        label: "Remove Site Access",
        message: "Confirm removal of###cip###access for site with url: '###origin###'"
      }
    }
  },
  tool: {
    frankenaddr: {
      label: "Franken Address Generator",
      caption: "Combine two addresses to create a new address with payment credentials from the first and stake credentials from the second.\n\nA normal (base) address consists of two parts. A payment part that controls who can spend the funds on the address, and a stake part that controls what stake pool (if any) the funds are delegated to. It's possible to combine the payment part of an address (base or enterprise) from one wallet with the stake part of an address (base or stake) from another wallet to form a so-called 'Franken Address'.",
      hint1: "Payment part (base or enterprise address)",
      hint2: "Stake part (base or stake address)",
      addr1error: "Invalid address, only base or enterprise address for current network valid.",
      addr2error: "Invalid address, only base or stake address for current network valid."
    }
  },
  reset: {
    label: "Reset application",
    caption: "Remove all stored data for all wallets to reset the application.",
    finish: "Application reset successfully",
    noPasting: "Please type the confirmation phrase to reset @:common.label.project",
    button: {
      label: "Reset application",
      icon: "mdi mdi-delete-outline"
    },
    warning: "Once you reset the @:common.label.project app, you will lose access to all the wallets' remaining funds. The only way to regain access after reset is by restoring your wallet recovery phrase or importing previously exported @:common.label.project .json files.",
    confirmation: "Are you sure you want to reset the application?",
    inDelete: "@:common.label.project is being reset, please stand by.",
    deleteConfig: "Reset configurations",
    deleteWallets: "Reset wallets",
    deleteFinish: "Finishing",
    phrase: {
      confirmation: "Reset @:common.label.project",
      name: "Confirmation phrase",
      label: "@:common.wallet.name.label",
      hint: "Enter the confirmation phrase here!"
    },
    toggle: {
      acknowledged: {
        label: "",
        text: "I understand that the only way to regain access to my wallets is by restoring them with the wallet recovery phrases.",
        icon: "mdi mdi-checkbox-blank-outline -mt-0.5",
        error: "Your confirmation phrase does not match."
      }
    }
  },
  devsettings: {
    label: "Dev Settings"
  },
  clearCache: {
    label: "Reset application cache",
    caption: "Remove all cached data to reset the application.\nThis includes transactions, token images and metadata. Your wallets, accounts and settings will NOT be affected.",
    finish: "Application cache reset successful.",
    inProgress: "@:common.label.project cache is being reset, please stand by.",
    warning: "Once you reset the Eternl cache, the application must fetch all data from the blockchain again.If you have multiple wallets or accounts, this will take some time.",
    button: {
      label: "Reset application cache",
      icon: "mdi mdi-delete-outline"
    }
  },
  handleLists: {
    label: "ADA Handle Allow- / Blocklist",
    caption: "Create lists to restrict or allow the sending to specific ADA Handles.",
    handle: "ADA Handles",
    allowlist: {
      label: "Set ADA Handle allowlist",
      caption: "Send funds to ADA Handles on this list with no restrictions. For handles not in this list you'll get an additional check.",
      add: {
        label: "Add entry"
      },
      delete: {
        label: "Delete entry",
        caption: "Do you want to delete allowlist entry for "
      }
    },
    blocklist: {
      label: "Set ADA Handle blocklist",
      caption: "You will not be able to send funds to ADA Handles on this list.",
      add: {
        label: "Add entry"
      },
      delete: {
        label: "Delete entry",
        caption: "Do you want to delete blocklist entry for "
      }
    },
    error: {
      noHandle: "An ADA Handles must start with $",
      on_allowlist: "This handle is already on the allowlist, it cannot also be on the blocklist.",
      on_blocklist: "This handle is already on the blocklist, it cannot also be on the allowlist."
    },
    button: {
      add: "Add entry",
      cancel: "Cancel",
      delete: "Delete"
    }
  },
  message: {
    success: "App preferences updated."
  }
};
const error404 = {
  headline: "Whoops",
  caption: "A wrong path. Let's start over on the main page",
  text: "The page you are looking for is not available.",
  button: {
    home: {
      label: "Home",
      link: "Default"
    }
  }
};
const accountSelection$1 = {
  error: {
    validNumber: "Please enter a valid number.",
    minNumber: "Number must be at least 1.",
    maxNumber: "Number can not be greater then ####LIMIT####."
  }
};
const add = {
  headline: "@:menu.main.add.label",
  caption: "@:menu.main.add.caption",
  button: {
    create: {
      label: "Create wallet",
      caption: "Create a new Cardano Shelley wallet",
      icon: "mdi mdi-wallet-plus-outline"
    },
    restore: {
      label: "Restore wallet",
      caption: "Restore an existing wallet by entering a @:common.label.walletPhrase",
      icon: "mdi mdi-sync"
    },
    pair: {
      label: "Hardware Wallet",
      caption: "Pair a hardware wallet to access your funds",
      icon: "mdi mdi-connection",
      action: "Select device to pair",
      ledger: {
        label: "ledger",
        caption: "The Ledger cryptocurrency hardware wallet is made by Ledger, a company headquartered in Paris, France. It's a small USB device used to store your private keys protected within a secure chip locked by a PIN code. This protects your funds even if your computer is compromised.",
        icon: "mdi mdi-shield-lock-outline"
      },
      trezor: {
        label: "trezor",
        caption: "Trezor Model T (or shortly Trezor T) comes from SatoshiLabs, based in the Czech Republic. The hardware wallet features a LCD color touchscreen and easy-to-use interface. Your keys never leave the device, keeping them isolated from online vulnerabilities.",
        icon: "mdi mdi-shield-lock-outline"
      }
    },
    import: {
      label: "Import",
      caption: "Import an old wallet",
      icon: "mdi mdi-import"
    }
  }
};
const create = {
  headline: "Create a Cardano wallet",
  caption: "@:common.label.shelleySupport",
  step: {
    password: "@:form.password.label",
    hint: "@:common.label.hint",
    recoveryphrase: "@:common.label.phrase",
    confirm: "@:common.label.confirm",
    account: "@:wallet.create.account.label"
  },
  message: {
    success: "@:common.walletCreation.success",
    faildb: "@:common.walletCreation.faildb",
    failmnemonic: "@:common.walletCreation.failmnemonic",
    inProgress: "@:common.walletCreation.inProgress",
    accounts: "@:common.walletCreation.accounts"
  },
  account: {
    amount: "Number of accounts",
    hint: "1",
    info: "Specify the number of accounts to create.",
    label: "Accounts",
    description: {
      line1: "A wallet in @:common.label.project can have up to ####accountLimit#### accounts. Each account can be delegated to a different staking pool. The account keys are generated from the wallet root key.",
      line2: "Each account added increases the syncing time of your wallet. We recommend only creating as many accounts per wallet as you use. You can always add more accounts after wallet creation."
    },
    discover: {
      title: "Discover accounts",
      caption: "Searching the first ####accountLimit#### accounts, add all accounts with a non-zero account balance."
    }
  },
  status: {
    initCreation: "Initialize wallet creation.",
    createWallet: "Creating wallet",
    startDiscovery: "Start account discovery",
    discoverUTxOs: "UTxOs are being checked.",
    createAccount: "Creating account",
    syncAccount: "Syncing account",
    finishing: "Finishing up wallet creation",
    error: "Error: unknown state Please reload or contact support if recurring."
  }
};
const chart = {
  headline: "Price Chart",
  caption: "Use button to switch to different intervals",
  show: "Show token chart",
  hide: "Hide token chart",
  duration: "Duration",
  scale: "Scale",
  type: "Type",
  noChart: "No token chart available"
};
const restore = {
  headline: "Restore a Cardano wallet",
  caption: "@:common.label.shelleySupport",
  step: {
    type: {
      label: "@:common.label.type",
      headline: "What kind of wallet would you like to restore?",
      caption: "Daedalus, Yoroi and @:common.label.project use recovery phrases of either 15 or 24 words length. 12 words are also common. \nByron era wallets are currently not supported. If you need to recover a pre-August 2020 wallet, please use Daedalus.\n",
      options: {
        length24: {
          label: "24 words",
          caption: "A Shelley wallet created by, eg. @:common.label.project or Daedalus."
        },
        length15: {
          label: "15 words",
          caption: "Eg. a Yoroi Shelley wallet."
        },
        length12: {
          label: "12 words",
          caption: "A 12 words Shelley wallet."
        }
      }
    },
    recoveryphrase: {
      label: "Recovery Phrase",
      headline: "@:common.label.instructions",
      caption: "@:common.recoveryphrase.caption"
    },
    password: {
      label: "@:common.label.password"
    },
    account: {
      label: "@:wallet.create.account.label"
    }
  },
  message: {
    success: "@:common.walletCreation.success",
    faildb: "@:common.walletCreation.faildb",
    failmnemonic: "@:common.walletCreation.failmnemonic",
    duplicate: "@:common.walletCreation.duplicate"
  }
};
const pair = {
  headline: "Pair a hardware wallet",
  caption: "Pick from a variety of hardware wallets.",
  step: {
    type: {
      label: "Type",
      headline: "What hardware wallet would you like to connect?",
      caption: "A hardware wallet gives you an extra layer of protection against cyber attacks, phishing sites, and malware. Your private keys are stored on the device and never exposed to the internet, so they cant be stolen. Thats why its also known as cold storage.",
      option: {
        ledger: {
          label: "Ledger (Nano X, S and S Plus supported)",
          caption: "The Ledger cryptocurrency hardware wallet made by Ledger, a company headquartered in Paris, France."
        },
        trezor: {
          label: "Trezor (Model T and Safe 3 supported)",
          caption: "Trezor comes from SatoshiLabs, based in the Czech Republic."
        },
        keystone: {
          label: "Keystone",
          caption: "A Hong Kong based company offering a 100% Air-gapped open-source QR code communication hardware wallet with a 4-Inch touch screen and fingerprint reader."
        }
      },
      button: {
        next: "@:common.label.next"
      }
    },
    connect: {
      label: "Connect",
      headline: "@:common.label.instructions",
      caption: {
        ledger: "Please unlock your Ledger device and open the Cardano app before proceeding.",
        trezor: "Click on @:common.label.next and follow the directions outlined in the opened Trezor Connect browser tab and on your Trezor device.",
        keystone: "Click on @:common.label.next and follow the directions outlined in the opened modal to complete the pairing process."
      },
      notice: {
        ledger: "Make sure no other browser tab or app is connected to your Ledger device, eg. Ledger Live or Yoroi in any browser window.",
        trezor: "",
        keystone: ""
      },
      loading: {
        ledger: "Please follow the directions in the Cardano app on your Ledger device to complete the pairing process.",
        trezor: "Please follow the directions outlined in the opened Trezor Connect browser tab and on your Trezor device."
      },
      ledger: {
        transport: {
          label: "@:common.label.transport",
          caption: "Override default ledger transport communication protocol."
        }
      },
      button: {
        back: "@:common.label.back",
        next: "@:common.label.next"
      }
    },
    name: {
      label: "Name",
      button: {
        back: "@:common.label.back",
        reset: "@:common.label.reset",
        save: "@:common.label.save"
      }
    }
  },
  setting: {
    ledger: {
      label: "Connect ledger using",
      usb: "Pair Ledger using USB",
      bluetooth: "Pair Ledger using Bluetooth"
    },
    trezor: {
      label: "Override Trezor derivation type (advanced)",
      derivation: {
        trezor: "Trezors implementation based on the Icarus standard.",
        icarus: "The Cardano derivation standard as defined by CIP03.",
        ledger: "Follows the Bitcoin standard as defined by BIP39.",
        default: "(default)"
      }
    }
  },
  message: {
    success: "@:common.walletCreation.success",
    faildb: "@:common.walletCreation.faildb",
    failmnemonic: "@:common.walletCreation.failmnemonic",
    duplicate: "@:common.walletCreation.duplicate"
  }
};
const imports = {
  headline: "Import a wallet",
  caption: "Exported @:common.label.project .json wallets and public account keys are supported.",
  json: {
    headline: "Import @:common.label.project .json wallet",
    caption: "Select a previously exported @:common.label.project .json file.",
    button: {
      label: "Import Wallet",
      icon: "mdi mdi-import"
    }
  },
  message: {
    success: "@:common.walletCreation.success",
    faildb: "@:common.walletCreation.faildb",
    failmnemonic: "@:common.walletCreation.failmnemonic",
    duplicateId: "A wallet with the same id already exists, redirecting to wallet '###walletname###'.",
    duplicateName: "A wallet with the same name already exists, please rename wallet '###walletname###' and retry import."
  }
};
const importsOld = {
  headline: "Import a wallet",
  caption: "Exported @:common.label.project .json wallets and public account keys are supported.",
  json: {
    headline: "Import @:common.label.project .json wallet",
    caption: "Select a previously exported @:common.label.project .json file.",
    button: {
      label: "Import Wallet",
      icon: "mdi mdi-import"
    }
  },
  message: {
    success: "@:common.walletCreation.success",
    faildb: "@:common.walletCreation.faildb",
    failmnemonic: "@:common.walletCreation.failmnemonic",
    duplicateId: "A wallet with the same id already exists, redirecting to wallet '###walletname###'.",
    duplicateName: "A wallet with the same name already exists, please rename wallet '###walletname###' and retry import."
  }
};
const importkey = {
  headline: "Import Account Key",
  caption: "@:common.accountkey.caption",
  step: {
    key: "@:common.label.key",
    name: "@:common.label.name"
  },
  message: {
    success: "@:common.walletCreation.success",
    faildb: "@:common.walletCreation.faildb",
    duplicate: "@:common.walletCreation.duplicate"
  }
};
const accounts = {
  headline: "Account list",
  caption: "Add more accounts to be able to delegate to multiple pools.",
  notice: {
    label: "Please note:",
    text: "Additional accounts will increase syncing times.",
    icon: "mdi mdi-information-outline"
  },
  confirm: {
    label: "Add Account",
    caption: "Account keys are generated from the wallet root key. Read-only accounts cannot add additional accounts.",
    info: {
      mnemonic: "Please enter your spending password to get access to an additional accounts.",
      ledger: "Press 'Add Account' and follow the directions on your Ledger device. You might have to select your Ledger device in a browser pop-up window.",
      trezor: "Press 'Add Account' and follow the directions on the opened Trezor Connect browser tab.",
      keystone: "Press 'Add Account' and follow the directions in the opened modal to sign.",
      readonly: "This wallet can't add accounts.",
      submit: "Account successfully created, press the Activate Account button to activate it."
    },
    discoverInfo: {
      ledger: "Press 'Discover Accounts' and follow the directions on your Ledger device. You might have to select your Ledger device in a browser pop-up window.",
      trezor: "Press 'Discover Accounts' and follow the directions on the opened Trezor Connect browser tab.",
      keystone: "Press 'Discover Accounts' and follow the directions in the opened modal to sign."
    },
    error: {
      accountLimit: "The maximum number of accounts has been reached for this wallet.",
      general: "Failed adding an account.",
      password: "Invalid password.",
      nohw: "No hardware wallet.",
      nokey: "No account key generated.",
      mismatch: "Wrong key for account 0: The derived account does not match this wallet's keys. Wrong device? Wrong optional secret passphrase?",
      noNumber: "Input is not a number",
      maxAccount: "Max account index is ###MAX###",
      inUse: "Account index ###INDEX### already used in account slot ###SLOT###.",
      enable: "Account index ###INDEX### can be enabled in grid at position ###SLOT###."
    },
    loading: {
      ledger: "Please follow the directions in the Cardano app on your Ledger device.",
      ledgerdiscover: "<br>It might take a while for Ledger device to derive keys so please be patient.",
      trezor: "Please follow the directions outlined in the opened Trezor Connect browser tab and on your Trezor device.",
      discover: "Account discovery in process ( ###syncing### / ###total### )"
    },
    preview: {
      label: "Transaction Preview",
      caption: "Addresses marked as 'own' belong to your wallet. 'ext' marks external wallet addresses."
    },
    password: form.password.spending.addAccount,
    button: {
      manage: "Manage Accounts",
      add: "Add Accounts",
      back: "@:common.label.back",
      submit: "@:common.label.submit",
      remove: "Remove Accounts",
      discover: "Discover Accounts",
      reset: "@:common.label.reset",
      save: "Add Account"
    }
  },
  add: {
    caption: "Click to toggle account selection",
    amount: {
      label: "Amount of accounts",
      caption: "Specify the number of accounts to add. You can only create up to ####LIMIT#### accounts."
    },
    index: {
      label: "Account index",
      caption: "Specify the index of the account to create. If you specify an amount bigger than 1, more accounts will be created starting at this index."
    }
  },
  remove: {
    label: "Remove account",
    caption: "Are you sure you want to remove the account ?"
  }
};
const dappbrowser = {
  headline: "DApp Browser",
  caption: "Your gateway to Cardano DeFi and NFTs.\nConnect this account to a dApp listed below.",
  notice: {
    label: "Please note:",
    text: "Additional accounts will increase syncing times.",
    icon: "mdi mdi-information-outline"
  },
  confirm: {
    label: "Add Account",
    caption: "Account keys are generated from the wallet root key. Read-only accounts cannot add additional accounts.",
    info: {
      mnemonic: "Please enter your spending password to get access to an additional accounts.",
      ledger: "Press 'Add Account' and follow the directions on your Ledger device. You might have to select your Ledger device in a browser pop-up window.",
      trezor: "Press 'Add Account' and follow the directions on the opened Trezor Connect browser tab.",
      readonly: "This wallet can't add accounts.",
      submit: "Account successfully created, press the Activate Account button to activate it."
    },
    error: {
      accountLimit: "The maximum number of accounts has been reached for this wallet.",
      general: "Failed adding an account.",
      password: "Invalid password.",
      nohw: "No hardware wallet.",
      nokey: "No account key generated.",
      mismatch: "Wrong key for account 0: The derived account does not match this wallet's keys. Wrong device? Wrong optional secret passphrase?"
    },
    loading: {
      ledger: "Please follow the directions in the Cardano app on your Ledger device.",
      trezor: "Please follow the directions outlined in the opened Trezor Connect browser tab and on your Trezor device."
    },
    preview: {
      label: "Transaction Preview",
      caption: "Addresses marked as 'own' belong to your wallet. 'ext' marks external wallet addresses."
    },
    password: form.password.spending.addAccount,
    button: {
      add: "Add Accounts",
      back: "@:common.label.back",
      sign: "Add Account",
      submit: "@:common.label.submit",
      remove: "Remove Accounts",
      reset: "@:common.label.reset",
      save: "Add Account"
    }
  },
  add: {
    caption: "Click to toggle account selection",
    amount: {
      label: "Amount of accounts",
      caption: "Specify the number of accounts to add. You can only create up to ####LIMIT#### accounts."
    },
    index: {
      label: "Account index",
      caption: "Specify the index of the account to create. If you specify an amount bigger than 1, more accounts will be created starting at this index."
    }
  }
};
const withdrawal$1 = {
  label: "Withdraw Rewards",
  text: "There is no need to withdraw, your rewards are automatically part of your delegated stake.",
  button: {
    label: "Withdraw rewards",
    norewards: "No rewards available",
    syncing: "@:wallet.message.syncing"
  },
  staking: {
    label: "Stake your funds to earn rewards",
    text: "You can earn staking rewards by delegating to one of Cardano's many stake pools. Consider supporting us by delegating to TITAN.",
    button: "Go to Staking"
  }
};
const token = {
  headline: "Token list",
  caption: "Here you can see your Cardano native assets, tokens, NFTs and FTs.",
  count: {
    label: "###count### unique asset(s)###collections### found.",
    collections: " and ###count### collection(s)"
  },
  fetch: "Fetching metadata for tokens",
  notokens: "Currently this wallet does not contain any tokens. If you expect tokens, please check whether the wallet is still syncing.",
  filterEmpty: "No tokens found with metadata matching search string input and selected type.",
  nometadata: "No metadata found for this token. Enable 'Detailed mode' for basic details.",
  label: "@:common.assets.token",
  fingerprint: "Fingerprint",
  policyId: "Policy ID",
  assetName: "Asset Name",
  totalSupply: "Total Supply",
  noimage: "No Image",
  loadIpfs: "Load original image via IPFS",
  dialog: {
    onchainfile: "@:common.message.onchainfile",
    onchainfiles: "@:common.message.onchainfiles",
    files: {
      select: "Open File ###INDEX### (###FORMAT###)",
      types: {
        gif: "Animation",
        image: "Image",
        video: "Video",
        file: "File",
        audio: "Audio"
      }
    },
    ipfs: {
      loading: "Please wait, the asset is being loaded.",
      error: "Error loading data from ipfs, please retry or contact support.",
      timeout: "Download of file timed out, please retry or contact support."
    }
  },
  sectionlabel: {
    metadata: "Metadata",
    policyname: "Policy Id & Asset Name",
    tokenCollection: "Token Collection"
  },
  hover: {
    ownedAmount: "Wallet Balance",
    sendAmount: "Amount To Send",
    refresh: "Force Refresh",
    onchainfile: "@:common.message.onchainfile",
    lockedinsv: "Locked in @:common.label.stakingvault",
    verified: "A MuesliSwap verified token!",
    nometa: "Loading metadata, input disabled and decimals unknown until completed!"
  },
  search: {
    label: "Filter tokens",
    hint: "Search...",
    info: "Search for tokens based on policy, fingerprint, name, ticker and other metadata. Semicolon can be used as a separator to input multiple search values.",
    error: {
      length: "A minimum of 3 characters needed to filter tokens."
    }
  },
  messages: {
    tokenSelect: "Token selection enabled"
  },
  modal: {
    amountOwned: "Amount owned",
    amountValue: "Value",
    totalCirculation: "Total in circulation",
    currentFloor: "Current floor",
    avgFloor: "Average floor",
    averagePrice: "Average price",
    description: "Description",
    rawJSON: "Raw JSON",
    website: "Website",
    blockchainData: "Blockchain data",
    priceData: "Price information",
    asset: "Asset",
    priceTable: {
      marketplace: "Website",
      price: "Price"
    }
  },
  milkomeda: {
    filtered: "Note: Only tokens that can be bridged to milkomeda are shown.",
    noAssetsOnMainnet: "Note: Milkomeda currently does not support sending assets on mainnet.",
    countAddition: " from which ###COUNT### can be bridged to milkomeda.",
    tokenLimit: "A transaction to Milkomeda can only include one kind of token.",
    sendAll: "Consider moving all token but one to another address before using send all.",
    invalidToken: "Your wallet includes a token that can not be bridged to Milkomeda."
  }
};
const utxo = {
  headline: "Account UTxO List",
  caption: "A list of all utxos under management of this account, including amount and token lists.",
  label: "###utxo### UTxO on ###addresses### addresses",
  collateralLabel: "###utxo### possible collateral UTxOs available, not all are set as collateral.",
  lockedLabel: "###utxo### locked UTxOs.",
  address: "@:common.address.label",
  txhash: "Hash # Idx",
  balance: "@.capitalize:common.label.balance"
};
const stakeinfo = {
  key: {
    label: "Stake Address"
  },
  upcoming: {
    label: "Current/Upcoming Delegations:",
    caption: "If the wallet is re-delegated the upcoming delegation for each epoch can be checked here.",
    current: "Current Epoch",
    next: "Next Epoch",
    epoch: "@.capitalize:common.label.epoch"
  },
  history: {
    label: "Rewards History",
    caption: "A list of earned rewards for staking and Catalyst voting sorted by epoch.",
    epoch: "@.capitalize:common.label.epoch",
    rewards: "Rewards",
    refund: "Pool Deregistration Refund",
    pool: "Pool",
    treasury: "Catalyst Voting",
    leader: "Pool Operator Rewards",
    reserves: "Instantanous Rewards"
  },
  gov: {
    nodelegation: {
      info: "Please consider delegating to a DRep for governance actions. It will be required in the following era to be able to withdraw staking rewards.",
      warn: "You can't withdraw staking rewards until it's is also delegated to a DRep. This helps to ensure high participation, and so, legitimacy. Even though rewards cannot be withdrawn, they are not lost, and will be withdrawable as soon as a governance delegation is put on chain."
    },
    inactive: "Account is delegated to a governance DRep that is marked as inactive and thus do not count towards the active voting stake anymore.",
    icon: {
      info: "mdi mdi-information-outline",
      warning: "mdi mdi-alert-octagon-outline"
    }
  },
  warning: {
    high: {
      label: "High Pool Fee",
      caption: "The pool to which this account is delegated has an unusually high fee that will reduce your staking rewards. If it's some kind of an ISPO, that's fine. If not, you should choose another pool with lower fees."
    },
    complete: {
      label: "99+% Pool Fee",
      caption: "The pool to which this account is delegated charges at least 99% and collect your ADA rewards. If it's some kind of an ISPO, that's fine. If not, you should choose another pool with lower fees."
    }
  }
};
const setDAppAccount = {
  label: "dApp Account",
  caption: "All dApps will connect to this account.",
  captionWeb: "This web app version of @:common.label.project cannot connect to dApps. Please install the browser extension to connect to dApps.",
  warning: {
    hwWallet: {
      label: "Limited hardware wallet support",
      icon: "mdi mdi-alert-octagon-outline"
    },
    readOnly: {
      label: "No Transaction signing",
      icon: "mdi mdi-alert-octagon-outline",
      text: "This is a read-only account. This account can't sign transactions."
    }
  },
  button: {
    enable: {
      label: "Connect as dApp Account"
    },
    disable: {
      label: "Disconnect dApp Account"
    }
  }
};
const summary$1 = {
  withdrawal: withdrawal$1,
  token,
  utxo,
  stakeinfo,
  accounts,
  dappbrowser,
  setDAppAccount,
  button: {
    copy: {
      icon: "mdi mdi-content-copy",
      utxo: {
        address: {
          hover: "@:common.label.copyAddress",
          notify: "@:common.message.copy.notify"
        },
        txhash: {
          hover: "Copy UTxO Hash # Idx",
          notify: "Copied UTxO Hash # Idx: "
        }
      },
      token: {
        fingerprint: {
          hover: "Copy fingerprint",
          notify: "Copied fingerprint: "
        },
        policyid: {
          hover: "Copy Policy ID",
          notify: "Copied Policy ID: "
        },
        assetname: {
          hover: "Copy Asset Name in hex format",
          notify: "Copied Asset Name: "
        }
      }
    },
    token: {
      expand: "@:common.label.expand",
      collapse: "@:common.label.collapse",
      ipfsimg: {
        hover: "Enlarge image"
      }
    }
  }
};
const history = {
  headline: "Account Transaction History",
  caption: "transactions found for this account ",
  loaded: "loaded",
  pending: {
    headline: "Pending transactions",
    caption: "pending transactions found for this account."
  }
};
const pending = {
  headline: "Pending Transactions",
  caption: "transactions found related to this account.",
  filter: {
    label: "Filters"
  }
};
const transactions = {
  history,
  pending,
  filtered: "displayed based on applied filters.",
  filtermax: "(result limit reached)",
  txCount: "Total Transactions: ",
  balanceatblocktime: "Account Balance at block time",
  confirmations: "confirmations",
  confirmation: "confirmation",
  button: {
    txDetails: {
      icon: "mdi mdi-chevron-",
      expand: "@:common.label.expand",
      collapse: "@:common.label.collapse"
    },
    copy: {
      icon: "mdi mdi-content-copy",
      address: {
        hover: "@:common.label.copyAddress",
        notify: "@:common.message.copy.notify"
      },
      cred: {
        hover: "@:common.label.copyCred",
        notify: "@:common.message.copy.notify"
      },
      tx: {
        hover: "@:common.copyTx",
        notify: "@:common.message.copy.notify"
      },
      block: {
        hover: "Copy block number",
        notify: "Copied block number: "
      },
      json: {
        hover: "Copy json",
        notify: "Copied json"
      },
      metadata: {
        hover: "Copy metadata",
        notify: "Copied metadata"
      },
      datum: {
        hover: "Copy datum",
        notify: "@:common.message.copy.notify"
      },
      bytes: {
        hover: "Copy bytes",
        notify: "@:common.message.copy.notify"
      },
      hash: {
        hover: "Copy hash",
        notify: "@:common.message.copy.notify"
      },
      script: {
        hover: "Copy script",
        notify: "@:common.message.copy.notify"
      },
      sign: {
        label: "Message",
        hover: "Copy decoded version of data to sign.",
        notify: "@:common.message.copy.notify"
      }
    },
    json: {
      label: "json",
      hover: "Click on JSON tree to expand"
    },
    milkomeda: {
      link: {
        hover: "Open in milkomeda ###NETWORK### explorer."
      }
    }
  },
  badge: {
    catalyst: {
      label: "catalyst",
      hover: "Transaction contains Catalyst voting registration"
    },
    metadata: {
      label: "meta",
      hover: "Transaction contains metadata"
    },
    mint: {
      label: "mint",
      hover: "Transaction contains minted token(s)."
    },
    reg: {
      label: "reg",
      hover: "Wallet / Stake key registration"
    },
    dereg: {
      label: "dereg",
      hover: "Wallet deregistration"
    },
    delegation: {
      label: "delegation",
      hover: "Stake pool delegation"
    },
    poolreg: {
      label: "pool reg",
      hover: "Stake pool registration"
    },
    poolupd: {
      label: "pool upd",
      hover: "Stake pool update"
    },
    poolret: {
      label: "pool retire",
      hover: "Stake pool retire"
    },
    gov: {
      label: "gov",
      hover: "Governance action"
    },
    vote: {
      label: "vote",
      hover: "Cast vote"
    },
    nativescript: {
      label: "script",
      hover: "Native/multi-sig script"
    },
    plutus: {
      label: "SC",
      hover: "Plutus contract"
    },
    signed: {
      label: "signed",
      hover: "Transaction was was signed."
    },
    submitted: {
      label: "submitted",
      hover: "Transaction was was submitted to the network."
    },
    onchain: {
      label: "on-chain",
      hover: "Transaction was included in a block"
    },
    invalid: {
      label: "invalid",
      hover: "An input of this transaction was spent in a different transaction."
    },
    failed: {
      label: "failed",
      hover: "Plutus smart contract execution failed, collateral has been spent."
    },
    pending: {
      label: "pending",
      hover: "Transaction is still pending execution"
    },
    staging: {
      label: "unsigned",
      hover: "This transaction was not signed yet."
    },
    validFor: {
      label: "valid for",
      hover: "Transaction will be executed eventually or become invalid if an input utxo was consumed by a different transaction."
    },
    unlockTimeStamp: {
      label: "Unlock at",
      hover: "These Staking Vault funds will unlock at that date."
    },
    stakingvault: {
      label: "staking vault",
      hover: "This transaction locks funds in Staking Vault."
    },
    unlimited: {
      label: "no time limit",
      hover: "Transaction will be executed eventually or become invalid if an input utxo was consumed by a different transaction."
    },
    expired: {
      label: "expired",
      hover: "Transaction life time expired"
    },
    setTTL: {
      label: "set TTL",
      hover: "Set transaction life time"
    },
    remove: {
      label: "Remove",
      hover: "Click to remove an expired or invalid transaction.",
      hoverNote: "Only remove, if you know that this transaction won't go through anymore."
    },
    utxo: {
      own: {
        label: "acc",
        hover: "Own wallet address"
      },
      ext: {
        label: "ext",
        hover: "External address"
      },
      add: {
        label: "+entity",
        hover: "Set an entity name for this address."
      },
      donation: {
        label: "Donation",
        hover: "@:common.label.project donation address"
      },
      burnit: {
        label: "Eternl Burn Address",
        hover: "@:common.label.project burn address"
      },
      swapfee: {
        label: "Frontend Fee",
        hover: "@:common.label.project frontend fee address"
      },
      eternl: {
        label: "Frontend Fee",
        hover: "@:common.label.project fee address"
      },
      dexhunter: {
        label: "DexHunter Fee",
        hover: "DexHunter fee address"
      },
      sv: {
        label: "Staking Vault",
        hover: "Staking vault timelock address"
      }
    },
    script: {
      label: "Script",
      hover: "SmartContract address"
    },
    milkomeda: {
      label: "Milkomeda",
      hover: "Bridged Cross Chain Transaction to Milkomeda"
    }
  },
  header: {
    txId: "Transaction Id",
    block: "@:common.label.block",
    size: "Tx @:common.label.size",
    fee: "@:common.label.fee",
    deposit: "@:common.label.deposit",
    donation: "@:common.label.donation",
    utxo: {
      collateralInputs: "UTxO Collateral Input(s)",
      collateralOutput: "UTxO Collateral Output",
      inputs: "UTxO Input(s)",
      referenceInputs: "UTxO Reference Input(s)",
      outputs: "UTxO Output(s)"
    },
    withdrawal: {
      label: "Withdrawal(s)",
      amount: "Amount"
    },
    mint: {
      label: "Mint/Burn(s)"
    },
    certificate: {
      label: "Certificate(s)",
      type: {
        stakereg: "Account Registration",
        stakedereg: "Account Deregistration",
        stakedel: "Stake Pool Delegation",
        stakeregdel: "Account Registration & Stake Pool Delegation",
        stakevotedel: "Stake Pool & DRep Delegation",
        stakevoteregdel: "Account Registration & Stake Pool / DRep Delegation",
        votedel: "DRep Delegation",
        voteregdel: "Account Registration & DRep Delegation",
        drepreg: "DRep Registration",
        drepupd: "DRep Update",
        drepdereg: "DRep Deregistration",
        poolreg: "Stake Pool Registration / Update",
        poolret: "Stake Pool Retirement",
        script: "@:wallet.transactions.header.nativescript.label",
        plutus: "Plutus Contract"
      },
      poolreg: {
        actepno: "Active in Epoch",
        fixedcost: "Fixed Cost",
        margin: "Margin",
        pledge: "Pledge",
        rewardaddr: "Reward Address",
        owners: "Owners",
        relays: "Relays",
        metaurl: "Metadata URL",
        metahash: "Metadata Hash",
        metadata: "Off-Chain Meta"
      },
      poolret: {
        retepno: "Retiring Epoch"
      },
      gov: {
        vote: "Vote",
        drep: "DRep (CIP129)",
        drep105: "DRep (CIP105)"
      }
    },
    metadata: {
      label: "@:common.label.metadata",
      key: "Label",
      value: "Value"
    },
    witnessset: {
      label: "Witness Set",
      key: "Label",
      value: "Value"
    },
    governance: {
      proposal: {
        label: "Voting Proposal",
        action: "Action"
      },
      procedure: {
        label: "Voting Procedure",
        voter: "Voter"
      }
    },
    datum: {
      label: {
        inline: "Inline Datum",
        hash: "Datum"
      },
      hash: "Hash",
      json: "JSON",
      bytes: "Data"
    },
    script: {
      label: {
        native: "Reference Script (native)",
        plutus: "Reference Script (plutus)"
      },
      hash: "Hash",
      size: "@:common.label.size",
      bytes: "Data",
      value: "Value"
    },
    nativescript: {
      label: "Native / Multi-Sig Script(s)",
      hash: "Hash",
      json: "JSON",
      bytecode: "Data"
    },
    plutus: {
      redeemer: {
        utxo: "UTxO",
        purpose: "Purpose",
        fee: "Contract Fee",
        usteps: "Unit Steps",
        umem: "Unit Memory",
        dhash: "Datum Hash",
        dvalue: "Datum Bytecode",
        djson: "Datum JSON"
      },
      datum: {
        hash: "Hash",
        bytecode: "Data",
        json: "JSON"
      }
    },
    plutusdata: {
      label: "Plutus Contract Data",
      redeemer: "Redeemer(s)",
      utxo: "UTxO(s)",
      datum: "Datum(s)",
      script: "Script(s)"
    },
    plutuscontract: {
      label: "Plutus Contract(s)",
      valid: "Valid Contract",
      redeemer: "Redeemer",
      datum: "Datum",
      script: {
        label: "Contract Script",
        hash: "Hash",
        size: "@:common.label.size",
        bytecode: "Data"
      },
      outdatum: "Output Datum"
    }
  },
  token: {
    more: "more token(s)",
    count: "token(s)"
  },
  filter: {
    headline: "Transaction History Filters",
    caption: "Apply one or more filters to filter out transaction(s).",
    syncinfo_line1: "All transaction details not loaded yet",
    syncinfo_line2: "Date range and tx id search will work for all transactions.",
    autosync: "To filter on other data points, enable account history sync in settings.",
    button: "Filters",
    period: {
      label: "Period"
    },
    amount: {
      label: "Amount",
      from: "From",
      to: "To"
    },
    search: {
      label: "Search",
      info: "Search in transaction message, for Id, or for an UTxO address.",
      hint: "Search for msg, tx id or address..."
    },
    error: {
      wallet: "Unable to get access wallet, please retry.",
      syncing: "Wallet syncing, please try again once synced.",
      adamin: "Invalid lower amount filter range.",
      adamax: "Invalid upper amount filter range.",
      adarange: "Unable to apply lower/upper amount range filter, not a valid number."
    }
  },
  note: {
    save: "Save note",
    add: "Add transaction note",
    edit: "Transaction note",
    delete: "Delete note",
    deleteModal: {
      title: "Confirm delete",
      caption: "Do you really want to delete the note ?"
    },
    filter: "Filter transactions with notes."
  },
  message: {
    encrypted: "- encrypted message -",
    hover: {
      locked: "Encrypted message, click to decrypt",
      unlocked: "Decrypted message, click to re-encrypt"
    },
    modal: {
      label: "Message Password",
      caption: "Enter password to decrypt transaction message.",
      error: "Failed to decrypt message with provided password"
    }
  }
};
const exports = {
  label: "Export Wallet",
  caption: "Options for account public key export & encrypted wallet JSON export that enabled easy import in other browsers/devices or to restore the wallet at a later point.",
  json: {
    headline: "@:common.label.project Wallet Backup (JSON export)",
    caption: "Exported @:common.label.project .json files can be imported in any other @:common.label.project app.",
    button: {
      label: "Export Wallet",
      icon: "mdi mdi-export"
    }
  },
  accountPub: {
    label: "Export Account Key",
    headline: "Account public key export",
    caption: "Export the public key of this account. Importing a public key restores the account history in a read-only mode with signing disabled.",
    hover: "Export account public key",
    button: {
      doexport: {
        label: "Export Account Pub Key",
        icon: "mdi mdi-export"
      },
      unlock: {
        label: "@:common.label.unlock",
        icon: "mdi mdi-lock-outline"
      },
      copy: {
        label: "@:common.message.copy.pubKey",
        hover: "@:common.message.copy.pubKey",
        notify: "Copied account public key: "
      }
    }
  },
  csv: {
    headline: "Export Transaction History",
    caption: "Export (per account) the transaction and rewards history as CSV file.",
    format: "Format",
    button: {
      label: "Export CSV",
      icon: "mdi mdi-export"
    },
    csvExport: {
      label: "CSV Export",
      caption: "Set your export preset and enable/disable the export functionality.",
      exportPreset: "Export preset"
    },
    notes: {
      label: "Notes",
      caption: "Export transaction notes in the last column. The export will concatenate multi-line notes."
    },
    localTime: {
      label: "Export local timestamp",
      caption: "Enable this if you want to export the transaction times in your local timezone and local format. Otherwise the timestamps will be exported as UTC time."
    }
  },
  qr: {
    headline: "Wallet Export (QR-code)",
    caption: "This QR code can be scanned in any other instance of @:common.label.project. It doesn't export wallet settings, like the name.",
    button: {
      label: "Export Wallet",
      icon: "mdi mdi-qrcode-scan"
    }
  }
};
const settings = {
  modal: {
    headline: "Wallet & Account settings",
    caption: "Settings for your wallet (shared among accounts within) and account specific settings (active account)"
  },
  wallet: {
    headline: "Wallet Overwrites",
    caption: "Changing these settings will overwrite settings of ALL wallet accounts."
  },
  walletSpecific: {
    headline: "Wallet Specific Settings"
  },
  account: {
    headline: "Account Settings",
    caption: "These account settings overwrite wallet settings."
  },
  walletNameGroupPassword: {
    label: "Name, Group and Password",
    caption: "Update your wallet name, group name or spending password."
  },
  walletEntity: {
    label: "Reporting",
    captionWallet: 'Set the name of the entity this wallet belongs to, e.g. a company name or "personal."',
    captionAccount: "Set the reporting type of this account.",
    isAllIncome: 'Account is "all-income"',
    isAllIncomeHover: "All incoming funds are counted as income without asking for manual checks.",
    isPassThrough: 'Account is "pass-through"',
    isPassThroughHover: "Not immediately counting transactions as income. If funds are sent to another account, they will be counted as income there."
  },
  accountName: {
    label: "Active Account Name",
    caption: "Update your (active) account name"
  },
  accessPassword: {
    label: "Wallet Access Password",
    caption: "Set a wallet access password, update or delete a current access password.",
    labelUnlock: "Wallet Access Password",
    labelUnlockGroup: "Wallet Group Access Password",
    labelMigration: "Unlock your wallet",
    captionUnlock: "Tries to unlock the wallet using entered the access password (not the spending password).",
    captionUnlockGroup: "Tries to unlock all wallets in the wallet group using the entered access password.",
    captionMigration: "After unlocking your imported wallet, it will be migrated to the new syncing system.",
    captionDelete: "Remove the wallet access password.",
    remove: "Remove",
    enter: {
      hint: "Enter access password"
    },
    relock: 'Wallet will be locked with current locking password.\n \nYou can change this under "Setting"',
    setLock: "Set a wallet login password (This is for accessing your wallet, not your spending password!) You can change this under settings.",
    enterCurrent: "Enter current access password to remove the access password.",
    removeFailed: "Failed to remove wallet access password.",
    removeSuccess: "Wallet lock password removed.",
    updateSuccess: "Wallet lock password updated.",
    pwCheckFailed: "The old lock password you entered is not correct.",
    settingsNotSaved: "Access password settings could not be saved.",
    noPwUpdate: "Access password could not be updated.",
    locked: "Wallet was locked",
    alreadyLocked: "Wallet is already locked.",
    unableToLock: "Wallet could not be locked.",
    noLockSet: "Can not lock wallet, no lock password is set.",
    unlock: "Unlock Wallet",
    message: "Enter the wallet access password.",
    wrongPassword: "You entered a wrong wallet access password.",
    unlocked: "Wallet unlocked.",
    cancel: "@:common.label.cancel",
    current: {
      hint: "Enter access password",
      label: "Enter current access password to remove the access password."
    }
  },
  unlock: {
    headline: "@:common.label.unlockWallet",
    caption: "After pressing this button you are asked for the wallet login password to unlock this wallet..",
    button: {
      unlock: {
        label: "@:common.label.unlockWallet",
        icon: "mdi mdi-lock-outline"
      }
    }
  },
  addrbook: {
    //
    label: "@:setting.addressbook.label.wallet",
    caption: "@:setting.addressbook.caption"
    //
    //   input: {
    //
    //     name: {
    //
    //       label:                '@:common.name',
    //       hint:                 'Enter address book name.',
    //
    //       error: {
    //
    //         length:             'An address book name requires at least 3 and at most 40 characters.',
    //         duplicate:          'An address book entry with this name already exist, please choose another or edit/delete existing.'
    //       }
    //     },
    //
    //     addr: {
    //
    //       label:      '@:common.address.label',
    //       hint:       'Enter a valid Cardano address.',
    //       error: {
    //
    //         format:     '@:common.address.invalid',
    //         duplicate:  'An address book entry with the name \'###name###\' already exist for this address, please choose another or edit/delete existing.'
    //       }
    //     }
    //   },
    //
    //   table: {
    //
    //     header: {
    //
    //       name:       '@:common.name',
    //       address:    '@:common.address.label',
    //       action:     '@:common.action'
    //     },
    //
    //     type: {
    //
    //       global:     'Global Address Book',
    //       wallet:     'Wallet Address Book'
    //     }
    //   },
    //
    //   button: {
    //
    //     enable:       '+ Add Receiver',
    //     edit:         'Edit',
    //     send:         'Send to address',
    //     save:         '@:common.label.save',
    //     delete:       '@:common.label.delete',
    //     cancel:       '@:common.label.cancel',
    //     add:          '@:common.label.add',
    //     global:       'Add to global address book'
    //   },
    //
    //   confirm: {
    //
    //     delete: {
    //
    //       label:      '@:common.label.delete',
    //       message:    '@:common.addressbook.confirm.delete',
    //
    //       local: {
    //
    //         label:      'Success! Delete Local Entry?',
    //         message:    'Successfully added \'###name###\' to global address book, do you want to delete local wallet entry?'
    //       }
    //     }
    //   },
    //
    //   globalsave: {
    //
    //     success:      'Saved to global address book',
    //     error:        'An entry with ###error### already exist in the global address book'
    //   }
  },
  exports,
  collateral: {
    label: "Collateral",
    caption: "Interacting with smart contracts can require collateral in case a transaction fails. This will be handled automatically by Eternl if a qualifying UTxO has been found, otherwise can be set with the 'Set Collateral' button.",
    button: "Set Collateral",
    alreadySet: "You have already set a collateral. It can be found in this UTxO ####utxo####",
    noCollateral: "No collateral UTxO found. Please set one by pressing the button below.",
    foundCollateral: "We've found a collateral UTxO for this account. It'll be used when interacting with smart contracts.",
    error: {
      label: "Error!",
      buildOutput: "One of the outputs needs at least ####amount#### to hold the tokens.",
      lowFunds: "This means you have too little funds in your wallet to set a collateral. Please add more funds and try again or contact support if recurring.",
      insufficient: "Your have insufficient funds in this account to set a collateral.",
      icon: "mdi mdi-alert-octagon-outline"
    },
    warning: {
      fundslow: {
        label: "Low funds for collateral",
        text: "Setting a collateral UTxO will use more than 10% of the funds you have in you account!",
        icon: "mdi mdi-alert-octagon-outline"
      }
    },
    multiAccount: {
      warning: {
        note: "Please Note!",
        headline: "Collateral is an account based setting."
        // text:         'Each account must set its own collateral. You cannot reuse a collateral from another account!'
      },
      info: {
        line1: "@:common.label.project can use any UTxO with no tokens and a value between ####minimumCollateral#### and ####maximumCollateral#### as collateral. When you activate this setting, it will look for a UTxO that is suitable. If none is available, a button will be shown to set one."
        // line2:        'If no such UTxO can be found, you will see a button which allows you to set a collateral. This will create a UTxO with an amount of ####minimumCollateral####.\n\n ' +
        //     'You will not be able to spend that amount in a normal tx. It will still count towards your balance, but will not be spendable when interacting with a smart contract.',
        // line3:        'When used with activated "Send all" or when this account is used within another instance of @:common.label.project, where collateral is deactivated, the created collateral UTxO might be spent and you will need to recreate it.'
      }
    },
    tag: {
      label: "collateral",
      hover: "This UTxO is valid as collateral for smart contract transactions."
    }
  },
  sam: {
    global: {
      label: "Global Single Address Mode",
      caption: "Some wallets and tools only track a single wallet address, eg. Nami and CNTools. In contrast Daedalus, Yoroi and @:common.label.project track all addresses of a wallet.\n\nEnable this option to only use the first address of an account as change address. This prevents @:common.label.project from automatically selecting a different, unused change address.\n\nIf you activate SAM after you did a transaction with @:common.label.project you will need to send all your funds and assets to your SAM receive address, so the wallet is again Nami compatible."
    },
    account: {
      label: "Single Address Mode (SAM)"
    },
    receiveaddress: {
      label: "Custom Receive Address",
      caption: "Overwrite the automatically chosen receive address by setting your address manually."
    },
    notice: {
      label: "Please read carefully:",
      text: "When using Single Address Mode, the first receive address is used by default Don't set a custom receive address if you don't know what you're doing. When changing this setting, this will only affect the current active account. ",
      icon: "mdi mdi-information-outline"
    },
    hint: "@:common.address.enterReceive",
    error: "@:common.address.invalid",
    current: "Current Address",
    addrBook: {
      label: "@:common.addressbook.label",
      caption: "@:common.addressbook.select",
      table: {
        header: {
          name: "@:common.label.name",
          address: "@:common.address.label",
          action: "@:common.action"
        }
      },
      confirm: {
        label: "@:common.label.delete",
        message: "@:common.addressbook.confirm.delete"
      }
    },
    button: {
      next: "@:common.label.save",
      custom: {
        label: "Custom Address",
        icon: "mdi mdi-pencil-outline"
      }
    }
  },
  resync: {
    label: "Wallet Synchronization",
    caption: "Force a complete wallet re-synchronization.",
    info: "By pressing this button your wallet data will be reset and fully synced from the blockchain.",
    button: {
      resync: {
        label: "Resync Wallet",
        icon: "mdi mdi-sync"
      }
    }
  },
  tokenfrag: {
    label: "Token Fragmentation (TF)",
    caption: "Split tokens into bundles on send if there are more tokens in change to be returned than set value. Depending on wallet UTxO/Token distribution and desired outcome, values might have to be tweaked for optimal result.",
    fragment: {
      label: "Token bundle size",
      error: "Token bundle size limit: 1-150.",
      info: "Sets number of tokens each UTxO output should contain. It's a tradeoff between low transaction fees and amount of funds locked in the wallet.\nsmall bundle size -> low fees, more Ada locked.\nlarge bundle size -> higher fees, less Ada locked."
    },
    button: {
      default: "@:common.label.default",
      save: "@:common.label.save"
    }
  },
  withdrawal: {
    label: "Auto Withdrawal",
    caption: "Automatically withdraw rewards if needed.",
    info: "If enabled, rewards will automatically be withdrawn if needed when creating a transaction. If disabled or for forced manual withdrawal, use Withdrawal button on Summary page."
  },
  sendall: {
    label: 'Enable "Send All"',
    caption: "Sending all funds is considered dangerous as you might accidentally send away your whole wallet content. Only enable this feature temporally and when you need it.",
    info: 'If disabled, the button for sending all assets will not be available. If enabled you can send all your funds(including tokens) using "Send All" on send page.',
    tooltip: '"Send All" feature can be enabled on the wallet settings page.'
  },
  manualsync: {
    label: "Manual Sync",
    caption: "Manually synchronize the wallet. If enabled the wallet needs to be synced manually by clicking the sync icon."
  },
  historysync: {
    label: "History Sync",
    caption: "Full transaction history synchronization. If enabled, when on transaction history page, all transactions of the account will start to synchronize. This can be useful for filtering to work fully but can take a long time for an account with a large history."
  },
  autoCleanup: {
    label: "Pending transactions: auto cleanup",
    caption: "If enabled, transactions that have been successfully submitted to the blockchain will be removed from the 'Pending Transactions' view."
  },
  ledger: {
    label: "@:common.ledger.transport.label",
    caption: "Set Ledger transport communication protocol.",
    info: "To communicate with a Ledger device, the transport communication protocol has to be set. By default,  an automatic detection will be attempted with WebUSB as the primary transport. This setting allow you to override the default auto mode and set the transport you would like to use manually.",
    warning: "This is considered an advanced feature. If unsure, leave on auto.",
    button: {
      icon: "mdi mdi-transit-connection-variant"
    }
  },
  deldereg: {
    dangerzone: "Danger zone",
    headline: "Delete Wallet",
    caption: "",
    deletewallet: {
      headline: "Delete Wallet",
      caption: "Once you delete this wallet it will be removed from this @:common.label.project app and you will lose access to any remaining funds in this wallet. The only way to regain access after deleting is by restoring your wallet recovery phrase or by importing a previously exported @:common.label.project .json file.\n\nFor easier import, export as @:common.label.project .json format prior to deleting.\n\nBe sure that the seed phrase of this wallet is stored safely!",
      button: {
        delete: {
          label: "Delete Wallet",
          icon: "mdi mdi-delete-outline"
        }
      },
      toggle: {
        acknowledged: {
          label: "",
          text: "I understand that the only way to regain access to this wallet is by restoring it with its wallet recovery phrase.",
          icon: "mdi mdi-checkbox-blank-outline -mt-0.5"
        }
      },
      name: {
        label: "@:common.wallet.name.label",
        hint: "Enter the name of this wallet",
        info: "To confirm the deletion of this wallet, please enter the wallet name.",
        error: "The wallet name does not match."
      }
    },
    deregwallet: {
      headline: "Un-Stake / De-Register Account",
      caption: "This action creates an account de-registration transaction. Once completed, the account will be un-delegated from any pool, and the key deposit from when the account was first delegated is returned.\n\nPlease note that any pending rewards from pool delegation, catalyst rewards, etc will be lost when the account is de-registered!",
      button: {
        dereg: {
          label: "De-Register Account",
          icon: "mdi mdi-clipboard-minus-outline"
        }
      },
      toggle: {
        acknowledged: {
          label: "",
          text: "I understand that any pending rewards will be lost.",
          noutxo: "Ada needed to pay for de-registration fee.",
          icon: "mdi mdi-checkbox-blank-outline -mt-0.5"
        }
      }
    },
    deregdrep: {
      headline: "Deregister as DRep",
      caption: "Clicking the below button will create a DRep de-registration transaction. The voting power delegated to that DRep will be lost. To regain the ability to withdraw staking rewards, you will need to delegate your account to a different DRep.",
      button: {
        dereg: {
          label: "De-Register as DRep",
          icon: "mdi mdi-clipboard-minus-outline"
        }
      },
      toggle: {
        acknowledged: {
          label: "",
          text: "I understand that all delegated voting power will be lost.",
          noutxo: "Ada needed to pay for de-registration fee.",
          icon: "mdi mdi-checkbox-blank-outline -mt-0.5"
        }
      }
    }
  },
  applyToAll: "Apply to all accounts",
  button: {
    item: {
      expand: "@:common.label.expand",
      collapse: "@:common.label.collapse"
    }
  },
  message: {
    unlock: "Unlock wallet to get access to all settings.",
    success: "Wallet settings updated.",
    failed: "Failed to save wallet setting, please retry."
  },
  namiMessages: {
    notOwned: "The address you entered is not your own. Please only enter addresses that belong to the current wallet.",
    nonStaking: "You entered a External addresses (not delegated). You will not be able to stake with that address."
  },
  advancedUTxOManagement: {
    label: "Advanced UTxO Management",
    caption: "Enable this setting to use advanced UTxO management on your transactions by default."
  },
  verification: {
    label: "Recovery phrase verification",
    caption: "Verify that you have stored the correct recovery phrase for a wallet. Once verified, you can also change your spending password.",
    start: "Verify phrase",
    match: {
      label: "The entered recovery phrase is correct.",
      icon: "mdi mdi-check-bold",
      spending: "Change spending password"
    },
    invalid: {
      label: "The entered recovery phrase is not correct for this wallet.",
      icon: "mdi mdi-alert-octagon-outline"
    },
    wordLimit: "A recovery phrase can have a maximum of 24 words.",
    recovery: {
      label: "Forgot access password ?",
      caption: "If you forgot your wallet access password, restore your wallet with the same recovery seed phrase.",
      icon: "mdi mdi-lock-question",
      recover: "Restore wallet",
      confirmModal: {
        label: "Restore wallet from recovery phrase?\n",
        text: `You already have a wallet with the same recovery phrase. If you've forgotten the access password and are locked out of your wallet, press confirm to overwrite the existing wallet.

If you confirm, the old wallet will be deleted and recreated.

This process will reset all wallet settings to default, including the wallet addressbook, icon, Single Address Mode, Token Fragmentation etc.

Before you start using the recreated wallet, make sure to edit the wallet settings. That is especially important if you used "Single address mode" with a custom change address or the Token Fragmentation feature.`,
        confirm: "Confirm",
        cancel: "Cancel"
      },
      unableToDelete: "Existing wallet could not be deleted."
    },
    spendingRecovery: {
      step0: "Wallet phrase",
      step1: "Spending password",
      label: "Set new spending password ?",
      caption: "You can reset your spending password for this wallet if you have forgotten or lost it.",
      confirmModal: {
        label: "Set new wallet spending password?\n",
        text: "Your current wallet spending password will be overwritten with the new one. Please confirm that you want to do this?",
        confirm: "Confirm",
        cancel: "Cancel"
      }
    }
  },
  recovery: {
    label: "Wallet recovery",
    caption: "@:wallet.settings.verification.recovery.caption",
    button: "Start wallet recovery"
  },
  voterData: {
    label: "Catalyst Voting",
    caption: "Saved Catalyst registration QR code.",
    info: "Scan this QR code using the Catalyst voting application and follow the instructions.",
    warning: "Please Download/Save this QR code as a backup! \nWe saved a local backup of the encrypted catalyst voting key if you lose it. But this is only a local backup, and it will not be there if you restore your wallet on another device using your wallet phrase. Only if you import from a JSON backup created after creating the Catalyst registration can it be restored. We strongly advise you to save it in a password manager.",
    error: "Failed to generate QR code, please reload browser and retry wallet voting registration or contact support if recurring.",
    qr: "QR code",
    password: {
      title: "Wallet spending password",
      caption: "Enter spending password to access the catalyst voting information.",
      confirm: "@:common.label.confirm",
      current: {
        label: "Current wallet spending password",
        info: "Enter the current spending password for this wallet.",
        hint: "Enter the current spending password for this wallet."
      },
      wrong: "The entered spending password is not correct."
    },
    mnemonic: {
      info: "Click 'Show QR Code' and and enter your spending password to display your saved Catalyst registration QR code."
    },
    hardware: {
      info: "Connect and unlock your hardware wallet, then click 'Show QR Code' to display your saved Catalyst registration QR code."
    },
    download: {
      label: "Download QR code",
      hover: "Download QR code as a PNG image"
    },
    copy: {
      label: "@:common.message.copy.catalyst",
      hover: "@:common.message.copy.catalyst",
      notify: "Copied encrypted Catalyst key: "
    },
    button: {
      showQR: "Show QR Code"
    }
  },
  dereg: {
    headline: "Un-stake wallet (De-register wallet)"
  },
  govdereg: {
    headline: "Deregister as DRep"
  }
};
const receive = {
  used: "used",
  unused: "unused",
  button: {
    share: {
      label: "@.capitalize:common.label.share",
      icon: "mdi mdi-qrcode",
      hover: "@.capitalize:common.label.shareAddress",
      notify: "@:common.message.copy.notify",
      qr: "Show QR Code"
    },
    copy: {
      label: "@:common.label.copyAddress",
      hover: "@:common.label.copyAddress",
      notify: "@:common.message.copy.notify"
    }
  },
  warning: {
    nonStaking: "The funds on this receive address are staked with an external stake key. You won't control the rewards that they accrue."
  },
  error: {
    setting: "Set receiver / change address in settings not found!"
  },
  advanced: {
    show: "Show used/additional addresses",
    hide: "Hide used/additional addresses"
  },
  current: {
    headline: "Available wallet addresses",
    static: "@:common.label.receiveAddress",
    caption: "Share this wallet address to receive payments.",
    notice: {
      label: "@:common.label.privacyNotice",
      text: "Please note that all of your delegated receiving addresses include your stake key. \nWhen you share a delegated receive address, the recipient can search the blockchain using your stake key to locate \nall addresses associated with your wallet and also discover your wallet balance and transaction history.",
      icon: "mdi mdi-information-outline"
    }
  },
  external: {
    delegated: {
      headline: "External addresses (delegated)",
      caption: "These addresses are delegated to a stake pool (if you in fact delegated this account)."
    },
    enterprise: {
      headline: "External addresses (not delegated)",
      caption: "These addresses are not delegated."
    }
  },
  internal: {
    delegated: {
      headline: "Internal change addresses (delegated)",
      caption: "These addresses are delegated to a stake pool (if you in fact delegated this account).\nDon't share internal addresses, always give out external addresses."
    },
    enterprise: {
      headline: "Internal change addresses (not delegated)",
      caption: "These addresses are not delegated.\nDon't share internal addresses, always give out external addresses."
    }
  },
  list: {
    headline: "@:common.address.used",
    caption: "@:wallet.list.caption",
    notstaked: "(not staked)",
    syncing: "Syncing receive addresses..."
  },
  filter: {
    label: "Search specific receive addresses.",
    caption: `You can specify a part of the address, or a derivation path like "m/1852'/1815'/0'/1/32", "1815 0 1 32" or "0 1 32". `,
    hint: "Part of address or derivation path.",
    toggle: {
      all: {
        label: "@:common.label.all",
        info: "Search in all addresses"
      },
      used: {
        label: "@:wallet.receive.used",
        info: "Only search in used addresses."
      },
      unused: {
        label: "@:wallet.receive.unused",
        info: "Only search in unused addresses."
      }
    },
    results: "Found ####count#### matching receive addresses.",
    error: {
      minLength: "A minimum of 2 characters needed to filter addresses.",
      empty: "No matching entries found."
    }
  }
};
const send = {
  headline: "Send ADA and tokens",
  caption: "Enter one or multiple Cardano addresses or ADA Handles from your address book, a qr code or your own accounts.",
  output: {
    hint: "Enter the address of a recipient or an ADA handle"
  },
  accounts: {
    headline: "Inter-account transaction"
  },
  wallets: {
    headline: "Inter-wallet transaction",
    current: "current wallet",
    loading: "Loading wallet list ..."
  },
  button: {
    account: "Send to Account"
  },
  options: {
    headline: "Send Options",
    is: {
      label: "Input Selection",
      caption: "Take control over input selection by spending specific utxo's in your account.",
      reset: "Reset Input Selection"
    },
    import: {
      label: "Import Transaction",
      caption: "Import an unsigned or signed transactions, exported from Eternl or sources."
    },
    metadata: {
      label: "Custom Metadata",
      caption: "Add a custom metadata schema in JSON format according to specification.",
      urllabel: "cardano.org documentation on metadata json format",
      hintJson: "Paste / Enter JSON",
      schemainfo: {
        NoConversions: "Faithfully converts between the minimal shared feature set between JSON and Metadata.",
        BasicConversions: "Adds additional support for byte (as hex strings) and integer keys (as strings).",
        DetailedSchema: "Verbose JSON schema but with most flexibility for metadata conversion."
      },
      error: {
        json: "Invalid JSON.",
        label: "Invalid label(s).\nTop level keys must be unique integers in the range -(2^64 - 1) to (2^64 - 1)."
      }
    },
    housekeeping: {
      label: "Housekeeping",
      caption: "Utilities to reduce the transaction fee for future transactions and to keep your account in a manageable state."
    },
    tf: {
      label: "Token Fragmentation",
      caption: "Spread your assets over multiple utxo's to lower fees for future transactions."
    },
    cu: {
      label: "UTxO Collection",
      caption: "Collect UTxOs of this account, basically merging them into fewer ones. Will create up to 10 transactions at a time. Processing might take a while."
    },
    ms: {
      label: "Special Collection",
      label2: "Collect in Wallet",
      caption: "Collect UTxOs of this ms fee wallet, basically merging them into fewer ones. Will create up to 10 transactions at a time. Processing might take a while."
    }
  },
  step: {
    stepper: {
      receiveAddr: "Receiver",
      metadata: "@.capitalize:common.label.message",
      assets: "@:common.assets.label",
      confirm: "@:common.label.confirm",
      submit: "@:common.label.submit",
      build: "@:common.label.build"
    },
    receiveAddr: {
      label: "@:common.label.receiveAddress",
      caption: "Enter the receive address of the wallet you want to send funds to",
      hint: "@:common.address.enterReceive",
      error: "@:common.address.invalid",
      delete: "Delete Receiver",
      addrBook: {
        label: "@:common.label.addrbook",
        caption: "Select an address from the address book as receiver.",
        show: "Open @:common.label.addrbook"
      },
      qrcode: {
        show: "Open QR-Code Reader"
      },
      resolve: {
        label: "###NAME### disclaimer",
        text: "@:common.label.project cannot check if the ###TYPE### belongs to a specific person! It is entirely your own responsibility to verify that this ###TYPE### belongs to the person you intend to send funds to.\n\nIf this ###TYPE### has a typo or belongs to a different person, your funds will be lost!",
        icon: "",
        change: {
          label: "###NAME### address changed!",
          text: "The address that is represented by the ###TYPE### ###HANDLE### changed since you added it to your address book. \nThis means the ###TYPE### was moved to a different wallet or account. If you send funds, they will go to a different address than what is stored in your address book.\n\nIf you proceed we will update the address book entry to the newest address of that ###TYPE###.\n\nOld address:\n####OLD####\n\nNew address:\n####NEW####",
          icon: "mdi mdi-alert-octagon-outline"
        }
      },
      script: {
        label: "Warning! Possible loss of funds!",
        text: "Do not send funds directly to a smart contract!\n\nThis address appears to be a script address, meaning it is either a Plutus smart contract, or a native script, and we can't tell which. Sending funds to a Plutus smart contract without the correct datum will lock the funds forever, and shouldn't be done through Eternl directly, but instead through a website that builds the transaction for you.",
        icon: "mdi mdi-alert-octagon-outline"
      },
      milkomeda: {
        label: "Important!",
        text: "<p>The address you specified is a <b>Milkomeda C1 side-chain</b> address.<br><br><b>DO NOT</b> attempt to send to a Coinbase, Binance or any other ETH address. <b>Make sure you own the keys to that address!</b><br><br>Funds will be sent to a Cardano smart contract which locks your funds and makes it available on the <b>Milkomeda C1 side-chain</b> as <b>milkADA</b>. <br>It is entirely your own responsibility to verify that this address exists on the Milkomeda C1 side-chain and that you own the keys.</p>",
        icon: "mdi mdi-alert-octagon-outline",
        fee: {
          info: "This fee will be deducted by Milkomeda, when you receive your funds on the Milkomeda chain.",
          mainnetCurrency: "milkADA",
          testnetCurrency: "milkTADA"
        },
        error: {
          minAmount: "The minimum amount to use the milkomeda bridge is ###MIN### lovelace."
        }
      }
    },
    metadata: {
      label: "@:common.label.add on-chain @:common.label.message",
      caption: "Add an (optional) message/comment/memo to the transaction. Press 'ENTER' for multi-line message.",
      hint: "Enter message",
      info: "The message is limited to a 64 byte text string.",
      error: {
        overflow: "Message limited to 64 byte text string.",
        invalidJSON: "Not a valid Cardano JSON general metadata schema."
      }
    },
    assets: {
      label: "@:common.assets.label",
      caption: "@:common.assets.caption",
      withdrawal: "Force withdrawal of rewards together with transaction.",
      utxoManagement: "Allow advanced UTxO management.",
      utxoManagementHover: "@:common.label.project will take care of your utxo management, create more outputs, split large outputs etc. This allows for more parallel transactions to take place later on.",
      donation: "Donate 1 ADA to support Eternl development.",
      donationHover: "We hope you like Eternl! Please consider sending 1 ADA with this transaction to support the development of our project.",
      ada: {
        label: "@:common.txtype.ada",
        hint: "0.000000"
      },
      info: {
        default: "@:common.assets.info.default",
        all: "@:common.assets.info.all",
        allRewards: "@:common.assets.info.allRewards",
        tokens: "@:common.assets.info.tokens",
        lockedUtxos: "@:common.assets.info.lockedUtxos"
      },
      error: {
        minUtxo: "@:common.error.minUtxo",
        fundsLow: "@:common.error.fundsLow",
        account: "No active account",
        minoutput: "One of the outputs needs at least ###AMOUNT### to hold the tokens.",
        milkomeda: {
          minimum: "Minimum token amount for bridging is ###AMOUNT###."
        }
      },
      token: {
        label: "Tokens",
        count: "asset(s) selected to be included in transaction.",
        all: "All",
        info: {
          sendlabel: "Amount to Send",
          added: "@:common.assets.added",
          removed: "@:common.assets.removed"
        }
      },
      button: {
        back: "@:common.label.back",
        all: "@:common.label.all",
        next: "@:common.label.next",
        token: {
          tokens: "Tokens",
          addToken: "@:common.label.add Token",
          addTokenHover: "No tokens left to add.",
          send: "Add Token",
          cancel: "@:common.label.cancel",
          add: "@:common.label.add",
          select: "@:common.label.select",
          addall: "Add All",
          addsearch: "Add All Filtered",
          addpage: "Add All on Page",
          reset: "@:common.label.reset",
          remove: "@.capitalize:common.label.remove",
          all: "Show All Tokens",
          selected: "Show Selected Tokens"
        }
      }
    },
    confirm: {
      label: "@:common.label.confirm",
      caption: "Please review the transaction before signing. Enter the wallet spending password or sign with the hardware device to confirm the transaction.",
      password: form.password.spending.sign,
      info: {
        ledger: "Press 'Sign' and follow the directions on your Ledger device. You might have to select your Ledger device in a browser pop-up window.",
        trezor: "Press 'Sign' and follow the directions on the opened Trezor Connect browser tab to sign.",
        keystone: "Press 'Sign' and follow the directions in the opened modal to sign.",
        readonly: "This wallet is read-only and unable to sign.",
        submit: "Transaction successfully signed, press the @:common.label.submit button to send it to the blockchain.",
        submitList: "Transaction successfully signed and automatically submitted."
      },
      error: {
        expired: "Unable to submit! Transaction life time has expired. Please recreate the transaction with a new expiration date (TTL).",
        submit: "Unable to submit due to error!",
        debug: "For further support, please open a Discord ticket with debug data downloaded.",
        unknownInputs: "Unable to calculate accurate transaction balance due to unknown inputs."
      },
      loading: {
        ledger: "Please follow the directions in the Cardano app on your Ledger device to sign the transaction.",
        trezor: "Please follow the directions outlined in the opened Trezor Connect browser tab and on your Trezor device to sign the transaction."
      },
      multitx: {
        label: "Summary of all transactions",
        doubleSpend: "Invalid transaction list, input utxo is spent more than once:\n"
      },
      preview: {
        label: "Transaction Preview",
        caption: "Addresses marked as 'own' belong to your wallet. 'ext' marks external wallet addresses."
      },
      button: {
        back: "@:common.label.back",
        sign: "@:common.label.sign",
        submit: "@:common.label.submit",
        download: "@.capitalize:common.label.download",
        debug: "Debug @.capitalize:common.label.download",
        reset: "@:common.label.reset",
        save: "@:common.label.sign"
      }
    },
    submit: {
      label: "@:common.label.submit",
      caption: "@:common.submitting",
      status: {
        unknown: "@:common.tx.status.unknown",
        sending: "@:common.tx.status.sending",
        pending: "@:common.tx.status.pending",
        onchain: "@:common.tx.status.onchain",
        verified: "@:common.tx.status.verified",
        failed: "@:common.tx.status.failed"
      },
      info: {
        submitting: "@:common.tx.submitting",
        waiting: "The transaction will be included in one of the upcoming blocks.",
        onchain: "Included in transaction, waiting on wallet sync: ",
        included: "@:common.tx.included"
      },
      button: {
        back: "@:common.label.retry"
      }
    }
  },
  builder: {
    label: "Build your own transaction (power user)",
    caption: "A custom transaction builder that lets your design a transaction just the way you want it.",
    stagingTx: "Staging Tx",
    builtTx: "Built Tx",
    button: {
      build: "Build Tx",
      tf: "Token Fragmentation",
      cu: "Collect UTxOs"
    },
    tf: {
      hint: "Processing. This might take a few minutes depending on the amount of tokens in this account."
    },
    cu: {
      hint: "Processing. This might take a few minutes depending on the amount of utxos in this account."
    },
    withdrawal: {
      autoON: "Automatic withdrawal activated in settings (if needed).",
      autoOFF: "Automatic withdrawal disabled in settings."
    },
    build: {
      ok: "Transaction successfully built!",
      error: {
        label: "Transaction build failed!",
        icon: "mdi mdi-alert-octagon-outline"
      }
    },
    modal: {
      input: {
        label: "UTxO Input(s)",
        caption: "Select specific inputs or leave empty to let @:common.label.project handle the selection for you.",
        button: "Input Selection",
        lockedHover: "This utxo is locked and can not be selected.",
        delete: "Remove input"
      },
      cleanup: {
        button: "Clean up account"
      },
      output: {
        label: "UTxO Output",
        caption: "Build an output by entering a receiver address, amount, and optional tokens.",
        button: "Add Output",
        delete: "Remove output"
      },
      donation: {
        label: "@:common.label.project Donation",
        caption: "We appreciate your support. Thank you.",
        button: "Donation",
        ada: {
          label: "",
          hint: "0"
        },
        error: {
          minAda: "At least ###minada### required (maximum: ###maxada###).",
          account: "No active account"
        }
      },
      ttl: {
        label: "Transaction TTL",
        caption: "Set a custom transaction TTL(Time-To-Live) in minutes. Specifies how long this transaction should be valid until rejected by chain. If unspecified, a default value of 3 hours will be used.",
        button: "Set TTL",
        hover: "Set transaction life time",
        invalid: "Invalid TTL number, please set a number in the range of 1-525600(~1yr.)"
      },
      metadata: {
        label: "Transaction Message",
        caption: "@:wallet.send.step.metadata.caption",
        button: "Add Message",
        delete: "Remove metadata entry",
        encerror: "Failure during message encryption, check console for details",
        builderror: "Failed to generate metadata from message, check console for details"
      },
      metadataLabel: {
        label: "Add metadata JSON",
        caption: "@:wallet.send.step.metadata.caption",
        button: "Add Label",
        delete: "Remove metadata entry",
        labelexist: "A metadata with this label has already been added to the transaction, overwrite existing metadata?"
      }
    }
  },
  locked: {
    label: "Locked UTxO in transaction",
    caption: "This transaction attempts to spend your manually locked UTxOs."
  },
  error: {
    syncing: "@:common.wallet.error.syncing",
    account: "@:common.error.account",
    genesis: "@:common.error.genesis",
    handle: "@:common.address.handle.notFound"
  }
};
const importTx = {
  headline: "Import transactions",
  caption: "You can import unsigned or signed transactions, exported from @:common.label.project or sources.",
  cbor: "Show raw Cbor",
  import: {
    upload: "Transaction file",
    success: "Transaction imported from upload.",
    submit: "Transaction already signed, available to submit."
  },
  steps: {
    select: "Import",
    sign: "Sign",
    submit: "Submit"
  },
  button: {
    sign: "Go to sign transaction",
    submit: "Submit transaction"
  },
  signed: {
    info: "You imported an already signed transaction. If you like you can now submit the transaction."
  },
  unsigned: {
    mnemonic: "You imported an unsigned transaction, please sign the transaction."
  },
  differentWallet: {
    title: "Transaction Wallet Mismatch",
    caption: "The imported transaction does not belong to the selected wallet.",
    info: {
      mnemonic: "@:wallet.importTx.differentWallet.caption You can still attempt to sign, but you will need to use the spending password of the wallet specified below.\n\n###walletname###\n###accountname###",
      hardware: "@:wallet.importTx.differentWallet.caption You can still attempt to sign, but you will need to use the hardware wallet device of the wallet specified below.\n\n###walletname###\n###accountname###"
    }
  },
  error: {
    expired: "@:wallet.send.step.confirm.error.expired",
    upload: "Could not read uploaded file, please make sure it is a text file. You can import files containing plain cbor or transactions exports from @:common.label.project wallet.",
    wallet: "We could not find a wallet with an account that could be used to sign this transaction.\nPlease make sure the wallet needed to sign this transaction is existing and unlocked.",
    walletdata: "Unable to get wallet data, please reload Eternl and try again or contact support if recurring.",
    accountdata: "Unable to get account data, please reload Eternl and try again or contact support if recurring.",
    multiple: "Cannot process import files with more than one transaction.",
    balance: "Failed to generate a tx balance, please contact support for further assistance."
  }
};
const staking = {
  tab: {
    ranked: "Ranked",
    md: "Multi-Delegation",
    featured: "Support us!"
  },
  button: {
    delegate: "Delegate",
    select: "Select",
    deselect: "Deselect",
    share: {
      label: "@:common.label.share",
      icon: "mdi mdi-qrcode",
      hover: "@:common.label.shareAddress",
      notify: "@:common.message.copy.notify"
    },
    copy: {
      label: "@:common.label.copyAddress",
      icon: "mdi mdi-content-copy",
      hover: "@:common.label.copyAddress",
      notify: "@:common.message.copy.notify"
    },
    md: {
      select: "Select Pool",
      deselect: "Deselect Pool",
      enable: "Multi-Delegation",
      disable: "Cancel",
      create: "Create Portfolio",
      submit: "Delegate to pool portfolio",
      clone: {
        label: "C",
        hover: "Copy amount to all pools"
      }
    }
  },
  rank: {
    hover: "Pool ranking based on calculated score"
  },
  support: {
    info: "This pool supports the development of @:common.label.project",
    icon: {
      hover: "@:wallet.staking.support.info"
    },
    rank: {
      hover: "Delegating to this pool supports the development of @:common.label.project"
    },
    score: {
      hover: "@:wallet.staking.info"
    }
  },
  score: {
    hover: "The calculated pool score"
  },
  badge: {
    multipool: {
      hover: "This SPO operates ###gpn### pools."
    },
    singlepool: {
      hover: "This is a single pool operator."
    },
    homepage: {
      hover: "Website"
    },
    twitter: {
      hover: "Twitter"
    },
    telegram: {
      hover: "Telegram"
    },
    youtube: {
      hover: "Youtube"
    },
    retired: {
      label: "retiring"
    }
  },
  saturation: {
    label: "Saturation",
    hover: '<span class="font-mono">< 90% - </span><span class="bg-gray-200 rounded-md px-1 cc-text-semi-bold text-green-600">Green</span>, a good choice<br>\n<span class="font-mono">< 95% - </span><span class="bg-gray-200 rounded-md px-1 cc-text-semi-bold text-yellow-600">Orange</span>, close to saturation<br>\n<span class="font-mono">> 95% - </span><span class="bg-gray-200 rounded-md px-1 cc-text-semi-bold text-red-600">Red</span>, very close to saturation,<br>\n<span class="font-mono">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>monitor and re-delegate if needed'
  },
  pledge: {
    label: "Pledge",
    hover: "This pool meets the registered<br>pledge and earns rewards.",
    notmet: "This pool does not meet the registered<br>pledge and won't yield any rewards."
  },
  fees: {
    label: "Fees",
    hover: "variable margin fee ( fixed cost )"
  },
  ros: {
    label: "ROS e12",
    hover: "ROS of the last 12 epochs"
  },
  poollist: {
    headline: "Available stake pools",
    caption: "A list of available stake pools. Enter the ticker or name of a pool to filter the list. \nClick the delegate button to delegate this account to a specific pool. The ranking prioritizes optimal rewards for the one staking. Pools of multi pool operations get a higher score penalty with each additional pool.",
    notice: {
      label: "@:common.label.privacyNotice",
      text: "Please note that all of your receiving addresses include your stake key. \nWhen you share a receive address, the recipient can search the blockchain using your stake key to locate \nall addresses associated with your wallet and also discover your wallet balance and transaction history.",
      icon: "mdi mdi-information-outline"
    },
    delegated: {
      headline: "Delegated Pools:",
      caption: "This list includes all pools the account is delegated to."
    },
    featured: {
      headline: "Recommended stake pools",
      caption: "To help support the continued development of @:common.label.project we appreciate if you would consider delegating your funds to one of these pools.",
      testnet: "This is a TestNet, feel free to delegate to whatever pool you find worthy."
    },
    poolid: {
      hover: "Copy pool id",
      notify: "Copied pool id: "
    },
    item: {
      name: "pool name",
      description: "description"
    }
  },
  search: {
    label: "Filter pools",
    hint: "Enter a ticker, pool name, other pool details.",
    error: "Error"
  },
  list: {
    headline: "@:common.address.used",
    caption: "@:wallet.list.caption",
    notstaked: "(not staked)"
  },
  md: {
    headline: "Pool Portfolio Delegation (Multi-Delegation)",
    caption: "Pool portfolio delegation is a good way to distribute your funds across multiple pools. Your \nfavorite pool portfolios are created on the wallet settings page after which they become available for selection. \nDelegating to multiple pools gives you several advantages but also a few limitations to consider mentioned below.",
    positive: {
      i1: "Spreading delegation over multiple pools reduces the risk of losing out on rewards due to pool problems/bad operation.",
      i2: "More even rewards as the luck in block election of a single pool is less significant.",
      i3: "Being able to support all your favorite pools without wallet splitting.",
      i4: "Normal delegation still work in parallel and as such delegation through other wallets doesn't impact multi-delegation."
    },
    negative: {
      i1: "Funds placed in multi-delegation are not directly spendable in the wallet without first unlocking. \nUnlocking spendable funds is instant and done by re-delegation of multi-delegation with updated \namounts(and pools if desired) or by disabling/ending current multi-delegation."
    },
    select: {
      label: "Choose Portfolio",
      hint: "Create and manage portfolios on global settings page.",
      noresult: "No matching porfolio"
    },
    ada: {
      divider: "Delegation Amount",
      label: "@:common.txtype.ada",
      hint: "0.000000",
      total: "Portfolio Delegation Total:"
    },
    error: {
      fundsLow: "Insufficient funds, ###reserved### is reserved not available for multi-delegation. \n###base### + ###pool### for each pool in portfolio."
    },
    messages: {
      portfolio: "Select pool portfolio for multi-delegation"
    }
  }
};
const delegation = {
  from: {
    headline: "Current delegation:"
  },
  to: {
    headline: "Change delegation to:"
  },
  warning: {
    saturationlevel: {
      label: "@:common.label.warning",
      text: "Delegating to this pool will oversaturate the pool. You will receive about ###percent### less rewards.",
      icon: "mdi mdi-alert-octagon-outline"
    },
    norewards: {
      label: "@:common.label.warning",
      text: "No rewards! This stake pool set its margin to 100%.\nYou will not earn any rewards!",
      icon: "mdi mdi-alert-outline"
    },
    highfee: {
      label: "@:common.label.warning",
      text: "This stake pool set an unusually high margin.\nYou will earn less compared to other public stake pools.",
      icon: "mdi mdi-alert-outline"
    },
    pledgenotmet: {
      label: "@:common.label.warning",
      text: "This stake pool fails to meet its set pledge goal.\nYou will not earn ANY rewards until the pledge is met.",
      icon: "mdi mdi-alert-outline"
    },
    retired: {
      label: "@:common.label.warning",
      text: "This stake pool will be retiring in epoch ###epoch###.\nYou will not earn ANY rewards from that epoch on.",
      icon: "mdi mdi-alert-outline"
    },
    fundslow: {
      label: "Please note!",
      text: "When delegating a wallet with a lower amount of funds, the time it takes to earn back the transaction \nfee can be very long. There is one transaction fee on delegation and a second claiming rewards. Transaction fee can \nbe seen in the details below and the pool's ROS(yearly) in the above pool tile.",
      icon: "mdi mdi-alert-octagon-outline"
    },
    nofunds: {
      label: "Not enough funds!",
      text: "Please add at least 2.2 Ada to this account (in addition to your collateral) to be able to delegate.",
      icon: "mdi mdi-alert-octagon-outline"
    }
  },
  steps: {
    stepper: {
      confirm: "@:common.label.confirm",
      submit: "@:common.label.submit"
    }
  },
  info: {
    nodata: "no pool data available",
    undelegated: "not delegated",
    delegated: "delegated",
    deregistered: "deregistered",
    registered: "registered",
    pending: "pending",
    producing: "producing"
  }
};
const deregistration = {
  headline: "Wallet De-Registration",
  rewards: {
    label: "@:common.label.attention",
    text: "The wallet contains ###rewards### unclaimed rewards. Rewards will be claimed together with the de-registration transaction.\nAny pending rewards however will be lost if you continue with the de-registration.",
    icon: "mdi mdi-information-outline"
  },
  steps: {
    stepper: {
      confirm: "@:common.label.confirm",
      submit: "@:common.label.submit"
    }
  },
  error: {
    account: "@:common.error.account",
    genesis: "@:common.error.genesis"
  }
};
const withdrawal = {
  headline: "Withdraw rewards:",
  steps: {
    stepper: {
      confirm: "@:common.label.confirm",
      submit: "@:common.label.submit"
    }
  }
};
const catalyst = {
  caption: "Catalyst brings on-chain governance to the Cardano blockchain by allowing the community to self-determine priorities for growth.",
  step: {
    stepper: {
      info: "Info",
      app: "App",
      pin: "PIN",
      tx: "Transaction"
    },
    info: {
      ideascale: {
        header: "IdeaScale",
        caption: "Browse Proposals",
        text: "Catalyst uses IdeaScale as a collaborative innovation platform. This is done through voting on \ncommunity generated proposals which focus on solving the challenge of a particular fund.",
        button: {
          label: "Learn More",
          link: "https://cardano.ideascale.com/"
        }
      },
      newsletter: {
        header: "Newsletter",
        caption: "Keep up to date",
        text: "Sign up for the Project Catalyst Newsletter to not miss out on the latest news and updates.",
        button: {
          label: "Subscribe",
          link: "https://mpc.projectcatalyst.io/newsletter-signup"
        }
      },
      engage: {
        header: "Engagement",
        caption: "Engage the community",
        text: "Join the Telegram discussion and announcement channels to share your ideas on future Cardano \nimprovement proposals and enjoy a healthy, stimulating discussion.",
        button1: {
          label: "Announcements Channel",
          link: "https://t.me/cardanocatalyst"
        },
        button2: {
          label: "Community Chat",
          link: "https://t.me/ProjectCatalystChat"
        }
      },
      townhall: {
        header: "Town Hall",
        caption: "Meet the builders",
        text: "Come and meet the future builders of Cardano in the weekly Town Hall meetings. Watch their live presentations and participate in meaningful conversations.",
        button: {
          label: "Weekly Town Hall Recordings",
          link: "https://www.youtube.com/playlist?list=PLnPTB0CuBOByRhpTUdALq4J89m_h7QqLk"
        }
      },
      fund: {
        challenges: {
          show: "Show Challenges",
          hide: "Hide Challenges",
          link: "Challenge Website",
          allocation: "Fund Allocation"
        },
        timeline: {
          caption: "Timeline shown below are subject to changes. Stay up-to-date by re-visiting this page and participate in the Catalyst weekly town hall meetings.",
          snapshot: {
            label: "Voting Power Snapshot",
            caption: ""
          },
          votestart: {
            label: "Voting Start",
            caption: ""
          },
          voteend: {
            label: "Voting End",
            caption: ""
          },
          result: {
            label: "Result",
            caption: " a few days."
          }
        }
      },
      button: {
        next: "@:common.label.next"
      }
    },
    app: {
      header: "Cardano Catalyst Voting Application",
      caption: "In order to participate and vote in the Catalyst funds, first you have to download the Catalyst mobile application to your phone.",
      apple: {
        label: "Apple App Store",
        url: "https://apps.apple.com/in/app/catalyst-voting/id1517473397"
      },
      android: {
        label: "Google Play Store",
        url: "https://play.google.com/store/apps/details?id=io.iohk.vitvoting"
      },
      button: {
        next: "@:common.label.next",
        register: "@:common.label.register"
      },
      notice: {
        label: "Please note:",
        text: "DON'T scan these QR codes in the Catalyst mobile app!\nQR code link to the store where you can download and install the Catalyst mobile app.",
        icon: "mdi mdi-information-outline"
      }
    },
    pin: {
      header: "PIN Code",
      caption: "This PIN will be required every time you use the Catalyst voting application on your phone.",
      warning: "Make sure to write it down! Losing this PIN will require a new voting key registration!",
      hint: "0",
      confirm: "Input PIN a second time to confirm.",
      confirmError: "PIN code mismatch, please retry!",
      button: {
        next: "@:common.label.next"
      }
    },
    tx: {
      header: "Voting Registration Transaction",
      caption: "Click on Register to construct a transaction that connects the generated Catalyst voting key to this wallet. \nThe higher amount of funds the wallet holds, the more voting power it disposes with. \nPlease review the transaction before signing. Enter the wallet spending password or sign with \nthe hardware device to confirm the transaction.",
      warning: "Make sure to keep your account balance above 25 Ada at the voting power snapshot event, \notherwise your voting key registration would be dismissed."
    }
  },
  error: {
    network: "Unsupported network for Catalyst vote registration.",
    syncing: "@:wallet.error.syncing",
    account: "@:common.error.account",
    save: "Failed to save voting key to wallet storage. Please contact support for further assistance!",
    catalystkey: "Catalyst voting key missing. This shouldn't happen, please contact support!",
    api: "Unable to query voting API, please reload or contact support if recurring.",
    funds: "At least ###min_ada_catalyst### is required for the wallet to be eligible to participate in voting.",
    rewards: "Your ###rewards_amount### rewards can not be used in voting unless you withdraw them to your wallet.",
    notregistered: "The wallet is not registered, please first delegate to a stake pool in order to participate in Catalyst voting.",
    nometadata: "Unknown error, registration metadata not correctly generated, please retry or contact support if recurring."
  },
  warning: {
    registerForNextFund: {
      label: "Please note",
      caption: "Currently, registration is open for fund 10 of Catalyst. After this event, voting on future funds will be handled differently. Join the Catalyst communities to learn more."
    }
  }
};
const governance = {
  caption: "Navigating the Voltaire Era in Cardano's blockchain governance, where community-driven decisions light the path to a resilient and inclusive ecosystem.",
  era: "The network has not crossed into the Voltaire (Conway) era yet.",
  delegation: {
    current: {
      label: "Current Vote Delegation",
      undelegated: "Undelegated",
      vote: "Vote",
      drep: "DRep ID (CIP-129)",
      drepOld: "DRep ID (CIP-105)",
      status: "Status",
      active: "Active",
      inactive: "Inactive",
      unregistered: "Unregistered",
      votepower: "Vote Power"
    },
    new: {
      label: "New Vote Delegation",
      options: {
        own: "Own Account",
        custom: "Specify DRep ID",
        eternl: "Eternl DRep Committee",
        abstain: "Abstain",
        noconfidence: "No Confidence"
      },
      button: {
        delegate: "Delegate",
        governance: "Governance Delegation"
      },
      accModal: {
        label: "Account Governance Vote Delegation",
        caption: "Select the account to delegate your voting power to. If same account, a DRep registration will automatically be done if needed, else the selected account must already be DRep registered.",
        accounts: {
          headline: "Inter-account vote delegation"
        },
        wallets: {
          headline: "Inter-wallet vote delegation",
          current: "current wallet",
          loading: "Loading wallet list ..."
        },
        button: {
          account: "Delegate to Account"
        }
      },
      anchorModal: {
        label: "DRep Registration Anchor (optional)",
        caption: "Your URL with extra info about you. Leave empty to omit. See this link for how to add info:",
        link: "https://docs.gov.tools/about/what-is-cardano-govtool/govtool-functions/storing-information-offline",
        hint: "https://..."
      },
      error: {
        accdrepmissing: "Account DRep credentials missing, please sync selected account!",
        owndrepmissing: "Own DRep credential missing, please sync active account!",
        invaliddrep: "Invalid DRep ID",
        notregistered: "DRep ID not registered, unable to delegated to specified DRep",
        unknown: "Unknown error occurred serializing DRep ID"
      }
    }
  },
  info: {
    text: "In order to participate in governance, each stake credential must be delegated to a DRep. Ada holders will generally delegate their voting rights to a registered DRep that will vote on their behalf. In addition, two pre-defined DRep options are available:",
    abstain: {
      label: "Abstain",
      text: "If an Ada holder delegates to Abstain, then their stake is actively marked as not participating in governance. The effect of delegating to Abstain on chain is that the delegated stake will not be considered to be a part of the active voting stake. However, the stake will be considered to be registered for the purpose of the incentives."
    },
    noconfidence: {
      label: "No Confidence",
      text: 'If an Ada holder delegates to No Confidence, then their stake is counted as a no vote on every governance action apart from a "Motion of no confidence". This also signals that they have no confidence in the existing constitutional committee. The effect of delegating to No Confidence on chain is that this stake will be considered to be a part of the active voting stake. It will count as a Yes vote on every No Confidence action and a No vote on every other action. It also serves as a directly auditable measure of the confidence of Ada holders in the constitutional committee.'
    },
    note: "Any Ada holder may register themselves as a DRep and delegate to themselves if they wish to actively participate in voting.",
    govtool: {
      mainnet: "",
      guild: "",
      sancho: "https://sanchogov.tools/",
      preprod: "",
      preview: "",
      label: "GovTool",
      info: "For more information about Cardano governance and additional actions, visit"
    }
  },
  key: {
    show: "Show Account Governance Credentials",
    hide: "Hide Account Governance Credentials",
    info: "CIP129 is the preferred standard. But showing also CIP105 for backwards compatibility.",
    drep: {
      header: "DRep ID",
      caption: "In the Conway ledger era, DRep credentials allow registered DReps to be identified on-chain, in DRep registrations, retirements, votes, and in vote delegations from ada holders."
    },
    cccold: {
      header: "CC Cold Credential",
      caption: "Constitutional committee members can be recognized by their cold credentials within update committee governance actions, authorize hot credential certificate and resign cold key certificates."
    },
    cchot: {
      header: "CC Hot Credential",
      caption: "Constitutional committee hot credential can be observed within the authorize hot key certificate and votes."
    }
  },
  copy: {
    address: {
      hover: "@:common.label.copyAddress",
      notify: "@:common.message.copy.notify"
    }
  }
};
const voting = {
  catalyst,
  governance,
  tab: {
    catalyst: "Catalyst - Project Funding",
    governance: "Blockchain Governance"
  }
};
const qr = {
  scan: {
    headline: "Scan QR Code",
    caption: "Scan QR Code Here",
    icon: "mdi mdi-qrcode",
    progress: "Progress"
  },
  select: "Select camera",
  loading: "Initializing camera(s)...",
  switch: {
    label: "Switch camera",
    icon: "mdi mdi-camera-flip"
  },
  error: {
    nocamera: "No camera detected on device",
    notfound: "Selected camera not found, disconnected?"
  },
  bex: {
    fullscreenNotice: "Please open the extension in fullscreen mode to allow camera access. This only has to be done once.\nClick on this text to go fullscreen."
  }
};
const syncInfo = {
  idle: "",
  initializing: "Initializing",
  queued: "Queued",
  syncing: "Syncing",
  success: "Finished",
  skipped: "Finished",
  synced: "Synced",
  error: "Failed"
};
const icon = {
  label: "Wallet Icon",
  caption: "Set a custom wallet icon or generate a random wallet icon.",
  upload: "Image Upload",
  setAs: "Use as wallet icon",
  button: {
    save: "Save Icon",
    reset: "Reset"
  }
};
const background = {
  label: "Wallet Background",
  caption: "Set a custom wallet background based on any NFT.",
  setAs: "Use as wallet background",
  opacity: "Opacity",
  tokenPolicy: {
    label: "Token Policy ID",
    info: "The policy id of the token you want to set as wallet background."
  },
  assetName: {
    label: "Asset Name",
    info: "The asset name of the token you want to set as wallet background. The asset name must be hex encoded."
  },
  button: {
    save: "Save Background",
    reset: "Reset",
    preview: "Show preview",
    randomMez: "Random mesmerizer",
    clearPreview: "Clear preview",
    remove: "Remove background"
  },
  error: {
    metadata: "No suitable metadata for background found.",
    bexMode: "We are sorry, but we cannot use this NFT as background due to browser extension limitations."
  }
};
const createAccount = {
  headline: "New @:common.label.stakingvault Account",
  caption: "Lock ADA in your @:common.label.stakingvault to help fund @:common.label.project and earn ADA rewards.",
  error: "Failed to create @:common.label.stakingvault account, please reload site and try again.",
  warning: {
    readFAQ: {
      label: "@:common.message.important",
      text: "<ul><li>Before you can create a @:common.label.stakingvault account, you must <strong>read and accept the FAQ</strong>!</li></ul>",
      icon: "mdi mdi-alert-octagon-outline"
    },
    toggleReadFAQ: {
      label: "Accept FAQ",
      text: "<strong>I've read the FAQ</strong> carefully and understand and <strong>accept</strong> the risks involved.",
      icon: "mdi mdi-alert-octagon-outline"
    },
    instructions: {
      account: {
        label: "@:common.label.instructions",
        text: "<ul><li>To be able to participate, first you need to create a @:common.label.stakingvault account.</li></ul>",
        icon: "mdi mdi-help-circle-outline"
      }
    }
  }
};
const summary = {
  headline: "Staking Vault",
  caption: "Manage your @:common.label.stakingvault funds here.",
  instructions: {
    locked: {
      text: "<ul><li>Funds can't be redeemed before the lock period ends.</li><li>Once a lock period is over, redeem your funds and rewards to earn public stake rewards or re-lock with Staking Vault.</li></ul>",
      icon: "mdi mdi-information-outline"
    },
    redeemable: {
      text: "<ul><li>Click <strong>'redeemable'</strong> to transfer your previously locked ADA and your ADA rewards to your currently active account.</li><li>Once the transfer is complete, you will earn rewards from the public stake pool your active account is delegated to.</li><li>You will also have the option to <strong>re-lock</strong> your ADA with <strong>Staking Vault</strong>.</li></ul>",
      icon: "mdi mdi-information-outline"
    },
    redeemed: {
      text: "<ul><li>These previously locked funds were successfully transferred to you usual wallet account.</li></ul>",
      icon: "mdi mdi-information-outline"
    },
    external: {
      text: "<ul><li>Funds can't be redeemed before the lock period ends.</li><li>Once a lock period is over, redeem your funds and rewards to earn public stake rewards or re-lock with Staking Vault.</li></ul>",
      icon: "mdi mdi-information-outline"
    },
    withLocks: {
      label: "@:common.label.pleaseNote",
      text: "<ul><li>Funds cannot be redeemed before the lock period ends.</li><li>Once a lock period is over, redeem your funds and rewards to earn public stake rewards or re-lock with Staking Vault.</li></ul>",
      icon: "mdi mdi-information-outline"
    },
    withoutLocks: {
      label: "@:common.label.instructions",
      text: "<ul><li>There are no @:common.label.stakingvault entries.</li><li>Please <strong>read the FAQ</strong> before you lock any funds.</li></ul>",
      icon: "mdi mdi-help-circle-outline"
    },
    withoutSVAccount: {
      label: "@:common.label.instructions",
      text: '<ul><li><strong>Read the FAQ</strong> and generate a @:common.label.stakingvault account in "Lock ADA"</li></ul>',
      icon: "mdi mdi-help-circle-outline"
    }
  },
  label: {
    lockedFunds: "Locked funds",
    redeemableFunds: "Redeemable funds",
    redeemedFunds: "Redeemed funds",
    externalFunds: "Rewards / External funds",
    lockedAt: "Locked At",
    transferredAt: "Transferred At",
    unlocksAt: "Unlocks At",
    amount: "Amount Locked",
    refRewards: "Rewards (Ref. Pool)",
    svRewards: "Rewards (Staking Vault)",
    status: "Status"
  },
  tooltip: {
    locked: "These funds (ADA and Mesmerizer tokens) are locked and can't be moved.",
    redeemable: "Click to redeem these previously locked funds.",
    redeemed: "These funds (ADA and Mesmerizer tokens) have been redeems.",
    external: "These funds were not part of a Staking Vault transaction. Click to redeem.",
    unknown: "These funds were not part of a Staking Vault transaction. Click to redeem."
  },
  note1: {
    label: "What is this and how does it work?",
    text: "+ Start by visiting the <strong>FAQ</strong>. After carefully reading it through it should answer any question you might have for what and how the staking vault feature work.<br/>+ Once you have read the FAQ you can move on to <strong>Lock ADA</strong> and follow the directions outlined."
  },
  note2: {
    label: "How to claim ADA and rewards?",
    text: "+ Once the locking duration ends, status will change from locked to <strong>claimable</strong>.<br/>+ Click on <strong>status button</strong> to redeem locked ADA and earned rewards.<br/><br/>Do <strong>NOT</strong> send any ADA to the timelock script address outside this interface. Only ADA locked through this interface generates rewards!"
  }
};
const lock = {
  headline: "Add funds to @:common.label.stakingvault",
  caption: "Lock ADA in your @:common.label.stakingvault to help fund @:common.label.project and earn ADA rewards.",
  //
  // readFAQ:                    '<strong>Read the FAQ</strong> carefully before you continue!',
  warning: {
    instructions: {
      process: {
        label: "@:common.label.instructions",
        text: '<ul><li>Choose a <strong>@:common.label.lockperiod </strong><ul class="pl-4"><li>+ Minimum 12 epochs (2 months)</li><li>+ Maximum 36 epochs (6 months)</li></ul></li><li>Choose an <strong>amount</strong> (minimum 500 ADA, maximum: 1MM ADA)</li><li>Lock the <strong>amount</strong> for the <strong>@:common.label.lockperiod </strong></li></ul>',
        icon: "mdi mdi-help-circle-outline"
      },
      account: {
        label: "Account necessary",
        text: "<ul><li>To be able to participate switch to <strong>Overview</strong> and create a Staking Vault account.</ul>",
        icon: "mdi mdi-help-circle-outline"
      },
      calc: {
        label: "Calculator",
        text: "<ul><li>Enter an ADA <strong>Lock Amount</strong> and the <strong>Lock Period</strong> to calculate the rewards.<li></ul>",
        icon: "mdi mdi-help-circle-outline"
      }
    }
  },
  // caption: {
  //
  //   1:                        '+ <strong>Read the FAQ</strong> carefully before you continue!',
  //   2:                        '+ Generate a @:common.label.stakingvault account',
  //   3:                        '+ Choose a <strong>@:common.label.lockperiod </strong><ul class="pl-4"><li>- Minimum 12 epochs (2 months)<li/><li>- Maximum 36 epochs (6 months)<li/></ul>',
  //   4:                        '+ Choose an <strong>amount</strong> (minimum 500 ADA)',
  //   5:                        '+ Lock the amount for the @:common.label.lockperiod'
  // },
  period: "Lock Period",
  rewards: "@.capitalize:common.label.rewards Comparison",
  refpool: {
    label: "0% Reference Pool (estimate)"
  },
  svpool: {
    label: "@:common.label.stakingvault  (deterministic)"
  },
  mez: {
    select: "Include 'The Mesmerizer' token in lock?",
    info: "Select up to two 'The Mesmerizer' support token(s) to include for an additional minor rewards boost. Please make sure to hold the token(s) in the account for the entire duration of the lock period.",
    notify: "Mesmerizer selection restricted to two, choose wisely!"
  },
  button: "Lock ADA",
  note: {
    label: "Locking unavailable",
    text: "We allow ADA to be locked in your Staking Vault from 4 hours into the epoch until 4 hours (###epochlimit###) before the end of the epoch. Please wait until the new epoch started to add funds to your Staking Vault."
  },
  network: {
    label: "Locking unavailable",
    text: "@:common.label.stakingvault is a Cardano Mainnet feature."
  },
  addaccount: {
    label: "Create @:common.label.stakingvault Account",
    caption: "Account keys are generated from the wallet root key.",
    password,
    info: {
      mnemonic: "Please enter your spending password to get access to @:common.label.stakingvault account.",
      ledger: "Press 'Add Account' and follow the directions on your Ledger device. You might have to select your Ledger device in a browser pop-up window.",
      trezor: "Press 'Add Account' and follow the directions on the opened Trezor Connect browser tab.",
      readonly: "This is a read-only wallet. It can't add a @:common.label.stakingvault account.",
      submit: "@:common.label.stakingvault account successfully created."
    },
    error: {
      general: "Failed adding an account.",
      password: "Invalid password.",
      nohw: "No hardware wallet.",
      nokey: "No account key generated.",
      mismatch: "Wrong key for account 0: The derived account does not match this wallet's keys. Wrong device? Wrong optional secret passphrase?"
    },
    loading: {
      ledger: "Please follow the directions in the Cardano app on your Ledger device.",
      trezor: "Please follow the directions outlined in the opened Trezor Connect browser tab and on your Trezor device."
    },
    button: {
      back: "@:common.label.back",
      sign: "Add Account",
      submit: "@:common.label.submit",
      reset: "@:common.label.reset",
      save: "Add Account"
    }
  },
  amount: {
    label: "Amount to Lock",
    ada: {
      label: "",
      hint: "0"
    },
    info: {
      default: "@:common.assets.info.default"
    },
    error: {
      minAda: "At least ###minada### required (maximum: ###maxada###).",
      fundsLow: "@:common.error.fundsLow",
      account: "No active account"
    }
  }
};
const faq = {
  headline: "Staking Vault - FAQ",
  caption: "Important! Read the Staking Vault FAQ entirely, especially the section about involved risks. It is crucial that you understand how it works and what to expect.",
  faq0: {
    headline: "Why Staking Vault?",
    text: "Staking Vault is our funding mechanism.\n\nWe are committed to providing a reliable wallet experience. At scale, this costs a lot of money each month.\n\nBut you can help us cover that cost, grow the team and continue to innovate."
  },
  faq1: {
    headline: "What is in it for me?",
    text: "In addition to new features, reliable infrastructure, and a motivated team of developers and community managers, you can earn more rewards. How?\n\nOn Cardano, a private stake pool that is fully pledged can earn more rewards than a public stake pool.\n\nIf you help us, we create a win-win situation. You as a delegator earn about 15% more ADA rewards* over the 12 epoch minimum period. Committing your ADA longer will earn you even more."
  },
  faq2: {
    headline: "But there is a catch, isn't there?",
    text: "Yes, there is. To be sure that the pledge isn't moved out of the private pool, your ADA must be time-locked. This has implications on who should and who should not stake with us.\n\nLets say you have two wallets, one for your day-to-day ADA spending and one long-term hold account, funds that you will not move within the next few months. Then Staking Vault is a viable choice for you because you earn more ADA rewards and help our project grow. Think of a traditional fixed return savings account.\n\nFunds that you need daily should not be staked using Staking Vault. You cant move those funds during the lock period.\n"
  },
  faq3: {
    headline: "Do I lose custody of my funds, are smart contracts involved?",
    text: "No to both. Cardano has support for Native Scripts, the little brother of Smart Contract scripts. Native Scripts add features like multi-sig, but also time-locking, which we will make use of for Staking Vault.\n\nYou retain full custody of your funds. You choose a lock period and once your ADA is transferred to the time-locked address, funds cant be moved until the lock period is over.\nUnlocking of your funds happens automatically, thanks to the Cardano ledger rules.\n\nAnd the best part: Its completely non-custodial. To transfer your funds back to your main account, only your own key needs to sign the transaction."
  },
  faq4: {
    headline: "How does that work exactly?",
    text: "We generate an extra account that will not interfere with your everyday wallet funds.\n\nYou select an ADA amount (minimum: 500 ADA, maximum: 1MM ADA) as well as the lock period (12 epochs minimum, up to 36 epochs).\n\nYou will be presented with the exact amount of rewards that you will earn during the lock period. This data will be part of the transaction metadata, clearly visible on-chain, for you to check.\n\nThe rewards will be added to the time-locked address during the epoch before your funds will unlock. Upon unlocking, you will withdraw your staked ADA as well as the ADA rewards.\n\nThis is an active staking process which means you have to keep track of your lock period. Once the lock period is over you need to move your funds back to your main account manually to again generate public pool rewards or to re-lock with Staking Vault."
  },
  faq5: {
    headline: "How much more is more?",
    text: "Locking your ADA for 12 epochs will earn you 15% more ADA rewards* than staking to a public stake pool. Over 24 epochs: 16.6% more* and over 36 epochs: 18.4% more*. \n\n(See how we compare the annualized ROS of private vs. public stake pools at the bottom of this page.)"
  },
  faq6: {
    headline: "Wen Mesmerizer utility?",
    text: "As a Thank you to our early supporters, Mesmerizer tokens will provide a small boost to earned Staking Vault ADA rewards.\n\nImportant! Please dont buy Mesmerizer tokens on the secondary market only to boost Staking Vault ADA rewards. Depending on your HODL ADA bag size, its not worth the investment for this purpose alone. Of course, the artistic value and collecting tokens are also valid reasons to buy them. All we are saying is, the rewards boost is not large enough if the staked bag is not large, to begin with.\n\nYou can add up to two of our The Mesmerizer ::: collection 2021 tokens to increase your earned ADA rewards. Here are some examples of how much more* ADA you can earn compared to a public pool with and without adding our tokens (number may vary, rewards for a locking process will be calculated on the Staking Vault page):",
    text_1: "epochs base   1 com  2 com  2 unc  2 rar  2 ult  uni+com\n\n  12   15.0%  16.0%  17.0%  18.0%  19.0%  20.0%  19.0%\n  24   16.6%  17.7%  18.7%  19.7%  20.8%  21.8%  20.8%\n  36   18.4%  19,4%  20.5%  21.5%  22.6%  23.6%  22.6%",
    text_1_1: "epochs base   1 com  2 com  2 unc\n\n  12   15.0%  16.0%  17.0%  18.0%\n  24   16.6%  17.7%  18.7%  19.7%\n  36   18.4%  19,4%  20.5%  21.5%",
    text_2: "As you can see, adding tokens scales with the amount of locked ADA and the lock period.\nAgain: its not worth buying Mesmerizers on the secondary market for small lock amounts.\n\nPlay around with the Staking Vault UI to see the effect of adding one or two Mesmerizers to a potential locked ADA bag.\n"
  },
  faq7: {
    headline: "Are rewards paid manually?",
    text: "Most important: this is not a trustless system.\n\nDelegating to a public Cardano stake pool either yields rewards or not, depending on whether the pool produces a block. Rewards of delegates are paid automatically by the Cardano protocol. Rewards of pledged ADA go to the pool operator, who must pay the pool owners manually.\n\nLocking your ADA in Staking Vault is similar: you pledge to a pool, and all rewards go to the pool operator, in this case, us. \n\nYour overall earned rewards are calculated before you sign the locking transaction. The rewards amount is part of the transaction metadata for you to verify.\n\nThe rewards will be added to the time-locked address during the epoch before a time-lock ends. Upon redeeming, you will withdraw your staked ADA as well as the ADA rewards and your Mesmerizer tokens."
  },
  faq8: {
    headline: "What are the risks?",
    text: "Keys: Only your own keys are involved. Your ADA remains in your wallet.\n\nTime-lock: The lock period is checked several times before the lock period is displayed and you sign the transaction. The risk of losing access to your funds for more than 36 epochs is tiny, but not zero.\n\nRewards payout: We do pay out rewards manually for the technical reasons described above. Honoring the amount of the rewards is our top priority. The only case in which it is possible that rewards dont get paid is if we would stop working altogether as a company providing this service. Our track record as pool operators is a good indication of our reliability and shows that this is absolutely not likely to happen.\n\n\nLosing out: Time-locking ADA bears the risk of losing gains. For example, lets say you lock your ADA for half a year (36 epochs), and a new ATH happens three months into the lock period, then the price falls until the funds unlock. Also, keep in mind that you also cannot participate in ISPOs with locked funds.\n\nIf you dont understand those risks or dont accept those risks: Dont lock your ADA with Staking Vault!"
  },
  faq9: {
    headline: "Why would I lock my ADA, then?",
    text: "We want to provide you with a scalable Cardano wallet solution, and we have a lot of ideas on how to improve the wallet and help the Cardano ecosystem as a whole.\n\nStaking Vault is our way of funding the project, and its a starting point for all the things to come.\n\nIf you want to see Eternl succeed and evolve, please consider putting one of your long-term holding ADA funds in Staking Vault.\n\n\nAlso: Earning more rewards than possible with any other pool available seems like a pretty sweet deal to us.\n\nThank you.\n"
  },
  faq10: {
    headline: "Private vs. Public staking:",
    text: "*We compare the difference in annualized ROS with a 0 ADA pledge, 0% margin fee, 340 ADA fixed fee, fully saturated public stake pool, that has 100% luck, and loses about 5% of its blocks (in epoch 325 only 20541 of an average of 21600 blocks were minted, roughly 95%)\n\nFor example, 15% more ADA rewards equate to an average of 4.6% annualized ROS vs. an average of 4.0% annualized ROS if a public pool would earn that much in that particular epoch.\n\nKeep in mind that the ADA reserves shrink with each epoch, and so does the annualized ROS (roughly by 0.8% per year). So each epoch, we will announce an annualized ROS value that will be static for the whole lock period. So while public stake pools return fewer rewards each epoch, with our fixed ROS value, you will earn more rewards with every additional epoch you have your ADA time-locked with Staking Vault."
  },
  faq11: {
    headline: "Why can't I lock my ADA in Staking Vault anymore?",
    text: `While the concept was promising, Staking Vault hasn't attracted much attention because ADA holders are used to unlocked staking.

The Staking Vault redemption page will be available as long as there is a single locked utxo left to redeem. All rewards will be paid as guaranteed when you locked your funds.

We want to say "Thank you!" to all our supporters. Please delegate to TITAN instead.
`
  }
  //
  //
  // 1: {
  //
  //   label:          'How does it work?',
  //   li: {
  //
  //     1:            '+ Generate a ccvaultio staking vault account',
  //     2:            '+ Choose a <strong>locking duration.</strong><ul class="pl-4"><li>- Minimum 12 epochs (2 months).<li/><li>- Maximum 36 epochs (6 months).<li/></ul>',
  //     3:            '+ Choose an <strong>amount</strong>, minimum 500 ADA.',
  //     4:            '+ Lock the amount for the locking duration.'
  //   }
  // },
  //
  // 2: {
  //
  //   label:          'How to claim ADA and rewards?',
  //   li: {
  //
  //     1:            '+ Once locking duration ends, status will change from locked to <strong>claimable</strong>.',
  //     2:            '+ Click on <strong>status button</strong> to redeem locked ADA and earned rewards.'
  //   }
  // },
  //
  // 3: {
  //
  //   label:          'Is there more in-depth information?',
  //   li: {
  //
  //     1:            'Yes, you will find a detailed overview of this staking vault feature in our FAQ.',
  //     2:            '[link to FAQ post for staking vault]'
  //   }
  // }
};
const stakingvault = {
  createAccount,
  summary,
  faq,
  lock,
  network: {
    label: "Unavailable",
    text: "@:common.label.stakingvault is a Cardano Mainnet feature."
  },
  building: "@.capitalize:common.status.building",
  steps: {
    stepper: {
      confirm: "@:common.label.confirm",
      submit: "@:common.label.submit"
    }
  },
  error: {
    metapool: "@:common.label.stakingvault pool in metadata not a valid pool",
    scriptaddr: "Transaction contains @:common.label.stakingvault metadata but is not locked on a valid time-lock script address.",
    create: "Unable to generate @:common.label.stakingvault transaction, please reload or contact support if recurring.",
    lockaccount: "Failed to create @:common.label.stakingvault account, please reload site and try again."
  }
};
const swap = {
  aggregator: {
    unavailable: "All exchange aggregators currently unavailable, please re-visit at a later time or utilize the DApp Browser to interact directly with an exchange.",
    ms: "MuesliSwap",
    dh: "DexHunter"
  },
  create: {
    headline: "Swap tokens",
    caption: "Eternl's in-wallet swap lets you buy/sell tokens at the best price available.",
    credit: "In collaboration with @:wallet.swap.aggregator.ms & @:wallet.swap.aggregator.dh",
    disabled: "In-Wallet swap temporary disabled.",
    instant: {
      label: "Market",
      hover: "Instant swap using market price from the best provider"
    },
    settings: {
      hover: "Open swap settings",
      modal: {
        label: "Swap Settings",
        slippage: {
          label: "Slippage Tolerance",
          info: "Your transaction will not go through if the pool price moves below set percentage.",
          limit: "Limit order activated, slippage setting has no effect!",
          warning: "Beware that using a high slippage is risky. Please read up on slippage for AMM orders before you continue.",
          custom: "Custom",
          input: "Custom Slippage",
          inputinfo: "Set a custom slippage percentage between 0.1 and 100."
        },
        aggregator: {
          label: "Aggregator"
        },
        provider: {
          label: "Provider Selection",
          info: "Disable specific DEX providers.",
          empty: "Unable to disable all providers"
        }
      },
      error: {
        slippage: {
          low: "A negative slippage is not allowed.",
          high: "A slippage above 100 % is not allowed."
        }
      }
    },
    limit: {
      label: "Limit",
      hover: "Limit swap using pool of selection at set price",
      provider: "Select a liquidity pool",
      fees: "Fees",
      liquidity: "Liquidity"
    },
    input: {
      from: {
        title: "Swap from",
        caption: "Select own wallet asset to swap."
      },
      to: {
        title: "Swap to",
        caption: "Select asset to receive."
      },
      clickselect: "Click To Select",
      modal: {
        title: "",
        caption: ""
      },
      token
    },
    estimate: "Fetching best price for swap",
    building: "@.capitalize:common.status.building",
    info: {
      summary: "Summary",
      provider: "Provider",
      price: "Price",
      avgprice: "Avg. Price",
      effprice: "Effective Price",
      pricediff: "Price Impact",
      batcherfee: "Batcher Fee",
      totalfee: "Total Fee",
      frontend: "Frontend Fee",
      dhfee: "DexHunter Fee",
      deposit: "Deposit (returned)",
      topay: "To Pay",
      estreceive: "Est. Receive",
      minreceive: "Min. Receive",
      aggbonus: "Agg. Bonus",
      slippage: "slippage",
      aggregator: "Aggregator"
    },
    modal: {
      swap: {
        label: "Confirm Swap Transaction"
      }
    }
  },
  orders: {
    headline: "Open Orders",
    caption: "Displays on-chain open swap orders not yet processed.",
    refresh: "Open Orders list successfully refreshed!",
    empty: {
      label: "No Open Orders",
      text: "The swap transaction has to be registered on-chain before it will be visible.",
      icon: "mdi mdi-help-circle-outline"
    },
    outOfRange: "Market price out of range",
    label: {
      provider: "@:wallet.swap.create.info.provider",
      from: "@:wallet.swap.create.input.from.title",
      to: "@:wallet.swap.create.input.to.title",
      orderprice: "Order price",
      marketprice: "Market price",
      marketpriceinfo: "(incl fees & AMM)",
      price: "Price",
      transaction: "@.capitalize:common.label.transaction",
      action: "@.capitalize:common.label.action"
    },
    tx: {
      hover: "@:wallet.summary.button.copy.utxo.txhash.hover",
      notify: "@:wallet.summary.button.copy.utxo.txhash.notify"
    },
    cancel: {
      building: "@.capitalize:common.status.building"
    }
  },
  button: {
    swap: "Swap",
    cancelOrder: "Cancel Order",
    pool: "Pool (auto)",
    auto: "Auto Select"
  },
  error: {
    routesNotFound: "No swap routes found, please reload and try again.",
    tokenNotFound: "Token not found in wallet.",
    noPoolMatch: "No provider was found able to handle the requested amount to swap.",
    lowLiqudityInPool: "Selected pool doesn't have enough liquidity to handle the requested amount to swap.",
    constructSwapDatum: "Failed to create transaction datum, please try again or contact support if recurring.",
    cancelSwapTransaction: "Failed to create cancellation transaction, please try again or contact support if recurring.",
    cancelEternlWitness: "Failed to generate witness for Eternl fee return input.",
    unsupportedBatcher: "Unsupported currency for provider processing fee, only ADA supported at this time.",
    checkOpenOrders: "Failed to grab open orders from endpoint.",
    fetchDelay: "Please wait another ###time###s before refreshing.",
    network: "Endpoint not defined for network.",
    collateral: "No collateral found, please set a collateral before you continue, option available in wallet settings."
  }
};
const keystone = {
  label: "Sign with Keystone",
  catalyst: "Generate Keystone Catalyst Metadata",
  ok: "Keystone QR code successfully scanned.",
  keystone: {
    unlock: "Unlock your Keystone device.",
    scan: "Click on scan QR code button.",
    qrscan: "Scan QR code with your Keystone device.",
    next: "Sign on Keystone device and click 'Next' to scan with Eternl."
  },
  eternl: {
    distance: "Adjust distance and optionally tap on Keystone QR code to improve scanning.",
    density: "Use low density for animated QR code if needed."
  }
};
const onofframp = {
  headline: "Buy / Sell ADA",
  caption: "Select your gateway between FIAT and Cardano.",
  noprovider: "Unfortunately, there is currently no provider available.",
  loading: "Loading FIAT On / Off ramp providers"
};
const bex = {
  activateAccount: "Switch to the @:common.label.project browser extension and activate a dApp account!"
};
const signdata = {
  step: {
    confirm: {
      label: "Sign data",
      caption: "A website requested a signature for the below message. Please review the data before signing. Enter the wallet spending password to sign the data.",
      preview: {
        label: "Data preview",
        icon: "mdi mdi-information-outline",
        decoded: {
          label: "Json data preview"
        },
        table: {
          label: "Table data preview"
        }
      },
      info: {
        ledger: "@:wallet.send.step.confirm.info.ledger",
        trezor: "@:wallet.send.step.confirm.info.trezor",
        keystone: "@:wallet.send.step.confirm.info.keystone",
        readonly: "@:wallet.send.step.confirm.info.readonly"
      },
      button: {
        sign: "@:common.label.sign"
      }
    }
  }
};
const wallet = {
  accountSelection: accountSelection$1,
  add,
  create,
  chart,
  restore,
  pair,
  imports,
  importsOld,
  importkey,
  summary: summary$1,
  transactions,
  settings,
  receive,
  send,
  importTx,
  staking,
  delegation,
  deregistration,
  withdrawal,
  voting,
  qr,
  icon,
  syncInfo,
  background,
  stakingvault,
  swap,
  keystone,
  onofframp,
  bex,
  signdata,
  signtx: {
    headline: "Sign transaction:",
    error: {
      notx: {
        text: "No transaction found to sign :(\nPlease contact support if recurring.",
        icon: "mdi mdi-alert-octagon-outline"
      }
    }
  },
  message: {
    syncing: "Wallet is syncing"
  },
  error: {
    syncing: "The wallet is currently syncing, please wait until complete before continuing."
  },
  list: {
    choose: "Choose a wallet from the list or create a new one.",
    caption: "This list includes all your wallet addresses that are known to the blockchain."
  },
  manualsync: {
    label: "manual",
    info: "Manual-sync for this wallet has been enabled in wallet settings. To sync it click the sync icon "
  }
};
const accountSelection = {
  headline: "Connect DApp Account",
  caption: "Select an account that you want to connect to DApps, either using our built-in DApp browser or for external DApp connections (only in the browser extension).",
  selectedWallet: "current dapp wallet"
};
const browser = {
  headline: "@:menu.main.dappbrowser.label",
  caption: "Your gateway to Cardano DApps. We invite all NFT marketplaces, DEXes and other DApps to join the Eternl DApp Browser.",
  recentlyConnected: "Recently Connected",
  supportedDApps: "Supported DApps",
  promoted: {
    headline: "Promoted",
    caption: "A huge thank you to the Eternl supporters."
  },
  marketplace: {
    headline: "Marketplaces"
  },
  dex: {
    headline: "DEX"
  },
  favs: {
    nofavs: "You have no favorites set. Select some under DApps or Mints."
  },
  account: {
    label: "@:common.label.instructions",
    text: "Wait for all accounts to be loaded, then choose an account that should connect to a Cardano DApp. ",
    icon: "mdi mdi-alert-octagon-outline"
  },
  urlInput: {
    label: "@:common.label.instructions",
    text: "Enter a URL to a Cardano DApp, that supports the Eternl DApp Browser. ",
    icon: "mdi mdi-information-outline",
    hint: "Enter a URL",
    error: "This is not a valid URL."
  }
};
const enable = {
  access: {
    info: {
      icon: "mdi mdi-information-outline",
      text: "<b>Connection request by a DApp</b><br>Please confirm that this is the correct URL and that it is secure (HTTPS)."
    },
    url: {
      icon: "mdi mdi-web"
    },
    access: {
      url: "URL",
      label: "Features",
      icon: "mdi mdi-shield-check-outline"
    },
    cip30: {
      label: "DApp Connector",
      description: "Allows reading your balance and prompting to sign transactions. You'll be able to review a transaction before signing.",
      icon: "mdi mdi-connection"
    },
    cip95: {
      label: "Cardano Governance",
      description: "Allows reading your voting credential.",
      icon: "mdi mdi-vote-outline"
    },
    cip104: {
      label: "Account Public Key",
      description: "Allows export of account public key. Please note that this will allow DApp derive any address for connected account.",
      icon: "mdi mdi-key-outline"
    }
  }
};
const dappvoting = {
  key: {
    label: "Voting Key",
    caption: "Sign to allow derivation of voting key for active DApp account. Enter the wallet spending password or sign with the hardware device to confirm.",
    info: {
      ledger: "@:wallet.send.step.confirm.info.ledger",
      trezor: "@:wallet.send.step.confirm.info.trezor",
      readonly: "@:wallet.send.step.confirm.info.readonly"
    },
    loading: {
      ledger: "Please follow the directions in the Cardano app on your Ledger device to sign.",
      trezor: "Please follow the directions outlined in the opened Trezor Connect browser tab and on your Trezor device to sign."
    },
    ledger: {
      transport: {
        label: "@:common.ledger.transport.label",
        caption: "@:wallet.send.step.confirm.ledger.transport.caption"
      }
    },
    error: {
      general: "@:wallet.summary.accounts.confirm.error.general",
      password: "@:wallet.summary.accounts.confirm.error.password",
      nohw: "@:wallet.summary.accounts.confirm.error.nohw",
      nokey: "@:wallet.summary.accounts.confirm.error.nokey",
      mismatch: "@:wallet.summary.accounts.confirm.error.mismatch"
    },
    button: {
      back: "@:common.label.back",
      sign: "@:common.label.sign",
      reset: "@:common.label.reset",
      save: "@:common.label.sign"
    }
  },
  delegation: {
    headline: "Governance - Voting Delegation",
    caption: "Register your voting delegation on the Cardano blockchain.",
    step: {
      stepper: {
        tx: "Transaction",
        submit: "Submit"
      },
      tx: catalyst.step.tx,
      submit: send.step.submit
    },
    error: {
      sign: "Failed to properly sign voting delegation metadata"
    }
  }
};
const dapps = {
  menu: {
    favorites: "Favorites",
    mint: "Mints",
    nmkr: "NMKR",
    browser: "DApps",
    connect: "Connect Account"
  },
  accountSelection,
  browser,
  enable,
  voting: dappvoting
};
const directconnect = {
  tabs: {
    connect: "Connect",
    manage: "Manage connections"
  },
  connect: {
    identifier: {
      label: "CardanoConnect identifier",
      hint: "Paste connectionId"
    },
    status: {
      connected: "Connected",
      disconnected: "Not connected",
      error: "Connection error",
      unknownError: "Unknown error occurred.",
      invalidAddress: "The input does not seem to be a valid direct connect address.",
      noaccount: "Please select an account to use.",
      nowallets: "Please add a wallet to use cardano connect."
    },
    actions: {
      connect: "Wallet is disconnected. Click to connect to the DApp.",
      disconnect: "Wallet is connected. Click to disconnect from the DApp.",
      delete: "Delete connection",
      edit: "Change account"
    },
    label: {
      connect: "Connect",
      disconnect: "Disconnect",
      status: "Connection status:"
    },
    autoconnect: "auto-connect",
    badge: {
      autoconnect: "The wallet will try to auto connect to this DApp upon start.",
      connected: "The DApp is currently connected to the wallet.",
      disconnected: "The DApp is currently not connected to the wallet."
    },
    to: "Connected to",
    from: "Connection ID",
    labels: {
      info: "Connection information:",
      connectedTo: "Connected to:",
      name: "DApp name:",
      url: "DApp url:",
      address: "DApp connection id:",
      walletConnectionId: "Wallet connection id:",
      walletId: "Connected wallet",
      accountPubKey: "Connected account",
      active: "Active connection",
      autoConnect: "Auto-connect",
      created: "Created",
      lastActive: "Last used"
    },
    identicon: {
      image: "Identicon",
      description: "This image, called identicon, is created from the connection between your wallet and the DApp.\nThe image should be identical on both sites; please compare them to ensure your connection has not been compromised."
    },
    headline: "Connect dApp using CardanoConnect",
    caption: "You can connect to any dApp that is implementing the CIP-0045 cardano web connect protocol. \nTo do so please enter the address or scan the QR code that the dApp is showing.",
    select: {
      headline: "Select direct connect wallet"
    },
    button: {
      enable: {
        label: "Use for direct connect account"
      },
      disable: {
        label: "Selected direct connect account"
      }
    }
  }
};
const walletconnect = {
  tabs: {
    connect: "Connect",
    manage: "Manage connections"
  },
  connect: {
    identifier: {
      label: "Wallet connect identifier",
      hint: "Wallet connect string"
    },
    status: {
      connected: "Connected",
      disconnected: "Not connected",
      error: "Connection error",
      unknownError: "Unknown error occurred.",
      invalidAddress: "The input does not seem to be a valid wallet connect address.",
      noaccount: "Please select an account to use."
    },
    actions: {
      connect: "Wallet is disconnected. Click to connect to the DApp.",
      disconnect: "Wallet is connected. Click to disconnect from the DApp.",
      delete: "Delete connection",
      edit: "Change account"
    },
    label: {
      connect: "Connect",
      disconnect: "Disconnect",
      status: "Connection status:",
      error: "Connection error:"
    },
    autoconnect: "auto-connect",
    badge: {
      autoconnect: "The wallet will try to auto connect to this DApp upon start.",
      connected: "The DApp is currently connected to the wallet.",
      disconnected: "The DApp is currently not connected to the wallet."
    },
    to: "Connected to",
    from: "Connection ID",
    labels: {
      info: "Connection information:",
      connectedTo: "Connected to:",
      name: "DApp name:",
      url: "DApp url:",
      address: "DApp connection id:",
      walletConnectionId: "Wallet connection id:",
      walletId: "Connected wallet",
      accountPubKey: "Connected account",
      active: "Active connection",
      autoConnect: "Auto-connect",
      created: "Created",
      lastActive: "Last used",
      expire: "Expires at:"
    },
    modal: {
      headline: "Approve session proposal",
      info: "A DApp is requesting access using the WalletConnect API.\nPlease check the requested session and confirm it.",
      name: "DApp Name",
      url: "DApp URL",
      request: "The DApp is requesting access to the following wallet API endpoints.",
      topic: "Pairing ID",
      namespace: "DApp Namespace",
      networkName: "Network",
      methods: "Methods",
      events: "Events",
      wallet: "Wallet",
      account: "Account",
      networkWarning: {
        label: "Wrong Network",
        info: "It looks like you are trying to connect to a DApp on a different network. Please change the network and try again."
      }
    },
    headline: "Connect dApp using WalletConnect",
    caption: "You can connect to any dApp that offers a WalletConnect feature on Cardano. \nTo do so please enter the address or scan the QR code that the dApp is showing.",
    select: {
      headline: "Select WalletConnect wallet"
    },
    button: {
      enable: {
        label: "Use for WalletConnect account"
      },
      disable: {
        label: "Selected WalletConnect account"
      }
    }
  }
};
const moving = {
  headline: "We moved!",
  caption: "ccvault.io is now <i>eternl.io</i>!",
  button: {
    label: "eternl.io"
  }
};
const enUS = {
  common,
  form,
  setting,
  header,
  footer,
  menu,
  imprint,
  banner,
  landingpage,
  announcements,
  faq: faq$1,
  preferences,
  wallet,
  dapps,
  directconnect,
  walletconnect,
  moving,
  error404
};
const messages = {
  "en-US": enUS
};
setAppMode(AppMode.enable);
const app = createApp(_sfc_main);
const i18n = createI18n({
  locale: "en-US",
  // getAppLanguage() ??
  legacy: false,
  messages
});
app.use(i18n);
app.mount("#q-app");
