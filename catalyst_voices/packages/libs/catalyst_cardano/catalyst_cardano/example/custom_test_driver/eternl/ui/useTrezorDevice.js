import { dG as es, dq as Buffer$1, dv as process$1, ds as getDefaultExportFromCjs, dw as commonjsGlobal, j1 as getLedgerTransport, eE as el, eF as sl, j2 as getHardenedDerivationPath, dc as purpose, j3 as coin, j4 as getPubKeyFromHex, j5 as getNetworkMagic, bF as getAccountKeyDetails, bz as toHexArray, b3 as toHexString, b0 as safeFreeCSLObject, aZ as ErrorSignTx, aY as checkEpochParams, ba as TransactionWitnessSet, b7 as Vkeywitnesses, j6 as hasWitness, a$ as isCatalystVotingRegistrationMetadata, j7 as getCatalystRegistrationMetadata, bb as addCatalystRegistrationSignature, bc as generateCatalystRegistration, bd as hash_auxiliary_data, gk as cslToJson, b1 as FixedTransaction, b2 as hash_transaction, b4 as Transaction, b5 as getTransactionJSONFromCSL, b6 as reinjectWitnessSet, j8 as getFilteredUtxoList, j9 as harden, ja as createPubKey, jb as getVkeyWitness, eJ as getOwnedCred, gF as isSameArray, eI as getAddressCredentials, i9 as getPlutusHVB, jc as isScriptStakeAddress, eP as CertificateTypes, id as CertificateKind, dm as getRewardAddressFromCred, jd as BigNum, je as decode_metadatum_to_json_str, gg as MetadataJsonSchema, jf as Address, jg as blake2b256Str, jh as toBufferFromArray, dp as eventsExports, ji as bignumberExports, dn as getAugmentedNamespace, jj as getStringDerivationPath } from "./index.js";
import { a as __values, b as __spreadArray, c as __read, d as __extends, e as __asyncGenerator, f as __generator, g as __await, h as __awaiter$6, i as __asyncValues, j as src, k as createSignDataBuilder, l as createCOSEKeyHex, r as require$$0 } from "./Keystone.vue_vue_type_script_setup_true_lang.js";
import { i as isTestnetNetwork } from "./NetworkId.js";
const errorClasses = {};
const deserializers = {};
const addCustomErrorDeserializer = (name, deserializer) => {
  deserializers[name] = deserializer;
};
const createCustomErrorClass = (name) => {
  class CustomErrorClass extends Error {
    constructor(message2, fields, options) {
      super(message2 || name, options);
      Object.setPrototypeOf(this, CustomErrorClass.prototype);
      this.name = name;
      if (fields) {
        for (const k in fields) {
          this[k] = fields[k];
        }
      }
      if (options && isObject(options) && "cause" in options && !("cause" in this)) {
        const cause = options.cause;
        this.cause = cause;
        if ("stack" in cause) {
          this.stack = this.stack + "\nCAUSE: " + cause.stack;
        }
      }
    }
  }
  errorClasses[name] = CustomErrorClass;
  return CustomErrorClass;
};
function isObject(value) {
  return typeof value === "object";
}
createCustomErrorClass("AccountNameRequired");
createCustomErrorClass("AccountNotSupported");
createCustomErrorClass("AccountAwaitingSendPendingOperations");
createCustomErrorClass("AmountRequired");
createCustomErrorClass("BluetoothRequired");
createCustomErrorClass("BtcUnmatchedApp");
createCustomErrorClass("CantOpenDevice");
createCustomErrorClass("CashAddrNotSupported");
createCustomErrorClass("ClaimRewardsFeesWarning");
createCustomErrorClass("CurrencyNotSupported");
createCustomErrorClass("DeviceAppVerifyNotSupported");
createCustomErrorClass("DeviceGenuineSocketEarlyClose");
createCustomErrorClass("DeviceNotGenuine");
createCustomErrorClass("DeviceOnDashboardExpected");
createCustomErrorClass("DeviceOnDashboardUnexpected");
createCustomErrorClass("DeviceInOSUExpected");
createCustomErrorClass("DeviceHalted");
createCustomErrorClass("DeviceNameInvalid");
createCustomErrorClass("DeviceSocketFail");
createCustomErrorClass("DeviceSocketNoBulkStatus");
createCustomErrorClass("DeviceSocketNoBulkStatus");
createCustomErrorClass("UnresponsiveDeviceError");
const DisconnectedDevice = createCustomErrorClass("DisconnectedDevice");
const DisconnectedDeviceDuringOperation = createCustomErrorClass("DisconnectedDeviceDuringOperation");
createCustomErrorClass("DeviceExtractOnboardingStateError");
createCustomErrorClass("DeviceOnboardingStatePollingError");
createCustomErrorClass("EnpointConfig");
createCustomErrorClass("EthAppPleaseEnableContractData");
createCustomErrorClass("FeeEstimationFailed");
createCustomErrorClass("FirmwareNotRecognized");
createCustomErrorClass("HardResetFail");
createCustomErrorClass("InvalidXRPTag");
createCustomErrorClass("InvalidAddress");
createCustomErrorClass("InvalidNonce");
createCustomErrorClass("InvalidAddressBecauseDestinationIsAlsoSource");
createCustomErrorClass("LatestMCUInstalledError");
createCustomErrorClass("UnknownMCU");
createCustomErrorClass("LedgerAPIError");
createCustomErrorClass("LedgerAPIErrorWithMessage");
createCustomErrorClass("LedgerAPINotAvailable");
createCustomErrorClass("ManagerAppAlreadyInstalled");
createCustomErrorClass("ManagerAppRelyOnBTC");
createCustomErrorClass("ManagerAppDepInstallRequired");
createCustomErrorClass("ManagerAppDepUninstallRequired");
createCustomErrorClass("ManagerDeviceLocked");
createCustomErrorClass("ManagerFirmwareNotEnoughSpace");
createCustomErrorClass("ManagerNotEnoughSpace");
createCustomErrorClass("ManagerUninstallBTCDep");
createCustomErrorClass("NetworkDown");
createCustomErrorClass("NetworkError");
createCustomErrorClass("NoAddressesFound");
createCustomErrorClass("NotEnoughBalance");
createCustomErrorClass("NotEnoughBalanceSwap");
createCustomErrorClass("NotEnoughBalanceToDelegate");
createCustomErrorClass("NotEnoughBalanceInParentAccount");
createCustomErrorClass("NotEnoughSpendableBalance");
createCustomErrorClass("NotEnoughBalanceBecauseDestinationNotCreated");
createCustomErrorClass("NoAccessToCamera");
createCustomErrorClass("NotEnoughGas");
createCustomErrorClass("NotEnoughGasSwap");
createCustomErrorClass("TronEmptyAccount");
createCustomErrorClass("MaybeKeepTronAccountAlive");
createCustomErrorClass("NotSupportedLegacyAddress");
createCustomErrorClass("GasLessThanEstimate");
createCustomErrorClass("PriorityFeeTooLow");
createCustomErrorClass("PriorityFeeTooHigh");
createCustomErrorClass("PriorityFeeHigherThanMaxFee");
createCustomErrorClass("MaxFeeTooLow");
createCustomErrorClass("PasswordsDontMatch");
createCustomErrorClass("PasswordIncorrect");
createCustomErrorClass("RecommendSubAccountsToEmpty");
createCustomErrorClass("RecommendUndelegation");
createCustomErrorClass("TimeoutTagged");
createCustomErrorClass("UnexpectedBootloader");
createCustomErrorClass("MCUNotGenuineToDashboard");
createCustomErrorClass("RecipientRequired");
createCustomErrorClass("UnavailableTezosOriginatedAccountReceive");
createCustomErrorClass("UnavailableTezosOriginatedAccountSend");
createCustomErrorClass("UpdateFetchFileFail");
createCustomErrorClass("UpdateIncorrectHash");
createCustomErrorClass("UpdateIncorrectSig");
createCustomErrorClass("UpdateYourApp");
createCustomErrorClass("UserRefusedDeviceNameChange");
createCustomErrorClass("UserRefusedAddress");
createCustomErrorClass("UserRefusedFirmwareUpdate");
createCustomErrorClass("UserRefusedAllowManager");
createCustomErrorClass("UserRefusedOnDevice");
createCustomErrorClass("PinNotSet");
createCustomErrorClass("ExpertModeRequired");
const TransportOpenUserCancelled = createCustomErrorClass("TransportOpenUserCancelled");
const TransportInterfaceNotAvailable = createCustomErrorClass("TransportInterfaceNotAvailable");
const TransportRaceCondition = createCustomErrorClass("TransportRaceCondition");
const TransportWebUSBGestureRequired = createCustomErrorClass("TransportWebUSBGestureRequired");
createCustomErrorClass("TransactionHasBeenValidatedError");
createCustomErrorClass("TransportExchangeTimeoutError");
createCustomErrorClass("DeviceShouldStayInApp");
createCustomErrorClass("WebsocketConnectionError");
createCustomErrorClass("WebsocketConnectionFailed");
createCustomErrorClass("WrongDeviceForAccount");
createCustomErrorClass("WrongDeviceForAccountPayout");
createCustomErrorClass("WrongDeviceForAccountRefund");
createCustomErrorClass("WrongAppForCurrency");
createCustomErrorClass("ETHAddressNonEIP");
createCustomErrorClass("CantScanQRCode");
createCustomErrorClass("FeeNotLoaded");
createCustomErrorClass("FeeNotLoadedSwap");
createCustomErrorClass("FeeRequired");
createCustomErrorClass("FeeTooHigh");
createCustomErrorClass("PendingOperation");
createCustomErrorClass("SyncError");
createCustomErrorClass("PairingFailed");
createCustomErrorClass("PeerRemovedPairing");
createCustomErrorClass("GenuineCheckFailed");
createCustomErrorClass("LedgerAPI4xx");
createCustomErrorClass("LedgerAPI5xx");
createCustomErrorClass("FirmwareOrAppUpdateRequired");
createCustomErrorClass("ReplacementTransactionUnderpriced");
createCustomErrorClass("OpReturnSizeLimit");
createCustomErrorClass("DustLimit");
createCustomErrorClass("LanguageNotFound");
createCustomErrorClass("NoDBPathGiven");
createCustomErrorClass("DBWrongPassword");
createCustomErrorClass("DBNotReset");
createCustomErrorClass("SequenceNumberError");
createCustomErrorClass("DisabledTransactionBroadcastError");
var HwTransportErrorType;
(function(HwTransportErrorType2) {
  HwTransportErrorType2["Unknown"] = "Unknown";
  HwTransportErrorType2["LocationServicesDisabled"] = "LocationServicesDisabled";
  HwTransportErrorType2["LocationServicesUnauthorized"] = "LocationServicesUnauthorized";
  HwTransportErrorType2["BluetoothScanStartFailed"] = "BluetoothScanStartFailed";
})(HwTransportErrorType || (HwTransportErrorType = {}));
class TransportError extends Error {
  constructor(message2, id2) {
    const name = "TransportError";
    super(message2 || name);
    this.name = name;
    this.message = message2;
    this.stack = new Error(message2).stack;
    this.id = id2;
  }
}
addCustomErrorDeserializer("TransportError", (e) => new TransportError(e.message, e.id));
const StatusCodes = {
  ACCESS_CONDITION_NOT_FULFILLED: 38916,
  ALGORITHM_NOT_SUPPORTED: 38020,
  CLA_NOT_SUPPORTED: 28160,
  CODE_BLOCKED: 38976,
  CODE_NOT_INITIALIZED: 38914,
  COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
  CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
  CONTRADICTION_INVALIDATION: 38928,
  CONTRADICTION_SECRET_CODE_STATUS: 38920,
  DEVICE_IN_RECOVERY_MODE: 26159,
  CUSTOM_IMAGE_EMPTY: 26158,
  FILE_ALREADY_EXISTS: 27273,
  FILE_NOT_FOUND: 37892,
  GP_AUTH_FAILED: 25344,
  HALTED: 28586,
  INCONSISTENT_FILE: 37896,
  INCORRECT_DATA: 27264,
  INCORRECT_LENGTH: 26368,
  INCORRECT_P1_P2: 27392,
  INS_NOT_SUPPORTED: 27904,
  DEVICE_NOT_ONBOARDED: 27911,
  DEVICE_NOT_ONBOARDED_2: 26129,
  INVALID_KCV: 38021,
  INVALID_OFFSET: 37890,
  LICENSING: 28482,
  LOCKED_DEVICE: 21781,
  MAX_VALUE_REACHED: 38992,
  MEMORY_PROBLEM: 37440,
  MISSING_CRITICAL_PARAMETER: 26624,
  NO_EF_SELECTED: 37888,
  NOT_ENOUGH_MEMORY_SPACE: 27268,
  OK: 36864,
  PIN_REMAINING_ATTEMPTS: 25536,
  REFERENCED_DATA_NOT_FOUND: 27272,
  SECURITY_STATUS_NOT_SATISFIED: 27010,
  TECHNICAL_PROBLEM: 28416,
  UNKNOWN_APDU: 27906,
  USER_REFUSED_ON_DEVICE: 21761,
  NOT_ENOUGH_SPACE: 20738,
  APP_NOT_FOUND_OR_INVALID_CONTEXT: 20771,
  INVALID_APP_NAME_LENGTH: 26378,
  GEN_AES_KEY_FAILED: 21529,
  INTERNAL_CRYPTO_OPERATION_FAILED: 21530,
  INTERNAL_COMPUTE_AES_CMAC_FAILED: 21531,
  ENCRYPT_APP_STORAGE_FAILED: 21532,
  INVALID_BACKUP_STATE: 26178,
  PIN_NOT_SET: 21762,
  INVALID_BACKUP_LENGTH: 26419,
  INVALID_RESTORE_STATE: 26179,
  INVALID_CHUNK_LENGTH: 26420,
  INVALID_BACKUP_HEADER: 26698,
  // Not documented:
  TRUSTCHAIN_WRONG_SEED: 45063
};
function getAltStatusMessage(code) {
  switch (code) {
    case 26368:
      return "Incorrect length";
    case 26624:
      return "Missing critical parameter";
    case 27010:
      return "Security not satisfied (dongle locked or have invalid access rights)";
    case 27013:
      return "Condition of use not satisfied (denied by the user?)";
    case 27264:
      return "Invalid data received";
    case 27392:
      return "Invalid parameter received";
    case 21781:
      return "Locked device";
  }
  if (28416 <= code && code <= 28671) {
    return "Internal error, please report";
  }
}
class TransportStatusError extends Error {
  /**
   * @param statusCode The error status code coming from a Transport implementation
   * @param options containing:
   *  - canBeMappedToChildError: enable the mapping of TransportStatusError to an error extending/inheriting from it
   *  . Ex: LockedDeviceError. Default to true.
   */
  constructor(statusCode, { canBeMappedToChildError = true } = {}) {
    const statusText = Object.keys(StatusCodes).find((k) => StatusCodes[k] === statusCode) || "UNKNOWN_ERROR";
    const smsg = getAltStatusMessage(statusCode) || statusText;
    const statusCodeStr = statusCode.toString(16);
    const message2 = `Ledger device: ${smsg} (0x${statusCodeStr})`;
    super(message2);
    this.name = "TransportStatusError";
    this.statusCode = statusCode;
    this.statusText = statusText;
    Object.setPrototypeOf(this, TransportStatusError.prototype);
    if (canBeMappedToChildError && statusCode === StatusCodes.LOCKED_DEVICE) {
      return new LockedDeviceError(message2);
    }
  }
}
class LockedDeviceError extends TransportStatusError {
  constructor(message2) {
    super(StatusCodes.LOCKED_DEVICE, { canBeMappedToChildError: false });
    if (message2) {
      this.message = message2;
    }
    this.name = "LockedDeviceError";
    Object.setPrototypeOf(this, LockedDeviceError.prototype);
  }
}
addCustomErrorDeserializer("TransportStatusError", (e) => new TransportStatusError(e.statusCode));
let id = 0;
const subscribers = [];
const log = (type2, message2, data) => {
  const obj = {
    type: type2,
    id: String(++id),
    date: /* @__PURE__ */ new Date()
  };
  if (message2)
    obj.message = message2;
  dispatch(obj);
};
const trace = ({ type: type2, message: message2, data, context }) => {
  const obj = {
    type: type2,
    id: String(++id),
    date: /* @__PURE__ */ new Date()
  };
  if (message2)
    obj.message = message2;
  if (data)
    obj.data = data;
  if (context)
    obj.context = context;
  dispatch(obj);
};
class LocalTracer {
  constructor(type2, context) {
    this.type = type2;
    this.context = context;
  }
  trace(message2, data) {
    trace({
      type: this.type,
      message: message2,
      data,
      context: this.context
    });
  }
  getContext() {
    return this.context;
  }
  setContext(context) {
    this.context = context;
  }
  updateContext(contextToAdd) {
    this.context = Object.assign(Object.assign({}, this.context), contextToAdd);
  }
  getType() {
    return this.type;
  }
  setType(type2) {
    this.type = type2;
  }
  /**
   * Create a new instance of the LocalTracer with an updated `type`
   *
   * It does not mutate the calling instance, but returns a new LocalTracer,
   * following a simple builder pattern.
   */
  withType(type2) {
    return new LocalTracer(type2, this.context);
  }
  /**
   * Create a new instance of the LocalTracer with a new `context`
   *
   * It does not mutate the calling instance, but returns a new LocalTracer,
   * following a simple builder pattern.
   *
   * @param context A TraceContext, that can undefined to reset the context
   */
  withContext(context) {
    return new LocalTracer(this.type, context);
  }
  /**
   * Create a new instance of the LocalTracer with an updated `context`,
   * on which an additional context is merged with the existing one.
   *
   * It does not mutate the calling instance, but returns a new LocalTracer,
   * following a simple builder pattern.
   */
  withUpdatedContext(contextToAdd) {
    return new LocalTracer(this.type, Object.assign(Object.assign({}, this.context), contextToAdd));
  }
}
const listen = (cb) => {
  subscribers.push(cb);
  return () => {
    const i = subscribers.indexOf(cb);
    if (i !== -1) {
      subscribers[i] = subscribers[subscribers.length - 1];
      subscribers.pop();
    }
  };
};
function dispatch(log2) {
  for (let i = 0; i < subscribers.length; i++) {
    try {
      subscribers[i](log2);
    } catch (e) {
      console.error(e);
    }
  }
}
if (typeof window !== "undefined") {
  window.__ledgerLogsListen = listen;
}
var __awaiter$5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const DEFAULT_LOG_TYPE = "transport";
class Transport {
  constructor({ context, logType } = {}) {
    this.exchangeTimeout = 3e4;
    this.unresponsiveTimeout = 15e3;
    this.deviceModel = null;
    this._events = new es();
    this.send = (cla_1, ins_1, p1_1, p2_1, ...args_1) => __awaiter$5(this, [cla_1, ins_1, p1_1, p2_1, ...args_1], void 0, function* (cla, ins, p1, p2, data = Buffer$1.alloc(0), statusList = [StatusCodes.OK], { abortTimeoutMs } = {}) {
      const tracer = this.tracer.withUpdatedContext({ function: "send" });
      if (data.length >= 256) {
        tracer.trace("data.length exceeded 256 bytes limit", { dataLength: data.length });
        throw new TransportError("data.length exceed 256 bytes limit. Got: " + data.length, "DataLengthTooBig");
      }
      tracer.trace("Starting an exchange", { abortTimeoutMs });
      const response = yield this.exchange(
        // The size of the data is added in 1 byte just before `data`
        Buffer$1.concat([Buffer$1.from([cla, ins, p1, p2]), Buffer$1.from([data.length]), data]),
        { abortTimeoutMs }
      );
      tracer.trace("Received response from exchange");
      const sw = response.readUInt16BE(response.length - 2);
      if (!statusList.some((s) => s === sw)) {
        throw new TransportStatusError(sw);
      }
      return response;
    });
    this._appAPIlock = null;
    this.tracer = new LocalTracer(logType !== null && logType !== void 0 ? logType : DEFAULT_LOG_TYPE, context);
  }
  /**
   * Send data to the device using a low level API.
   * It's recommended to use the "send" method for a higher level API.
   * @param {Buffer} apdu - The data to send.
   * @param {Object} options - Contains optional options for the exchange function
   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists
   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.
   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
   */
  exchange(_apdu, { abortTimeoutMs: _abortTimeoutMs } = {}) {
    throw new Error("exchange not implemented");
  }
  /**
   * Send apdus in batch to the device using a low level API.
   * The default implementation is to call exchange for each apdu.
   * @param {Array<Buffer>} apdus - array of apdus to send.
   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.
   * @returns {Subscription} A Subscription object on which you can call ".unsubscribe()" to stop sending apdus.
   */
  exchangeBulk(apdus, observer) {
    let unsubscribed = false;
    const unsubscribe = () => {
      unsubscribed = true;
    };
    const main = () => __awaiter$5(this, void 0, void 0, function* () {
      if (unsubscribed)
        return;
      for (const apdu of apdus) {
        const r = yield this.exchange(apdu);
        if (unsubscribed)
          return;
        const status = r.readUInt16BE(r.length - 2);
        if (status !== StatusCodes.OK) {
          throw new TransportStatusError(status);
        }
        observer.next(r);
      }
    });
    main().then(() => !unsubscribed && observer.complete(), (e) => !unsubscribed && observer.error(e));
    return { unsubscribe };
  }
  /**
   * Set the "scramble key" for the next data exchanges with the device.
   * Each app can have a different scramble key and it is set internally during instantiation.
   * @param {string} key - The scramble key to set.
   * deprecated This method is no longer needed for modern transports and should be migrated away from.
   * no @ before deprecated as it breaks documentationjs on version 14.0.2
   * https://github.com/documentationjs/documentation/issues/1596
   */
  setScrambleKey(_key) {
  }
  /**
   * Close the connection with the device.
   *
   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,
   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.
   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.
   *
   * @returns {Promise<void>} A promise that resolves when the transport is closed.
   */
  close() {
    return Promise.resolve();
  }
  /**
   * Listen for an event on the transport instance.
   * Transport implementations may have specific events. Common events include:
   * "disconnect" : triggered when the transport is disconnected.
   * @param {string} eventName - The name of the event to listen for.
   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.
   */
  on(eventName, cb) {
    this._events.on(eventName, cb);
  }
  /**
   * Stop listening to an event on an instance of transport.
   */
  off(eventName, cb) {
    this._events.removeListener(eventName, cb);
  }
  emit(event, ...args) {
    this._events.emit(event, ...args);
  }
  /**
   * Enable or not logs of the binary exchange
   */
  setDebugMode() {
    console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
  }
  /**
   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
   */
  setExchangeTimeout(exchangeTimeout) {
    this.exchangeTimeout = exchangeTimeout;
  }
  /**
   * Define the delay before emitting "unresponsive" on an exchange that does not respond
   */
  setExchangeUnresponsiveTimeout(unresponsiveTimeout) {
    this.unresponsiveTimeout = unresponsiveTimeout;
  }
  /**
   * create() allows to open the first descriptor available or
   * throw if there is none or if timeout is reached.
   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
   * @example
  TransportFoo.create().then(transport => ...)
   */
  static create(openTimeout = 3e3, listenTimeout) {
    return new Promise((resolve, reject) => {
      let found = false;
      const sub = this.listen({
        next: (e) => {
          found = true;
          if (sub)
            sub.unsubscribe();
          if (listenTimeoutId)
            clearTimeout(listenTimeoutId);
          this.open(e.descriptor, openTimeout).then(resolve, reject);
        },
        error: (e) => {
          if (listenTimeoutId)
            clearTimeout(listenTimeoutId);
          reject(e);
        },
        complete: () => {
          if (listenTimeoutId)
            clearTimeout(listenTimeoutId);
          if (!found) {
            reject(new TransportError(this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
          }
        }
      });
      const listenTimeoutId = listenTimeout ? setTimeout(() => {
        sub.unsubscribe();
        reject(new TransportError(this.ErrorMessage_ListenTimeout, "ListenTimeout"));
      }, listenTimeout) : null;
    });
  }
  /**
   * Wrapper to make an exchange "atomic" (blocking any other exchange)
   *
   * It also handles "unresponsiveness" by emitting "unresponsive" and "responsive" events.
   *
   * @param f The exchange job, using the transport to run
   * @returns a Promise resolving with the output of the given job
   */
  exchangeAtomicImpl(f) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const tracer = this.tracer.withUpdatedContext({
        function: "exchangeAtomicImpl",
        unresponsiveTimeout: this.unresponsiveTimeout
      });
      if (this.exchangeBusyPromise) {
        tracer.trace("Atomic exchange is already busy");
        throw new TransportRaceCondition("An action was already pending on the Ledger device. Please deny or reconnect.");
      }
      let resolveBusy;
      const busyPromise = new Promise((r) => {
        resolveBusy = r;
      });
      this.exchangeBusyPromise = busyPromise;
      let unresponsiveReached = false;
      const timeout = setTimeout(() => {
        tracer.trace(`Timeout reached, emitting Transport event "unresponsive"`, {
          unresponsiveTimeout: this.unresponsiveTimeout
        });
        unresponsiveReached = true;
        this.emit("unresponsive");
      }, this.unresponsiveTimeout);
      try {
        const res = yield f();
        if (unresponsiveReached) {
          tracer.trace("Device was unresponsive, emitting responsive");
          this.emit("responsive");
        }
        return res;
      } finally {
        tracer.trace("Finalize, clearing busy guard");
        clearTimeout(timeout);
        if (resolveBusy)
          resolveBusy();
        this.exchangeBusyPromise = null;
      }
    });
  }
  decorateAppAPIMethods(self2, methods2, scrambleKey) {
    for (const methodName of methods2) {
      self2[methodName] = this.decorateAppAPIMethod(methodName, self2[methodName], self2, scrambleKey);
    }
  }
  decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {
    return (...args) => __awaiter$5(this, void 0, void 0, function* () {
      const { _appAPIlock } = this;
      if (_appAPIlock) {
        return Promise.reject(new TransportError("Ledger Device is busy (lock " + _appAPIlock + ")", "TransportLocked"));
      }
      try {
        this._appAPIlock = methodName;
        this.setScrambleKey(scrambleKey);
        return yield f.apply(ctx, args);
      } finally {
        this._appAPIlock = null;
      }
    });
  }
  /**
   * Sets the context used by the logging/tracing mechanism
   *
   * Useful when re-using (cached) the same Transport instance,
   * but with a new tracing context.
   *
   * @param context A TraceContext, that can undefined to reset the context
   */
  setTraceContext(context) {
    this.tracer = this.tracer.withContext(context);
  }
  /**
   * Updates the context used by the logging/tracing mechanism
   *
   * The update only overrides the key-value that are already defined in the current context.
   *
   * @param contextToAdd A TraceContext that will be added to the current context
   */
  updateTraceContext(contextToAdd) {
    this.tracer.updateContext(contextToAdd);
  }
  /**
   * Gets the tracing context of the transport instance
   */
  getTraceContext() {
    return this.tracer.getContext();
  }
}
Transport.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
Transport.ErrorMessage_NoDeviceFound = "No Ledger device found";
const Tag = 5;
function asUInt16BE(value) {
  const b = Buffer$1.alloc(2);
  b.writeUInt16BE(value, 0);
  return b;
}
const initialAcc = {
  data: Buffer$1.alloc(0),
  dataLength: 0,
  sequence: 0
};
const createHIDframing = (channel, packetSize) => {
  return {
    /**
     * Frames/encodes an APDU message into HID USB packets/frames
     *
     * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]
     * @returns an array of HID USB frames ready to be sent
     */
    makeBlocks(apdu) {
      let data = Buffer$1.concat([asUInt16BE(apdu.length), apdu]);
      const blockSize = packetSize - 5;
      const nbBlocks = Math.ceil(data.length / blockSize);
      data = Buffer$1.concat([data, Buffer$1.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);
      const blocks = [];
      for (let i = 0; i < nbBlocks; i++) {
        const head = Buffer$1.alloc(5);
        head.writeUInt16BE(channel, 0);
        head.writeUInt8(Tag, 2);
        head.writeUInt16BE(i, 3);
        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);
        blocks.push(Buffer$1.concat([head, chunk]));
      }
      return blocks;
    },
    /**
     * Reduces HID USB packets/frames to one response.
     *
     * @param acc The value resulting from (accumulating) the previous call of reduceResponse.
     *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.
     * @param chunk Current chunk to reduce into accumulator
     * @returns An accumulator value updated with the current chunk
     */
    reduceResponse(acc, chunk) {
      let { data, dataLength, sequence } = acc || initialAcc;
      if (chunk.readUInt16BE(0) !== channel) {
        throw new TransportError("Invalid channel", "InvalidChannel");
      }
      if (chunk.readUInt8(2) !== Tag) {
        throw new TransportError("Invalid tag", "InvalidTag");
      }
      if (chunk.readUInt16BE(3) !== sequence) {
        throw new TransportError("Invalid sequence", "InvalidSequence");
      }
      if (!acc) {
        dataLength = chunk.readUInt16BE(5);
      }
      sequence++;
      const chunkData = chunk.slice(acc ? 5 : 7);
      data = Buffer$1.concat([data, chunkData]);
      if (data.length > dataLength) {
        data = data.slice(0, dataLength);
      }
      return {
        data,
        dataLength,
        sequence
      };
    },
    /**
     * Returns the response message that has been reduced from the HID USB frames
     *
     * @param acc The accumulator
     * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the
     *   accumulator is incorrect (message length is not valid)
     */
    getReducedResult(acc) {
      if (acc && acc.dataLength === acc.data.length) {
        return acc.data;
      }
    }
  };
};
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$4 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
var define_process_env_default = {};
const debug$2 = typeof process$1 === "object" && define_process_env_default && define_process_env_default.NODE_DEBUG && /\bsemver\b/i.test(define_process_env_default.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1$2 = debug$2;
(function(module, exports2) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$4;
  const debug2 = debug_1$2;
  exports2 = module.exports = {};
  const re2 = exports2.re = [];
  const safeRe = exports2.safeRe = [];
  const src2 = exports2.src = [];
  const t2 = exports2.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t2[name] = index;
    src2[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src2[t2.NUMERICIDENTIFIER]}|${src2[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t2.NUMERICIDENTIFIERLOOSE]}|${src2[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src2[t2.PRERELEASEIDENTIFIER]}(?:\\.${src2[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src2[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src2[t2.BUILDIDENTIFIER]}(?:\\.${src2[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src2[t2.MAINVERSION]}${src2[t2.PRERELEASE]}?${src2[t2.BUILD]}?`);
  createToken("FULL", `^${src2[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src2[t2.MAINVERSIONLOOSE]}${src2[t2.PRERELEASELOOSE]}?${src2[t2.BUILD]}?`);
  createToken("LOOSE", `^${src2[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src2[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src2[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:${src2[t2.PRERELEASE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:${src2[t2.PRERELEASELOOSE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src2[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src2[t2.COERCEPLAIN] + `(?:${src2[t2.PRERELEASE]})?(?:${src2[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src2[t2.COERCE], true);
  createToken("COERCERTLFULL", src2[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src2[t2.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src2[t2.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src2[t2.GTLT]}\\s*(${src2[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]}|${src2[t2.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src2[t2.XRANGEPLAIN]})\\s+-\\s+(${src2[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug$1 = debug_1$2;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$4;
const { safeRe: re$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer2 {
  constructor(version2, options) {
    options = parseOptions(options);
    if (version2 instanceof SemVer2) {
      if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug$1("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version2.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$1("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer2)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer2(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug$1("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug$1("build compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$2 = SemVer$d;
const SemVer$c = semver$2;
const parse$7 = (version2, options, throwErrors = false) => {
  if (version2 instanceof SemVer$c) {
    return version2;
  }
  try {
    return new SemVer$c(version2, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1$e = parse$7;
const parse$6 = parse_1$e;
const valid$2 = (version2, options) => {
  const v = parse$6(version2, options);
  return v ? v.version : null;
};
var valid_1 = valid$2;
const parse$5 = parse_1$e;
const clean$1 = (version2, options) => {
  const s = parse$5(version2.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$2;
const inc$1 = (version2, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version2 instanceof SemVer$b ? version2.version : version2,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$4 = parse_1$e;
const diff$1 = (version1, version2) => {
  const v1 = parse$4(version1, null, true);
  const v2 = parse$4(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (highVersion.patch) {
      return "patch";
    }
    if (highVersion.minor) {
      return "minor";
    }
    return "major";
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$2;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$2;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$2;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;
const parse$3 = parse_1$e;
const prerelease$1 = (version2, options) => {
  const parsed = parse$3(version2, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$2;
const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$2;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$1(a, b, loose);
    case "!=":
      return neq$1(a, b, loose);
    case ">":
      return gt$3(a, b, loose);
    case ">=":
      return gte$2(a, b, loose);
    case "<":
      return lt$2(a, b, loose);
    case "<=":
      return lte$2(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$2;
const parse$2 = parse_1$e;
const { safeRe: re, t } = reExports;
const coerce$1 = (version2, options) => {
  if (version2 instanceof SemVer$5) {
    return version2;
  }
  if (typeof version2 === "number") {
    version2 = String(version2);
  }
  if (typeof version2 !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  const major2 = match[2];
  const minor2 = match[3] || "0";
  const patch2 = match[4] || "0";
  const prerelease2 = options.includePrerelease && match[5] ? `-${match[5]}` : "";
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
  return parse$2(`${major2}.${minor2}.${patch2}${prerelease2}${build}`, options);
};
var coerce_1 = coerce$1;
class LRUCache {
  constructor() {
    this.max = 1e3;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    const value = this.map.get(key);
    if (value === void 0) {
      return void 0;
    } else {
      this.map.delete(key);
      this.map.set(key, value);
      return value;
    }
  }
  delete(key) {
    return this.map.delete(key);
  }
  set(key, value) {
    const deleted = this.delete(key);
    if (!deleted && value !== void 0) {
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value;
        this.delete(firstKey);
      }
      this.map.set(key, value);
    }
    return this;
  }
}
var lrucache = LRUCache;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first2 = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first2];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  const LRU = lrucache;
  const cache = new LRU();
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1$2;
  const SemVer3 = semver$2;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$4;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z2 = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from2, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from2 = "";
    } else if (isX(fm)) {
      from2 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from2 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from2 = `>=${from2}`;
    } else {
      from2 = `>=${from2}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from2} ${to}`.trim();
  };
  const testSet = (set, version2, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug2(set[i].semver);
        if (set[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1$2;
  const SemVer3 = semver$2;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version2, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version2);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$2;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$4(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$2;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$3(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$2;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$2;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version2, range2, hilo, options) => {
  version2 = new SemVer$1(version2, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version2, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version2, range2, options) => outside$2(version2, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version2, range2, options) => outside$1(version2, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range2, options) => {
  const set = [];
  let first2 = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$2(a, b, options));
  for (const version2 of v) {
    const included = satisfies$2(version2, range2, options);
    if (included) {
      prev = version2;
      if (!first2) {
        first2 = version2;
      }
    } else {
      if (prev) {
        set.push([first2, prev]);
      }
      prev = null;
      first2 = null;
    }
  }
  if (first2) {
    set.push([first2, null]);
  }
  const ranges = [];
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v[0]) {
      ranges.push("*");
    } else if (!max) {
      ranges.push(`>=${min}`);
    } else if (min === v[0]) {
      ranges.push(`<=${max}`);
    } else {
      ranges.push(`${min} - ${max}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER;
      }
    }
    if (sawNonNull) {
      return false;
    }
  }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants$3 = constants$4;
const SemVer = semver$2;
const identifiers = identifiers$1;
const parse$1 = parse_1$e;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver = {
  parse: parse$1,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants$3.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants$3.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
const semver$1 = /* @__PURE__ */ getDefaultExportFromCjs(semver);
var DeviceModelId;
(function(DeviceModelId2) {
  DeviceModelId2["blue"] = "blue";
  DeviceModelId2["nanoS"] = "nanoS";
  DeviceModelId2["nanoSP"] = "nanoSP";
  DeviceModelId2["nanoX"] = "nanoX";
  DeviceModelId2["stax"] = "stax";
  DeviceModelId2["europa"] = "europa";
})(DeviceModelId || (DeviceModelId = {}));
const devices = {
  [DeviceModelId.blue]: {
    id: DeviceModelId.blue,
    productName: "Ledger Blue",
    productIdMM: 0,
    legacyUsbProductId: 0,
    usbOnly: true,
    memorySize: 480 * 1024,
    masks: [822083584, 822149120],
    getBlockSize: (_firwareVersion) => 4 * 1024
  },
  [DeviceModelId.nanoS]: {
    id: DeviceModelId.nanoS,
    productName: "Ledger Nano S",
    productIdMM: 16,
    legacyUsbProductId: 1,
    usbOnly: true,
    memorySize: 320 * 1024,
    masks: [823132160],
    getBlockSize: (firmwareVersion) => {
      var _a;
      return semver$1.lt((_a = semver$1.coerce(firmwareVersion)) !== null && _a !== void 0 ? _a : "", "2.0.0") ? 4 * 1024 : 2 * 1024;
    }
  },
  [DeviceModelId.nanoX]: {
    id: DeviceModelId.nanoX,
    productName: "Ledger Nano X",
    productIdMM: 64,
    legacyUsbProductId: 4,
    usbOnly: false,
    memorySize: 2 * 1024 * 1024,
    masks: [855638016],
    getBlockSize: (_firwareVersion) => 4 * 1024,
    bluetoothSpec: [
      {
        serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
        notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
        writeUuid: "13d63400-2c97-0004-0002-4c6564676572",
        writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572"
      }
    ]
  },
  [DeviceModelId.nanoSP]: {
    id: DeviceModelId.nanoSP,
    productName: "Ledger Nano S Plus",
    productIdMM: 80,
    legacyUsbProductId: 5,
    usbOnly: true,
    memorySize: 1533 * 1024,
    masks: [856686592],
    getBlockSize: (_firmwareVersion) => 32
  },
  [DeviceModelId.stax]: {
    id: DeviceModelId.stax,
    productName: "Ledger Stax",
    productIdMM: 96,
    legacyUsbProductId: 6,
    usbOnly: false,
    memorySize: 1533 * 1024,
    masks: [857735168],
    getBlockSize: (_firmwareVersion) => 32,
    bluetoothSpec: [
      {
        serviceUuid: "13d63400-2c97-6004-0000-4c6564676572",
        notifyUuid: "13d63400-2c97-6004-0001-4c6564676572",
        writeUuid: "13d63400-2c97-6004-0002-4c6564676572",
        writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572"
      }
    ]
  },
  [DeviceModelId.europa]: {
    id: DeviceModelId.europa,
    productName: "Ledger Flex",
    productIdMM: 112,
    legacyUsbProductId: 7,
    usbOnly: false,
    memorySize: 1533 * 1024,
    masks: [858783744],
    getBlockSize: (_firmwareVersion) => 32,
    bluetoothSpec: [
      {
        serviceUuid: "13d63400-2c97-3004-0000-4c6564676572",
        notifyUuid: "13d63400-2c97-3004-0001-4c6564676572",
        writeUuid: "13d63400-2c97-3004-0002-4c6564676572",
        writeCmdUuid: "13d63400-2c97-3004-0003-4c6564676572"
      }
    ]
  }
};
({
  Blue: DeviceModelId.blue,
  "Nano S": DeviceModelId.nanoS,
  "Nano S Plus": DeviceModelId.nanoSP,
  "Nano X": DeviceModelId.nanoX,
  Stax: DeviceModelId.stax,
  Europa: DeviceModelId.europa
});
const devicesList = Object.values(devices);
const ledgerUSBVendorId = 11415;
const identifyUSBProductId = (usbProductId) => {
  const legacy = devicesList.find((d) => d.legacyUsbProductId === usbProductId);
  if (legacy)
    return legacy;
  const mm = usbProductId >> 8;
  const deviceModel = devicesList.find((d) => d.productIdMM === mm);
  return deviceModel;
};
const bluetoothServices = [];
const serviceUuidToInfos = {};
for (const id2 in devices) {
  const deviceModel = devices[id2];
  const { bluetoothSpec } = deviceModel;
  if (bluetoothSpec) {
    for (let i = 0; i < bluetoothSpec.length; i++) {
      const spec = bluetoothSpec[i];
      bluetoothServices.push(spec.serviceUuid);
      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, "")] = Object.assign({ deviceModel }, spec);
    }
  }
}
const getBluetoothServiceUuids = () => bluetoothServices;
const getInfosForServiceUuid = (uuid) => serviceUuidToInfos[uuid.toLowerCase()];
var __awaiter$4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const ledgerDevices$1 = [
  {
    vendorId: ledgerUSBVendorId
  }
];
function requestLedgerDevice() {
  return __awaiter$4(this, void 0, void 0, function* () {
    const device2 = yield navigator.usb.requestDevice({
      filters: ledgerDevices$1
    });
    return device2;
  });
}
function getLedgerDevices$1() {
  return __awaiter$4(this, void 0, void 0, function* () {
    const devices2 = yield navigator.usb.getDevices();
    return devices2.filter((d) => d.vendorId === ledgerUSBVendorId);
  });
}
function getFirstLedgerDevice$1() {
  return __awaiter$4(this, void 0, void 0, function* () {
    const existingDevices = yield getLedgerDevices$1();
    if (existingDevices.length > 0)
      return existingDevices[0];
    return requestLedgerDevice();
  });
}
const isSupported$1 = () => Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices === "function");
var __awaiter$3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const configurationValue = 1;
const endpointNumber = 3;
class TransportWebUSB extends Transport {
  constructor(device2, interfaceNumber) {
    super();
    this.channel = Math.floor(Math.random() * 65535);
    this.packetSize = 64;
    this._disconnectEmitted = false;
    this._emitDisconnect = (e) => {
      if (this._disconnectEmitted)
        return;
      this._disconnectEmitted = true;
      this.emit("disconnect", e);
    };
    this.device = device2;
    this.interfaceNumber = interfaceNumber;
    this.deviceModel = identifyUSBProductId(device2.productId);
  }
  /**
   * Similar to create() except it will always display the device permission (even if some devices are already accepted).
   */
  static request() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const device2 = yield requestLedgerDevice();
      return TransportWebUSB.open(device2);
    });
  }
  /**
   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
   */
  static openConnected() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const devices2 = yield getLedgerDevices$1();
      if (devices2.length === 0)
        return null;
      return TransportWebUSB.open(devices2[0]);
    });
  }
  /**
   * Create a Ledger transport with a USBDevice
   */
  static open(device2) {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield device2.open();
      if (device2.configuration === null) {
        yield device2.selectConfiguration(configurationValue);
      }
      yield gracefullyResetDevice(device2);
      const iface = device2.configurations[0].interfaces.find(({ alternates }) => alternates.some((a) => a.interfaceClass === 255));
      if (!iface) {
        throw new TransportInterfaceNotAvailable("No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.");
      }
      const interfaceNumber = iface.interfaceNumber;
      try {
        yield device2.claimInterface(interfaceNumber);
      } catch (e) {
        yield device2.close();
        throw new TransportInterfaceNotAvailable(e.message);
      }
      const transport2 = new TransportWebUSB(device2, interfaceNumber);
      const onDisconnect = (e) => {
        if (device2 === e.device) {
          navigator.usb.removeEventListener("disconnect", onDisconnect);
          transport2._emitDisconnect(new DisconnectedDevice());
        }
      };
      navigator.usb.addEventListener("disconnect", onDisconnect);
      return transport2;
    });
  }
  /**
   * Release the transport device
   */
  close() {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.exchangeBusyPromise;
      yield this.device.releaseInterface(this.interfaceNumber);
      yield gracefullyResetDevice(this.device);
      yield this.device.close();
    });
  }
  /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   */
  exchange(apdu) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const b = yield this.exchangeAtomicImpl(() => __awaiter$3(this, void 0, void 0, function* () {
        const { channel, packetSize } = this;
        log("apdu", "=> " + apdu.toString("hex"));
        const framing = createHIDframing(channel, packetSize);
        const blocks = framing.makeBlocks(apdu);
        for (let i = 0; i < blocks.length; i++) {
          yield this.device.transferOut(endpointNumber, blocks[i]);
        }
        let result;
        let acc;
        while (!(result = framing.getReducedResult(acc))) {
          const r = yield this.device.transferIn(endpointNumber, packetSize);
          const buffer2 = Buffer$1.from(r.data.buffer);
          acc = framing.reduceResponse(acc, buffer2);
        }
        log("apdu", "<= " + result.toString("hex"));
        return result;
      })).catch((e) => {
        if (e && e.message && e.message.includes("disconnected")) {
          this._emitDisconnect(e);
          throw new DisconnectedDeviceDuringOperation(e.message);
        }
        throw e;
      });
      return b;
    });
  }
  setScrambleKey() {
  }
}
TransportWebUSB.isSupported = isSupported$1;
TransportWebUSB.list = getLedgerDevices$1;
TransportWebUSB.listen = (observer) => {
  let unsubscribed = false;
  getFirstLedgerDevice$1().then((device2) => {
    if (!unsubscribed) {
      const deviceModel = identifyUSBProductId(device2.productId);
      observer.next({
        type: "add",
        descriptor: device2,
        deviceModel
      });
      observer.complete();
    }
  }, (error) => {
    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {
      observer.error(new TransportWebUSBGestureRequired(error.message));
    } else {
      observer.error(new TransportOpenUserCancelled(error.message));
    }
  });
  function unsubscribe() {
    unsubscribed = true;
  }
  return {
    unsubscribe
  };
};
function gracefullyResetDevice(device2) {
  return __awaiter$3(this, void 0, void 0, function* () {
    try {
      yield device2.reset();
    } catch (err) {
      console.warn(err);
    }
  });
}
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const ledgerDevices = [
  {
    vendorId: ledgerUSBVendorId
  }
];
const isSupported = () => Promise.resolve(!!(window.navigator && window.navigator.hid));
const getHID = () => {
  const { hid } = navigator;
  if (!hid)
    throw new TransportError("navigator.hid is not supported", "HIDNotSupported");
  return hid;
};
function requestLedgerDevices() {
  return __awaiter$2(this, void 0, void 0, function* () {
    const device2 = yield getHID().requestDevice({
      filters: ledgerDevices
    });
    if (Array.isArray(device2))
      return device2;
    return [device2];
  });
}
function getLedgerDevices() {
  return __awaiter$2(this, void 0, void 0, function* () {
    const devices2 = yield getHID().getDevices();
    return devices2.filter((d) => d.vendorId === ledgerUSBVendorId);
  });
}
function getFirstLedgerDevice() {
  return __awaiter$2(this, void 0, void 0, function* () {
    const existingDevices = yield getLedgerDevices();
    if (existingDevices.length > 0)
      return existingDevices[0];
    const devices2 = yield requestLedgerDevices();
    return devices2[0];
  });
}
class TransportWebHID extends Transport {
  constructor(device2) {
    super();
    this.channel = Math.floor(Math.random() * 65535);
    this.packetSize = 64;
    this.inputs = [];
    this.read = () => {
      if (this.inputs.length) {
        return Promise.resolve(this.inputs.shift());
      }
      return new Promise((success) => {
        this.inputCallback = success;
      });
    };
    this.onInputReport = (e) => {
      const buffer2 = Buffer$1.from(e.data.buffer);
      if (this.inputCallback) {
        this.inputCallback(buffer2);
        this.inputCallback = null;
      } else {
        this.inputs.push(buffer2);
      }
    };
    this._disconnectEmitted = false;
    this._emitDisconnect = (e) => {
      if (this._disconnectEmitted)
        return;
      this._disconnectEmitted = true;
      this.emit("disconnect", e);
    };
    this.exchange = (apdu) => __awaiter$2(this, void 0, void 0, function* () {
      const b = yield this.exchangeAtomicImpl(() => __awaiter$2(this, void 0, void 0, function* () {
        const { channel, packetSize } = this;
        log("apdu", "=> " + apdu.toString("hex"));
        const framing = createHIDframing(channel, packetSize);
        const blocks = framing.makeBlocks(apdu);
        for (let i = 0; i < blocks.length; i++) {
          yield this.device.sendReport(0, blocks[i]);
        }
        let result;
        let acc;
        while (!(result = framing.getReducedResult(acc))) {
          const buffer2 = yield this.read();
          acc = framing.reduceResponse(acc, buffer2);
        }
        log("apdu", "<= " + result.toString("hex"));
        return result;
      })).catch((e) => {
        if (e && e.message && e.message.includes("write")) {
          this._emitDisconnect(e);
          throw new DisconnectedDeviceDuringOperation(e.message);
        }
        throw e;
      });
      return b;
    });
    this.device = device2;
    this.deviceModel = typeof device2.productId === "number" ? identifyUSBProductId(device2.productId) : void 0;
    device2.addEventListener("inputreport", this.onInputReport);
  }
  /**
   * Similar to create() except it will always display the device permission (even if some devices are already accepted).
   */
  static request() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const [device2] = yield requestLedgerDevices();
      return TransportWebHID.open(device2);
    });
  }
  /**
   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
   */
  static openConnected() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const devices2 = yield getLedgerDevices();
      if (devices2.length === 0)
        return null;
      return TransportWebHID.open(devices2[0]);
    });
  }
  /**
   * Create a Ledger transport with a HIDDevice
   */
  static open(device2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield device2.open();
      const transport2 = new TransportWebHID(device2);
      const onDisconnect = (e) => {
        if (device2 === e.device) {
          getHID().removeEventListener("disconnect", onDisconnect);
          transport2._emitDisconnect(new DisconnectedDevice());
        }
      };
      getHID().addEventListener("disconnect", onDisconnect);
      return transport2;
    });
  }
  /**
   * Release the transport device
   */
  close() {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.exchangeBusyPromise;
      this.device.removeEventListener("inputreport", this.onInputReport);
      yield this.device.close();
    });
  }
  setScrambleKey() {
  }
}
TransportWebHID.isSupported = isSupported;
TransportWebHID.list = getLedgerDevices;
TransportWebHID.listen = (observer) => {
  let unsubscribed = false;
  getFirstLedgerDevice().then((device2) => {
    if (!device2) {
      observer.error(new TransportOpenUserCancelled("Access denied to use Ledger device"));
    } else if (!unsubscribed) {
      const deviceModel = typeof device2.productId === "number" ? identifyUSBProductId(device2.productId) : void 0;
      observer.next({
        type: "add",
        descriptor: device2,
        deviceModel
      });
      observer.complete();
    }
  }, (error) => {
    observer.error(new TransportOpenUserCancelled(error.message));
  });
  function unsubscribe() {
    unsubscribed = true;
  }
  return {
    unsubscribe
  };
};
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors2) {
    _super(this);
    this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors2;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors2;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors2 = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors2 = errors2 !== null && errors2 !== void 0 ? errors2 : [];
              if (err instanceof UnsubscriptionError) {
                errors2 = __spreadArray(__spreadArray([], __read(errors2)), __read(err.errors));
              } else {
                errors2.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors2) {
        throw new UnsubscriptionError(errors2);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config$1 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop() {
}
function errorContext(cb) {
  {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config$1.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$1.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last2 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last2 = i;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader2, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader2 = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader2.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader2.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter$6(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator$1;
    executeSchedule(subscriber, scheduler, function() {
      iterator$1 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator$1.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
function firstValueFrom(source, config2) {
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) ;
            else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
  };
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
function take(count) {
  return count <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
function ignoreElements() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, noop));
  });
}
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount--;
        if (refCount === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const TagId$1 = 5;
function createChunkedBuffers(buffer2, sizeForIndex) {
  const chunks = [];
  for (let i = 0, size = sizeForIndex(0); i < buffer2.length; i += size, size = sizeForIndex(i)) {
    chunks.push(buffer2.slice(i, i + size));
  }
  return chunks;
}
const sendAPDU = (write, apdu, mtuSize, { context } = {}) => {
  const chunks = createChunkedBuffers(apdu, (i) => mtuSize - (i === 0 ? 5 : 3)).map((buffer2, i) => {
    const head = Buffer$1.alloc(i === 0 ? 5 : 3);
    head.writeUInt8(TagId$1, 0);
    head.writeUInt16BE(i, 1);
    if (i === 0) {
      head.writeUInt16BE(apdu.length, 3);
    }
    return Buffer$1.concat([head, buffer2]);
  });
  return new Observable((o) => {
    let terminated = false;
    function main() {
      return __awaiter$1(this, void 0, void 0, function* () {
        for (const chunk of chunks) {
          if (terminated)
            return;
          yield write(chunk);
        }
      });
    }
    main().then(() => {
      terminated = true;
      o.complete();
    }, (error) => {
      terminated = true;
      trace({
        type: "ble-error",
        message: `sendAPDU failure: ${error}`,
        data: { error },
        context
      });
      o.error(error);
    });
    const unsubscribe = () => {
      if (!terminated) {
        trace({
          type: "ble-error",
          message: "sendAPDU interruption",
          context
        });
        terminated = true;
      }
    };
    return unsubscribe;
  });
};
const TagId = 5;
const receiveAPDU = (rawStream, { context } = {}) => new Observable((o) => {
  let notifiedIndex = 0;
  let notifiedDataLength = 0;
  let notifiedData = Buffer$1.alloc(0);
  const subscriptionCleaner = new ReplaySubject();
  rawStream.pipe(takeUntil(subscriptionCleaner)).subscribe({
    complete: () => {
      o.error(new DisconnectedDevice());
    },
    error: (error) => {
      trace({
        type: "ble-error",
        message: `Error in receiveAPDU: ${error}`,
        data: { error },
        context
      });
      o.error(error);
    },
    next: (value) => {
      if (value instanceof Error) {
        trace({
          type: "ble-error",
          message: `Error emitted to receiveAPDU next: ${value}`,
          data: { error: value },
          context
        });
        return;
      }
      const tag = value.readUInt8(0);
      const chunkIndex = value.readUInt16BE(1);
      let chunkData = value.slice(3);
      if (tag !== TagId) {
        o.error(new TransportError("Invalid tag " + tag.toString(16), "InvalidTag"));
        return;
      }
      if (notifiedIndex !== chunkIndex) {
        o.error(new TransportError(`BLE: Invalid sequence number. discontinued chunk. Received ${chunkIndex} but expected ${notifiedIndex}`, "InvalidSequence"));
        return;
      }
      if (chunkIndex === 0) {
        notifiedDataLength = chunkData.readUInt16BE(0);
        chunkData = chunkData.slice(2);
      }
      notifiedIndex++;
      notifiedData = Buffer$1.concat([notifiedData, chunkData]);
      if (notifiedData.length > notifiedDataLength) {
        o.error(new TransportError(`BLE: received too much data. discontinued chunk. Received ${notifiedData.length} but expected ${notifiedDataLength}`, "BLETooMuchData"));
        return;
      }
      if (notifiedData.length === notifiedDataLength) {
        o.next(notifiedData);
        o.complete();
        subscriptionCleaner.next();
      }
    }
  });
  return () => {
    subscriptionCleaner.next();
  };
});
const monitorCharacteristic = (characteristic) => Observable.create((o) => {
  log("ble-verbose", "start monitor " + characteristic.uuid);
  function onCharacteristicValueChanged(event) {
    const characteristic2 = event.target;
    if (characteristic2.value) {
      o.next(Buffer$1.from(characteristic2.value.buffer));
    }
  }
  characteristic.startNotifications().then(() => {
    characteristic.addEventListener("characteristicvaluechanged", onCharacteristicValueChanged);
  });
  return () => {
    log("ble-verbose", "end monitor " + characteristic.uuid);
    characteristic.stopNotifications();
  };
});
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const requiresBluetooth = () => {
  const { bluetooth } = navigator;
  if (typeof bluetooth === "undefined") {
    throw new Error("web bluetooth not supported");
  }
  return bluetooth;
};
const availability = () => Observable.create((observer) => {
  const bluetooth = requiresBluetooth();
  const onAvailabilityChanged = (e) => {
    observer.next(e.value);
  };
  bluetooth.addEventListener("availabilitychanged", onAvailabilityChanged);
  let unsubscribed = false;
  bluetooth.getAvailability().then((available) => {
    if (!unsubscribed) {
      observer.next(available);
    }
  });
  return () => {
    unsubscribed = true;
    bluetooth.removeEventListener("availabilitychanged", onAvailabilityChanged);
  };
});
const transportsCache = {};
const requestDeviceParam = () => ({
  filters: getBluetoothServiceUuids().map((uuid) => ({
    services: [uuid]
  }))
});
const retrieveService = (device2) => __awaiter(void 0, void 0, void 0, function* () {
  if (!device2.gatt)
    throw new Error("bluetooth gatt not found");
  const [service2] = yield device2.gatt.getPrimaryServices();
  if (!service2)
    throw new Error("bluetooth service not found");
  const infos = getInfosForServiceUuid(service2.uuid);
  if (!infos)
    throw new Error("bluetooth service infos not found");
  return [service2, infos];
});
function open(deviceOrId, needsReconnect) {
  return __awaiter(this, void 0, void 0, function* () {
    let device2;
    if (typeof deviceOrId === "string") {
      if (transportsCache[deviceOrId]) {
        log("ble-verbose", "Transport in cache, using that.");
        return transportsCache[deviceOrId];
      }
      const bluetooth = requiresBluetooth();
      device2 = yield bluetooth.requestDevice(requestDeviceParam());
    } else {
      device2 = deviceOrId;
    }
    if (!device2.gatt.connected) {
      log("ble-verbose", "not connected. connecting...");
      yield device2.gatt.connect();
    }
    const [service2, infos] = yield retrieveService(device2);
    const { deviceModel, writeUuid, notifyUuid } = infos;
    const [writeC, notifyC] = yield Promise.all([
      service2.getCharacteristic(writeUuid),
      service2.getCharacteristic(notifyUuid)
    ]);
    const notifyObservable = monitorCharacteristic(notifyC).pipe(tap((value) => {
      log("ble-frame", "<= " + value.toString("hex"));
    }), share());
    const notif = notifyObservable.subscribe();
    const transport2 = new BluetoothTransport(device2, writeC, notifyObservable, deviceModel);
    if (!device2.gatt.connected) {
      throw new DisconnectedDevice();
    }
    transportsCache[transport2.id] = transport2;
    const onDisconnect = (e) => {
      console.log("onDisconnect!", e);
      delete transportsCache[transport2.id];
      transport2.notYetDisconnected = false;
      notif.unsubscribe();
      device2.removeEventListener("gattserverdisconnected", onDisconnect);
      log("ble-verbose", `BleTransport(${transport2.id}) disconnected`);
      transport2.emit("disconnect", e);
    };
    device2.addEventListener("gattserverdisconnected", onDisconnect);
    const beforeMTUTime = Date.now();
    try {
      yield transport2.inferMTU();
    } finally {
      const afterMTUTime = Date.now();
      if (afterMTUTime - beforeMTUTime < 1e3) {
        needsReconnect = false;
      }
      if (needsReconnect) {
        yield device2.gatt.disconnect();
        yield new Promise((s) => setTimeout(s, 4e3));
      }
    }
    if (needsReconnect) {
      return open(device2, false);
    }
    return transport2;
  });
}
class BluetoothTransport extends Transport {
  /**
   * Scan for Ledger Bluetooth devices.
   * On this web implementation, it only emits ONE device, the one that was selected in the UI (if any).
   */
  static listen(observer) {
    log("ble-verbose", "listen...");
    let unsubscribed;
    const bluetooth = requiresBluetooth();
    bluetooth.requestDevice(requestDeviceParam()).then((device2) => {
      if (!unsubscribed) {
        observer.next({
          type: "add",
          descriptor: device2
        });
        observer.complete();
      }
    }, (error) => {
      observer.error(new TransportOpenUserCancelled(error.message));
    });
    function unsubscribe() {
      unsubscribed = true;
    }
    return {
      unsubscribe
    };
  }
  /**
   * open a bluetooth device.
   */
  static open(deviceOrId) {
    return __awaiter(this, void 0, void 0, function* () {
      return open(deviceOrId, true);
    });
  }
  constructor(device2, writeCharacteristic, notifyObservable, deviceModel) {
    super();
    this.mtuSize = 20;
    this.notYetDisconnected = true;
    this.write = (buffer2) => __awaiter(this, void 0, void 0, function* () {
      log("ble-frame", "=> " + buffer2.toString("hex"));
      yield this.writeCharacteristic.writeValue(buffer2);
    });
    this.id = device2.id;
    this.device = device2;
    this.writeCharacteristic = writeCharacteristic;
    this.notifyObservable = notifyObservable;
    this.deviceModel = deviceModel;
    log("ble-verbose", `BleTransport(${String(this.id)}) new instance`);
  }
  inferMTU() {
    return __awaiter(this, void 0, void 0, function* () {
      let mtu = 23;
      yield this.exchangeAtomicImpl(() => __awaiter(this, void 0, void 0, function* () {
        try {
          mtu = (yield firstValueFrom(merge(this.notifyObservable.pipe(first((buffer2) => buffer2.readUInt8(0) === 8), map((buffer2) => buffer2.readUInt8(5))), defer(() => from(this.write(Buffer$1.from([8, 0, 0, 0, 0])))).pipe(ignoreElements())))) + 3;
        } catch (e) {
          log("ble-error", "inferMTU got " + String(e));
          this.device.gatt.disconnect();
          throw e;
        }
      }));
      if (mtu > 23) {
        const mtuSize = mtu - 3;
        log("ble-verbose", `BleTransport(${String(this.id)}) mtu set to ${String(mtuSize)}`);
        this.mtuSize = mtuSize;
      }
      return this.mtuSize;
    });
  }
  /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   */
  exchange(apdu) {
    return __awaiter(this, void 0, void 0, function* () {
      const b = yield this.exchangeAtomicImpl(() => __awaiter(this, void 0, void 0, function* () {
        try {
          const msgIn = apdu.toString("hex");
          log("apdu", `=> ${msgIn}`);
          const data = yield firstValueFrom(merge(this.notifyObservable.pipe(receiveAPDU), sendAPDU(this.write, apdu, this.mtuSize)));
          const msgOut = data.toString("hex");
          log("apdu", `<= ${msgOut}`);
          return data;
        } catch (e) {
          log("ble-error", "exchange got " + String(e));
          if (this.notYetDisconnected) {
            this.device.gatt.disconnect();
          }
          throw e;
        }
      }));
      return b;
    });
  }
  setScrambleKey() {
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.exchangeBusyPromise) {
        yield this.exchangeBusyPromise;
      }
    });
  }
}
BluetoothTransport.isSupported = () => Promise.resolve().then(requiresBluetooth).then(() => true, () => false);
BluetoothTransport.observeAvailability = (observer) => availability().subscribe(observer);
BluetoothTransport.list = () => Promise.resolve([]);
BluetoothTransport.disconnect = (id2) => __awaiter(void 0, void 0, void 0, function* () {
  log("ble-verbose", `user disconnect(${id2})`);
  const transport2 = transportsCache[id2];
  if (transport2) {
    transport2.device.gatt.disconnect();
  }
});
var Ada = {};
var errors$4 = {};
var errorBase = {};
Object.defineProperty(errorBase, "__esModule", { value: true });
errorBase.ErrorBase = void 0;
class ErrorBase extends Error {
  constructor(message2) {
    super(message2);
    this.name = this.constructor.name;
  }
}
errorBase.ErrorBase = ErrorBase;
var invalidData = {};
Object.defineProperty(invalidData, "__esModule", { value: true });
invalidData.InvalidData = void 0;
const errorBase_1$2 = errorBase;
class InvalidData extends errorBase_1$2.ErrorBase {
  constructor(reason) {
    super(reason);
  }
}
invalidData.InvalidData = InvalidData;
var deviceUnsupported = {};
Object.defineProperty(deviceUnsupported, "__esModule", { value: true });
deviceUnsupported.DeviceVersionUnsupported = void 0;
const errorBase_1$1 = errorBase;
class DeviceVersionUnsupported extends errorBase_1$1.ErrorBase {
}
deviceUnsupported.DeviceVersionUnsupported = DeviceVersionUnsupported;
var deviceStatusError = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DeviceStatusError = exports2.DeviceStatusMessages = exports2.DeviceStatusCodes = void 0;
  const errorBase_12 = errorBase;
  exports2.DeviceStatusCodes = {
    ERR_STILL_IN_CALL: 28164,
    ERR_INVALID_DATA: 28167,
    ERR_INVALID_BIP_PATH: 28168,
    ERR_REJECTED_BY_USER: 28169,
    ERR_REJECTED_BY_POLICY: 28176,
    ERR_DEVICE_LOCKED: 28177,
    ERR_UNSUPPORTED_ADDRESS_TYPE: 28178,
    ERR_CLA_NOT_SUPPORTED: 28160
  };
  exports2.DeviceStatusMessages = {
    [exports2.DeviceStatusCodes.ERR_INVALID_DATA]: "Invalid data supplied to Ledger",
    [exports2.DeviceStatusCodes.ERR_INVALID_BIP_PATH]: "Invalid derivation path supplied to Ledger",
    [exports2.DeviceStatusCodes.ERR_REJECTED_BY_USER]: "Action rejected by user",
    [exports2.DeviceStatusCodes.ERR_REJECTED_BY_POLICY]: "Action rejected by Ledger's security policy",
    [exports2.DeviceStatusCodes.ERR_DEVICE_LOCKED]: "Device is locked",
    [exports2.DeviceStatusCodes.ERR_CLA_NOT_SUPPORTED]: "Wrong Ledger app",
    [exports2.DeviceStatusCodes.ERR_UNSUPPORTED_ADDRESS_TYPE]: "Unsupported address type"
  };
  const GH_DEVICE_ERRORS_LINK = "https://github.com/cardano-foundation/ledger-app-cardano/blob/master/src/errors.h";
  const getDeviceErrorDescription = (statusCode) => {
    var _a;
    const statusCodeHex = `0x${statusCode.toString(16)}`;
    const defaultMsg = `General error ${statusCodeHex}. Please consult ${GH_DEVICE_ERRORS_LINK}`;
    return (_a = exports2.DeviceStatusMessages[statusCode]) !== null && _a !== void 0 ? _a : defaultMsg;
  };
  class DeviceStatusError extends errorBase_12.ErrorBase {
    constructor(code) {
      super(getDeviceErrorDescription(code));
      this.code = code;
    }
  }
  exports2.DeviceStatusError = DeviceStatusError;
})(deviceStatusError);
var invalidDataReason = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.InvalidDataReason = void 0;
  (function(InvalidDataReason) {
    InvalidDataReason["GET_EXT_PUB_KEY_PATHS_NOT_ARRAY"] = "ext pub key paths not an array";
    InvalidDataReason["INVALID_PATH"] = "invalid path";
    InvalidDataReason["NETWORK_INVALID_PROTOCOL_MAGIC"] = "invalid protocol magic";
    InvalidDataReason["NETWORK_INVALID_NETWORK_ID"] = "invalid network id";
    InvalidDataReason["NETWORK_ID_INCLUDE_INVALID"] = "invalid value for includeNetworkId";
    InvalidDataReason["INPUTS_NOT_ARRAY"] = "inputs not an array";
    InvalidDataReason["INPUT_INVALID_TX_HASH"] = "invalid tx hash in an input";
    InvalidDataReason["INPUT_INVALID_PATH"] = "invalid input path";
    InvalidDataReason["INPUT_INVALID_UTXO_INDEX"] = "invalid input utxo index";
    InvalidDataReason["OUTPUTS_NOT_ARRAY"] = "outputs not an array";
    InvalidDataReason["OUTPUT_INVALID_FORMAT"] = "invalid output format";
    InvalidDataReason["OUTPUT_INVALID_AMOUNT"] = "invalid amount in an output";
    InvalidDataReason["OUTPUT_INVALID_ADDRESS"] = "invalid address in an output";
    InvalidDataReason["OUTPUT_INVALID_ADDRESS_PARAMS"] = "change address must have path as payment part";
    InvalidDataReason["OUTPUT_INVALID_DATUM_HASH"] = "invalid datum hash";
    InvalidDataReason["OUTPUT_INVALID_INLINE_DATUM"] = "invalid inline datum";
    InvalidDataReason["OUTPUT_INVALID_REFERENCE_SCRIPT_HEX"] = "invalid script hex";
    InvalidDataReason["OUTPUT_INCONSISTENT_DATUM"] = "datum is not consistent with output type";
    InvalidDataReason["OUTPUT_INCONSISTENT_REFERENCE_SCRIPT"] = "reference script is not consistent with output type";
    InvalidDataReason["MULTIASSET_INVALID_POLICY_NAME"] = "invalid policy id in a multiasset token bundle";
    InvalidDataReason["MULTIASSET_INVALID_TOKEN_BUNDLE_NOT_ARRAY"] = "invalid multiasset token bundle - asset groups not an array";
    InvalidDataReason["MULTIASSET_INVALID_TOKEN_BUNDLE_TOO_LARGE"] = "invalid multiasset token bundle - too many asset groups";
    InvalidDataReason["MULTIASSET_INVALID_TOKEN_BUNDLE_ORDERING"] = "invalid multiasset token bundle - incorrect ordering of asset groups";
    InvalidDataReason["MULTIASSET_INVALID_TOKEN_BUNDLE_NOT_UNIQUE"] = "invalid multiasset token bundle - policyIds not unique";
    InvalidDataReason["MULTIASSET_INVALID_TOKEN_BUNDLE_EMPTY"] = "invalid multiasset token bundle - token bundle is not allowed to be empty";
    InvalidDataReason["MULTIASSET_INVALID_TOKEN_AMOUNT"] = "invalid token amount in an asset group in a multiasset token bundle";
    InvalidDataReason["MULTIASSET_INVALID_ASSET_NAME"] = "invalid asset name in an asset group in a multiasset token bundle";
    InvalidDataReason["MULTIASSET_INVALID_ASSET_GROUP_NOT_ARRAY"] = "invalid asset group in multiasset token bundle - tokens not an array";
    InvalidDataReason["MULTIASSET_INVALID_ASSET_GROUP_TOO_LARGE"] = "invalid asset group in multiasset token bundle - too many tokens";
    InvalidDataReason["MULTIASSET_INVALID_ASSET_GROUP_EMPTY"] = "invalid asset group in multiasset token bundle - zero tokens";
    InvalidDataReason["MULTIASSET_INVALID_ASSET_GROUP_ORDERING"] = "invalid asset group in multiasset token bundle - incorrect ordering of tokens";
    InvalidDataReason["MULTIASSET_INVALID_ASSET_GROUP_NOT_UNIQUE"] = "invalid asset group in multiasset token bundle - token names not unique";
    InvalidDataReason["ADDRESS_UNKNOWN_TYPE"] = "unknown address type";
    InvalidDataReason["ADDRESS_INVALID_SPENDING_INFO"] = "invalid address spending information";
    InvalidDataReason["ADDRESS_INVALID_SPENDING_KEY_PATH"] = "invalid address spending key path";
    InvalidDataReason["ADDRESS_INVALID_SPENDING_SCRIPT_HASH"] = "invalid address spending script hash";
    InvalidDataReason["ADDRESS_INVALID_BLOCKCHAIN_POINTER"] = "invalid address blockchain pointer";
    InvalidDataReason["ADDRESS_INVALID_STAKING_KEY_PATH"] = "invalid address staking key path";
    InvalidDataReason["ADDRESS_INVALID_STAKING_KEY_HASH"] = "invalid address staking key hash";
    InvalidDataReason["ADDRESS_INVALID_STAKING_SCRIPT_HASH"] = "invalid address staking script hash";
    InvalidDataReason["ADDRESS_INVALID_STAKING_INFO"] = "Invalid staking info in an output";
    InvalidDataReason["ADDRESS_INVALID_REWARD_ADDRESS"] = "invalid reward address for this version of ledger";
    InvalidDataReason["FEE_INVALID"] = "invalid fee";
    InvalidDataReason["TTL_INVALID"] = "invalid ttl";
    InvalidDataReason["CERTIFICATES_NOT_ARRAY"] = "certificates not an array";
    InvalidDataReason["CERTIFICATE_INVALID_TYPE"] = "invalid certificate type";
    InvalidDataReason["CERTIFICATE_INVALID_PATH"] = "one of the certificates contains an invalid path";
    InvalidDataReason["CERTIFICATE_INVALID_STAKE_CREDENTIAL"] = "one of the certificates contains an invalid stake credential";
    InvalidDataReason["CERTIFICATE_INVALID_COMMITTEE_CREDENTIAL"] = "one of the certificates contains invalid constitutional committee credential";
    InvalidDataReason["CERTIFICATE_INVALID_DREP_CREDENTIAL"] = "one of the certificates contains an invalid DRep credential";
    InvalidDataReason["CERTIFICATE_INVALID_POOL_KEY_HASH"] = "one of the certificates contains an invalid pool key hash";
    InvalidDataReason["CERTIFICATE_SUPERFLUOUS_POOL_KEY_HASH"] = "superfluous pool key hash in a certificate";
    InvalidDataReason["CERTIFICATE_INVALID_DEPOSIT"] = "one of the certificates contains an invalid deposit";
    InvalidDataReason["CERTIFICATE_INVALID_DREP"] = "one of the certificates contains an invalid DRep";
    InvalidDataReason["ANCHOR_INVALID_URL"] = "anchor with an invalid URL";
    InvalidDataReason["ANCHOR_INVALID_HASH"] = "anchor with an invalid data hash";
    InvalidDataReason["POOL_REGISTRATION_INVALID_VRF_KEY_HASH"] = "invalid vrf key hash in a pool registration certificate";
    InvalidDataReason["POOL_REGISTRATION_INVALID_PLEDGE"] = "invalid pledge in a pool registration certificate";
    InvalidDataReason["POOL_REGISTRATION_INVALID_COST"] = "invalid cost in a pool registration certificate";
    InvalidDataReason["POOL_REGISTRATION_INVALID_MARGIN"] = "invalid margin in a pool registration certificate";
    InvalidDataReason["POOL_REGISTRATION_INVALID_MARGIN_DENOMINATOR"] = "pool margin denominator must be a value between 1 and 10^15";
    InvalidDataReason["POOL_REGISTRATION_OWNERS_TOO_MANY"] = "too many owners in a pool registration certificate";
    InvalidDataReason["POOL_KEY_INVALID_TYPE"] = "invalid pool key type";
    InvalidDataReason["POOL_KEY_INVALID_PATH"] = "invalid pool key path in a pool registration certificate";
    InvalidDataReason["POOL_KEY_INVALID_KEY_HASH"] = "invalid pool key hash in a pool registration certificate";
    InvalidDataReason["POOL_OWNER_INVALID_TYPE"] = "invalid owner type";
    InvalidDataReason["POOL_OWNER_INVALID_PATH"] = "invalid owner path in a pool registration certificate";
    InvalidDataReason["POOL_OWNER_INVALID_KEY_HASH"] = "invalid owner key hash in a pool registration certificate";
    InvalidDataReason["POOL_REGISTRATION_RELAYS_TOO_MANY"] = "too many pool relays in a pool registration certificate";
    InvalidDataReason["POOL_REWARD_ACCOUNT_INVALID_TYPE"] = "invalid pool reward account type";
    InvalidDataReason["POOL_REWARD_ACCOUNT_INVALID_PATH"] = "invalid pool reward account key path in a pool registration certificate";
    InvalidDataReason["POOL_REWARD_ACCOUNT_INVALID_HEX"] = "invalid pool reward account hex in a pool registration certificate";
    InvalidDataReason["POOL_RETIREMENT_INVALID_RETIREMENT_EPOCH"] = "invalid pool retirement epoch";
    InvalidDataReason["RELAY_INVALID_TYPE"] = "invalid type of a relay in a pool registration certificate";
    InvalidDataReason["RELAY_INVALID_PORT"] = "invalid port in a relay in a pool registration certificate";
    InvalidDataReason["RELAY_INVALID_IPV4"] = "invalid ipv4 in a relay in a pool registration certificate";
    InvalidDataReason["RELAY_INVALID_IPV6"] = "invalid ipv6 in a relay in a pool registration certificate";
    InvalidDataReason["RELAY_INVALID_DNS"] = "invalid dns record in a relay in a pool registration certificate";
    InvalidDataReason["POOL_REGISTRATION_METADATA_INVALID_URL"] = "invalid metadata in a pool registration certificate= invalid url";
    InvalidDataReason["POOL_REGISTRATION_METADATA_INVALID_HASH"] = "invalid metadata in a pool registration certificate= invalid hash";
    InvalidDataReason["WITHDRAWALS_NOT_ARRAY"] = "withdrawals not an array";
    InvalidDataReason["WITHDRAWAL_INVALID_AMOUNT"] = "invalid withdrawal amount";
    InvalidDataReason["WITHDRAWAL_INVALID_PATH"] = "invalid withdrawal path";
    InvalidDataReason["WITHDRAWAL_INVALID_STAKE_CREDENTIAL"] = "withdrawal stake credential contains both a path and a scripthash or neither";
    InvalidDataReason["AUXILIARY_DATA_UNKNOWN_TYPE"] = "unknown auxiliary data type";
    InvalidDataReason["AUXILIARY_DATA_INVALID_HASH"] = "invalid auxiliary data hash";
    InvalidDataReason["METADATA_UNKNOWN_TYPE"] = "unknown metadata type";
    InvalidDataReason["CVOTE_REGISTRATION_INCONSISTENT_WITH_CIP15"] = "CIP36 registration params inconsistent with CIP-15";
    InvalidDataReason["CVOTE_REGISTRATION_INCONSISTENT_WITH_CIP36"] = "CIP36 registration params inconsistent with CIP-36";
    InvalidDataReason["CVOTE_REGISTRATION_BOTH_KEY_AND_PATH"] = "CIP36 vote key given both as a key and as a derivation path";
    InvalidDataReason["CVOTE_REGISTRATION_MISSING_VOTE_KEY"] = "CIP36 vote key missing";
    InvalidDataReason["CVOTE_REGISTRATION_INVALID_VOTE_KEY"] = "invalid CIP36 registration vote key";
    InvalidDataReason["CVOTE_REGISTRATION_INVALID_VOTE_KEY_PATH"] = "invalid CIP36 registration vote key path";
    InvalidDataReason["CVOTE_REGISTRATION_INVALID_STAKING_KEY_PATH"] = "invalid CIP36 registration staking key path";
    InvalidDataReason["CVOTE_REGISTRATION_INVALID_NONCE"] = "invalid CIP36 registration nonce";
    InvalidDataReason["CVOTE_REGISTRATION_INVALID_VOTING_PURPOSE"] = "invalid CIP36 registration voting purpose";
    InvalidDataReason["CVOTE_REGISTRATION_DELEGATIONS_NOT_ARRAY"] = "CIP36 registration delegations not an array";
    InvalidDataReason["CVOTE_DELEGATION_UNKNOWN_FORMAT"] = "invalid CIP36 delegation format";
    InvalidDataReason["CVOTE_DELEGATION_UNKNOWN_DELEGATION_TYPE"] = "invalid CIP36 delegation type";
    InvalidDataReason["CVOTE_DELEGATION_INVALID_WEIGHT"] = "invalid CIP36 delegation weight";
    InvalidDataReason["CVOTE_DELEGATION_INVALID_PATH"] = "invalid CIP36 delegation path";
    InvalidDataReason["CVOTE_DELEGATION_INVALID_KEY"] = "invalid CIP36 delegation key";
    InvalidDataReason["VALIDITY_INTERVAL_START_INVALID"] = "invalid validity interval start";
    InvalidDataReason["SCRIPT_DATA_HASH_WRONG_LENGTH"] = "script data hash not 32 bytes long";
    InvalidDataReason["COLLATERAL_INPUTS_NOT_ARRAY"] = "collateral inputs not an array";
    InvalidDataReason["REQUIRED_SIGNERS_NOT_ARRAY"] = "required signers not an array";
    InvalidDataReason["VKEY_HASH_WRONG_LENGTH"] = "vkey hash not 28 bytes long";
    InvalidDataReason["UNKNOWN_REQUIRED_SIGNER_TYPE"] = "unknown required signer type";
    InvalidDataReason["REQUIRED_SIGNER_INVALID_PATH"] = "invalid path for required signer";
    InvalidDataReason["COLLATERAL_INPUT_CONTAINS_DATUM"] = "collateral return output contains datum";
    InvalidDataReason["COLLATERAL_INPUT_CONTAINS_REFERENCE_SCRIPT"] = "collateral return output contains reference script";
    InvalidDataReason["TOTAL_COLLATERAL_NOT_VALID"] = "total collateral not valid";
    InvalidDataReason["REFERENCE_INPUTS_NOT_ARRAY"] = "reference inputs not an array";
    InvalidDataReason["VOTING_PROCEDURES_NOT_ARRAY"] = "voting procedures not an array";
    InvalidDataReason["VOTER_VOTES_NOT_ARRAY"] = "voter's votes not an array";
    InvalidDataReason["VOTER_INVALID"] = "invalid voter in voting procedures";
    InvalidDataReason["GOV_ACTION_ID_INVALID_TX_HASH"] = "invalid governance action id tx hash";
    InvalidDataReason["GOV_ACTION_ID_INVALID_INDEX"] = "invalid governance action id index";
    InvalidDataReason["VOTING_PROCEDURES_INVALID_NUMBER_OF_VOTERS"] = "there must be exactly 1 voter in voting procedures";
    InvalidDataReason["VOTING_PROCEDURES_INVALID_NUMBER_OF_VOTES"] = "there must be exactly 1 voting procedure per voter";
    InvalidDataReason["TREASURY_NOT_VALID"] = "treasury amount not valid";
    InvalidDataReason["DONATION_NOT_VALID"] = "treasury donation not valid";
    InvalidDataReason["SIGN_MODE_UNKNOWN"] = "unknown signing mode";
    InvalidDataReason["SIGN_MODE_ORDINARY__POOL_REGISTRATION_NOT_ALLOWED"] = "pool registration not allowed in TransactionSigningMode.ORDINARY_TRANSACTION";
    InvalidDataReason["SIGN_MODE_ORDINARY__CERTIFICATE_STAKE_CREDENTIAL_ONLY_AS_PATH"] = "certificate stake credential must be given as a staking path in TransactionSigningMode.ORDINARY_TRANSACTION";
    InvalidDataReason["SIGN_MODE_ORDINARY__CERTIFICATE_COMMITTEE_COLD_CREDENTIAL_ONLY_AS_PATH"] = "certificate constitutional committee cold credential must be given as a path in TransactionSigningMode.ORDINARY_TRANSACTION";
    InvalidDataReason["SIGN_MODE_ORDINARY__CERTIFICATE_DREP_CREDENTIAL_ONLY_AS_PATH"] = "certificate DRep credential must be given as a path in TransactionSigningMode.ORDINARY_TRANSACTION";
    InvalidDataReason["SIGN_MODE_ORDINARY__WITHDRAWAL_ONLY_AS_PATH"] = "withdrawal must be given as a path in TransactionSigningMode.ORDINARY_TRANSACTION";
    InvalidDataReason["SIGN_MODE_ORDINARY__COLLATERAL_INPUTS_NOT_ALLOWED"] = "collateral inputs not allowed in TransactionSigningMode.ORDINARY_TRANSACTION";
    InvalidDataReason["SIGN_MODE_ORDINARY__COLLATERAL_OUTPUT_NOT_ALLOWED"] = "collateral output not allowed in TransactionSigningMode.ORDINARY_TRANSACTION";
    InvalidDataReason["SIGN_MODE_ORDINARY__TOTAL_COLLATERAL_NOT_ALLOWED"] = "total collateral not allowed in TransactionSigningMode.ORDINARY_TRANSACTION";
    InvalidDataReason["SIGN_MODE_ORDINARY__REFERENCE_INPUTS_NOT_ALLOWED"] = "reference inputs not allowed in TransactionSigningMode.ORDINARY_TRANSACTION";
    InvalidDataReason["SIGN_MODE_ORDINARY__VOTER_ONLY_AS_PATH"] = "voter credential in voting procedures must be given as a path in TransactionSigningMode.ORDINARY_TRANSACTION";
    InvalidDataReason["SIGN_MODE_MULTISIG__POOL_REGISTRATION_NOT_ALLOWED"] = "pool registration not allowed in TransactionSigningMode.MULTISIG_TRANSACTION";
    InvalidDataReason["SIGN_MODE_MULTISIG__POOL_RETIREMENT_NOT_ALLOWED"] = "pool retirement not allowed in TransactionSigningMode.MULTISIG_TRANSACTION";
    InvalidDataReason["SIGN_MODE_MULTISIG__DEVICE_OWNED_ADDRESS_NOT_ALLOWED"] = "outputs given by path not allowed in TransactionSigningMode.MULTISIG_TRANSACTION";
    InvalidDataReason["SIGN_MODE_MULTISIG__CERTIFICATE_CREDENTIAL_ONLY_AS_SCRIPT"] = "certificate credential must be a script hash in TransactionSigningMode.MULTISIG_TRANSACTION";
    InvalidDataReason["SIGN_MODE_MULTISIG__WITHDRAWAL_ONLY_AS_SCRIPT"] = "withdrawal must be a script hash in TransactionSigningMode.MULTISIG_TRANSACTION";
    InvalidDataReason["SIGN_MODE_MULTISIG__COLLATERAL_INPUTS_NOT_ALLOWED"] = "collateral inputs not allowed in TransactionSigningMode.MULTISIG_TRANSACTION";
    InvalidDataReason["SIGN_MODE_MULTISIG__COLLATERAL_OUTPUT_NOT_ALLOWED"] = "collateral output not allowed in TransactionSigningMode.MULTISIG_TRANSACTION";
    InvalidDataReason["SIGN_MODE_MULTISIG__TOTAL_COLLATERAL_NOT_ALLOWED"] = "total collateral not allowed in TransactionSigningMode.MULTISIG_TRANSACTION";
    InvalidDataReason["SIGN_MODE_MULTISIG__REFERENCE_INPUTS_NOT_ALLOWED"] = "reference inputs not allowed in TransactionSigningMode.MULTISIG_TRANSACTION";
    InvalidDataReason["SIGN_MODE_MULTISIG__VOTER_ONLY_AS_SCRIPT"] = "voter credential in voting procedures must be a script hash in TransactionSigningMode.MULTISIG_TRANSACTION";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__INPUT_WITH_PATH_NOT_ALLOWED"] = "inputs with path not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__DEVICE_OWNED_ADDRESS_NOT_ALLOWED"] = "outputs given by path are not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__DATUM_NOT_ALLOWED"] = "datum in outputs not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__REFERENCE_SCRIPT_NOT_ALLOWED"] = "reference script in outputs not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__SINGLE_POOL_REG_CERTIFICATE_REQUIRED"] = "single pool registration certificate is expected in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__THIRD_PARTY_POOL_KEY_REQUIRED"] = "third party pool key is required in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__SINGLE_DEVICE_OWNER_REQUIRED"] = "single device-owned pool owner is expected in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__WITHDRAWALS_NOT_ALLOWED"] = "withdrawals not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__MINT_NOT_ALLOWED"] = "mint not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__SCRIPT_DATA_HASH_NOT_ALLOWED"] = "script data hash not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__COLLATERAL_INPUTS_NOT_ALLOWED"] = "collateral inputs not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__COLLATERAL_OUTPUT_NOT_ALLOWED"] = "reference inputs not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__TOTAL_COLLATERAL_NOT_ALLOWED"] = "total collateral not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__REQUIRED_SIGNERS_NOT_ALLOWED"] = "required signers not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__REFERENCE_INPUTS_NOT_ALLOWED"] = "reference inputs not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__VOTING_PROCEDURES_NOT_ALLOWED"] = "voting procedures not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__TREASURY_NOT_ALLOWED"] = "treasury amount not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OWNER__DONATION_NOT_ALLOWED"] = "treasury donation not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OWNER";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__DATUM_NOT_ALLOWED"] = "datum in outputs not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__REFERENCE_SCRIPT_NOT_ALLOWED"] = "reference script in outputs not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__SINGLE_POOL_REG_CERTIFICATE_REQUIRED"] = "single pool registration certificate is expected in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__DEVICE_OWNED_POOL_KEY_REQUIRED"] = "device owned pool key is required in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__DEVICE_OWNED_POOL_OWNER_NOT_ALLOWED"] = "device-owned pool owner not expected in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__WITHDRAWALS_NOT_ALLOWED"] = "withdrawals not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__MINT_NOT_ALLOWED"] = "mint not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__SCRIPT_DATA_HASH_NOT_ALLOWED"] = "script data hash not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__COLLATERAL_INPUTS_NOT_ALLOWED"] = "collateral inputs not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__COLLATERAL_OUTPUT_NOT_ALLOWED"] = "collateral output not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__TOTAL_COLLATERAL_NOT_ALLOWED"] = "total collateral not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__REQUIRED_SIGNERS_NOT_ALLOWED"] = "required signers not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__REFERENCE_INPUTS_NOT_ALLOWED"] = "reference inputs not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__VOTING_PROCEDURES_NOT_ALLOWED"] = "voting procedures not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__TREASURY_NOT_ALLOWED"] = "treasury amount not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_POOL_OPERATOR__DONATION_NOT_ALLOWED"] = "treasury donation not allowed in TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR";
    InvalidDataReason["SIGN_MODE_PLUTUS__DEVICE_OWNED_ADDRESS_NOT_ALLOWED"] = "outputs given by path not allowed in TransactionSigningMode.PLUTUS_TRANSACTION";
    InvalidDataReason["SIGN_MODE_PLUTUS__POOL_REGISTRATION_NOT_ALLOWED"] = "pool registration not allowed in TransactionSigningMode.PLUTUS_TRANSACTION";
    InvalidDataReason["ADDITIONAL_WITNESSES_NOT_ARRAY"] = "additional witnesses not an array";
    InvalidDataReason["OPERATIONAL_CERTIFICATE_INVALID_KES_KEY"] = "invalid operational certificate kes key";
    InvalidDataReason["OPERATIONAL_CERTIFICATE_INVALID_KES_PERIOD"] = "invalid operational certificate kes period";
    InvalidDataReason["OPERATIONAL_CERTIFICATE_INVALID_ISSUE_COUNTER"] = "invalid operational certificate issue counter";
    InvalidDataReason["OPERATIONAL_CERTIFICATE_INVALID_COLD_KEY_PATH"] = "invalid operational certificate cold key path";
    InvalidDataReason["MESSAGE_DATA_INVALID_WITNESS_PATH"] = "CIP-8 message signing: invalid witness path";
    InvalidDataReason["MESSAGE_DATA_INVALID_MESSAGE_HEX"] = "CIP-8 message signing: invalid message hex string";
    InvalidDataReason["MESSAGE_DATA_LONG_NON_HASHED_MSG"] = "CIP-8 message signing: non-hashed message too long";
    InvalidDataReason["CVOTE_INVALID_VOTECAST_DATA"] = "invalid votecast data for CIP36 vote";
    InvalidDataReason["CVOTE_INVALID_WITNESS"] = "invalid witness for CIP36 vote";
    InvalidDataReason["DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA"] = "invalid native script input";
    InvalidDataReason["DERIVE_NATIVE_SCRIPT_HASH_INVALID_KEY_PATH"] = "invalid key path param";
    InvalidDataReason["DERIVE_NATIVE_SCRIPT_HASH_INVALID_KEY_HASH"] = "invalid key hash param";
    InvalidDataReason["DERIVE_NATIVE_SCRIPT_HASH_SCRIPTS_NOT_AN_ARRAY"] = "invalid scripts - scripts is not an array";
    InvalidDataReason["DERIVE_NATIVE_SCRIPT_HASH_INVALID_REQUIRED_COUNT"] = "invalid required count";
    InvalidDataReason["DERIVE_NATIVE_SCRIPT_HASH_INVALID_TOKEN_LOCKING_SLOT"] = "invalid token locking slot";
    InvalidDataReason["DERIVE_NATIVE_SCRIPT_HASH_REQUIRED_COUNT_HIGHER_THAN_NUMBER_OF_SCRIPTS"] = "invalid required count - higher than number of total scripts";
    InvalidDataReason["DERIVE_NATIVE_SCRIPT_HASH_UNKNOWN_TYPE"] = "unknown script type";
    InvalidDataReason["DERIVE_NATIVE_SCRIPT_HASH_INVALID_DISPLAY_FORMAT"] = "invalid native script hash display format";
    InvalidDataReason["LEDGER_POLICY"] = "Action rejected by Ledger's security policy";
    InvalidDataReason["INVALID_DATA_SUPPLIED_TO_LEDGER"] = "Invalid data supplied to Ledger";
    InvalidDataReason["INVALID_B2_HASH"] = "invalid blake2 hashing";
  })(exports2.InvalidDataReason || (exports2.InvalidDataReason = {}));
})(invalidDataReason);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.InvalidDataReason = exports2.DeviceStatusMessages = exports2.DeviceStatusError = exports2.DeviceStatusCodes = exports2.DeviceVersionUnsupported = exports2.InvalidData = exports2.ErrorBase = void 0;
  var errorBase_12 = errorBase;
  Object.defineProperty(exports2, "ErrorBase", { enumerable: true, get: function() {
    return errorBase_12.ErrorBase;
  } });
  var invalidData_1 = invalidData;
  Object.defineProperty(exports2, "InvalidData", { enumerable: true, get: function() {
    return invalidData_1.InvalidData;
  } });
  var deviceUnsupported_1 = deviceUnsupported;
  Object.defineProperty(exports2, "DeviceVersionUnsupported", { enumerable: true, get: function() {
    return deviceUnsupported_1.DeviceVersionUnsupported;
  } });
  var deviceStatusError_1 = deviceStatusError;
  Object.defineProperty(exports2, "DeviceStatusCodes", { enumerable: true, get: function() {
    return deviceStatusError_1.DeviceStatusCodes;
  } });
  Object.defineProperty(exports2, "DeviceStatusError", { enumerable: true, get: function() {
    return deviceStatusError_1.DeviceStatusError;
  } });
  Object.defineProperty(exports2, "DeviceStatusMessages", { enumerable: true, get: function() {
    return deviceStatusError_1.DeviceStatusMessages;
  } });
  var invalidDataReason_12 = invalidDataReason;
  Object.defineProperty(exports2, "InvalidDataReason", { enumerable: true, get: function() {
    return invalidDataReason_12.InvalidDataReason;
  } });
})(errors$4);
var deriveAddress$1 = {};
var utils$2 = {};
var address$1 = {};
var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP = {};
for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z);
  if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
  ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
  var b = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
}
function prefixChk(prefix) {
  var chk = 1;
  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) return "Invalid prefix (" + prefix + ")";
    chk = polymodStep(chk) ^ c >> 5;
  }
  chk = polymodStep(chk);
  for (i = 0; i < prefix.length; ++i) {
    var v = prefix.charCodeAt(i);
    chk = polymodStep(chk) ^ v & 31;
  }
  return chk;
}
function encode$1(prefix, words, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix.length + 7 + words.length > LIMIT) throw new TypeError("Exceeds length limit");
  prefix = prefix.toLowerCase();
  var chk = prefixChk(prefix);
  if (typeof chk === "string") throw new Error(chk);
  var result = prefix + "1";
  for (var i = 0; i < words.length; ++i) {
    var x2 = words[i];
    if (x2 >> 5 !== 0) throw new Error("Non 5-bit word");
    chk = polymodStep(chk) ^ x2;
    result += ALPHABET.charAt(x2);
  }
  for (i = 0; i < 6; ++i) {
    chk = polymodStep(chk);
  }
  chk ^= 1;
  for (i = 0; i < 6; ++i) {
    var v = chk >> (5 - i) * 5 & 31;
    result += ALPHABET.charAt(v);
  }
  return result;
}
function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8) return str + " too short";
  if (str.length > LIMIT) return "Exceeds length limit";
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered) return "Mixed-case string " + str;
  str = lowered;
  var split = str.lastIndexOf("1");
  if (split === -1) return "No separator character for " + str;
  if (split === 0) return "Missing prefix for " + str;
  var prefix = str.slice(0, split);
  var wordChars = str.slice(split + 1);
  if (wordChars.length < 6) return "Data too short";
  var chk = prefixChk(prefix);
  if (typeof chk === "string") return chk;
  var words = [];
  for (var i = 0; i < wordChars.length; ++i) {
    var c = wordChars.charAt(i);
    var v = ALPHABET_MAP[c];
    if (v === void 0) return "Unknown character " + c;
    chk = polymodStep(chk) ^ v;
    if (i + 6 >= wordChars.length) continue;
    words.push(v);
  }
  if (chk !== 1) return "Invalid checksum for " + str;
  return { prefix, words };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object") return res;
}
function decode$1(str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object") return res;
  throw new Error(res);
}
function convert(data, inBits, outBits, pad) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i = 0; i < data.length; ++i) {
    value = value << inBits | data[i];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits) return "Excess padding";
    if (value << outBits - bits & maxV) return "Non-zero padding";
  }
  return result;
}
function toWordsUnsafe(bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res)) return res;
}
function toWords(bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res)) return res;
  throw new Error(res);
}
function fromWordsUnsafe(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
}
function fromWords(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe,
  decode: decode$1,
  encode: encode$1,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
var _public = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.NativeScriptHashDisplayFormat = exports2.NativeScriptType = exports2.TransactionSigningMode = exports2.VoteOption = exports2.VoterType = exports2.TxRequiredSignerType = exports2.CIP36VoteDelegationType = exports2.CIP36VoteRegistrationFormat = exports2.TxAuxiliaryDataType = exports2.TxAuxiliaryDataSupplementType = exports2.DRepParamsType = exports2.CredentialParamsType = exports2.PoolRewardAccountType = exports2.PoolOwnerType = exports2.PoolKeyType = exports2.TxOutputDestinationType = exports2.TxOutputFormat = exports2.DatumType = exports2.MessageAddressFieldType = exports2.HARDENED = exports2.CertificateType = exports2.AddressType = void 0;
  (function(AddressType) {
    AddressType[AddressType["BASE_PAYMENT_KEY_STAKE_KEY"] = 0] = "BASE_PAYMENT_KEY_STAKE_KEY";
    AddressType[AddressType["BASE_PAYMENT_SCRIPT_STAKE_KEY"] = 1] = "BASE_PAYMENT_SCRIPT_STAKE_KEY";
    AddressType[AddressType["BASE_PAYMENT_KEY_STAKE_SCRIPT"] = 2] = "BASE_PAYMENT_KEY_STAKE_SCRIPT";
    AddressType[AddressType["BASE_PAYMENT_SCRIPT_STAKE_SCRIPT"] = 3] = "BASE_PAYMENT_SCRIPT_STAKE_SCRIPT";
    AddressType[AddressType["POINTER_KEY"] = 4] = "POINTER_KEY";
    AddressType[AddressType["POINTER_SCRIPT"] = 5] = "POINTER_SCRIPT";
    AddressType[AddressType["ENTERPRISE_KEY"] = 6] = "ENTERPRISE_KEY";
    AddressType[AddressType["ENTERPRISE_SCRIPT"] = 7] = "ENTERPRISE_SCRIPT";
    AddressType[AddressType["BYRON"] = 8] = "BYRON";
    AddressType[AddressType["REWARD_KEY"] = 14] = "REWARD_KEY";
    AddressType[AddressType["REWARD_SCRIPT"] = 15] = "REWARD_SCRIPT";
  })(exports2.AddressType || (exports2.AddressType = {}));
  (function(CertificateType) {
    CertificateType[CertificateType["STAKE_REGISTRATION"] = 0] = "STAKE_REGISTRATION";
    CertificateType[CertificateType["STAKE_DEREGISTRATION"] = 1] = "STAKE_DEREGISTRATION";
    CertificateType[CertificateType["STAKE_DELEGATION"] = 2] = "STAKE_DELEGATION";
    CertificateType[CertificateType["STAKE_POOL_REGISTRATION"] = 3] = "STAKE_POOL_REGISTRATION";
    CertificateType[CertificateType["STAKE_POOL_RETIREMENT"] = 4] = "STAKE_POOL_RETIREMENT";
    CertificateType[CertificateType["STAKE_REGISTRATION_CONWAY"] = 7] = "STAKE_REGISTRATION_CONWAY";
    CertificateType[CertificateType["STAKE_DEREGISTRATION_CONWAY"] = 8] = "STAKE_DEREGISTRATION_CONWAY";
    CertificateType[CertificateType["VOTE_DELEGATION"] = 9] = "VOTE_DELEGATION";
    CertificateType[CertificateType["AUTHORIZE_COMMITTEE_HOT"] = 14] = "AUTHORIZE_COMMITTEE_HOT";
    CertificateType[CertificateType["RESIGN_COMMITTEE_COLD"] = 15] = "RESIGN_COMMITTEE_COLD";
    CertificateType[CertificateType["DREP_REGISTRATION"] = 16] = "DREP_REGISTRATION";
    CertificateType[CertificateType["DREP_DEREGISTRATION"] = 17] = "DREP_DEREGISTRATION";
    CertificateType[CertificateType["DREP_UPDATE"] = 18] = "DREP_UPDATE";
  })(exports2.CertificateType || (exports2.CertificateType = {}));
  exports2.HARDENED = 2147483648;
  (function(MessageAddressFieldType) {
    MessageAddressFieldType["ADDRESS"] = "address";
    MessageAddressFieldType["KEY_HASH"] = "key_hash";
  })(exports2.MessageAddressFieldType || (exports2.MessageAddressFieldType = {}));
  (function(DatumType) {
    DatumType[DatumType["HASH"] = 0] = "HASH";
    DatumType[DatumType["INLINE"] = 1] = "INLINE";
  })(exports2.DatumType || (exports2.DatumType = {}));
  (function(TxOutputFormat) {
    TxOutputFormat[TxOutputFormat["ARRAY_LEGACY"] = 0] = "ARRAY_LEGACY";
    TxOutputFormat[TxOutputFormat["MAP_BABBAGE"] = 1] = "MAP_BABBAGE";
  })(exports2.TxOutputFormat || (exports2.TxOutputFormat = {}));
  (function(TxOutputDestinationType) {
    TxOutputDestinationType["THIRD_PARTY"] = "third_party";
    TxOutputDestinationType["DEVICE_OWNED"] = "device_owned";
  })(exports2.TxOutputDestinationType || (exports2.TxOutputDestinationType = {}));
  (function(PoolKeyType) {
    PoolKeyType["THIRD_PARTY"] = "third_party";
    PoolKeyType["DEVICE_OWNED"] = "device_owned";
  })(exports2.PoolKeyType || (exports2.PoolKeyType = {}));
  (function(PoolOwnerType) {
    PoolOwnerType["THIRD_PARTY"] = "third_party";
    PoolOwnerType["DEVICE_OWNED"] = "device_owned";
  })(exports2.PoolOwnerType || (exports2.PoolOwnerType = {}));
  (function(PoolRewardAccountType) {
    PoolRewardAccountType["THIRD_PARTY"] = "third_party";
    PoolRewardAccountType["DEVICE_OWNED"] = "device_owned";
  })(exports2.PoolRewardAccountType || (exports2.PoolRewardAccountType = {}));
  (function(CredentialParamsType) {
    CredentialParamsType[CredentialParamsType["KEY_PATH"] = 0] = "KEY_PATH";
    CredentialParamsType[CredentialParamsType["KEY_HASH"] = 1] = "KEY_HASH";
    CredentialParamsType[CredentialParamsType["SCRIPT_HASH"] = 2] = "SCRIPT_HASH";
  })(exports2.CredentialParamsType || (exports2.CredentialParamsType = {}));
  (function(DRepParamsType) {
    DRepParamsType[DRepParamsType["KEY_PATH"] = 0] = "KEY_PATH";
    DRepParamsType[DRepParamsType["KEY_HASH"] = 1] = "KEY_HASH";
    DRepParamsType[DRepParamsType["SCRIPT_HASH"] = 2] = "SCRIPT_HASH";
    DRepParamsType[DRepParamsType["ABSTAIN"] = 3] = "ABSTAIN";
    DRepParamsType[DRepParamsType["NO_CONFIDENCE"] = 4] = "NO_CONFIDENCE";
  })(exports2.DRepParamsType || (exports2.DRepParamsType = {}));
  (function(TxAuxiliaryDataSupplementType) {
    TxAuxiliaryDataSupplementType["CIP36_REGISTRATION"] = "cip36_voting_registration";
  })(exports2.TxAuxiliaryDataSupplementType || (exports2.TxAuxiliaryDataSupplementType = {}));
  (function(TxAuxiliaryDataType) {
    TxAuxiliaryDataType["ARBITRARY_HASH"] = "arbitrary_hash";
    TxAuxiliaryDataType["CIP36_REGISTRATION"] = "cip36_registration";
  })(exports2.TxAuxiliaryDataType || (exports2.TxAuxiliaryDataType = {}));
  (function(CIP36VoteRegistrationFormat) {
    CIP36VoteRegistrationFormat["CIP_15"] = "cip_15";
    CIP36VoteRegistrationFormat["CIP_36"] = "cip_36";
  })(exports2.CIP36VoteRegistrationFormat || (exports2.CIP36VoteRegistrationFormat = {}));
  (function(CIP36VoteDelegationType) {
    CIP36VoteDelegationType["PATH"] = "cip36_vote_key_path";
    CIP36VoteDelegationType["KEY"] = "cip36_vote_key_keyHex";
  })(exports2.CIP36VoteDelegationType || (exports2.CIP36VoteDelegationType = {}));
  (function(TxRequiredSignerType) {
    TxRequiredSignerType["PATH"] = "required_signer_path";
    TxRequiredSignerType["HASH"] = "required_signer_hash";
  })(exports2.TxRequiredSignerType || (exports2.TxRequiredSignerType = {}));
  (function(VoterType) {
    VoterType[VoterType["COMMITTEE_KEY_HASH"] = 0] = "COMMITTEE_KEY_HASH";
    VoterType[VoterType["COMMITTEE_KEY_PATH"] = 100] = "COMMITTEE_KEY_PATH";
    VoterType[VoterType["COMMITTEE_SCRIPT_HASH"] = 1] = "COMMITTEE_SCRIPT_HASH";
    VoterType[VoterType["DREP_KEY_HASH"] = 2] = "DREP_KEY_HASH";
    VoterType[VoterType["DREP_KEY_PATH"] = 102] = "DREP_KEY_PATH";
    VoterType[VoterType["DREP_SCRIPT_HASH"] = 3] = "DREP_SCRIPT_HASH";
    VoterType[VoterType["STAKE_POOL_KEY_HASH"] = 4] = "STAKE_POOL_KEY_HASH";
    VoterType[VoterType["STAKE_POOL_KEY_PATH"] = 104] = "STAKE_POOL_KEY_PATH";
  })(exports2.VoterType || (exports2.VoterType = {}));
  (function(VoteOption) {
    VoteOption[VoteOption["NO"] = 0] = "NO";
    VoteOption[VoteOption["YES"] = 1] = "YES";
    VoteOption[VoteOption["ABSTAIN"] = 2] = "ABSTAIN";
  })(exports2.VoteOption || (exports2.VoteOption = {}));
  (function(TransactionSigningMode) {
    TransactionSigningMode["ORDINARY_TRANSACTION"] = "ordinary_transaction";
    TransactionSigningMode["MULTISIG_TRANSACTION"] = "multisig_transaction";
    TransactionSigningMode["POOL_REGISTRATION_AS_OWNER"] = "pool_registration_as_owner";
    TransactionSigningMode["POOL_REGISTRATION_AS_OPERATOR"] = "pool_registration_as_operator";
    TransactionSigningMode["PLUTUS_TRANSACTION"] = "plutus_transaction";
  })(exports2.TransactionSigningMode || (exports2.TransactionSigningMode = {}));
  (function(NativeScriptType) {
    NativeScriptType["PUBKEY_DEVICE_OWNED"] = "pubkey_device_owned";
    NativeScriptType["PUBKEY_THIRD_PARTY"] = "pubkey_third_party";
    NativeScriptType["ALL"] = "all";
    NativeScriptType["ANY"] = "any";
    NativeScriptType["N_OF_K"] = "n_of_k";
    NativeScriptType["INVALID_BEFORE"] = "invalid_before";
    NativeScriptType["INVALID_HEREAFTER"] = "invalid_hereafter";
  })(exports2.NativeScriptType || (exports2.NativeScriptType = {}));
  (function(NativeScriptHashDisplayFormat) {
    NativeScriptHashDisplayFormat["BECH32"] = "bech32";
    NativeScriptHashDisplayFormat["POLICY_ID"] = "policyId";
  })(exports2.NativeScriptHashDisplayFormat || (exports2.NativeScriptHashDisplayFormat = {}));
})(_public);
var assert$1 = {};
Object.defineProperty(assert$1, "__esModule", { value: true });
assert$1.unreachable = assert$1.assert = void 0;
const errorBase_1 = errorBase;
function assert(cond, errMsg) {
  const msg = errMsg ? `: ${errMsg}` : "";
  if (!cond)
    throw new errorBase_1.ErrorBase(`Assertion failed${msg}`);
}
assert$1.assert = assert;
function unreachable(_val) {
  assert(false, "Unreachable code hit");
}
assert$1.unreachable = unreachable;
var parse = {};
var constants$2 = {};
Object.defineProperty(constants$2, "__esModule", { value: true });
constants$2.TOKENS_IN_GROUP_MAX = constants$2.ASSET_GROUPS_MAX = constants$2.POOL_REGISTRATION_RELAYS_MAX = constants$2.POOL_REGISTRATION_OWNERS_MAX = constants$2.MAX_LOVELACE_SUPPLY_STR = void 0;
constants$2.MAX_LOVELACE_SUPPLY_STR = "45 000 000 000.000000".replace(/[ .]/, "");
constants$2.POOL_REGISTRATION_OWNERS_MAX = 1e3;
constants$2.POOL_REGISTRATION_RELAYS_MAX = 1e3;
constants$2.ASSET_GROUPS_MAX = 1e3;
constants$2.TOKENS_IN_GROUP_MAX = 1e3;
var internal = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.NATIVE_SCRIPT_HASH_LENGTH = exports2.ASSET_NAME_LENGTH_MAX = exports2.CVOTE_PUBLIC_KEY_LENGTH = exports2.TOKEN_POLICY_LENGTH = exports2.MAX_DNS_NAME_LENGTH = exports2.MAX_URL_LENGTH = exports2.ANCHOR_HASH_LENGTH = exports2.DATUM_HASH_LENGTH = exports2.SCRIPT_DATA_HASH_LENGTH = exports2.ED25519_SIGNATURE_LENGTH = exports2.REWARD_ACCOUNT_HEX_LENGTH = exports2.VRF_KEY_HASH_LENGTH = exports2.KES_PUBLIC_KEY_LENGTH = exports2.AUXILIARY_DATA_HASH_LENGTH = exports2.TX_HASH_LENGTH = exports2.SCRIPT_HASH_LENGTH = exports2.KEY_HASH_LENGTH = exports2.PUBLIC_KEY_LENGTH = exports2.EXTENDED_PUBLIC_KEY_LENGTH = exports2.NativeScriptHashDisplayFormat = exports2.TxOutputFormat = exports2.TxOutputDestinationType = exports2.CIP36VoteDelegationType = exports2.TxAuxiliaryDataType = exports2.TransactionSigningMode = exports2.PoolRewardAccountType = exports2.PoolOwnerType = exports2.PoolKeyType = exports2.NativeScriptType = exports2.DatumType = exports2.CertificateType = exports2.AddressType = void 0;
  const public_12 = _public;
  Object.defineProperty(exports2, "AddressType", { enumerable: true, get: function() {
    return public_12.AddressType;
  } });
  Object.defineProperty(exports2, "CertificateType", { enumerable: true, get: function() {
    return public_12.CertificateType;
  } });
  Object.defineProperty(exports2, "CIP36VoteDelegationType", { enumerable: true, get: function() {
    return public_12.CIP36VoteDelegationType;
  } });
  Object.defineProperty(exports2, "DatumType", { enumerable: true, get: function() {
    return public_12.DatumType;
  } });
  Object.defineProperty(exports2, "NativeScriptType", { enumerable: true, get: function() {
    return public_12.NativeScriptType;
  } });
  Object.defineProperty(exports2, "PoolKeyType", { enumerable: true, get: function() {
    return public_12.PoolKeyType;
  } });
  Object.defineProperty(exports2, "PoolOwnerType", { enumerable: true, get: function() {
    return public_12.PoolOwnerType;
  } });
  Object.defineProperty(exports2, "PoolRewardAccountType", { enumerable: true, get: function() {
    return public_12.PoolRewardAccountType;
  } });
  Object.defineProperty(exports2, "TransactionSigningMode", { enumerable: true, get: function() {
    return public_12.TransactionSigningMode;
  } });
  Object.defineProperty(exports2, "TxAuxiliaryDataType", { enumerable: true, get: function() {
    return public_12.TxAuxiliaryDataType;
  } });
  Object.defineProperty(exports2, "TxOutputDestinationType", { enumerable: true, get: function() {
    return public_12.TxOutputDestinationType;
  } });
  Object.defineProperty(exports2, "TxOutputFormat", { enumerable: true, get: function() {
    return public_12.TxOutputFormat;
  } });
  var public_2 = _public;
  Object.defineProperty(exports2, "NativeScriptHashDisplayFormat", { enumerable: true, get: function() {
    return public_2.NativeScriptHashDisplayFormat;
  } });
  exports2.EXTENDED_PUBLIC_KEY_LENGTH = 64;
  exports2.PUBLIC_KEY_LENGTH = 32;
  exports2.KEY_HASH_LENGTH = 28;
  exports2.SCRIPT_HASH_LENGTH = 28;
  exports2.TX_HASH_LENGTH = 32;
  exports2.AUXILIARY_DATA_HASH_LENGTH = 32;
  exports2.KES_PUBLIC_KEY_LENGTH = 32;
  exports2.VRF_KEY_HASH_LENGTH = 32;
  exports2.REWARD_ACCOUNT_HEX_LENGTH = 29;
  exports2.ED25519_SIGNATURE_LENGTH = 64;
  exports2.SCRIPT_DATA_HASH_LENGTH = 32;
  exports2.DATUM_HASH_LENGTH = 32;
  exports2.ANCHOR_HASH_LENGTH = 32;
  exports2.MAX_URL_LENGTH = 128;
  exports2.MAX_DNS_NAME_LENGTH = 128;
  exports2.TOKEN_POLICY_LENGTH = 28;
  exports2.CVOTE_PUBLIC_KEY_LENGTH = 32;
  exports2.ASSET_NAME_LENGTH_MAX = 32;
  exports2.NATIVE_SCRIPT_HASH_LENGTH = 28;
})(internal);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.parseAnchor = exports2.parseCredential = exports2.parseCoin = exports2.parseIntFromStr = exports2.parseBIP32Path = exports2.parseUint8_t = exports2.parseUint16_t = exports2.parseUint32_t = exports2.parseUint64_str = exports2.parseInt64_str = exports2.parseHexStringOfLength = exports2.parseHexString = exports2.parseAscii = exports2.validate = exports2.isInt64Bigint = exports2.isInt64Number = exports2.isInt64str = exports2.isIntStr = exports2.isUint64Bigint = exports2.isUint64Number = exports2.isUint64str = exports2.isUintStr = exports2.isValidPath = exports2.isHexStringOfLength = exports2.isHexString = exports2.isUint8 = exports2.isUint16 = exports2.isUint32 = exports2.isBuffer = exports2.isArray = exports2.isInteger = exports2.isString = exports2.MAX_INT_64_STR = exports2.MIN_INT_64_STR = exports2.MAX_UINT_64_STR = void 0;
  const constants_12 = constants$2;
  const index_1 = errors$4;
  const internal_12 = internal;
  const public_12 = _public;
  const assert_12 = assert$1;
  exports2.MAX_UINT_64_STR = "18446744073709551615";
  exports2.MIN_INT_64_STR = "-9223372036854775808";
  exports2.MAX_INT_64_STR = "9223372036854775807";
  const isString = (data) => typeof data === "string";
  exports2.isString = isString;
  const isInteger = (data) => Number.isInteger(data);
  exports2.isInteger = isInteger;
  const isArray = (data) => Array.isArray(data);
  exports2.isArray = isArray;
  const isBuffer = (data) => Buffer$1.isBuffer(data);
  exports2.isBuffer = isBuffer;
  const isUint32 = (data) => (0, exports2.isInteger)(data) && data >= 0 && data <= 4294967295;
  exports2.isUint32 = isUint32;
  const isUint16 = (data) => (0, exports2.isInteger)(data) && data >= 0 && data <= 65535;
  exports2.isUint16 = isUint16;
  const isUint8 = (data) => (0, exports2.isInteger)(data) && data >= 0 && data <= 255;
  exports2.isUint8 = isUint8;
  const isHexString = (data) => (0, exports2.isString)(data) && data.length % 2 === 0 && /^[0-9a-fA-F]*$/.test(data);
  exports2.isHexString = isHexString;
  const isHexStringOfLength = (data, expectedByteLength) => (0, exports2.isHexString)(data) && data.length === expectedByteLength * 2;
  exports2.isHexStringOfLength = isHexStringOfLength;
  const isValidPath = (data) => (0, exports2.isArray)(data) && data.every((x2) => (0, exports2.isUint32)(x2)) && data.length <= 5;
  exports2.isValidPath = isValidPath;
  const isUintStr = (data, constraints) => {
    var _a, _b;
    const min = (_a = constraints.min) !== null && _a !== void 0 ? _a : "0";
    const max = (_b = constraints.max) !== null && _b !== void 0 ? _b : exports2.MAX_UINT_64_STR;
    return (0, exports2.isString)(data) && /^[0-9]*$/.test(data) && data.length > 0 && data.length <= max.length && (data.length === 1 || data[0] !== "0") && (data.length < max.length || data <= max) && (data.length > min.length || data >= min);
  };
  exports2.isUintStr = isUintStr;
  const isUint64str = (data) => (0, exports2.isUintStr)(data, {});
  exports2.isUint64str = isUint64str;
  const isUint64Number = (data) => (0, exports2.isInteger)(data) && data >= 0 && data <= Number.MAX_SAFE_INTEGER;
  exports2.isUint64Number = isUint64Number;
  const isUint64Bigint = (data) => typeof data === "bigint" && (0, exports2.isUint64str)(data.toString());
  exports2.isUint64Bigint = isUint64Bigint;
  const isIntStr = (data, constraints) => {
    var _a, _b;
    const min = (_a = constraints.min) !== null && _a !== void 0 ? _a : exports2.MIN_INT_64_STR;
    const max = (_b = constraints.max) !== null && _b !== void 0 ? _b : exports2.MAX_INT_64_STR;
    const hasValidFormat = (0, exports2.isString)(data) && /^-?[0-9]*$/.test(data) && data.length > 0;
    const isValidNegativeNumber = (0, exports2.isString)(data) && data.startsWith("-") && (data.length === 2 || data[1] !== "0") && (data.length < min.length || data <= min);
    const isValidPositiveNumber = (0, exports2.isString)(data) && !data.startsWith("-") && (data.length === 1 || data[0] !== "0") && (data.length < max.length || data <= max);
    return hasValidFormat && (isValidNegativeNumber || isValidPositiveNumber);
  };
  exports2.isIntStr = isIntStr;
  const isInt64str = (data) => (0, exports2.isIntStr)(data, {});
  exports2.isInt64str = isInt64str;
  const isInt64Number = (data) => (0, exports2.isInteger)(data) && data >= Number.MIN_SAFE_INTEGER && data <= Number.MAX_SAFE_INTEGER;
  exports2.isInt64Number = isInt64Number;
  const isInt64Bigint = (data) => typeof data === "bigint" && (0, exports2.isInt64str)(data.toString());
  exports2.isInt64Bigint = isInt64Bigint;
  function validate(cond, errMsg) {
    if (!cond)
      throw new index_1.InvalidData(errMsg);
  }
  exports2.validate = validate;
  function parseAscii(str, errMsg) {
    validate((0, exports2.isString)(str), errMsg);
    validate(str.split("").every((c) => c.charCodeAt(0) >= 32 && c.charCodeAt(0) <= 126), errMsg);
    return str;
  }
  exports2.parseAscii = parseAscii;
  function parseHexString(str, errMsg) {
    validate((0, exports2.isHexString)(str), errMsg);
    return str;
  }
  exports2.parseHexString = parseHexString;
  function parseHexStringOfLength(str, length, errMsg) {
    validate((0, exports2.isHexStringOfLength)(str, length), errMsg);
    return str;
  }
  exports2.parseHexStringOfLength = parseHexStringOfLength;
  function parseInt64_str(val, constraints, errMsg) {
    switch (typeof val) {
      case "string":
        validate((0, exports2.isInt64str)(val) && (0, exports2.isIntStr)(val, constraints), errMsg);
        return val;
      case "number":
        validate((0, exports2.isInt64Number)(val) && (0, exports2.isIntStr)(val.toString(), constraints), errMsg);
        return val.toString();
      case "bigint":
        validate((0, exports2.isInt64Bigint)(val) && (0, exports2.isIntStr)(val.toString(), constraints), errMsg);
        return val.toString();
      default:
        validate(false, errMsg);
    }
  }
  exports2.parseInt64_str = parseInt64_str;
  function parseUint64_str(val, constraints, errMsg) {
    switch (typeof val) {
      case "string":
        validate((0, exports2.isUint64str)(val) && (0, exports2.isUintStr)(val, constraints), errMsg);
        return val;
      case "number":
        validate((0, exports2.isUint64Number)(val) && (0, exports2.isUintStr)(val.toString(), constraints), errMsg);
        return val.toString();
      case "bigint":
        validate((0, exports2.isUint64Bigint)(val) && (0, exports2.isUintStr)(val.toString(), constraints), errMsg);
        return val.toString();
      default:
        validate(false, errMsg);
    }
  }
  exports2.parseUint64_str = parseUint64_str;
  function parseUint32_t(value, errMsg) {
    validate((0, exports2.isUint32)(value), errMsg);
    return value;
  }
  exports2.parseUint32_t = parseUint32_t;
  function parseUint16_t(value, errMsg) {
    validate((0, exports2.isUint16)(value), errMsg);
    return value;
  }
  exports2.parseUint16_t = parseUint16_t;
  function parseUint8_t(value, errMsg) {
    validate((0, exports2.isUint8)(value), errMsg);
    return value;
  }
  exports2.parseUint8_t = parseUint8_t;
  function parseBIP32Path(value, errMsg) {
    validate((0, exports2.isValidPath)(value), errMsg);
    return value;
  }
  exports2.parseBIP32Path = parseBIP32Path;
  function parseIntFromStr(str, errMsg) {
    validate((0, exports2.isString)(str), errMsg);
    const i = parseInt(str, 10);
    validate(`${i}` === str, errMsg);
    validate(!isNaN(i), errMsg);
    validate((0, exports2.isInteger)(i), errMsg);
    return i;
  }
  exports2.parseIntFromStr = parseIntFromStr;
  function parseCoin(coin2, errMsg) {
    return parseUint64_str(coin2, { max: constants_12.MAX_LOVELACE_SUPPLY_STR }, errMsg);
  }
  exports2.parseCoin = parseCoin;
  function parseCredential(credential, errMsg) {
    switch (credential.type) {
      case public_12.CredentialParamsType.KEY_PATH:
        return {
          type: 0,
          path: parseBIP32Path(credential.keyPath, errMsg)
        };
      case public_12.CredentialParamsType.KEY_HASH:
        return {
          type: 2,
          keyHashHex: parseHexStringOfLength(credential.keyHashHex, internal_12.KEY_HASH_LENGTH, errMsg)
        };
      case public_12.CredentialParamsType.SCRIPT_HASH:
        return {
          type: 1,
          scriptHashHex: parseHexStringOfLength(credential.scriptHashHex, internal_12.SCRIPT_HASH_LENGTH, errMsg)
        };
      default:
        (0, assert_12.unreachable)(credential);
    }
  }
  exports2.parseCredential = parseCredential;
  function parseAnchor(params2) {
    const url = parseAscii(params2.url, index_1.InvalidDataReason.ANCHOR_INVALID_URL);
    validate(url.length <= internal_12.MAX_URL_LENGTH, index_1.InvalidDataReason.ANCHOR_INVALID_URL);
    const hashHex = parseHexStringOfLength(params2.hashHex, internal_12.ANCHOR_HASH_LENGTH, index_1.InvalidDataReason.ANCHOR_INVALID_HASH);
    return {
      url,
      hashHex,
      __brand: "anchor"
    };
  }
  exports2.parseAnchor = parseAnchor;
})(parse);
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(address$1, "__esModule", { value: true });
address$1.bech32_decodeAddress = address$1.bech32_encodeAddress = address$1.base58_decode = address$1.base58_encode = address$1.str_to_path = void 0;
const base_x_1 = __importDefault$1(src);
const bech32_1 = __importDefault$1(bech32);
const errors_1$f = errors$4;
const public_1$d = _public;
const assert_1$f = assert$1;
const parse_1$d = parse;
const BASE58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const bs58 = (0, base_x_1.default)(BASE58_ALPHABET);
const TESTNET_NETWORK_ID = 0;
function parseBIP32Index(str, errMsg) {
  let base = 0;
  if (str.endsWith("'")) {
    str = str.slice(0, -1);
    base = public_1$d.HARDENED;
  }
  const i = (0, parse_1$d.parseIntFromStr)(str, errMsg);
  (0, parse_1$d.validate)(i >= 0, errMsg);
  (0, parse_1$d.validate)(i < public_1$d.HARDENED, errMsg);
  return base + i;
}
function str_to_path(data) {
  const errMsg = errors_1$f.InvalidDataReason.INVALID_PATH;
  (0, parse_1$d.validate)((0, parse_1$d.isString)(data), errMsg);
  (0, parse_1$d.validate)(data.length > 0, errMsg);
  return data.split("/").map((x2) => {
    return parseBIP32Index(x2, errMsg);
  });
}
address$1.str_to_path = str_to_path;
function base58_encode(data) {
  (0, assert_1$f.assert)((0, parse_1$d.isBuffer)(data), "invalid buffer");
  return bs58.encode(data);
}
address$1.base58_encode = base58_encode;
const isValidBase58 = (data) => (0, parse_1$d.isString)(data) && [...data].every((c) => BASE58_ALPHABET.includes(c));
function base58_decode(data) {
  (0, assert_1$f.assert)(isValidBase58(data), "invalid base58 string");
  return bs58.decode(data);
}
address$1.base58_decode = base58_decode;
function getShelleyAddressPrefix(data) {
  let result = "";
  const addressType = (data[0] & 240) >> 4;
  switch (addressType) {
    case public_1$d.AddressType.REWARD_KEY:
    case public_1$d.AddressType.REWARD_SCRIPT:
      result = "stake";
      break;
    default:
      result = "addr";
  }
  const networkId = data[0] & 15;
  if (networkId === TESTNET_NETWORK_ID) {
    result += "_test";
  }
  return result;
}
function bech32_encodeAddress(data) {
  (0, assert_1$f.assert)((0, parse_1$d.isBuffer)(data), "invalid buffer");
  const data5bit = bech32_1.default.toWords(data);
  const MAX_HUMAN_ADDRESS_LENGTH = 150;
  return bech32_1.default.encode(getShelleyAddressPrefix(data), data5bit, MAX_HUMAN_ADDRESS_LENGTH);
}
address$1.bech32_encodeAddress = bech32_encodeAddress;
function bech32_decodeAddress(data) {
  const { words } = bech32_1.default.decode(data, 1e3);
  return Buffer$1.from(bech32_1.default.fromWords(words));
}
address$1.bech32_decodeAddress = bech32_decodeAddress;
var serialize = {};
var int64Buffer = {};
(function(exports2) {
  !function(exports3) {
    var UNDEFINED = "undefined";
    var BUFFER = UNDEFINED !== typeof Buffer$1 && Buffer$1;
    var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
    var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
    var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
    var isArray = Array.isArray || _isArray;
    var BIT32 = 4294967296;
    var BIT24 = 16777216;
    var storage2;
    factory2("Uint64BE", true, true);
    factory2("Int64BE", true, false);
    factory2("Uint64LE", false, true);
    factory2("Int64LE", false, false);
    function factory2(name, bigendian, unsigned) {
      var posH = bigendian ? 0 : 4;
      var posL = bigendian ? 4 : 0;
      var pos0 = bigendian ? 0 : 3;
      var pos1 = bigendian ? 1 : 2;
      var pos2 = bigendian ? 2 : 1;
      var pos3 = bigendian ? 3 : 0;
      var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
      var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
      var proto = Int64.prototype;
      var isName = "is" + name;
      var _isInt64 = "_" + isName;
      proto.buffer = void 0;
      proto.offset = 0;
      proto[_isInt64] = true;
      proto.toNumber = toNumber;
      proto.toString = toString;
      proto.toJSON = toNumber;
      proto.toArray = toArray;
      if (BUFFER) proto.toBuffer = toBuffer;
      if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;
      Int64[isName] = isInt64;
      exports3[name] = Int64;
      return Int64;
      function Int64(buffer2, offset, value, raddix) {
        if (!(this instanceof Int64)) return new Int64(buffer2, offset, value, raddix);
        return init(this, buffer2, offset, value, raddix);
      }
      function isInt64(b) {
        return !!(b && b[_isInt64]);
      }
      function init(that, buffer2, offset, value, raddix) {
        if (UINT8ARRAY && ARRAYBUFFER) {
          if (buffer2 instanceof ARRAYBUFFER) buffer2 = new UINT8ARRAY(buffer2);
          if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);
        }
        if (!buffer2 && !offset && !value && !storage2) {
          that.buffer = newArray(ZERO, 0);
          return;
        }
        if (!isValidBuffer(buffer2, offset)) {
          var _storage = storage2 || Array;
          raddix = offset;
          value = buffer2;
          offset = 0;
          buffer2 = storage2 === BUFFER ? BUFFER.alloc(8) : new _storage(8);
        }
        that.buffer = buffer2;
        that.offset = offset |= 0;
        if (UNDEFINED === typeof value) return;
        if ("string" === typeof value) {
          fromString(buffer2, offset, value, raddix || 10);
        } else if (isValidBuffer(value, raddix)) {
          fromArray(buffer2, offset, value, raddix);
        } else if ("number" === typeof raddix) {
          writeInt32(buffer2, offset + posH, value);
          writeInt32(buffer2, offset + posL, raddix);
        } else if (value > 0) {
          fromPositive(buffer2, offset, value);
        } else if (value < 0) {
          fromNegative(buffer2, offset, value);
        } else {
          fromArray(buffer2, offset, ZERO, 0);
        }
      }
      function fromString(buffer2, offset, str, raddix) {
        var pos = 0;
        var len = str.length;
        var high = 0;
        var low = 0;
        if (str[0] === "-") pos++;
        var sign = pos;
        while (pos < len) {
          var chr = parseInt(str[pos++], raddix);
          if (!(chr >= 0)) break;
          low = low * raddix + chr;
          high = high * raddix + Math.floor(low / BIT32);
          low %= BIT32;
        }
        if (sign) {
          high = ~high;
          if (low) {
            low = BIT32 - low;
          } else {
            high++;
          }
        }
        writeInt32(buffer2, offset + posH, high);
        writeInt32(buffer2, offset + posL, low);
      }
      function toNumber() {
        var buffer2 = this.buffer;
        var offset = this.offset;
        var high = readInt32(buffer2, offset + posH);
        var low = readInt32(buffer2, offset + posL);
        if (!unsigned) high |= 0;
        return high ? high * BIT32 + low : low;
      }
      function toString(radix) {
        var buffer2 = this.buffer;
        var offset = this.offset;
        var high = readInt32(buffer2, offset + posH);
        var low = readInt32(buffer2, offset + posL);
        var str = "";
        var sign = !unsigned && high & 2147483648;
        if (sign) {
          high = ~high;
          low = BIT32 - low;
        }
        radix = radix || 10;
        while (1) {
          var mod2 = high % radix * BIT32 + low;
          high = Math.floor(high / radix);
          low = Math.floor(mod2 / radix);
          str = (mod2 % radix).toString(radix) + str;
          if (!high && !low) break;
        }
        if (sign) {
          str = "-" + str;
        }
        return str;
      }
      function writeInt32(buffer2, offset, value) {
        buffer2[offset + pos3] = value & 255;
        value = value >> 8;
        buffer2[offset + pos2] = value & 255;
        value = value >> 8;
        buffer2[offset + pos1] = value & 255;
        value = value >> 8;
        buffer2[offset + pos0] = value & 255;
      }
      function readInt32(buffer2, offset) {
        return buffer2[offset + pos0] * BIT24 + (buffer2[offset + pos1] << 16) + (buffer2[offset + pos2] << 8) + buffer2[offset + pos3];
      }
    }
    function toArray(raw) {
      var buffer2 = this.buffer;
      var offset = this.offset;
      storage2 = null;
      if (raw !== false && isArray(buffer2)) {
        return buffer2.length === 8 ? buffer2 : buffer2.slice(offset, offset + 8);
      }
      return newArray(buffer2, offset);
    }
    function toBuffer(raw) {
      var buffer2 = this.buffer;
      var offset = this.offset;
      storage2 = BUFFER;
      if (raw !== false && BUFFER.isBuffer(buffer2)) {
        return buffer2.length === 8 ? buffer2 : buffer2.slice(offset, offset + 8);
      }
      return BUFFER.from(toArrayBuffer.call(this, raw));
    }
    function toArrayBuffer(raw) {
      var buffer2 = this.buffer;
      var offset = this.offset;
      var arrbuf = buffer2.buffer;
      storage2 = UINT8ARRAY;
      if (raw !== false && !buffer2.offset && arrbuf instanceof ARRAYBUFFER) {
        return arrbuf.byteLength === 8 ? arrbuf : arrbuf.slice(offset, offset + 8);
      }
      var dest = new UINT8ARRAY(8);
      fromArray(dest, 0, buffer2, offset);
      return dest.buffer;
    }
    function isValidBuffer(buffer2, offset) {
      var len = buffer2 && buffer2.length;
      offset |= 0;
      return len && offset + 8 <= len && "string" !== typeof buffer2[offset];
    }
    function fromArray(destbuf, destoff, srcbuf, srcoff) {
      destoff |= 0;
      srcoff |= 0;
      for (var i = 0; i < 8; i++) {
        destbuf[destoff++] = srcbuf[srcoff++] & 255;
      }
    }
    function newArray(buffer2, offset) {
      return Array.prototype.slice.call(buffer2, offset, offset + 8);
    }
    function fromPositiveBE(buffer2, offset, value) {
      var pos = offset + 8;
      while (pos > offset) {
        buffer2[--pos] = value & 255;
        value /= 256;
      }
    }
    function fromNegativeBE(buffer2, offset, value) {
      var pos = offset + 8;
      value++;
      while (pos > offset) {
        buffer2[--pos] = -value & 255 ^ 255;
        value /= 256;
      }
    }
    function fromPositiveLE(buffer2, offset, value) {
      var end = offset + 8;
      while (offset < end) {
        buffer2[offset++] = value & 255;
        value /= 256;
      }
    }
    function fromNegativeLE(buffer2, offset, value) {
      var end = offset + 8;
      value++;
      while (offset < end) {
        buffer2[offset++] = -value & 255 ^ 255;
        value /= 256;
      }
    }
    function _isArray(val) {
      return !!val && "[object Array]" == Object.prototype.toString.call(val);
    }
  }(typeof exports2.nodeName !== "string" ? exports2 : commonjsGlobal || {});
})(int64Buffer);
Object.defineProperty(serialize, "__esModule", { value: true });
serialize.serializeAnchor = serialize.serializeCredential = serialize.serializeCoin = serialize.serializeOptionFlag = serialize.path_to_buf = serialize.buf_to_hex = serialize.hex_to_buf = serialize.int64_to_buf = serialize.uint64_to_buf = serialize.buf_to_uint32 = serialize.uint32_to_buf = serialize.buf_to_uint16 = serialize.uint16_to_buf = serialize.uint8_to_buf = void 0;
const int64_buffer_1 = int64Buffer;
const assert_1$e = assert$1;
const parse_1$c = parse;
function uint8_to_buf(value) {
  (0, assert_1$e.assert)((0, parse_1$c.isUint8)(value), "invalid uint8");
  const data = Buffer$1.alloc(1);
  data.writeUInt8(value, 0);
  return data;
}
serialize.uint8_to_buf = uint8_to_buf;
function uint16_to_buf(value) {
  (0, assert_1$e.assert)((0, parse_1$c.isUint16)(value), "invalid uint16");
  const data = Buffer$1.alloc(2);
  data.writeUInt16BE(value, 0);
  return data;
}
serialize.uint16_to_buf = uint16_to_buf;
function buf_to_uint16(data) {
  (0, assert_1$e.assert)(data.length === 2, "invalid uint16 buffer");
  return data.readUIntBE(0, 2);
}
serialize.buf_to_uint16 = buf_to_uint16;
function uint32_to_buf(value) {
  (0, assert_1$e.assert)((0, parse_1$c.isUint32)(value), "invalid uint32");
  const data = Buffer$1.alloc(4);
  data.writeUInt32BE(value, 0);
  return data;
}
serialize.uint32_to_buf = uint32_to_buf;
function buf_to_uint32(data) {
  (0, assert_1$e.assert)(data.length === 4, "invalid uint32 buffer");
  return data.readUIntBE(0, 4);
}
serialize.buf_to_uint32 = buf_to_uint32;
function uint64_to_buf(value) {
  (0, assert_1$e.assert)((0, parse_1$c.isUint64str)(value), "invalid uint64_str");
  const data = new int64_buffer_1.Uint64BE(value, 10).toBuffer();
  (0, assert_1$e.assert)(data.length === 8, "invalid data length");
  return data;
}
serialize.uint64_to_buf = uint64_to_buf;
function int64_to_buf(value) {
  (0, assert_1$e.assert)((0, parse_1$c.isInt64str)(value), "invalid int64_str");
  const data = new int64_buffer_1.Int64BE(value, 10).toBuffer();
  (0, assert_1$e.assert)(data.length === 8, "invalid data length");
  return data;
}
serialize.int64_to_buf = int64_to_buf;
function hex_to_buf(data) {
  (0, assert_1$e.assert)((0, parse_1$c.isHexString)(data), "invalid hex string");
  return Buffer$1.from(data, "hex");
}
serialize.hex_to_buf = hex_to_buf;
function buf_to_hex(data) {
  return data.toString("hex");
}
serialize.buf_to_hex = buf_to_hex;
function path_to_buf(path2) {
  (0, assert_1$e.assert)((0, parse_1$c.isValidPath)(path2), "invalid bip32 path");
  const data = Buffer$1.alloc(1 + 4 * path2.length);
  data.writeUInt8(path2.length, 0);
  for (let i = 0; i < path2.length; i++) {
    data.writeUInt32BE(path2[i], 1 + i * 4);
  }
  return data;
}
serialize.path_to_buf = path_to_buf;
function serializeOptionFlag(included) {
  const SignTxIncluded2 = {
    NO: 1,
    YES: 2
  };
  const value = included ? SignTxIncluded2.YES : SignTxIncluded2.NO;
  return uint8_to_buf(value);
}
serialize.serializeOptionFlag = serializeOptionFlag;
function serializeCoin(coin2) {
  return Buffer$1.concat([uint64_to_buf(coin2)]);
}
serialize.serializeCoin = serializeCoin;
function serializeCredential(credential) {
  switch (credential.type) {
    case 0:
      return Buffer$1.concat([
        uint8_to_buf(credential.type),
        path_to_buf(credential.path)
      ]);
    case 2:
      return Buffer$1.concat([
        uint8_to_buf(credential.type),
        hex_to_buf(credential.keyHashHex)
      ]);
    case 1:
      return Buffer$1.concat([
        uint8_to_buf(credential.type),
        hex_to_buf(credential.scriptHashHex)
      ]);
    default:
      (0, assert_1$e.unreachable)(credential);
  }
}
serialize.serializeCredential = serializeCredential;
function serializeAnchor(anchor) {
  if (anchor == null) {
    return Buffer$1.concat([serializeOptionFlag(false)]);
  } else {
    return Buffer$1.concat([
      serializeOptionFlag(true),
      hex_to_buf(anchor.hashHex),
      Buffer$1.from(anchor.url, "ascii")
    ]);
  }
}
serialize.serializeAnchor = serializeAnchor;
Object.defineProperty(utils$2, "__esModule", { value: true });
utils$2.getVersionString = utils$2.stripRetcodeFromResponse = utils$2.chunkBy = void 0;
const address_1$2 = address$1;
const assert_1$d = assert$1;
const parse_1$b = parse;
const serialize_1$f = serialize;
const sum = (arr) => arr.reduce((x2, y) => x2 + y, 0);
function chunkBy(data, chunkLengths) {
  (0, assert_1$d.assert)((0, parse_1$b.isBuffer)(data), "invalid buffer");
  (0, assert_1$d.assert)((0, parse_1$b.isArray)(chunkLengths), "invalid chunks");
  for (const len of chunkLengths) {
    (0, assert_1$d.assert)((0, parse_1$b.isInteger)(len), "bad chunk length");
    (0, assert_1$d.assert)(len > 0, "bad chunk length");
  }
  (0, assert_1$d.assert)(data.length <= sum(chunkLengths), "data too short");
  let offset = 0;
  const result = [];
  const restLength = data.length - sum(chunkLengths);
  for (const c of [...chunkLengths, restLength]) {
    result.push(data.slice(offset, offset + c));
    offset += c;
  }
  return result;
}
utils$2.chunkBy = chunkBy;
function stripRetcodeFromResponse(response) {
  (0, assert_1$d.assert)((0, parse_1$b.isBuffer)(response), "invalid buffer");
  (0, assert_1$d.assert)(response.length >= 2, "response too short");
  const L = response.length - 2;
  const retcode = (0, serialize_1$f.buf_to_uint16)(response.slice(L, L + 2));
  (0, assert_1$d.assert)(retcode === 36864, `Invalid retcode ${retcode}`);
  return response.slice(0, L);
}
utils$2.stripRetcodeFromResponse = stripRetcodeFromResponse;
utils$2.default = {
  hex_to_buf: serialize_1$f.hex_to_buf,
  buf_to_hex: serialize_1$f.buf_to_hex,
  assert: assert_1$d.assert,
  base58_encode: address_1$2.base58_encode,
  bech32_encodeAddress: address_1$2.bech32_encodeAddress,
  bech32_decodeAddress: address_1$2.bech32_decodeAddress,
  chunkBy,
  stripRetcodeFromResponse
};
function getVersionString(version2) {
  const xs = version2.flags.isAppXS ? "-NanoS" : "";
  return `${version2.major}.${version2.minor}.${version2.patch}${xs}`;
}
utils$2.getVersionString = getVersionString;
var getVersion$1 = {};
Object.defineProperty(getVersion$1, "__esModule", { value: true });
getVersion$1.ensureLedgerAppVersionCompatible = getVersion$1.getCompatibility = getVersion$1.isLedgerAppVersionAtMost = getVersion$1.isLedgerAppVersionAtLeast = getVersion$1.getVersion = void 0;
const errors_1$e = errors$4;
const utils_1$9 = utils$2;
const send$a = (params2) => Object.assign({ ins: 0 }, params2);
function* getVersion() {
  const P1_UNUSED = 0;
  const P2_UNUSED = 0;
  const response = yield send$a({
    p1: P1_UNUSED,
    p2: P2_UNUSED,
    data: Buffer$1.alloc(0),
    expectedResponseLength: 4
  });
  const [major2, minor2, patch2, flags_value] = response;
  const FLAG_IS_DEBUG = 1;
  const FLAG_IS_APP_XS = 4;
  const flags = {
    isDebug: (flags_value & FLAG_IS_DEBUG) === FLAG_IS_DEBUG,
    isAppXS: (flags_value & FLAG_IS_APP_XS) === FLAG_IS_APP_XS
  };
  return { major: major2, minor: minor2, patch: patch2, flags };
}
getVersion$1.getVersion = getVersion;
function isLedgerAppVersionAtLeast(version2, minMajor, minMinor) {
  const { major: major2, minor: minor2 } = version2;
  return major2 > minMajor || major2 === minMajor && minor2 >= minMinor;
}
getVersion$1.isLedgerAppVersionAtLeast = isLedgerAppVersionAtLeast;
function isLedgerAppVersionAtMost(version2, maxMajor, maxMinor) {
  const { major: major2, minor: minor2 } = version2;
  return major2 < maxMajor || major2 === maxMajor && minor2 <= maxMinor;
}
getVersion$1.isLedgerAppVersionAtMost = isLedgerAppVersionAtMost;
function getCompatibility(version2) {
  const v2_2 = isLedgerAppVersionAtLeast(version2, 2, 2) && isLedgerAppVersionAtMost(version2, 7, Infinity);
  const v2_3 = isLedgerAppVersionAtLeast(version2, 2, 3) && isLedgerAppVersionAtMost(version2, 7, Infinity);
  const v2_4 = isLedgerAppVersionAtLeast(version2, 2, 4) && isLedgerAppVersionAtMost(version2, 7, Infinity);
  const v3_0 = isLedgerAppVersionAtLeast(version2, 3, 0) && isLedgerAppVersionAtMost(version2, 7, Infinity);
  const v4_0 = isLedgerAppVersionAtLeast(version2, 4, 0) && isLedgerAppVersionAtMost(version2, 7, Infinity);
  const v4_1 = isLedgerAppVersionAtLeast(version2, 4, 1) && isLedgerAppVersionAtMost(version2, 7, Infinity);
  const v5_0 = isLedgerAppVersionAtLeast(version2, 5, 0) && isLedgerAppVersionAtMost(version2, 7, Infinity);
  const v6_0 = isLedgerAppVersionAtLeast(version2, 6, 0) && isLedgerAppVersionAtMost(version2, 7, Infinity);
  const v7_0 = isLedgerAppVersionAtLeast(version2, 7, 0) && isLedgerAppVersionAtMost(version2, 7, Infinity);
  const v7_1 = isLedgerAppVersionAtLeast(version2, 7, 1) && isLedgerAppVersionAtMost(version2, 7, Infinity);
  const isAppXS = version2.flags.isAppXS;
  return {
    isCompatible: v2_2,
    recommendedVersion: v2_2 ? null : "7.0",
    supportsByronAddressDerivation: v2_2 && !isAppXS,
    supportsMary: v2_2,
    supportsCatalystRegistration: v2_3,
    supportsCIP36: v6_0,
    supportsZeroTtl: v2_3,
    supportsPoolRegistrationAsOwner: v2_2 && !isAppXS,
    supportsPoolRegistrationAsOperator: v2_4 && !isAppXS,
    supportsPoolRetirement: v2_4 && !isAppXS,
    supportsNativeScriptHashDerivation: v3_0 && !isAppXS,
    supportsMultisigTransaction: v3_0,
    supportsMint: v3_0,
    supportsAlonzo: v4_0,
    supportsReqSignersInOrdinaryTx: v4_1,
    supportsBabbage: v5_0,
    supportsCIP36Vote: v6_0,
    supportsConway: v7_0,
    supportsMessageSigning: v7_1
  };
}
getVersion$1.getCompatibility = getCompatibility;
function ensureLedgerAppVersionCompatible(version2) {
  const { isCompatible, recommendedVersion } = getCompatibility(version2);
  if (!isCompatible) {
    throw new errors_1$e.DeviceVersionUnsupported(`Device app version ${(0, utils_1$9.getVersionString)(version2)} unsupported, recommended version is ${recommendedVersion}.`);
  }
}
getVersion$1.ensureLedgerAppVersionCompatible = ensureLedgerAppVersionCompatible;
var addressParams = {};
Object.defineProperty(addressParams, "__esModule", { value: true });
addressParams.serializeAddressParams = void 0;
const errors_1$d = errors$4;
const invalidDataReason_1$a = invalidDataReason;
const internal_1$i = internal;
const utils_1$8 = utils$2;
const assert_1$c = assert$1;
const serialize_1$e = serialize;
const getVersion_1$c = getVersion$1;
function serializeSpendingDataSource(dataSource) {
  switch (dataSource.type) {
    case "spending_path":
      return (0, serialize_1$e.path_to_buf)(dataSource.path);
    case "spending_script_hash":
      return (0, serialize_1$e.hex_to_buf)(dataSource.scriptHashHex);
    case "no_spending":
      return Buffer$1.alloc(0);
    default:
      (0, assert_1$c.unreachable)(dataSource);
  }
}
function serializeStakingDataSource(dataSource) {
  const stakingChoicesEncoding = {
    ["no_staking"]: 17,
    ["staking_key_path"]: 34,
    ["staking_key_hash"]: 51,
    ["blockchain_pointer"]: 68,
    ["staking_script_hash"]: 85
  };
  switch (dataSource.type) {
    case "no_staking": {
      return Buffer$1.concat([
        (0, serialize_1$e.uint8_to_buf)(stakingChoicesEncoding[dataSource.type])
      ]);
    }
    case "staking_key_hash": {
      return Buffer$1.concat([
        (0, serialize_1$e.uint8_to_buf)(stakingChoicesEncoding[dataSource.type]),
        (0, serialize_1$e.hex_to_buf)(dataSource.keyHashHex)
      ]);
    }
    case "staking_script_hash": {
      return Buffer$1.concat([
        (0, serialize_1$e.uint8_to_buf)(stakingChoicesEncoding[dataSource.type]),
        (0, serialize_1$e.hex_to_buf)(dataSource.scriptHashHex)
      ]);
    }
    case "staking_key_path": {
      return Buffer$1.concat([
        (0, serialize_1$e.uint8_to_buf)(stakingChoicesEncoding[dataSource.type]),
        (0, serialize_1$e.path_to_buf)(dataSource.path)
      ]);
    }
    case "blockchain_pointer": {
      return Buffer$1.concat([
        (0, serialize_1$e.uint8_to_buf)(stakingChoicesEncoding[dataSource.type]),
        (0, serialize_1$e.uint32_to_buf)(dataSource.pointer.blockIndex),
        (0, serialize_1$e.uint32_to_buf)(dataSource.pointer.txIndex),
        (0, serialize_1$e.uint32_to_buf)(dataSource.pointer.certificateIndex)
      ]);
    }
    default:
      (0, assert_1$c.unreachable)(dataSource);
  }
}
function serializeAddressParams(params2, version2) {
  let spending = params2.spendingDataSource;
  let staking = params2.stakingDataSource;
  if (!(0, getVersion_1$c.getCompatibility)(version2).supportsMultisigTransaction) {
    if (params2.type === internal_1$i.AddressType.REWARD_KEY) {
      (0, assert_1$c.assert)(staking.type === "staking_key_path", invalidDataReason_1$a.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
      spending = {
        type: "spending_path",
        path: staking.path
      };
      staking = {
        type: "no_staking"
      };
    } else if (params2.type === internal_1$i.AddressType.REWARD_SCRIPT) {
      throw new errors_1$d.DeviceVersionUnsupported(`Scripthash based address derivation not supported by Ledger app version ${(0, utils_1$8.getVersionString)(version2)}.`);
    }
  }
  return Buffer$1.concat([
    (0, serialize_1$e.uint8_to_buf)(params2.type),
    params2.type === internal_1$i.AddressType.BYRON ? (0, serialize_1$e.uint32_to_buf)(params2.protocolMagic) : (0, serialize_1$e.uint8_to_buf)(params2.networkId),
    serializeSpendingDataSource(spending),
    serializeStakingDataSource(staking)
  ]);
}
addressParams.serializeAddressParams = serializeAddressParams;
Object.defineProperty(deriveAddress$1, "__esModule", { value: true });
deriveAddress$1.deriveAddress = deriveAddress$1.ensureAddressDerivationSupportedByAppVersion = void 0;
const errors_1$c = errors$4;
const utils_1$7 = utils$2;
const public_1$c = _public;
const getVersion_1$b = getVersion$1;
const addressParams_1$3 = addressParams;
const send$9 = (params2) => Object.assign({ ins: 17 }, params2);
function ensureAddressDerivationSupportedByAppVersion(version2, addressParams2) {
  (0, getVersion_1$b.ensureLedgerAppVersionCompatible)(version2);
  if (addressParams2.type === public_1$c.AddressType.BYRON && !(0, getVersion_1$b.getCompatibility)(version2).supportsByronAddressDerivation) {
    throw new errors_1$c.DeviceVersionUnsupported(`Byron address parameters not supported by Ledger app version ${(0, utils_1$7.getVersionString)(version2)}.`);
  }
}
deriveAddress$1.ensureAddressDerivationSupportedByAppVersion = ensureAddressDerivationSupportedByAppVersion;
function* deriveAddress(version2, addressParams2) {
  ensureAddressDerivationSupportedByAppVersion(version2, addressParams2);
  const P1_RETURN = 1;
  const P2_UNUSED = 0;
  const response = yield send$9({
    p1: P1_RETURN,
    p2: P2_UNUSED,
    data: (0, addressParams_1$3.serializeAddressParams)(addressParams2, version2)
  });
  return {
    addressHex: response.toString("hex")
  };
}
deriveAddress$1.deriveAddress = deriveAddress;
var deriveNativeScriptHash$1 = {};
var nativeScript$1 = {};
Object.defineProperty(nativeScript$1, "__esModule", { value: true });
nativeScript$1.serializeWholeNativeScriptFinish = nativeScript$1.serializeSimpleNativeScript = nativeScript$1.serializeComplexNativeScriptStart = void 0;
const internal_1$h = internal;
const assert_1$b = assert$1;
const serialize_1$d = serialize;
const TYPE_ENCODING = {
  [internal_1$h.NativeScriptType.PUBKEY_DEVICE_OWNED]: 0,
  [internal_1$h.NativeScriptType.PUBKEY_THIRD_PARTY]: 0,
  [internal_1$h.NativeScriptType.ALL]: 1,
  [internal_1$h.NativeScriptType.ANY]: 2,
  [internal_1$h.NativeScriptType.N_OF_K]: 3,
  [internal_1$h.NativeScriptType.INVALID_BEFORE]: 4,
  [internal_1$h.NativeScriptType.INVALID_HEREAFTER]: 5
};
const PUBKEY_TYPE_ENCODING = {
  [internal_1$h.NativeScriptType.PUBKEY_DEVICE_OWNED]: 1,
  [internal_1$h.NativeScriptType.PUBKEY_THIRD_PARTY]: 2
};
const DISPLAY_FORMAT_ENCODING = {
  [internal_1$h.NativeScriptHashDisplayFormat.BECH32]: 1,
  [internal_1$h.NativeScriptHashDisplayFormat.POLICY_ID]: 2
};
function serializeComplexNativeScriptStart(script) {
  switch (script.type) {
    case internal_1$h.NativeScriptType.ALL:
    case internal_1$h.NativeScriptType.ANY:
      return Buffer$1.concat([
        (0, serialize_1$d.uint8_to_buf)(TYPE_ENCODING[script.type]),
        (0, serialize_1$d.uint32_to_buf)(script.params.scripts.length)
      ]);
    case internal_1$h.NativeScriptType.N_OF_K:
      return Buffer$1.concat([
        (0, serialize_1$d.uint8_to_buf)(TYPE_ENCODING[script.type]),
        (0, serialize_1$d.uint32_to_buf)(script.params.scripts.length),
        (0, serialize_1$d.uint32_to_buf)(script.params.requiredCount)
      ]);
    default:
      (0, assert_1$b.unreachable)(script);
  }
}
nativeScript$1.serializeComplexNativeScriptStart = serializeComplexNativeScriptStart;
function serializeSimpleNativeScript(script) {
  switch (script.type) {
    case internal_1$h.NativeScriptType.PUBKEY_DEVICE_OWNED:
      return Buffer$1.concat([
        (0, serialize_1$d.uint8_to_buf)(TYPE_ENCODING[script.type]),
        (0, serialize_1$d.uint8_to_buf)(PUBKEY_TYPE_ENCODING[script.type]),
        (0, serialize_1$d.path_to_buf)(script.params.path)
      ]);
    case internal_1$h.NativeScriptType.PUBKEY_THIRD_PARTY:
      return Buffer$1.concat([
        (0, serialize_1$d.uint8_to_buf)(TYPE_ENCODING[script.type]),
        (0, serialize_1$d.uint8_to_buf)(PUBKEY_TYPE_ENCODING[script.type]),
        (0, serialize_1$d.hex_to_buf)(script.params.keyHashHex)
      ]);
    case internal_1$h.NativeScriptType.INVALID_BEFORE:
      return Buffer$1.concat([
        (0, serialize_1$d.uint8_to_buf)(TYPE_ENCODING[script.type]),
        (0, serialize_1$d.uint64_to_buf)(script.params.slot)
      ]);
    case internal_1$h.NativeScriptType.INVALID_HEREAFTER:
      return Buffer$1.concat([
        (0, serialize_1$d.uint8_to_buf)(TYPE_ENCODING[script.type]),
        (0, serialize_1$d.uint64_to_buf)(script.params.slot)
      ]);
    default:
      (0, assert_1$b.unreachable)(script);
  }
}
nativeScript$1.serializeSimpleNativeScript = serializeSimpleNativeScript;
function serializeWholeNativeScriptFinish(displayFormat) {
  return Buffer$1.concat([(0, serialize_1$d.uint8_to_buf)(DISPLAY_FORMAT_ENCODING[displayFormat])]);
}
nativeScript$1.serializeWholeNativeScriptFinish = serializeWholeNativeScriptFinish;
Object.defineProperty(deriveNativeScriptHash$1, "__esModule", { value: true });
deriveNativeScriptHash$1.deriveNativeScriptHash = void 0;
const errors_1$b = errors$4;
const internal_1$g = internal;
const public_1$b = _public;
const utils_1$6 = utils$2;
const getVersion_1$a = getVersion$1;
const nativeScript_1 = nativeScript$1;
const send$8 = (params2) => Object.assign({ ins: 18 }, params2);
function* deriveScriptHash_startComplexScript(script) {
  yield send$8({
    p1: 1,
    p2: 0,
    data: (0, nativeScript_1.serializeComplexNativeScriptStart)(script),
    expectedResponseLength: 0
  });
}
function* deriveNativeScriptHash_addSimpleScript(script) {
  yield send$8({
    p1: 2,
    p2: 0,
    data: (0, nativeScript_1.serializeSimpleNativeScript)(script),
    expectedResponseLength: 0
  });
}
function isComplexScript(script) {
  switch (script.type) {
    case public_1$b.NativeScriptType.ALL:
    case public_1$b.NativeScriptType.ANY:
    case public_1$b.NativeScriptType.N_OF_K:
      return true;
    default:
      return false;
  }
}
function* deriveNativeScriptHash_addScript(script) {
  if (isComplexScript(script)) {
    yield* deriveScriptHash_startComplexScript(script);
    for (const subscript of script.params.scripts) {
      yield* deriveNativeScriptHash_addScript(subscript);
    }
  } else {
    return yield* deriveNativeScriptHash_addSimpleScript(script);
  }
}
function* deriveNativeScriptHash_finishWholeNativeScript(displayFormat) {
  const response = yield send$8({
    p1: 3,
    p2: 0,
    data: (0, nativeScript_1.serializeWholeNativeScriptFinish)(displayFormat),
    expectedResponseLength: internal_1$g.NATIVE_SCRIPT_HASH_LENGTH
  });
  return {
    scriptHashHex: response.toString("hex")
  };
}
function ensureScriptHashDerivationSupportedByAppVersion(version2) {
  if (!(0, getVersion_1$a.getCompatibility)(version2).supportsNativeScriptHashDerivation) {
    throw new errors_1$b.DeviceVersionUnsupported(`Native script hash derivation not supported by Ledger app version ${(0, utils_1$6.getVersionString)(version2)}.`);
  }
}
function* deriveNativeScriptHash(version2, script, displayFormat) {
  (0, getVersion_1$a.ensureLedgerAppVersionCompatible)(version2);
  ensureScriptHashDerivationSupportedByAppVersion(version2);
  yield* deriveNativeScriptHash_addScript(script);
  const { scriptHashHex } = yield* deriveNativeScriptHash_finishWholeNativeScript(displayFormat);
  return {
    scriptHashHex
  };
}
deriveNativeScriptHash$1.deriveNativeScriptHash = deriveNativeScriptHash;
var getExtendedPublicKeys$1 = {};
Object.defineProperty(getExtendedPublicKeys$1, "__esModule", { value: true });
getExtendedPublicKeys$1.getExtendedPublicKeys = void 0;
const errors_1$a = errors$4;
const internal_1$f = internal;
const public_1$a = _public;
const utils_1$5 = utils$2;
const assert_1$a = assert$1;
const serialize_1$c = serialize;
const getVersion_1$9 = getVersion$1;
function ensureLedgerAppVersionCompatibleForPaths(version2, paths) {
  const voteKeysPresent = paths.some((path2) => path2[0] === 1694 + public_1$a.HARDENED);
  if (voteKeysPresent && !(0, getVersion_1$9.getCompatibility)(version2).supportsCIP36Vote) {
    throw new errors_1$a.DeviceVersionUnsupported(`CIP36 vote keys not supported by Ledger app version ${(0, utils_1$5.getVersionString)(version2)}.`);
  }
}
const send$7 = (params2) => Object.assign({ ins: 16 }, params2);
function* getExtendedPublicKeys(version2, paths) {
  (0, getVersion_1$9.ensureLedgerAppVersionCompatible)(version2);
  ensureLedgerAppVersionCompatibleForPaths(version2, paths);
  const result = [];
  for (let i = 0; i < paths.length; i++) {
    const pathData = Buffer$1.concat([(0, serialize_1$c.path_to_buf)(paths[i])]);
    let response;
    if (i === 0) {
      const remainingKeysData = paths.length > 1 ? (0, serialize_1$c.uint32_to_buf)(paths.length - 1) : Buffer$1.from([]);
      response = yield send$7({
        p1: 0,
        p2: 0,
        data: Buffer$1.concat([pathData, remainingKeysData]),
        expectedResponseLength: internal_1$f.EXTENDED_PUBLIC_KEY_LENGTH
      });
    } else {
      response = yield send$7({
        p1: 1,
        p2: 0,
        data: pathData,
        expectedResponseLength: internal_1$f.EXTENDED_PUBLIC_KEY_LENGTH
      });
    }
    const VKEY_LENGTH = 32;
    const CHAINCODE_LENGTH = 32;
    const [publicKey, chainCode, rest] = (0, utils_1$5.chunkBy)(response, [
      VKEY_LENGTH,
      CHAINCODE_LENGTH
    ]);
    (0, assert_1$a.assert)(rest.length === 0, "invalid response length");
    result.push({
      publicKeyHex: publicKey.toString("hex"),
      chainCodeHex: chainCode.toString("hex")
    });
  }
  return result;
}
getExtendedPublicKeys$1.getExtendedPublicKeys = getExtendedPublicKeys;
var getSerial$1 = {};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(getSerial$1, "__esModule", { value: true });
getSerial$1.getSerial = void 0;
const utils_1$4 = __importDefault(utils$2);
const getVersion_1$8 = getVersion$1;
const send$6 = (params2) => Object.assign({ ins: 1 }, params2);
function* getSerial(version2) {
  (0, getVersion_1$8.ensureLedgerAppVersionCompatible)(version2);
  const P1_UNUSED = 0;
  const P2_UNUSED = 0;
  const response = yield send$6({
    p1: P1_UNUSED,
    p2: P2_UNUSED,
    data: Buffer$1.alloc(0),
    expectedResponseLength: 7
  });
  const serialHex = utils_1$4.default.buf_to_hex(response);
  return { serialHex };
}
getSerial$1.getSerial = getSerial;
var runTests$1 = {};
Object.defineProperty(runTests$1, "__esModule", { value: true });
runTests$1.runTests = void 0;
const send$5 = (params2) => Object.assign({ ins: 240 }, params2);
function* runTests(_version2) {
  yield send$5({
    p1: 0,
    p2: 0,
    data: Buffer$1.alloc(0),
    expectedResponseLength: 0
  });
}
runTests$1.runTests = runTests;
var showAddress$1 = {};
Object.defineProperty(showAddress$1, "__esModule", { value: true });
showAddress$1.showAddress = void 0;
const addressParams_1$2 = addressParams;
const deriveAddress_1 = deriveAddress$1;
const send$4 = (params2) => Object.assign({ ins: 17 }, params2);
function* showAddress(version2, addressParams2) {
  (0, deriveAddress_1.ensureAddressDerivationSupportedByAppVersion)(version2, addressParams2);
  const P1_DISPLAY = 2;
  const P2_UNUSED = 0;
  yield send$4({
    p1: P1_DISPLAY,
    p2: P2_UNUSED,
    data: (0, addressParams_1$2.serializeAddressParams)(addressParams2, version2),
    expectedResponseLength: 0
  });
}
showAddress$1.showAddress = showAddress;
var signCVote$1 = {};
Object.defineProperty(signCVote$1, "__esModule", { value: true });
signCVote$1.signCVote = void 0;
const errors_1$9 = errors$4;
const internal_1$e = internal;
const utils_1$3 = utils$2;
const serialize_1$b = serialize;
const getVersion_1$7 = getVersion$1;
const send$3 = (params2) => Object.assign({ ins: 35 }, params2);
function* signCVote(version2, cVote2) {
  if (!(0, getVersion_1$7.getCompatibility)(version2).supportsCIP36Vote) {
    throw new errors_1$9.DeviceVersionUnsupported(`CIP36 voting not supported by Ledger app version ${(0, utils_1$3.getVersionString)(version2)}.`);
  }
  const MAX_VOTECAST_CHUNK_SIZE = 240;
  const votecastBytes = (0, serialize_1$b.hex_to_buf)(cVote2.voteCastDataHex);
  let start = 0;
  let end = Math.min(votecastBytes.length, start + MAX_VOTECAST_CHUNK_SIZE);
  const initDataBuffer = Buffer$1.concat([
    (0, serialize_1$b.uint32_to_buf)(votecastBytes.length),
    votecastBytes.slice(start, end)
  ]);
  yield send$3({
    p1: 1,
    p2: 0,
    data: initDataBuffer,
    expectedResponseLength: 0
  });
  start = end;
  while (start < votecastBytes.length) {
    end = Math.min(votecastBytes.length, start + MAX_VOTECAST_CHUNK_SIZE);
    yield send$3({
      p1: 2,
      p2: 0,
      data: votecastBytes.slice(start, end),
      expectedResponseLength: 0
    });
    start = end;
  }
  const VOTECAST_HASH_LENGTH = 32;
  const confirmResponse = yield send$3({
    p1: 3,
    p2: 0,
    data: Buffer$1.concat([]),
    expectedResponseLength: VOTECAST_HASH_LENGTH
  });
  const witnessResponse = yield send$3({
    p1: 4,
    p2: 0,
    data: (0, serialize_1$b.path_to_buf)(cVote2.witnessPath),
    expectedResponseLength: internal_1$e.ED25519_SIGNATURE_LENGTH
  });
  return {
    dataHashHex: confirmResponse.toString("hex"),
    witnessPath: cVote2.witnessPath,
    witnessSignatureHex: witnessResponse.toString("hex")
  };
}
signCVote$1.signCVote = signCVote;
var signOperationalCertificate$1 = {};
var operationalCertificate$1 = {};
Object.defineProperty(operationalCertificate$1, "__esModule", { value: true });
operationalCertificate$1.serializeOperationalCertificate = void 0;
const serialize_1$a = serialize;
function serializeOperationalCertificate({ kesPublicKeyHex, kesPeriod, issueCounter, coldKeyPath }) {
  return Buffer$1.concat([
    (0, serialize_1$a.hex_to_buf)(kesPublicKeyHex),
    (0, serialize_1$a.uint64_to_buf)(kesPeriod),
    (0, serialize_1$a.uint64_to_buf)(issueCounter),
    (0, serialize_1$a.path_to_buf)(coldKeyPath)
  ]);
}
operationalCertificate$1.serializeOperationalCertificate = serializeOperationalCertificate;
Object.defineProperty(signOperationalCertificate$1, "__esModule", { value: true });
signOperationalCertificate$1.signOperationalCertificate = void 0;
const errors_1$8 = errors$4;
const internal_1$d = internal;
const utils_1$2 = utils$2;
const getVersion_1$6 = getVersion$1;
const operationalCertificate_1 = operationalCertificate$1;
const send$2 = (params2) => Object.assign({ ins: 34 }, params2);
function* signOperationalCertificate(version2, operationalCertificate2) {
  if (!(0, getVersion_1$6.getCompatibility)(version2).supportsPoolRegistrationAsOperator) {
    throw new errors_1$8.DeviceVersionUnsupported(`Operational certificate signing not supported by Ledger app version ${(0, utils_1$2.getVersionString)(version2)}.`);
  }
  const P1_UNUSED = 0;
  const P2_UNUSED = 0;
  const response = yield send$2({
    p1: P1_UNUSED,
    p2: P2_UNUSED,
    data: (0, operationalCertificate_1.serializeOperationalCertificate)(operationalCertificate2),
    expectedResponseLength: internal_1$d.ED25519_SIGNATURE_LENGTH
  });
  return {
    signatureHex: response.toString("hex")
  };
}
signOperationalCertificate$1.signOperationalCertificate = signOperationalCertificate;
var signMessage$1 = {};
var messageData$1 = {};
Object.defineProperty(messageData$1, "__esModule", { value: true });
messageData$1.serializeMessageDataInit = void 0;
const public_1$9 = _public;
const serialize_1$9 = serialize;
const addressParams_1$1 = addressParams;
function serializeMessageDataInit(version2, msgData) {
  const msgLengthBuffer = (0, serialize_1$9.uint32_to_buf)(msgData.messageHex.length / 2);
  const hashPayloadBuffer = msgData.hashPayload ? (0, serialize_1$9.uint8_to_buf)(1) : (0, serialize_1$9.uint8_to_buf)(0);
  const isAsciiBuffer = msgData.isAscii ? (0, serialize_1$9.uint8_to_buf)(1) : (0, serialize_1$9.uint8_to_buf)(0);
  const addressFieldTypeEncoding = {
    [public_1$9.MessageAddressFieldType.ADDRESS]: 1,
    [public_1$9.MessageAddressFieldType.KEY_HASH]: 2
  };
  const addressFieldTypeBuffer = (0, serialize_1$9.uint8_to_buf)(addressFieldTypeEncoding[msgData.addressFieldType]);
  const addressBuffer = msgData.addressFieldType === public_1$9.MessageAddressFieldType.ADDRESS ? (0, addressParams_1$1.serializeAddressParams)(msgData.address, version2) : Buffer$1.concat([]);
  return Buffer$1.concat([
    msgLengthBuffer,
    (0, serialize_1$9.path_to_buf)(msgData.signingPath),
    hashPayloadBuffer,
    isAsciiBuffer,
    addressFieldTypeBuffer,
    addressBuffer
  ]);
}
messageData$1.serializeMessageDataInit = serializeMessageDataInit;
Object.defineProperty(signMessage$1, "__esModule", { value: true });
signMessage$1.signMessage = void 0;
const serialize_1$8 = serialize;
const errors_1$7 = errors$4;
const internal_1$c = internal;
const utils_1$1 = utils$2;
const getVersion_1$5 = getVersion$1;
const messageData_1 = messageData$1;
const parse_1$a = parse;
const send$1 = (params2) => Object.assign({ ins: 36 }, params2);
function* signMessage(version2, msgData) {
  if (!(0, getVersion_1$5.getCompatibility)(version2).supportsMessageSigning) {
    throw new errors_1$7.DeviceVersionUnsupported(`CIP-8 message signing not supported by Ledger app version ${(0, utils_1$1.getVersionString)(version2)}.`);
  }
  yield send$1({
    p1: 1,
    p2: 0,
    data: (0, messageData_1.serializeMessageDataInit)(version2, msgData),
    expectedResponseLength: 0
  });
  const MAX_CIP8_MSG_FIRST_CHUNK_ASCII_SIZE = 198;
  const MAX_CIP8_MSG_FIRST_CHUNK_HEX_SIZE = 99;
  const MAX_CIP8_MSG_HIDDEN_CHUNK_SIZE = 250;
  const msgBytes = (0, serialize_1$8.hex_to_buf)(msgData.messageHex);
  const getChunkData = (start2, end2) => {
    const chunk = msgBytes.slice(start2, end2);
    return Buffer$1.concat([(0, serialize_1$8.uint32_to_buf)(chunk.length), chunk]);
  };
  const firstChunkSize = msgData.isAscii ? MAX_CIP8_MSG_FIRST_CHUNK_ASCII_SIZE : MAX_CIP8_MSG_FIRST_CHUNK_HEX_SIZE;
  let start = 0;
  let end = Math.min(msgBytes.length, firstChunkSize);
  yield send$1({
    p1: 2,
    p2: 0,
    data: getChunkData(start, end),
    expectedResponseLength: 0
  });
  start = end;
  if (start < msgBytes.length) {
    (0, parse_1$a.validate)(msgData.hashPayload, errors_1$7.InvalidDataReason.MESSAGE_DATA_LONG_NON_HASHED_MSG);
  }
  while (start < msgBytes.length) {
    end = Math.min(msgBytes.length, start + MAX_CIP8_MSG_HIDDEN_CHUNK_SIZE);
    yield send$1({
      p1: 2,
      p2: 0,
      data: getChunkData(start, end),
      expectedResponseLength: 0
    });
    start = end;
  }
  const MAX_ADDRESS_SIZE = 128;
  const confirmResponse = yield send$1({
    p1: 3,
    p2: 0,
    data: Buffer$1.concat([]),
    expectedResponseLength: internal_1$c.ED25519_SIGNATURE_LENGTH + internal_1$c.PUBLIC_KEY_LENGTH + 4 + MAX_ADDRESS_SIZE
  });
  let s = 0;
  const signatureHex = confirmResponse.slice(s, s + internal_1$c.ED25519_SIGNATURE_LENGTH).toString("hex");
  s += internal_1$c.ED25519_SIGNATURE_LENGTH;
  const signingPublicKeyHex = confirmResponse.slice(s, s + internal_1$c.PUBLIC_KEY_LENGTH).toString("hex");
  s += internal_1$c.PUBLIC_KEY_LENGTH;
  const addressFieldSizeBuf = confirmResponse.slice(s, s + 4);
  s += 4;
  const addressFieldSize = (0, serialize_1$8.buf_to_uint32)(addressFieldSizeBuf);
  const addressFieldHex = confirmResponse.slice(s, s + addressFieldSize).toString("hex");
  return {
    signatureHex,
    signingPublicKeyHex,
    addressFieldHex
  };
}
signMessage$1.signMessage = signMessage;
var messageData = {};
var address = {};
var network$1 = {};
Object.defineProperty(network$1, "__esModule", { value: true });
network$1.parseNetwork = void 0;
const invalidDataReason_1$9 = invalidDataReason;
const parse_1$9 = parse;
function parseNetwork(network2) {
  const parsed = {
    protocolMagic: (0, parse_1$9.parseUint32_t)(network2.protocolMagic, invalidDataReason_1$9.InvalidDataReason.NETWORK_INVALID_PROTOCOL_MAGIC),
    networkId: (0, parse_1$9.parseUint8_t)(network2.networkId, invalidDataReason_1$9.InvalidDataReason.NETWORK_INVALID_NETWORK_ID)
  };
  (0, parse_1$9.validate)(parsed.networkId <= 15, invalidDataReason_1$9.InvalidDataReason.NETWORK_INVALID_NETWORK_ID);
  return parsed;
}
network$1.parseNetwork = parseNetwork;
Object.defineProperty(address, "__esModule", { value: true });
address.parseAddress = void 0;
const errors_1$6 = errors$4;
const invalidDataReason_1$8 = invalidDataReason;
const internal_1$b = internal;
const parse_1$8 = parse;
const network_1$1 = network$1;
function extractSpendingDataSource(spendingPath, spendingScriptHash) {
  if (null != spendingPath) {
    (0, parse_1$8.validate)(spendingScriptHash == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_SPENDING_SCRIPT_HASH);
    return {
      type: "spending_path",
      path: (0, parse_1$8.parseBIP32Path)(spendingPath, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_SPENDING_KEY_PATH)
    };
  }
  if (null != spendingScriptHash) {
    (0, parse_1$8.validate)(spendingPath == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_SPENDING_KEY_PATH);
    return {
      type: "spending_script_hash",
      scriptHashHex: (0, parse_1$8.parseHexStringOfLength)(spendingScriptHash, internal_1$b.SCRIPT_HASH_LENGTH, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_SPENDING_SCRIPT_HASH)
    };
  }
  return {
    type: "no_spending"
  };
}
function extractStakingDataSource(stakingPath, stakingKeyHashHex, stakingBlockchainPointer, stakingScriptHashHex) {
  if (null != stakingPath) {
    (0, parse_1$8.validate)(stakingKeyHashHex == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    (0, parse_1$8.validate)(stakingBlockchainPointer == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    (0, parse_1$8.validate)(stakingScriptHashHex == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    const codedStakingPath = (0, parse_1$8.parseBIP32Path)(stakingPath, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_SPENDING_KEY_PATH);
    return {
      type: "staking_key_path",
      path: codedStakingPath
    };
  }
  if (null != stakingKeyHashHex) {
    (0, parse_1$8.validate)(stakingPath == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    (0, parse_1$8.validate)(stakingBlockchainPointer == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    (0, parse_1$8.validate)(stakingScriptHashHex == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    const hashHex = (0, parse_1$8.parseHexStringOfLength)(stakingKeyHashHex, internal_1$b.KEY_HASH_LENGTH, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_KEY_HASH);
    return {
      type: "staking_key_hash",
      keyHashHex: hashHex
    };
  }
  if (null != stakingBlockchainPointer) {
    (0, parse_1$8.validate)(stakingPath == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    (0, parse_1$8.validate)(stakingKeyHashHex == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    (0, parse_1$8.validate)(stakingScriptHashHex == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    const pointer = stakingBlockchainPointer;
    return {
      type: "blockchain_pointer",
      pointer: {
        blockIndex: (0, parse_1$8.parseUint32_t)(pointer.blockIndex, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_BLOCKCHAIN_POINTER),
        txIndex: (0, parse_1$8.parseUint32_t)(pointer.txIndex, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_BLOCKCHAIN_POINTER),
        certificateIndex: (0, parse_1$8.parseUint32_t)(pointer.certificateIndex, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_BLOCKCHAIN_POINTER)
      }
    };
  }
  if (null != stakingScriptHashHex) {
    (0, parse_1$8.validate)(stakingPath == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    (0, parse_1$8.validate)(stakingKeyHashHex == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    (0, parse_1$8.validate)(stakingBlockchainPointer == null, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
    const stakingHash = (0, parse_1$8.parseHexStringOfLength)(stakingScriptHashHex, internal_1$b.SCRIPT_HASH_LENGTH, invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_SCRIPT_HASH);
    return {
      type: "staking_script_hash",
      scriptHashHex: stakingHash
    };
  }
  return {
    type: "no_staking"
  };
}
function validateSpendingDataSource(addressType, spending) {
  switch (addressType) {
    case internal_1$b.AddressType.BASE_PAYMENT_KEY_STAKE_KEY:
    case internal_1$b.AddressType.BASE_PAYMENT_KEY_STAKE_SCRIPT:
    case internal_1$b.AddressType.POINTER_KEY:
    case internal_1$b.AddressType.ENTERPRISE_KEY:
    case internal_1$b.AddressType.BYRON:
      (0, parse_1$8.validate)(spending.type === "spending_path", invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_SPENDING_INFO);
      break;
    case internal_1$b.AddressType.BASE_PAYMENT_SCRIPT_STAKE_KEY:
    case internal_1$b.AddressType.BASE_PAYMENT_SCRIPT_STAKE_SCRIPT:
    case internal_1$b.AddressType.POINTER_SCRIPT:
    case internal_1$b.AddressType.ENTERPRISE_SCRIPT:
      (0, parse_1$8.validate)(spending.type === "spending_script_hash", invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_SPENDING_INFO);
      break;
    case internal_1$b.AddressType.REWARD_KEY:
    case internal_1$b.AddressType.REWARD_SCRIPT:
      (0, parse_1$8.validate)(spending.type === "no_spending", invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_SPENDING_INFO);
      break;
    default:
      throw new errors_1$6.InvalidData(invalidDataReason_1$8.InvalidDataReason.ADDRESS_UNKNOWN_TYPE);
  }
}
function validateStakingDataSource(addressType, staking) {
  switch (addressType) {
    case internal_1$b.AddressType.BASE_PAYMENT_KEY_STAKE_KEY:
    case internal_1$b.AddressType.BASE_PAYMENT_SCRIPT_STAKE_KEY:
    case internal_1$b.AddressType.REWARD_KEY:
      (0, parse_1$8.validate)(staking.type === "staking_key_path" || staking.type === "staking_key_hash", invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
      break;
    case internal_1$b.AddressType.BASE_PAYMENT_SCRIPT_STAKE_SCRIPT:
    case internal_1$b.AddressType.BASE_PAYMENT_KEY_STAKE_SCRIPT:
    case internal_1$b.AddressType.REWARD_SCRIPT:
      (0, parse_1$8.validate)(staking.type === "staking_script_hash", invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
      break;
    case internal_1$b.AddressType.POINTER_KEY:
    case internal_1$b.AddressType.POINTER_SCRIPT:
      (0, parse_1$8.validate)(staking.type === "blockchain_pointer", invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
      break;
    case internal_1$b.AddressType.BYRON:
    case internal_1$b.AddressType.ENTERPRISE_KEY:
    case internal_1$b.AddressType.ENTERPRISE_SCRIPT:
      (0, parse_1$8.validate)(staking.type === "no_staking", invalidDataReason_1$8.InvalidDataReason.ADDRESS_INVALID_STAKING_INFO);
      break;
    default:
      throw new errors_1$6.InvalidData(invalidDataReason_1$8.InvalidDataReason.ADDRESS_UNKNOWN_TYPE);
  }
}
function parseAddress(network2, address2) {
  const parsedNetwork = (0, network_1$1.parseNetwork)(network2);
  const params2 = address2.params;
  const spendingDataSource = extractSpendingDataSource(params2.spendingPath, params2.spendingScriptHashHex);
  const stakingDataSource = extractStakingDataSource(params2.stakingPath, params2.stakingKeyHashHex, params2.stakingBlockchainPointer, params2.stakingScriptHashHex);
  validateSpendingDataSource(address2.type, spendingDataSource);
  validateStakingDataSource(address2.type, stakingDataSource);
  if (address2.type === internal_1$b.AddressType.BYRON) {
    return {
      type: address2.type,
      protocolMagic: parsedNetwork.protocolMagic,
      spendingDataSource,
      stakingDataSource
    };
  } else {
    const networkId = parsedNetwork.networkId;
    return {
      type: address2.type,
      networkId,
      spendingDataSource,
      stakingDataSource
    };
  }
}
address.parseAddress = parseAddress;
Object.defineProperty(messageData, "__esModule", { value: true });
messageData.parseMessageData = void 0;
const assert_1$9 = assert$1;
const invalidDataReason_1$7 = invalidDataReason;
const public_1$8 = _public;
const parse_1$7 = parse;
const address_1$1 = address;
function isPrintableAscii(buffer2) {
  for (let i = 0; i < buffer2.length; i++) {
    if (buffer2[i] > 126)
      return false;
    if (buffer2[i] < 32)
      return false;
  }
  return true;
}
function isAscii$1(msg) {
  const buffer2 = Buffer$1.from(msg, "hex");
  if (buffer2.length === 0)
    return false;
  if (!isPrintableAscii(buffer2))
    return false;
  const space = " ".charCodeAt(0);
  if (buffer2[0] === space)
    return false;
  if (buffer2[buffer2.length - 1] === space)
    return false;
  for (let i = 0; i + 1 < buffer2.length; i++) {
    if (buffer2[i] === space && buffer2[i + 1] === space)
      return false;
  }
  return true;
}
function parseMessageData(data) {
  const preferHexDisplay = data.preferHexDisplay || false;
  const common = {
    signingPath: (0, parse_1$7.parseBIP32Path)(data.signingPath, invalidDataReason_1$7.InvalidDataReason.MESSAGE_DATA_INVALID_WITNESS_PATH),
    isAscii: isAscii$1(data.messageHex) && !preferHexDisplay,
    hashPayload: data.hashPayload,
    messageHex: (0, parse_1$7.parseHexString)(data.messageHex, invalidDataReason_1$7.InvalidDataReason.MESSAGE_DATA_INVALID_MESSAGE_HEX)
  };
  switch (data.addressFieldType) {
    case public_1$8.MessageAddressFieldType.ADDRESS:
      return Object.assign(Object.assign({}, common), { addressFieldType: public_1$8.MessageAddressFieldType.ADDRESS, address: (0, address_1$1.parseAddress)(data.network, data.address) });
    case public_1$8.MessageAddressFieldType.KEY_HASH:
      return Object.assign(Object.assign({}, common), { addressFieldType: public_1$8.MessageAddressFieldType.KEY_HASH });
    default:
      (0, assert_1$9.unreachable)(data);
  }
}
messageData.parseMessageData = parseMessageData;
var signTx = {};
var cVoteRegistration = {};
var txOutput = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.serializeTxOutputRefScript = exports2.serializeTxOutputDatum = exports2.serializeTxOutputBasicParams = exports2.serializeTxOutputDestination = exports2.MAX_CHUNK_SIZE = void 0;
  const internal_12 = internal;
  const public_12 = _public;
  const assert_12 = assert$1;
  const serialize_12 = serialize;
  const getVersion_12 = getVersion$1;
  const addressParams_12 = addressParams;
  exports2.MAX_CHUNK_SIZE = 240;
  function serializeTxOutputDestination(destination, version2) {
    const typeEncoding = {
      [internal_12.TxOutputDestinationType.THIRD_PARTY]: 1,
      [internal_12.TxOutputDestinationType.DEVICE_OWNED]: 2
    };
    switch (destination.type) {
      case internal_12.TxOutputDestinationType.THIRD_PARTY:
        return Buffer$1.concat([
          (0, serialize_12.uint8_to_buf)(typeEncoding[destination.type]),
          (0, serialize_12.uint32_to_buf)(destination.addressHex.length / 2),
          (0, serialize_12.hex_to_buf)(destination.addressHex)
        ]);
      case internal_12.TxOutputDestinationType.DEVICE_OWNED:
        return Buffer$1.concat([
          (0, serialize_12.uint8_to_buf)(typeEncoding[destination.type]),
          (0, addressParams_12.serializeAddressParams)(destination.addressParams, version2)
        ]);
      default:
        (0, assert_12.unreachable)(destination);
    }
  }
  exports2.serializeTxOutputDestination = serializeTxOutputDestination;
  function serializeTxOutputBasicParams(output2, version2) {
    const serializationFormatBuffer = (0, getVersion_12.getCompatibility)(version2).supportsBabbage ? (0, serialize_12.uint8_to_buf)(output2.format) : Buffer$1.from([]);
    const includeDatumBuffer = (0, getVersion_12.getCompatibility)(version2).supportsAlonzo ? (0, serialize_12.serializeOptionFlag)(output2.datum != null) : Buffer$1.from([]);
    const includeScriptBuffer = (0, getVersion_12.getCompatibility)(version2).supportsBabbage ? (0, serialize_12.serializeOptionFlag)(output2.referenceScriptHex != null) : Buffer$1.from([]);
    return Buffer$1.concat([
      serializationFormatBuffer,
      serializeTxOutputDestination(output2.destination, version2),
      (0, serialize_12.serializeCoin)(output2.amount),
      (0, serialize_12.uint32_to_buf)(output2.tokenBundle.length),
      includeDatumBuffer,
      includeScriptBuffer
    ]);
  }
  exports2.serializeTxOutputBasicParams = serializeTxOutputBasicParams;
  function serializeTxOutputDatum(datum, version2) {
    switch (datum.type) {
      case public_12.DatumType.HASH: {
        const datumHashBuffer = (0, getVersion_12.getCompatibility)(version2).supportsBabbage ? (0, serialize_12.uint8_to_buf)(public_12.DatumType.HASH) : Buffer$1.concat([]);
        return Buffer$1.concat([datumHashBuffer, (0, serialize_12.hex_to_buf)(datum.datumHashHex)]);
      }
      case public_12.DatumType.INLINE: {
        const totalDatumSize = datum.datumHex.length / 2;
        let chunkHex;
        if (totalDatumSize > exports2.MAX_CHUNK_SIZE) {
          chunkHex = datum.datumHex.substring(0, exports2.MAX_CHUNK_SIZE * 2);
        } else {
          chunkHex = datum.datumHex;
        }
        const chunkSize = chunkHex.length / 2;
        return Buffer$1.concat([
          (0, serialize_12.uint8_to_buf)(public_12.DatumType.INLINE),
          (0, serialize_12.uint32_to_buf)(totalDatumSize),
          (0, serialize_12.uint32_to_buf)(chunkSize),
          (0, serialize_12.hex_to_buf)(chunkHex)
        ]);
      }
      default:
        return (0, assert_12.unreachable)(datum);
    }
  }
  exports2.serializeTxOutputDatum = serializeTxOutputDatum;
  function serializeTxOutputRefScript(referenceScriptHex) {
    const totalScriptSize = referenceScriptHex.length / 2;
    let chunkHex;
    if (totalScriptSize > exports2.MAX_CHUNK_SIZE) {
      chunkHex = referenceScriptHex.substring(0, exports2.MAX_CHUNK_SIZE * 2);
    } else {
      chunkHex = referenceScriptHex;
    }
    const chunkSize = chunkHex.length / 2;
    return Buffer$1.concat([
      (0, serialize_12.uint32_to_buf)(totalScriptSize),
      (0, serialize_12.uint32_to_buf)(chunkSize),
      (0, serialize_12.hex_to_buf)(chunkHex)
    ]);
  }
  exports2.serializeTxOutputRefScript = serializeTxOutputRefScript;
})(txOutput);
Object.defineProperty(cVoteRegistration, "__esModule", { value: true });
cVoteRegistration.serializeCVoteRegistrationVotingPurpose = cVoteRegistration.serializeCVoteRegistrationNonce = cVoteRegistration.serializeCVoteRegistrationPaymentDestination = cVoteRegistration.serializeCVoteRegistrationStakingPath = cVoteRegistration.serializeCVoteRegistrationDelegation = cVoteRegistration.serializeCVoteRegistrationVoteKey = cVoteRegistration.serializeCVoteRegistrationInit = void 0;
const getVersion_1$4 = getVersion$1;
const public_1$7 = _public;
const assert_1$8 = assert$1;
const serialize_1$7 = serialize;
const addressParams_1 = addressParams;
const txOutput_1$1 = txOutput;
function serializeCVoteRegistrationInit(params2) {
  const registrationFormatEncoding = {
    [public_1$7.CIP36VoteRegistrationFormat.CIP_15]: 1,
    [public_1$7.CIP36VoteRegistrationFormat.CIP_36]: 2
  };
  const formatBuffer = (0, serialize_1$7.uint8_to_buf)(registrationFormatEncoding[params2.format]);
  const numDelegations = params2.delegations != null ? params2.delegations.length : 0;
  const numDelegationsBuffer = (0, serialize_1$7.uint32_to_buf)(numDelegations);
  return Buffer$1.concat([
    formatBuffer,
    numDelegationsBuffer
  ]);
}
cVoteRegistration.serializeCVoteRegistrationInit = serializeCVoteRegistrationInit;
function serializeDelegationType(type2) {
  const delegationTypeEncoding = {
    [public_1$7.CIP36VoteDelegationType.KEY]: 1,
    [public_1$7.CIP36VoteDelegationType.PATH]: 2
  };
  return (0, serialize_1$7.uint8_to_buf)(delegationTypeEncoding[type2]);
}
function serializeCVoteRegistrationVoteKey(votePublicKey, votePublicKeyPath, version2) {
  if (votePublicKey != null) {
    (0, assert_1$8.assert)(votePublicKeyPath == null, "redundant vote key path");
    const delegationTypeBuffer = (0, getVersion_1$4.getCompatibility)(version2).supportsCIP36 ? serializeDelegationType(public_1$7.CIP36VoteDelegationType.KEY) : Buffer$1.from([]);
    return Buffer$1.concat([delegationTypeBuffer, (0, serialize_1$7.hex_to_buf)(votePublicKey)]);
  } else {
    (0, assert_1$8.assert)(votePublicKeyPath != null, "missing vote key");
    (0, assert_1$8.assert)((0, getVersion_1$4.getCompatibility)(version2).supportsCIP36Vote, "key derivation path for vote keys not supported by the device");
    return Buffer$1.concat([
      serializeDelegationType(public_1$7.CIP36VoteDelegationType.PATH),
      (0, serialize_1$7.path_to_buf)(votePublicKeyPath)
    ]);
  }
}
cVoteRegistration.serializeCVoteRegistrationVoteKey = serializeCVoteRegistrationVoteKey;
function serializeCVoteRegistrationDelegation(delegation) {
  const typeBuffer = serializeDelegationType(delegation.type);
  const weightBuffer = (0, serialize_1$7.uint32_to_buf)(delegation.weight);
  switch (delegation.type) {
    case public_1$7.CIP36VoteDelegationType.KEY:
      return Buffer$1.concat([
        typeBuffer,
        (0, serialize_1$7.hex_to_buf)(delegation.voteKey),
        weightBuffer
      ]);
    case public_1$7.CIP36VoteDelegationType.PATH:
      return Buffer$1.concat([
        typeBuffer,
        (0, serialize_1$7.path_to_buf)(delegation.voteKeyPath),
        weightBuffer
      ]);
    default:
      (0, assert_1$8.unreachable)(delegation);
  }
}
cVoteRegistration.serializeCVoteRegistrationDelegation = serializeCVoteRegistrationDelegation;
function serializeCVoteRegistrationStakingPath(stakingPath) {
  return Buffer$1.concat([(0, serialize_1$7.path_to_buf)(stakingPath)]);
}
cVoteRegistration.serializeCVoteRegistrationStakingPath = serializeCVoteRegistrationStakingPath;
function serializeCVoteRegistrationPaymentDestination(paymentDestination, version2) {
  if ((0, getVersion_1$4.getCompatibility)(version2).supportsCIP36) {
    return (0, txOutput_1$1.serializeTxOutputDestination)(paymentDestination, version2);
  } else {
    (0, assert_1$8.assert)(paymentDestination.type === public_1$7.TxOutputDestinationType.DEVICE_OWNED, "wrong destination for payment address in Catalyst");
    return (0, addressParams_1.serializeAddressParams)(paymentDestination.addressParams, version2);
  }
}
cVoteRegistration.serializeCVoteRegistrationPaymentDestination = serializeCVoteRegistrationPaymentDestination;
function serializeCVoteRegistrationNonce(nonce) {
  return Buffer$1.concat([(0, serialize_1$7.uint64_to_buf)(nonce)]);
}
cVoteRegistration.serializeCVoteRegistrationNonce = serializeCVoteRegistrationNonce;
function serializeCVoteRegistrationVotingPurpose(votingPurpose) {
  const includeVotingPurposeBuffer = (0, serialize_1$7.serializeOptionFlag)(votingPurpose != null);
  const votingPurposeBuffer = votingPurpose != null ? (0, serialize_1$7.uint64_to_buf)(votingPurpose) : Buffer$1.from([]);
  return Buffer$1.concat([
    includeVotingPurposeBuffer,
    votingPurposeBuffer
  ]);
}
cVoteRegistration.serializeCVoteRegistrationVotingPurpose = serializeCVoteRegistrationVotingPurpose;
var poolRegistrationCertificate = {};
Object.defineProperty(poolRegistrationCertificate, "__esModule", { value: true });
poolRegistrationCertificate.serializePoolMetadata = poolRegistrationCertificate.serializePoolRelay = poolRegistrationCertificate.serializePoolRewardAccountLegacy = poolRegistrationCertificate.serializePoolRewardAccount = poolRegistrationCertificate.serializePoolOwner = poolRegistrationCertificate.serializePoolKeyLegacy = poolRegistrationCertificate.serializePoolKey = poolRegistrationCertificate.serializeFinancials = poolRegistrationCertificate.serializePoolInitialParamsLegacy = poolRegistrationCertificate.serializePoolInitialParams = void 0;
const internal_1$a = internal;
const assert_1$7 = assert$1;
const serialize_1$6 = serialize;
const SignTxIncluded = Object.freeze({
  SIGN_TX_INCLUDED_NO: 1,
  SIGN_TX_INCLUDED_YES: 2
});
function serializePoolInitialParams(pool) {
  return Buffer$1.concat([
    (0, serialize_1$6.uint32_to_buf)(pool.owners.length),
    (0, serialize_1$6.uint32_to_buf)(pool.relays.length)
  ]);
}
poolRegistrationCertificate.serializePoolInitialParams = serializePoolInitialParams;
function serializePoolInitialParamsLegacy(pool) {
  return Buffer$1.concat([
    serializePoolKeyLegacy(pool.poolKey),
    (0, serialize_1$6.hex_to_buf)(pool.vrfHashHex),
    (0, serialize_1$6.serializeCoin)(pool.pledge),
    (0, serialize_1$6.serializeCoin)(pool.cost),
    (0, serialize_1$6.uint64_to_buf)(pool.margin.numerator),
    (0, serialize_1$6.uint64_to_buf)(pool.margin.denominator),
    serializePoolRewardAccountLegacy(pool.rewardAccount),
    (0, serialize_1$6.uint32_to_buf)(pool.owners.length),
    (0, serialize_1$6.uint32_to_buf)(pool.relays.length)
  ]);
}
poolRegistrationCertificate.serializePoolInitialParamsLegacy = serializePoolInitialParamsLegacy;
function serializeFinancials(pool) {
  return Buffer$1.concat([
    (0, serialize_1$6.serializeCoin)(pool.pledge),
    (0, serialize_1$6.serializeCoin)(pool.cost),
    (0, serialize_1$6.uint64_to_buf)(pool.margin.numerator),
    (0, serialize_1$6.uint64_to_buf)(pool.margin.denominator)
  ]);
}
poolRegistrationCertificate.serializeFinancials = serializeFinancials;
function serializePoolKey(key) {
  const typeHeader = {
    [internal_1$a.PoolKeyType.DEVICE_OWNED]: 1,
    [internal_1$a.PoolKeyType.THIRD_PARTY]: 2
  };
  switch (key.type) {
    case internal_1$a.PoolKeyType.DEVICE_OWNED: {
      return Buffer$1.concat([
        (0, serialize_1$6.uint8_to_buf)(typeHeader[key.type]),
        (0, serialize_1$6.path_to_buf)(key.path)
      ]);
    }
    case internal_1$a.PoolKeyType.THIRD_PARTY: {
      return Buffer$1.concat([
        (0, serialize_1$6.uint8_to_buf)(typeHeader[key.type]),
        (0, serialize_1$6.hex_to_buf)(key.hashHex)
      ]);
    }
    default:
      (0, assert_1$7.unreachable)(key);
  }
}
poolRegistrationCertificate.serializePoolKey = serializePoolKey;
function serializePoolKeyLegacy(key) {
  (0, assert_1$7.assert)(key.type === internal_1$a.PoolKeyType.THIRD_PARTY, "invalid pool key type for legacy Ledger version");
  return (0, serialize_1$6.hex_to_buf)(key.hashHex);
}
poolRegistrationCertificate.serializePoolKeyLegacy = serializePoolKeyLegacy;
function serializePoolOwner(owner) {
  const typeHeader = {
    [internal_1$a.PoolOwnerType.DEVICE_OWNED]: 1,
    [internal_1$a.PoolOwnerType.THIRD_PARTY]: 2
  };
  switch (owner.type) {
    case internal_1$a.PoolOwnerType.DEVICE_OWNED: {
      return Buffer$1.concat([
        (0, serialize_1$6.uint8_to_buf)(typeHeader[owner.type]),
        (0, serialize_1$6.path_to_buf)(owner.path)
      ]);
    }
    case internal_1$a.PoolOwnerType.THIRD_PARTY: {
      return Buffer$1.concat([
        (0, serialize_1$6.uint8_to_buf)(typeHeader[owner.type]),
        (0, serialize_1$6.hex_to_buf)(owner.hashHex)
      ]);
    }
    default:
      (0, assert_1$7.unreachable)(owner);
  }
}
poolRegistrationCertificate.serializePoolOwner = serializePoolOwner;
function serializePoolRewardAccount(rewardAccount) {
  const typeHeader = {
    [internal_1$a.PoolRewardAccountType.DEVICE_OWNED]: 1,
    [internal_1$a.PoolRewardAccountType.THIRD_PARTY]: 2
  };
  switch (rewardAccount.type) {
    case internal_1$a.PoolRewardAccountType.DEVICE_OWNED: {
      return Buffer$1.concat([
        (0, serialize_1$6.uint8_to_buf)(typeHeader[rewardAccount.type]),
        (0, serialize_1$6.path_to_buf)(rewardAccount.path)
      ]);
    }
    case internal_1$a.PoolRewardAccountType.THIRD_PARTY: {
      return Buffer$1.concat([
        (0, serialize_1$6.uint8_to_buf)(typeHeader[rewardAccount.type]),
        (0, serialize_1$6.hex_to_buf)(rewardAccount.rewardAccountHex)
      ]);
    }
    default:
      (0, assert_1$7.unreachable)(rewardAccount);
  }
}
poolRegistrationCertificate.serializePoolRewardAccount = serializePoolRewardAccount;
function serializePoolRewardAccountLegacy(rewardAccount) {
  (0, assert_1$7.assert)(rewardAccount.type === internal_1$a.PoolRewardAccountType.THIRD_PARTY, "invalid pool reward account type for legacy Ledger version");
  return (0, serialize_1$6.hex_to_buf)(rewardAccount.rewardAccountHex);
}
poolRegistrationCertificate.serializePoolRewardAccountLegacy = serializePoolRewardAccountLegacy;
function serializePoolRelay(relay) {
  function serializeOptional(x2, cb) {
    if (x2 == null) {
      return Buffer$1.concat([(0, serialize_1$6.uint8_to_buf)(1)]);
    } else {
      return Buffer$1.concat([(0, serialize_1$6.uint8_to_buf)(2), cb(x2)]);
    }
  }
  switch (relay.type) {
    case 0: {
      return Buffer$1.concat([
        (0, serialize_1$6.uint8_to_buf)(relay.type),
        serializeOptional(relay.port, (port) => (0, serialize_1$6.uint16_to_buf)(port)),
        serializeOptional(relay.ipv4, (ipv4) => ipv4),
        serializeOptional(relay.ipv6, (ipv6) => ipv6)
      ]);
    }
    case 1: {
      return Buffer$1.concat([
        (0, serialize_1$6.uint8_to_buf)(relay.type),
        serializeOptional(relay.port, (port) => (0, serialize_1$6.uint16_to_buf)(port)),
        Buffer$1.from(relay.dnsName, "ascii")
      ]);
    }
    case 2: {
      return Buffer$1.concat([
        (0, serialize_1$6.uint8_to_buf)(relay.type),
        Buffer$1.from(relay.dnsName, "ascii")
      ]);
    }
    default:
      (0, assert_1$7.unreachable)(relay);
  }
}
poolRegistrationCertificate.serializePoolRelay = serializePoolRelay;
function serializePoolMetadata(metadata) {
  if (metadata == null) {
    return Buffer$1.concat([
      (0, serialize_1$6.uint8_to_buf)(SignTxIncluded.SIGN_TX_INCLUDED_NO)
    ]);
  } else {
    return Buffer$1.concat([
      (0, serialize_1$6.uint8_to_buf)(SignTxIncluded.SIGN_TX_INCLUDED_YES),
      (0, serialize_1$6.hex_to_buf)(metadata.hashHex),
      Buffer$1.from(metadata.url, "ascii")
    ]);
  }
}
poolRegistrationCertificate.serializePoolMetadata = serializePoolMetadata;
var txAuxiliaryData$1 = {};
Object.defineProperty(txAuxiliaryData$1, "__esModule", { value: true });
txAuxiliaryData$1.serializeTxAuxiliaryData = void 0;
const internal_1$9 = internal;
const assert_1$6 = assert$1;
const serialize_1$5 = serialize;
function serializeTxAuxiliaryData(auxiliaryData) {
  const auxiliaryDataTypesEncoding = {
    [internal_1$9.TxAuxiliaryDataType.ARBITRARY_HASH]: 0,
    [internal_1$9.TxAuxiliaryDataType.CIP36_REGISTRATION]: 1
  };
  switch (auxiliaryData.type) {
    case internal_1$9.TxAuxiliaryDataType.ARBITRARY_HASH: {
      return Buffer$1.concat([
        (0, serialize_1$5.uint8_to_buf)(auxiliaryDataTypesEncoding[auxiliaryData.type]),
        (0, serialize_1$5.hex_to_buf)(auxiliaryData.hashHex)
      ]);
    }
    case internal_1$9.TxAuxiliaryDataType.CIP36_REGISTRATION: {
      return Buffer$1.concat([
        (0, serialize_1$5.uint8_to_buf)(auxiliaryDataTypesEncoding[auxiliaryData.type])
      ]);
    }
    default:
      (0, assert_1$6.unreachable)(auxiliaryData);
  }
}
txAuxiliaryData$1.serializeTxAuxiliaryData = serializeTxAuxiliaryData;
var txCertificate = {};
Object.defineProperty(txCertificate, "__esModule", { value: true });
txCertificate.serializeTxCertificate = txCertificate.serializeTxCertificatePreMultisig = txCertificate.serializeDRep = void 0;
const internal_1$8 = internal;
const assert_1$5 = assert$1;
const serialize_1$4 = serialize;
const getVersion_1$3 = getVersion$1;
function serializeDRep(dRep) {
  switch (dRep.type) {
    case 100:
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(dRep.type),
        (0, serialize_1$4.path_to_buf)(dRep.path)
      ]);
    case 0:
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(dRep.type),
        (0, serialize_1$4.hex_to_buf)(dRep.keyHashHex)
      ]);
    case 1:
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(dRep.type),
        (0, serialize_1$4.hex_to_buf)(dRep.scriptHashHex)
      ]);
    case 2:
    case 3:
      return Buffer$1.concat([(0, serialize_1$4.uint8_to_buf)(dRep.type)]);
    default:
      (0, assert_1$5.unreachable)(dRep);
  }
}
txCertificate.serializeDRep = serializeDRep;
function serializeTxCertificatePreMultisig(certificate2) {
  switch (certificate2.type) {
    case internal_1$8.CertificateType.STAKE_REGISTRATION:
    case internal_1$8.CertificateType.STAKE_DEREGISTRATION: {
      (0, assert_1$5.assert)(certificate2.stakeCredential.type === 0, "invalid stake credential");
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.path_to_buf)(certificate2.stakeCredential.path)
      ]);
    }
    case internal_1$8.CertificateType.STAKE_DELEGATION: {
      (0, assert_1$5.assert)(certificate2.stakeCredential.type === 0, "invalid stake credential");
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.path_to_buf)(certificate2.stakeCredential.path),
        (0, serialize_1$4.hex_to_buf)(certificate2.poolKeyHashHex)
      ]);
    }
    case internal_1$8.CertificateType.STAKE_POOL_REGISTRATION: {
      return Buffer$1.concat([(0, serialize_1$4.uint8_to_buf)(certificate2.type)]);
    }
    case internal_1$8.CertificateType.STAKE_POOL_RETIREMENT: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.path_to_buf)(certificate2.path),
        (0, serialize_1$4.uint64_to_buf)(certificate2.retirementEpoch)
      ]);
    }
    case internal_1$8.CertificateType.STAKE_REGISTRATION_CONWAY:
    case internal_1$8.CertificateType.STAKE_DEREGISTRATION_CONWAY:
    case internal_1$8.CertificateType.VOTE_DELEGATION:
    case internal_1$8.CertificateType.AUTHORIZE_COMMITTEE_HOT:
    case internal_1$8.CertificateType.RESIGN_COMMITTEE_COLD:
    case internal_1$8.CertificateType.DREP_REGISTRATION:
    case internal_1$8.CertificateType.DREP_DEREGISTRATION:
    case internal_1$8.CertificateType.DREP_UPDATE: {
      (0, assert_1$5.assert)(false, "Conway certificates in pre-multisig serialization");
      break;
    }
    default:
      (0, assert_1$5.unreachable)(certificate2);
  }
}
txCertificate.serializeTxCertificatePreMultisig = serializeTxCertificatePreMultisig;
function serializeTxCertificate(certificate2, version2) {
  if (!(0, getVersion_1$3.getCompatibility)(version2).supportsMultisigTransaction) {
    return serializeTxCertificatePreMultisig(certificate2);
  }
  switch (certificate2.type) {
    case internal_1$8.CertificateType.STAKE_REGISTRATION:
    case internal_1$8.CertificateType.STAKE_DEREGISTRATION: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.serializeCredential)(certificate2.stakeCredential)
      ]);
    }
    case internal_1$8.CertificateType.STAKE_REGISTRATION_CONWAY:
    case internal_1$8.CertificateType.STAKE_DEREGISTRATION_CONWAY: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.serializeCredential)(certificate2.stakeCredential),
        (0, serialize_1$4.serializeCoin)(certificate2.deposit)
      ]);
    }
    case internal_1$8.CertificateType.STAKE_DELEGATION: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.serializeCredential)(certificate2.stakeCredential),
        (0, serialize_1$4.hex_to_buf)(certificate2.poolKeyHashHex)
      ]);
    }
    case internal_1$8.CertificateType.VOTE_DELEGATION: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.serializeCredential)(certificate2.stakeCredential),
        serializeDRep(certificate2.dRep)
      ]);
    }
    case internal_1$8.CertificateType.AUTHORIZE_COMMITTEE_HOT: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.serializeCredential)(certificate2.coldCredential),
        (0, serialize_1$4.serializeCredential)(certificate2.hotCredential)
      ]);
    }
    case internal_1$8.CertificateType.RESIGN_COMMITTEE_COLD: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.serializeCredential)(certificate2.coldCredential),
        (0, serialize_1$4.serializeAnchor)(certificate2.anchor)
      ]);
    }
    case internal_1$8.CertificateType.DREP_REGISTRATION: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.serializeCredential)(certificate2.dRepCredential),
        (0, serialize_1$4.serializeCoin)(certificate2.deposit),
        (0, serialize_1$4.serializeAnchor)(certificate2.anchor)
      ]);
    }
    case internal_1$8.CertificateType.DREP_DEREGISTRATION: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.serializeCredential)(certificate2.dRepCredential),
        (0, serialize_1$4.serializeCoin)(certificate2.deposit)
      ]);
    }
    case internal_1$8.CertificateType.DREP_UPDATE: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.serializeCredential)(certificate2.dRepCredential),
        (0, serialize_1$4.serializeAnchor)(certificate2.anchor)
      ]);
    }
    case internal_1$8.CertificateType.STAKE_POOL_REGISTRATION: {
      return Buffer$1.concat([(0, serialize_1$4.uint8_to_buf)(certificate2.type)]);
    }
    case internal_1$8.CertificateType.STAKE_POOL_RETIREMENT: {
      return Buffer$1.concat([
        (0, serialize_1$4.uint8_to_buf)(certificate2.type),
        (0, serialize_1$4.path_to_buf)(certificate2.path),
        (0, serialize_1$4.uint64_to_buf)(certificate2.retirementEpoch)
      ]);
    }
    default:
      (0, assert_1$5.unreachable)(certificate2);
  }
}
txCertificate.serializeTxCertificate = serializeTxCertificate;
var txInit = {};
Object.defineProperty(txInit, "__esModule", { value: true });
txInit.serializeTxInit = void 0;
const internal_1$7 = internal;
const assert_1$4 = assert$1;
const serialize_1$3 = serialize;
const getVersion_1$2 = getVersion$1;
const _serializeSigningMode = (mode) => {
  const value = {
    [internal_1$7.TransactionSigningMode.ORDINARY_TRANSACTION]: 3,
    [internal_1$7.TransactionSigningMode.POOL_REGISTRATION_AS_OWNER]: 4,
    [internal_1$7.TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR]: 5,
    [internal_1$7.TransactionSigningMode.MULTISIG_TRANSACTION]: 6,
    [internal_1$7.TransactionSigningMode.PLUTUS_TRANSACTION]: 7
  }[mode];
  (0, assert_1$4.assert)(value !== void 0, "Invalid signing mode");
  return (0, serialize_1$3.uint8_to_buf)(value);
};
function serializeTxOptions(options) {
  let optionFlags = 0;
  if (options.tagCborSets) {
    optionFlags += 1;
  }
  return (0, serialize_1$3.uint64_to_buf)(optionFlags.toString());
}
function serializeTxInit(tx, signingMode, numWitnesses, options, version2) {
  const optionsBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsConway ? serializeTxOptions(options) : Buffer$1.from([]);
  const appAwareOfMint = (0, getVersion_1$2.getCompatibility)(version2).supportsMint || version2.flags.isAppXS;
  const mintBuffer = appAwareOfMint ? (0, serialize_1$3.serializeOptionFlag)(tx.mint != null) : Buffer$1.from([]);
  const scriptDataHashBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsAlonzo ? (0, serialize_1$3.serializeOptionFlag)(tx.scriptDataHashHex != null) : Buffer$1.from([]);
  const collateralInputsBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsAlonzo ? (0, serialize_1$3.uint32_to_buf)(tx.collateralInputs.length) : Buffer$1.from([]);
  const requiredSignersBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsAlonzo ? (0, serialize_1$3.uint32_to_buf)(tx.requiredSigners.length) : Buffer$1.from([]);
  const includeNetworkIdBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsAlonzo ? (0, serialize_1$3.serializeOptionFlag)(tx.includeNetworkId) : Buffer$1.from([]);
  const includeCollateralOutputBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsBabbage ? (0, serialize_1$3.serializeOptionFlag)(tx.collateralOutput != null) : Buffer$1.from([]);
  const includeTotalCollateralBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsBabbage ? (0, serialize_1$3.serializeOptionFlag)(tx.totalCollateral != null) : Buffer$1.from([]);
  const referenceInputsBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsBabbage ? (0, serialize_1$3.uint32_to_buf)(tx.referenceInputs.length) : Buffer$1.from([]);
  const votingProceduresBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsConway ? (0, serialize_1$3.uint32_to_buf)(tx.votingProcedures.length) : Buffer$1.from([]);
  const includeTreasuryBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsConway ? (0, serialize_1$3.serializeOptionFlag)(tx.treasury != null) : Buffer$1.from([]);
  const includeDonationBuffer = (0, getVersion_1$2.getCompatibility)(version2).supportsConway ? (0, serialize_1$3.serializeOptionFlag)(tx.donation != null) : Buffer$1.from([]);
  const witnessBufferLegacy = (0, getVersion_1$2.getCompatibility)(version2).supportsBabbage ? Buffer$1.from([]) : (0, serialize_1$3.uint32_to_buf)(numWitnesses);
  const witnessBufferBabbage = (0, getVersion_1$2.getCompatibility)(version2).supportsBabbage ? (0, serialize_1$3.uint32_to_buf)(numWitnesses) : Buffer$1.from([]);
  return Buffer$1.concat([
    optionsBuffer,
    (0, serialize_1$3.uint8_to_buf)(tx.network.networkId),
    (0, serialize_1$3.uint32_to_buf)(tx.network.protocolMagic),
    (0, serialize_1$3.serializeOptionFlag)(tx.ttl != null),
    (0, serialize_1$3.serializeOptionFlag)(tx.auxiliaryData != null),
    (0, serialize_1$3.serializeOptionFlag)(tx.validityIntervalStart != null),
    mintBuffer,
    scriptDataHashBuffer,
    includeNetworkIdBuffer,
    includeCollateralOutputBuffer,
    includeTotalCollateralBuffer,
    includeTreasuryBuffer,
    includeDonationBuffer,
    _serializeSigningMode(signingMode),
    (0, serialize_1$3.uint32_to_buf)(tx.inputs.length),
    (0, serialize_1$3.uint32_to_buf)(tx.outputs.length),
    (0, serialize_1$3.uint32_to_buf)(tx.certificates.length),
    (0, serialize_1$3.uint32_to_buf)(tx.withdrawals.length),
    witnessBufferLegacy,
    collateralInputsBuffer,
    requiredSignersBuffer,
    referenceInputsBuffer,
    votingProceduresBuffer,
    witnessBufferBabbage
  ]);
}
txInit.serializeTxInit = serializeTxInit;
var txOther = {};
Object.defineProperty(txOther, "__esModule", { value: true });
txOther.serializeVoterVotes = txOther.serializeRequiredSigner = txOther.serializeMintBasicParams = txOther.serializeToken = txOther.serializeAssetGroup = txOther.serializeTxWitnessRequest = txOther.serializeTxValidityStart = txOther.serializeTxTtl = txOther.serializeTxWithdrawal = txOther.serializeTxInput = void 0;
const public_1$6 = _public;
const invalidDataReason_1$6 = invalidDataReason;
const assert_1$3 = assert$1;
const serialize_1$2 = serialize;
const getVersion_1$1 = getVersion$1;
function serializeTxInput(input) {
  return Buffer$1.concat([
    (0, serialize_1$2.hex_to_buf)(input.txHashHex),
    (0, serialize_1$2.uint32_to_buf)(input.outputIndex)
  ]);
}
txOther.serializeTxInput = serializeTxInput;
function serializeTxWithdrawal(withdrawal, version2) {
  if ((0, getVersion_1$1.getCompatibility)(version2).supportsMultisigTransaction) {
    return Buffer$1.concat([
      (0, serialize_1$2.serializeCoin)(withdrawal.amount),
      (0, serialize_1$2.serializeCredential)(withdrawal.stakeCredential)
    ]);
  } else {
    (0, assert_1$3.assert)(withdrawal.stakeCredential.type === 0, invalidDataReason_1$6.InvalidDataReason.WITHDRAWAL_INVALID_STAKE_CREDENTIAL);
    return Buffer$1.concat([
      (0, serialize_1$2.serializeCoin)(withdrawal.amount),
      (0, serialize_1$2.path_to_buf)(withdrawal.stakeCredential.path)
    ]);
  }
}
txOther.serializeTxWithdrawal = serializeTxWithdrawal;
function serializeTxTtl(ttl) {
  return Buffer$1.concat([(0, serialize_1$2.uint64_to_buf)(ttl)]);
}
txOther.serializeTxTtl = serializeTxTtl;
function serializeTxValidityStart(validityIntervalStart) {
  return Buffer$1.concat([(0, serialize_1$2.uint64_to_buf)(validityIntervalStart)]);
}
txOther.serializeTxValidityStart = serializeTxValidityStart;
function serializeTxWitnessRequest(path2) {
  return Buffer$1.concat([(0, serialize_1$2.path_to_buf)(path2)]);
}
txOther.serializeTxWitnessRequest = serializeTxWitnessRequest;
function serializeAssetGroup(assetGroup) {
  return Buffer$1.concat([
    (0, serialize_1$2.hex_to_buf)(assetGroup.policyIdHex),
    (0, serialize_1$2.uint32_to_buf)(assetGroup.tokens.length)
  ]);
}
txOther.serializeAssetGroup = serializeAssetGroup;
function serializeToken(token, serializeTokenAmountFn) {
  return Buffer$1.concat([
    (0, serialize_1$2.uint32_to_buf)(token.assetNameHex.length / 2),
    (0, serialize_1$2.hex_to_buf)(token.assetNameHex),
    serializeTokenAmountFn(token.amount)
  ]);
}
txOther.serializeToken = serializeToken;
function serializeMintBasicParams(mint) {
  return Buffer$1.concat([(0, serialize_1$2.uint32_to_buf)(mint.length)]);
}
txOther.serializeMintBasicParams = serializeMintBasicParams;
function serializeRequiredSigner(requiredSigner) {
  switch (requiredSigner.type) {
    case 0:
      return Buffer$1.concat([
        (0, serialize_1$2.uint8_to_buf)(requiredSigner.type),
        (0, serialize_1$2.path_to_buf)(requiredSigner.path)
      ]);
    case 1:
      return Buffer$1.concat([
        (0, serialize_1$2.uint8_to_buf)(requiredSigner.type),
        (0, serialize_1$2.hex_to_buf)(requiredSigner.hashHex)
      ]);
    default:
      (0, assert_1$3.unreachable)(requiredSigner);
  }
}
txOther.serializeRequiredSigner = serializeRequiredSigner;
function serializeVoter(voter) {
  switch (voter.type) {
    case public_1$6.VoterType.COMMITTEE_KEY_HASH:
    case public_1$6.VoterType.DREP_KEY_HASH:
    case public_1$6.VoterType.STAKE_POOL_KEY_HASH:
      return Buffer$1.concat([
        (0, serialize_1$2.uint8_to_buf)(voter.type),
        (0, serialize_1$2.hex_to_buf)(voter.keyHashHex)
      ]);
    case public_1$6.VoterType.COMMITTEE_KEY_PATH:
    case public_1$6.VoterType.DREP_KEY_PATH:
    case public_1$6.VoterType.STAKE_POOL_KEY_PATH:
      return Buffer$1.concat([
        (0, serialize_1$2.uint8_to_buf)(voter.type),
        (0, serialize_1$2.path_to_buf)(voter.keyPath)
      ]);
    case public_1$6.VoterType.COMMITTEE_SCRIPT_HASH:
    case public_1$6.VoterType.DREP_SCRIPT_HASH:
      return Buffer$1.concat([
        (0, serialize_1$2.uint8_to_buf)(voter.type),
        (0, serialize_1$2.hex_to_buf)(voter.scriptHashHex)
      ]);
    default:
      (0, assert_1$3.unreachable)(voter);
  }
}
function serializeVoterVotes(voterVotes) {
  (0, assert_1$3.assert)(voterVotes.votes.length === 1, "too few / too many votes");
  const vote = voterVotes.votes[0];
  return Buffer$1.concat([
    serializeVoter(voterVotes.voter),
    Buffer$1.concat([
      (0, serialize_1$2.hex_to_buf)(vote.govActionId.txHashHex),
      (0, serialize_1$2.uint32_to_buf)(vote.govActionId.govActionIndex)
    ]),
    Buffer$1.concat([
      (0, serialize_1$2.uint8_to_buf)(vote.votingProcedure.vote),
      (0, serialize_1$2.serializeAnchor)(vote.votingProcedure.anchor)
    ])
  ]);
}
txOther.serializeVoterVotes = serializeVoterVotes;
Object.defineProperty(signTx, "__esModule", { value: true });
signTx.signTransaction = void 0;
const errors_1$5 = errors$4;
const internal_1$6 = internal;
const public_1$5 = _public;
const utils_1 = utils$2;
const assert_1$2 = assert$1;
const serialize_1$1 = serialize;
const getVersion_1 = getVersion$1;
const cVoteRegistration_1 = cVoteRegistration;
const poolRegistrationCertificate_1 = poolRegistrationCertificate;
const txAuxiliaryData_1$1 = txAuxiliaryData$1;
const txCertificate_1 = txCertificate;
const txInit_1 = txInit;
const txOther_1 = txOther;
const txOutput_1 = txOutput;
const send = (params2) => Object.assign({ ins: 33 }, params2);
function* signTx_init(tx, signingMode, witnessPaths, options, version2) {
  yield send({
    p1: 1,
    p2: 0,
    data: (0, txInit_1.serializeTxInit)(tx, signingMode, witnessPaths.length, options, version2),
    expectedResponseLength: 0
  });
}
function* signTx_addInput(input) {
  yield send({
    p1: 2,
    p2: 0,
    data: (0, txOther_1.serializeTxInput)(input),
    expectedResponseLength: 0
  });
}
function* signTx_addOutput_sendChunks(hex, p2) {
  let start = txOutput_1.MAX_CHUNK_SIZE * 2;
  let end = start;
  while (start < hex.length) {
    end = Math.min(hex.length, start + txOutput_1.MAX_CHUNK_SIZE * 2);
    const chunk = hex.substring(start, end);
    yield send({
      p1: 3,
      p2,
      data: Buffer$1.concat([
        (0, serialize_1$1.uint32_to_buf)(chunk.length / 2),
        (0, serialize_1$1.hex_to_buf)(chunk)
      ]),
      expectedResponseLength: 0
    });
    start = end;
  }
}
function* signTx_addTokenBundle(tokenBundle, p1, serializeTokenAmountFn) {
  for (const assetGroup of tokenBundle) {
    yield send({
      p1,
      p2: 49,
      data: (0, txOther_1.serializeAssetGroup)(assetGroup),
      expectedResponseLength: 0
    });
    for (const token of assetGroup.tokens) {
      yield send({
        p1,
        p2: 50,
        data: (0, txOther_1.serializeToken)(token, serializeTokenAmountFn),
        expectedResponseLength: 0
      });
    }
  }
}
function* signTx_addOutput(output2, version2) {
  yield send({
    p1: 3,
    p2: 48,
    data: (0, txOutput_1.serializeTxOutputBasicParams)(output2, version2),
    expectedResponseLength: 0
  });
  yield* signTx_addTokenBundle(output2.tokenBundle, 3, serialize_1$1.uint64_to_buf);
  if (output2.datum) {
    yield send({
      p1: 3,
      p2: 52,
      data: (0, txOutput_1.serializeTxOutputDatum)(output2.datum, version2),
      expectedResponseLength: 0
    });
    if (output2.datum.type === public_1$5.DatumType.INLINE) {
      const additionalChunksNeeded = output2.datum.datumHex.length / 2 > txOutput_1.MAX_CHUNK_SIZE;
      if (additionalChunksNeeded) {
        yield* signTx_addOutput_sendChunks(output2.datum.datumHex, 53);
      }
    }
  }
  if (output2.referenceScriptHex) {
    yield send({
      p1: 3,
      p2: 54,
      data: (0, txOutput_1.serializeTxOutputRefScript)(output2.referenceScriptHex),
      expectedResponseLength: 0
    });
    if (output2.referenceScriptHex.length / 2 > txOutput_1.MAX_CHUNK_SIZE) {
      yield* signTx_addOutput_sendChunks(output2.referenceScriptHex, 55);
    }
  }
  yield send({
    p1: 3,
    p2: 51,
    data: Buffer$1.concat([]),
    expectedResponseLength: 0
  });
}
function* signTx_addStakePoolRegistrationCertificate(certificate2) {
  (0, assert_1$2.assert)(certificate2.type === internal_1$6.CertificateType.STAKE_POOL_REGISTRATION, "invalid certificate type");
  const pool = certificate2.pool;
  yield send({
    p1: 6,
    p2: 48,
    data: (0, poolRegistrationCertificate_1.serializePoolInitialParams)(pool),
    expectedResponseLength: 0
  });
  yield send({
    p1: 6,
    p2: 49,
    data: (0, poolRegistrationCertificate_1.serializePoolKey)(pool.poolKey),
    expectedResponseLength: 0
  });
  yield send({
    p1: 6,
    p2: 50,
    data: (0, serialize_1$1.hex_to_buf)(pool.vrfHashHex),
    expectedResponseLength: 0
  });
  yield send({
    p1: 6,
    p2: 51,
    data: (0, poolRegistrationCertificate_1.serializeFinancials)(pool),
    expectedResponseLength: 0
  });
  yield send({
    p1: 6,
    p2: 52,
    data: (0, poolRegistrationCertificate_1.serializePoolRewardAccount)(pool.rewardAccount),
    expectedResponseLength: 0
  });
  for (const owner of pool.owners) {
    yield send({
      p1: 6,
      p2: 53,
      data: (0, poolRegistrationCertificate_1.serializePoolOwner)(owner),
      expectedResponseLength: 0
    });
  }
  for (const relay of pool.relays) {
    yield send({
      p1: 6,
      p2: 54,
      data: (0, poolRegistrationCertificate_1.serializePoolRelay)(relay),
      expectedResponseLength: 0
    });
  }
  yield send({
    p1: 6,
    p2: 55,
    data: (0, poolRegistrationCertificate_1.serializePoolMetadata)(pool.metadata),
    expectedResponseLength: 0
  });
  yield send({
    p1: 6,
    p2: 56,
    data: Buffer$1.alloc(0),
    expectedResponseLength: 0
  });
}
function* signTx_addStakePoolRegistrationCertificateLegacy(certificate2) {
  (0, assert_1$2.assert)(certificate2.type === internal_1$6.CertificateType.STAKE_POOL_REGISTRATION, "invalid certificate type");
  const pool = certificate2.pool;
  yield send({
    p1: 6,
    p2: 48,
    data: (0, poolRegistrationCertificate_1.serializePoolInitialParamsLegacy)(pool),
    expectedResponseLength: 0
  });
  for (const owner of pool.owners) {
    yield send({
      p1: 6,
      p2: 49,
      data: (0, poolRegistrationCertificate_1.serializePoolOwner)(owner),
      expectedResponseLength: 0
    });
  }
  for (const relay of pool.relays) {
    yield send({
      p1: 6,
      p2: 50,
      data: (0, poolRegistrationCertificate_1.serializePoolRelay)(relay),
      expectedResponseLength: 0
    });
  }
  yield send({
    p1: 6,
    p2: 51,
    data: (0, poolRegistrationCertificate_1.serializePoolMetadata)(pool.metadata),
    expectedResponseLength: 0
  });
  yield send({
    p1: 6,
    p2: 52,
    data: Buffer$1.alloc(0),
    expectedResponseLength: 0
  });
}
function* signTx_addCertificate(certificate2, version2) {
  yield send({
    p1: 6,
    p2: 0,
    data: (0, txCertificate_1.serializeTxCertificate)(certificate2, version2),
    expectedResponseLength: 0
  });
  if (certificate2.type === internal_1$6.CertificateType.STAKE_POOL_REGISTRATION) {
    if ((0, getVersion_1.getCompatibility)(version2).supportsPoolRegistrationAsOperator) {
      yield* signTx_addStakePoolRegistrationCertificate(certificate2);
    } else {
      yield* signTx_addStakePoolRegistrationCertificateLegacy(certificate2);
    }
  }
}
function* signTx_addWithdrawal(withdrawal, version2) {
  yield send({
    p1: 7,
    p2: 0,
    data: (0, txOther_1.serializeTxWithdrawal)(withdrawal, version2),
    expectedResponseLength: 0
  });
}
function* signTx_setFee(fee) {
  yield send({
    p1: 4,
    p2: 0,
    data: (0, serialize_1$1.serializeCoin)(fee),
    expectedResponseLength: 0
  });
}
function* signTx_setTtl(ttl) {
  yield send({
    p1: 5,
    p2: 0,
    data: (0, txOther_1.serializeTxTtl)(ttl),
    expectedResponseLength: 0
  });
}
function* signTx_setAuxiliaryData(auxiliaryData, version2) {
  const supportedAuxiliaryDataTypes = [
    public_1$5.TxAuxiliaryDataType.ARBITRARY_HASH,
    public_1$5.TxAuxiliaryDataType.CIP36_REGISTRATION
  ];
  (0, assert_1$2.assert)(supportedAuxiliaryDataTypes.includes(auxiliaryData.type), "Auxiliary data type not implemented");
  yield send({
    p1: 8,
    p2: 0,
    data: (0, txAuxiliaryData_1$1.serializeTxAuxiliaryData)(auxiliaryData),
    expectedResponseLength: 0
  });
  if (auxiliaryData.type === public_1$5.TxAuxiliaryDataType.CIP36_REGISTRATION) {
    const params2 = auxiliaryData.params;
    if ((0, getVersion_1.getCompatibility)(version2).supportsCIP36) {
      yield send({
        p1: 8,
        p2: 54,
        data: (0, cVoteRegistration_1.serializeCVoteRegistrationInit)(auxiliaryData.params),
        expectedResponseLength: 0
      });
    }
    if (params2.votePublicKey || params2.votePublicKeyPath) {
      yield send({
        p1: 8,
        p2: 48,
        data: (0, cVoteRegistration_1.serializeCVoteRegistrationVoteKey)(params2.votePublicKey, params2.votePublicKeyPath, version2),
        expectedResponseLength: 0
      });
    } else if (params2.delegations) {
      for (const delegation of params2.delegations) {
        yield send({
          p1: 8,
          p2: 55,
          data: (0, cVoteRegistration_1.serializeCVoteRegistrationDelegation)(delegation),
          expectedResponseLength: 0
        });
      }
    } else {
      throw Error("wrong CIP36 registration params");
    }
    yield send({
      p1: 8,
      p2: 49,
      data: (0, cVoteRegistration_1.serializeCVoteRegistrationStakingPath)(params2.stakingPath),
      expectedResponseLength: 0
    });
    yield send({
      p1: 8,
      p2: 50,
      data: (0, cVoteRegistration_1.serializeCVoteRegistrationPaymentDestination)(params2.paymentDestination, version2),
      expectedResponseLength: 0
    });
    yield send({
      p1: 8,
      p2: 51,
      data: (0, cVoteRegistration_1.serializeCVoteRegistrationNonce)(params2.nonce),
      expectedResponseLength: 0
    });
    if ((0, getVersion_1.getCompatibility)(version2).supportsCIP36) {
      yield send({
        p1: 8,
        p2: 53,
        data: (0, cVoteRegistration_1.serializeCVoteRegistrationVotingPurpose)(params2.votingPurpose),
        expectedResponseLength: 0
      });
    }
    const ED25519_SIGNATURE_LENGTH = 64;
    const response = yield send({
      p1: 8,
      p2: 52,
      data: Buffer$1.alloc(0),
      expectedResponseLength: internal_1$6.AUXILIARY_DATA_HASH_LENGTH + ED25519_SIGNATURE_LENGTH
    });
    const auxDataHash = response.slice(0, internal_1$6.AUXILIARY_DATA_HASH_LENGTH);
    const signature = response.slice(internal_1$6.AUXILIARY_DATA_HASH_LENGTH, internal_1$6.AUXILIARY_DATA_HASH_LENGTH + ED25519_SIGNATURE_LENGTH);
    return {
      type: public_1$5.TxAuxiliaryDataSupplementType.CIP36_REGISTRATION,
      auxiliaryDataHashHex: auxDataHash.toString("hex"),
      cip36VoteRegistrationSignatureHex: signature.toString("hex")
    };
  }
  return null;
}
function* signTx_setAuxiliaryData_before_v2_3(auxiliaryData) {
  (0, assert_1$2.assert)(auxiliaryData.type === public_1$5.TxAuxiliaryDataType.ARBITRARY_HASH, "Auxiliary data type not implemented");
  yield send({
    p1: 8,
    p2: 0,
    data: (0, serialize_1$1.hex_to_buf)(auxiliaryData.hashHex),
    expectedResponseLength: 0
  });
  return null;
}
function* signTx_setValidityIntervalStart(validityIntervalStartStr) {
  yield send({
    p1: 9,
    p2: 0,
    data: (0, txOther_1.serializeTxValidityStart)(validityIntervalStartStr)
  });
}
function* signTx_setMint(mint) {
  yield send({
    p1: 11,
    p2: 48,
    data: (0, txOther_1.serializeMintBasicParams)(mint),
    expectedResponseLength: 0
  });
  yield* signTx_addTokenBundle(mint, 11, serialize_1$1.int64_to_buf);
  yield send({
    p1: 11,
    p2: 51,
    data: Buffer$1.alloc(0),
    expectedResponseLength: 0
  });
}
function* signTx_setScriptDataHash(scriptDataHash) {
  yield send({
    p1: 12,
    p2: 0,
    data: (0, serialize_1$1.hex_to_buf)(scriptDataHash)
  });
}
function* signTx_addCollateralInput(collateralInput) {
  yield send({
    p1: 13,
    p2: 0,
    data: (0, txOther_1.serializeTxInput)(collateralInput),
    expectedResponseLength: 0
  });
}
function* signTx_addRequiredSigner(requiredSigner) {
  yield send({
    p1: 14,
    p2: 0,
    data: (0, txOther_1.serializeRequiredSigner)(requiredSigner),
    expectedResponseLength: 0
  });
}
function* signTx_addCollateralOutput(collateralOutput, version2) {
  yield send({
    p1: 18,
    p2: 48,
    data: (0, txOutput_1.serializeTxOutputBasicParams)(collateralOutput, version2),
    expectedResponseLength: 0
  });
  yield* signTx_addTokenBundle(collateralOutput.tokenBundle, 18, serialize_1$1.uint64_to_buf);
  yield send({
    p1: 18,
    p2: 51,
    data: Buffer$1.concat([]),
    expectedResponseLength: 0
  });
}
function* signTx_addTotalCollateral(totalCollateral) {
  yield send({
    p1: 16,
    p2: 0,
    data: (0, serialize_1$1.serializeCoin)(totalCollateral),
    expectedResponseLength: 0
  });
}
function* signTx_addReferenceInput(referenceInput) {
  yield send({
    p1: 17,
    p2: 0,
    data: (0, txOther_1.serializeTxInput)(referenceInput),
    expectedResponseLength: 0
  });
}
function* signTx_addVoterVotes(voterVotes) {
  yield send({
    p1: 19,
    p2: 0,
    data: (0, txOther_1.serializeVoterVotes)(voterVotes),
    expectedResponseLength: 0
  });
}
function* signTx_addTreasury(treasury) {
  yield send({
    p1: 21,
    p2: 0,
    data: (0, serialize_1$1.serializeCoin)(treasury),
    expectedResponseLength: 0
  });
}
function* signTx_addDonation(donation) {
  yield send({
    p1: 22,
    p2: 0,
    data: (0, serialize_1$1.serializeCoin)(donation),
    expectedResponseLength: 0
  });
}
function* signTx_awaitConfirm() {
  const response = yield send({
    p1: 10,
    p2: 0,
    data: Buffer$1.alloc(0),
    expectedResponseLength: internal_1$6.TX_HASH_LENGTH
  });
  return {
    txHashHex: response.toString("hex")
  };
}
function* signTx_getWitness(path2) {
  const response = yield send({
    p1: 15,
    p2: 0,
    data: (0, txOther_1.serializeTxWitnessRequest)(path2),
    expectedResponseLength: internal_1$6.ED25519_SIGNATURE_LENGTH
  });
  return {
    path: path2,
    witnessSignatureHex: (0, serialize_1$1.buf_to_hex)(response)
  };
}
function uniquify(witnessPaths) {
  const uniquifier = {};
  witnessPaths.forEach((p) => {
    uniquifier[JSON.stringify(p)] = p;
  });
  return Object.values(uniquifier);
}
function gatherWitnessPaths(request) {
  const { tx, signingMode, additionalWitnessPaths } = request;
  const witnessPaths = [];
  if (signingMode !== public_1$5.TransactionSigningMode.MULTISIG_TRANSACTION) {
    for (const input of tx.inputs) {
      if (input.path != null) {
        witnessPaths.push(input.path);
      }
    }
    for (const cert of tx.certificates) {
      switch (cert.type) {
        case internal_1$6.CertificateType.STAKE_REGISTRATION_CONWAY:
        case internal_1$6.CertificateType.STAKE_DEREGISTRATION:
        case internal_1$6.CertificateType.STAKE_DEREGISTRATION_CONWAY:
        case internal_1$6.CertificateType.STAKE_DELEGATION:
        case internal_1$6.CertificateType.VOTE_DELEGATION:
          if (cert.stakeCredential.type === 0) {
            witnessPaths.push(cert.stakeCredential.path);
          }
          break;
        case internal_1$6.CertificateType.AUTHORIZE_COMMITTEE_HOT:
        case internal_1$6.CertificateType.RESIGN_COMMITTEE_COLD:
          if (cert.coldCredential.type === 0) {
            witnessPaths.push(cert.coldCredential.path);
          }
          break;
        case internal_1$6.CertificateType.DREP_REGISTRATION:
        case internal_1$6.CertificateType.DREP_DEREGISTRATION:
        case internal_1$6.CertificateType.DREP_UPDATE:
          if (cert.dRepCredential.type === 0) {
            witnessPaths.push(cert.dRepCredential.path);
          }
          break;
        case internal_1$6.CertificateType.STAKE_POOL_REGISTRATION:
          cert.pool.owners.forEach((owner) => {
            if (owner.type === internal_1$6.PoolOwnerType.DEVICE_OWNED) {
              witnessPaths.push(owner.path);
            }
          });
          if (cert.pool.poolKey.type === public_1$5.PoolKeyType.DEVICE_OWNED) {
            witnessPaths.push(cert.pool.poolKey.path);
          }
          break;
        case internal_1$6.CertificateType.STAKE_POOL_RETIREMENT:
          witnessPaths.push(cert.path);
          break;
      }
    }
    for (const withdrawal of tx.withdrawals) {
      if (withdrawal.stakeCredential.type === 0) {
        witnessPaths.push(withdrawal.stakeCredential.path);
      }
    }
    for (const signer of tx.requiredSigners) {
      switch (signer.type) {
        case 0:
          witnessPaths.push(signer.path);
          break;
      }
    }
    for (const collateral of tx.collateralInputs) {
      if (collateral.path != null) {
        witnessPaths.push(collateral.path);
      }
    }
    for (const voterVotes of tx.votingProcedures) {
      switch (voterVotes.voter.type) {
        case public_1$5.VoterType.COMMITTEE_KEY_PATH:
        case public_1$5.VoterType.DREP_KEY_PATH:
        case public_1$5.VoterType.STAKE_POOL_KEY_PATH:
          witnessPaths.push(voterVotes.voter.keyPath);
          break;
      }
    }
  }
  additionalWitnessPaths.forEach((path2) => witnessPaths.push(path2));
  return uniquify(witnessPaths);
}
function hasCredentialInCertificatesPreConway(tx, credentialType) {
  return tx.certificates.some((c) => (c.type === internal_1$6.CertificateType.STAKE_DELEGATION || c.type === internal_1$6.CertificateType.STAKE_REGISTRATION || c.type === internal_1$6.CertificateType.STAKE_DEREGISTRATION) && c.stakeCredential.type === credentialType);
}
function hasCredentialInWithdrawals(tx, stakeCredentialType) {
  return tx.withdrawals.some((w) => w.stakeCredential.type === stakeCredentialType);
}
function hasScriptHashInAddressParams(tx) {
  const scriptAddressTypes = [
    public_1$5.AddressType.BASE_PAYMENT_KEY_STAKE_SCRIPT,
    public_1$5.AddressType.BASE_PAYMENT_SCRIPT_STAKE_KEY,
    public_1$5.AddressType.BASE_PAYMENT_SCRIPT_STAKE_SCRIPT,
    public_1$5.AddressType.ENTERPRISE_SCRIPT,
    public_1$5.AddressType.POINTER_SCRIPT,
    public_1$5.AddressType.REWARD_SCRIPT
  ];
  return tx.outputs.some((o) => o.destination.type === public_1$5.TxOutputDestinationType.DEVICE_OWNED && scriptAddressTypes.includes(o.destination.addressParams.type));
}
function ensureRequestSupportedByAppVersion(version2, request) {
  var _a, _b, _c;
  if (request.signingMode === public_1$5.TransactionSigningMode.POOL_REGISTRATION_AS_OWNER && !(0, getVersion_1.getCompatibility)(version2).supportsPoolRegistrationAsOwner) {
    throw new errors_1$5.DeviceVersionUnsupported(`Pool registration as owner not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.signingMode === public_1$5.TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR && !(0, getVersion_1.getCompatibility)(version2).supportsPoolRegistrationAsOperator) {
    throw new errors_1$5.DeviceVersionUnsupported(`Pool registration as operator not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.signingMode === public_1$5.TransactionSigningMode.MULTISIG_TRANSACTION && !(0, getVersion_1.getCompatibility)(version2).supportsMultisigTransaction) {
    throw new errors_1$5.DeviceVersionUnsupported(`Multisig transactions not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.signingMode === public_1$5.TransactionSigningMode.PLUTUS_TRANSACTION && !(0, getVersion_1.getCompatibility)(version2).supportsAlonzo) {
    throw new errors_1$5.DeviceVersionUnsupported(`Plutus transactions not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  const isOutputByron = (o) => o != null && o.destination.type === public_1$5.TxOutputDestinationType.DEVICE_OWNED && o.destination.addressParams.type === public_1$5.AddressType.BYRON;
  const hasByronAddressParam = request.tx.outputs.some(isOutputByron) || isOutputByron(request.tx.collateralOutput);
  if (hasByronAddressParam && !(0, getVersion_1.getCompatibility)(version2).supportsByronAddressDerivation) {
    throw new errors_1$5.DeviceVersionUnsupported(`Byron address parameters not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (hasScriptHashInAddressParams(request.tx) && !(0, getVersion_1.getCompatibility)(version2).supportsMultisigTransaction) {
    throw new errors_1$5.DeviceVersionUnsupported(`Script hash in address parameters in output not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  const hasDatumInOutputs = request.tx.outputs.some((o) => o.datum != null);
  if (hasDatumInOutputs && !(0, getVersion_1.getCompatibility)(version2).supportsAlonzo) {
    throw new errors_1$5.DeviceVersionUnsupported(`Datum in output not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  const hasMapFormatInOutputs = request.tx.outputs.some((o) => o.format === public_1$5.TxOutputFormat.MAP_BABBAGE);
  if (hasMapFormatInOutputs && !(0, getVersion_1.getCompatibility)(version2).supportsBabbage) {
    throw new errors_1$5.DeviceVersionUnsupported(`Outputs with map format not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (((_a = request.tx) === null || _a === void 0 ? void 0 : _a.ttl) === "0" && !(0, getVersion_1.getCompatibility)(version2).supportsZeroTtl) {
    throw new errors_1$5.DeviceVersionUnsupported(`Zero TTL not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  const hasPoolRegistration = request.tx.certificates.some((c) => c.type === internal_1$6.CertificateType.STAKE_POOL_REGISTRATION);
  const supportsPoolRegistration = (0, getVersion_1.getCompatibility)(version2).supportsPoolRegistrationAsOwner || (0, getVersion_1.getCompatibility)(version2).supportsPoolRegistrationAsOperator;
  if (hasPoolRegistration && !supportsPoolRegistration) {
    throw new errors_1$5.DeviceVersionUnsupported(`Pool registration certificate not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  const hasPoolRetirement = request.tx.certificates.some((c) => c.type === internal_1$6.CertificateType.STAKE_POOL_RETIREMENT);
  if (hasPoolRetirement && !(0, getVersion_1.getCompatibility)(version2).supportsPoolRetirement) {
    throw new errors_1$5.DeviceVersionUnsupported(`Pool retirement certificate not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  const conwayCertificateTypes = [
    internal_1$6.CertificateType.STAKE_REGISTRATION_CONWAY,
    internal_1$6.CertificateType.STAKE_DEREGISTRATION_CONWAY,
    internal_1$6.CertificateType.VOTE_DELEGATION,
    internal_1$6.CertificateType.AUTHORIZE_COMMITTEE_HOT,
    internal_1$6.CertificateType.RESIGN_COMMITTEE_COLD,
    internal_1$6.CertificateType.DREP_REGISTRATION,
    internal_1$6.CertificateType.DREP_DEREGISTRATION,
    internal_1$6.CertificateType.DREP_UPDATE
  ];
  const hasConwayCertificates = request.tx.certificates.some((c) => conwayCertificateTypes.includes(c.type));
  if (hasConwayCertificates && !(0, getVersion_1.getCompatibility)(version2).supportsConway) {
    throw new errors_1$5.DeviceVersionUnsupported(`Conway era certificates not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (hasCredentialInCertificatesPreConway(request.tx, 1) && !(0, getVersion_1.getCompatibility)(version2).supportsMultisigTransaction) {
    throw new errors_1$5.DeviceVersionUnsupported(`Script hash in certificate stake credential not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (hasCredentialInCertificatesPreConway(request.tx, 2) && !(0, getVersion_1.getCompatibility)(version2).supportsAlonzo) {
    throw new errors_1$5.DeviceVersionUnsupported(`Key hash in certificate stake credential not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (hasCredentialInWithdrawals(request.tx, 1) && !(0, getVersion_1.getCompatibility)(version2).supportsMultisigTransaction) {
    throw new errors_1$5.DeviceVersionUnsupported(`Script hash in withdrawal not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (hasCredentialInWithdrawals(request.tx, 2) && !(0, getVersion_1.getCompatibility)(version2).supportsAlonzo) {
    throw new errors_1$5.DeviceVersionUnsupported(`Key hash in withdrawal not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (((_b = request.tx) === null || _b === void 0 ? void 0 : _b.mint) !== null && !(0, getVersion_1.getCompatibility)(version2).supportsMint) {
    throw new errors_1$5.DeviceVersionUnsupported(`Mint not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.tx.validityIntervalStart !== null && !(0, getVersion_1.getCompatibility)(version2).supportsMary) {
    throw new errors_1$5.DeviceVersionUnsupported(`Validity interval start not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.tx.scriptDataHashHex !== null && !(0, getVersion_1.getCompatibility)(version2).supportsAlonzo) {
    throw new errors_1$5.DeviceVersionUnsupported(`Script data hash not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.tx.collateralInputs.length > 0 && !(0, getVersion_1.getCompatibility)(version2).supportsAlonzo) {
    throw new errors_1$5.DeviceVersionUnsupported(`Collateral inputs not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.tx.requiredSigners.length > 0) {
    if (!(0, getVersion_1.getCompatibility)(version2).supportsAlonzo) {
      throw new errors_1$5.DeviceVersionUnsupported(`Required signers not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
    }
    if (!(0, getVersion_1.getCompatibility)(version2).supportsReqSignersInOrdinaryTx) {
      switch (request.signingMode) {
        case public_1$5.TransactionSigningMode.ORDINARY_TRANSACTION:
          throw new errors_1$5.DeviceVersionUnsupported(`Required signers in ordinary transaction not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
        case public_1$5.TransactionSigningMode.MULTISIG_TRANSACTION:
          throw new errors_1$5.DeviceVersionUnsupported(`Required signers in multisig transaction not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
      }
    }
  }
  if (request.tx.includeNetworkId !== null && !(0, getVersion_1.getCompatibility)(version2).supportsAlonzo) {
    throw new errors_1$5.DeviceVersionUnsupported(`Network id in tx body not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.tx.collateralOutput !== null && !(0, getVersion_1.getCompatibility)(version2).supportsBabbage) {
    throw new errors_1$5.DeviceVersionUnsupported(`Collateral output not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.tx.totalCollateral !== null && !(0, getVersion_1.getCompatibility)(version2).supportsBabbage) {
    throw new errors_1$5.DeviceVersionUnsupported(`Total collateral not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.tx.referenceInputs.length > 0 && !(0, getVersion_1.getCompatibility)(version2).supportsBabbage) {
    throw new errors_1$5.DeviceVersionUnsupported(`Reference inputs not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.tx.votingProcedures.length > 0 && !(0, getVersion_1.getCompatibility)(version2).supportsConway) {
    throw new errors_1$5.DeviceVersionUnsupported(`Voting procedures not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.tx.treasury !== null && !(0, getVersion_1.getCompatibility)(version2).supportsConway) {
    throw new errors_1$5.DeviceVersionUnsupported(`Treasury amount not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  if (request.tx.donation !== null && !(0, getVersion_1.getCompatibility)(version2).supportsConway) {
    throw new errors_1$5.DeviceVersionUnsupported(`Treasury donation not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  const auxiliaryData = (_c = request.tx) === null || _c === void 0 ? void 0 : _c.auxiliaryData;
  const hasCIP15Registration = (auxiliaryData === null || auxiliaryData === void 0 ? void 0 : auxiliaryData.type) === public_1$5.TxAuxiliaryDataType.CIP36_REGISTRATION && auxiliaryData.params.format === public_1$5.CIP36VoteRegistrationFormat.CIP_15;
  if (hasCIP15Registration && !(0, getVersion_1.getCompatibility)(version2).supportsCatalystRegistration) {
    throw new errors_1$5.DeviceVersionUnsupported(`Catalyst registration not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  const hasCIP36Registration = (auxiliaryData === null || auxiliaryData === void 0 ? void 0 : auxiliaryData.type) === public_1$5.TxAuxiliaryDataType.CIP36_REGISTRATION && auxiliaryData.params.format === public_1$5.CIP36VoteRegistrationFormat.CIP_36;
  if (hasCIP36Registration && !(0, getVersion_1.getCompatibility)(version2).supportsCIP36) {
    throw new errors_1$5.DeviceVersionUnsupported(`CIP36 registration not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  const hasKeyPath = (auxiliaryData === null || auxiliaryData === void 0 ? void 0 : auxiliaryData.type) === public_1$5.TxAuxiliaryDataType.CIP36_REGISTRATION && auxiliaryData.params.votePublicKeyPath != null;
  if (hasKeyPath && !(0, getVersion_1.getCompatibility)(version2).supportsCIP36Vote) {
    throw new errors_1$5.DeviceVersionUnsupported(`Vote key derivation path in CIP15/CIP36 registration not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
  const thirdPartyPayment = (auxiliaryData === null || auxiliaryData === void 0 ? void 0 : auxiliaryData.type) === public_1$5.TxAuxiliaryDataType.CIP36_REGISTRATION && auxiliaryData.params.paymentDestination.type !== public_1$5.TxOutputDestinationType.DEVICE_OWNED;
  if (thirdPartyPayment && !(0, getVersion_1.getCompatibility)(version2).supportsCIP36) {
    throw new errors_1$5.DeviceVersionUnsupported(`CIP36 payment addresses not owned by the device not supported by Ledger app version ${(0, utils_1.getVersionString)(version2)}.`);
  }
}
function* signTransaction(version2, request) {
  (0, getVersion_1.ensureLedgerAppVersionCompatible)(version2);
  ensureRequestSupportedByAppVersion(version2, request);
  const auxDataBeforeTxBody = (0, getVersion_1.getCompatibility)(version2).supportsCatalystRegistration || (0, getVersion_1.getCompatibility)(version2).supportsCIP36;
  const { tx, signingMode } = request;
  const witnessPaths = gatherWitnessPaths(request);
  yield* signTx_init(tx, signingMode, witnessPaths, request.options, version2);
  let auxiliaryDataSupplement = null;
  if (auxDataBeforeTxBody && tx.auxiliaryData != null) {
    auxiliaryDataSupplement = yield* signTx_setAuxiliaryData(tx.auxiliaryData, version2);
  }
  for (const input of tx.inputs) {
    yield* signTx_addInput(input);
  }
  for (const output2 of tx.outputs) {
    yield* signTx_addOutput(output2, version2);
  }
  yield* signTx_setFee(tx.fee);
  if (tx.ttl != null) {
    yield* signTx_setTtl(tx.ttl);
  }
  for (const certificate2 of tx.certificates) {
    yield* signTx_addCertificate(certificate2, version2);
  }
  for (const withdrawal of tx.withdrawals) {
    yield* signTx_addWithdrawal(withdrawal, version2);
  }
  if (!auxDataBeforeTxBody && tx.auxiliaryData != null) {
    auxiliaryDataSupplement = yield* signTx_setAuxiliaryData_before_v2_3(tx.auxiliaryData);
  }
  if (tx.validityIntervalStart != null) {
    yield* signTx_setValidityIntervalStart(tx.validityIntervalStart);
  }
  if (tx.mint != null) {
    yield* signTx_setMint(tx.mint);
  }
  if (tx.scriptDataHashHex != null) {
    yield* signTx_setScriptDataHash(tx.scriptDataHashHex);
  }
  for (const input of tx.collateralInputs) {
    yield* signTx_addCollateralInput(input);
  }
  for (const input of tx.requiredSigners) {
    yield* signTx_addRequiredSigner(input);
  }
  if (tx.collateralOutput != null) {
    yield* signTx_addCollateralOutput(tx.collateralOutput, version2);
  }
  if (tx.totalCollateral != null) {
    yield* signTx_addTotalCollateral(tx.totalCollateral);
  }
  for (const referenceInput of tx.referenceInputs) {
    yield* signTx_addReferenceInput(referenceInput);
  }
  for (const voterVotes of tx.votingProcedures) {
    yield* signTx_addVoterVotes(voterVotes);
  }
  if (tx.treasury != null) {
    yield* signTx_addTreasury(tx.treasury);
  }
  if (tx.donation != null) {
    yield* signTx_addDonation(tx.donation);
  }
  const { txHashHex } = yield* signTx_awaitConfirm();
  const witnesses = [];
  for (const path2 of witnessPaths) {
    const witness = yield* signTx_getWitness(path2);
    witnesses.push(witness);
  }
  return {
    txHashHex,
    witnesses,
    auxiliaryDataSupplement
  };
}
signTx.signTransaction = signTransaction;
var cVote = {};
Object.defineProperty(cVote, "__esModule", { value: true });
cVote.parseCVote = void 0;
const invalidDataReason_1$5 = invalidDataReason;
const parse_1$6 = parse;
function parseCVote(cVote2) {
  const voteCastDataHex = (0, parse_1$6.parseHexString)(cVote2.voteCastDataHex, invalidDataReason_1$5.InvalidDataReason.CVOTE_INVALID_VOTECAST_DATA);
  const MIN_VOTECAST_LENGTH = 32 + 1 + 1 + 1;
  (0, parse_1$6.validate)(voteCastDataHex.length >= 2 * MIN_VOTECAST_LENGTH, invalidDataReason_1$5.InvalidDataReason.CVOTE_INVALID_VOTECAST_DATA);
  const witnessPath = (0, parse_1$6.parseBIP32Path)(cVote2.witnessPath, invalidDataReason_1$5.InvalidDataReason.CVOTE_INVALID_WITNESS);
  return {
    voteCastDataHex,
    witnessPath
  };
}
cVote.parseCVote = parseCVote;
var nativeScript = {};
Object.defineProperty(nativeScript, "__esModule", { value: true });
nativeScript.parseNativeScriptHashDisplayFormat = nativeScript.parseNativeScript = void 0;
const errors_1$4 = errors$4;
const internal_1$5 = internal;
const public_1$4 = _public;
const parse_1$5 = parse;
function parseNativeScript(script) {
  const params2 = script.params;
  switch (script.type) {
    case public_1$4.NativeScriptType.PUBKEY_DEVICE_OWNED: {
      (0, parse_1$5.validate)(params2.keyHashHex == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.requiredCount == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.slot == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.scripts == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      return {
        type: script.type,
        params: {
          path: (0, parse_1$5.parseBIP32Path)(params2.path, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_KEY_PATH)
        }
      };
    }
    case public_1$4.NativeScriptType.PUBKEY_THIRD_PARTY: {
      (0, parse_1$5.validate)(params2.path == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.requiredCount == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.slot == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.scripts == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      return {
        type: script.type,
        params: {
          keyHashHex: (0, parse_1$5.parseHexStringOfLength)(params2.keyHashHex, internal_1$5.KEY_HASH_LENGTH, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_KEY_HASH)
        }
      };
    }
    case public_1$4.NativeScriptType.ALL:
    case public_1$4.NativeScriptType.ANY: {
      (0, parse_1$5.validate)(params2.path == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.keyHashHex == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.requiredCount == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.slot == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)((0, parse_1$5.isArray)(params2.scripts), errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_SCRIPTS_NOT_AN_ARRAY);
      return {
        type: script.type,
        params: {
          scripts: params2.scripts.map(parseNativeScript)
        }
      };
    }
    case public_1$4.NativeScriptType.N_OF_K: {
      (0, parse_1$5.validate)(params2.path == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.keyHashHex == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.slot == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)((0, parse_1$5.isArray)(params2.scripts), errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_SCRIPTS_NOT_AN_ARRAY);
      const requiredCount = (0, parse_1$5.parseUint32_t)(params2.requiredCount, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_REQUIRED_COUNT);
      (0, parse_1$5.validate)(requiredCount <= params2.scripts.length, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_REQUIRED_COUNT_HIGHER_THAN_NUMBER_OF_SCRIPTS);
      return {
        type: script.type,
        params: {
          requiredCount,
          scripts: params2.scripts.map(parseNativeScript)
        }
      };
    }
    case public_1$4.NativeScriptType.INVALID_BEFORE:
    case public_1$4.NativeScriptType.INVALID_HEREAFTER: {
      (0, parse_1$5.validate)(params2.path == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.keyHashHex == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.requiredCount == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      (0, parse_1$5.validate)(params2.scripts == null, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DATA);
      return {
        type: script.type,
        params: {
          slot: (0, parse_1$5.parseUint64_str)(params2.slot, {}, errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_TOKEN_LOCKING_SLOT)
        }
      };
    }
    default:
      throw new errors_1$4.InvalidData(errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_UNKNOWN_TYPE);
  }
}
nativeScript.parseNativeScript = parseNativeScript;
function parseNativeScriptHashDisplayFormat(displayFormat) {
  switch (displayFormat) {
    case public_1$4.NativeScriptHashDisplayFormat.BECH32:
    case public_1$4.NativeScriptHashDisplayFormat.POLICY_ID:
      break;
    default:
      throw new errors_1$4.InvalidData(errors_1$4.InvalidDataReason.DERIVE_NATIVE_SCRIPT_HASH_INVALID_DISPLAY_FORMAT);
  }
  return displayFormat;
}
nativeScript.parseNativeScriptHashDisplayFormat = parseNativeScriptHashDisplayFormat;
var operationalCertificate = {};
Object.defineProperty(operationalCertificate, "__esModule", { value: true });
operationalCertificate.parseOperationalCertificate = void 0;
const invalidDataReason_1$4 = invalidDataReason;
const internal_1$4 = internal;
const parse_1$4 = parse;
function parseOperationalCertificate(operationalCertificate2) {
  return {
    kesPublicKeyHex: (0, parse_1$4.parseHexStringOfLength)(operationalCertificate2.kesPublicKeyHex, internal_1$4.KES_PUBLIC_KEY_LENGTH, invalidDataReason_1$4.InvalidDataReason.OPERATIONAL_CERTIFICATE_INVALID_KES_KEY),
    kesPeriod: (0, parse_1$4.parseUint64_str)(operationalCertificate2.kesPeriod, {}, invalidDataReason_1$4.InvalidDataReason.OPERATIONAL_CERTIFICATE_INVALID_KES_PERIOD),
    issueCounter: (0, parse_1$4.parseUint64_str)(operationalCertificate2.issueCounter, {}, invalidDataReason_1$4.InvalidDataReason.OPERATIONAL_CERTIFICATE_INVALID_ISSUE_COUNTER),
    coldKeyPath: (0, parse_1$4.parseBIP32Path)(operationalCertificate2.coldKeyPath, invalidDataReason_1$4.InvalidDataReason.OPERATIONAL_CERTIFICATE_INVALID_COLD_KEY_PATH)
  };
}
operationalCertificate.parseOperationalCertificate = parseOperationalCertificate;
var transaction = {};
var certificate = {};
var poolRegistration = {};
Object.defineProperty(poolRegistration, "__esModule", { value: true });
poolRegistration.parsePoolParams = void 0;
const errors_1$3 = errors$4;
const invalidDataReason_1$3 = invalidDataReason;
const internal_1$3 = internal;
const public_1$3 = _public;
const parse_1$3 = parse;
const serialize_1 = serialize;
const constants_1$2 = constants$2;
function parseMargin(params2) {
  const POOL_MARGIN_DENOMINATOR_MAX_STR = "1 000 000 000 000 000 000".replace(/[ ]/, "");
  const marginDenominator = (0, parse_1$3.parseUint64_str)(params2.denominator, { max: POOL_MARGIN_DENOMINATOR_MAX_STR }, invalidDataReason_1$3.InvalidDataReason.POOL_REGISTRATION_INVALID_MARGIN_DENOMINATOR);
  const marginNumerator = (0, parse_1$3.parseUint64_str)(params2.numerator, { max: marginDenominator }, invalidDataReason_1$3.InvalidDataReason.POOL_REGISTRATION_INVALID_MARGIN);
  return {
    numerator: marginNumerator,
    denominator: marginDenominator
  };
}
function parsePoolKey(poolKey) {
  switch (poolKey.type) {
    case public_1$3.PoolKeyType.DEVICE_OWNED: {
      const params2 = poolKey.params;
      const path2 = (0, parse_1$3.parseBIP32Path)(params2.path, invalidDataReason_1$3.InvalidDataReason.POOL_KEY_INVALID_PATH);
      return {
        type: public_1$3.PoolKeyType.DEVICE_OWNED,
        path: path2
      };
    }
    case public_1$3.PoolKeyType.THIRD_PARTY: {
      const params2 = poolKey.params;
      const hashHex = (0, parse_1$3.parseHexStringOfLength)(params2.keyHashHex, internal_1$3.KEY_HASH_LENGTH, invalidDataReason_1$3.InvalidDataReason.POOL_KEY_INVALID_KEY_HASH);
      return {
        type: public_1$3.PoolKeyType.THIRD_PARTY,
        hashHex
      };
    }
    default:
      throw new errors_1$3.InvalidData(invalidDataReason_1$3.InvalidDataReason.POOL_KEY_INVALID_TYPE);
  }
}
function parsePoolOwnerParams(poolOwner) {
  switch (poolOwner.type) {
    case public_1$3.PoolOwnerType.DEVICE_OWNED: {
      const params2 = poolOwner.params;
      const path2 = (0, parse_1$3.parseBIP32Path)(params2.stakingPath, invalidDataReason_1$3.InvalidDataReason.POOL_OWNER_INVALID_PATH);
      return {
        type: public_1$3.PoolOwnerType.DEVICE_OWNED,
        path: path2
      };
    }
    case public_1$3.PoolOwnerType.THIRD_PARTY: {
      const params2 = poolOwner.params;
      const hashHex = (0, parse_1$3.parseHexStringOfLength)(params2.stakingKeyHashHex, internal_1$3.KEY_HASH_LENGTH, invalidDataReason_1$3.InvalidDataReason.POOL_OWNER_INVALID_KEY_HASH);
      return {
        type: public_1$3.PoolOwnerType.THIRD_PARTY,
        hashHex
      };
    }
    default:
      throw new errors_1$3.InvalidData(invalidDataReason_1$3.InvalidDataReason.POOL_OWNER_INVALID_TYPE);
  }
}
function parseRewardAccount(poolRewardAccount) {
  switch (poolRewardAccount.type) {
    case public_1$3.PoolRewardAccountType.DEVICE_OWNED: {
      const params2 = poolRewardAccount.params;
      const path2 = (0, parse_1$3.parseBIP32Path)(params2.path, invalidDataReason_1$3.InvalidDataReason.POOL_REWARD_ACCOUNT_INVALID_PATH);
      return {
        type: public_1$3.PoolRewardAccountType.DEVICE_OWNED,
        path: path2
      };
    }
    case public_1$3.PoolRewardAccountType.THIRD_PARTY: {
      const params2 = poolRewardAccount.params;
      const rewardAccountHex = (0, parse_1$3.parseHexStringOfLength)(params2.rewardAccountHex, internal_1$3.REWARD_ACCOUNT_HEX_LENGTH, invalidDataReason_1$3.InvalidDataReason.POOL_REWARD_ACCOUNT_INVALID_HEX);
      return {
        type: public_1$3.PoolRewardAccountType.THIRD_PARTY,
        rewardAccountHex
      };
    }
    default:
      throw new errors_1$3.InvalidData(invalidDataReason_1$3.InvalidDataReason.POOL_REWARD_ACCOUNT_INVALID_TYPE);
  }
}
function parsePort(portNumber, errMsg) {
  (0, parse_1$3.validate)((0, parse_1$3.isUint16)(portNumber), errMsg);
  return portNumber;
}
function parseIPv4(ipv4, errMsg) {
  (0, parse_1$3.validate)((0, parse_1$3.isString)(ipv4), errMsg);
  const ipParts = ipv4.split(".");
  (0, parse_1$3.validate)(ipParts.length === 4, errMsg);
  const ipBytes = Buffer$1.alloc(4);
  for (let i = 0; i < 4; i++) {
    const ipPart = (0, parse_1$3.parseIntFromStr)(ipParts[i], invalidDataReason_1$3.InvalidDataReason.RELAY_INVALID_IPV4);
    (0, parse_1$3.validate)((0, parse_1$3.isUint8)(ipPart), errMsg);
    ipBytes.writeUInt8(ipPart, i);
  }
  return ipBytes;
}
function parseIPv6(ipv6, errMsg) {
  (0, parse_1$3.validate)((0, parse_1$3.isString)(ipv6), errMsg);
  const ipHex = ipv6.split(":").join("");
  (0, parse_1$3.validate)((0, parse_1$3.isHexStringOfLength)(ipHex, 16), errMsg);
  return (0, serialize_1.hex_to_buf)(ipHex);
}
function parseDnsName(dnsName, errMsg) {
  (0, parse_1$3.validate)((0, parse_1$3.isString)(dnsName), errMsg);
  (0, parse_1$3.validate)(dnsName.length <= internal_1$3.MAX_DNS_NAME_LENGTH, errMsg);
  (0, parse_1$3.validate)(dnsName.length > 0, errMsg);
  (0, parse_1$3.validate)(/^[\x00-\x7F]*$/.test(dnsName), errMsg);
  (0, parse_1$3.validate)(dnsName.split("").every((c) => c.charCodeAt(0) >= 32 && c.charCodeAt(0) <= 126), errMsg);
  return dnsName;
}
function parsePoolRelayParams(relayParams) {
  switch (relayParams.type) {
    case 0: {
      const params2 = relayParams.params;
      return {
        type: 0,
        port: "portNumber" in params2 && params2.portNumber != null ? parsePort(params2.portNumber, invalidDataReason_1$3.InvalidDataReason.RELAY_INVALID_PORT) : null,
        ipv4: "ipv4" in params2 && params2.ipv4 != null ? parseIPv4(params2.ipv4, invalidDataReason_1$3.InvalidDataReason.RELAY_INVALID_IPV4) : null,
        ipv6: "ipv6" in params2 && params2.ipv6 != null ? parseIPv6(params2.ipv6, invalidDataReason_1$3.InvalidDataReason.RELAY_INVALID_IPV6) : null
      };
    }
    case 1: {
      const params2 = relayParams.params;
      return {
        type: 1,
        port: "portNumber" in params2 && params2.portNumber != null ? parsePort(params2.portNumber, invalidDataReason_1$3.InvalidDataReason.RELAY_INVALID_PORT) : null,
        dnsName: parseDnsName(params2.dnsName, invalidDataReason_1$3.InvalidDataReason.RELAY_INVALID_DNS)
      };
    }
    case 2: {
      const params2 = relayParams.params;
      return {
        type: 2,
        dnsName: parseDnsName(params2.dnsName, invalidDataReason_1$3.InvalidDataReason.RELAY_INVALID_DNS)
      };
    }
    default:
      throw new errors_1$3.InvalidData(invalidDataReason_1$3.InvalidDataReason.RELAY_INVALID_TYPE);
  }
}
function parsePoolMetadataParams(params2) {
  const url = (0, parse_1$3.parseAscii)(params2.metadataUrl, invalidDataReason_1$3.InvalidDataReason.POOL_REGISTRATION_METADATA_INVALID_URL);
  (0, parse_1$3.validate)(url.length <= internal_1$3.MAX_URL_LENGTH, invalidDataReason_1$3.InvalidDataReason.POOL_REGISTRATION_METADATA_INVALID_URL);
  const hashHex = (0, parse_1$3.parseHexStringOfLength)(params2.metadataHashHex, internal_1$3.AUXILIARY_DATA_HASH_LENGTH, invalidDataReason_1$3.InvalidDataReason.POOL_REGISTRATION_METADATA_INVALID_HASH);
  return {
    url,
    hashHex,
    __brand: "pool_metadata"
  };
}
function parsePoolParams(params2) {
  const poolKey = parsePoolKey(params2.poolKey);
  const vrfHashHex = (0, parse_1$3.parseHexStringOfLength)(params2.vrfKeyHashHex, internal_1$3.VRF_KEY_HASH_LENGTH, invalidDataReason_1$3.InvalidDataReason.POOL_REGISTRATION_INVALID_VRF_KEY_HASH);
  const pledge = (0, parse_1$3.parseCoin)(params2.pledge, invalidDataReason_1$3.InvalidDataReason.POOL_REGISTRATION_INVALID_PLEDGE);
  const cost = (0, parse_1$3.parseCoin)(params2.cost, invalidDataReason_1$3.InvalidDataReason.POOL_REGISTRATION_INVALID_COST);
  const margin = parseMargin(params2.margin);
  const rewardAccount = parseRewardAccount(params2.rewardAccount);
  const owners = params2.poolOwners.map((owner) => parsePoolOwnerParams(owner));
  const relays = params2.relays.map((relay) => parsePoolRelayParams(relay));
  const metadata = params2.metadata == null ? null : parsePoolMetadataParams(params2.metadata);
  (0, parse_1$3.validate)(owners.length <= constants_1$2.POOL_REGISTRATION_OWNERS_MAX, invalidDataReason_1$3.InvalidDataReason.POOL_REGISTRATION_OWNERS_TOO_MANY);
  (0, parse_1$3.validate)(relays.length <= constants_1$2.POOL_REGISTRATION_RELAYS_MAX, invalidDataReason_1$3.InvalidDataReason.POOL_REGISTRATION_RELAYS_TOO_MANY);
  return {
    poolKey,
    vrfHashHex,
    pledge,
    cost,
    margin,
    rewardAccount,
    owners,
    relays,
    metadata
  };
}
poolRegistration.parsePoolParams = parsePoolParams;
Object.defineProperty(certificate, "__esModule", { value: true });
certificate.parseCertificate = void 0;
const assert_1$1 = assert$1;
const errors_1$2 = errors$4;
const invalidDataReason_1$2 = invalidDataReason;
const internal_1$2 = internal;
const public_1$2 = _public;
const parse_1$2 = parse;
const poolRegistration_1 = poolRegistration;
function parseDRep(dRep, errMsg) {
  switch (dRep.type) {
    case public_1$2.DRepParamsType.KEY_PATH:
      return {
        type: 100,
        path: (0, parse_1$2.parseBIP32Path)(dRep.keyPath, errMsg)
      };
    case public_1$2.DRepParamsType.KEY_HASH:
      return {
        type: 0,
        keyHashHex: (0, parse_1$2.parseHexStringOfLength)(dRep.keyHashHex, internal_1$2.KEY_HASH_LENGTH, errMsg)
      };
    case public_1$2.DRepParamsType.SCRIPT_HASH:
      return {
        type: 1,
        scriptHashHex: (0, parse_1$2.parseHexStringOfLength)(dRep.scriptHashHex, internal_1$2.SCRIPT_HASH_LENGTH, errMsg)
      };
    case public_1$2.DRepParamsType.ABSTAIN:
      return {
        type: 2
      };
    case public_1$2.DRepParamsType.NO_CONFIDENCE:
      return {
        type: 3
      };
    default:
      (0, assert_1$1.unreachable)(dRep);
  }
}
function parseDeposit(deposit) {
  return (0, parse_1$2.parseCoin)(deposit, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_DEPOSIT);
}
function parseCertificate(cert) {
  switch (cert.type) {
    case internal_1$2.CertificateType.STAKE_REGISTRATION:
    case internal_1$2.CertificateType.STAKE_DEREGISTRATION: {
      return {
        type: cert.type,
        stakeCredential: (0, parse_1$2.parseCredential)(cert.params.stakeCredential, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_STAKE_CREDENTIAL)
      };
    }
    case internal_1$2.CertificateType.STAKE_REGISTRATION_CONWAY:
    case internal_1$2.CertificateType.STAKE_DEREGISTRATION_CONWAY: {
      return {
        type: cert.type,
        stakeCredential: (0, parse_1$2.parseCredential)(cert.params.stakeCredential, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_STAKE_CREDENTIAL),
        deposit: parseDeposit(cert.params.deposit)
      };
    }
    case internal_1$2.CertificateType.STAKE_DELEGATION: {
      return {
        type: cert.type,
        stakeCredential: (0, parse_1$2.parseCredential)(cert.params.stakeCredential, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_STAKE_CREDENTIAL),
        poolKeyHashHex: (0, parse_1$2.parseHexStringOfLength)(cert.params.poolKeyHashHex, internal_1$2.KEY_HASH_LENGTH, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_POOL_KEY_HASH)
      };
    }
    case internal_1$2.CertificateType.VOTE_DELEGATION: {
      return {
        type: cert.type,
        stakeCredential: (0, parse_1$2.parseCredential)(cert.params.stakeCredential, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_STAKE_CREDENTIAL),
        dRep: parseDRep(cert.params.dRep, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_DREP)
      };
    }
    case internal_1$2.CertificateType.AUTHORIZE_COMMITTEE_HOT: {
      return {
        type: cert.type,
        coldCredential: (0, parse_1$2.parseCredential)(cert.params.coldCredential, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_COMMITTEE_CREDENTIAL),
        hotCredential: (0, parse_1$2.parseCredential)(cert.params.hotCredential, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_COMMITTEE_CREDENTIAL)
      };
    }
    case internal_1$2.CertificateType.RESIGN_COMMITTEE_COLD: {
      return {
        type: cert.type,
        coldCredential: (0, parse_1$2.parseCredential)(cert.params.coldCredential, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_COMMITTEE_CREDENTIAL),
        anchor: cert.params.anchor == null ? null : (0, parse_1$2.parseAnchor)(cert.params.anchor)
      };
    }
    case internal_1$2.CertificateType.DREP_REGISTRATION: {
      return {
        type: cert.type,
        dRepCredential: (0, parse_1$2.parseCredential)(cert.params.dRepCredential, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_DREP_CREDENTIAL),
        deposit: parseDeposit(cert.params.deposit),
        anchor: cert.params.anchor == null ? null : (0, parse_1$2.parseAnchor)(cert.params.anchor)
      };
    }
    case internal_1$2.CertificateType.DREP_DEREGISTRATION: {
      return {
        type: cert.type,
        dRepCredential: (0, parse_1$2.parseCredential)(cert.params.dRepCredential, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_DREP_CREDENTIAL),
        deposit: parseDeposit(cert.params.deposit)
      };
    }
    case internal_1$2.CertificateType.DREP_UPDATE: {
      return {
        type: cert.type,
        dRepCredential: (0, parse_1$2.parseCredential)(cert.params.dRepCredential, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_DREP_CREDENTIAL),
        anchor: cert.params.anchor == null ? null : (0, parse_1$2.parseAnchor)(cert.params.anchor)
      };
    }
    case internal_1$2.CertificateType.STAKE_POOL_REGISTRATION: {
      return {
        type: cert.type,
        pool: (0, poolRegistration_1.parsePoolParams)(cert.params)
      };
    }
    case internal_1$2.CertificateType.STAKE_POOL_RETIREMENT: {
      return {
        type: cert.type,
        path: (0, parse_1$2.parseBIP32Path)(cert.params.poolKeyPath, invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_PATH),
        retirementEpoch: (0, parse_1$2.parseUint64_str)(cert.params.retirementEpoch, {}, invalidDataReason_1$2.InvalidDataReason.POOL_RETIREMENT_INVALID_RETIREMENT_EPOCH)
      };
    }
    default:
      throw new errors_1$2.InvalidData(invalidDataReason_1$2.InvalidDataReason.CERTIFICATE_INVALID_TYPE);
  }
}
certificate.parseCertificate = parseCertificate;
var output = {};
Object.defineProperty(output, "__esModule", { value: true });
output.parseTxOutput = output.parseTxDestination = output.parseTokenBundle = void 0;
const errors_1$1 = errors$4;
const invalidDataReason_1$1 = invalidDataReason;
const internal_1$1 = internal;
const public_1$1 = _public;
const parse_1$1 = parse;
const address_1 = address;
const constants_1$1 = constants$2;
function parseToken(token, parseTokenAmountFn) {
  const assetNameHex = (0, parse_1$1.parseHexString)(token.assetNameHex, invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_ASSET_NAME);
  (0, parse_1$1.validate)(token.assetNameHex.length <= internal_1$1.ASSET_NAME_LENGTH_MAX * 2, invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_ASSET_NAME);
  const amount = parseTokenAmountFn(token.amount, {}, invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_TOKEN_AMOUNT);
  return {
    assetNameHex,
    amount
  };
}
function parseAssetGroup(assetGroup, parseTokenAmountFn) {
  (0, parse_1$1.validate)((0, parse_1$1.isArray)(assetGroup.tokens), invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_ASSET_GROUP_NOT_ARRAY);
  (0, parse_1$1.validate)(assetGroup.tokens.length <= constants_1$1.TOKENS_IN_GROUP_MAX, invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_ASSET_GROUP_TOO_LARGE);
  (0, parse_1$1.validate)(assetGroup.tokens.length > 0, invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_ASSET_GROUP_EMPTY);
  const parsedAssetGroup = {
    policyIdHex: (0, parse_1$1.parseHexStringOfLength)(assetGroup.policyIdHex, internal_1$1.TOKEN_POLICY_LENGTH, invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_POLICY_NAME),
    tokens: assetGroup.tokens.map((t2) => parseToken(t2, parseTokenAmountFn))
  };
  const assetNamesHex = parsedAssetGroup.tokens.map((t2) => t2.assetNameHex);
  (0, parse_1$1.validate)(assetNamesHex.length === new Set(assetNamesHex).size, invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_ASSET_GROUP_NOT_UNIQUE);
  const sortedAssetNames = [...assetNamesHex].sort((n1, n2) => {
    if (n1.length === n2.length)
      return n1.localeCompare(n2);
    else
      return n1.length - n2.length;
  });
  (0, parse_1$1.validate)(JSON.stringify(assetNamesHex) === JSON.stringify(sortedAssetNames), invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_ASSET_GROUP_ORDERING);
  return parsedAssetGroup;
}
function parseTokenBundle(tokenBundle, emptyTokenBundleAllowed, parseTokenAmountFn) {
  (0, parse_1$1.validate)((0, parse_1$1.isArray)(tokenBundle), invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_TOKEN_BUNDLE_NOT_ARRAY);
  (0, parse_1$1.validate)(tokenBundle.length <= constants_1$1.ASSET_GROUPS_MAX, invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_TOKEN_BUNDLE_TOO_LARGE);
  (0, parse_1$1.validate)(emptyTokenBundleAllowed || tokenBundle.length > 0, invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_TOKEN_BUNDLE_EMPTY);
  const parsedTokenBundle = tokenBundle.map((ag) => parseAssetGroup(ag, parseTokenAmountFn));
  const policyIds = parsedTokenBundle.map((ag) => ag.policyIdHex);
  (0, parse_1$1.validate)(policyIds.length === new Set(policyIds).size, invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_TOKEN_BUNDLE_NOT_UNIQUE);
  const sortedPolicyIds = [...policyIds].sort();
  (0, parse_1$1.validate)(JSON.stringify(policyIds) === JSON.stringify(sortedPolicyIds), invalidDataReason_1$1.InvalidDataReason.MULTIASSET_INVALID_TOKEN_BUNDLE_ORDERING);
  return parsedTokenBundle;
}
output.parseTokenBundle = parseTokenBundle;
function parseDatumHash(datumHashHex) {
  return {
    type: public_1$1.DatumType.HASH,
    datumHashHex: (0, parse_1$1.parseHexStringOfLength)(datumHashHex, internal_1$1.DATUM_HASH_LENGTH, invalidDataReason_1$1.InvalidDataReason.OUTPUT_INVALID_DATUM_HASH)
  };
}
function parseDatum(output2) {
  var _a, _b;
  if (output2.format === public_1$1.TxOutputFormat.MAP_BABBAGE) {
    switch ((_a = output2.datum) === null || _a === void 0 ? void 0 : _a.type) {
      case public_1$1.DatumType.HASH:
        return parseDatumHash((_b = output2.datum) === null || _b === void 0 ? void 0 : _b.datumHashHex);
      case public_1$1.DatumType.INLINE:
        return {
          type: public_1$1.DatumType.INLINE,
          datumHex: (0, parse_1$1.parseHexString)(output2.datum.datumHex, invalidDataReason_1$1.InvalidDataReason.OUTPUT_INVALID_INLINE_DATUM)
        };
      default:
        return null;
    }
  } else {
    return output2.datumHashHex == null ? null : parseDatumHash(output2.datumHashHex);
  }
}
function parseTxDestination(network2, destination, validateAsTxOutput) {
  switch (destination.type) {
    case public_1$1.TxOutputDestinationType.THIRD_PARTY: {
      const params2 = destination.params;
      const addressHex = (0, parse_1$1.parseHexString)(params2.addressHex, invalidDataReason_1$1.InvalidDataReason.OUTPUT_INVALID_ADDRESS);
      (0, parse_1$1.validate)(params2.addressHex.length <= 128 * 2, invalidDataReason_1$1.InvalidDataReason.OUTPUT_INVALID_ADDRESS);
      return {
        type: public_1$1.TxOutputDestinationType.THIRD_PARTY,
        addressHex
      };
    }
    case public_1$1.TxOutputDestinationType.DEVICE_OWNED: {
      const params2 = destination.params;
      const addressParams2 = (0, address_1.parseAddress)(network2, params2);
      if (validateAsTxOutput) {
        (0, parse_1$1.validate)(addressParams2.spendingDataSource.type === "spending_path", invalidDataReason_1$1.InvalidDataReason.OUTPUT_INVALID_ADDRESS_PARAMS);
      }
      return {
        type: public_1$1.TxOutputDestinationType.DEVICE_OWNED,
        addressParams: addressParams2
      };
    }
    default:
      throw new errors_1$1.InvalidData(invalidDataReason_1$1.InvalidDataReason.ADDRESS_UNKNOWN_TYPE);
  }
}
output.parseTxDestination = parseTxDestination;
function parseTxOutput(output2, network2) {
  var _a;
  const format = output2.format === public_1$1.TxOutputFormat.MAP_BABBAGE ? public_1$1.TxOutputFormat.MAP_BABBAGE : public_1$1.TxOutputFormat.ARRAY_LEGACY;
  const amount = (0, parse_1$1.parseCoin)(output2.amount, invalidDataReason_1$1.InvalidDataReason.OUTPUT_INVALID_AMOUNT);
  const tokenBundle = parseTokenBundle((_a = output2.tokenBundle) !== null && _a !== void 0 ? _a : [], true, parse_1$1.parseUint64_str);
  const destination = parseTxDestination(network2, output2.destination, true);
  const datum = parseDatum(output2);
  if ((datum === null || datum === void 0 ? void 0 : datum.type) === public_1$1.DatumType.INLINE) {
    (0, parse_1$1.validate)(output2.format === public_1$1.TxOutputFormat.MAP_BABBAGE, invalidDataReason_1$1.InvalidDataReason.OUTPUT_INCONSISTENT_DATUM);
  }
  const referenceScriptHex = output2.format === public_1$1.TxOutputFormat.MAP_BABBAGE && output2.referenceScriptHex ? (0, parse_1$1.parseHexString)(output2.referenceScriptHex, invalidDataReason_1$1.InvalidDataReason.OUTPUT_INVALID_REFERENCE_SCRIPT_HEX) : null;
  if (referenceScriptHex != null) {
    (0, parse_1$1.validate)(output2.format === public_1$1.TxOutputFormat.MAP_BABBAGE, invalidDataReason_1$1.InvalidDataReason.OUTPUT_INCONSISTENT_REFERENCE_SCRIPT);
  }
  return {
    format,
    amount,
    tokenBundle,
    destination,
    datum,
    referenceScriptHex
  };
}
output.parseTxOutput = parseTxOutput;
var txAuxiliaryData = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.parseTxAuxiliaryData = exports2.CVOTE_VKEY_LENGTH = void 0;
  const errors_12 = errors$4;
  const invalidDataReason_12 = invalidDataReason;
  const internal_12 = internal;
  const public_12 = _public;
  const parse_12 = parse;
  const output_12 = output;
  exports2.CVOTE_VKEY_LENGTH = 32;
  function parseCVoteDelegation(delegation) {
    const weight = (0, parse_12.parseUint32_t)(delegation.weight, invalidDataReason_12.InvalidDataReason.CVOTE_DELEGATION_INVALID_WEIGHT);
    switch (delegation.type) {
      case public_12.CIP36VoteDelegationType.KEY:
        return {
          type: delegation.type,
          voteKey: (0, parse_12.parseHexStringOfLength)(delegation.voteKeyHex, internal_12.CVOTE_PUBLIC_KEY_LENGTH, invalidDataReason_12.InvalidDataReason.CVOTE_DELEGATION_INVALID_KEY),
          weight
        };
      case public_12.CIP36VoteDelegationType.PATH:
        return {
          type: delegation.type,
          voteKeyPath: (0, parse_12.parseBIP32Path)(delegation.voteKeyPath, invalidDataReason_12.InvalidDataReason.CVOTE_DELEGATION_INVALID_PATH),
          weight
        };
      default:
        throw new errors_12.InvalidData(invalidDataReason_12.InvalidDataReason.CVOTE_DELEGATION_UNKNOWN_DELEGATION_TYPE);
    }
  }
  function parseCVoteDelegations(delegations) {
    (0, parse_12.validate)((0, parse_12.isArray)(delegations), invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_DELEGATIONS_NOT_ARRAY);
    return delegations.map((d) => parseCVoteDelegation(d));
  }
  function parseCVoteRegistrationParams(network2, params2) {
    switch (params2.format) {
      case public_12.CIP36VoteRegistrationFormat.CIP_15:
        (0, parse_12.validate)(params2.delegations == null, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_INCONSISTENT_WITH_CIP15);
        (0, parse_12.validate)(params2.voteKeyHex != null, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_INCONSISTENT_WITH_CIP15);
        (0, parse_12.validate)(params2.votingPurpose == null, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_INCONSISTENT_WITH_CIP15);
        break;
      case public_12.CIP36VoteRegistrationFormat.CIP_36:
        if (params2.delegations != null) {
          (0, parse_12.validate)(params2.voteKeyHex == null && params2.voteKeyPath == null, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_INCONSISTENT_WITH_CIP36);
        } else {
          (0, parse_12.validate)(params2.delegations == null, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_INCONSISTENT_WITH_CIP36);
          (0, parse_12.validate)(params2.voteKeyHex == null || params2.voteKeyPath == null, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_BOTH_KEY_AND_PATH);
          (0, parse_12.validate)(params2.voteKeyHex != null || params2.voteKeyPath != null, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_MISSING_VOTE_KEY);
        }
        break;
      default:
        throw new errors_12.InvalidData(invalidDataReason_12.InvalidDataReason.CVOTE_DELEGATION_UNKNOWN_FORMAT);
    }
    const voteKey = params2.voteKeyHex == null ? null : (0, parse_12.parseHexStringOfLength)(params2.voteKeyHex, exports2.CVOTE_VKEY_LENGTH, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_INVALID_VOTE_KEY);
    const voteKeyPath = params2.voteKeyPath == null ? null : (0, parse_12.parseBIP32Path)(params2.voteKeyPath, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_INVALID_VOTE_KEY_PATH);
    const delegations = params2.delegations == null ? null : parseCVoteDelegations(params2.delegations);
    const votingPurpose = params2.votingPurpose == null ? null : (0, parse_12.parseUint64_str)(params2.votingPurpose, {}, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_INVALID_VOTING_PURPOSE);
    return {
      format: params2.format,
      votePublicKey: voteKey,
      votePublicKeyPath: voteKeyPath,
      delegations,
      stakingPath: (0, parse_12.parseBIP32Path)(params2.stakingPath, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_INVALID_STAKING_KEY_PATH),
      paymentDestination: (0, output_12.parseTxDestination)(network2, params2.paymentDestination, false),
      nonce: (0, parse_12.parseUint64_str)(params2.nonce, {}, invalidDataReason_12.InvalidDataReason.CVOTE_REGISTRATION_INVALID_NONCE),
      votingPurpose
    };
  }
  function parseTxAuxiliaryData(network2, auxiliaryData) {
    switch (auxiliaryData.type) {
      case public_12.TxAuxiliaryDataType.ARBITRARY_HASH: {
        return {
          type: public_12.TxAuxiliaryDataType.ARBITRARY_HASH,
          hashHex: (0, parse_12.parseHexStringOfLength)(auxiliaryData.params.hashHex, internal_12.AUXILIARY_DATA_HASH_LENGTH, invalidDataReason_12.InvalidDataReason.AUXILIARY_DATA_INVALID_HASH)
        };
      }
      case public_12.TxAuxiliaryDataType.CIP36_REGISTRATION: {
        return {
          type: public_12.TxAuxiliaryDataType.CIP36_REGISTRATION,
          params: parseCVoteRegistrationParams(network2, auxiliaryData.params)
        };
      }
      default:
        throw new errors_12.InvalidData(invalidDataReason_12.InvalidDataReason.AUXILIARY_DATA_UNKNOWN_TYPE);
    }
  }
  exports2.parseTxAuxiliaryData = parseTxAuxiliaryData;
})(txAuxiliaryData);
Object.defineProperty(transaction, "__esModule", { value: true });
transaction.parseSignTransactionRequest = transaction.parseTransaction = transaction.parseSigningMode = void 0;
const errors_1 = errors$4;
const invalidDataReason_1 = invalidDataReason;
const internal_1 = internal;
const public_1 = _public;
const assert_1 = assert$1;
const parse_1 = parse;
const certificate_1 = certificate;
const constants_1 = constants$2;
const network_1 = network$1;
const output_1 = output;
const txAuxiliaryData_1 = txAuxiliaryData;
function parseCertificates(certificates) {
  (0, parse_1.validate)((0, parse_1.isArray)(certificates), invalidDataReason_1.InvalidDataReason.CERTIFICATES_NOT_ARRAY);
  const parsed = certificates.map((cert) => (0, certificate_1.parseCertificate)(cert));
  return parsed;
}
function parseBoolean(value, errorMsg) {
  (0, parse_1.validate)(typeof value === "boolean", errorMsg);
  return value;
}
function parseTxInput(input) {
  const txHashHex = (0, parse_1.parseHexStringOfLength)(input.txHashHex, internal_1.TX_HASH_LENGTH, invalidDataReason_1.InvalidDataReason.INPUT_INVALID_TX_HASH);
  const outputIndex = (0, parse_1.parseUint32_t)(input.outputIndex, invalidDataReason_1.InvalidDataReason.INPUT_INVALID_UTXO_INDEX);
  return {
    txHashHex,
    outputIndex,
    path: input.path != null ? (0, parse_1.parseBIP32Path)(input.path, invalidDataReason_1.InvalidDataReason.INPUT_INVALID_PATH) : null
  };
}
function parseWithdrawal(params2) {
  return {
    amount: (0, parse_1.parseCoin)(params2.amount, invalidDataReason_1.InvalidDataReason.WITHDRAWAL_INVALID_AMOUNT),
    stakeCredential: (0, parse_1.parseCredential)(params2.stakeCredential, invalidDataReason_1.InvalidDataReason.WITHDRAWAL_INVALID_STAKE_CREDENTIAL)
  };
}
function parseRequiredSigner(requiredSigner) {
  switch (requiredSigner.type) {
    case public_1.TxRequiredSignerType.PATH:
      return {
        type: 0,
        path: (0, parse_1.parseBIP32Path)(requiredSigner.path, invalidDataReason_1.InvalidDataReason.REQUIRED_SIGNER_INVALID_PATH)
      };
    case public_1.TxRequiredSignerType.HASH:
      return {
        type: 1,
        hashHex: (0, parse_1.parseHexStringOfLength)(requiredSigner.hashHex, internal_1.KEY_HASH_LENGTH, invalidDataReason_1.InvalidDataReason.VKEY_HASH_WRONG_LENGTH)
      };
    default:
      throw new errors_1.InvalidData(invalidDataReason_1.InvalidDataReason.UNKNOWN_REQUIRED_SIGNER_TYPE);
  }
}
function parseVoter(voter) {
  const errMsg = invalidDataReason_1.InvalidDataReason.VOTER_INVALID;
  switch (voter.type) {
    case public_1.VoterType.COMMITTEE_KEY_HASH:
    case public_1.VoterType.DREP_KEY_HASH:
    case public_1.VoterType.STAKE_POOL_KEY_HASH:
      return {
        type: voter.type,
        keyHashHex: (0, parse_1.parseHexStringOfLength)(voter.keyHashHex, internal_1.KEY_HASH_LENGTH, errMsg)
      };
    case public_1.VoterType.COMMITTEE_KEY_PATH:
    case public_1.VoterType.DREP_KEY_PATH:
    case public_1.VoterType.STAKE_POOL_KEY_PATH:
      return {
        type: voter.type,
        keyPath: (0, parse_1.parseBIP32Path)(voter.keyPath, errMsg)
      };
    case public_1.VoterType.DREP_SCRIPT_HASH:
    case public_1.VoterType.COMMITTEE_SCRIPT_HASH:
      return {
        type: voter.type,
        scriptHashHex: (0, parse_1.parseHexStringOfLength)(voter.scriptHashHex, internal_1.SCRIPT_HASH_LENGTH, errMsg)
      };
    default:
      (0, assert_1.unreachable)(voter);
  }
}
function parseVote(vote) {
  return {
    govActionId: {
      txHashHex: (0, parse_1.parseHexStringOfLength)(vote.govActionId.txHashHex, internal_1.TX_HASH_LENGTH, invalidDataReason_1.InvalidDataReason.GOV_ACTION_ID_INVALID_TX_HASH),
      govActionIndex: (0, parse_1.parseUint32_t)(vote.govActionId.govActionIndex, invalidDataReason_1.InvalidDataReason.GOV_ACTION_ID_INVALID_INDEX)
    },
    votingProcedure: {
      vote: vote.votingProcedure.vote,
      anchor: vote.votingProcedure.anchor == null ? null : (0, parse_1.parseAnchor)(vote.votingProcedure.anchor)
    }
  };
}
function parseVoterVotes(voterVotes) {
  (0, parse_1.validate)((0, parse_1.isArray)(voterVotes.votes), invalidDataReason_1.InvalidDataReason.VOTER_VOTES_NOT_ARRAY);
  return {
    voter: parseVoter(voterVotes.voter),
    votes: voterVotes.votes.map((v) => parseVote(v))
  };
}
function parseSigningMode(mode) {
  switch (mode) {
    case public_1.TransactionSigningMode.ORDINARY_TRANSACTION:
    case public_1.TransactionSigningMode.POOL_REGISTRATION_AS_OWNER:
    case public_1.TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR:
    case public_1.TransactionSigningMode.MULTISIG_TRANSACTION:
    case public_1.TransactionSigningMode.PLUTUS_TRANSACTION:
      return mode;
    default:
      throw new errors_1.InvalidData(invalidDataReason_1.InvalidDataReason.SIGN_MODE_UNKNOWN);
  }
}
transaction.parseSigningMode = parseSigningMode;
function parseTransaction(tx) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  const network2 = (0, network_1.parseNetwork)(tx.network);
  (0, parse_1.validate)((0, parse_1.isArray)(tx.inputs), invalidDataReason_1.InvalidDataReason.INPUTS_NOT_ARRAY);
  const inputs = tx.inputs.map((inp) => parseTxInput(inp));
  (0, parse_1.validate)((0, parse_1.isArray)(tx.outputs), invalidDataReason_1.InvalidDataReason.OUTPUTS_NOT_ARRAY);
  const outputs = tx.outputs.map((o) => (0, output_1.parseTxOutput)(o, tx.network));
  const fee = (0, parse_1.parseCoin)(tx.fee, invalidDataReason_1.InvalidDataReason.FEE_INVALID);
  const ttl = tx.ttl == null ? null : (0, parse_1.parseUint64_str)(tx.ttl, {}, invalidDataReason_1.InvalidDataReason.TTL_INVALID);
  (0, parse_1.validate)((0, parse_1.isArray)((_a = tx.certificates) !== null && _a !== void 0 ? _a : []), invalidDataReason_1.InvalidDataReason.CERTIFICATES_NOT_ARRAY);
  const certificates = parseCertificates((_b = tx.certificates) !== null && _b !== void 0 ? _b : []);
  (0, parse_1.validate)((0, parse_1.isArray)((_c = tx.withdrawals) !== null && _c !== void 0 ? _c : []), invalidDataReason_1.InvalidDataReason.WITHDRAWALS_NOT_ARRAY);
  const withdrawals = ((_d = tx.withdrawals) !== null && _d !== void 0 ? _d : []).map((w) => parseWithdrawal(w));
  const auxiliaryData = tx.auxiliaryData == null ? null : (0, txAuxiliaryData_1.parseTxAuxiliaryData)(network2, tx.auxiliaryData);
  const validityIntervalStart = tx.validityIntervalStart == null ? null : (0, parse_1.parseUint64_str)(tx.validityIntervalStart, {}, invalidDataReason_1.InvalidDataReason.VALIDITY_INTERVAL_START_INVALID);
  const mint = tx.mint == null ? null : (0, output_1.parseTokenBundle)(tx.mint, false, parse_1.parseInt64_str);
  const scriptDataHashHex = tx.scriptDataHashHex == null ? null : (0, parse_1.parseHexStringOfLength)(tx.scriptDataHashHex, internal_1.SCRIPT_DATA_HASH_LENGTH, invalidDataReason_1.InvalidDataReason.SCRIPT_DATA_HASH_WRONG_LENGTH);
  (0, parse_1.validate)((0, parse_1.isArray)((_e = tx.collateralInputs) !== null && _e !== void 0 ? _e : []), invalidDataReason_1.InvalidDataReason.COLLATERAL_INPUTS_NOT_ARRAY);
  const collateralInputs = ((_f = tx.collateralInputs) !== null && _f !== void 0 ? _f : []).map((inp) => parseTxInput(inp));
  (0, parse_1.validate)((0, parse_1.isArray)((_g = tx.requiredSigners) !== null && _g !== void 0 ? _g : []), invalidDataReason_1.InvalidDataReason.REQUIRED_SIGNERS_NOT_ARRAY);
  const requiredSigners = ((_h = tx.requiredSigners) !== null && _h !== void 0 ? _h : []).map((rs) => parseRequiredSigner(rs));
  const includeNetworkId = tx.includeNetworkId == null ? false : parseBoolean(tx.includeNetworkId, invalidDataReason_1.InvalidDataReason.NETWORK_ID_INCLUDE_INVALID);
  const collateralOutput = tx.collateralOutput == null ? null : (0, output_1.parseTxOutput)(tx.collateralOutput, tx.network);
  (0, parse_1.validate)((collateralOutput === null || collateralOutput === void 0 ? void 0 : collateralOutput.datum) == null, invalidDataReason_1.InvalidDataReason.COLLATERAL_INPUT_CONTAINS_DATUM);
  (0, parse_1.validate)((collateralOutput === null || collateralOutput === void 0 ? void 0 : collateralOutput.referenceScriptHex) == null, invalidDataReason_1.InvalidDataReason.COLLATERAL_INPUT_CONTAINS_REFERENCE_SCRIPT);
  const totalCollateral = tx.totalCollateral == null ? null : (0, parse_1.parseCoin)(tx.totalCollateral, invalidDataReason_1.InvalidDataReason.TOTAL_COLLATERAL_NOT_VALID);
  (0, parse_1.validate)((0, parse_1.isArray)((_j = tx.referenceInputs) !== null && _j !== void 0 ? _j : []), invalidDataReason_1.InvalidDataReason.REFERENCE_INPUTS_NOT_ARRAY);
  const referenceInputs = ((_k = tx.referenceInputs) !== null && _k !== void 0 ? _k : []).map((ri) => parseTxInput(ri));
  (0, parse_1.validate)((0, parse_1.isArray)((_l = tx.votingProcedures) !== null && _l !== void 0 ? _l : []), invalidDataReason_1.InvalidDataReason.VOTING_PROCEDURES_NOT_ARRAY);
  const votingProcedures = ((_m = tx.votingProcedures) !== null && _m !== void 0 ? _m : []).map((x2) => parseVoterVotes(x2));
  (0, parse_1.validate)(votingProcedures.length <= 1, invalidDataReason_1.InvalidDataReason.VOTING_PROCEDURES_INVALID_NUMBER_OF_VOTERS);
  for (const voterVotes of votingProcedures) {
    (0, parse_1.validate)(voterVotes.votes.length === 1, invalidDataReason_1.InvalidDataReason.VOTING_PROCEDURES_INVALID_NUMBER_OF_VOTES);
  }
  const treasury = tx.treasury == null ? null : (0, parse_1.parseCoin)(tx.treasury, invalidDataReason_1.InvalidDataReason.TREASURY_NOT_VALID);
  const donation = tx.donation == null ? null : (0, parse_1.parseUint64_str)(tx.donation, { min: "1", max: constants_1.MAX_LOVELACE_SUPPLY_STR }, invalidDataReason_1.InvalidDataReason.DONATION_NOT_VALID);
  return {
    network: network2,
    inputs,
    outputs,
    ttl,
    auxiliaryData,
    validityIntervalStart,
    withdrawals,
    certificates,
    fee,
    mint,
    scriptDataHashHex,
    collateralInputs,
    requiredSigners,
    includeNetworkId,
    collateralOutput,
    totalCollateral,
    referenceInputs,
    votingProcedures,
    treasury,
    donation
  };
}
transaction.parseTransaction = parseTransaction;
function parseTxOptions(options) {
  return {
    tagCborSets: (options === null || options === void 0 ? void 0 : options.tagCborSets) || false
  };
}
function parseSignTransactionRequest(request) {
  var _a, _b;
  const tx = parseTransaction(request.tx);
  const signingMode = parseSigningMode(request.signingMode);
  const options = parseTxOptions(request.options);
  (0, parse_1.validate)((0, parse_1.isArray)((_a = request.additionalWitnessPaths) !== null && _a !== void 0 ? _a : []), invalidDataReason_1.InvalidDataReason.ADDITIONAL_WITNESSES_NOT_ARRAY);
  const additionalWitnessPaths = ((_b = request.additionalWitnessPaths) !== null && _b !== void 0 ? _b : []).map((path2) => (0, parse_1.parseBIP32Path)(path2, invalidDataReason_1.InvalidDataReason.INVALID_PATH));
  switch (signingMode) {
    case public_1.TransactionSigningMode.ORDINARY_TRANSACTION: {
      (0, parse_1.validate)(tx.certificates.every((certificate2) => certificate2.type !== internal_1.CertificateType.STAKE_POOL_REGISTRATION), invalidDataReason_1.InvalidDataReason.SIGN_MODE_ORDINARY__POOL_REGISTRATION_NOT_ALLOWED);
      (0, parse_1.validate)(tx.certificates.every((certificate2) => {
        switch (certificate2.type) {
          case internal_1.CertificateType.STAKE_REGISTRATION:
          case internal_1.CertificateType.STAKE_REGISTRATION_CONWAY:
          case internal_1.CertificateType.STAKE_DEREGISTRATION:
          case internal_1.CertificateType.STAKE_DEREGISTRATION_CONWAY:
          case internal_1.CertificateType.STAKE_DELEGATION:
          case internal_1.CertificateType.VOTE_DELEGATION:
            return certificate2.stakeCredential.type === 0;
          default:
            return true;
        }
      }), invalidDataReason_1.InvalidDataReason.SIGN_MODE_ORDINARY__CERTIFICATE_STAKE_CREDENTIAL_ONLY_AS_PATH);
      (0, parse_1.validate)(tx.certificates.every((certificate2) => {
        switch (certificate2.type) {
          case internal_1.CertificateType.AUTHORIZE_COMMITTEE_HOT:
          case internal_1.CertificateType.RESIGN_COMMITTEE_COLD:
            return certificate2.coldCredential.type === 0;
          default:
            return true;
        }
      }), invalidDataReason_1.InvalidDataReason.SIGN_MODE_ORDINARY__CERTIFICATE_COMMITTEE_COLD_CREDENTIAL_ONLY_AS_PATH);
      (0, parse_1.validate)(tx.certificates.every((certificate2) => {
        switch (certificate2.type) {
          case internal_1.CertificateType.DREP_REGISTRATION:
          case internal_1.CertificateType.DREP_DEREGISTRATION:
          case internal_1.CertificateType.DREP_UPDATE:
            return certificate2.dRepCredential.type === 0;
          default:
            return true;
        }
      }), invalidDataReason_1.InvalidDataReason.SIGN_MODE_ORDINARY__CERTIFICATE_DREP_CREDENTIAL_ONLY_AS_PATH);
      (0, parse_1.validate)(tx.withdrawals.every((withdrawal) => withdrawal.stakeCredential.type === 0), invalidDataReason_1.InvalidDataReason.SIGN_MODE_ORDINARY__WITHDRAWAL_ONLY_AS_PATH);
      (0, parse_1.validate)(tx.collateralInputs.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_ORDINARY__COLLATERAL_INPUTS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.collateralOutput == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_ORDINARY__COLLATERAL_OUTPUT_NOT_ALLOWED);
      (0, parse_1.validate)(tx.totalCollateral == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_ORDINARY__TOTAL_COLLATERAL_NOT_ALLOWED);
      (0, parse_1.validate)(tx.referenceInputs.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_ORDINARY__REFERENCE_INPUTS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.votingProcedures.every((voterVotes) => {
        switch (voterVotes.voter.type) {
          case public_1.VoterType.COMMITTEE_KEY_PATH:
          case public_1.VoterType.DREP_KEY_PATH:
          case public_1.VoterType.STAKE_POOL_KEY_PATH:
            return true;
          default:
            return false;
        }
      }), invalidDataReason_1.InvalidDataReason.SIGN_MODE_ORDINARY__VOTER_ONLY_AS_PATH);
      break;
    }
    case public_1.TransactionSigningMode.MULTISIG_TRANSACTION: {
      (0, parse_1.validate)(tx.outputs.every((output2) => output2.destination.type === public_1.TxOutputDestinationType.THIRD_PARTY), invalidDataReason_1.InvalidDataReason.SIGN_MODE_MULTISIG__DEVICE_OWNED_ADDRESS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.certificates.every((certificate2) => certificate2.type !== internal_1.CertificateType.STAKE_POOL_REGISTRATION), invalidDataReason_1.InvalidDataReason.SIGN_MODE_MULTISIG__POOL_REGISTRATION_NOT_ALLOWED);
      (0, parse_1.validate)(tx.certificates.every((certificate2) => certificate2.type !== internal_1.CertificateType.STAKE_POOL_RETIREMENT), invalidDataReason_1.InvalidDataReason.SIGN_MODE_MULTISIG__POOL_RETIREMENT_NOT_ALLOWED);
      (0, parse_1.validate)(tx.certificates.every((certificate2) => {
        switch (certificate2.type) {
          case internal_1.CertificateType.STAKE_REGISTRATION:
          case internal_1.CertificateType.STAKE_REGISTRATION_CONWAY:
          case internal_1.CertificateType.STAKE_DEREGISTRATION:
          case internal_1.CertificateType.STAKE_DEREGISTRATION_CONWAY:
          case internal_1.CertificateType.STAKE_DELEGATION:
          case internal_1.CertificateType.VOTE_DELEGATION:
            return certificate2.stakeCredential.type === 1;
          case internal_1.CertificateType.AUTHORIZE_COMMITTEE_HOT:
          case internal_1.CertificateType.RESIGN_COMMITTEE_COLD:
            return certificate2.coldCredential.type === 1;
          case internal_1.CertificateType.DREP_REGISTRATION:
          case internal_1.CertificateType.DREP_DEREGISTRATION:
          case internal_1.CertificateType.DREP_UPDATE:
            return certificate2.dRepCredential.type === 1;
          default:
            return true;
        }
      }), invalidDataReason_1.InvalidDataReason.SIGN_MODE_MULTISIG__CERTIFICATE_CREDENTIAL_ONLY_AS_SCRIPT);
      (0, parse_1.validate)(tx.withdrawals.every((withdrawal) => withdrawal.stakeCredential.type === 1), invalidDataReason_1.InvalidDataReason.SIGN_MODE_MULTISIG__WITHDRAWAL_ONLY_AS_SCRIPT);
      (0, parse_1.validate)(tx.collateralInputs.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_MULTISIG__COLLATERAL_INPUTS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.collateralOutput == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_MULTISIG__COLLATERAL_OUTPUT_NOT_ALLOWED);
      (0, parse_1.validate)(tx.totalCollateral == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_MULTISIG__TOTAL_COLLATERAL_NOT_ALLOWED);
      (0, parse_1.validate)(tx.referenceInputs.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_MULTISIG__REFERENCE_INPUTS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.votingProcedures.every((voterVotes) => {
        switch (voterVotes.voter.type) {
          case public_1.VoterType.COMMITTEE_SCRIPT_HASH:
          case public_1.VoterType.DREP_SCRIPT_HASH:
            return true;
          default:
            return false;
        }
      }), invalidDataReason_1.InvalidDataReason.SIGN_MODE_MULTISIG__VOTER_ONLY_AS_SCRIPT);
      break;
    }
    case public_1.TransactionSigningMode.POOL_REGISTRATION_AS_OWNER: {
      (0, parse_1.validate)(tx.inputs.every((inp) => inp.path == null), invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__INPUT_WITH_PATH_NOT_ALLOWED);
      (0, parse_1.validate)(tx.outputs.every((out) => out.destination.type === public_1.TxOutputDestinationType.THIRD_PARTY), invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__DEVICE_OWNED_ADDRESS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.outputs.every((out) => out.datum == null), invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__DATUM_NOT_ALLOWED);
      (0, parse_1.validate)(tx.outputs.every((out) => out.referenceScriptHex == null), invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__REFERENCE_SCRIPT_NOT_ALLOWED);
      (0, parse_1.validate)(tx.certificates.length === 1, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__SINGLE_POOL_REG_CERTIFICATE_REQUIRED);
      tx.certificates.forEach((certificate2) => {
        (0, parse_1.validate)(certificate2.type === internal_1.CertificateType.STAKE_POOL_REGISTRATION, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__SINGLE_POOL_REG_CERTIFICATE_REQUIRED);
        (0, parse_1.validate)(certificate2.pool.poolKey.type === public_1.PoolKeyType.THIRD_PARTY, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__THIRD_PARTY_POOL_KEY_REQUIRED);
        (0, parse_1.validate)(certificate2.pool.owners.filter((o) => o.type === public_1.PoolOwnerType.DEVICE_OWNED).length === 1, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__SINGLE_DEVICE_OWNER_REQUIRED);
      });
      (0, parse_1.validate)(tx.withdrawals.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__WITHDRAWALS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.mint == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__MINT_NOT_ALLOWED);
      (0, parse_1.validate)(tx.scriptDataHashHex == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__SCRIPT_DATA_HASH_NOT_ALLOWED);
      (0, parse_1.validate)(tx.collateralInputs.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__COLLATERAL_INPUTS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.requiredSigners.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__REQUIRED_SIGNERS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.collateralOutput == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__COLLATERAL_OUTPUT_NOT_ALLOWED);
      (0, parse_1.validate)(tx.totalCollateral == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__TOTAL_COLLATERAL_NOT_ALLOWED);
      (0, parse_1.validate)(tx.referenceInputs.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__REFERENCE_INPUTS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.votingProcedures.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__VOTING_PROCEDURES_NOT_ALLOWED);
      (0, parse_1.validate)(tx.treasury == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__TREASURY_NOT_ALLOWED);
      (0, parse_1.validate)(tx.donation == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OWNER__DONATION_NOT_ALLOWED);
      break;
    }
    case public_1.TransactionSigningMode.POOL_REGISTRATION_AS_OPERATOR: {
      (0, parse_1.validate)(tx.outputs.every((out) => out.datum == null), invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__DATUM_NOT_ALLOWED);
      (0, parse_1.validate)(tx.outputs.every((out) => out.referenceScriptHex == null), invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__REFERENCE_SCRIPT_NOT_ALLOWED);
      (0, parse_1.validate)(tx.certificates.length === 1, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__SINGLE_POOL_REG_CERTIFICATE_REQUIRED);
      tx.certificates.forEach((certificate2) => {
        (0, parse_1.validate)(certificate2.type === internal_1.CertificateType.STAKE_POOL_REGISTRATION, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__SINGLE_POOL_REG_CERTIFICATE_REQUIRED);
        (0, parse_1.validate)(certificate2.pool.poolKey.type === public_1.PoolKeyType.DEVICE_OWNED, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__DEVICE_OWNED_POOL_KEY_REQUIRED);
        (0, parse_1.validate)(certificate2.pool.owners.filter((o) => o.type === public_1.PoolOwnerType.DEVICE_OWNED).length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__DEVICE_OWNED_POOL_OWNER_NOT_ALLOWED);
      });
      (0, parse_1.validate)(tx.withdrawals.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__WITHDRAWALS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.mint == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__MINT_NOT_ALLOWED);
      (0, parse_1.validate)(tx.scriptDataHashHex == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__SCRIPT_DATA_HASH_NOT_ALLOWED);
      (0, parse_1.validate)(tx.collateralInputs.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__COLLATERAL_INPUTS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.requiredSigners.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__REQUIRED_SIGNERS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.collateralOutput == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__COLLATERAL_OUTPUT_NOT_ALLOWED);
      (0, parse_1.validate)(tx.totalCollateral == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__TOTAL_COLLATERAL_NOT_ALLOWED);
      (0, parse_1.validate)(tx.referenceInputs.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__REFERENCE_INPUTS_NOT_ALLOWED);
      (0, parse_1.validate)(tx.votingProcedures.length === 0, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__VOTING_PROCEDURES_NOT_ALLOWED);
      (0, parse_1.validate)(tx.treasury == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__TREASURY_NOT_ALLOWED);
      (0, parse_1.validate)(tx.donation == null, invalidDataReason_1.InvalidDataReason.SIGN_MODE_POOL_OPERATOR__DONATION_NOT_ALLOWED);
      break;
    }
    case public_1.TransactionSigningMode.PLUTUS_TRANSACTION: {
      (0, parse_1.validate)(tx.certificates.every((certificate2) => certificate2.type !== internal_1.CertificateType.STAKE_POOL_REGISTRATION), invalidDataReason_1.InvalidDataReason.SIGN_MODE_PLUTUS__POOL_REGISTRATION_NOT_ALLOWED);
      break;
    }
    default:
      (0, assert_1.unreachable)(signingMode);
  }
  return { tx, signingMode, additionalWitnessPaths, options };
}
transaction.parseSignTransactionRequest = parseSignTransactionRequest;
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
  };
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Networks = exports2.utils = exports2.Ada = void 0;
  const errors_12 = errors$4;
  const invalidDataReason_12 = invalidDataReason;
  const deriveAddress_12 = deriveAddress$1;
  const deriveNativeScriptHash_1 = deriveNativeScriptHash$1;
  const getExtendedPublicKeys_1 = getExtendedPublicKeys$1;
  const getSerial_1 = getSerial$1;
  const getVersion_12 = getVersion$1;
  const runTests_1 = runTests$1;
  const showAddress_1 = showAddress$1;
  const signCVote_1 = signCVote$1;
  const signOperationalCertificate_1 = signOperationalCertificate$1;
  const signMessage_1 = signMessage$1;
  const messageData_12 = messageData;
  const signTx_1 = signTx;
  const address_12 = address;
  const cVote_1 = cVote;
  const nativeScript_12 = nativeScript;
  const operationalCertificate_12 = operationalCertificate;
  const transaction_1 = transaction;
  const utils_12 = __importDefault2(utils$2);
  exports2.utils = utils_12.default;
  const assert_12 = assert$1;
  const parse_12 = parse;
  __exportStar(errors$4, exports2);
  __exportStar(_public, exports2);
  const CLA = 215;
  function wrapConvertDeviceStatusError(fn) {
    return (...args) => __awaiter2(this, void 0, void 0, function* () {
      try {
        return yield fn(...args);
      } catch (e) {
        if (e && typeof e === "object" && "statusCode" in e && typeof e.statusCode === "number") {
          throw new errors_12.DeviceStatusError(e.statusCode);
        }
        throw e;
      }
    });
  }
  function wrapRetryStillInCall(fn) {
    return (...args) => __awaiter2(this, void 0, void 0, function* () {
      try {
        return yield fn(...args);
      } catch (e) {
        if (e && e.statusCode && e.statusCode === errors_12.DeviceStatusCodes.ERR_STILL_IN_CALL) {
          return yield fn(...args);
        }
        throw e;
      }
    });
  }
  function interact(interaction, send2) {
    return __awaiter2(this, void 0, void 0, function* () {
      let cursor = interaction.next();
      let first2 = true;
      while (!cursor.done) {
        const apdu = cursor.value;
        const res = first2 ? yield wrapRetryStillInCall(send2)(apdu) : yield send2(apdu);
        first2 = false;
        cursor = interaction.next(res);
      }
      return cursor.value;
    });
  }
  class Ada2 {
    constructor(transport2, scrambleKey = "ADA") {
      this.transport = transport2;
      const methods2 = [
        "getVersion",
        "getSerial",
        "getExtendedPublicKeys",
        "signTransaction",
        "deriveAddress",
        "showAddress",
        "deriveNativeScriptHash"
      ];
      this.transport.decorateAppAPIMethods(this, methods2, scrambleKey);
      this._send = (params2) => __awaiter2(this, void 0, void 0, function* () {
        if (params2.data.length > 255) {
          throw new Error("APDU too large, likely a bug");
        }
        let response = yield wrapConvertDeviceStatusError(this.transport.send)(CLA, params2.ins, params2.p1, params2.p2, params2.data);
        response = utils_12.default.stripRetcodeFromResponse(response);
        if (params2.expectedResponseLength != null) {
          (0, assert_12.assert)(response.length === params2.expectedResponseLength, `unexpected response length: ${response.length} instead of ${params2.expectedResponseLength}`);
        }
        return response;
      });
    }
    getVersion() {
      return __awaiter2(this, void 0, void 0, function* () {
        const version2 = yield interact(this._getVersion(), this._send);
        return { version: version2, compatibility: (0, getVersion_12.getCompatibility)(version2) };
      });
    }
    *_getVersion() {
      return yield* (0, getVersion_12.getVersion)();
    }
    getSerial() {
      return __awaiter2(this, void 0, void 0, function* () {
        return interact(this._getSerial(), this._send);
      });
    }
    *_getSerial() {
      const version2 = yield* (0, getVersion_12.getVersion)();
      return yield* (0, getSerial_1.getSerial)(version2);
    }
    runTests() {
      return __awaiter2(this, void 0, void 0, function* () {
        return interact(this._runTests(), this._send);
      });
    }
    *_runTests() {
      const version2 = yield* (0, getVersion_12.getVersion)();
      return yield* (0, runTests_1.runTests)(version2);
    }
    getExtendedPublicKeys({ paths }) {
      return __awaiter2(this, void 0, void 0, function* () {
        (0, parse_12.validate)((0, parse_12.isArray)(paths), invalidDataReason_12.InvalidDataReason.GET_EXT_PUB_KEY_PATHS_NOT_ARRAY);
        const parsed = paths.map((path2) => (0, parse_12.parseBIP32Path)(path2, invalidDataReason_12.InvalidDataReason.INVALID_PATH));
        return interact(this._getExtendedPublicKeys(parsed), this._send);
      });
    }
    *_getExtendedPublicKeys(paths) {
      const version2 = yield* (0, getVersion_12.getVersion)();
      return yield* (0, getExtendedPublicKeys_1.getExtendedPublicKeys)(version2, paths);
    }
    getExtendedPublicKey({ path: path2 }) {
      return __awaiter2(this, void 0, void 0, function* () {
        return (yield this.getExtendedPublicKeys({ paths: [path2] }))[0];
      });
    }
    deriveAddress({ network: network2, address: address2 }) {
      return __awaiter2(this, void 0, void 0, function* () {
        const parsedParams = (0, address_12.parseAddress)(network2, address2);
        return interact(this._deriveAddress(parsedParams), this._send);
      });
    }
    *_deriveAddress(addressParams2) {
      const version2 = yield* (0, getVersion_12.getVersion)();
      return yield* (0, deriveAddress_12.deriveAddress)(version2, addressParams2);
    }
    showAddress({ network: network2, address: address2 }) {
      return __awaiter2(this, void 0, void 0, function* () {
        const parsedParams = (0, address_12.parseAddress)(network2, address2);
        return interact(this._showAddress(parsedParams), this._send);
      });
    }
    *_showAddress(addressParams2) {
      const version2 = yield* (0, getVersion_12.getVersion)();
      return yield* (0, showAddress_1.showAddress)(version2, addressParams2);
    }
    signTransaction(request) {
      return __awaiter2(this, void 0, void 0, function* () {
        const parsedRequest = (0, transaction_1.parseSignTransactionRequest)(request);
        return interact(this._signTx(parsedRequest), this._send);
      });
    }
    *_signTx(request) {
      const version2 = yield* (0, getVersion_12.getVersion)();
      return yield* (0, signTx_1.signTransaction)(version2, request);
    }
    signOperationalCertificate(request) {
      return __awaiter2(this, void 0, void 0, function* () {
        const parsedOperationalCertificate = (0, operationalCertificate_12.parseOperationalCertificate)(request);
        return interact(this._signOperationalCertificate(parsedOperationalCertificate), this._send);
      });
    }
    *_signOperationalCertificate(request) {
      const version2 = yield* (0, getVersion_12.getVersion)();
      return yield* (0, signOperationalCertificate_1.signOperationalCertificate)(version2, request);
    }
    signMessage(request) {
      return __awaiter2(this, void 0, void 0, function* () {
        const parsedMsgData = (0, messageData_12.parseMessageData)(request);
        return interact(this._signMessage(parsedMsgData), this._send);
      });
    }
    *_signMessage(request) {
      const version2 = yield* (0, getVersion_12.getVersion)();
      return yield* (0, signMessage_1.signMessage)(version2, request);
    }
    signCIP36Vote(request) {
      return __awaiter2(this, void 0, void 0, function* () {
        const parsedCVote = (0, cVote_1.parseCVote)(request);
        return interact(this._signCIP36Vote(parsedCVote), this._send);
      });
    }
    *_signCIP36Vote(request) {
      const version2 = yield* (0, getVersion_12.getVersion)();
      return yield* (0, signCVote_1.signCVote)(version2, request);
    }
    deriveNativeScriptHash({ script, displayFormat }) {
      return __awaiter2(this, void 0, void 0, function* () {
        const parsedScript = (0, nativeScript_12.parseNativeScript)(script);
        const parsedDisplayFormat = (0, nativeScript_12.parseNativeScriptHashDisplayFormat)(displayFormat);
        return interact(this._deriveNativeScriptHash(parsedScript, parsedDisplayFormat), this._send);
      });
    }
    *_deriveNativeScriptHash(script, displayFormat) {
      const version2 = yield* (0, getVersion_12.getVersion)();
      return yield* (0, deriveNativeScriptHash_1.deriveNativeScriptHash)(version2, script, displayFormat);
    }
  }
  exports2.Ada = Ada2;
  exports2.default = Ada2;
  exports2.Networks = {
    Mainnet: {
      networkId: 1,
      protocolMagic: 764824073
    },
    Testnet: {
      networkId: 0,
      protocolMagic: 1097911063
    }
  };
})(Ada);
const doLog = false;
const storeId = "useLedgerDevice";
const isWebUSBSupported = async () => {
  return await TransportWebUSB.isSupported();
};
const isWebHIDSupported = async () => {
  return await TransportWebHID.isSupported();
};
const isWebBLESupported = async () => {
  return await BluetoothTransport.isSupported();
};
let _transportType = null;
let _transport = null;
let _transportClose = null;
let _ledger = null;
let _version = null;
let _requestNumber = 0;
const ledgerTransport = getLedgerTransport();
const setActiveTransport = (transport2, type2) => {
  _transportClose = null;
  _transport = transport2;
  _transportType = type2;
  if (!_transport && _ledger) {
    _ledger = null;
  }
};
async function closeTransport() {
  try {
    if (!_transport) {
      return;
    }
    if (doLog) ;
    _transportClose = _transport.close();
    await _transportClose;
    if (doLog) ;
    setActiveTransport(null, null);
  } catch (e) {
    console.error(e);
  }
}
const tryHidTransport = async () => {
  const isSupported2 = await isWebHIDSupported();
  if (isSupported2) {
    try {
      if (_transportClose) {
        await _transportClose;
      }
      if (_transport && _transportType === "WebHID") {
        return _transport;
      }
      let transport2 = await TransportWebHID.create();
      transport2.on("disconnect", () => {
        if (doLog) ;
        setActiveTransport(null, null);
      });
      if (doLog) ;
      setActiveTransport(transport2, "WebHID");
      return transport2;
    } catch (e) {
      console.error(e);
      throw e;
    }
  } else {
    throw new Error("WebHID not supported. Please check USB connection and/or choose another connection method.");
  }
};
const tryUsbTransport = async () => {
  const isSupported2 = await isWebUSBSupported();
  if (isSupported2) {
    if (_transportClose) {
      await _transportClose;
    }
    if (_transport && _transportType === "WebUSB") {
      return _transport;
    }
    let transport2 = await TransportWebUSB.create();
    transport2.on("disconnect", () => {
      setActiveTransport(null, null);
    });
    setActiveTransport(transport2, "WebUSB");
    return transport2;
  } else {
    throw new Error("WebUSB not supported. Please check USB connection and/or choose another connection method.");
  }
};
const tryBluetoothTransport = async () => {
  const isSupported2 = await isWebBLESupported();
  if (isSupported2) {
    if (_transportClose) {
      await _transportClose;
    }
    if (_transport && _transportType === "WebBLE") {
      return _transport;
    }
    let transport2 = await BluetoothTransport.create(12e3);
    transport2.on("disconnect", () => {
      setActiveTransport(null, null);
    });
    setActiveTransport(transport2, "WebBLE");
    return transport2;
  } else {
    throw new Error("Bluetooth not supported by Ledger device or platform. Please check bluetooth connection and/or choose another connection method in wallet settings.");
  }
};
async function _getLedgerTransport(type2) {
  type2 = type2 ?? (ledgerTransport.value === "USB" ? "WebHID" : "WebBLE");
  let transport2;
  try {
    switch (type2) {
      case "WebHID":
        transport2 = await tryHidTransport();
        break;
      case "WebUSB":
        transport2 = await tryUsbTransport();
        break;
      case "WebBLE":
        transport2 = await tryBluetoothTransport();
        break;
    }
  } catch (err) {
    console.error("Ledger transport:", err, { name: err.name, message: err.message });
    throw err;
  }
  return transport2;
}
async function initiateLedger(type2, signingMode = null, timeout) {
  _requestNumber++;
  try {
    const transport2 = await _getLedgerTransport(type2);
    if (timeout) ;
    const ledger = new Ada.Ada(transport2);
    const version2 = await ledger.getVersion();
    console.log("ledger version", version2.version);
    console.log("ledger compatibility", version2.compatibility);
    _version = version2;
    if (signingMode === Ada.TransactionSigningMode.PLUTUS_TRANSACTION) {
      if (!version2.compatibility.supportsAlonzo) throw new Error("Alonzo: Ledger app version too old, please update firmware and Cardano app version on your Ledger device.");
    } else if (signingMode === Ada.TransactionSigningMode.MULTISIG_TRANSACTION) {
      if (!version2.compatibility.supportsMultisigTransaction) throw new Error("Multisig: Ledger app version too old, please update firmware and Cardano app version on your Ledger device.");
    } else {
      if (!version2.compatibility.supportsMary) throw new Error("Mary: Ledger app version too old, please update firmware and Cardano app version on your Ledger device.");
    }
    _ledger = ledger;
    return ledger;
  } catch (error) {
    if (!type2 || type2 === "WebHID") {
      try {
        return initiateLedger("WebUSB", signingMode, timeout);
      } catch (e) {
      }
    }
    let errMsg = error.message ?? error;
    if (errMsg.includes("0x6e01") || errMsg.includes("0x5515")) {
      errMsg = "Please unlock and open the Cardano app on your Ledger device before proceeding.";
    }
    throw new Error(errMsg);
  }
}
async function getLedgerPublicKeyAndSerial(accPurpose = purpose.hdwallet, accIndex = -1, amountAccounts = 1, accList = []) {
  const ledger = await initiateLedger();
  const requestNumber = _requestNumber;
  if (!ledger) {
    return { serial: "", pubKeyList: [] };
  }
  const { serialHex } = await ledger.getSerial();
  if (requestNumber !== _requestNumber) {
    return { serial: "", pubKeyList: [] };
  }
  const list = [];
  const responseList = [];
  if (accIndex === -1 && accList.length === 0) {
    let paths = [];
    for (let i = 0; i < amountAccounts; i++) {
      paths.push(getHardenedDerivationPath([accPurpose, coin.ada, i]));
    }
    responseList.push(...await ledger.getExtendedPublicKeys({
      paths
    }));
  } else if (accList.length === 0) {
    if (accIndex >= 0 || accPurpose !== purpose.hdwallet) {
      responseList.push(...await ledger.getExtendedPublicKeys({
        paths: [
          getHardenedDerivationPath([accPurpose, coin.ada, accIndex])
        ]
      }));
    } else {
      responseList.push(...await ledger.getExtendedPublicKeys({
        paths: [
          getHardenedDerivationPath([purpose.hdwallet, coin.ada, 0])
          // compare to current wallet
        ]
      }));
    }
  } else {
    let paths = [];
    for (let i = 0; i < accList.length; i++) {
      paths.push(getHardenedDerivationPath([accPurpose, coin.ada, accList[i]]));
    }
    responseList.push(...await ledger.getExtendedPublicKeys({
      paths
    }));
  }
  if (requestNumber !== _requestNumber) {
    return { serial: "", pubKeyList: [] };
  }
  for (const response of responseList) {
    list.push(getPubKeyFromHex(response.publicKeyHex + response.chainCodeHex));
  }
  closeTransport().catch((e) => console.error(e));
  return { serial: serialHex, pubKeyList: list };
}
async function getLedgerPublicKey(accPurpose = purpose.hdwallet, accIndex = -1, amountAccounts = 1, accList = []) {
  return (await getLedgerPublicKeyAndSerial(accPurpose, accIndex, amountAccounts, accList)).pubKeyList;
}
const signMessageWithLedger = async (appAccount, address2, payload) => {
  const accountData = appAccount.data;
  const networkId = appAccount.data.state.networkId;
  const isTestnet = isTestnetNetwork(networkId);
  const network2 = {
    protocolMagic: getNetworkMagic(isTestnet ? networkId : "mainnet"),
    networkId: isTestnet ? 0 : 1
  };
  const hashPayload = payload.length > 99;
  const keyDetails = getAccountKeyDetails(address2, accountData);
  try {
    const accountKey = keyDetails.accountCredAndType.cred;
    let req;
    if (accountKey.path[3] > 2) {
      req = {
        messageHex: payload,
        signingPath: getHardenedDerivationPath(accountKey.path),
        hashPayload,
        preferHexDisplay: false,
        addressFieldType: Ada.MessageAddressFieldType.KEY_HASH
      };
    } else {
      req = {
        messageHex: payload,
        signingPath: getHardenedDerivationPath(accountKey.path),
        hashPayload,
        preferHexDisplay: false,
        addressFieldType: Ada.MessageAddressFieldType.ADDRESS,
        address: generateLedgerOwnedAddress(accountData, keyDetails.addrPaymentCred, keyDetails.addrStakeCred),
        network: network2
      };
    }
    const req_json = JSON.parse(JSON.stringify(req));
    console.log("req_json", req_json);
    const ledger = await initiateLedger();
    const requestNumber = _requestNumber;
    const response = await ledger.signMessage(req);
    if (requestNumber !== _requestNumber) {
      throw new Error("Ledger request closes.");
    }
    const builder = createSignDataBuilder(toHexArray(response.addressFieldHex), payload, hashPayload);
    const coseSign1 = builder.build(toHexArray(response.signatureHex));
    const signatureHex = toHexString(coseSign1.to_bytes());
    const keyHex = createCOSEKeyHex(toHexArray(response.signingPublicKeyHex));
    console.warn("signatureHex:", signatureHex);
    safeFreeCSLObject(builder);
    safeFreeCSLObject(coseSign1);
    return {
      signature: signatureHex,
      key: keyHex
    };
  } catch (err) {
    closeTransport();
    throw (err == null ? void 0 : err.message) ?? err;
  }
};
const signTxWithLedger = async (appAccount, txBuildRes, credList, moreTxFollow = false) => {
  var _a, _b;
  let cslSignedTx;
  let cslWitnessSetOwned;
  let cslVkeys;
  let cslCatalystMeta;
  let cslCatalystMetaSigned;
  let res = { error: "notExecuted" };
  try {
    if (!(txBuildRes == null ? void 0 : txBuildRes.builtTx)) {
      return { error: ErrorSignTx.missingTx };
    }
    if (!(txBuildRes == null ? void 0 : txBuildRes.txCbor)) {
      return { error: ErrorSignTx.missingTx };
    }
    if (!credList) {
      return { error: ErrorSignTx.missingKeysList };
    }
    const networkId = appAccount.data.state.networkId;
    const epochParams = checkEpochParams(networkId);
    let ledgerSign;
    try {
      ledgerSign = await getWitnessesWithLedger(
        appAccount,
        txBuildRes,
        credList,
        moreTxFollow,
        false
      );
    } catch (e) {
      if ((_a = e == null ? void 0 : e.message) == null ? void 0 : _a.startsWith("General error 0x6e04")) {
        ledgerSign = await getWitnessesWithLedger(
          appAccount,
          txBuildRes,
          credList,
          moreTxFollow,
          false
        );
      } else {
        throw e;
      }
    }
    cslWitnessSetOwned = TransactionWitnessSet.from_hex(ledgerSign.serializedWitnessSet);
    const cslVkeysOwned = cslWitnessSetOwned.vkeys();
    cslVkeys = txBuildRes.cslWitnessSet.vkeys() ?? Vkeywitnesses.new();
    for (let i = 0; i < ((cslVkeysOwned == null ? void 0 : cslVkeysOwned.len()) ?? 0); i++) {
      const vkeyWitness = cslVkeysOwned.get(i);
      if (!hasWitness(cslVkeys, vkeyWitness)) {
        cslVkeys.add(vkeyWitness);
      }
      safeFreeCSLObject(vkeyWitness);
    }
    txBuildRes.cslWitnessSet.set_vkeys(cslVkeys);
    safeFreeCSLObject(cslVkeysOwned);
    if (txBuildRes.cslAuxData && isCatalystVotingRegistrationMetadata(txBuildRes.cslAuxData)) {
      if (!((_b = ledgerSign.signedTransactionData.auxiliaryDataSupplement) == null ? void 0 : _b.cip36VoteRegistrationSignatureHex)) {
        return { error: ErrorSignTx.ledgerCatalyst };
      }
      cslCatalystMeta = getCatalystRegistrationMetadata(txBuildRes.cslAuxData);
      cslCatalystMetaSigned = addCatalystRegistrationSignature(
        cslCatalystMeta,
        void 0,
        ledgerSign.signedTransactionData.auxiliaryDataSupplement.cip36VoteRegistrationSignatureHex
      );
      safeFreeCSLObject(txBuildRes.cslAuxData);
      txBuildRes.cslAuxData = generateCatalystRegistration(cslCatalystMetaSigned);
      const cslAuxHash = hash_auxiliary_data(txBuildRes.cslAuxData);
      txBuildRes.builtTx.auxiliary_data = cslToJson(txBuildRes.cslAuxData.to_json());
      txBuildRes.cslTxBody.set_auxiliary_data_hash(cslAuxHash);
      let cslTxHash;
      try {
        const cslFixedTx = FixedTransaction.new_from_body_bytes(txBuildRes.cslTxBody.to_bytes());
        cslTxHash = cslFixedTx.transaction_hash();
        safeFreeCSLObject(cslFixedTx);
      } catch (err) {
        if (err === "NOT_IMPLEMENTED") {
          console.warn("NOT_IMPLEMENTED > fallback cslTxHash");
          cslTxHash = hash_transaction(txBuildRes.cslTxBody);
        } else {
          throw err;
        }
      }
      txBuildRes.txHash = toHexString(cslTxHash.to_bytes());
      txBuildRes.txCbor = null;
      safeFreeCSLObject(cslAuxHash);
      safeFreeCSLObject(cslTxHash);
    }
    cslSignedTx = Transaction.new(txBuildRes.cslTxBody, txBuildRes.cslWitnessSet, txBuildRes.cslAuxData);
    txBuildRes.cslAuxData = cslSignedTx.auxiliary_data();
    const signedTxBytes = cslSignedTx.to_bytes();
    const signedTxHash = txBuildRes.txHash;
    const signedTx = getTransactionJSONFromCSL(networkId, cslSignedTx);
    const signedTxSize = signedTxBytes.byteLength;
    if (ledgerSign.signedTransactionData.txHashHex !== signedTxHash) {
      console.error("Ledger tx hash:", ledgerSign.signedTransactionData.txHashHex);
      console.error("Eternl tx hash:", signedTxHash);
      return { error: ErrorSignTx.ledgerTxHashMismatch };
    }
    signedTx.hash = signedTxHash;
    signedTx.size = signedTxSize;
    signedTx.inputUtxoList = txBuildRes.builtTx.inputUtxoList;
    const signedTxHex = reinjectWitnessSet(txBuildRes.txCbor, toHexString(signedTxBytes), txBuildRes.cslWitnessSet);
    const signedTxWitnessSet = toHexString(txBuildRes.cslWitnessSet.to_bytes());
    const maxTxSize = epochParams.maxTxSize;
    signedTx.cbor = signedTxHex;
    res = {
      tx: signedTx,
      hash: signedTxHash,
      cbor: signedTxHex,
      witnessSet: signedTxWitnessSet,
      witnessSetOwned: ledgerSign.serializedWitnessSet
    };
    if (signedTxSize > epochParams.maxTxSize) {
      res.error = ErrorSignTx.txSize + "." + signedTxSize + "." + maxTxSize;
    }
  } catch (err) {
    closeTransport();
    res = { error: (err == null ? void 0 : err.message) ?? err };
  }
  safeFreeCSLObject(cslSignedTx);
  safeFreeCSLObject(cslWitnessSetOwned);
  safeFreeCSLObject(cslVkeys);
  safeFreeCSLObject(cslCatalystMeta);
  safeFreeCSLObject(cslCatalystMetaSigned);
  return res;
};
const getWitnessesWithLedger = async (appAccount, txBuildRes, credList, moreTxFollow = false, doHashCheck = true) => {
  const accountData = appAccount.data;
  const networkId = accountData.state.networkId;
  const isTestnet = isTestnetNetwork(networkId);
  const network2 = {
    protocolMagic: getNetworkMagic(isTestnet ? networkId : "mainnet"),
    networkId: isTestnet ? 0 : 1
  };
  const tx = txBuildRes.builtTx;
  if (tx.body.voting_proposals) {
    throw new Error("Tx contains unsupported by Ledger governance voting proposals");
  }
  let inputUtxoList = tx.inputUtxoList;
  if (!inputUtxoList) {
    const { utxoList } = getFilteredUtxoList(appAccount, false);
    inputUtxoList = utxoList;
  }
  const inputs = await generateLedgerInputs(accountData, tx.body.inputs, inputUtxoList);
  const collateralInputs = tx.body.collateral ? await generateLedgerInputs(accountData, tx.body.collateral, inputUtxoList) : null;
  const referenceInputs = tx.body.reference_inputs ? await generateLedgerInputs(accountData, tx.body.reference_inputs, inputUtxoList) : null;
  const outputs = generateLedgerOutputs(accountData, tx, tx.body.outputs, false);
  let collateralOutput = null;
  if (tx.body.collateral_return) {
    collateralOutput = generateLedgerOutputs(accountData, tx, [tx.body.collateral_return], true)[0];
  }
  const additionalWitnessPaths = generateAdditionalWitnessPaths$1(credList, inputs, collateralInputs, referenceInputs);
  let lTx = {
    network: network2,
    inputs,
    outputs,
    fee: tx.body.fee
  };
  const ttl = tx.body.ttl;
  const donation = tx.body.donation;
  const totalCollateral = tx.body.total_collateral;
  const withdrawals = tx.body.withdrawals;
  const certificates = tx.body.certs;
  const validityStart = tx.body.validity_start_interval;
  const scriptDataHash = tx.body.script_data_hash;
  const metadataHash = tx.body.auxiliary_data_hash;
  const mint = tx.body.mint;
  const requiredSigners = tx.body.required_signers;
  const includeNetworkId = !!tx.body.network_id;
  const votingProcedures = tx.body.voting_procedures;
  const hasConwaySetTag = tx.hasConwaySetTag;
  if (ttl) {
    lTx.ttl = ttl;
  }
  if (donation) {
    lTx.donation = donation;
  }
  if (collateralInputs) {
    lTx.collateralInputs = collateralInputs;
  }
  if (referenceInputs) {
    lTx.referenceInputs = referenceInputs;
  }
  if (collateralOutput) {
    lTx.collateralOutput = collateralOutput;
  }
  if (totalCollateral != null) {
    lTx.totalCollateral = totalCollateral;
  }
  if (withdrawals) {
    lTx.withdrawals = generateLedgerWithdrawals(accountData, withdrawals);
  }
  if (certificates) {
    lTx.certificates = generateLedgerCertificates(accountData, certificates);
  }
  if (txBuildRes.cslAuxData && isCatalystVotingRegistrationMetadata(txBuildRes.cslAuxData)) {
    lTx.auxiliaryData = generateLedgerMetadata(accountData, txBuildRes.cslAuxData);
  } else if (metadataHash) {
    lTx.auxiliaryData = generateLedgerMetadataFromHash(metadataHash);
  }
  if (mint) {
    lTx.mint = generateLedgerMintBundle(mint);
  }
  if (scriptDataHash != null) {
    lTx.scriptDataHashHex = scriptDataHash;
  }
  if (validityStart != null) {
    lTx.validityIntervalStart = validityStart;
  }
  if (requiredSigners) {
    lTx.requiredSigners = generateRequiredSigners$1(accountData, requiredSigners);
  }
  if (includeNetworkId) {
    lTx.includeNetworkId = true;
  }
  if (votingProcedures) {
    lTx.votingProcedures = generateLedgerVotingProcedures(accountData, votingProcedures);
  }
  let signingMode;
  if (!!collateralInputs || !!tx.witness_set.redeemers || !!tx.body.reference_inputs) {
    signingMode = Ada.TransactionSigningMode.PLUTUS_TRANSACTION;
  } else if (additionalWitnessPaths.some((path2) => path2[0] === harden(purpose.multisig) || path2[0] === harden(purpose.minting))) {
    signingMode = Ada.TransactionSigningMode.MULTISIG_TRANSACTION;
  } else {
    signingMode = Ada.TransactionSigningMode.ORDINARY_TRANSACTION;
  }
  let req = {
    signingMode,
    tx: lTx,
    options: {
      tagCborSets: hasConwaySetTag
    }
  };
  if (additionalWitnessPaths.length > 0) {
    req.additionalWitnessPaths = additionalWitnessPaths;
  }
  const req_json = JSON.parse(JSON.stringify(req));
  txBuildRes.hwRequest = req_json;
  console.log("builtTx", txBuildRes);
  console.log("req_json", JSON.stringify(req_json));
  console.log("req_json", req_json);
  const ledger = await initiateLedger(void 0, signingMode);
  const requestNumber = _requestNumber;
  const response = await ledger.signTransaction(req_json);
  if (requestNumber !== _requestNumber) {
    throw new Error("Ledger request closes.");
  }
  console.log("response", response);
  console.log("txBuildRes ", txBuildRes);
  if (!moreTxFollow) {
    closeTransport().catch((e) => console.error(e));
  }
  if (txBuildRes.txHash && doHashCheck) {
    if (response.txHashHex !== txBuildRes.txHash) {
      console.error("Ledger tx hash response:", response.txHashHex);
      console.error("Source tx hash from cbor:", txBuildRes.txHash);
      throw new Error("Tx serialization mismatch between Ledger and source transaction");
    }
  }
  const witnessSetHex = assembleWitnesses$1(accountData, response);
  return {
    serializedWitnessSet: witnessSetHex,
    signedTransactionData: response
  };
};
const assembleWitnesses$1 = (accountData, signedTxData) => {
  const witnesses = TransactionWitnessSet.new();
  const vkeyWitnesses = witnesses.vkeys() ?? Vkeywitnesses.new();
  for (const witness of signedTxData.witnesses) {
    const pubKey = createPubKey(accountData.account.pub, witness.path.slice(3));
    vkeyWitnesses.add(getVkeyWitness(pubKey, witness.witnessSignatureHex));
  }
  witnesses.set_vkeys(vkeyWitnesses);
  const witnessSetHex = witnesses.to_hex();
  safeFreeCSLObject(vkeyWitnesses);
  safeFreeCSLObject(witnesses);
  return witnessSetHex;
};
function generateRequiredSigners$1(accountData, requiredSigners) {
  const requiredSignerList = [];
  for (const requiredSigner of requiredSigners) {
    const cred = getOwnedCred([accountData.keys], requiredSigner);
    if (cred) {
      requiredSignerList.push({
        type: Ada.TxRequiredSignerType.PATH,
        path: getHardenedDerivationPath(cred.path)
      });
    } else {
      requiredSignerList.push({
        type: Ada.TxRequiredSignerType.HASH,
        hashHex: requiredSigner
      });
    }
  }
  return requiredSignerList;
}
function generateAdditionalWitnessPaths$1(credList, inputs, collaterals, refInputs, checkInputs) {
  const additionalWitnessPaths = [];
  {
    for (const cred of credList) {
      const hardenedPath = getHardenedDerivationPath(cred.path);
      if (additionalWitnessPaths.some((i) => isSameArray(i, hardenedPath))) {
        continue;
      }
      const isPartOfInputs = inputs.some((item) => item.path && isSameArray(item.path, hardenedPath));
      const isPartOfCollaterals = collaterals ? collaterals.some((item) => item.path && isSameArray(item.path, hardenedPath)) : false;
      const isPartOfRefInputs = refInputs ? refInputs.some((item) => item.path && isSameArray(item.path, hardenedPath)) : false;
      if (!isPartOfInputs && !isPartOfCollaterals && !isPartOfRefInputs) {
        additionalWitnessPaths.push(hardenedPath);
      }
    }
  }
  return additionalWitnessPaths;
}
async function generateLedgerInputs(accountData, inputs, utxoList) {
  const ledgerInputs = [];
  for (const input of inputs) {
    const utxo = utxoList.find((u) => u.input.transaction_id === input.transaction_id && u.input.index === input.index);
    const cred = utxo ? getAddressCredentials(utxo.output.address) : null;
    const key = cred ? getOwnedCred([accountData.keys], cred.paymentCred) : null;
    ledgerInputs.push({
      txHashHex: input.transaction_id,
      outputIndex: input.index,
      path: key ? getHardenedDerivationPath(key.path) : null
    });
  }
  return ledgerInputs;
}
function generateLedgerOutputs(accountData, tx, outputs, isCollateral) {
  var _a, _b;
  const ledgerOutputs = [];
  for (let i = 0; i < outputs.length; i++) {
    const output2 = outputs[i];
    const cred = getAddressCredentials(output2.address, null, true);
    if (!cred) {
      throw new Error("unable to parse output address: " + output2.address);
    }
    const paymentCred = cred.paymentCred ? getOwnedCred([accountData.keys], cred.paymentCred) : null;
    let out;
    let format = Ada.TxOutputFormat.ARRAY_LEGACY;
    const outputData = isCollateral ? (_a = tx.colOutputDataList) == null ? void 0 : _a[i] : (_b = tx.outputData) == null ? void 0 : _b[i];
    if (outputData && outputData.isBabbage) {
      format = Ada.TxOutputFormat.MAP_BABBAGE;
    }
    try {
      if (paymentCred) {
        out = {
          format,
          destination: {
            type: Ada.TxOutputDestinationType.DEVICE_OWNED,
            params: generateLedgerOwnedAddress(accountData, paymentCred, cred.stakeCred)
          },
          amount: output2.amount.coin
        };
      }
    } catch (err) {
    }
    if (!out) {
      out = {
        format,
        destination: {
          type: Ada.TxOutputDestinationType.THIRD_PARTY,
          params: {
            addressHex: toHexString(cred.addressBytes)
          }
        },
        amount: output2.amount.coin
      };
    }
    if (output2.amount.multiasset) {
      out.tokenBundle = generateLedgerTokenBundle(output2.amount.multiasset);
    }
    if (output2.script_ref) {
      let script = null;
      if (outputData == null ? void 0 : outputData.plutusScriptBytes) {
        script = toHexString(outputData.plutusScriptBytes);
      } else {
        script = output2.script_ref["PlutusScript"] ?? output2.script_ref["NativeScript"] ?? null;
      }
      if (script && typeof script === "string") {
        out = {
          ...out,
          referenceScriptHex: script
        };
      }
    }
    const hvb = getPlutusHVB(output2.plutus_data);
    if (outputData == null ? void 0 : outputData.plutusDataBytes) {
      hvb.bytes = toHexString(outputData.plutusDataBytes);
    }
    if (hvb.bytes) {
      out = {
        ...out,
        datum: {
          type: 1,
          // DatumType.INLINE
          datumHex: hvb.bytes
        }
      };
    } else if (hvb.hash) {
      if (format === Ada.TxOutputFormat.MAP_BABBAGE) {
        out = {
          ...out,
          datum: {
            type: 0,
            // DatumType.HASH
            datumHashHex: hvb.hash
          }
        };
      } else {
        out = {
          ...out,
          datumHashHex: hvb.hash
        };
      }
    }
    ledgerOutputs.push(out);
  }
  return ledgerOutputs;
}
const generateLedgerOwnedAddress = (accountData, paymentCred, stakeCred) => {
  const _paymentCred = typeof paymentCred === "string" ? getOwnedCred([accountData.keys], paymentCred) : paymentCred;
  const _stakeCred = typeof stakeCred === "string" ? getOwnedCred([accountData.keys], stakeCred, "stake") : stakeCred;
  if (_paymentCred && _stakeCred) {
    return {
      type: Ada.AddressType.BASE_PAYMENT_KEY_STAKE_KEY,
      params: {
        spendingPath: getHardenedDerivationPath(_paymentCred.path),
        stakingPath: getHardenedDerivationPath(_stakeCred.path)
      }
    };
  } else if (_paymentCred && !stakeCred) {
    return {
      type: Ada.AddressType.ENTERPRISE_KEY,
      params: {
        spendingPath: getHardenedDerivationPath(_paymentCred.path)
      }
    };
  } else if (_stakeCred && !paymentCred) {
    return {
      type: Ada.AddressType.REWARD_KEY,
      params: {
        stakingPath: getHardenedDerivationPath(_stakeCred.path)
      }
    };
  }
  throw new Error(`generateLedgerOwnedAddress: couldn't find cred for: paymentCred=${paymentCred}, stakeCred=${stakeCred}`);
};
function generateLedgerTokenBundle(assets) {
  const assetGroup = [];
  const sortedPolicyList = Object.entries(assets).sort((a, b) => a[0].localeCompare(b[0], "en-US"));
  for (const policy of sortedPolicyList) {
    const assetList = [];
    const sortedAssetList = Object.entries(policy[1]).sort((a, b) => {
      return a[0].length === b[0].length ? a[0].localeCompare(b[0], "en-US") : a[0].length - b[0].length;
    });
    for (const asset of sortedAssetList) {
      assetList.push({
        assetNameHex: asset[0],
        amount: asset[1]
      });
    }
    assetGroup.push({
      policyIdHex: policy[0],
      tokens: assetList
    });
  }
  return assetGroup;
}
function generateLedgerMintBundle(mintList) {
  const assetGroup = [];
  const sortedMintList = [...mintList].sort((a, b) => a[0].localeCompare(b[0], "en-US"));
  for (const mint of sortedMintList) {
    const assetList = [];
    const sortedAssetList = Object.entries(mint[1]).sort((a, b) => {
      return a[0].length === b[0].length ? a[0].localeCompare(b[0], "en-US") : a[0].length - b[0].length;
    });
    for (const asset of sortedAssetList) {
      assetList.push({
        assetNameHex: asset[0],
        amount: asset[1]
      });
    }
    assetGroup.push({
      policyIdHex: mint[0],
      tokens: assetList
    });
  }
  return assetGroup;
}
function generateLedgerWithdrawals(accountData, withdrawals) {
  const ledgerWithdrawals = [];
  for (const withdrawal of Object.entries(withdrawals)) {
    const cred = getAddressCredentials(withdrawal[0]);
    const stakeCred = getOwnedCred([accountData.keys], cred.stakeCred, "stake");
    if (stakeCred) {
      ledgerWithdrawals.push({
        stakeCredential: {
          type: Ada.CredentialParamsType.KEY_PATH,
          keyPath: getHardenedDerivationPath(stakeCred.path)
        },
        amount: withdrawal[1]
      });
    } else if (cred.stakeCred) {
      ledgerWithdrawals.push({
        stakeCredential: isScriptStakeAddress(withdrawal[0]) ? {
          type: Ada.CredentialParamsType.SCRIPT_HASH,
          scriptHashHex: cred.stakeCred
        } : {
          type: Ada.CredentialParamsType.KEY_HASH,
          keyHashHex: cred.stakeCred
        },
        amount: withdrawal[1]
      });
    }
  }
  return ledgerWithdrawals.length === 0 ? void 0 : ledgerWithdrawals;
}
function generateLedgerCertificates(accountData, certificates) {
  const ledgerCertificate = [];
  const networkId = accountData.state.networkId;
  for (const cert of certificates) {
    const id2 = CertificateTypes.findIndex((type2) => type2 === Object.keys(cert)[0]);
    switch (id2) {
      case CertificateKind.StakeRegistration: {
        const regCert = cert.StakeRegistration;
        const cred = Object.values(regCert.stake_credential)[0];
        const addr = getRewardAddressFromCred(cred, networkId);
        const ownedCred = getOwnedCred([accountData.keys], cred, "stake");
        const ledgerRegCert = {
          type: regCert.coin ? Ada.CertificateType.STAKE_REGISTRATION_CONWAY : Ada.CertificateType.STAKE_REGISTRATION,
          params: {
            stakeCredential: ownedCred ? {
              type: Ada.CredentialParamsType.KEY_PATH,
              keyPath: getHardenedDerivationPath(ownedCred.path)
            } : isScriptStakeAddress(addr) ? {
              type: Ada.CredentialParamsType.SCRIPT_HASH,
              scriptHashHex: cred
            } : {
              type: Ada.CredentialParamsType.KEY_HASH,
              keyHashHex: cred
            }
          }
        };
        if (regCert.coin) {
          ledgerRegCert.params.deposit = regCert.coin;
        }
        ledgerCertificate.push(ledgerRegCert);
        break;
      }
      case CertificateKind.StakeDeregistration: {
        const deregCert = cert.StakeDeregistration;
        const cred = Object.values(deregCert.stake_credential)[0];
        const addr = getRewardAddressFromCred(cred, networkId);
        const ownedCred = getOwnedCred([accountData.keys], cred, "stake");
        const ledgerDeregCert = {
          type: deregCert.coin ? Ada.CertificateType.STAKE_DEREGISTRATION_CONWAY : Ada.CertificateType.STAKE_DEREGISTRATION,
          params: {
            stakeCredential: ownedCred ? {
              type: Ada.CredentialParamsType.KEY_PATH,
              keyPath: getHardenedDerivationPath(ownedCred.path)
            } : isScriptStakeAddress(addr) ? {
              type: Ada.CredentialParamsType.SCRIPT_HASH,
              scriptHashHex: cred
            } : {
              type: Ada.CredentialParamsType.KEY_HASH,
              keyHashHex: cred
            }
          }
        };
        if (deregCert.coin) {
          ledgerDeregCert.params.deposit = deregCert.coin;
        }
        ledgerCertificate.push(ledgerDeregCert);
        break;
      }
      case CertificateKind.StakeDelegation: {
        const delegation = cert.StakeDelegation;
        const cred = Object.values(delegation.stake_credential)[0];
        const addr = getRewardAddressFromCred(cred, networkId);
        const ownedCred = getOwnedCred([accountData.keys], cred, "stake");
        ledgerCertificate.push({
          type: Ada.CertificateType.STAKE_DELEGATION,
          params: {
            stakeCredential: ownedCred ? {
              type: Ada.CredentialParamsType.KEY_PATH,
              keyPath: getHardenedDerivationPath(ownedCred.path)
            } : isScriptStakeAddress(addr) ? {
              type: Ada.CredentialParamsType.SCRIPT_HASH,
              scriptHashHex: cred
            } : {
              type: Ada.CredentialParamsType.KEY_HASH,
              keyHashHex: cred
            },
            poolKeyHashHex: delegation.pool_keyhash
          }
        });
        break;
      }
      case CertificateKind.PoolRegistration:
      case CertificateKind.PoolRetirement:
        throw new Error("Error: generateLedgerCertificates: pool registration / retire cert no supported yet.");
      case CertificateKind.VoteDelegation: {
        const delegation = cert.VoteDelegation;
        const cred = Object.values(delegation.stake_credential)[0];
        const addr = getRewardAddressFromCred(cred, networkId);
        const drep = delegation.drep;
        const ownedCred = getOwnedCred([accountData.keys], cred, "stake");
        const ledgerVoteDel = {
          type: Ada.CertificateType.VOTE_DELEGATION,
          params: {
            stakeCredential: ownedCred ? {
              type: Ada.CredentialParamsType.KEY_PATH,
              keyPath: getHardenedDerivationPath(ownedCred.path)
            } : isScriptStakeAddress(addr) ? {
              type: Ada.CredentialParamsType.SCRIPT_HASH,
              scriptHashHex: cred
            } : {
              type: Ada.CredentialParamsType.KEY_HASH,
              keyHashHex: cred
            }
          }
        };
        if (typeof drep === "string") {
          if (drep === "AlwaysAbstain") {
            ledgerVoteDel.params.dRep = {
              type: Ada.DRepParamsType.ABSTAIN
            };
          } else {
            ledgerVoteDel.params.dRep = {
              type: Ada.DRepParamsType.NO_CONFIDENCE
            };
          }
        } else {
          const keyHash = drep.KeyHash;
          const ownedDRepCred = keyHash ? getOwnedCred([accountData.keys], keyHash, "drep") : null;
          if (keyHash) {
            if (ownedDRepCred) {
              ledgerVoteDel.params.dRep = {
                type: Ada.DRepParamsType.KEY_PATH,
                keyPath: getHardenedDerivationPath(ownedDRepCred.path)
              };
            } else {
              ledgerVoteDel.params.dRep = {
                type: Ada.DRepParamsType.KEY_HASH,
                keyHashHex: keyHash
              };
            }
          } else {
            ledgerVoteDel.params.dRep = {
              type: Ada.DRepParamsType.SCRIPT_HASH,
              scriptHashHex: drep.ScriptHash
            };
          }
        }
        ledgerCertificate.push(ledgerVoteDel);
        break;
      }
      case CertificateKind.CommitteeHotAuth: {
        const committeeHotAuth = cert.CommitteeHotAuth;
        const coldKey = Object.values(committeeHotAuth.committee_cold_credential)[0];
        const hotKey = Object.values(committeeHotAuth.committee_hot_credential)[0];
        const ownedColdCred = getOwnedCred([accountData.keys], coldKey, "cc_cold");
        const ownedHotCred = getOwnedCred([accountData.keys], hotKey, "cc_hot");
        const ledgerCommitteeHotAuth = {
          type: Ada.CertificateType.AUTHORIZE_COMMITTEE_HOT,
          params: {
            coldCredential: ownedColdCred ? {
              type: Ada.CredentialParamsType.KEY_PATH,
              keyPath: getHardenedDerivationPath(ownedColdCred.path)
            } : {
              type: Ada.CredentialParamsType.KEY_HASH,
              keyHashHex: ownedColdCred
            },
            hotCredential: ownedHotCred ? {
              type: Ada.CredentialParamsType.KEY_PATH,
              keyPath: getHardenedDerivationPath(ownedHotCred.path)
            } : {
              type: Ada.CredentialParamsType.KEY_HASH,
              keyHashHex: ownedHotCred
            }
          }
        };
        ledgerCertificate.push(ledgerCommitteeHotAuth);
        break;
      }
      case CertificateKind.CommitteeColdResign: {
        const committeeHColdResign = cert.CommitteeColdResign;
        const coldKey = Object.values(committeeHColdResign.committee_cold_credential)[0];
        const ownedColdCred = getOwnedCred([accountData.keys], coldKey, "cc_cold");
        const ledgerCommitteeColdResign = {
          type: Ada.CertificateType.RESIGN_COMMITTEE_COLD,
          params: {
            coldCredential: ownedColdCred ? {
              type: Ada.CredentialParamsType.KEY_PATH,
              keyPath: getHardenedDerivationPath(ownedColdCred.path)
            } : {
              type: Ada.CredentialParamsType.KEY_HASH,
              keyHashHex: ownedColdCred
            }
          }
        };
        if (committeeHColdResign.anchor) {
          ledgerCommitteeColdResign.params.anchor = {
            url: committeeHColdResign.anchor.anchor_url,
            hashHex: committeeHColdResign.anchor.anchor_data_hash
          };
        }
        ledgerCertificate.push(ledgerCommitteeColdResign);
        break;
      }
      case CertificateKind.DRepRegistration: {
        const drepRegistration = cert.DRepRegistration;
        const cred = Object.values(drepRegistration.voting_credential)[0];
        const ownedDRepCred = getOwnedCred([accountData.keys], cred, "drep");
        const ledgerDRepRegistration = {
          type: Ada.CertificateType.DREP_REGISTRATION,
          params: {
            dRepCredential: ownedDRepCred ? {
              type: Ada.CredentialParamsType.KEY_PATH,
              keyPath: getHardenedDerivationPath(ownedDRepCred.path)
            } : {
              type: Ada.CredentialParamsType.KEY_HASH,
              keyHashHex: ownedDRepCred
            },
            deposit: drepRegistration.coin
          }
        };
        if (drepRegistration.anchor) {
          ledgerDRepRegistration.params.anchor = {
            url: drepRegistration.anchor.anchor_url,
            hashHex: drepRegistration.anchor.anchor_data_hash
          };
        }
        ledgerCertificate.push(ledgerDRepRegistration);
        break;
      }
      case CertificateKind.DRepUpdate: {
        const drepUpdate = cert.DRepUpdate;
        const cred = Object.values(drepUpdate.voting_credential)[0];
        const ownedDRepCred = getOwnedCred([accountData.keys], cred, "drep");
        const ledgerDRepUpdate = {
          type: Ada.CertificateType.DREP_UPDATE,
          params: {
            dRepCredential: ownedDRepCred ? {
              type: Ada.CredentialParamsType.KEY_PATH,
              keyPath: getHardenedDerivationPath(ownedDRepCred.path)
            } : {
              type: Ada.CredentialParamsType.KEY_HASH,
              keyHashHex: ownedDRepCred
            }
          }
        };
        if (drepUpdate.anchor) {
          ledgerDRepUpdate.params.anchor = {
            url: drepUpdate.anchor.anchor_url,
            hashHex: drepUpdate.anchor.anchor_data_hash
          };
        }
        ledgerCertificate.push(ledgerDRepUpdate);
        break;
      }
      case CertificateKind.DRepDeregistration: {
        const drepDeregistration = cert.DRepDeregistration;
        const cred = Object.values(drepDeregistration.voting_credential)[0];
        const ownedDRepCred = getOwnedCred([accountData.keys], cred, "drep");
        const ledgerDRepdrepDeregistration = {
          type: Ada.CertificateType.DREP_DEREGISTRATION,
          params: {
            dRepCredential: ownedDRepCred ? {
              type: Ada.CredentialParamsType.KEY_PATH,
              keyPath: getHardenedDerivationPath(ownedDRepCred.path)
            } : {
              type: Ada.CredentialParamsType.KEY_HASH,
              keyHashHex: ownedDRepCred
            },
            deposit: drepDeregistration.coin
          }
        };
        ledgerCertificate.push(ledgerDRepdrepDeregistration);
        break;
      }
      default:
        throw new Error(`generateLedgerCertificates: unsupported certificate type`);
    }
  }
  return ledgerCertificate;
}
function generateLedgerMetadataFromHash(metadataHash) {
  return {
    type: Ada.TxAuxiliaryDataType.ARBITRARY_HASH,
    params: {
      hashHex: metadataHash
    }
  };
}
function generateLedgerMetadata(accountData, metadata) {
  if (isCatalystVotingRegistrationMetadata(metadata)) {
    const metadatum = getCatalystRegistrationMetadata(metadata).get(BigNum.from_str("61284"));
    const catalyst_meta = JSON.parse(decode_metadatum_to_json_str(metadatum, MetadataJsonSchema.BasicConversions));
    const votingPublicKey = catalyst_meta["1"];
    const nonce = catalyst_meta["4"];
    const rewardAddr = Address.from_hex(catalyst_meta["3"].replace(/^0x/, ""));
    const rewardAddrBech32 = rewardAddr.to_bech32();
    safeFreeCSLObject(rewardAddr);
    const cred = getAddressCredentials(rewardAddrBech32);
    const paymentCred = getOwnedCred([accountData.keys], cred.paymentCred);
    const stakeCred = getOwnedCred([accountData.keys], cred.stakeCred, "stake");
    if (!paymentCred || !stakeCred) {
      throw new Error("Error: generateLedgerMetadata: reward address credentials not found");
    }
    const stakingKeyPath = getHardenedDerivationPath(stakeCred.path);
    return {
      type: Ada.TxAuxiliaryDataType.CIP36_REGISTRATION,
      params: {
        format: Ada.CIP36VoteRegistrationFormat.CIP_15,
        voteKeyHex: votingPublicKey.replace(/^0x/, ""),
        // voteKeyPath: BIP32Path;
        // delegations: Array<CIP36VoteDelegation>;
        stakingPath: stakingKeyPath,
        paymentDestination: {
          type: Ada.TxOutputDestinationType.DEVICE_OWNED,
          params: generateLedgerOwnedAddress(accountData, paymentCred, stakeCred)
        },
        nonce
        // votingPurpose: bigint_like;
      }
    };
  } else {
    return {
      type: Ada.TxAuxiliaryDataType.ARBITRARY_HASH,
      params: {
        hashHex: blake2b256Str(toBufferFromArray(metadata.to_bytes()))
      }
    };
  }
}
function generateLedgerVotingProcedures(accountData, procedureList) {
  const ledgerVotingProcedures = [];
  for (const procedure of procedureList) {
    let voter = void 0;
    const voterType = Object.keys(procedure.voter)[0];
    switch (voterType) {
      case "ConstitutionalCommitteeHotKey": {
        const ccHotKey = procedure.voter.ConstitutionalCommitteeHotKey;
        const cred = Object.values(ccHotKey)[0];
        const ownedCred = getOwnedCred([accountData.keys], cred, "cc_hot");
        if (ownedCred) {
          voter = {
            type: Ada.VoterType.COMMITTEE_KEY_PATH,
            keyPath: getHardenedDerivationPath(ownedCred.path)
          };
        } else if (Object.keys(ccHotKey)[0] === "Key") {
          voter = {
            type: Ada.VoterType.COMMITTEE_KEY_HASH,
            keyHashHex: cred
          };
        } else {
          voter = {
            type: Ada.VoterType.COMMITTEE_SCRIPT_HASH,
            scriptHashHex: cred
          };
        }
        break;
      }
      case "DRep": {
        const drep = procedure.voter.DRep;
        const cred = Object.values(drep)[0];
        const ownedCred = getOwnedCred([accountData.keys], cred, "drep");
        if (ownedCred) {
          voter = {
            type: Ada.VoterType.DREP_KEY_PATH,
            keyPath: getHardenedDerivationPath(ownedCred.path)
          };
        } else if (Object.keys(drep)[0] === "Key") {
          voter = {
            type: Ada.VoterType.DREP_KEY_HASH,
            keyHashHex: cred
          };
        } else {
          voter = {
            type: Ada.VoterType.DREP_SCRIPT_HASH,
            scriptHashHex: cred
          };
        }
        break;
      }
      case "StakingPool": {
        voter = {
          type: Ada.VoterType.STAKE_POOL_KEY_HASH,
          keyHashHex: procedure.voter.StakingPool
        };
        break;
      }
      default:
        throw new Error(`generateLedgerVotingProcedures: unsupported voter type: ${voterType}`);
    }
    const votingProcedure = {
      voter,
      votes: []
    };
    for (const vote of procedure.votes) {
      let voteOption;
      if (vote.voting_procedure.vote === "No") {
        voteOption = Ada.VoteOption.NO;
      } else if (vote.voting_procedure.vote === "Yes") {
        voteOption = Ada.VoteOption.YES;
      } else {
        voteOption = Ada.VoteOption.ABSTAIN;
      }
      const ledgerVote = {
        govActionId: {
          txHashHex: vote.action_id.transaction_id,
          govActionIndex: vote.action_id.index
        },
        votingProcedure: {
          vote: voteOption
        }
      };
      if (vote.voting_procedure.anchor) {
        ledgerVote.votingProcedure.anchor = {
          url: vote.voting_procedure.anchor.anchor_url,
          hashHex: vote.voting_procedure.anchor.anchor_data_hash
        };
      }
      votingProcedure.votes.push(ledgerVote);
    }
    ledgerVotingProcedures.push(votingProcedure);
  }
  return ledgerVotingProcedures;
}
function getLedgerVersion() {
  return _version;
}
function useLedgerDevice() {
  return {
    getLedgerPublicKey,
    getLedgerPublicKeyAndSerial,
    getLedgerVersion,
    signTxWithLedger,
    signMessageWithLedger,
    getWitnessesWithLedger,
    closeLedger: closeTransport
  };
}
var lib$5 = {};
var factory$1 = {};
var events = {};
var uiRequest = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.createUiMessage = exports2.UI_REQUEST = exports2.UI_EVENT = void 0;
  exports2.UI_EVENT = "UI_EVENT";
  exports2.UI_REQUEST = {
    TRANSPORT: "ui-no_transport",
    BOOTLOADER: "ui-device_bootloader_mode",
    NOT_IN_BOOTLOADER: "ui-device_not_in_bootloader_mode",
    REQUIRE_MODE: "ui-device_require_mode",
    INITIALIZE: "ui-device_not_initialized",
    SEEDLESS: "ui-device_seedless",
    FIRMWARE_OLD: "ui-device_firmware_old",
    FIRMWARE_OUTDATED: "ui-device_firmware_outdated",
    FIRMWARE_NOT_SUPPORTED: "ui-device_firmware_unsupported",
    FIRMWARE_NOT_COMPATIBLE: "ui-device_firmware_not_compatible",
    FIRMWARE_NOT_INSTALLED: "ui-device_firmware_not_installed",
    FIRMWARE_PROGRESS: "ui-firmware-progress",
    FIRMWARE_RECONNECT: "ui-firmware_reconnect",
    DEVICE_NEEDS_BACKUP: "ui-device_needs_backup",
    REQUEST_UI_WINDOW: "ui-request_window",
    CLOSE_UI_WINDOW: "ui-close_window",
    REQUEST_PERMISSION: "ui-request_permission",
    REQUEST_CONFIRMATION: "ui-request_confirmation",
    REQUEST_PIN: "ui-request_pin",
    INVALID_PIN: "ui-invalid_pin",
    REQUEST_PASSPHRASE: "ui-request_passphrase",
    REQUEST_PASSPHRASE_ON_DEVICE: "ui-request_passphrase_on_device",
    INVALID_PASSPHRASE: "ui-invalid_passphrase",
    CONNECT: "ui-connect",
    LOADING: "ui-loading",
    SET_OPERATION: "ui-set_operation",
    SELECT_DEVICE: "ui-select_device",
    SELECT_ACCOUNT: "ui-select_account",
    SELECT_FEE: "ui-select_fee",
    UPDATE_CUSTOM_FEE: "ui-update_custom_fee",
    INSUFFICIENT_FUNDS: "ui-insufficient_funds",
    REQUEST_BUTTON: "ui-button",
    REQUEST_WORD: "ui-request_word",
    LOGIN_CHALLENGE_REQUEST: "ui-login_challenge_request",
    BUNDLE_PROGRESS: "ui-bundle_progress",
    ADDRESS_VALIDATION: "ui-address_validation",
    IFRAME_FAILURE: "ui-iframe_failure"
  };
  const createUiMessage = (type2, payload) => ({
    event: exports2.UI_EVENT,
    type: type2,
    payload
  });
  exports2.createUiMessage = createUiMessage;
})(uiRequest);
var uiResponse = {};
Object.defineProperty(uiResponse, "__esModule", { value: true });
uiResponse.createUiResponse = uiResponse.UI_RESPONSE = void 0;
const ui_request_1 = uiRequest;
uiResponse.UI_RESPONSE = {
  RECEIVE_PERMISSION: "ui-receive_permission",
  RECEIVE_CONFIRMATION: "ui-receive_confirmation",
  RECEIVE_PIN: "ui-receive_pin",
  RECEIVE_PASSPHRASE: "ui-receive_passphrase",
  RECEIVE_DEVICE: "ui-receive_device",
  RECEIVE_ACCOUNT: "ui-receive_account",
  RECEIVE_FEE: "ui-receive_fee",
  RECEIVE_WORD: "ui-receive_word",
  INVALID_PASSPHRASE_ACTION: "ui-invalid_passphrase_action",
  CHANGE_SETTINGS: "ui-change_settings",
  LOGIN_CHALLENGE_RESPONSE: "ui-login_challenge_response"
};
const createUiResponse = (type2, payload) => ({
  event: ui_request_1.UI_EVENT,
  type: type2,
  payload
});
uiResponse.createUiResponse = createUiResponse;
var blockchain = {};
var hasRequiredBlockchain;
function requireBlockchain() {
  if (hasRequiredBlockchain) return blockchain;
  hasRequiredBlockchain = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBlockchainMessage = exports2.BLOCKCHAIN = exports2.BLOCKCHAIN_EVENT = void 0;
    exports2.BLOCKCHAIN_EVENT = "BLOCKCHAIN_EVENT";
    exports2.BLOCKCHAIN = {
      CONNECT: "blockchain-connect",
      RECONNECTING: "blockchain-reconnecting",
      ERROR: "blockchain-error",
      BLOCK: "blockchain-block",
      NOTIFICATION: "blockchain-notification",
      FIAT_RATES_UPDATE: "fiat-rates-update"
    };
    const createBlockchainMessage = (type2, payload) => ({
      event: exports2.BLOCKCHAIN_EVENT,
      type: type2,
      payload
    });
    exports2.createBlockchainMessage = createBlockchainMessage;
  })(blockchain);
  return blockchain;
}
var call = {};
var errors$3 = {};
var hasRequiredErrors$3;
function requireErrors$3() {
  if (hasRequiredErrors$3) return errors$3;
  hasRequiredErrors$3 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LIBUSB_ERROR_MESSAGE = exports2.serializeError = exports2.TypedError = exports2.TrezorError = exports2.ERROR_CODES = void 0;
    exports2.ERROR_CODES = {
      Init_NotInitialized: "TrezorConnect not initialized",
      Init_AlreadyInitialized: "TrezorConnect has been already initialized",
      Init_IframeBlocked: "Iframe blocked",
      Init_IframeTimeout: "Iframe timeout",
      Init_ManifestMissing: "Manifest not set. Read more at https://github.com/trezor/trezor-suite/blob/develop/docs/packages/connect/index.md",
      Popup_ConnectionMissing: "Unable to establish connection with iframe",
      Transport_Missing: "Transport is missing",
      Transport_InvalidProtobuf: "",
      Method_InvalidPackage: "This package is not suitable to work with browser. Use @trezor/connect-web package instead",
      Method_InvalidParameter: "",
      Method_NotAllowed: "Method not allowed for this configuration",
      Method_PermissionsNotGranted: "Permissions not granted",
      Method_Cancel: "Cancelled",
      Method_Interrupted: "Popup closed",
      Method_UnknownCoin: "Coin not found",
      Method_AddressNotMatch: "Addresses do not match",
      Method_FirmwareUpdate_DownloadFailed: "Failed to download firmware binary",
      Method_Discovery_BundleException: "",
      Method_Override: "override",
      Method_NoResponse: "Call resolved without response",
      Backend_NotSupported: "BlockchainLink settings not found in coins.json",
      Backend_WorkerMissing: "",
      Backend_Disconnected: "Backend disconnected",
      Backend_Invalid: "Invalid backend",
      Backend_Error: "",
      Runtime: "",
      Device_NotFound: "Device not found",
      Device_InitializeFailed: "",
      Device_FwException: "",
      Device_ModeException: "",
      Device_Disconnected: "Device disconnected",
      Device_UsedElsewhere: "Device is used in another window",
      Device_InvalidState: "Passphrase is incorrect",
      Device_CallInProgress: "Device call in progress",
      Device_MultipleNotSupported: "Multiple devices are not supported"
    };
    class TrezorError extends Error {
      constructor(code, message2) {
        super(message2);
        this.code = code;
        this.message = message2;
      }
    }
    exports2.TrezorError = TrezorError;
    const TypedError = (id2, message2) => new TrezorError(id2, message2 || exports2.ERROR_CODES[id2]);
    exports2.TypedError = TypedError;
    const serializeError = (payload) => {
      if (payload && payload.error instanceof Error) {
        return { error: payload.error.message, code: payload.error.code };
      }
      return payload;
    };
    exports2.serializeError = serializeError;
    exports2.LIBUSB_ERROR_MESSAGE = "LIBUSB_ERROR";
  })(errors$3);
  return errors$3;
}
var hasRequiredCall;
function requireCall() {
  if (hasRequiredCall) return call;
  hasRequiredCall = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createResponseMessage = exports2.RESPONSE_EVENT = void 0;
    const errors_12 = requireErrors$3();
    exports2.RESPONSE_EVENT = "RESPONSE_EVENT";
    const createResponseMessage = (id2, success, payload) => ({
      event: exports2.RESPONSE_EVENT,
      type: exports2.RESPONSE_EVENT,
      id: id2,
      success,
      payload: success ? payload : (0, errors_12.serializeError)(payload)
    });
    exports2.createResponseMessage = createResponseMessage;
  })(call);
  return call;
}
var core = {};
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  Object.defineProperty(core, "__esModule", { value: true });
  core.createErrorMessage = core.parseMessage = core.CORE_EVENT = void 0;
  core.CORE_EVENT = "CORE_EVENT";
  const parseMessage = (messageData2) => {
    const message2 = {
      event: messageData2.event,
      type: messageData2.type,
      payload: messageData2.payload
    };
    if (typeof messageData2.id === "number") {
      message2.id = messageData2.id;
    }
    if (typeof messageData2.success === "boolean") {
      message2.success = messageData2.success;
    }
    return message2;
  };
  core.parseMessage = parseMessage;
  const createErrorMessage = (error) => ({
    success: false,
    payload: {
      error: error.message,
      code: error.code
    }
  });
  core.createErrorMessage = createErrorMessage;
  return core;
}
var device$1 = {};
var hasRequiredDevice$1;
function requireDevice$1() {
  if (hasRequiredDevice$1) return device$1;
  hasRequiredDevice$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDeviceMessage = exports2.DEVICE = exports2.DEVICE_EVENT = void 0;
    exports2.DEVICE_EVENT = "DEVICE_EVENT";
    exports2.DEVICE = {
      CONNECT: "device-connect",
      CONNECT_UNACQUIRED: "device-connect_unacquired",
      DISCONNECT: "device-disconnect",
      CHANGED: "device-changed",
      ACQUIRE: "device-acquire",
      RELEASE: "device-release",
      ACQUIRED: "device-acquired",
      RELEASED: "device-released",
      USED_ELSEWHERE: "device-used_elsewhere",
      SAVE_STATE: "device-save_state",
      LOADING: "device-loading",
      BUTTON: "button",
      PIN: "pin",
      PASSPHRASE: "passphrase",
      PASSPHRASE_ON_DEVICE: "passphrase_on_device",
      WORD: "word"
    };
    const createDeviceMessage = (type2, payload) => ({
      event: exports2.DEVICE_EVENT,
      type: type2,
      payload
    });
    exports2.createDeviceMessage = createDeviceMessage;
  })(device$1);
  return device$1;
}
var iframe$2 = {};
var hasRequiredIframe$1;
function requireIframe$1() {
  if (hasRequiredIframe$1) return iframe$2;
  hasRequiredIframe$1 = 1;
  Object.defineProperty(iframe$2, "__esModule", { value: true });
  iframe$2.createIFrameMessage = iframe$2.IFRAME = void 0;
  const ui_request_12 = uiRequest;
  iframe$2.IFRAME = {
    BOOTSTRAP: "iframe-bootstrap",
    LOADED: "iframe-loaded",
    INIT: "iframe-init",
    ERROR: "iframe-error",
    CALL: "iframe-call",
    LOG: "iframe-log"
  };
  const createIFrameMessage = (type2, payload) => ({
    event: ui_request_12.UI_EVENT,
    type: type2,
    payload
  });
  iframe$2.createIFrameMessage = createIFrameMessage;
  return iframe$2;
}
var popup$3 = {};
var hasRequiredPopup$1;
function requirePopup$1() {
  if (hasRequiredPopup$1) return popup$3;
  hasRequiredPopup$1 = 1;
  Object.defineProperty(popup$3, "__esModule", { value: true });
  popup$3.createPopupMessage = popup$3.POPUP = void 0;
  const ui_request_12 = uiRequest;
  popup$3.POPUP = {
    BOOTSTRAP: "popup-bootstrap",
    LOADED: "popup-loaded",
    CORE_LOADED: "popup-core-loaded",
    INIT: "popup-init",
    ERROR: "popup-error",
    EXTENSION_USB_PERMISSIONS: "open-usb-permissions",
    HANDSHAKE: "popup-handshake",
    CLOSED: "popup-closed",
    CANCEL_POPUP_REQUEST: "ui-cancel-popup-request",
    CLOSE_WINDOW: "window.close",
    ANALYTICS_RESPONSE: "popup-analytics-response",
    CONTENT_SCRIPT_LOADED: "popup-content-script-loaded",
    METHOD_INFO: "popup-method-info"
  };
  const createPopupMessage = (type2, payload) => ({
    event: ui_request_12.UI_EVENT,
    type: type2,
    payload
  });
  popup$3.createPopupMessage = createPopupMessage;
  return popup$3;
}
var transport = {};
var constants$1 = {};
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TRANSPORT = exports2.ACTION_TIMEOUT = exports2.TREZOR_USB_DESCRIPTORS = exports2.WEBUSB_BOOTLOADER_PRODUCT = exports2.T1_HID_VENDOR = exports2.ENDPOINT_ID = exports2.INTERFACE_ID = exports2.CONFIGURATION_ID = void 0;
    exports2.CONFIGURATION_ID = 1;
    exports2.INTERFACE_ID = 0;
    exports2.ENDPOINT_ID = 1;
    exports2.T1_HID_VENDOR = 21324;
    const T1_HID_PRODUCT = 1;
    const WEBUSB_FIRMWARE_PRODUCT = 21441;
    exports2.WEBUSB_BOOTLOADER_PRODUCT = 21440;
    exports2.TREZOR_USB_DESCRIPTORS = [
      { vendorId: 21324, productId: T1_HID_PRODUCT },
      { vendorId: 4617, productId: exports2.WEBUSB_BOOTLOADER_PRODUCT },
      { vendorId: 4617, productId: WEBUSB_FIRMWARE_PRODUCT }
    ];
    exports2.ACTION_TIMEOUT = 1e4;
    exports2.TRANSPORT = {
      START: "transport-start",
      ERROR: "transport-error",
      UPDATE: "transport-update",
      DISABLE_WEBUSB: "transport-disable_webusb",
      REQUEST_DEVICE: "transport-request_device"
    };
  })(constants$1);
  return constants$1;
}
var hasRequiredTransport;
function requireTransport() {
  if (hasRequiredTransport) return transport;
  hasRequiredTransport = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTransportMessage = exports2.TRANSPORT_EVENT = exports2.TRANSPORT = void 0;
    const errors_12 = requireErrors$3();
    var constants_12 = requireConstants$1();
    Object.defineProperty(exports2, "TRANSPORT", { enumerable: true, get: function() {
      return constants_12.TRANSPORT;
    } });
    exports2.TRANSPORT_EVENT = "TRANSPORT_EVENT";
    const createTransportMessage = (type2, payload) => ({
      event: exports2.TRANSPORT_EVENT,
      type: type2,
      payload: "error" in payload ? (0, errors_12.serializeError)(payload) : payload
    });
    exports2.createTransportMessage = createTransportMessage;
  })(transport);
  return transport;
}
var uiPromise = {};
var hasRequiredUiPromise;
function requireUiPromise() {
  if (hasRequiredUiPromise) return uiPromise;
  hasRequiredUiPromise = 1;
  Object.defineProperty(uiPromise, "__esModule", { value: true });
  return uiPromise;
}
var webextension = {};
var hasRequiredWebextension;
function requireWebextension() {
  if (hasRequiredWebextension) return webextension;
  hasRequiredWebextension = 1;
  Object.defineProperty(webextension, "__esModule", { value: true });
  webextension.WEBEXTENSION = void 0;
  webextension.WEBEXTENSION = {
    USB_PERMISSIONS_BROADCAST: "usb-permissions",
    USB_PERMISSIONS_INIT: "usb-permissions-init",
    USB_PERMISSIONS_CLOSE: "usb-permissions-close",
    USB_PERMISSIONS_FINISHED: "usb-permissions-finished",
    CHANNEL_HANDSHAKE_CONFIRM: "channel-handshake-confirm"
  };
  return webextension;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.UI = void 0;
  const tslib_12 = require$$0;
  const ui_request_12 = uiRequest;
  const ui_response_1 = uiResponse;
  tslib_12.__exportStar(requireBlockchain(), exports2);
  tslib_12.__exportStar(requireCall(), exports2);
  tslib_12.__exportStar(requireCore(), exports2);
  tslib_12.__exportStar(requireDevice$1(), exports2);
  tslib_12.__exportStar(requireIframe$1(), exports2);
  tslib_12.__exportStar(requirePopup$1(), exports2);
  tslib_12.__exportStar(requireTransport(), exports2);
  tslib_12.__exportStar(requireUiPromise(), exports2);
  tslib_12.__exportStar(uiRequest, exports2);
  tslib_12.__exportStar(uiResponse, exports2);
  tslib_12.__exportStar(requireWebextension(), exports2);
  exports2.UI = {
    ...ui_request_12.UI_REQUEST,
    ...ui_response_1.UI_RESPONSE
  };
})(events);
Object.defineProperty(factory$1, "__esModule", { value: true });
factory$1.factory = void 0;
const events_1$2 = events;
const factory = ({ eventEmitter, manifest, init, call: call2, requestLogin, uiResponse: uiResponse2, renderWebUSBButton, disableWebUSB, requestWebUSBDevice, cancel, dispose }) => {
  const api2 = {
    manifest,
    init,
    getSettings: () => call2({ method: "getSettings" }),
    on: (type2, fn) => {
      eventEmitter.on(type2, fn);
    },
    off: (type2, fn) => {
      eventEmitter.removeListener(type2, fn);
    },
    removeAllListeners: (type2) => {
      if (typeof type2 === "string") {
        eventEmitter.removeAllListeners(type2);
      } else {
        eventEmitter.removeAllListeners();
      }
    },
    uiResponse: uiResponse2,
    blockchainGetAccountBalanceHistory: (params2) => call2({ ...params2, method: "blockchainGetAccountBalanceHistory" }),
    blockchainGetCurrentFiatRates: (params2) => call2({ ...params2, method: "blockchainGetCurrentFiatRates" }),
    blockchainGetFiatRatesForTimestamps: (params2) => call2({ ...params2, method: "blockchainGetFiatRatesForTimestamps" }),
    blockchainDisconnect: (params2) => call2({ ...params2, method: "blockchainDisconnect" }),
    blockchainEstimateFee: (params2) => call2({ ...params2, method: "blockchainEstimateFee" }),
    blockchainGetTransactions: (params2) => call2({ ...params2, method: "blockchainGetTransactions" }),
    blockchainSetCustomBackend: (params2) => call2({ ...params2, method: "blockchainSetCustomBackend" }),
    blockchainSubscribe: (params2) => call2({ ...params2, method: "blockchainSubscribe" }),
    blockchainSubscribeFiatRates: (params2) => call2({ ...params2, method: "blockchainSubscribeFiatRates" }),
    blockchainUnsubscribe: (params2) => call2({ ...params2, method: "blockchainUnsubscribe" }),
    blockchainUnsubscribeFiatRates: (params2) => call2({ ...params2, method: "blockchainUnsubscribeFiatRates" }),
    requestLogin: (params2) => requestLogin(params2),
    cardanoGetAddress: (params2) => call2({
      ...params2,
      method: "cardanoGetAddress",
      useEventListener: eventEmitter.listenerCount(events_1$2.UI.ADDRESS_VALIDATION) > 0
    }),
    cardanoGetNativeScriptHash: (params2) => call2({ ...params2, method: "cardanoGetNativeScriptHash" }),
    cardanoGetPublicKey: (params2) => call2({ ...params2, method: "cardanoGetPublicKey" }),
    cardanoSignTransaction: (params2) => call2({ ...params2, method: "cardanoSignTransaction" }),
    cardanoComposeTransaction: (params2) => call2({ ...params2, method: "cardanoComposeTransaction" }),
    cipherKeyValue: (params2) => call2({ ...params2, method: "cipherKeyValue" }),
    composeTransaction: (params2) => call2({ ...params2, method: "composeTransaction" }),
    ethereumGetAddress: (params2) => call2({
      ...params2,
      method: "ethereumGetAddress",
      useEventListener: eventEmitter.listenerCount(events_1$2.UI.ADDRESS_VALIDATION) > 0
    }),
    ethereumGetPublicKey: (params2) => call2({ ...params2, method: "ethereumGetPublicKey" }),
    ethereumSignMessage: (params2) => call2({ ...params2, method: "ethereumSignMessage" }),
    ethereumSignTransaction: (params2) => call2({ ...params2, method: "ethereumSignTransaction" }),
    ethereumSignTypedData: (params2) => call2({ ...params2, method: "ethereumSignTypedData" }),
    ethereumVerifyMessage: (params2) => call2({ ...params2, method: "ethereumVerifyMessage" }),
    getAccountDescriptor: (params2) => call2({ ...params2, method: "getAccountDescriptor" }),
    getAccountInfo: (params2) => call2({ ...params2, method: "getAccountInfo" }),
    getAddress: (params2) => call2({
      ...params2,
      method: "getAddress",
      useEventListener: eventEmitter.listenerCount(events_1$2.UI.ADDRESS_VALIDATION) > 0
    }),
    getDeviceState: (params2) => call2({ ...params2, method: "getDeviceState" }),
    getFeatures: (params2) => call2({ ...params2, method: "getFeatures" }),
    getFirmwareHash: (params2) => call2({ ...params2, method: "getFirmwareHash" }),
    getOwnershipId: (params2) => call2({ ...params2, method: "getOwnershipId" }),
    getOwnershipProof: (params2) => call2({ ...params2, method: "getOwnershipProof" }),
    getPublicKey: (params2) => call2({ ...params2, method: "getPublicKey" }),
    nemGetAddress: (params2) => call2({
      ...params2,
      method: "nemGetAddress",
      useEventListener: eventEmitter.listenerCount(events_1$2.UI.ADDRESS_VALIDATION) > 0
    }),
    nemSignTransaction: (params2) => call2({ ...params2, method: "nemSignTransaction" }),
    pushTransaction: (params2) => call2({ ...params2, method: "pushTransaction" }),
    rippleGetAddress: (params2) => call2({
      ...params2,
      method: "rippleGetAddress",
      useEventListener: eventEmitter.listenerCount(events_1$2.UI.ADDRESS_VALIDATION) > 0
    }),
    rippleSignTransaction: (params2) => call2({ ...params2, method: "rippleSignTransaction" }),
    signMessage: (params2) => call2({ ...params2, method: "signMessage" }),
    signTransaction: (params2) => call2({ ...params2, method: "signTransaction" }),
    solanaGetPublicKey: (params2) => call2({ ...params2, method: "solanaGetPublicKey" }),
    solanaGetAddress: (params2) => call2({ ...params2, method: "solanaGetAddress" }),
    solanaSignTransaction: (params2) => call2({ ...params2, method: "solanaSignTransaction" }),
    stellarGetAddress: (params2) => call2({
      ...params2,
      method: "stellarGetAddress",
      useEventListener: eventEmitter.listenerCount(events_1$2.UI.ADDRESS_VALIDATION) > 0
    }),
    stellarSignTransaction: (params2) => call2({ ...params2, method: "stellarSignTransaction" }),
    tezosGetAddress: (params2) => call2({
      ...params2,
      method: "tezosGetAddress",
      useEventListener: eventEmitter.listenerCount(events_1$2.UI.ADDRESS_VALIDATION) > 0
    }),
    tezosGetPublicKey: (params2) => call2({ ...params2, method: "tezosGetPublicKey" }),
    tezosSignTransaction: (params2) => call2({ ...params2, method: "tezosSignTransaction" }),
    unlockPath: (params2) => call2({ ...params2, method: "unlockPath" }),
    eosGetPublicKey: (params2) => call2({ ...params2, method: "eosGetPublicKey" }),
    eosSignTransaction: (params2) => call2({ ...params2, method: "eosSignTransaction" }),
    binanceGetAddress: (params2) => call2({
      ...params2,
      method: "binanceGetAddress",
      useEventListener: eventEmitter.listenerCount(events_1$2.UI.ADDRESS_VALIDATION) > 0
    }),
    binanceGetPublicKey: (params2) => call2({ ...params2, method: "binanceGetPublicKey" }),
    binanceSignTransaction: (params2) => call2({ ...params2, method: "binanceSignTransaction" }),
    verifyMessage: (params2) => call2({ ...params2, method: "verifyMessage" }),
    resetDevice: (params2) => call2({ ...params2, method: "resetDevice" }),
    wipeDevice: (params2) => call2({ ...params2, method: "wipeDevice" }),
    checkFirmwareAuthenticity: (params2) => call2({ ...params2, method: "checkFirmwareAuthenticity" }),
    applyFlags: (params2) => call2({ ...params2, method: "applyFlags" }),
    applySettings: (params2) => call2({ ...params2, method: "applySettings" }),
    authenticateDevice: (params2) => call2({ ...params2, method: "authenticateDevice" }),
    authorizeCoinjoin: (params2) => call2({ ...params2, method: "authorizeCoinjoin" }),
    cancelCoinjoinAuthorization: (params2) => call2({ ...params2, method: "cancelCoinjoinAuthorization" }),
    showDeviceTutorial: (params2) => call2({ ...params2, method: "showDeviceTutorial" }),
    backupDevice: (params2) => call2({ ...params2, method: "backupDevice" }),
    changeLanguage: (params2) => call2({ ...params2, method: "changeLanguage" }),
    changePin: (params2) => call2({ ...params2, method: "changePin" }),
    changeWipeCode: (params2) => call2({ ...params2, method: "changeWipeCode" }),
    firmwareUpdate: (params2) => call2({ ...params2, method: "firmwareUpdate" }),
    recoveryDevice: (params2) => call2({ ...params2, method: "recoveryDevice" }),
    getCoinInfo: (params2) => call2({ ...params2, method: "getCoinInfo" }),
    rebootToBootloader: (params2) => call2({ ...params2, method: "rebootToBootloader" }),
    setBrightness: (params2) => call2({ ...params2, method: "setBrightness" }),
    setBusy: (params2) => call2({ ...params2, method: "setBusy" }),
    setProxy: (params2) => call2({ ...params2, method: "setProxy" }),
    dispose,
    cancel,
    renderWebUSBButton,
    disableWebUSB,
    requestWebUSBDevice
  };
  return api2;
};
factory$1.factory = factory;
var coreInIframe = {};
var debug = {};
var lib$4 = {};
var bufferUtils = {};
var hasRequiredBufferUtils;
function requireBufferUtils() {
  if (hasRequiredBufferUtils) return bufferUtils;
  hasRequiredBufferUtils = 1;
  Object.defineProperty(bufferUtils, "__esModule", { value: true });
  bufferUtils.getChunkSize = bufferUtils.reverseBuffer = void 0;
  const reverseBuffer = (src2) => {
    if (src2.length < 1)
      return src2;
    const buffer2 = Buffer$1.alloc(src2.length);
    let j = buffer2.length - 1;
    for (let i = 0; i < buffer2.length / 2; i++) {
      buffer2[i] = src2[j];
      buffer2[j] = src2[i];
      j--;
    }
    return buffer2;
  };
  bufferUtils.reverseBuffer = reverseBuffer;
  const getChunkSize = (n) => {
    const buf = Buffer$1.allocUnsafe(1);
    buf.writeUInt8(n);
    return buf;
  };
  bufferUtils.getChunkSize = getChunkSize;
  return bufferUtils;
}
var enumUtils = {};
var hasRequiredEnumUtils;
function requireEnumUtils() {
  if (hasRequiredEnumUtils) return enumUtils;
  hasRequiredEnumUtils = 1;
  Object.defineProperty(enumUtils, "__esModule", { value: true });
  enumUtils.getValueByKey = enumUtils.getKeyByValue = void 0;
  function getKeyByValue(obj, value) {
    return obj && Object.keys(obj).find((x2) => obj[x2] === value);
  }
  enumUtils.getKeyByValue = getKeyByValue;
  function getValueByKey(obj, enumKey) {
    const key = obj && Object.keys(obj).find((x2) => x2 === enumKey);
    return key && obj[key];
  }
  enumUtils.getValueByKey = getValueByKey;
  return enumUtils;
}
var versionUtils = {};
var hasRequiredVersionUtils;
function requireVersionUtils() {
  if (hasRequiredVersionUtils) return versionUtils;
  hasRequiredVersionUtils = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizeVersion = exports2.isNewerOrEqual = exports2.isEqual = exports2.isNewer = exports2.isVersionArray = void 0;
    const isVersionArray = (arr) => {
      if (!Array.isArray(arr)) {
        return false;
      }
      if (arr.length !== 3) {
        return false;
      }
      for (let i = 0; i < arr.length; i++) {
        const versionNumber = arr[i];
        if (typeof versionNumber !== "number" || versionNumber < 0) {
          return false;
        }
      }
      return true;
    };
    exports2.isVersionArray = isVersionArray;
    const parse2 = (versionArr) => ({
      major: versionArr[0],
      minor: versionArr[1],
      patch: versionArr[2]
    });
    const split = (version2) => {
      const arr = version2.split(".").map((v) => Number(v));
      if (!(0, exports2.isVersionArray)(arr)) {
        throw new Error(`version string is in wrong format: ${version2}`);
      }
      return arr;
    };
    const versionToString = (arr) => `${arr[0]}.${arr[1]}.${arr[2]}`;
    const isNewer = (versionX, versionY) => {
      const parsedX = parse2(typeof versionX === "string" ? split(versionX) : versionX);
      const parsedY = parse2(typeof versionY === "string" ? split(versionY) : versionY);
      if (parsedX.major - parsedY.major !== 0) {
        return parsedX.major > parsedY.major;
      }
      if (parsedX.minor - parsedY.minor !== 0) {
        return parsedX.minor > parsedY.minor;
      }
      if (parsedX.patch - parsedY.patch !== 0) {
        return parsedX.patch > parsedY.patch;
      }
      return false;
    };
    exports2.isNewer = isNewer;
    const isEqual = (versionX, versionY) => {
      const strX = typeof versionX === "string" ? versionX : versionToString(versionX);
      const strY = typeof versionY === "string" ? versionY : versionToString(versionY);
      return strX === strY;
    };
    exports2.isEqual = isEqual;
    const isNewerOrEqual = (versionX, versionY) => (0, exports2.isNewer)(versionX, versionY) || (0, exports2.isEqual)(versionX, versionY);
    exports2.isNewerOrEqual = isNewerOrEqual;
    const normalizeVersion = (version2) => version2.replace(/\b0+(\d)/g, "$1");
    exports2.normalizeVersion = normalizeVersion;
  })(versionUtils);
  return versionUtils;
}
var xssFilters = {};
var hasRequiredXssFilters;
function requireXssFilters() {
  if (hasRequiredXssFilters) return xssFilters;
  hasRequiredXssFilters = 1;
  Object.defineProperty(xssFilters, "__esModule", { value: true });
  xssFilters.inDoubleQuotes = xssFilters.inSingleQuotes = xssFilters.inHTML = void 0;
  const LT = /</g;
  const SQUOT = /'/g;
  const QUOT = /"/g;
  const inHTML = (value) => value.replace(LT, "&lt;");
  xssFilters.inHTML = inHTML;
  const inSingleQuotes = (value) => value.replace(SQUOT, "&#39;");
  xssFilters.inSingleQuotes = inSingleQuotes;
  const inDoubleQuotes = (value) => value.replace(QUOT, "&quot;");
  xssFilters.inDoubleQuotes = inDoubleQuotes;
  return xssFilters;
}
var addDashesToSpaces = {};
var hasRequiredAddDashesToSpaces;
function requireAddDashesToSpaces() {
  if (hasRequiredAddDashesToSpaces) return addDashesToSpaces;
  hasRequiredAddDashesToSpaces = 1;
  Object.defineProperty(addDashesToSpaces, "__esModule", { value: true });
  addDashesToSpaces.addDashesToSpaces = void 0;
  const addDashesToSpaces$1 = (inputString) => inputString.replace(/\s+/g, "-");
  addDashesToSpaces.addDashesToSpaces = addDashesToSpaces$1;
  return addDashesToSpaces;
}
var arrayDistinct = {};
var hasRequiredArrayDistinct;
function requireArrayDistinct() {
  if (hasRequiredArrayDistinct) return arrayDistinct;
  hasRequiredArrayDistinct = 1;
  Object.defineProperty(arrayDistinct, "__esModule", { value: true });
  arrayDistinct.arrayDistinct = void 0;
  const arrayDistinct$1 = (item, index, self2) => self2.indexOf(item) === index;
  arrayDistinct.arrayDistinct = arrayDistinct$1;
  return arrayDistinct;
}
var arrayPartition = {};
var hasRequiredArrayPartition;
function requireArrayPartition() {
  if (hasRequiredArrayPartition) return arrayPartition;
  hasRequiredArrayPartition = 1;
  Object.defineProperty(arrayPartition, "__esModule", { value: true });
  arrayPartition.arrayPartition = void 0;
  const arrayPartition$1 = (array, condition) => array.reduce(([pass, fail], elem) => condition(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]], [[], []]);
  arrayPartition.arrayPartition = arrayPartition$1;
  return arrayPartition;
}
var arrayShuffle = {};
var hasRequiredArrayShuffle;
function requireArrayShuffle() {
  if (hasRequiredArrayShuffle) return arrayShuffle;
  hasRequiredArrayShuffle = 1;
  Object.defineProperty(arrayShuffle, "__esModule", { value: true });
  arrayShuffle.arrayShuffle = void 0;
  const arrayShuffle$1 = (array) => {
    const shuffled = array.slice();
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  };
  arrayShuffle.arrayShuffle = arrayShuffle$1;
  return arrayShuffle;
}
var arrayToDictionary = {};
var hasRequiredArrayToDictionary;
function requireArrayToDictionary() {
  if (hasRequiredArrayToDictionary) return arrayToDictionary;
  hasRequiredArrayToDictionary = 1;
  Object.defineProperty(arrayToDictionary, "__esModule", { value: true });
  arrayToDictionary.arrayToDictionary = void 0;
  const validateKey = (key) => {
    if (["string", "number"].includes(typeof key)) {
      return true;
    }
    return false;
  };
  const arrayToDictionary$1 = (array, getKey, multiple) => multiple ? array.reduce((prev, cur) => {
    var _a;
    const key = getKey(cur);
    if (validateKey(key)) {
      return Object.assign(Object.assign({}, prev), { [key]: [...(_a = prev[key]) !== null && _a !== void 0 ? _a : [], cur] });
    }
    return prev;
  }, {}) : array.reduce((prev, cur) => {
    const key = getKey(cur);
    if (validateKey(key)) {
      return Object.assign(Object.assign({}, prev), { [key]: cur });
    }
    return prev;
  }, {});
  arrayToDictionary.arrayToDictionary = arrayToDictionary$1;
  return arrayToDictionary;
}
var bytesToHumanReadable = {};
var hasRequiredBytesToHumanReadable;
function requireBytesToHumanReadable() {
  if (hasRequiredBytesToHumanReadable) return bytesToHumanReadable;
  hasRequiredBytesToHumanReadable = 1;
  Object.defineProperty(bytesToHumanReadable, "__esModule", { value: true });
  bytesToHumanReadable.bytesToHumanReadable = void 0;
  const units = ["B", "KB", "MB", "GB", "TB"];
  const bytesToHumanReadable$1 = (bytes) => {
    let size = Math.abs(bytes);
    let i = 0;
    while (size >= 1024 || i >= units.length) {
      size /= 1024;
      i++;
    }
    return `${size.toFixed(1)} ${units[i]}`;
  };
  bytesToHumanReadable.bytesToHumanReadable = bytesToHumanReadable$1;
  return bytesToHumanReadable;
}
var capitalizeFirstLetter = {};
var hasRequiredCapitalizeFirstLetter;
function requireCapitalizeFirstLetter() {
  if (hasRequiredCapitalizeFirstLetter) return capitalizeFirstLetter;
  hasRequiredCapitalizeFirstLetter = 1;
  Object.defineProperty(capitalizeFirstLetter, "__esModule", { value: true });
  capitalizeFirstLetter.capitalizeFirstLetter = void 0;
  const capitalizeFirstLetter$1 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
  capitalizeFirstLetter.capitalizeFirstLetter = capitalizeFirstLetter$1;
  return capitalizeFirstLetter;
}
var cloneObject = {};
var hasRequiredCloneObject;
function requireCloneObject() {
  if (hasRequiredCloneObject) return cloneObject;
  hasRequiredCloneObject = 1;
  Object.defineProperty(cloneObject, "__esModule", { value: true });
  cloneObject.cloneObject = void 0;
  const cloneObject$1 = (obj) => {
    const jsonString = JSON.stringify(obj);
    if (jsonString === void 0) {
      return obj;
    }
    return JSON.parse(jsonString);
  };
  cloneObject.cloneObject = cloneObject$1;
  return cloneObject;
}
var countBytesInString = {};
var hasRequiredCountBytesInString;
function requireCountBytesInString() {
  if (hasRequiredCountBytesInString) return countBytesInString;
  hasRequiredCountBytesInString = 1;
  Object.defineProperty(countBytesInString, "__esModule", { value: true });
  countBytesInString.countBytesInString = void 0;
  const countBytesInString$1 = (input) => encodeURI(input).split(/%..|./).length - 1;
  countBytesInString.countBytesInString = countBytesInString$1;
  return countBytesInString;
}
var createCooldown = {};
var hasRequiredCreateCooldown;
function requireCreateCooldown() {
  if (hasRequiredCreateCooldown) return createCooldown;
  hasRequiredCreateCooldown = 1;
  Object.defineProperty(createCooldown, "__esModule", { value: true });
  createCooldown.createCooldown = void 0;
  const createCooldown$1 = (cooldownMs) => {
    let last2 = 0;
    return () => {
      const now = Date.now();
      if (now - last2 >= cooldownMs) {
        last2 = now;
        return true;
      }
      return false;
    };
  };
  createCooldown.createCooldown = createCooldown$1;
  return createCooldown;
}
var createDeferred = {};
var hasRequiredCreateDeferred;
function requireCreateDeferred() {
  if (hasRequiredCreateDeferred) return createDeferred;
  hasRequiredCreateDeferred = 1;
  Object.defineProperty(createDeferred, "__esModule", { value: true });
  createDeferred.createDeferred = void 0;
  const createDeferred$1 = (id2) => {
    let localResolve = () => {
    };
    let localReject = () => {
    };
    const promise = new Promise((resolve, reject) => {
      localResolve = resolve;
      localReject = reject;
    });
    return {
      id: id2,
      resolve: localResolve,
      reject: localReject,
      promise
    };
  };
  createDeferred.createDeferred = createDeferred$1;
  return createDeferred;
}
var createDeferredManager = {};
var hasRequiredCreateDeferredManager;
function requireCreateDeferredManager() {
  if (hasRequiredCreateDeferredManager) return createDeferredManager;
  hasRequiredCreateDeferredManager = 1;
  Object.defineProperty(createDeferredManager, "__esModule", { value: true });
  createDeferredManager.createDeferredManager = void 0;
  const createDeferred_1 = requireCreateDeferred();
  const createDeferredManager$1 = (options) => {
    const { initialId = 0, timeout: defaultTimeout = 0, onTimeout } = options !== null && options !== void 0 ? options : {};
    const promises = [];
    let ID = initialId;
    let timeoutHandle;
    const length = () => promises.length;
    const nextId = () => ID;
    const replanTimeout = () => {
      const now = Date.now();
      const nearestDeadline = promises.reduce((prev, { deadline }) => (prev && deadline ? Math.min : Math.max)(prev, deadline), 0);
      if (timeoutHandle)
        clearTimeout(timeoutHandle);
      timeoutHandle = nearestDeadline ? setTimeout(timeoutCallback, Math.max(nearestDeadline - now, 0)) : void 0;
    };
    const timeoutCallback = () => {
      const now = Date.now();
      promises.filter((promise) => promise.deadline && promise.deadline <= now).forEach((promise) => {
        onTimeout === null || onTimeout === void 0 ? void 0 : onTimeout(promise.id);
        promise.deadline = 0;
      });
      replanTimeout();
    };
    const create = (timeout = defaultTimeout) => {
      const promiseId = ID++;
      const deferred = (0, createDeferred_1.createDeferred)(promiseId);
      const deadline = timeout && Date.now() + timeout;
      promises.push(Object.assign(Object.assign({}, deferred), { deadline }));
      if (timeout)
        replanTimeout();
      return { promiseId, promise: deferred.promise };
    };
    const extract = (promiseId) => {
      const index = promises.findIndex(({ id: id2 }) => id2 === promiseId);
      const [promise] = index >= 0 ? promises.splice(index, 1) : [void 0];
      if (promise === null || promise === void 0 ? void 0 : promise.deadline)
        replanTimeout();
      return promise;
    };
    const resolve = (promiseId, value) => {
      const promise = extract(promiseId);
      promise === null || promise === void 0 ? void 0 : promise.resolve(value);
      return !!promise;
    };
    const reject = (promiseId, error) => {
      const promise = extract(promiseId);
      promise === null || promise === void 0 ? void 0 : promise.reject(error);
      return !!promise;
    };
    const rejectAll = (error) => {
      promises.forEach((promise) => promise.reject(error));
      const deleted = promises.splice(0, promises.length);
      if (deleted.length)
        replanTimeout();
    };
    return { length, nextId, create, resolve, reject, rejectAll };
  };
  createDeferredManager.createDeferredManager = createDeferredManager$1;
  return createDeferredManager;
}
var createTimeoutPromise = {};
var hasRequiredCreateTimeoutPromise;
function requireCreateTimeoutPromise() {
  if (hasRequiredCreateTimeoutPromise) return createTimeoutPromise;
  hasRequiredCreateTimeoutPromise = 1;
  Object.defineProperty(createTimeoutPromise, "__esModule", { value: true });
  createTimeoutPromise.createTimeoutPromise = void 0;
  const createTimeoutPromise$1 = (timeout) => new Promise((resolve) => setTimeout(resolve, timeout));
  createTimeoutPromise.createTimeoutPromise = createTimeoutPromise$1;
  return createTimeoutPromise;
}
var getLocaleSeparators = {};
var hasRequiredGetLocaleSeparators;
function requireGetLocaleSeparators() {
  if (hasRequiredGetLocaleSeparators) return getLocaleSeparators;
  hasRequiredGetLocaleSeparators = 1;
  Object.defineProperty(getLocaleSeparators, "__esModule", { value: true });
  getLocaleSeparators.getLocaleSeparators = void 0;
  const getLocaleSeparators$1 = (locale) => {
    var _a, _b;
    const numberFormat = new Intl.NumberFormat(locale);
    const parts = numberFormat.formatToParts(10000.1);
    const decimalSeparator = (_a = parts.find(({ type: type2 }) => type2 === "decimal")) === null || _a === void 0 ? void 0 : _a.value;
    const thousandsSeparator = (_b = parts.find(({ type: type2 }) => type2 === "group")) === null || _b === void 0 ? void 0 : _b.value;
    return { decimalSeparator, thousandsSeparator };
  };
  getLocaleSeparators.getLocaleSeparators = getLocaleSeparators$1;
  return getLocaleSeparators;
}
var getNumberFromPixelString = {};
var hasRequiredGetNumberFromPixelString;
function requireGetNumberFromPixelString() {
  if (hasRequiredGetNumberFromPixelString) return getNumberFromPixelString;
  hasRequiredGetNumberFromPixelString = 1;
  Object.defineProperty(getNumberFromPixelString, "__esModule", { value: true });
  getNumberFromPixelString.getNumberFromPixelString = void 0;
  const getNumberFromPixelString$1 = (size) => parseInt(size.replace("px", ""), 10);
  getNumberFromPixelString.getNumberFromPixelString = getNumberFromPixelString$1;
  return getNumberFromPixelString;
}
var getRandomNumberInRange = {};
var hasRequiredGetRandomNumberInRange;
function requireGetRandomNumberInRange() {
  if (hasRequiredGetRandomNumberInRange) return getRandomNumberInRange;
  hasRequiredGetRandomNumberInRange = 1;
  Object.defineProperty(getRandomNumberInRange, "__esModule", { value: true });
  getRandomNumberInRange.getRandomNumberInRange = void 0;
  const getRandomNumberInRange$1 = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  getRandomNumberInRange.getRandomNumberInRange = getRandomNumberInRange$1;
  return getRandomNumberInRange;
}
var getSynchronize = {};
var hasRequiredGetSynchronize;
function requireGetSynchronize() {
  if (hasRequiredGetSynchronize) return getSynchronize;
  hasRequiredGetSynchronize = 1;
  Object.defineProperty(getSynchronize, "__esModule", { value: true });
  getSynchronize.getSynchronize = void 0;
  const getSynchronize$1 = () => {
    let lock;
    return (action) => {
      const newLock = (lock !== null && lock !== void 0 ? lock : Promise.resolve()).catch(() => {
      }).then(action).finally(() => {
        if (lock === newLock) {
          lock = void 0;
        }
      });
      lock = newLock;
      return lock;
    };
  };
  getSynchronize.getSynchronize = getSynchronize$1;
  return getSynchronize;
}
var getWeakRandomId = {};
var hasRequiredGetWeakRandomId;
function requireGetWeakRandomId() {
  if (hasRequiredGetWeakRandomId) return getWeakRandomId;
  hasRequiredGetWeakRandomId = 1;
  Object.defineProperty(getWeakRandomId, "__esModule", { value: true });
  getWeakRandomId.getWeakRandomId = void 0;
  const getWeakRandomId$1 = (length) => {
    let id2 = "";
    const list = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (let i = 0; i < length; i++) {
      id2 += list.charAt(Math.floor(Math.random() * list.length));
    }
    return id2;
  };
  getWeakRandomId.getWeakRandomId = getWeakRandomId$1;
  return getWeakRandomId;
}
var hasUppercaseLetter = {};
var hasRequiredHasUppercaseLetter;
function requireHasUppercaseLetter() {
  if (hasRequiredHasUppercaseLetter) return hasUppercaseLetter;
  hasRequiredHasUppercaseLetter = 1;
  Object.defineProperty(hasUppercaseLetter, "__esModule", { value: true });
  hasUppercaseLetter.hasUppercaseLetter = void 0;
  const HAS_UPPERCASE_LATER_REGEXP = new RegExp("^(.*[A-Z].*)$");
  const hasUppercaseLetter$1 = (value) => HAS_UPPERCASE_LATER_REGEXP.test(value);
  hasUppercaseLetter.hasUppercaseLetter = hasUppercaseLetter$1;
  return hasUppercaseLetter;
}
var isAscii = {};
var hasRequiredIsAscii;
function requireIsAscii() {
  if (hasRequiredIsAscii) return isAscii;
  hasRequiredIsAscii = 1;
  Object.defineProperty(isAscii, "__esModule", { value: true });
  isAscii.isAscii = void 0;
  function isAscii$12(value) {
    if (!value)
      return true;
    return /^[\x00-\x7F]*$/.test(value);
  }
  isAscii.isAscii = isAscii$12;
  return isAscii;
}
var isHex = {};
var hasRequiredIsHex;
function requireIsHex() {
  if (hasRequiredIsHex) return isHex;
  hasRequiredIsHex = 1;
  Object.defineProperty(isHex, "__esModule", { value: true });
  isHex.isHex = void 0;
  const isHex$1 = (str) => {
    const regExp = /^(0x|0X)?[0-9A-Fa-f]+$/g;
    return regExp.test(str);
  };
  isHex.isHex = isHex$1;
  return isHex;
}
var isNotUndefined = {};
var hasRequiredIsNotUndefined;
function requireIsNotUndefined() {
  if (hasRequiredIsNotUndefined) return isNotUndefined;
  hasRequiredIsNotUndefined = 1;
  Object.defineProperty(isNotUndefined, "__esModule", { value: true });
  isNotUndefined.isNotUndefined = void 0;
  const isNotUndefined$1 = (item) => typeof item !== "undefined";
  isNotUndefined.isNotUndefined = isNotUndefined$1;
  return isNotUndefined;
}
var isUrl = {};
var hasRequiredIsUrl;
function requireIsUrl() {
  if (hasRequiredIsUrl) return isUrl;
  hasRequiredIsUrl = 1;
  Object.defineProperty(isUrl, "__esModule", { value: true });
  isUrl.isUrl = void 0;
  const URL_REGEXP = /^(http|ws)s?:\/\/[a-z0-9]([a-z0-9.-]+)?(:[0-9]{1,5})?((\/)?(([a-z0-9-_])+(\/)?)+)$/i;
  const isUrl$1 = (value) => URL_REGEXP.test(value);
  isUrl.isUrl = isUrl$1;
  return isUrl;
}
var mergeDeepObject = {};
var hasRequiredMergeDeepObject;
function requireMergeDeepObject() {
  if (hasRequiredMergeDeepObject) return mergeDeepObject;
  hasRequiredMergeDeepObject = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeepObject = void 0;
    const isObject2 = (obj) => {
      if (typeof obj === "object" && obj !== null) {
        if (typeof Object.getPrototypeOf === "function") {
          const prototype = Object.getPrototypeOf(obj);
          return prototype === Object.prototype || prototype === null;
        }
        return Object.prototype.toString.call(obj) === "[object Object]";
      }
      return false;
    };
    const mergeValuesWithPath = (target, value, [key, ...rest]) => {
      if (key === void 0) {
        return mergeValues(target, value);
      } else if (!isObject2(target)) {
        return { [key]: mergeValuesWithPath({}, value, rest) };
      } else {
        return Object.assign(Object.assign({}, target), { [key]: mergeValuesWithPath(target[key], value, rest) });
      }
    };
    const mergeValues = (target, value) => {
      if (Array.isArray(target) && Array.isArray(value)) {
        return exports2.mergeDeepObject.options.mergeArrays ? Array.from(new Set(target.concat(value))) : value;
      } else if (isObject2(target) && isObject2(value)) {
        return (0, exports2.mergeDeepObject)(target, value);
      } else {
        return value;
      }
    };
    const mergeDeepObject2 = (...objects) => objects.reduce((result, current) => {
      if (Array.isArray(current)) {
        throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
      }
      Object.keys(current).forEach((key) => {
        if (["__proto__", "constructor", "prototype"].includes(key)) {
          return;
        }
        if (exports2.mergeDeepObject.options.dotNotation) {
          const [first2, ...rest] = key.split(".");
          result[first2] = mergeValuesWithPath(result[first2], current[key], rest);
        } else {
          result[key] = mergeValues(result[key], current[key]);
        }
      });
      return result;
    }, {});
    exports2.mergeDeepObject = mergeDeepObject2;
    const defaultOptions = {
      mergeArrays: true,
      dotNotation: false
    };
    exports2.mergeDeepObject.options = defaultOptions;
    exports2.mergeDeepObject.withOptions = (options, ...objects) => {
      exports2.mergeDeepObject.options = Object.assign(Object.assign({}, defaultOptions), options);
      const result = (0, exports2.mergeDeepObject)(...objects);
      exports2.mergeDeepObject.options = defaultOptions;
      return result;
    };
  })(mergeDeepObject);
  return mergeDeepObject;
}
var objectPartition = {};
var hasRequiredObjectPartition;
function requireObjectPartition() {
  if (hasRequiredObjectPartition) return objectPartition;
  hasRequiredObjectPartition = 1;
  Object.defineProperty(objectPartition, "__esModule", { value: true });
  objectPartition.objectPartition = void 0;
  const tslib_12 = require$$0;
  const objectPartition$1 = (obj, keys) => keys.reduce(([included, excluded], key) => {
    const _a = excluded, _b = key, value = _a[_b], rest = tslib_12.__rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
    return typeof value !== "undefined" ? [Object.assign(Object.assign({}, included), { [key]: value }), rest] : [included, excluded];
  }, [{}, obj]);
  objectPartition.objectPartition = objectPartition$1;
  return objectPartition;
}
var parseElectrumUrl = {};
var hasRequiredParseElectrumUrl;
function requireParseElectrumUrl() {
  if (hasRequiredParseElectrumUrl) return parseElectrumUrl;
  hasRequiredParseElectrumUrl = 1;
  Object.defineProperty(parseElectrumUrl, "__esModule", { value: true });
  parseElectrumUrl.parseElectrumUrl = void 0;
  const ELECTRUM_URL_REGEX = /^(?:([a-zA-Z0-9.-]+)|\[([a-f0-9:]+)\]):([0-9]{1,5}):([ts])$/;
  const parseElectrumUrl$1 = (url) => {
    var _a;
    const match = url.match(ELECTRUM_URL_REGEX);
    if (!match)
      return void 0;
    return {
      host: (_a = match[1]) !== null && _a !== void 0 ? _a : match[2],
      port: Number.parseInt(match[3], 10),
      protocol: match[4]
    };
  };
  parseElectrumUrl.parseElectrumUrl = parseElectrumUrl$1;
  return parseElectrumUrl;
}
var parseHostname = {};
var hasRequiredParseHostname;
function requireParseHostname() {
  if (hasRequiredParseHostname) return parseHostname;
  hasRequiredParseHostname = 1;
  Object.defineProperty(parseHostname, "__esModule", { value: true });
  parseHostname.parseHostname = void 0;
  const HOSTNAME_REGEX = /^([a-z0-9.+-]+:\/\/)?([a-z0-9.-]+)([:/][^:/]+)*\/?$/i;
  const parseHostname$1 = (url) => {
    var _a, _b;
    return (_b = (_a = url.match(HOSTNAME_REGEX)) === null || _a === void 0 ? void 0 : _a[2]) === null || _b === void 0 ? void 0 : _b.toLowerCase();
  };
  parseHostname.parseHostname = parseHostname$1;
  return parseHostname;
}
var promiseAllSequence = {};
var hasRequiredPromiseAllSequence;
function requirePromiseAllSequence() {
  if (hasRequiredPromiseAllSequence) return promiseAllSequence;
  hasRequiredPromiseAllSequence = 1;
  Object.defineProperty(promiseAllSequence, "__esModule", { value: true });
  promiseAllSequence.promiseAllSequence = void 0;
  const tslib_12 = require$$0;
  const promiseAllSequence$1 = (actions) => tslib_12.__awaiter(void 0, void 0, void 0, function* () {
    const results = [];
    for (let i = 0; i < actions.length; ++i) {
      const result = yield actions[i]();
      results.push(result);
    }
    return results;
  });
  promiseAllSequence.promiseAllSequence = promiseAllSequence$1;
  return promiseAllSequence;
}
var redactUserPath = {};
var hasRequiredRedactUserPath;
function requireRedactUserPath() {
  if (hasRequiredRedactUserPath) return redactUserPath;
  hasRequiredRedactUserPath = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.redactUserPathFromString = exports2.startOfUserPathRegex = void 0;
    exports2.startOfUserPathRegex = /([/\\][Uu]sers[/\\]{1,4})([^"^'^[^\]^/^\\]*)/g;
    const redactUserPathFromString = (text) => text.replace(exports2.startOfUserPathRegex, "$1[*]");
    exports2.redactUserPathFromString = redactUserPathFromString;
  })(redactUserPath);
  return redactUserPath;
}
var scheduleAction = {};
var hasRequiredScheduleAction;
function requireScheduleAction() {
  if (hasRequiredScheduleAction) return scheduleAction;
  hasRequiredScheduleAction = 1;
  Object.defineProperty(scheduleAction, "__esModule", { value: true });
  scheduleAction.scheduleAction = void 0;
  const tslib_12 = require$$0;
  const isArray = (attempts) => Array.isArray(attempts);
  const abortedBySignal = () => new Error("Aborted by signal");
  const abortedByDeadline = () => new Error("Aborted by deadline");
  const abortedByTimeout = () => new Error("Aborted by timeout");
  const resolveAfterMs = (ms, clear) => new Promise((resolve, reject) => {
    if (clear.aborted)
      return reject();
    if (ms === void 0)
      return resolve();
    const timeout = setTimeout(resolve, ms);
    const onClear = () => {
      clearTimeout(timeout);
      clear.removeEventListener("abort", onClear);
      reject();
    };
    clear.addEventListener("abort", onClear);
  });
  const rejectAfterMs = (ms, reason, clear) => new Promise((_, reject) => {
    if (clear.aborted)
      return reject();
    const timeout = ms !== void 0 ? setTimeout(() => reject(reason()), ms) : void 0;
    const onClear = () => {
      clearTimeout(timeout);
      clear.removeEventListener("abort", onClear);
      reject();
    };
    clear.addEventListener("abort", onClear);
  });
  const rejectWhenAborted = (signal, clear) => new Promise((_, reject) => {
    if (clear.aborted)
      return reject();
    if (signal === null || signal === void 0 ? void 0 : signal.aborted)
      return reject(abortedBySignal());
    const onAbort = () => reject(abortedBySignal());
    signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", onAbort);
    const onClear = () => {
      signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", onAbort);
      clear.removeEventListener("abort", onClear);
      reject();
    };
    clear.addEventListener("abort", onClear);
  });
  const resolveAction = (action, clear) => tslib_12.__awaiter(void 0, void 0, void 0, function* () {
    const aborter = new AbortController();
    const onClear = () => aborter.abort();
    if (clear.aborted)
      onClear();
    clear.addEventListener("abort", onClear);
    try {
      return yield new Promise((resolve) => resolve(action(aborter.signal)));
    } finally {
      clear.removeEventListener("abort", onClear);
    }
  });
  const attemptLoop = (attempts, attempt, failure, clear) => tslib_12.__awaiter(void 0, void 0, void 0, function* () {
    for (let a = 0; a < attempts - 1; a++) {
      if (clear.aborted)
        break;
      const aborter = new AbortController();
      const onClear = () => aborter.abort();
      clear.addEventListener("abort", onClear);
      try {
        return yield attempt(a, aborter.signal);
      } catch (_a) {
        onClear();
        yield failure(a);
      } finally {
        clear.removeEventListener("abort", onClear);
      }
    }
    return clear.aborted ? Promise.reject() : attempt(attempts - 1, clear);
  });
  const scheduleAction$1 = (action, params2) => tslib_12.__awaiter(void 0, void 0, void 0, function* () {
    const { signal, delay, attempts, timeout, deadline, gap } = params2;
    const deadlineMs = deadline && deadline - Date.now();
    const attemptCount = isArray(attempts) ? attempts.length : attempts !== null && attempts !== void 0 ? attempts : deadline ? Infinity : 1;
    const clearAborter = new AbortController();
    const clear = clearAborter.signal;
    const getParams = isArray(attempts) ? (attempt) => attempts[attempt] : () => ({ timeout, gap });
    try {
      return yield Promise.race([
        rejectWhenAborted(signal, clear),
        rejectAfterMs(deadlineMs, abortedByDeadline, clear),
        resolveAfterMs(delay, clear).then(() => attemptLoop(attemptCount, (attempt, abort) => Promise.race([
          rejectAfterMs(getParams(attempt).timeout, abortedByTimeout, clear),
          resolveAction(action, abort)
        ]), (attempt) => {
          var _a;
          return resolveAfterMs((_a = getParams(attempt).gap) !== null && _a !== void 0 ? _a : 0, clear);
        }, clear))
      ]);
    } finally {
      clearAborter.abort();
    }
  });
  scheduleAction.scheduleAction = scheduleAction$1;
  return scheduleAction;
}
var splitStringEveryNCharacters = {};
var hasRequiredSplitStringEveryNCharacters;
function requireSplitStringEveryNCharacters() {
  if (hasRequiredSplitStringEveryNCharacters) return splitStringEveryNCharacters;
  hasRequiredSplitStringEveryNCharacters = 1;
  Object.defineProperty(splitStringEveryNCharacters, "__esModule", { value: true });
  splitStringEveryNCharacters.splitStringEveryNCharacters = void 0;
  function splitStringEveryNCharacters$1(value, n) {
    var _a;
    if (n === 0) {
      return [];
    }
    const regex = new RegExp(`.{1,${n}}`, "g");
    return (_a = value.match(regex)) !== null && _a !== void 0 ? _a : [];
  }
  splitStringEveryNCharacters.splitStringEveryNCharacters = splitStringEveryNCharacters$1;
  return splitStringEveryNCharacters;
}
var throwError = {};
var hasRequiredThrowError;
function requireThrowError() {
  if (hasRequiredThrowError) return throwError;
  hasRequiredThrowError = 1;
  Object.defineProperty(throwError, "__esModule", { value: true });
  throwError.throwError = void 0;
  const throwError$1 = (reason) => {
    throw new Error(reason);
  };
  throwError.throwError = throwError$1;
  return throwError;
}
var topologicalSort = {};
var hasRequiredTopologicalSort;
function requireTopologicalSort() {
  if (hasRequiredTopologicalSort) return topologicalSort;
  hasRequiredTopologicalSort = 1;
  Object.defineProperty(topologicalSort, "__esModule", { value: true });
  topologicalSort.topologicalSort = void 0;
  const arrayPartition_1 = requireArrayPartition();
  const topologicalSort$1 = (elements, precedes, tie) => {
    const result = [];
    const filterRoots = (verts) => (0, arrayPartition_1.arrayPartition)(verts, (succ) => !verts.some((pred) => precedes(pred, succ)));
    let elem = elements;
    while (elem.length) {
      const [roots2, rest] = filterRoots(elem);
      if (!roots2.length)
        throw new Error("Cycle detected");
      result.push(...tie ? roots2.sort(tie) : roots2);
      elem = rest;
    }
    return result;
  };
  topologicalSort.topologicalSort = topologicalSort$1;
  return topologicalSort;
}
var truncateMiddle = {};
var hasRequiredTruncateMiddle;
function requireTruncateMiddle() {
  if (hasRequiredTruncateMiddle) return truncateMiddle;
  hasRequiredTruncateMiddle = 1;
  Object.defineProperty(truncateMiddle, "__esModule", { value: true });
  truncateMiddle.truncateMiddle = void 0;
  const truncateMiddle$1 = (text, startChars, endChars) => {
    if (text.length <= startChars + endChars)
      return text;
    const start = text.substring(0, startChars);
    const end = text.substring(text.length - endChars, text.length);
    return `${start}…${end}`;
  };
  truncateMiddle.truncateMiddle = truncateMiddle$1;
  return truncateMiddle;
}
var typedEventEmitter = {};
var hasRequiredTypedEventEmitter;
function requireTypedEventEmitter() {
  if (hasRequiredTypedEventEmitter) return typedEventEmitter;
  hasRequiredTypedEventEmitter = 1;
  Object.defineProperty(typedEventEmitter, "__esModule", { value: true });
  typedEventEmitter.TypedEmitter = void 0;
  const events_12 = eventsExports;
  class TypedEmitter extends events_12.EventEmitter {
    listenerCount(eventName) {
      return super.listenerCount(eventName);
    }
  }
  typedEventEmitter.TypedEmitter = TypedEmitter;
  return typedEventEmitter;
}
var urlToOnion = {};
var hasRequiredUrlToOnion;
function requireUrlToOnion() {
  if (hasRequiredUrlToOnion) return urlToOnion;
  hasRequiredUrlToOnion = 1;
  Object.defineProperty(urlToOnion, "__esModule", { value: true });
  urlToOnion.urlToOnion = void 0;
  const urlToOnion$1 = (url, onionDomains) => {
    var _a;
    const [, protocol, subdomain, domain, rest] = (_a = url.match(/^(http|ws)s?:\/\/([^:/]+\.)?([^/.]+\.[^/.]+)(\/.*)?$/i)) !== null && _a !== void 0 ? _a : [];
    if (!domain || !onionDomains[domain])
      return;
    return `${protocol}://${subdomain !== null && subdomain !== void 0 ? subdomain : ""}${onionDomains[domain]}${rest !== null && rest !== void 0 ? rest : ""}`;
  };
  urlToOnion.urlToOnion = urlToOnion$1;
  return urlToOnion;
}
var logs = {};
var hasRequiredLogs;
function requireLogs() {
  if (hasRequiredLogs) return logs;
  hasRequiredLogs = 1;
  Object.defineProperty(logs, "__esModule", { value: true });
  logs.Log = void 0;
  class Log {
    constructor(prefix, enabled, logWriter) {
      this.css = "";
      this.MAX_ENTRIES = 100;
      this.prefix = prefix;
      this.enabled = enabled;
      this.messages = [];
      if (logWriter) {
        this.logWriter = logWriter;
      }
    }
    setColors(colors) {
      this.css = typeof window !== "undefined" && colors[this.prefix] ? colors[this.prefix] : "";
    }
    addMessage({ level, prefix, timestamp }, ...args) {
      const message2 = {
        level,
        prefix,
        css: this.css,
        message: args,
        timestamp: timestamp || Date.now()
      };
      this.messages.push(message2);
      if (this.logWriter) {
        try {
          this.logWriter.add(message2);
        } catch (err) {
          console.error("There was an error adding log message", err, message2);
        }
      }
      if (this.messages.length > this.MAX_ENTRIES) {
        this.messages.shift();
      }
    }
    setWriter(logWriter) {
      this.logWriter = logWriter;
    }
    log(...args) {
      this.addMessage({ level: "log", prefix: this.prefix }, ...args);
      if (this.enabled) {
        console.log(`%c${this.prefix}`, this.css, ...args);
      }
    }
    error(...args) {
      this.addMessage({ level: "error", prefix: this.prefix }, ...args);
      if (this.enabled) {
        console.error(`%c${this.prefix}`, this.css, ...args);
      }
    }
    info(...args) {
      this.addMessage({ level: "info", prefix: this.prefix }, ...args);
      if (this.enabled) {
        console.info(`%c${this.prefix}`, this.css, ...args);
      }
    }
    warn(...args) {
      this.addMessage({ level: "warn", prefix: this.prefix }, ...args);
      if (this.enabled) {
        console.warn(`%c${this.prefix}`, this.css, ...args);
      }
    }
    debug(...args) {
      this.addMessage({ level: "debug", prefix: this.prefix }, ...args);
      if (this.enabled) {
        if (this.css) {
          console.log(`%c${this.prefix}`, this.css, ...args);
        } else {
          console.log(this.prefix, ...args);
        }
      }
    }
    getLog() {
      return this.messages;
    }
  }
  logs.Log = Log;
  return logs;
}
var logsManager = {};
var hasRequiredLogsManager;
function requireLogsManager() {
  if (hasRequiredLogsManager) return logsManager;
  hasRequiredLogsManager = 1;
  Object.defineProperty(logsManager, "__esModule", { value: true });
  logsManager.LogsManager = void 0;
  const logs_1 = requireLogs();
  class LogsManager {
    constructor({ colors }) {
      this.logs = {};
      this.colors = {};
      this.colors = colors;
    }
    initLog(prefix, enabled, logWriter) {
      const instanceWriter = logWriter || this.writer;
      const instance = new logs_1.Log(prefix, !!enabled, instanceWriter);
      if (this.colors) {
        instance.setColors(this.colors);
      }
      this.logs[prefix] = instance;
      return instance;
    }
    setLogWriter(logWriterFactory) {
      Object.keys(this.logs).forEach((key) => {
        this.writer = logWriterFactory();
        if (this.writer) {
          this.logs[key].setWriter(this.writer);
          const { messages: messages2 } = this.logs[key];
          messages2.forEach((message2) => {
            var _a;
            (_a = this.writer) === null || _a === void 0 ? void 0 : _a.add(message2);
          });
        }
      });
    }
    enableLog(enabled) {
      Object.keys(this.logs).forEach((key) => {
        this.logs[key].enabled = !!enabled;
      });
    }
    enableLogByPrefix(prefix, enabled) {
      if (this.logs[prefix]) {
        this.logs[prefix].enabled = enabled;
      }
    }
    getLog() {
      let logs2 = [];
      Object.keys(this.logs).forEach((key) => {
        logs2 = logs2.concat(this.logs[key].messages);
      });
      logs2.sort((a, b) => a.timestamp - b.timestamp);
      return logs2;
    }
  }
  logsManager.LogsManager = LogsManager;
  return logsManager;
}
var bigNumber = {};
var hasRequiredBigNumber;
function requireBigNumber() {
  if (hasRequiredBigNumber) return bigNumber;
  hasRequiredBigNumber = 1;
  Object.defineProperty(bigNumber, "__esModule", { value: true });
  bigNumber.BigNumber = void 0;
  const tslib_12 = require$$0;
  const bignumber_js_1 = tslib_12.__importDefault(bignumberExports);
  bigNumber.BigNumber = bignumber_js_1.default.clone({
    EXPONENTIAL_AT: 1e9
  });
  return bigNumber;
}
var throttler = {};
var hasRequiredThrottler;
function requireThrottler() {
  if (hasRequiredThrottler) return throttler;
  hasRequiredThrottler = 1;
  Object.defineProperty(throttler, "__esModule", { value: true });
  throttler.Throttler = void 0;
  class Throttler {
    constructor(delay) {
      this.delay = delay;
      this.intervals = {};
      this.callbacks = {};
    }
    throttle(id2, callback) {
      if (this.intervals[id2]) {
        this.callbacks[id2] = callback;
      } else {
        callback();
        this.intervals[id2] = setInterval(() => this.tick(id2), this.delay);
      }
    }
    tick(id2) {
      if (this.callbacks[id2]) {
        this.callbacks[id2]();
        delete this.callbacks[id2];
      } else {
        this.cancel(id2);
      }
    }
    cancel(id2) {
      clearInterval(this.intervals[id2]);
      delete this.intervals[id2];
      delete this.callbacks[id2];
    }
    dispose() {
      Object.keys(this.intervals).forEach(this.cancel, this);
    }
  }
  throttler.Throttler = Throttler;
  return throttler;
}
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$4;
  hasRequiredLib$4 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.xssFilters = exports2.versionUtils = exports2.enumUtils = exports2.bufferUtils = void 0;
    const tslib_12 = require$$0;
    exports2.bufferUtils = tslib_12.__importStar(requireBufferUtils());
    exports2.enumUtils = tslib_12.__importStar(requireEnumUtils());
    exports2.versionUtils = tslib_12.__importStar(requireVersionUtils());
    exports2.xssFilters = tslib_12.__importStar(requireXssFilters());
    tslib_12.__exportStar(requireAddDashesToSpaces(), exports2);
    tslib_12.__exportStar(requireArrayDistinct(), exports2);
    tslib_12.__exportStar(requireArrayPartition(), exports2);
    tslib_12.__exportStar(requireArrayShuffle(), exports2);
    tslib_12.__exportStar(requireArrayToDictionary(), exports2);
    tslib_12.__exportStar(requireBytesToHumanReadable(), exports2);
    tslib_12.__exportStar(requireCapitalizeFirstLetter(), exports2);
    tslib_12.__exportStar(requireCloneObject(), exports2);
    tslib_12.__exportStar(requireCountBytesInString(), exports2);
    tslib_12.__exportStar(requireCreateCooldown(), exports2);
    tslib_12.__exportStar(requireCreateDeferred(), exports2);
    tslib_12.__exportStar(requireCreateDeferredManager(), exports2);
    tslib_12.__exportStar(requireCreateTimeoutPromise(), exports2);
    tslib_12.__exportStar(requireGetLocaleSeparators(), exports2);
    tslib_12.__exportStar(requireGetNumberFromPixelString(), exports2);
    tslib_12.__exportStar(requireGetRandomNumberInRange(), exports2);
    tslib_12.__exportStar(requireGetSynchronize(), exports2);
    tslib_12.__exportStar(requireGetWeakRandomId(), exports2);
    tslib_12.__exportStar(requireHasUppercaseLetter(), exports2);
    tslib_12.__exportStar(requireIsAscii(), exports2);
    tslib_12.__exportStar(requireIsHex(), exports2);
    tslib_12.__exportStar(requireIsNotUndefined(), exports2);
    tslib_12.__exportStar(requireIsUrl(), exports2);
    tslib_12.__exportStar(requireMergeDeepObject(), exports2);
    tslib_12.__exportStar(requireObjectPartition(), exports2);
    tslib_12.__exportStar(requireParseElectrumUrl(), exports2);
    tslib_12.__exportStar(requireParseHostname(), exports2);
    tslib_12.__exportStar(requirePromiseAllSequence(), exports2);
    tslib_12.__exportStar(requireRedactUserPath(), exports2);
    tslib_12.__exportStar(requireScheduleAction(), exports2);
    tslib_12.__exportStar(requireSplitStringEveryNCharacters(), exports2);
    tslib_12.__exportStar(requireThrowError(), exports2);
    tslib_12.__exportStar(requireTopologicalSort(), exports2);
    tslib_12.__exportStar(requireTruncateMiddle(), exports2);
    tslib_12.__exportStar(requireTypedEventEmitter(), exports2);
    tslib_12.__exportStar(requireUrlToOnion(), exports2);
    tslib_12.__exportStar(requireLogs(), exports2);
    tslib_12.__exportStar(requireLogsManager(), exports2);
    tslib_12.__exportStar(requireBigNumber(), exports2);
    tslib_12.__exportStar(requireThrottler(), exports2);
  })(lib$4);
  return lib$4;
}
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug;
  hasRequiredDebug = 1;
  Object.defineProperty(debug, "__esModule", { value: true });
  debug.getLog = debug.enableLogByPrefix = debug.enableLog = debug.setLogWriter = debug.initLog = void 0;
  const utils_12 = requireLib$4();
  const green = "#bada55";
  const blue = "#20abd8";
  const orange = "#f4a744";
  const yellow = "#fbd948";
  const colors = {
    "@trezor/connect": `color: ${blue}; background: #000;`,
    "@trezor/connect-web": `color: ${blue}; background: #000;`,
    "@trezor/connect-webextension": `color: ${blue}; background: #000;`,
    IFrame: `color: ${orange}; background: #000;`,
    Core: `color: ${orange}; background: #000;`,
    DeviceList: `color: ${green}; background: #000;`,
    Device: `color: ${green}; background: #000;`,
    DeviceCommands: `color: ${green}; background: #000;`,
    "@trezor/transport": `color: ${green}; background: #000;`,
    InteractionTimeout: `color: ${green}; background: #000;`,
    "@trezor/connect-popup": `color: ${yellow}; background: #000;`
  };
  const logsManager2 = new utils_12.LogsManager({ colors });
  debug.initLog = logsManager2.initLog.bind(logsManager2);
  debug.setLogWriter = logsManager2.setLogWriter.bind(logsManager2);
  debug.enableLog = logsManager2.enableLog.bind(logsManager2);
  debug.enableLogByPrefix = logsManager2.enableLogByPrefix.bind(logsManager2);
  debug.getLog = logsManager2.getLog.bind(logsManager2);
  return debug;
}
var config = {};
var hasRequiredConfig;
function requireConfig() {
  if (hasRequiredConfig) return config;
  hasRequiredConfig = 1;
  Object.defineProperty(config, "__esModule", { value: true });
  config.config = void 0;
  const constants_12 = requireConstants$1();
  config.config = {
    webusb: constants_12.TREZOR_USB_DESCRIPTORS,
    whitelist: [
      { origin: "chrome-extension://imloifkgjagghnncjkhggdhalmcnfklk", priority: 1 },
      { origin: "chrome-extension://niebkpllfhmpfbffbfifagfgoamhpflf", priority: 1 },
      { origin: "file://", priority: 2 },
      { origin: "trezor.io", priority: 0 },
      { origin: "sldev.cz", priority: 0 },
      { origin: "localhost", priority: 0 },
      { origin: "trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad.onion", priority: 0 }
    ],
    management: [{ origin: "trezor.io" }, { origin: "sldev.cz" }, { origin: "localhost" }],
    knownHosts: [
      {
        origin: "imloifkgjagghnncjkhggdhalmcnfklk",
        label: "Trezor Password Manager (Develop)",
        icon: ""
      },
      { origin: "niebkpllfhmpfbffbfifagfgoamhpflf", label: "Trezor Password Manager", icon: "" },
      {
        origin: "mnpfhpndmjholfdlhpkjfmjkgppmodaf",
        label: "MetaMask",
        icon: ""
      },
      {
        origin: "webextension@metamask.io",
        label: "MetaMask",
        icon: ""
      },
      {
        origin: "nkbihfbeogaeaoehlefnkodbefgpgknn",
        label: "MetaMask",
        icon: ""
      },
      {
        origin: "bpcdaglidgnlggelgbjfagekoapjmccp",
        label: "Rainbow DEV",
        icon: ""
      },
      {
        origin: "opfgelmcmbiajamepnmloijbpoleiama",
        label: "Rainbow",
        icon: ""
      },
      {
        origin: "acmacodkjbdgmoleebolmdjonilkdbch",
        label: "Rabby",
        icon: ""
      },
      { origin: "file://", label: " ", icon: "" }
    ],
    onionDomains: {
      "trezor.io": "trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad.onion"
    },
    assets: [
      {
        name: "coins",
        url: "./data/coins.json"
      },
      {
        name: "coinsEth",
        url: "./data/coins-eth.json"
      },
      {
        name: "bridge",
        url: "./data/bridge/releases.json"
      },
      {
        name: "firmware-t1b1",
        url: "./data/firmware/t1b1/releases.json"
      },
      {
        name: "firmware-t2t1",
        url: "./data/firmware/t2t1/releases.json"
      },
      {
        name: "firmware-t2b1",
        url: "./data/firmware/t2b1/releases.json"
      },
      {
        name: "firmware-t3t1",
        url: "./data/firmware/t3t1/releases.json"
      }
    ],
    messages: "./data/messages/messages.json",
    supportedBrowsers: {
      chrome: {
        version: 59,
        download: "https://www.google.com/chrome/",
        update: "https://support.google.com/chrome/answer/95414"
      },
      chromium: {
        version: 59,
        download: "https://www.chromium.org/",
        update: "https://www.chromium.org/"
      },
      electron: {
        version: 0,
        download: "https://www.electronjs.org/",
        update: "https://www.electronjs.org/"
      },
      firefox: {
        version: 54,
        download: "https://www.mozilla.org/en-US/firefox/new/",
        update: "https://support.mozilla.org/en-US/kb/update-firefox-latest-version"
      },
      brave: {
        version: 59,
        download: "https://brave.com/download/",
        update: "https://brave.com/download/"
      },
      edge: {
        version: 79,
        download: "https://www.microsoft.com/en-us/edge",
        update: "https://www.microsoft.com/en-us/edge"
      }
    },
    supportedFirmware: [
      {
        coin: ["xrp", "txrp"],
        methods: ["getAccountInfo"],
        min: { T1B1: "0", T2T1: "2.1.0" },
        max: void 0,
        comment: [
          "Since firmware 2.1.0 there is a new protobuf field 'destination_tag' in RippleSignTx"
        ]
      },
      {
        coin: ["bnb"],
        min: { T1B1: "1.9.0", T2T1: "2.3.0" },
        comment: [
          "There were protobuf backwards incompatible changes with introduction of 1.9.0/2.3.0 firmwares"
        ]
      },
      {
        coin: ["eth", "tsep", "thol"],
        min: { T1B1: "1.8.0", T2T1: "2.1.0" },
        comment: ["There were protobuf backwards incompatible changes."]
      },
      {
        coin: ["ada", "tada"],
        min: { T1B1: "0", T2T1: "2.4.3" },
        comment: ["Since 2.4.3 there is initialize.derive_cardano message"]
      },
      {
        methods: ["rippleGetAddress", "rippleSignTransaction"],
        min: { T1B1: "0", T2T1: "2.1.0" },
        comment: [
          "Since firmware 2.1.0 there is a new protobuf field 'destination_tag' in RippleSignTx"
        ]
      },
      {
        methods: ["cardanoGetAddress", "cardanoGetPublicKey"],
        min: { T1B1: "0", T2T1: "2.4.3" },
        comment: ["Since 2.4.3 Cardano derivation behavior has changed"]
      },
      {
        methods: ["cardanoSignTransaction"],
        min: { T1B1: "0", T2T1: "2.6.0" },
        comment: ["Before 2.6.0 not all Cardano transactions were supported"]
      },
      {
        methods: ["cardanoGetNativeScriptHash"],
        min: { T1B1: "0", T2T1: "2.4.3" },
        comment: ["Since 2.4.3 Cardano derivation behavior has changed"]
      },
      {
        methods: ["tezosSignTransaction"],
        min: { T1B1: "0", T2T1: "2.1.8" },
        comment: [
          "Since 2.1.8 there are new protobuf fields in tezos transaction (Babylon fork)"
        ]
      },
      {
        methods: ["stellarSignTransaction"],
        min: { T1B1: "1.9.0", T2T1: "2.3.0" },
        comment: [
          "There were protobuf backwards incompatible changes with introduction of 1.9.0/2.3.0 firmwares"
        ]
      },
      {
        capabilities: ["replaceTransaction", "amountUnit"],
        min: { T1B1: "1.9.4", T2T1: "2.3.5" },
        comment: ["new sign tx process since 1.9.4/2.3.5"]
      },
      {
        capabilities: ["decreaseOutput"],
        min: { T1B1: "1.10.0", T2T1: "2.4.0" },
        comment: ["allow reduce output in RBF transaction since 1.10.0/2.4.0"]
      },
      {
        capabilities: ["eip1559"],
        min: { T1B1: "1.10.4", T2T1: "2.4.2" },
        comment: ["new eth transaction pricing mechanism (EIP1559) since 1.10.4/2.4.2"]
      },
      {
        capabilities: ["taproot", "signMessageNoScriptType"],
        min: { T1B1: "1.10.4", T2T1: "2.4.3" },
        comment: [
          "new btc accounts taproot since 1.10.4/2.4.3 (BTC + TEST only)",
          "SignMessage with no_script_type support"
        ]
      },
      {
        coin: ["dcr", "tdcr"],
        methods: ["signTransaction"],
        min: { T1B1: "1.10.1", T2T1: "2.4.0" },
        comment: [""]
      },
      {
        methods: ["ethereumSignTypedData"],
        min: { T1B1: "1.10.5", T2T1: "2.4.3" },
        comment: ["EIP-712 typed signing support added in 1.10.5/2.4.3"]
      },
      {
        capabilities: ["eip712-domain-only"],
        min: { T1B1: "1.10.6", T2T1: "2.4.4" },
        comment: ["EIP-712 domain-only signing, when primaryType=EIP712Domain"]
      },
      {
        capabilities: ["coinjoin"],
        methods: [
          "authorizeCoinjoin",
          "cancelCoinjoinAuthorization",
          "getOwnershipId",
          "getOwnershipProof",
          "setBusy",
          "unlockPath"
        ],
        min: { T1B1: "1.12.1", T2T1: "2.5.3" }
      },
      {
        methods: ["showDeviceTutorial", "authenticateDevice"],
        min: { T1B1: "0", T2T1: "0", T2B1: "2.6.1" },
        comment: ["Only on T2B1"]
      },
      {
        methods: ["rebootToBootloader"],
        min: { T1B1: "1.10.0", T2T1: "2.6.0" }
      },
      {
        methods: ["getFirmwareHash"],
        min: { T1B1: "1.11.1", T2T1: "2.5.1" }
      },
      {
        methods: ["solanaGetPublicKey", "solanaGetAddress", "solanaSignTransaction"],
        min: { T1B1: "0", T2T1: "2.6.4", T2B1: "2.6.4" }
      },
      {
        capabilities: ["chunkify"],
        min: { T1B1: "0", T2T1: "2.6.3", T2B1: "2.6.3" },
        comment: [
          "Since firmware 2.6.3 there is a new protobuf field 'chunkify' in almost all getAddress and signTx methods"
        ]
      },
      {
        methods: ["changeLanguage"],
        min: { T1B1: "0", T2T1: "2.7.0", T2B1: "2.7.0", T3T1: "2.7.1" }
      }
    ]
  };
  return config;
}
var iframe$1 = {};
var urlUtils = {};
var hasRequiredUrlUtils;
function requireUrlUtils() {
  if (hasRequiredUrlUtils) return urlUtils;
  hasRequiredUrlUtils = 1;
  Object.defineProperty(urlUtils, "__esModule", { value: true });
  urlUtils.getOnionDomain = urlUtils.getHost = urlUtils.getOrigin = void 0;
  const utils_12 = requireLib$4();
  const getOrigin = (url) => {
    var _a;
    if (typeof url !== "string")
      return "unknown";
    if (url.indexOf("file://") === 0)
      return "file://";
    const [origin] = (_a = url.match(/^https?:\/\/[^/]+/)) !== null && _a !== void 0 ? _a : [];
    return origin !== null && origin !== void 0 ? origin : "unknown";
  };
  urlUtils.getOrigin = getOrigin;
  const getHost = (url) => {
    var _a;
    if (typeof url !== "string")
      return;
    const [, , uri] = (_a = url.match(/^(https?):\/\/([^:/]+)?/i)) !== null && _a !== void 0 ? _a : [];
    if (uri) {
      const parts = uri.split(".");
      return parts.length > 2 ? parts.slice(parts.length - 2, parts.length).join(".") : uri;
    }
  };
  urlUtils.getHost = getHost;
  const getOnionDomain = (url, dict) => {
    var _a;
    if (Array.isArray(url))
      return url.map((u) => {
        var _a2;
        return (_a2 = (0, utils_12.urlToOnion)(u, dict)) !== null && _a2 !== void 0 ? _a2 : u;
      });
    if (typeof url === "string")
      return (_a = (0, utils_12.urlToOnion)(url, dict)) !== null && _a !== void 0 ? _a : url;
    return url;
  };
  urlUtils.getOnionDomain = getOnionDomain;
  return urlUtils;
}
var inlineStyles = {};
var hasRequiredInlineStyles;
function requireInlineStyles() {
  if (hasRequiredInlineStyles) return inlineStyles;
  hasRequiredInlineStyles = 1;
  Object.defineProperty(inlineStyles, "__esModule", { value: true });
  const css = '.trezorconnect-container{position:fixed!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-orient:vertical!important;-webkit-box-direction:normal!important;-webkit-flex-direction:column!important;-ms-flex-direction:column!important;flex-direction:column!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important;z-index:10000!important;width:100%!important;height:100%!important;top:0!important;left:0!important;background:rgba(0,0,0,.35)!important;overflow:auto!important;padding:20px!important;margin:0!important}.trezorconnect-container .trezorconnect-window{position:relative!important;display:block!important;width:370px!important;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif!important;margin:auto!important;border-radius:3px!important;background-color:#fff!important;text-align:center!important;overflow:hidden!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head{text-align:left;padding:12px 24px!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-logo{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close{cursor:pointer!important;height:24px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close svg{fill:#757575;-webkit-transition:fill .3s ease-in-out!important;transition:fill .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close:hover svg{fill:#494949}.trezorconnect-container .trezorconnect-window .trezorconnect-body{padding:24px 24px 32px!important;background:#FBFBFB!important;border-top:1px solid #EBEBEB}.trezorconnect-container .trezorconnect-window .trezorconnect-body h3{color:#505050!important;font-size:16px!important;font-weight:500!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body p{margin:8px 0 24px!important;font-weight:400!important;color:#A9A9A9!important;font-size:12px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button{width:100%!important;padding:12px 24px!important;margin:0!important;border-radius:3px!important;font-size:14px!important;font-weight:300!important;cursor:pointer!important;background:#01B757!important;color:#fff!important;border:0!important;-webkit-transition:background-color .3s ease-in-out!important;transition:background-color .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:hover{background-color:#00AB51!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:active{background-color:#009546!important}/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlucHV0IiwiJHN0ZGluIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNBLHlCQUNJLFNBQUEsZ0JBQ0EsUUFBQSxzQkFDQSxRQUFBLHVCQUNBLFFBQUEsc0JBRUEsUUFBQSxlQUNBLG1CQUFBLG1CQUNBLHNCQUFBLGlCQUNBLHVCQUFBLGlCQUNBLG1CQUFBLGlCQUNBLGVBQUEsaUJBRUEsa0JBQUEsaUJBQ0Esb0JBQUEsaUJBQ0EsZUFBQSxpQkNmTSxZQUFhLGlCREFyQixRQUFTLGdCQWtCSCxNQUFBLGVBQ0EsT0FBQSxlQUNBLElBQUEsWUFDQSxLQUFBLFlBQ0EsV0FBQSwwQkFDQSxTQUFBLGVBQ0EsUUFBQSxlQUNBLE9BQUEsWUNkUiwrQ0RYRSxTQUFVLG1CQTZCQSxRQUFBLGdCQUNBLE1BQUEsZ0JBQ0EsWUFBQSxjQUFBLG1CQUFBLFdBQUEsT0FBQSxpQkFBQSxNQUFBLHFCQUNBLE9BQUEsZUNmVixjQUFlLGNEakJmLGlCQWlCRSxlQWtCWSxXQUFBLGlCQ2ZkLFNBQVUsaUJEbUJJLG1FQUNBLFdBQUEsS0NoQmQsUUFBUyxLQUFLLGVEeEJkLFFBQVMsc0JBMENTLFFBQUEsdUJBQ0EsUUFBQSxzQkNmbEIsUUFBUyxlRGlCSyxrQkE1QlosaUJBOEJvQixvQkFBQSxpQkNoQmxCLGVBQWdCLGlCRC9CWixZQWlCTixpQkFzQ1EsdUZBQ0EsaUJBQUEsRUNwQlYsYUFBYyxFRHBDVixTQUFVLEVBMkRBLEtBQUEsRUFFQSx3RkNwQmQsT0FBUSxrQkR6Q1IsT0FBUSxlQWlFTSw0RkFDQSxLQUFBLFFBQ0EsbUJBQUEsS0FBQSxJQUFBLHNCQ3BCZCxXQUFZLEtBQUssSUFBSyxzQkR3QlIsa0dBQ0EsS0FBQSxRQUVBLG1FQUNBLFFBQUEsS0FBQSxLQUFBLGVBQ0EsV0FBQSxrQkFDQSxXQUFBLElBQUEsTUFBQSxRQUVBLHNFQUNBLE1BQUEsa0JBQ0EsVUFBQSxlQ3JCZCxZQUFhLGNEd0JLLHFFQ3JCbEIsT0FBUSxJQUFJLEVBQUksZUR3QkYsWUFBQSxjQUNJLE1BQUEsa0JDdEJsQixVQUFXLGVBRWIsMEVBQ0UsTUFBTyxlQUNQLFFBQVMsS0FBSyxlQUNkLE9BQVEsWUFDUixjQUFlLGNBQ2YsVUFBVyxlQUNYLFlBQWEsY0FDYixPQUFRLGtCQUNSLFdBQVksa0JBQ1osTUFBTyxlQUNQLE9BQVEsWUFDUixtQkFBb0IsaUJBQWlCLElBQUssc0JBQzFDLFdBQVksaUJBQWlCLElBQUssc0JBRXBDLGdGQUNFLGlCQUFrQixrQkFFcEIsaUZBQ0UsaUJBQWtCIn0= */';
  inlineStyles.default = css;
  return inlineStyles;
}
var hasRequiredIframe;
function requireIframe() {
  if (hasRequiredIframe) return iframe$1;
  hasRequiredIframe = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initIframeLogger = exports2.clearTimeout = exports2.postMessage = exports2.init = exports2.dispose = exports2.error = exports2.timeout = exports2.initPromise = exports2.origin = exports2.instance = void 0;
    const tslib_12 = require$$0;
    const utils_12 = requireLib$4();
    const ERRORS2 = tslib_12.__importStar(requireErrors$3());
    const events_12 = events;
    const urlUtils_1 = requireUrlUtils();
    const debug_12 = requireDebug();
    const inlineStyles_1 = tslib_12.__importDefault(requireInlineStyles());
    exports2.initPromise = (0, utils_12.createDeferred)();
    exports2.timeout = 0;
    const dispose = () => {
      if (exports2.instance && exports2.instance.parentNode) {
        try {
          exports2.instance.parentNode.removeChild(exports2.instance);
        } catch (e) {
        }
      }
      exports2.instance = null;
      exports2.timeout = 0;
    };
    exports2.dispose = dispose;
    const handleIframeBlocked = () => {
      window.clearTimeout(exports2.timeout);
      exports2.error = ERRORS2.TypedError("Init_IframeBlocked");
      (0, exports2.dispose)();
      exports2.initPromise.reject(exports2.error);
    };
    const injectStyleSheet = () => {
      if (!exports2.instance) {
        throw ERRORS2.TypedError("Init_IframeBlocked");
      }
      const doc = exports2.instance.ownerDocument;
      const head = doc.head || doc.getElementsByTagName("head")[0];
      const style = document.createElement("style");
      style.setAttribute("type", "text/css");
      style.setAttribute("id", "TrezorConnectStylesheet");
      if (style.styleSheet) {
        style.styleSheet.cssText = inlineStyles_1.default;
        head.appendChild(style);
      } else {
        style.appendChild(document.createTextNode(inlineStyles_1.default));
        head.append(style);
      }
    };
    const init = async (settings2) => {
      exports2.initPromise = (0, utils_12.createDeferred)();
      const existedFrame = document.getElementById("trezorconnect");
      if (existedFrame) {
        exports2.instance = existedFrame;
      } else {
        exports2.instance = document.createElement("iframe");
        exports2.instance.frameBorder = "0";
        exports2.instance.width = "0px";
        exports2.instance.height = "0px";
        exports2.instance.style.position = "absolute";
        exports2.instance.style.display = "none";
        exports2.instance.style.border = "0px";
        exports2.instance.style.width = "0px";
        exports2.instance.style.height = "0px";
        exports2.instance.id = "trezorconnect";
      }
      let src2;
      if (settings2.env === "web") {
        const manifestString = settings2.manifest ? JSON.stringify(settings2.manifest) : "undefined";
        const manifest = `version=${settings2.version}&manifest=${encodeURIComponent(btoa(JSON.stringify(manifestString)))}`;
        src2 = `${settings2.iframeSrc}?${manifest}`;
      } else {
        src2 = settings2.iframeSrc;
      }
      exports2.instance.setAttribute("src", src2);
      if (settings2.webusb) {
        console.warn('webusb option is deprecated. use `transports: ["WebUsbTransport"] instead`');
      }
      if (navigator.usb) {
        exports2.instance.setAttribute("allow", "usb");
      }
      exports2.origin = (0, urlUtils_1.getOrigin)(exports2.instance.src);
      exports2.timeout = window.setTimeout(() => {
        exports2.initPromise.reject(ERRORS2.TypedError("Init_IframeTimeout"));
      }, 1e4);
      const onLoad = () => {
        var _a, _b;
        if (!exports2.instance) {
          exports2.initPromise.reject(ERRORS2.TypedError("Init_IframeBlocked"));
          return;
        }
        try {
          const iframeOrigin = (_a = exports2.instance.contentWindow) === null || _a === void 0 ? void 0 : _a.location.origin;
          if (!iframeOrigin || iframeOrigin === "null") {
            handleIframeBlocked();
            return;
          }
        } catch (e) {
        }
        let extension;
        if (typeof chrome !== "undefined" && chrome.runtime && typeof chrome.runtime.onConnect !== "undefined") {
          chrome.runtime.onConnect.addListener(() => {
          });
          extension = chrome.runtime.id;
        }
        (_b = exports2.instance.contentWindow) === null || _b === void 0 ? void 0 : _b.postMessage({
          type: events_12.IFRAME.INIT,
          payload: {
            settings: settings2,
            extension
          }
        }, exports2.origin);
        exports2.instance.onload = null;
      };
      if (exports2.instance.attachEvent) {
        exports2.instance.attachEvent("onload", onLoad);
      } else {
        exports2.instance.onload = onLoad;
      }
      if (document.body) {
        document.body.appendChild(exports2.instance);
        injectStyleSheet();
      }
      try {
        await exports2.initPromise.promise;
      } catch (e) {
        if (exports2.instance) {
          if (exports2.instance.parentNode) {
            exports2.instance.parentNode.removeChild(exports2.instance);
          }
          exports2.instance = null;
        }
        throw e;
      } finally {
        window.clearTimeout(exports2.timeout);
        exports2.timeout = 0;
      }
    };
    exports2.init = init;
    const postMessage = (message2) => {
      var _a;
      if (!exports2.instance) {
        throw ERRORS2.TypedError("Init_IframeBlocked");
      }
      (_a = exports2.instance.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(message2, exports2.origin);
    };
    exports2.postMessage = postMessage;
    const clearTimeout2 = () => {
      window.clearTimeout(exports2.timeout);
    };
    exports2.clearTimeout = clearTimeout2;
    const initIframeLogger = () => {
      const logWriterFactory = () => ({
        add: (message2) => {
          (0, exports2.postMessage)({
            type: events_12.IFRAME.LOG,
            payload: message2
          });
        }
      });
      (0, debug_12.setLogWriter)(logWriterFactory);
    };
    exports2.initIframeLogger = initIframeLogger;
  })(iframe$1);
  return iframe$1;
}
var popup$2 = {};
var showPopupRequest = {};
var hasRequiredShowPopupRequest;
function requireShowPopupRequest() {
  if (hasRequiredShowPopupRequest) return showPopupRequest;
  hasRequiredShowPopupRequest = 1;
  Object.defineProperty(showPopupRequest, "__esModule", { value: true });
  showPopupRequest.showPopupRequest = void 0;
  const LAYER_ID = "TrezorConnectInteractionLayer";
  const HTML = `
    <div class="trezorconnect-container" id="${LAYER_ID}">
        <div class="trezorconnect-window">
            <div class="trezorconnect-head">
                <svg class="trezorconnect-logo" x="0px" y="0px" viewBox="0 0 163.7 41.9" width="78px" height="20px" preserveAspectRatio="xMinYMin meet">
                    <polygon points="101.1,12.8 118.2,12.8 118.2,17.3 108.9,29.9 118.2,29.9 118.2,35.2 101.1,35.2 101.1,30.7 110.4,18.1 101.1,18.1"/>
                    <path d="M158.8,26.9c2.1-0.8,4.3-2.9,4.3-6.6c0-4.5-3.1-7.4-7.7-7.4h-10.5v22.3h5.8v-7.5h2.2l4.1,7.5h6.7L158.8,26.9z M154.7,22.5 h-4V18h4c1.5,0,2.5,0.9,2.5,2.2C157.2,21.6,156.2,22.5,154.7,22.5z"/>
                    <path d="M130.8,12.5c-6.8,0-11.6,4.9-11.6,11.5s4.9,11.5,11.6,11.5s11.7-4.9,11.7-11.5S137.6,12.5,130.8,12.5z M130.8,30.3 c-3.4,0-5.7-2.6-5.7-6.3c0-3.8,2.3-6.3,5.7-6.3c3.4,0,5.8,2.6,5.8,6.3C136.6,27.7,134.2,30.3,130.8,30.3z"/>
                    <polygon points="82.1,12.8 98.3,12.8 98.3,18 87.9,18 87.9,21.3 98,21.3 98,26.4 87.9,26.4 87.9,30 98.3,30 98.3,35.2 82.1,35.2 "/>
                    <path d="M24.6,9.7C24.6,4.4,20,0,14.4,0S4.2,4.4,4.2,9.7v3.1H0v22.3h0l14.4,6.7l14.4-6.7h0V12.9h-4.2V9.7z M9.4,9.7 c0-2.5,2.2-4.5,5-4.5s5,2,5,4.5v3.1H9.4V9.7z M23,31.5l-8.6,4l-8.6-4V18.1H23V31.5z"/>
                    <path d="M79.4,20.3c0-4.5-3.1-7.4-7.7-7.4H61.2v22.3H67v-7.5h2.2l4.1,7.5H80l-4.9-8.3C77.2,26.1,79.4,24,79.4,20.3z M71,22.5h-4V18 h4c1.5,0,2.5,0.9,2.5,2.2C73.5,21.6,72.5,22.5,71,22.5z"/>
                    <polygon points="40.5,12.8 58.6,12.8 58.6,18.1 52.4,18.1 52.4,35.2 46.6,35.2 46.6,18.1 40.5,18.1 "/>
                </svg>
                <div class="trezorconnect-close">
                    <svg x="0px" y="0px" viewBox="24 24 60 60" width="24px" height="24px" preserveAspectRatio="xMinYMin meet">
                        <polygon class="st0" points="40,67.9 42.1,70 55,57.1 67.9,70 70,67.9 57.1,55 70,42.1 67.9,40 55,52.9 42.1,40 40,42.1 52.9,55 "/>
                    </svg>
                </div>
            </div>
            <div class="trezorconnect-body">
                <h3>Popup was blocked</h3>
                <p>Please click to "Continue" to open popup manually</p>
                <button class="trezorconnect-open">Continue</button>
            </div>
        </div>
    </div>
`;
  const showPopupRequest$1 = (open2, cancel) => {
    if (document.getElementById(LAYER_ID)) {
      return;
    }
    const div = document.createElement("div");
    div.id = LAYER_ID;
    div.className = "trezorconnect-container";
    div.innerHTML = HTML;
    if (document.body) {
      document.body.appendChild(div);
    }
    const button2 = div.getElementsByClassName("trezorconnect-open")[0];
    button2.onclick = () => {
      open2();
      if (document.body) {
        document.body.removeChild(div);
      }
    };
    const close = div.getElementsByClassName("trezorconnect-close")[0];
    close.onclick = () => {
      cancel();
      if (document.body) {
        document.body.removeChild(div);
      }
    };
  };
  showPopupRequest.showPopupRequest = showPopupRequest$1;
  return showPopupRequest;
}
var serviceworkerWindow = {};
var lib$3 = {};
var storage = {};
var hasRequiredStorage;
function requireStorage() {
  if (hasRequiredStorage) return storage;
  hasRequiredStorage = 1;
  Object.defineProperty(storage, "__esModule", { value: true });
  storage.storage = void 0;
  const utils_12 = requireLib$4();
  const storageVersion = 2;
  const storageName = `storage_v${storageVersion}`;
  const getEmptyState = () => ({
    origin: {}
  });
  let memoryStorage = getEmptyState();
  const getPermanentStorage = () => {
    const ls = localStorage.getItem(storageName);
    return ls ? JSON.parse(ls) : getEmptyState();
  };
  class Storage extends utils_12.TypedEmitter {
    save(getNewState, temporary = false) {
      if (temporary || !commonjsGlobal.window) {
        memoryStorage = getNewState(memoryStorage);
        return;
      }
      try {
        const newState = getNewState(getPermanentStorage());
        localStorage.setItem(storageName, JSON.stringify(newState));
        this.emit("changed", newState);
      } catch (err) {
        console.warn("long term storage not available");
        memoryStorage = getNewState(memoryStorage);
      }
    }
    saveForOrigin(getNewState, origin, temporary = false) {
      this.save((state) => {
        var _a;
        return Object.assign(Object.assign({}, state), { origin: Object.assign(Object.assign({}, state.origin), { [origin]: getNewState(((_a = state.origin) === null || _a === void 0 ? void 0 : _a[origin]) || {}) }) });
      }, temporary);
    }
    load(temporary = false) {
      var _a;
      if (temporary || !((_a = commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.window) === null || _a === void 0 ? void 0 : _a.localStorage)) {
        return memoryStorage;
      }
      try {
        return getPermanentStorage();
      } catch (err) {
        console.warn("long term storage not available");
        return memoryStorage;
      }
    }
    loadForOrigin(origin, temporary = false) {
      var _a;
      const state = this.load(temporary);
      return ((_a = state.origin) === null || _a === void 0 ? void 0 : _a[origin]) || {};
    }
  }
  const storage$1 = new Storage();
  storage.storage = storage$1;
  return storage;
}
var abstract = {};
var hasRequiredAbstract;
function requireAbstract() {
  if (hasRequiredAbstract) return abstract;
  hasRequiredAbstract = 1;
  Object.defineProperty(abstract, "__esModule", { value: true });
  abstract.AbstractMessageChannel = void 0;
  const tslib_12 = require$$0;
  const utils_12 = requireLib$4();
  const utils_2 = requireLib$4();
  const utils_3 = requireLib$4();
  class AbstractMessageChannel extends utils_2.TypedEmitter {
    constructor({ sendFn, channel, logger, lazyHandshake = false, legacyMode = false }) {
      super();
      this.messagePromises = {};
      this.messagesQueue = [];
      this.messageID = 0;
      this.isConnected = false;
      this.handshakeMaxRetries = 5;
      this.handshakeRetryInterval = 2e3;
      this.channel = channel;
      this.sendFn = sendFn;
      this.lazyHandshake = lazyHandshake;
      this.legacyMode = legacyMode;
      this.logger = logger;
    }
    init() {
      if (!this.handshakeFinished) {
        this.handshakeFinished = (0, utils_12.createDeferred)();
        if (this.legacyMode) {
          setTimeout(() => {
            var _a;
            (_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.resolve();
          }, 500);
        }
        if (!this.lazyHandshake) {
          this.handshakeWithPeer();
        }
      }
      return this.handshakeFinished.promise;
    }
    handshakeWithPeer() {
      var _a;
      (_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(this.channel.here, "handshake");
      return (0, utils_3.scheduleAction)(() => tslib_12.__awaiter(this, void 0, void 0, function* () {
        var _b;
        this.postMessage({
          type: "channel-handshake-request",
          data: { success: true, payload: void 0 }
        }, { usePromise: false, useQueue: false });
        yield (_b = this.handshakeFinished) === null || _b === void 0 ? void 0 : _b.promise;
      }), {
        attempts: this.handshakeMaxRetries,
        timeout: this.handshakeRetryInterval
      }).then(() => {
        var _a2;
        (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(this.channel.here, "handshake confirmed");
        this.messagesQueue.forEach((message2) => {
          message2.channel = this.channel;
          this.sendFn(message2);
        });
        this.messagesQueue = [];
      }).catch(() => {
        var _a2;
        (_a2 = this.handshakeFinished) === null || _a2 === void 0 ? void 0 : _a2.reject(new Error("handshake failed"));
        this.handshakeFinished = void 0;
      });
    }
    onMessage(_message) {
      var _a, _b;
      let message2 = _message;
      if (this.legacyMode && message2.type === void 0 && "data" in message2 && typeof message2.data === "object" && message2.data !== null && "type" in message2.data && typeof message2.data.type === "string") {
        message2 = message2.data;
      }
      const { channel, id: id2, type: type2, payload, success } = message2;
      if (!this.legacyMode) {
        if (!(channel === null || channel === void 0 ? void 0 : channel.peer) || channel.peer !== this.channel.here) {
          return;
        }
        if (!(channel === null || channel === void 0 ? void 0 : channel.here) || this.channel.peer !== channel.here) {
          return;
        }
      }
      if (type2 === "channel-handshake-request") {
        this.postMessage({
          type: "channel-handshake-confirm",
          data: { success: true, payload: void 0 }
        }, { usePromise: false, useQueue: false });
        if (this.lazyHandshake) {
          this.handshakeWithPeer();
        }
        return;
      }
      if (type2 === "channel-handshake-confirm") {
        (_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.resolve(void 0);
        return;
      }
      if (this.messagePromises[id2]) {
        this.messagePromises[id2].resolve({ id: id2, payload, success });
        delete this.messagePromises[id2];
      }
      const messagePromisesLength = Object.keys(this.messagePromises).length;
      if (messagePromisesLength > 5) {
        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn(`too many message promises (${messagePromisesLength}). this feels unexpected!`);
      }
      this.emit("message", message2);
    }
    postMessage(message2, { usePromise = true, useQueue = true } = {}) {
      message2.channel = this.channel;
      if (!usePromise) {
        try {
          this.sendFn(message2);
        } catch (err) {
          if (useQueue) {
            this.messagesQueue.push(message2);
          }
        }
        return;
      }
      this.messageID++;
      message2.id = this.messageID;
      this.messagePromises[message2.id] = (0, utils_12.createDeferred)();
      try {
        this.sendFn(message2);
      } catch (err) {
        if (useQueue) {
          this.messagesQueue.push(message2);
        }
      }
      return this.messagePromises[message2.id].promise;
    }
    resolveMessagePromises(resolvePayload) {
      Object.keys(this.messagePromises).forEach((id2) => this.messagePromises[id2].resolve({
        id: id2,
        payload: resolvePayload
      }));
    }
    clear() {
      this.handshakeFinished = void 0;
    }
  }
  abstract.AbstractMessageChannel = AbstractMessageChannel;
  return abstract;
}
var systemInfo = {};
var lib$2 = {};
var envUtils = {};
var uaParser = { exports: {} };
var hasRequiredUaParser;
function requireUaParser() {
  if (hasRequiredUaParser) return uaParser.exports;
  hasRequiredUaParser = 1;
  (function(module, exports2) {
    (function(window2, undefined$1) {
      var LIBVERSION = "1.0.39", EMPTY2 = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
      var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS", SUFFIX_BROWSER = " Browser";
      var extend = function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i in regexes2) {
          if (extensions[i] && extensions[i].length % 2 === 0) {
            mergedRegexes[i] = extensions[i].concat(regexes2[i]);
          } else {
            mergedRegexes[i] = regexes2[i];
          }
        }
        return mergedRegexes;
      }, enumerize = function(arr) {
        var enums = {};
        for (var i = 0; i < arr.length; i++) {
          enums[arr[i].toUpperCase()] = arr[i];
        }
        return enums;
      }, has = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
      }, lowerize = function(str) {
        return str.toLowerCase();
      }, majorize = function(version2) {
        return typeof version2 === STR_TYPE ? version2.replace(/[^\d\.]/g, EMPTY2).split(".")[0] : undefined$1;
      }, trim = function(str, len) {
        if (typeof str === STR_TYPE) {
          str = str.replace(/^\s\s*/, EMPTY2);
          return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
      };
      var rgxMapper = function(ua, arrays) {
        var i = 0, j, k, p, q, matches, match;
        while (i < arrays.length && !matches) {
          var regex = arrays[i], props = arrays[i + 1];
          j = k = 0;
          while (j < regex.length && !matches) {
            if (!regex[j]) {
              break;
            }
            matches = regex[j++].exec(ua);
            if (!!matches) {
              for (p = 0; p < props.length; p++) {
                match = matches[++k];
                q = props[p];
                if (typeof q === OBJ_TYPE && q.length > 0) {
                  if (q.length === 2) {
                    if (typeof q[1] == FUNC_TYPE) {
                      this[q[0]] = q[1].call(this, match);
                    } else {
                      this[q[0]] = q[1];
                    }
                  } else if (q.length === 3) {
                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                      this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;
                    } else {
                      this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;
                    }
                  } else if (q.length === 4) {
                    this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;
                  }
                } else {
                  this[q] = match ? match : undefined$1;
                }
              }
            }
          }
          i += 2;
        }
      }, strMapper = function(str, map2) {
        for (var i in map2) {
          if (typeof map2[i] === OBJ_TYPE && map2[i].length > 0) {
            for (var j = 0; j < map2[i].length; j++) {
              if (has(map2[i][j], str)) {
                return i === UNKNOWN ? undefined$1 : i;
              }
            }
          } else if (has(map2[i], str)) {
            return i === UNKNOWN ? undefined$1 : i;
          }
        }
        return map2.hasOwnProperty("*") ? map2["*"] : str;
      };
      var oldSafariMap = {
        "1.0": "/8",
        "1.2": "/1",
        "1.3": "/3",
        "2.0": "/412",
        "2.0.2": "/416",
        "2.0.3": "/417",
        "2.0.4": "/419",
        "?": "/"
      }, windowsVersionMap = {
        "ME": "4.90",
        "NT 3.11": "NT3.51",
        "NT 4.0": "NT4.0",
        "2000": "NT 5.0",
        "XP": ["NT 5.1", "NT 5.2"],
        "Vista": "NT 6.0",
        "7": "NT 6.1",
        "8": "NT 6.2",
        "8.1": "NT 6.3",
        "10": ["NT 6.4", "NT 10.0"],
        "RT": "ARM"
      };
      var regexes = {
        browser: [
          [
            /\b(?:crmo|crios)\/([\w\.]+)/i
            // Chrome for Android/iOS
          ],
          [VERSION, [NAME, "Chrome"]],
          [
            /edg(?:e|ios|a)?\/([\w\.]+)/i
            // Microsoft Edge
          ],
          [VERSION, [NAME, "Edge"]],
          [
            // Presto based
            /(opera mini)\/([-\w\.]+)/i,
            // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
            // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            // Opera
          ],
          [NAME, VERSION],
          [
            /opios[\/ ]+([\w\.]+)/i
            // Opera mini on iphone >= 8.0
          ],
          [VERSION, [NAME, OPERA + " Mini"]],
          [
            /\bop(?:rg)?x\/([\w\.]+)/i
            // Opera GX
          ],
          [VERSION, [NAME, OPERA + " GX"]],
          [
            /\bopr\/([\w\.]+)/i
            // Opera Webkit
          ],
          [VERSION, [NAME, OPERA]],
          [
            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
            // Baidu
          ],
          [VERSION, [NAME, "Baidu"]],
          [
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
            // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i,
            // Avant/IEMobile/SlimBrowser
            /(?:ms|\()(ie) ([\w\.]+)/i,
            // Internet Explorer
            // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio)\/([-\w\.]+)/i,
            // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio
            /(heytap|ovi)browser\/([\d\.]+)/i,
            // HeyTap/Ovi
            /(weibo)__([\d\.]+)/i
            // Weibo
          ],
          [NAME, VERSION],
          [
            /quark(?:pc)?\/([-\w\.]+)/i
            // Quark
          ],
          [VERSION, [NAME, "Quark"]],
          [
            /\bddg\/([\w\.]+)/i
            // DuckDuckGo
          ],
          [VERSION, [NAME, "DuckDuckGo"]],
          [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
            // UCBrowser
          ],
          [VERSION, [NAME, "UC" + BROWSER]],
          [
            /microm.+\bqbcore\/([\w\.]+)/i,
            // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i,
            /micromessenger\/([\w\.]+)/i
            // WeChat
          ],
          [VERSION, [NAME, "WeChat"]],
          [
            /konqueror\/([\w\.]+)/i
            // Konqueror
          ],
          [VERSION, [NAME, "Konqueror"]],
          [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
            // IE11
          ],
          [VERSION, [NAME, "IE"]],
          [
            /ya(?:search)?browser\/([\w\.]+)/i
            // Yandex
          ],
          [VERSION, [NAME, "Yandex"]],
          [
            /slbrowser\/([\w\.]+)/i
            // Smart Lenovo Browser
          ],
          [VERSION, [NAME, "Smart Lenovo " + BROWSER]],
          [
            /(avast|avg)\/([\w\.]+)/i
            // Avast/AVG Secure Browser
          ],
          [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION],
          [
            /\bfocus\/([\w\.]+)/i
            // Firefox Focus
          ],
          [VERSION, [NAME, FIREFOX + " Focus"]],
          [
            /\bopt\/([\w\.]+)/i
            // Opera Touch
          ],
          [VERSION, [NAME, OPERA + " Touch"]],
          [
            /coc_coc\w+\/([\w\.]+)/i
            // Coc Coc Browser
          ],
          [VERSION, [NAME, "Coc Coc"]],
          [
            /dolfin\/([\w\.]+)/i
            // Dolphin
          ],
          [VERSION, [NAME, "Dolphin"]],
          [
            /coast\/([\w\.]+)/i
            // Opera Coast
          ],
          [VERSION, [NAME, OPERA + " Coast"]],
          [
            /miuibrowser\/([\w\.]+)/i
            // MIUI Browser
          ],
          [VERSION, [NAME, "MIUI " + BROWSER]],
          [
            /fxios\/([-\w\.]+)/i
            // Firefox for iOS
          ],
          [VERSION, [NAME, FIREFOX]],
          [
            /\bqihu|(qi?ho?o?|360)browser/i
            // 360
          ],
          [[NAME, "360" + SUFFIX_BROWSER]],
          [
            /\b(qq)\/([\w\.]+)/i
            // QQ
          ],
          [[NAME, /(.+)/, "$1Browser"], VERSION],
          [
            /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
          ],
          [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION],
          [
            // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i
            // Samsung Internet
          ],
          [VERSION, [NAME, SAMSUNG + " Internet"]],
          [
            /(comodo_dragon)\/([\w\.]+)/i
            // Comodo Dragon
          ],
          [[NAME, /_/g, " "], VERSION],
          [
            /metasr[\/ ]?([\d\.]+)/i
            // Sogou Explorer
          ],
          [VERSION, [NAME, "Sogou Explorer"]],
          [
            /(sogou)mo\w+\/([\d\.]+)/i
            // Sogou Mobile
          ],
          [[NAME, "Sogou Mobile"], VERSION],
          [
            /(electron)\/([\w\.]+) safari/i,
            // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
            // Tesla
            /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i
            // QQBrowser/2345 Browser
          ],
          [NAME, VERSION],
          [
            /(lbbrowser|rekonq)/i,
            // LieBao Browser/Rekonq
            /\[(linkedin)app\]/i
            // LinkedIn App for iOS & Android
          ],
          [NAME],
          [
            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
            // Facebook App for iOS & Android
          ],
          [[NAME, FACEBOOK], VERSION],
          [
            /(Klarna)\/([\w\.]+)/i,
            // Klarna Shopping Browser for iOS & Android
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
            // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
            // Naver InApp
            /safari (line)\/([\w\.]+)/i,
            // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,
            // Line App for Android
            /(alipay)client\/([\w\.]+)/i,
            // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,
            // Twitter
            /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
            // Chromium/Instagram/Snapchat
          ],
          [NAME, VERSION],
          [
            /\bgsa\/([\w\.]+) .*safari\//i
            // Google Search Appliance on iOS
          ],
          [VERSION, [NAME, "GSA"]],
          [
            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
            // TikTok
          ],
          [VERSION, [NAME, "TikTok"]],
          [
            /headlesschrome(?:\/([\w\.]+)| )/i
            // Chrome Headless
          ],
          [VERSION, [NAME, CHROME + " Headless"]],
          [
            / wv\).+(chrome)\/([\w\.]+)/i
            // Chrome WebView
          ],
          [[NAME, CHROME + " WebView"], VERSION],
          [
            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
            // Android Browser
          ],
          [VERSION, [NAME, "Android " + BROWSER]],
          [
            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
            // Chrome/OmniWeb/Arora/Tizen/Nokia
          ],
          [NAME, VERSION],
          [
            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
            // Mobile Safari
          ],
          [VERSION, [NAME, "Mobile Safari"]],
          [
            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
            // Safari & Safari Mobile
          ],
          [VERSION, NAME],
          [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
            // Safari < 3.0
          ],
          [NAME, [VERSION, strMapper, oldSafariMap]],
          [
            /(webkit|khtml)\/([\w\.]+)/i
          ],
          [NAME, VERSION],
          [
            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i
            // Netscape
          ],
          [[NAME, "Netscape"], VERSION],
          [
            /(wolvic)\/([\w\.]+)/i
            // Wolvic
          ],
          [NAME, VERSION],
          [
            /mobile vr; rv:([\w\.]+)\).+firefox/i
            // Firefox Reality
          ],
          [VERSION, [NAME, FIREFOX + " Reality"]],
          [
            /ekiohf.+(flow)\/([\w\.]+)/i,
            // Flow
            /(swiftfox)/i,
            // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
            // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
            // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,
            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
            // Mozilla
            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
            // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser
            /(links) \(([\w\.]+)/i
            // Links
          ],
          [NAME, [VERSION, /_/g, "."]],
          [
            /(cobalt)\/([\w\.]+)/i
            // Cobalt
          ],
          [NAME, [VERSION, /master.|lts./, ""]]
        ],
        cpu: [
          [
            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
            // AMD64 (x64)
          ],
          [[ARCHITECTURE, "amd64"]],
          [
            /(ia32(?=;))/i
            // IA32 (quicktime)
          ],
          [[ARCHITECTURE, lowerize]],
          [
            /((?:i[346]|x)86)[;\)]/i
            // IA32 (x86)
          ],
          [[ARCHITECTURE, "ia32"]],
          [
            /\b(aarch64|arm(v?8e?l?|_?64))\b/i
            // ARM64
          ],
          [[ARCHITECTURE, "arm64"]],
          [
            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
            // ARMHF
          ],
          [[ARCHITECTURE, "armhf"]],
          [
            // PocketPC mistakenly identified as PowerPC
            /windows (ce|mobile); ppc;/i
          ],
          [[ARCHITECTURE, "arm"]],
          [
            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
            // PowerPC
          ],
          [[ARCHITECTURE, /ower/, EMPTY2, lowerize]],
          [
            /(sun4\w)[;\)]/i
            // SPARC
          ],
          [[ARCHITECTURE, "sparc"]],
          [
            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
            // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
          ],
          [[ARCHITECTURE, lowerize]]
        ],
        device: [
          [
            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////
            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
          [
            /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
            /samsung[- ]((?!sm-[lr])[-\w]+)/i,
            /sec-(sgh\w+)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
          [
            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
            // iPod/iPhone
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
          [
            /\((ipad);[-\w\),; ]+apple/i,
            // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
          [
            /(macintosh);/i
          ],
          [MODEL, [VENDOR, APPLE]],
          [
            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
          [
            // Huawei
            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
          [
            /(?:huawei|honor)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
          [
            // Xiaomi
            /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
            // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,
            // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
            // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
            // Xiaomi Redmi
            /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
            // Xiaomi Redmi 'numeric' models
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i
            // Xiaomi Mi
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
          [
            /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
            // Redmi Pad
            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
            // Mi Pad tablets
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
          [
            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
          ],
          [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]],
          [
            /\b(opd2\d{3}a?) bui/i
          ],
          [MODEL, [VENDOR, "OPPO"], [TYPE, TABLET]],
          [
            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
          ],
          [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
          [
            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
          ],
          [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
          [
            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
          [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
          [
            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, TABLET]],
          [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
            /\blg-?([\d\w]+) bui/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
          [
            // Lenovo
            /(ideatab[-\w ]+)/i,
            /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
          ],
          [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
          [
            // Nokia
            /(?:maemo|nokia).*(n900|lumia \d+)/i,
            /nokia[-_ ]?([-\w\.]*)/i
          ],
          [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]],
          [
            // Google
            /(pixel c)\b/i
            // Google Pixel C
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
          [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
            // Google Pixel
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
          [
            // Sony
            /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
          ],
          [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
          [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
          ],
          [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
          [
            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
          ],
          [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
          [
            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
            // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i
            // Kindle Fire HD
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
          [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
            // Fire Phone
          ],
          [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
          [
            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i
            // BlackBerry PlayBook
          ],
          [MODEL, VENDOR, [TYPE, TABLET]],
          [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i
            // BlackBerry 10
          ],
          [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
          [
            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
          [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
          [
            // HTC
            /(nexus 9)/i
            // HTC Nexus 9
          ],
          [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
          [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
            // HTC
            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
            // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
          ],
          [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
          [
            // TCL
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i
          ],
          [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]],
          [
            // itel
            /(itel) ((\w+))/i
          ],
          [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { "tablet": ["p10001l", "w7001"], "*": "mobile" }]],
          [
            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
          ],
          [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
          [
            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
          ],
          [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
          [
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
          [
            // Nothing
            /droid.+; (a(?:015|06[35]|142p?))/i
          ],
          [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]],
          [
            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i,
            // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp) ([\w ]+\w)/i,
            // HP iPAQ
            /(asus)-?(\w+)/i,
            // Asus
            /(microsoft); (lumia[\w ]+)/i,
            // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w]+)/i,
            // Lenovo
            /(jolla)/i,
            // Jolla
            /(oppo) ?([\w ]+) bui/i
            // OPPO
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kobo)\s(ereader|touch)/i,
            // Kobo
            /(archos) (gamepad2?)/i,
            // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,
            // HP TouchPad
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(nook)[\w ]+build\/(\w+)/i,
            // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,
            // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
            // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,
            // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,
            // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i
            // Vodafone
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(surface duo)/i
            // Surface Duo
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
          [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i
            // Fairphone
          ],
          [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
          [
            /(u304aa)/i
            // AT&T
          ],
          [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
          [
            /\bsie-(\w*)/i
            // Siemens
          ],
          [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
          [
            /\b(rct\w+) b/i
            // RCA Tablets
          ],
          [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
          [
            /\b(venue[\d ]{2,7}) b/i
            // Dell Venue Tablets
          ],
          [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
          [
            /\b(q(?:mv|ta)\w+) b/i
            // Verizon Tablet
          ],
          [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
          [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
            // Barnes & Noble Tablet
          ],
          [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
          [
            /\b(tm\d{3}\w+) b/i
          ],
          [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
          [
            /\b(k88) b/i
            // ZTE K Series Tablet
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
          [
            /\b(nx\d{3}j) b/i
            // ZTE Nubia
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
          [
            /\b(gen\d{3}) b.+49h/i
            // Swiss GEN Mobile
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
          [
            /\b(zur\d{3}) b/i
            // Swiss ZUR Tablet
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
          [
            /\b((zeki)?tb.*\b) b/i
            // Zeki Tablets
          ],
          [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
          [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i
            // Dragon Touch Tablet
          ],
          [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
          [
            /\b(ns-?\w{0,9}) b/i
            // Insignia Tablets
          ],
          [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
          [
            /\b((nxa|next)-?\w{0,9}) b/i
            // NextBook Tablets
          ],
          [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
          [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
            // Voice Xtreme Phones
          ],
          [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
          [
            /\b(lvtel\-)?(v1[12]) b/i
            // LvTel Phones
          ],
          [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
          [
            /\b(ph-1) /i
            // Essential PH-1
          ],
          [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
          [
            /\b(v(100md|700na|7011|917g).*\b) b/i
            // Envizen Tablets
          ],
          [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
          [
            /\b(trio[-\w\. ]+) b/i
            // MachSpeed Tablets
          ],
          [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
          [
            /\btu_(1491) b/i
            // Rotor Tablets
          ],
          [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
          [
            /(shield[\w ]+) b/i
            // Nvidia Shield Tablets
          ],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]],
          [
            /(sprint) (\w+)/i
            // Sprint Phones
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kin\.[onetw]{3})/i
            // Microsoft Kin
          ],
          [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
          [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
            // Zebra
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
          [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
          [
            ///////////////////
            // SMARTTVS
            ///////////////////
            /smart-tv.+(samsung)/i
            // Samsung
          ],
          [VENDOR, [TYPE, SMARTTV]],
          [
            /hbbtv.+maple;(\d+)/i
          ],
          [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
          [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
            // LG SmartTV
          ],
          [[VENDOR, LG], [TYPE, SMARTTV]],
          [
            /(apple) ?tv/i
            // Apple TV
          ],
          [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
          [
            /crkey/i
            // Google Chromecast
          ],
          [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /droid.+aft(\w+)( bui|\))/i
            // Fire TV
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
          [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i
            // Sharp
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
          [
            /(bravia[\w ]+)( bui|\))/i
            // Sony
          ],
          [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
          [
            /(mitv-\w{5}) bui/i
            // Xiaomi
          ],
          [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
          [
            /Hbbtv.*(technisat) (.*);/i
            // TechniSAT
          ],
          [VENDOR, MODEL, [TYPE, SMARTTV]],
          [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
            // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
            // HbbTV devices
          ],
          [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
          [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
            // SmartTV from Unidentified Vendors
          ],
          [[TYPE, SMARTTV]],
          [
            ///////////////////
            // CONSOLES
            ///////////////////
            /(ouya)/i,
            // Ouya
            /(nintendo) ([wids3utch]+)/i
            // Nintendo
          ],
          [VENDOR, MODEL, [TYPE, CONSOLE]],
          [
            /droid.+; (shield) bui/i
            // Nvidia
          ],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
          [
            /(playstation [345portablevi]+)/i
            // Playstation
          ],
          [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
          [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i
            // Microsoft Xbox
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
          [
            ///////////////////
            // WEARABLES
            ///////////////////
            /\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i
            // Samsung Galaxy Watch
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]],
          [
            /((pebble))app/i
            // Pebble
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
            // Apple Watch
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
          [
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /droid.+; (wt63?0{2,3})\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
          [
            /(quest( \d| pro)?)/i
            // Oculus Quest
          ],
          [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
          [
            ///////////////////
            // EMBEDDED
            ///////////////////
            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
            // Tesla
          ],
          [VENDOR, [TYPE, EMBEDDED]],
          [
            /(aeobc)\b/i
            // Echo Dot
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
          [
            ////////////////////
            // MIXED (GENERIC)
            ///////////////////
            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
            // Android Phones from Unidentified Vendors
          ],
          [MODEL, [TYPE, MOBILE]],
          [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
            // Android Tablets from Unidentified Vendors
          ],
          [MODEL, [TYPE, TABLET]],
          [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
            // Unidentifiable Tablet
          ],
          [[TYPE, TABLET]],
          [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
            // Unidentifiable Mobile
          ],
          [[TYPE, MOBILE]],
          [
            /(android[-\w\. ]{0,9});.+buil/i
            // Generic Android Device
          ],
          [MODEL, [VENDOR, "Generic"]]
        ],
        engine: [
          [
            /windows.+ edge\/([\w\.]+)/i
            // EdgeHTML
          ],
          [VERSION, [NAME, EDGE + "HTML"]],
          [
            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
            // Blink
          ],
          [VERSION, [NAME, "Blink"]],
          [
            /(presto)\/([\w\.]+)/i,
            // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
            // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
            /ekioh(flow)\/([\w\.]+)/i,
            // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
            // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,
            // iCab
            /\b(libweb)/i
          ],
          [NAME, VERSION],
          [
            /rv\:([\w\.]{1,9})\b.+(gecko)/i
            // Gecko
          ],
          [VERSION, NAME]
        ],
        os: [
          [
            // Windows
            /microsoft (windows) (vista|xp)/i
            // Windows (iTunes)
          ],
          [NAME, VERSION],
          [
            /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i
            // Windows Phone
          ],
          [NAME, [VERSION, strMapper, windowsVersionMap]],
          [
            /windows nt 6\.2; (arm)/i,
            // Windows RT
            /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
            /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
          ],
          [[VERSION, strMapper, windowsVersionMap], [NAME, "Windows"]],
          [
            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
            // iOS
            /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
            /cfnetwork\/.+darwin/i
          ],
          [[VERSION, /_/g, "."], [NAME, "iOS"]],
          [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i
            // Mac OS
          ],
          [[NAME, MAC_OS], [VERSION, /_/g, "."]],
          [
            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
            // Android-x86/HarmonyOS
          ],
          [VERSION, NAME],
          [
            // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
            /(blackberry)\w*\/([\w\.]*)/i,
            // Blackberry
            /(tizen|kaios)[\/ ]([\w\.]+)/i,
            // Tizen/KaiOS
            /\((series40);/i
            // Series 40
          ],
          [NAME, VERSION],
          [
            /\(bb(10);/i
            // BlackBerry 10
          ],
          [VERSION, [NAME, BLACKBERRY]],
          [
            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
            // Symbian
          ],
          [VERSION, [NAME, "Symbian"]],
          [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            // Firefox OS
          ],
          [VERSION, [NAME, FIREFOX + " OS"]],
          [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
            // WebOS
          ],
          [VERSION, [NAME, "webOS"]],
          [
            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
            // watchOS
          ],
          [VERSION, [NAME, "watchOS"]],
          [
            // Google Chromecast
            /crkey\/([\d\.]+)/i
            // Google Chromecast
          ],
          [VERSION, [NAME, CHROME + "cast"]],
          [
            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
            // Chromium OS
          ],
          [[NAME, CHROMIUM_OS], VERSION],
          [
            // Smart TVs
            /panasonic;(viera)/i,
            // Panasonic Viera
            /(netrange)mmh/i,
            // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,
            // NetTV
            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,
            // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,
            // Microsoft Xbox (360, One, X, S, Series X, Series S)
            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,
            // Mint
            /(mageia|vectorlinux)[; ]/i,
            // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
            // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux) ?([\w\.]*)/i,
            // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,
            // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
            // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i
            // Haiku
          ],
          [NAME, VERSION],
          [
            /(sunos) ?([\w\.\d]*)/i
            // Solaris
          ],
          [[NAME, "Solaris"], VERSION],
          [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
            // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
            // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i
            // UNIX
          ],
          [NAME, VERSION]
        ]
      };
      var UAParser = function(ua, extensions) {
        if (typeof ua === OBJ_TYPE) {
          extensions = ua;
          ua = undefined$1;
        }
        if (!(this instanceof UAParser)) {
          return new UAParser(ua, extensions).getResult();
        }
        var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined$1;
        var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY2);
        var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined$1;
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        var _isSelfNav = _navigator && _navigator.userAgent == _ua;
        this.getBrowser = function() {
          var _browser = {};
          _browser[NAME] = undefined$1;
          _browser[VERSION] = undefined$1;
          rgxMapper.call(_browser, _ua, _rgxmap.browser);
          _browser[MAJOR] = majorize(_browser[VERSION]);
          if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
            _browser[NAME] = "Brave";
          }
          return _browser;
        };
        this.getCPU = function() {
          var _cpu = {};
          _cpu[ARCHITECTURE] = undefined$1;
          rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
          return _cpu;
        };
        this.getDevice = function() {
          var _device = {};
          _device[VENDOR] = undefined$1;
          _device[MODEL] = undefined$1;
          _device[TYPE] = undefined$1;
          rgxMapper.call(_device, _ua, _rgxmap.device);
          if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
            _device[TYPE] = MOBILE;
          }
          if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
            _device[MODEL] = "iPad";
            _device[TYPE] = TABLET;
          }
          return _device;
        };
        this.getEngine = function() {
          var _engine = {};
          _engine[NAME] = undefined$1;
          _engine[VERSION] = undefined$1;
          rgxMapper.call(_engine, _ua, _rgxmap.engine);
          return _engine;
        };
        this.getOS = function() {
          var _os = {};
          _os[NAME] = undefined$1;
          _os[VERSION] = undefined$1;
          rgxMapper.call(_os, _ua, _rgxmap.os);
          if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != "Unknown") {
            _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
          }
          return _os;
        };
        this.getResult = function() {
          return {
            ua: this.getUA(),
            browser: this.getBrowser(),
            engine: this.getEngine(),
            os: this.getOS(),
            device: this.getDevice(),
            cpu: this.getCPU()
          };
        };
        this.getUA = function() {
          return _ua;
        };
        this.setUA = function(ua2) {
          _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
          return this;
        };
        this.setUA(_ua);
        return this;
      };
      UAParser.VERSION = LIBVERSION;
      UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
      UAParser.CPU = enumerize([ARCHITECTURE]);
      UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
      {
        if (module.exports) {
          exports2 = module.exports = UAParser;
        }
        exports2.UAParser = UAParser;
      }
      var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
      if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function() {
          return parser.getUA();
        };
        $.ua.set = function(ua) {
          parser.setUA(ua);
          var result = parser.getResult();
          for (var prop in result) {
            $.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : commonjsGlobal);
  })(uaParser, uaParser.exports);
  return uaParser.exports;
}
var jws = {};
var hasRequiredJws;
function requireJws() {
  if (hasRequiredJws) return jws;
  hasRequiredJws = 1;
  Object.defineProperty(jws, "__esModule", { value: true });
  jws.publicKey = void 0;
  jws.publicKey = {
    dev: `-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEbSUHJlr17+NywPS/w+xMkp3dSD8eWXSuAfFKwonZPe5fL63kISipJC+eJP7Mad0WxgyJoiMsZCV6BZPK2jIFdg==
-----END PUBLIC KEY-----`,
    codesign: `-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAES7MbBzU/v5BsljkTM8Mz0Jsk+Nn5n2wH
o2/+MUI3TgCVdTbEHhn3HXaY7GJ6TLyWqxn+pIDY9wUUAyUqOStTUQ==
-----END PUBLIC KEY-----`
  };
  return jws;
}
var hasRequiredEnvUtils;
function requireEnvUtils() {
  if (hasRequiredEnvUtils) return envUtils;
  hasRequiredEnvUtils = 1;
  (function(exports2) {
    var define_process_env_default2 = {};
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envUtils = exports2.getJWSPublicKey = exports2.getEnvironment = exports2.isNative = exports2.isDesktop = exports2.isWeb = void 0;
    const tslib_12 = require$$0;
    const ua_parser_js_1 = tslib_12.__importDefault(requireUaParser());
    const jws_1 = requireJws();
    const isWeb = () => define_process_env_default2.SUITE_TYPE === "web";
    exports2.isWeb = isWeb;
    const isDesktop = () => define_process_env_default2.SUITE_TYPE === "desktop";
    exports2.isDesktop = isDesktop;
    const isNative = () => false;
    exports2.isNative = isNative;
    const getEnvironment = () => {
      if ((0, exports2.isWeb)())
        return "web";
      return "desktop";
    };
    exports2.getEnvironment = getEnvironment;
    let userAgentParser;
    const getUserAgent = () => window.navigator.userAgent;
    const getUserAgentParser = () => {
      if (!userAgentParser) {
        const ua = getUserAgent();
        userAgentParser = new ua_parser_js_1.default(ua);
      }
      return userAgentParser;
    };
    const isAndroid = () => /Android/.test(getUserAgent());
    const isChromeOs = () => /CrOS/.test(getUserAgent());
    const getBrowserVersion = () => getUserAgentParser().getBrowser().version || "";
    const getCommitHash = () => define_process_env_default2.COMMITHASH || "";
    const getOsVersion = () => getUserAgentParser().getOS().version || "";
    const getSuiteVersion = () => define_process_env_default2.VERSION || "";
    const getBrowserName = () => {
      const browserName = getUserAgentParser().getBrowser().name;
      return (browserName === null || browserName === void 0 ? void 0 : browserName.toLowerCase()) || "";
    };
    const isFirefox = () => getBrowserName() === "firefox";
    const getPlatform = () => window.navigator.platform;
    const getPlatformLanguages = () => window.navigator.languages;
    const getScreenWidth = () => window.screen.width;
    const getScreenHeight = () => window.screen.height;
    const getWindowWidth = () => window.innerWidth;
    const getWindowHeight = () => window.innerHeight;
    const getLocationOrigin = () => window.location.origin;
    const getLocationHostname = () => window.location.hostname;
    const getProcessPlatform = () => typeof process$1 !== "undefined" ? process$1.platform : "";
    const isMacOs = () => {
      if (getProcessPlatform() === "darwin")
        return true;
      if (typeof window === "undefined")
        return;
      return getPlatform().startsWith("Mac");
    };
    const isWindows = () => {
      if (getProcessPlatform() === "win32")
        return true;
      if (typeof window === "undefined")
        return;
      return getPlatform().startsWith("Win");
    };
    const isIOs = () => ["iPhone", "iPad", "iPod"].includes(getPlatform());
    const isLinux = () => {
      if (getProcessPlatform() === "linux")
        return true;
      if (typeof window === "undefined")
        return;
      if (isAndroid() || isChromeOs())
        return false;
      return getPlatform().startsWith("Linux");
    };
    const isCodesignBuild = () => define_process_env_default2.IS_CODESIGN_BUILD === "true";
    const getOsName = () => {
      if (isWindows())
        return "windows";
      if (isMacOs())
        return "macos";
      if (isAndroid())
        return "android";
      if (isChromeOs())
        return "chromeos";
      if (isLinux())
        return "linux";
      if (isIOs())
        return "ios";
      return "";
    };
    const getOsNameWeb = () => getUserAgentParser().getOS().name;
    const getOsFamily = () => {
      const osName = getUserAgentParser().getOS().name;
      if (osName === "Windows") {
        return "Windows";
      }
      if (osName === "Mac OS") {
        return "MacOS";
      }
      return "Linux";
    };
    const getDeviceType = () => getUserAgentParser().getDevice().type;
    const getJWSPublicKey = () => isCodesignBuild() ? jws_1.publicKey.codesign : jws_1.publicKey.dev;
    exports2.getJWSPublicKey = getJWSPublicKey;
    exports2.envUtils = {
      isWeb: exports2.isWeb,
      isDesktop: exports2.isDesktop,
      isNative: exports2.isNative,
      getEnvironment: exports2.getEnvironment,
      getUserAgent,
      isAndroid,
      isChromeOs,
      getOsVersion,
      getBrowserName,
      getBrowserVersion,
      getCommitHash,
      getDeviceType,
      getSuiteVersion,
      isFirefox,
      getPlatform,
      getPlatformLanguages,
      getScreenWidth,
      getScreenHeight,
      getWindowWidth,
      getWindowHeight,
      getLocationOrigin,
      getLocationHostname,
      getProcessPlatform,
      isMacOs,
      isWindows,
      isIOs,
      isLinux,
      isCodesignBuild,
      getOsName,
      getOsNameWeb,
      getOsFamily,
      getJWSPublicKey: exports2.getJWSPublicKey
    };
  })(envUtils);
  return envUtils;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$2;
  hasRequiredLib$3 = 1;
  Object.defineProperty(lib$2, "__esModule", { value: true });
  lib$2.getJWSPublicKey = lib$2.getOsFamily = lib$2.getOsNameWeb = lib$2.getOsName = lib$2.isCodesignBuild = lib$2.isLinux = lib$2.isIOs = lib$2.isWindows = lib$2.isMacOs = lib$2.getProcessPlatform = lib$2.getLocationHostname = lib$2.getLocationOrigin = lib$2.getWindowHeight = lib$2.getWindowWidth = lib$2.getScreenHeight = lib$2.getScreenWidth = lib$2.getPlatformLanguages = lib$2.getPlatform = lib$2.isFirefox = lib$2.getSuiteVersion = lib$2.getOsVersion = lib$2.getDeviceType = lib$2.getCommitHash = lib$2.getBrowserName = lib$2.getBrowserVersion = lib$2.isChromeOs = lib$2.isAndroid = lib$2.getUserAgent = lib$2.getEnvironment = lib$2.isNative = lib$2.isDesktop = lib$2.isWeb = void 0;
  const envUtils_1 = requireEnvUtils();
  lib$2.isWeb = envUtils_1.envUtils.isWeb, lib$2.isDesktop = envUtils_1.envUtils.isDesktop, lib$2.isNative = envUtils_1.envUtils.isNative, lib$2.getEnvironment = envUtils_1.envUtils.getEnvironment, lib$2.getUserAgent = envUtils_1.envUtils.getUserAgent, lib$2.isAndroid = envUtils_1.envUtils.isAndroid, lib$2.isChromeOs = envUtils_1.envUtils.isChromeOs, lib$2.getBrowserVersion = envUtils_1.envUtils.getBrowserVersion, lib$2.getBrowserName = envUtils_1.envUtils.getBrowserName, lib$2.getCommitHash = envUtils_1.envUtils.getCommitHash, lib$2.getDeviceType = envUtils_1.envUtils.getDeviceType, lib$2.getOsVersion = envUtils_1.envUtils.getOsVersion, lib$2.getSuiteVersion = envUtils_1.envUtils.getSuiteVersion, lib$2.isFirefox = envUtils_1.envUtils.isFirefox, lib$2.getPlatform = envUtils_1.envUtils.getPlatform, lib$2.getPlatformLanguages = envUtils_1.envUtils.getPlatformLanguages, lib$2.getScreenWidth = envUtils_1.envUtils.getScreenWidth, lib$2.getScreenHeight = envUtils_1.envUtils.getScreenHeight, lib$2.getWindowWidth = envUtils_1.envUtils.getWindowWidth, lib$2.getWindowHeight = envUtils_1.envUtils.getWindowHeight, lib$2.getLocationOrigin = envUtils_1.envUtils.getLocationOrigin, lib$2.getLocationHostname = envUtils_1.envUtils.getLocationHostname, lib$2.getProcessPlatform = envUtils_1.envUtils.getProcessPlatform, lib$2.isMacOs = envUtils_1.envUtils.isMacOs, lib$2.isWindows = envUtils_1.envUtils.isWindows, lib$2.isIOs = envUtils_1.envUtils.isIOs, lib$2.isLinux = envUtils_1.envUtils.isLinux, lib$2.isCodesignBuild = envUtils_1.envUtils.isCodesignBuild, lib$2.getOsName = envUtils_1.envUtils.getOsName, lib$2.getOsNameWeb = envUtils_1.envUtils.getOsNameWeb, lib$2.getOsFamily = envUtils_1.envUtils.getOsFamily, lib$2.getJWSPublicKey = envUtils_1.envUtils.getJWSPublicKey;
  return lib$2;
}
var hasRequiredSystemInfo;
function requireSystemInfo() {
  if (hasRequiredSystemInfo) return systemInfo;
  hasRequiredSystemInfo = 1;
  Object.defineProperty(systemInfo, "__esModule", { value: true });
  systemInfo.getSystemInfo = systemInfo.getInstallerPackage = void 0;
  const env_utils_1 = requireLib$3();
  const getInstallerPackage = () => {
    const agent = (0, env_utils_1.getUserAgent)();
    switch ((0, env_utils_1.getOsFamily)()) {
      case "MacOS":
        return "mac";
      case "Windows": {
        const arch = agent.match(/(Win64|WOW64)/) ? "64" : "32";
        return `win${arch}`;
      }
      case "Linux": {
        const isRpm = agent.match(/CentOS|Fedora|Mandriva|Mageia|Red Hat|Scientific|SUSE/) ? "rpm" : "deb";
        const is64x = agent.match(/Linux i[3456]86/) ? "32" : "64";
        return `${isRpm}${is64x}`;
      }
    }
  };
  systemInfo.getInstallerPackage = getInstallerPackage;
  const getSystemInfo = (supportedBrowsers) => {
    const browserName = (0, env_utils_1.getBrowserName)();
    const browserVersion = (0, env_utils_1.getBrowserVersion)();
    const supportedBrowser = browserName ? supportedBrowsers[browserName.toLowerCase()] : void 0;
    const outdatedBrowser = supportedBrowser ? supportedBrowser.version > parseInt(browserVersion, 10) : false;
    const mobile = (0, env_utils_1.getDeviceType)() === "mobile";
    const supportedMobile = mobile ? "usb" in navigator : true;
    const supported = !!(supportedBrowser && !outdatedBrowser && supportedMobile);
    return {
      os: {
        family: (0, env_utils_1.getOsFamily)(),
        mobile
      },
      browser: {
        supported,
        outdated: outdatedBrowser
      }
    };
  };
  systemInfo.getSystemInfo = getSystemInfo;
  return systemInfo;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$3;
  hasRequiredLib$2 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_12 = require$$0;
    tslib_12.__exportStar(requireStorage(), exports2);
    tslib_12.__exportStar(requireAbstract(), exports2);
    tslib_12.__exportStar(requireSystemInfo(), exports2);
  })(lib$3);
  return lib$3;
}
var hasRequiredServiceworkerWindow;
function requireServiceworkerWindow() {
  if (hasRequiredServiceworkerWindow) return serviceworkerWindow;
  hasRequiredServiceworkerWindow = 1;
  Object.defineProperty(serviceworkerWindow, "__esModule", { value: true });
  serviceworkerWindow.ServiceWorkerWindowChannel = void 0;
  const connect_common_1 = requireLib$2();
  class ServiceWorkerWindowChannel extends connect_common_1.AbstractMessageChannel {
    constructor({ name, channel, logger, lazyHandshake, legacyMode, allowSelfOrigin = false, currentId }) {
      super({
        channel,
        sendFn: (message2) => {
          if (!this.port)
            throw new Error("port not assigned");
          this.port.postMessage(message2);
        },
        logger,
        lazyHandshake,
        legacyMode
      });
      this.name = name;
      this.allowSelfOrigin = allowSelfOrigin;
      this.currentId = currentId;
      this.connect();
    }
    connect() {
      chrome.runtime.onConnect.addListener((port) => {
        var _a, _b, _c, _d;
        if (port.name !== this.name)
          return;
        if (((_a = this.currentId) === null || _a === void 0 ? void 0 : _a.call(this)) && ((_b = this.currentId) === null || _b === void 0 ? void 0 : _b.call(this)) !== ((_d = (_c = port.sender) === null || _c === void 0 ? void 0 : _c.tab) === null || _d === void 0 ? void 0 : _d.id))
          return;
        this.port = port;
        this.port.onMessage.addListener((message2, { sender }) => {
          var _a2, _b2, _c2, _d2, _e;
          if (!sender) {
            (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.error("service-worker-window", "no sender");
            return;
          }
          const { origin } = sender;
          const whitelist = [
            "https://connect.trezor.io",
            "https://staging-connect.trezor.io",
            "https://suite.corp.sldev.cz",
            "https://dev.suite.sldev.cz",
            "http://localhost:8088"
          ];
          const webextensionId = (_b2 = chrome === null || chrome === void 0 ? void 0 : chrome.runtime) === null || _b2 === void 0 ? void 0 : _b2.id;
          if (webextensionId) {
            whitelist.push(`chrome-extension://${webextensionId}`);
          }
          const webextensionUrl = (_c2 = chrome === null || chrome === void 0 ? void 0 : chrome.runtime) === null || _c2 === void 0 ? void 0 : _c2.getURL("");
          if (webextensionUrl) {
            whitelist.push(webextensionUrl.slice(0, -1));
          }
          if (!origin) {
            (_d2 = this.logger) === null || _d2 === void 0 ? void 0 : _d2.error("connect-webextension/messageChannel/extensionPort/onMessage", "no origin");
            return;
          }
          if (!whitelist.includes(origin)) {
            (_e = this.logger) === null || _e === void 0 ? void 0 : _e.error("connect-webextension/messageChannel/extensionPort/onMessage", "origin not whitelisted", origin);
            return;
          }
          if (origin === self.origin && !this.allowSelfOrigin) {
            return;
          }
          this.onMessage(message2);
        });
      });
      this.isConnected = true;
    }
    disconnect() {
      var _a;
      if (!this.isConnected)
        return;
      (_a = this.port) === null || _a === void 0 ? void 0 : _a.disconnect();
      this.clear();
      this.isConnected = false;
    }
  }
  serviceworkerWindow.ServiceWorkerWindowChannel = ServiceWorkerWindowChannel;
  return serviceworkerWindow;
}
var windowWindow = {};
var hasRequiredWindowWindow;
function requireWindowWindow() {
  if (hasRequiredWindowWindow) return windowWindow;
  hasRequiredWindowWindow = 1;
  Object.defineProperty(windowWindow, "__esModule", { value: true });
  windowWindow.WindowWindowChannel = void 0;
  const connect_common_1 = requireLib$2();
  class WindowWindowChannel extends connect_common_1.AbstractMessageChannel {
    constructor({ windowHere, windowPeer, channel, logger, origin, legacyMode }) {
      super({
        channel,
        sendFn: (message2) => {
          var _a;
          (_a = windowPeer()) === null || _a === void 0 ? void 0 : _a.postMessage(message2, origin);
        },
        logger,
        legacyMode
      });
      this._listener = this.listener.bind(this);
      this._windowHere = windowHere;
      this.connect();
    }
    listener(event) {
      const message2 = Object.assign(Object.assign({}, event.data), { success: true, origin: event.origin, payload: event.data.payload || {}, channel: event.data.channel || {
        peer: this.channel.here,
        here: this.channel.peer
      } });
      this.onMessage(message2);
    }
    connect() {
      this._windowHere.addEventListener("message", this._listener);
      this.isConnected = true;
    }
    disconnect() {
      if (!this.isConnected)
        return;
      this._windowHere.removeEventListener("message", this._listener);
      this.isConnected = false;
    }
  }
  windowWindow.WindowWindowChannel = WindowWindowChannel;
  return windowWindow;
}
var hasRequiredPopup;
function requirePopup() {
  if (hasRequiredPopup) return popup$2;
  hasRequiredPopup = 1;
  Object.defineProperty(popup$2, "__esModule", { value: true });
  popup$2.PopupManager = void 0;
  const tslib_12 = require$$0;
  const events_12 = tslib_12.__importDefault(eventsExports);
  const utils_12 = requireLib$4();
  const events_22 = events;
  const urlUtils_1 = requireUrlUtils();
  const showPopupRequest_1 = requireShowPopupRequest();
  const serviceworker_window_1 = requireServiceworkerWindow();
  const window_window_1 = requireWindowWindow();
  const checkIfTabExists = (tabId) => new Promise((resolve) => {
    if (!tabId)
      return resolve(false);
    function callback() {
      if (chrome.runtime.lastError) {
        resolve(false);
      } else {
        resolve(true);
      }
    }
    chrome.tabs.get(tabId, callback);
  });
  const POPUP_REQUEST_TIMEOUT = 850;
  const POPUP_CLOSE_INTERVAL = 500;
  const POPUP_OPEN_TIMEOUT = 5e3;
  class PopupManager extends events_12.default {
    constructor(settings2, { logger }) {
      var _a;
      super();
      this.locked = false;
      this.extensionTabId = 0;
      this.injectContentScript = (tabId) => {
        chrome.permissions.getAll((permissions) => {
          var _a2;
          if ((_a2 = permissions.permissions) === null || _a2 === void 0 ? void 0 : _a2.includes("scripting")) {
            (0, utils_12.scheduleAction)(() => chrome.scripting.executeScript({
              target: { tabId },
              func: () => {
              }
            }).then(() => {
              this.logger.debug("content script injected");
            }).catch((error) => {
              this.logger.error("content script injection error", error);
              throw error;
            }), { attempts: new Array(3).fill({ timeout: 100 }) });
          }
        });
      };
      this.settings = settings2;
      this.origin = (0, urlUtils_1.getOrigin)(settings2.popupSrc);
      this.logger = logger;
      if (this.isWebExtensionWithTab()) {
        this.channel = new serviceworker_window_1.ServiceWorkerWindowChannel({
          name: "trezor-connect",
          channel: {
            here: "@trezor/connect-webextension",
            peer: "@trezor/connect-content-script"
          },
          logger,
          currentId: () => {
            var _a2, _b;
            if (((_a2 = this.popupWindow) === null || _a2 === void 0 ? void 0 : _a2.mode) === "tab")
              return (_b = this.popupWindow) === null || _b === void 0 ? void 0 : _b.tab.id;
          },
          legacyMode: !this.settings.useCoreInPopup
        });
      } else {
        this.channel = new window_window_1.WindowWindowChannel({
          windowHere: window,
          windowPeer: () => {
            var _a2, _b;
            if (((_a2 = this.popupWindow) === null || _a2 === void 0 ? void 0 : _a2.mode) === "window")
              return (_b = this.popupWindow) === null || _b === void 0 ? void 0 : _b.window;
          },
          channel: {
            here: "@trezor/connect-web",
            peer: "@trezor/connect-popup"
          },
          logger,
          origin: this.origin,
          legacyMode: !this.settings.useCoreInPopup
        });
      }
      if (!this.settings.useCoreInPopup) {
        this.iframeHandshakePromise = (0, utils_12.createDeferred)(events_22.IFRAME.LOADED);
        this.channelIframe = new window_window_1.WindowWindowChannel({
          windowHere: window,
          windowPeer: () => window,
          channel: {
            here: "@trezor/connect-web",
            peer: "@trezor/connect-iframe"
          },
          logger,
          origin: this.origin
        });
        (_a = this.channelIframe) === null || _a === void 0 ? void 0 : _a.on("message", this.handleMessage.bind(this));
      }
      if (this.settings.useCoreInPopup) {
        this.handshakePromise = (0, utils_12.createDeferred)();
        this.channel.on("message", this.handleCoreMessage.bind(this));
        return;
      } else if (this.isWebExtensionWithTab()) {
        this.channel.on("message", this.handleExtensionMessage.bind(this));
      } else {
        this.channel.on("message", this.handleMessage.bind(this));
      }
      this.channel.init();
    }
    async request() {
      var _a, _b, _c, _d, _f;
      if (this.settings.useCoreInPopup && ((_a = this.popupWindow) === null || _a === void 0 ? void 0 : _a.mode) === "tab") {
        const currentPopupExists = await checkIfTabExists((_c = (_b = this.popupWindow) === null || _b === void 0 ? void 0 : _b.tab) === null || _c === void 0 ? void 0 : _c.id);
        if (!currentPopupExists) {
          this.clear();
        }
      }
      if (this.locked) {
        if (((_d = this.popupWindow) === null || _d === void 0 ? void 0 : _d.mode) === "tab" && this.popupWindow.tab.id) {
          chrome.tabs.update(this.popupWindow.tab.id, { active: true });
        } else if (((_f = this.popupWindow) === null || _f === void 0 ? void 0 : _f.mode) === "window") {
          this.popupWindow.window.focus();
        }
        return;
      }
      if (this.popupWindow && !this.locked) {
        this.close();
      }
      const openFn = this.open.bind(this);
      this.locked = true;
      const timeout = this.settings.env === "webextension" ? 1 : POPUP_REQUEST_TIMEOUT;
      this.requestTimeout = setTimeout(() => {
        this.requestTimeout = void 0;
        openFn();
      }, timeout);
    }
    unlock() {
      this.locked = false;
    }
    open() {
      const src2 = this.settings.popupSrc;
      this.popupPromise = (0, utils_12.createDeferred)(events_22.POPUP.LOADED);
      this.openWrapper(src2);
      if (this.settings.useCoreInPopup) {
        return;
      }
      this.closeInterval = setInterval(() => {
        if (!this.popupWindow)
          return;
        if (this.popupWindow.mode === "tab" && this.popupWindow.tab.id) {
          chrome.tabs.get(this.popupWindow.tab.id, (tab) => {
            if (!tab) {
              this.emitClosed();
              this.clear();
            }
          });
        } else if (this.popupWindow.mode === "window" && this.popupWindow.window.closed) {
          this.clear();
          this.emitClosed();
        }
      }, POPUP_CLOSE_INTERVAL);
      if (this.settings.useCoreInPopup) {
        return;
      }
      this.openTimeout = setTimeout(() => {
        this.clear();
        (0, showPopupRequest_1.showPopupRequest)(this.open.bind(this), () => {
          this.emitClosed();
        });
      }, POPUP_OPEN_TIMEOUT);
    }
    openWrapper(url) {
      if (this.isWebExtensionWithTab()) {
        chrome.windows.getCurrent((currentWindow) => {
          this.logger.debug("opening popup. currentWindow: ", currentWindow);
          if (currentWindow.type !== "normal") {
            chrome.windows.create({ url }, (newWindow) => {
              chrome.tabs.query({
                windowId: newWindow === null || newWindow === void 0 ? void 0 : newWindow.id,
                active: true
              }, (tabs) => {
                this.popupWindow = { mode: "tab", tab: tabs[0] };
                this.injectContentScript(tabs[0].id);
              });
            });
          } else {
            chrome.tabs.query({
              currentWindow: true,
              active: true
            }, (tabs) => {
              this.extensionTabId = tabs[0].id;
              chrome.tabs.create({
                url,
                index: tabs[0].index + 1
              }, (tab) => {
                this.popupWindow = { mode: "tab", tab };
                this.injectContentScript(tab.id);
              });
            });
          }
        });
      } else {
        const windowResult = window.open(url, "modal");
        if (!windowResult)
          return;
        this.popupWindow = { mode: "window", window: windowResult };
      }
      if (!this.channel.isConnected) {
        this.channel.connect();
      }
    }
    handleCoreMessage(message2) {
      var _a;
      if (message2.type === events_22.POPUP.BOOTSTRAP) {
        this.channel.init();
      } else if (message2.type === events_22.POPUP.LOADED) {
        this.handleMessage(message2);
        this.channel.postMessage({
          type: events_22.POPUP.INIT,
          payload: {
            settings: this.settings,
            useCore: true
          }
        });
      } else if (message2.type === events_22.POPUP.CORE_LOADED) {
        this.channel.postMessage({
          type: events_22.POPUP.HANDSHAKE,
          payload: { settings: this.settings }
        });
        (_a = this.handshakePromise) === null || _a === void 0 ? void 0 : _a.resolve();
      } else if (message2.type === events_22.POPUP.CLOSED) {
        this.emitClosed();
      }
    }
    handleExtensionMessage(data) {
      if (data.type === events_22.POPUP.ERROR || data.type === events_22.POPUP.LOADED || data.type === events_22.POPUP.BOOTSTRAP) {
        this.handleMessage(data);
      } else if (data.type === events_22.POPUP.EXTENSION_USB_PERMISSIONS) {
        chrome.tabs.query({
          currentWindow: true,
          active: true
        }, (tabs) => {
          chrome.tabs.create({
            url: "trezor-usb-permissions.html",
            index: tabs[0].index + 1
          }, (_tab) => {
          });
        });
      } else if (data.type === events_22.POPUP.CLOSE_WINDOW) {
        this.clear();
      }
    }
    handleMessage(data) {
      var _a, _b;
      if (data.type === events_22.IFRAME.LOADED) {
        (_a = this.iframeHandshakePromise) === null || _a === void 0 ? void 0 : _a.resolve(data.payload);
      } else if (data.type === events_22.POPUP.BOOTSTRAP) {
        if (this.openTimeout)
          clearTimeout(this.openTimeout);
      } else if (data.type === events_22.POPUP.ERROR && this.popupWindow) {
        const errorMessage = data.payload && typeof data.payload.error === "string" ? data.payload.error : null;
        this.emit(events_22.POPUP.CLOSED, errorMessage ? `Popup error: ${errorMessage}` : null);
        this.clear();
      } else if (data.type === events_22.POPUP.LOADED) {
        if (this.openTimeout)
          clearTimeout(this.openTimeout);
        if (this.popupPromise) {
          this.popupPromise.resolve();
          this.popupPromise = void 0;
        }
        (_b = this.iframeHandshakePromise) === null || _b === void 0 ? void 0 : _b.promise.then((payload) => {
          this.channel.postMessage({
            type: events_22.POPUP.INIT,
            payload: Object.assign(Object.assign({}, payload), { settings: this.settings })
          });
        });
      } else if (data.type === events_22.POPUP.CANCEL_POPUP_REQUEST) {
        clearTimeout(this.requestTimeout);
        if (this.popupPromise) {
          this.close();
        }
      } else if (data.type === events_22.UI.CLOSE_UI_WINDOW) {
        this.clear(false);
      }
    }
    clear(focus = true) {
      this.locked = false;
      this.popupPromise = void 0;
      this.handshakePromise = (0, utils_12.createDeferred)();
      if (this.channel) {
        this.channel.disconnect();
      }
      if (this.requestTimeout) {
        clearTimeout(this.requestTimeout);
        this.requestTimeout = void 0;
      }
      if (this.openTimeout) {
        clearTimeout(this.openTimeout);
        this.openTimeout = void 0;
      }
      if (this.closeInterval) {
        clearInterval(this.closeInterval);
        this.closeInterval = void 0;
      }
      if (focus && this.extensionTabId) {
        chrome.tabs.update(this.extensionTabId, { active: true });
        this.extensionTabId = 0;
      }
    }
    close() {
      var _a;
      if (!this.popupWindow)
        return;
      this.logger.debug("closing popup");
      if (this.popupWindow.mode === "tab") {
        let _e = chrome.runtime.lastError;
        if (this.popupWindow.tab.id) {
          chrome.tabs.remove(this.popupWindow.tab.id, () => {
            _e = chrome.runtime.lastError;
            if (_e) {
              this.logger.error("closed with error", _e);
            }
          });
        }
      } else if (this.popupWindow.mode === "window") {
        this.popupWindow.window.close();
      }
      this.popupWindow = void 0;
      if ((_a = this.settings) === null || _a === void 0 ? void 0 : _a.useCoreInPopup) {
        this.channel.clear();
      }
    }
    async postMessage(message2) {
      var _a, _b;
      if (!this.popupWindow && message2.type !== events_22.UI.REQUEST_UI_WINDOW && this.openTimeout) {
        this.clear();
        (0, showPopupRequest_1.showPopupRequest)(this.open.bind(this), () => {
          this.emitClosed();
        });
        return;
      }
      if (this.popupPromise) {
        await this.popupPromise.promise;
      }
      if (((_a = this.popupWindow) === null || _a === void 0 ? void 0 : _a.mode) === "window") {
        this.popupWindow.window.postMessage(message2, this.origin);
      } else if (((_b = this.popupWindow) === null || _b === void 0 ? void 0 : _b.mode) === "tab") {
        this.channel.postMessage(message2);
      }
    }
    isWebExtensionWithTab() {
      var _a;
      return ((_a = this.settings) === null || _a === void 0 ? void 0 : _a.env) === "webextension" && typeof chrome !== "undefined" && typeof (chrome === null || chrome === void 0 ? void 0 : chrome.tabs) !== "undefined";
    }
    emitClosed() {
      var _a;
      if ((_a = this.settings) === null || _a === void 0 ? void 0 : _a.useCoreInPopup) {
        this.channel.resolveMessagePromises({
          code: "Method_Interrupted",
          error: events_22.POPUP.CLOSED
        });
      }
      this.emit(events_22.POPUP.CLOSED);
    }
  }
  popup$2.PopupManager = PopupManager;
  return popup$2;
}
var button = {};
var hasRequiredButton;
function requireButton() {
  if (hasRequiredButton) return button;
  hasRequiredButton = 1;
  Object.defineProperty(button, "__esModule", { value: true });
  const render = (className = "", url) => {
    const query = className || ".trezor-webusb-button";
    const buttons = document.querySelectorAll(query);
    const src2 = `${url}?${Date.now()}`;
    buttons.forEach((b) => {
      if (b.getElementsByTagName("iframe").length < 1) {
        const bounds = b.getBoundingClientRect();
        const btnIframe = document.createElement("iframe");
        btnIframe.frameBorder = "0";
        btnIframe.width = `${Math.round(bounds.width)}px`;
        btnIframe.height = `${Math.round(bounds.height)}px`;
        btnIframe.style.position = "absolute";
        btnIframe.style.top = "0px";
        btnIframe.style.left = "0px";
        btnIframe.style.zIndex = "1";
        btnIframe.setAttribute("allow", "usb");
        btnIframe.setAttribute("scrolling", "no");
        btnIframe.src = src2;
        b.append(btnIframe);
      }
    });
  };
  button.default = render;
  return button;
}
var connectSettings$1 = {};
var connectSettings = {};
var version = {};
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version;
  hasRequiredVersion = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_DOMAIN = exports2.VERSION = void 0;
    exports2.VERSION = "9.3.0";
    const versionN = exports2.VERSION.split(".").map((s) => parseInt(s, 10));
    const isBeta = exports2.VERSION.includes("beta");
    exports2.DEFAULT_DOMAIN = isBeta ? `https://connect.trezor.io/${exports2.VERSION}/` : `https://connect.trezor.io/${versionN[0]}/`;
  })(version);
  return version;
}
var hasRequiredConnectSettings$1;
function requireConnectSettings$1() {
  if (hasRequiredConnectSettings$1) return connectSettings;
  hasRequiredConnectSettings$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseConnectSettings = exports2.corsValidator = exports2.DEFAULT_PRIORITY = void 0;
    const version_1 = requireVersion();
    exports2.DEFAULT_PRIORITY = 2;
    const initialSettings = {
      configSrc: "./data/config.json",
      version: version_1.VERSION,
      debug: false,
      priority: exports2.DEFAULT_PRIORITY,
      trustedHost: true,
      connectSrc: version_1.DEFAULT_DOMAIN,
      iframeSrc: `${version_1.DEFAULT_DOMAIN}iframe.html`,
      popup: false,
      popupSrc: `${version_1.DEFAULT_DOMAIN}popup.html`,
      webusbSrc: `${version_1.DEFAULT_DOMAIN}webusb.html`,
      transports: void 0,
      pendingTransportEvent: true,
      env: "node",
      lazyLoad: false,
      timestamp: (/* @__PURE__ */ new Date()).getTime(),
      interactionTimeout: 600,
      sharedLogger: true
    };
    const parseManifest = (manifest) => {
      if (!manifest)
        return;
      if (typeof manifest.email !== "string")
        return;
      if (typeof manifest.appUrl !== "string")
        return;
      return {
        email: manifest.email,
        appUrl: manifest.appUrl
      };
    };
    const corsValidator = (url) => {
      if (typeof url !== "string")
        return;
      if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*trezor\.io\//))
        return url;
      if (url.match(/^https?:\/\/localhost:[58][0-9]{3}\//))
        return url;
      if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*sldev\.cz\//))
        return url;
      if (url.match(/^https?:\/\/([A-Za-z0-9\-_]+\.)*trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad\.onion\//))
        return url;
    };
    exports2.corsValidator = corsValidator;
    const parseConnectSettings = (input = {}) => {
      var _a;
      const settings2 = { ...initialSettings };
      if ("debug" in input) {
        if (typeof input.debug === "boolean") {
          settings2.debug = input.debug;
        } else if (typeof input.debug === "string") {
          settings2.debug = input.debug === "true";
        }
      }
      if (input.trustedHost === false) {
        settings2.trustedHost = input.trustedHost;
      }
      if (typeof input.connectSrc === "string" && ((_a = input.connectSrc) === null || _a === void 0 ? void 0 : _a.startsWith("http"))) {
        settings2.connectSrc = (0, exports2.corsValidator)(input.connectSrc);
      } else if (settings2.trustedHost) {
        settings2.connectSrc = input.connectSrc;
      }
      const src2 = settings2.connectSrc || version_1.DEFAULT_DOMAIN;
      settings2.iframeSrc = `${src2}iframe.html`;
      settings2.popupSrc = `${src2}popup.html`;
      settings2.webusbSrc = `${src2}webusb.html`;
      if (typeof input.transportReconnect === "boolean") {
        settings2.transportReconnect = input.transportReconnect;
      }
      if (typeof input.webusb === "boolean") {
        settings2.webusb = input.webusb;
      }
      if (Array.isArray(input.transports)) {
        settings2.transports = input.transports;
      }
      if (typeof input.popup === "boolean") {
        settings2.popup = input.popup;
      }
      if (typeof input.lazyLoad === "boolean") {
        settings2.lazyLoad = input.lazyLoad;
      }
      if (typeof input.pendingTransportEvent === "boolean") {
        settings2.pendingTransportEvent = input.pendingTransportEvent;
      }
      if (typeof input.extension === "string") {
        settings2.extension = input.extension;
      }
      if (typeof input.env === "string") {
        settings2.env = input.env;
      }
      if (typeof input.timestamp === "number") {
        settings2.timestamp = input.timestamp;
      }
      if (typeof input.interactionTimeout === "number") {
        settings2.interactionTimeout = input.interactionTimeout;
      }
      if (typeof input.manifest === "object") {
        settings2.manifest = parseManifest(input.manifest);
      }
      if (typeof input.sharedLogger === "boolean") {
        settings2.sharedLogger = input.sharedLogger;
      }
      if (typeof input.useCoreInPopup === "boolean") {
        settings2.useCoreInPopup = input.useCoreInPopup;
      }
      if (typeof input._extendWebextensionLifetime === "boolean") {
        settings2._extendWebextensionLifetime = input._extendWebextensionLifetime;
      }
      return settings2;
    };
    exports2.parseConnectSettings = parseConnectSettings;
  })(connectSettings);
  return connectSettings;
}
var hasRequiredConnectSettings;
function requireConnectSettings() {
  if (hasRequiredConnectSettings) return connectSettings$1;
  hasRequiredConnectSettings = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseConnectSettings = exports2.getEnv = void 0;
    const connectSettings_12 = requireConnectSettings$1();
    const getEnv = () => {
      var _a;
      if (typeof chrome !== "undefined" && typeof ((_a = chrome.runtime) === null || _a === void 0 ? void 0 : _a.onConnect) !== "undefined") {
        return "webextension";
      }
      if (typeof navigator !== "undefined") {
        if (typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative") {
          return "react-native";
        }
        const userAgent = navigator.userAgent.toLowerCase();
        if (userAgent.indexOf(" electron/") > -1) {
          return "electron";
        }
      }
      return "web";
    };
    exports2.getEnv = getEnv;
    const processQueryString = (url, keys) => {
      const searchParams = new URLSearchParams(url);
      const result = {};
      const paramArray = Array.from(searchParams.entries());
      paramArray.forEach(([key, value]) => {
        if (keys.includes(key)) {
          result[key] = decodeURIComponent(value);
        }
      });
      return result;
    };
    const parseConnectSettings = (input = {}) => {
      var _a;
      const settings2 = Object.assign({ popup: true }, input);
      let globalSrc;
      if (typeof window !== "undefined") {
        globalSrc = window.__TREZOR_CONNECT_SRC;
      } else if (typeof commonjsGlobal !== "undefined") {
        globalSrc = commonjsGlobal.__TREZOR_CONNECT_SRC;
      }
      if (typeof globalSrc === "string") {
        settings2.connectSrc = globalSrc;
        settings2.debug = true;
      }
      if (typeof window !== "undefined" && typeof ((_a = window.location) === null || _a === void 0 ? void 0 : _a.search) === "string") {
        const query = processQueryString(window.location.search, ["trezor-connect-src"]);
        if (query["trezor-connect-src"]) {
          settings2.debug = true;
          settings2.connectSrc = query["trezor-connect-src"];
        }
      }
      if (typeof input.env !== "string") {
        settings2.env = (0, exports2.getEnv)();
      }
      return (0, connectSettings_12.parseConnectSettings)(settings2);
    };
    exports2.parseConnectSettings = parseConnectSettings;
  })(connectSettings$1);
  return connectSettings$1;
}
Object.defineProperty(coreInIframe, "__esModule", { value: true });
coreInIframe.TrezorConnect = coreInIframe.CoreInIframe = void 0;
const tslib_1$1 = require$$0;
const events_1$1 = tslib_1$1.__importDefault(eventsExports);
const ERRORS$1 = tslib_1$1.__importStar(requireErrors$3());
const events_2$1 = events;
const factory_1$1 = factory$1;
const debug_1$1 = requireDebug();
const config_1 = requireConfig();
const createDeferredManager_1 = requireCreateDeferredManager();
const iframe = tslib_1$1.__importStar(requireIframe());
const popup$1 = tslib_1$1.__importStar(requirePopup());
const button_1 = tslib_1$1.__importDefault(requireButton());
const connectSettings_1$1 = requireConnectSettings();
class CoreInIframe {
  constructor() {
    this.eventEmitter = new events_1$1.default();
    this.boundHandleMessage = this.handleMessage.bind(this);
    this.boundDispose = this.dispose.bind(this);
    this._settings = (0, connectSettings_1$1.parseConnectSettings)();
    this._log = (0, debug_1$1.initLog)("@trezor/connect-web");
    this._messagePromises = (0, createDeferredManager_1.createDeferredManager)({ initialId: 1 });
  }
  initPopupManager() {
    const pm = new popup$1.PopupManager(this._settings, { logger: this._log });
    pm.on(events_2$1.POPUP.CLOSED, (error) => {
      iframe.postMessage({
        type: events_2$1.POPUP.CLOSED,
        payload: error ? { error } : null
      });
    });
    return pm;
  }
  manifest(data) {
    this._settings = (0, connectSettings_1$1.parseConnectSettings)(Object.assign(Object.assign({}, this._settings), { manifest: data }));
  }
  dispose() {
    this.eventEmitter.removeAllListeners();
    iframe.dispose();
    this._settings = (0, connectSettings_1$1.parseConnectSettings)();
    if (this._popupManager) {
      this._popupManager.close();
    }
    window.removeEventListener("message", this.boundHandleMessage);
    window.removeEventListener("unload", this.boundDispose);
    return Promise.resolve(void 0);
  }
  cancel(error) {
    if (this._popupManager) {
      this._popupManager.emit(events_2$1.POPUP.CLOSED, error);
    }
  }
  handleMessage(messageEvent) {
    if (messageEvent.origin !== iframe.origin)
      return;
    const message2 = (0, events_2$1.parseMessage)(messageEvent.data);
    this._log.log("handleMessage", message2);
    switch (message2.event) {
      case events_2$1.RESPONSE_EVENT: {
        const { id: id2 = 0, success, payload } = message2;
        const resolved = this._messagePromises.resolve(id2, { id: id2, success, payload });
        if (!resolved)
          this._log.warn(`Unknown message id ${id2}`);
        break;
      }
      case events_2$1.DEVICE_EVENT:
        this.eventEmitter.emit(message2.event, message2);
        this.eventEmitter.emit(message2.type, message2.payload);
        break;
      case events_2$1.TRANSPORT_EVENT:
        this.eventEmitter.emit(message2.event, message2);
        this.eventEmitter.emit(message2.type, message2.payload);
        break;
      case events_2$1.BLOCKCHAIN_EVENT:
        this.eventEmitter.emit(message2.event, message2);
        this.eventEmitter.emit(message2.type, message2.payload);
        break;
      case events_2$1.UI_EVENT:
        if (message2.type === events_2$1.IFRAME.BOOTSTRAP) {
          iframe.clearTimeout();
          break;
        }
        if (message2.type === events_2$1.IFRAME.LOADED) {
          iframe.initPromise.resolve();
        }
        if (message2.type === events_2$1.IFRAME.ERROR) {
          iframe.initPromise.reject(message2.payload.error);
        }
        this.eventEmitter.emit(message2.event, message2);
        this.eventEmitter.emit(message2.type, message2.payload);
        break;
      default:
        this._log.log("Undefined message", messageEvent.data);
    }
  }
  async init(settings2 = {}) {
    var _a;
    if (iframe.instance) {
      throw ERRORS$1.TypedError("Init_AlreadyInitialized");
    }
    this._settings = (0, connectSettings_1$1.parseConnectSettings)(Object.assign(Object.assign({}, this._settings), settings2));
    if (!this._settings.manifest) {
      throw ERRORS$1.TypedError("Init_ManifestMissing");
    }
    if (!((_a = this._settings.transports) === null || _a === void 0 ? void 0 : _a.length)) {
      this._settings.transports = ["BridgeTransport", "WebUsbTransport"];
    }
    if (this._settings.lazyLoad) {
      this._settings.lazyLoad = false;
      return;
    }
    if (!this._popupManager) {
      this._popupManager = this.initPopupManager();
    }
    this._log.enabled = !!this._settings.debug;
    window.addEventListener("message", this.boundHandleMessage);
    window.addEventListener("unload", this.boundDispose);
    await iframe.init(this._settings);
    if (this._settings.sharedLogger !== false) {
      iframe.initIframeLogger();
    }
  }
  async call(params2) {
    if (!iframe.instance && !iframe.timeout) {
      this._settings = (0, connectSettings_1$1.parseConnectSettings)(this._settings);
      if (!this._settings.manifest) {
        return (0, events_2$1.createErrorMessage)(ERRORS$1.TypedError("Init_ManifestMissing"));
      }
      if (!this._popupManager) {
        this._popupManager = this.initPopupManager();
      }
      this._popupManager.request();
      try {
        await this.init(this._settings);
      } catch (error) {
        if (this._popupManager) {
          if (["Init_IframeBlocked", "Init_IframeTimeout"].includes(error.code)) {
            this._popupManager.postMessage((0, events_2$1.createUiMessage)(events_2$1.UI.IFRAME_FAILURE));
          } else {
            this._popupManager.clear();
          }
        }
        return (0, events_2$1.createErrorMessage)(error);
      }
    }
    if (iframe.timeout) {
      await iframe.initPromise.promise;
    }
    if (iframe.error) {
      return (0, events_2$1.createErrorMessage)(iframe.error);
    }
    if (this._settings.popup && this._popupManager) {
      this._popupManager.request();
    }
    try {
      const { promiseId, promise } = this._messagePromises.create();
      iframe.postMessage({ id: promiseId, type: events_2$1.IFRAME.CALL, payload: params2 });
      const response = await promise;
      if (response) {
        if (!response.success && response.payload.code !== "Device_CallInProgress" && this._popupManager) {
          this._popupManager.unlock();
        }
        return response;
      }
      if (this._popupManager) {
        this._popupManager.unlock();
      }
      return (0, events_2$1.createErrorMessage)(ERRORS$1.TypedError("Method_NoResponse"));
    } catch (error) {
      this._log.error("__call error", error);
      if (this._popupManager) {
        this._popupManager.clear(false);
      }
      return (0, events_2$1.createErrorMessage)(error);
    }
  }
  uiResponse(response) {
    if (!iframe.instance) {
      throw ERRORS$1.TypedError("Init_NotInitialized");
    }
    iframe.postMessage(response);
  }
  renderWebUSBButton(className) {
    (0, button_1.default)(className, this._settings.webusbSrc);
  }
  async requestLogin(params2) {
    if (typeof params2.callback === "function") {
      const { callback } = params2;
      const loginChallengeListener = async (event) => {
        const { data } = event;
        if (data && data.type === events_2$1.UI.LOGIN_CHALLENGE_REQUEST) {
          try {
            const payload = await callback();
            iframe.postMessage({
              type: events_2$1.UI.LOGIN_CHALLENGE_RESPONSE,
              payload
            });
          } catch (error) {
            iframe.postMessage({
              type: events_2$1.UI.LOGIN_CHALLENGE_RESPONSE,
              payload: error.message
            });
          }
        }
      };
      window.addEventListener("message", loginChallengeListener, false);
      const response = await this.call(Object.assign(Object.assign({ method: "requestLogin" }, params2), { asyncChallenge: true, callback: null }));
      window.removeEventListener("message", loginChallengeListener);
      return response;
    }
    return this.call(Object.assign({ method: "requestLogin" }, params2));
  }
  disableWebUSB() {
    if (!iframe.instance) {
      throw ERRORS$1.TypedError("Init_NotInitialized");
    }
    iframe.postMessage({ type: events_2$1.TRANSPORT.DISABLE_WEBUSB });
  }
  async requestWebUSBDevice() {
    try {
      await window.navigator.usb.requestDevice({ filters: config_1.config.webusb });
      iframe.postMessage({ type: events_2$1.TRANSPORT.REQUEST_DEVICE });
    } catch (_err) {
    }
  }
}
coreInIframe.CoreInIframe = CoreInIframe;
const methods$1 = new CoreInIframe();
coreInIframe.TrezorConnect = (0, factory_1$1.factory)({
  eventEmitter: methods$1.eventEmitter,
  init: methods$1.init.bind(methods$1),
  call: methods$1.call.bind(methods$1),
  manifest: methods$1.manifest.bind(methods$1),
  requestLogin: methods$1.requestLogin.bind(methods$1),
  uiResponse: methods$1.uiResponse.bind(methods$1),
  renderWebUSBButton: methods$1.renderWebUSBButton.bind(methods$1),
  disableWebUSB: methods$1.disableWebUSB.bind(methods$1),
  requestWebUSBDevice: methods$1.requestWebUSBDevice.bind(methods$1),
  cancel: methods$1.cancel.bind(methods$1),
  dispose: methods$1.dispose.bind(methods$1)
});
var coreInPopup = {};
Object.defineProperty(coreInPopup, "__esModule", { value: true });
coreInPopup.TrezorConnect = coreInPopup.CoreInPopup = void 0;
const tslib_1 = require$$0;
const events_1 = tslib_1.__importDefault(eventsExports);
const events_2 = events;
const ERRORS = tslib_1.__importStar(requireErrors$3());
const factory_1 = factory$1;
const debug_1 = requireDebug();
const popup = tslib_1.__importStar(requirePopup());
const connectSettings_1 = requireConnectSettings();
class CoreInPopup {
  constructor() {
    this.eventEmitter = new events_1.default();
    this._settings = (0, connectSettings_1.parseConnectSettings)();
    this.logger = (0, debug_1.initLog)("@trezor/connect-web");
    this.popupManagerLogger = (0, debug_1.initLog)("@trezor/connect-web/popupManager");
  }
  logWriterFactory(popupManager) {
    return {
      add: (message2) => {
        popupManager.channel.postMessage({
          event: events_2.UI_EVENT,
          type: events_2.IFRAME.LOG,
          payload: message2
        }, { usePromise: false, useQueue: true });
      }
    };
  }
  manifest(data) {
    this._settings = (0, connectSettings_1.parseConnectSettings)(Object.assign(Object.assign({}, this._settings), { manifest: data }));
  }
  dispose() {
    this.eventEmitter.removeAllListeners();
    this._settings = (0, connectSettings_1.parseConnectSettings)();
    if (this._popupManager) {
      this._popupManager.close();
    }
    return Promise.resolve(void 0);
  }
  cancel(error) {
    if (this._popupManager) {
      this._popupManager.emit(events_2.POPUP.CLOSED, error);
    }
  }
  init(settings2 = {}) {
    var _a, _b;
    const oldSettings = (0, connectSettings_1.parseConnectSettings)(Object.assign({}, this._settings));
    const newSettings = (0, connectSettings_1.parseConnectSettings)(Object.assign(Object.assign({}, this._settings), settings2));
    if (!((_a = newSettings.transports) === null || _a === void 0 ? void 0 : _a.length)) {
      newSettings.transports = ["BridgeTransport", "WebUsbTransport"];
    }
    newSettings.useCoreInPopup = true;
    if (typeof window !== "undefined" && ((_b = window === null || window === void 0 ? void 0 : window.location) === null || _b === void 0 ? void 0 : _b.origin)) {
      newSettings.origin = window.location.origin;
    }
    const equalSettings = JSON.stringify(oldSettings) === JSON.stringify(newSettings);
    this._settings = newSettings;
    if (!this._popupManager || !equalSettings) {
      if (this._popupManager)
        this._popupManager.close();
      this._popupManager = new popup.PopupManager(this._settings, {
        logger: this.popupManagerLogger
      });
      (0, debug_1.setLogWriter)(() => this.logWriterFactory(this._popupManager));
    }
    this.logger.enabled = !!settings2.debug;
    if (!this._settings.manifest) {
      throw ERRORS.TypedError("Init_ManifestMissing");
    }
    this.logger.debug("initiated");
    return Promise.resolve();
  }
  async call(params2) {
    var _a, _b;
    this.logger.debug("call", params2);
    if (!this._popupManager) {
      return (0, events_2.createErrorMessage)(ERRORS.TypedError("Init_NotInitialized"));
    }
    if (this._settings.popup) {
      await this._popupManager.request();
    }
    await this._popupManager.channel.init();
    if (this._settings.env === "webextension") {
      await ((_a = this._popupManager.popupPromise) === null || _a === void 0 ? void 0 : _a.promise);
      this._popupManager.channel.postMessage({
        type: events_2.POPUP.INIT,
        payload: {
          settings: this._settings,
          useCore: true
        }
      });
    }
    await ((_b = this._popupManager.handshakePromise) === null || _b === void 0 ? void 0 : _b.promise);
    try {
      const response = await this._popupManager.channel.postMessage({
        type: events_2.IFRAME.CALL,
        payload: params2
      });
      this.logger.debug("call: response: ", response);
      if (response) {
        if (this._popupManager && response.success) {
          this._popupManager.clear();
        }
        return response;
      }
      return (0, events_2.createErrorMessage)(ERRORS.TypedError("Method_NoResponse"));
    } catch (error) {
      this.logger.error("call: error", error);
      this._popupManager.clear(false);
      return (0, events_2.createErrorMessage)(error);
    }
  }
  uiResponse(response) {
    var _a, _b;
    const { type: type2, payload } = response;
    (_b = (_a = this._popupManager) === null || _a === void 0 ? void 0 : _a.channel) === null || _b === void 0 ? void 0 : _b.postMessage({ event: events_2.UI_EVENT, type: type2, payload });
  }
  renderWebUSBButton() {
  }
  requestLogin() {
    throw ERRORS.TypedError("Method_InvalidPackage");
  }
  disableWebUSB() {
    throw ERRORS.TypedError("Method_InvalidPackage");
  }
  requestWebUSBDevice() {
    throw ERRORS.TypedError("Method_InvalidPackage");
  }
}
coreInPopup.CoreInPopup = CoreInPopup;
const methods = new CoreInPopup();
coreInPopup.TrezorConnect = (0, factory_1.factory)({
  eventEmitter: methods.eventEmitter,
  init: methods.init.bind(methods),
  call: methods.call.bind(methods),
  manifest: methods.manifest.bind(methods),
  requestLogin: methods.requestLogin.bind(methods),
  uiResponse: methods.uiResponse.bind(methods),
  renderWebUSBButton: methods.renderWebUSBButton.bind(methods),
  disableWebUSB: methods.disableWebUSB.bind(methods),
  requestWebUSBDevice: methods.requestWebUSBDevice.bind(methods),
  cancel: methods.cancel.bind(methods),
  dispose: methods.dispose.bind(methods)
});
var exports = {};
var constants = {};
var network = {};
var hasRequiredNetwork;
function requireNetwork() {
  if (hasRequiredNetwork) return network;
  hasRequiredNetwork = 1;
  Object.defineProperty(network, "__esModule", { value: true });
  network.MODULES = network.TYPES = void 0;
  network.TYPES = {
    bitcoin: "Bitcoin",
    ethereum: "Ethereum",
    eos: "Eos",
    nem: "NEM",
    stellar: "Stellar",
    cardano: "Cardano",
    ripple: "Ripple",
    tezos: "Tezos",
    binance: "Binance",
    solana: "Solana"
  };
  network.MODULES = [
    "binance",
    "cardano",
    "eos",
    "ethereum",
    "nem",
    "ripple",
    "solana",
    "stellar",
    "tezos"
  ];
  return network;
}
var cardano$1 = {};
var hasRequiredCardano$1;
function requireCardano$1() {
  if (hasRequiredCardano$1) return cardano$1;
  hasRequiredCardano$1 = 1;
  Object.defineProperty(cardano$1, "__esModule", { value: true });
  cardano$1.NETWORK_IDS = cardano$1.PROTOCOL_MAGICS = void 0;
  var PROTOCOL_MAGICS;
  (function(PROTOCOL_MAGICS2) {
    PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["mainnet"] = 764824073] = "mainnet";
    PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["testnet_preprod"] = 1] = "testnet_preprod";
    PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["testnet_preview"] = 2] = "testnet_preview";
    PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["testnet_legacy"] = 1097911063] = "testnet_legacy";
  })(PROTOCOL_MAGICS || (cardano$1.PROTOCOL_MAGICS = PROTOCOL_MAGICS = {}));
  var NETWORK_IDS;
  (function(NETWORK_IDS2) {
    NETWORK_IDS2[NETWORK_IDS2["mainnet"] = 1] = "mainnet";
    NETWORK_IDS2[NETWORK_IDS2["testnet"] = 0] = "testnet";
  })(NETWORK_IDS || (cardano$1.NETWORK_IDS = NETWORK_IDS = {}));
  return cardano$1;
}
var nem = {};
var lib$1 = {};
var typebox = {};
var hasRequiredTypebox;
function requireTypebox() {
  if (hasRequiredTypebox) return typebox;
  hasRequiredTypebox = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Type = exports2.JsonType = exports2.JavaScriptTypeBuilder = exports2.JsonTypeBuilder = exports2.TypeBuilder = exports2.TypeBuilderError = exports2.TransformEncodeBuilder = exports2.TransformDecodeBuilder = exports2.TemplateLiteralDslParser = exports2.TemplateLiteralGenerator = exports2.TemplateLiteralGeneratorError = exports2.TemplateLiteralFinite = exports2.TemplateLiteralFiniteError = exports2.TemplateLiteralParser = exports2.TemplateLiteralParserError = exports2.TemplateLiteralResolver = exports2.TemplateLiteralPattern = exports2.TemplateLiteralPatternError = exports2.UnionResolver = exports2.KeyArrayResolver = exports2.KeyArrayResolverError = exports2.KeyResolver = exports2.ObjectMap = exports2.Intrinsic = exports2.IndexedAccessor = exports2.TypeClone = exports2.TypeExtends = exports2.TypeExtendsResult = exports2.TypeExtendsError = exports2.ExtendsUndefined = exports2.TypeGuard = exports2.TypeGuardUnknownTypeError = exports2.ValueGuard = exports2.FormatRegistry = exports2.TypeBoxError = exports2.TypeRegistry = exports2.PatternStringExact = exports2.PatternNumberExact = exports2.PatternBooleanExact = exports2.PatternString = exports2.PatternNumber = exports2.PatternBoolean = exports2.Kind = exports2.Hint = exports2.Optional = exports2.Readonly = exports2.Transform = void 0;
    exports2.Transform = Symbol.for("TypeBox.Transform");
    exports2.Readonly = Symbol.for("TypeBox.Readonly");
    exports2.Optional = Symbol.for("TypeBox.Optional");
    exports2.Hint = Symbol.for("TypeBox.Hint");
    exports2.Kind = Symbol.for("TypeBox.Kind");
    exports2.PatternBoolean = "(true|false)";
    exports2.PatternNumber = "(0|[1-9][0-9]*)";
    exports2.PatternString = "(.*)";
    exports2.PatternBooleanExact = `^${exports2.PatternBoolean}$`;
    exports2.PatternNumberExact = `^${exports2.PatternNumber}$`;
    exports2.PatternStringExact = `^${exports2.PatternString}$`;
    var TypeRegistry;
    (function(TypeRegistry2) {
      const map2 = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map2);
      }
      TypeRegistry2.Entries = Entries;
      function Clear() {
        return map2.clear();
      }
      TypeRegistry2.Clear = Clear;
      function Delete(kind) {
        return map2.delete(kind);
      }
      TypeRegistry2.Delete = Delete;
      function Has(kind) {
        return map2.has(kind);
      }
      TypeRegistry2.Has = Has;
      function Set2(kind, func) {
        map2.set(kind, func);
      }
      TypeRegistry2.Set = Set2;
      function Get(kind) {
        return map2.get(kind);
      }
      TypeRegistry2.Get = Get;
    })(TypeRegistry || (exports2.TypeRegistry = TypeRegistry = {}));
    class TypeBoxError extends Error {
      constructor(message2) {
        super(message2);
      }
    }
    exports2.TypeBoxError = TypeBoxError;
    var FormatRegistry;
    (function(FormatRegistry2) {
      const map2 = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map2);
      }
      FormatRegistry2.Entries = Entries;
      function Clear() {
        return map2.clear();
      }
      FormatRegistry2.Clear = Clear;
      function Delete(format) {
        return map2.delete(format);
      }
      FormatRegistry2.Delete = Delete;
      function Has(format) {
        return map2.has(format);
      }
      FormatRegistry2.Has = Has;
      function Set2(format, func) {
        map2.set(format, func);
      }
      FormatRegistry2.Set = Set2;
      function Get(format) {
        return map2.get(format);
      }
      FormatRegistry2.Get = Get;
    })(FormatRegistry || (exports2.FormatRegistry = FormatRegistry = {}));
    var ValueGuard;
    (function(ValueGuard2) {
      function IsArray(value) {
        return Array.isArray(value);
      }
      ValueGuard2.IsArray = IsArray;
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      ValueGuard2.IsBigInt = IsBigInt;
      function IsBoolean(value) {
        return typeof value === "boolean";
      }
      ValueGuard2.IsBoolean = IsBoolean;
      function IsDate(value) {
        return value instanceof globalThis.Date;
      }
      ValueGuard2.IsDate = IsDate;
      function IsNull(value) {
        return value === null;
      }
      ValueGuard2.IsNull = IsNull;
      function IsNumber(value) {
        return typeof value === "number";
      }
      ValueGuard2.IsNumber = IsNumber;
      function IsObject(value) {
        return typeof value === "object" && value !== null;
      }
      ValueGuard2.IsObject = IsObject;
      function IsString(value) {
        return typeof value === "string";
      }
      ValueGuard2.IsString = IsString;
      function IsUint8Array(value) {
        return value instanceof globalThis.Uint8Array;
      }
      ValueGuard2.IsUint8Array = IsUint8Array;
      function IsUndefined(value) {
        return value === void 0;
      }
      ValueGuard2.IsUndefined = IsUndefined;
    })(ValueGuard || (exports2.ValueGuard = ValueGuard = {}));
    class TypeGuardUnknownTypeError extends TypeBoxError {
    }
    exports2.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
    var TypeGuard;
    (function(TypeGuard2) {
      function IsPattern(value) {
        try {
          new RegExp(value);
          return true;
        } catch {
          return false;
        }
      }
      function IsControlCharacterFree(value) {
        if (!ValueGuard.IsString(value))
          return false;
        for (let i = 0; i < value.length; i++) {
          const code = value.charCodeAt(i);
          if (code >= 7 && code <= 13 || code === 27 || code === 127) {
            return false;
          }
        }
        return true;
      }
      function IsAdditionalProperties(value) {
        return IsOptionalBoolean(value) || TSchema(value);
      }
      function IsOptionalBigInt(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
      }
      function IsOptionalNumber(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
      }
      function IsOptionalBoolean(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
      }
      function IsOptionalString(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
      }
      function IsOptionalPattern(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
      }
      function IsOptionalFormat(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
      }
      function IsOptionalSchema(value) {
        return ValueGuard.IsUndefined(value) || TSchema(value);
      }
      function TAny(schema) {
        return TKindOf(schema, "Any") && IsOptionalString(schema.$id);
      }
      TypeGuard2.TAny = TAny;
      function TArray(schema) {
        return TKindOf(schema, "Array") && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);
      }
      TypeGuard2.TArray = TArray;
      function TAsyncIterator(schema) {
        return TKindOf(schema, "AsyncIterator") && schema.type === "AsyncIterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
      }
      TypeGuard2.TAsyncIterator = TAsyncIterator;
      function TBigInt(schema) {
        return TKindOf(schema, "BigInt") && schema.type === "bigint" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.exclusiveMaximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.multipleOf);
      }
      TypeGuard2.TBigInt = TBigInt;
      function TBoolean(schema) {
        return TKindOf(schema, "Boolean") && schema.type === "boolean" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TBoolean = TBoolean;
      function TConstructor(schema) {
        return TKindOf(schema, "Constructor") && schema.type === "Constructor" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
      }
      TypeGuard2.TConstructor = TConstructor;
      function TDate(schema) {
        return TKindOf(schema, "Date") && schema.type === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.multipleOfTimestamp);
      }
      TypeGuard2.TDate = TDate;
      function TFunction(schema) {
        return TKindOf(schema, "Function") && schema.type === "Function" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
      }
      TypeGuard2.TFunction = TFunction;
      function TInteger(schema) {
        return TKindOf(schema, "Integer") && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
      }
      TypeGuard2.TInteger = TInteger;
      function TIntersect(schema) {
        return TKindOf(schema, "Intersect") && (ValueGuard.IsString(schema.type) && schema.type !== "object" ? false : true) && ValueGuard.IsArray(schema.allOf) && schema.allOf.every((schema2) => TSchema(schema2) && !TTransform(schema2)) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id);
      }
      TypeGuard2.TIntersect = TIntersect;
      function TIterator(schema) {
        return TKindOf(schema, "Iterator") && schema.type === "Iterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
      }
      TypeGuard2.TIterator = TIterator;
      function TKindOf(schema, kind) {
        return TKind(schema) && schema[exports2.Kind] === kind;
      }
      TypeGuard2.TKindOf = TKindOf;
      function TKind(schema) {
        return ValueGuard.IsObject(schema) && exports2.Kind in schema && ValueGuard.IsString(schema[exports2.Kind]);
      }
      TypeGuard2.TKind = TKind;
      function TLiteralString(schema) {
        return TLiteral(schema) && ValueGuard.IsString(schema.const);
      }
      TypeGuard2.TLiteralString = TLiteralString;
      function TLiteralNumber(schema) {
        return TLiteral(schema) && ValueGuard.IsNumber(schema.const);
      }
      TypeGuard2.TLiteralNumber = TLiteralNumber;
      function TLiteralBoolean(schema) {
        return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);
      }
      TypeGuard2.TLiteralBoolean = TLiteralBoolean;
      function TLiteral(schema) {
        return TKindOf(schema, "Literal") && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));
      }
      TypeGuard2.TLiteral = TLiteral;
      function TNever(schema) {
        return TKindOf(schema, "Never") && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;
      }
      TypeGuard2.TNever = TNever;
      function TNot(schema) {
        return TKindOf(schema, "Not") && TSchema(schema.not);
      }
      TypeGuard2.TNot = TNot;
      function TNull(schema) {
        return TKindOf(schema, "Null") && schema.type === "null" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TNull = TNull;
      function TNumber(schema) {
        return TKindOf(schema, "Number") && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
      }
      TypeGuard2.TNumber = TNumber;
      function TObject(schema) {
        return TKindOf(schema, "Object") && schema.type === "object" && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties) && Object.entries(schema.properties).every(([key, schema2]) => IsControlCharacterFree(key) && TSchema(schema2));
      }
      TypeGuard2.TObject = TObject;
      function TPromise(schema) {
        return TKindOf(schema, "Promise") && schema.type === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
      }
      TypeGuard2.TPromise = TPromise;
      function TRecord(schema) {
        return TKindOf(schema, "Record") && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties) && ((schema2) => {
          const keys = Object.getOwnPropertyNames(schema2.patternProperties);
          return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema2.patternProperties) && TSchema(schema2.patternProperties[keys[0]]);
        })(schema);
      }
      TypeGuard2.TRecord = TRecord;
      function TRecursive(schema) {
        return ValueGuard.IsObject(schema) && exports2.Hint in schema && schema[exports2.Hint] === "Recursive";
      }
      TypeGuard2.TRecursive = TRecursive;
      function TRef(schema) {
        return TKindOf(schema, "Ref") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
      }
      TypeGuard2.TRef = TRef;
      function TString(schema) {
        return TKindOf(schema, "String") && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
      }
      TypeGuard2.TString = TString;
      function TSymbol(schema) {
        return TKindOf(schema, "Symbol") && schema.type === "symbol" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TSymbol = TSymbol;
      function TTemplateLiteral(schema) {
        return TKindOf(schema, "TemplateLiteral") && schema.type === "string" && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
      }
      TypeGuard2.TTemplateLiteral = TTemplateLiteral;
      function TThis(schema) {
        return TKindOf(schema, "This") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
      }
      TypeGuard2.TThis = TThis;
      function TTransform(schema) {
        return ValueGuard.IsObject(schema) && exports2.Transform in schema;
      }
      TypeGuard2.TTransform = TTransform;
      function TTuple(schema) {
        return TKindOf(schema, "Tuple") && schema.type === "array" && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems && // empty
        (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0 || ValueGuard.IsArray(schema.items) && schema.items.every((schema2) => TSchema(schema2)));
      }
      TypeGuard2.TTuple = TTuple;
      function TUndefined(schema) {
        return TKindOf(schema, "Undefined") && schema.type === "undefined" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUndefined = TUndefined;
      function TUnionLiteral(schema) {
        return TUnion(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
      }
      TypeGuard2.TUnionLiteral = TUnionLiteral;
      function TUnion(schema) {
        return TKindOf(schema, "Union") && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema) && ValueGuard.IsArray(schema.anyOf) && schema.anyOf.every((schema2) => TSchema(schema2));
      }
      TypeGuard2.TUnion = TUnion;
      function TUint8Array(schema) {
        return TKindOf(schema, "Uint8Array") && schema.type === "Uint8Array" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
      }
      TypeGuard2.TUint8Array = TUint8Array;
      function TUnknown(schema) {
        return TKindOf(schema, "Unknown") && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUnknown = TUnknown;
      function TUnsafe(schema) {
        return TKindOf(schema, "Unsafe");
      }
      TypeGuard2.TUnsafe = TUnsafe;
      function TVoid(schema) {
        return TKindOf(schema, "Void") && schema.type === "void" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TVoid = TVoid;
      function TReadonly(schema) {
        return ValueGuard.IsObject(schema) && schema[exports2.Readonly] === "Readonly";
      }
      TypeGuard2.TReadonly = TReadonly;
      function TOptional(schema) {
        return ValueGuard.IsObject(schema) && schema[exports2.Optional] === "Optional";
      }
      TypeGuard2.TOptional = TOptional;
      function TSchema(schema) {
        return ValueGuard.IsObject(schema) && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TAsyncIterator(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TIterator(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports2.Kind]));
      }
      TypeGuard2.TSchema = TSchema;
    })(TypeGuard || (exports2.TypeGuard = TypeGuard = {}));
    var ExtendsUndefined;
    (function(ExtendsUndefined2) {
      function Check(schema) {
        return schema[exports2.Kind] === "Intersect" ? schema.allOf.every((schema2) => Check(schema2)) : schema[exports2.Kind] === "Union" ? schema.anyOf.some((schema2) => Check(schema2)) : schema[exports2.Kind] === "Undefined" ? true : schema[exports2.Kind] === "Not" ? !Check(schema.not) : false;
      }
      ExtendsUndefined2.Check = Check;
    })(ExtendsUndefined || (exports2.ExtendsUndefined = ExtendsUndefined = {}));
    class TypeExtendsError extends TypeBoxError {
    }
    exports2.TypeExtendsError = TypeExtendsError;
    var TypeExtendsResult;
    (function(TypeExtendsResult2) {
      TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
      TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
      TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
    })(TypeExtendsResult || (exports2.TypeExtendsResult = TypeExtendsResult = {}));
    var TypeExtends;
    (function(TypeExtends2) {
      function IntoBooleanResult(result) {
        return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;
      }
      function Throw(message2) {
        throw new TypeExtendsError(message2);
      }
      function IsStructuralRight(right) {
        return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
      }
      function StructuralRight(left, right) {
        return TypeGuard.TNever(right) ? TNeverRight() : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight() : TypeGuard.TAny(right) ? TAnyRight() : Throw("StructuralRight");
      }
      function TAnyRight(left, right) {
        return TypeExtendsResult.True;
      }
      function TAny(left, right) {
        return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
      }
      function TArrayRight(left, right) {
        return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TArray(left, right) {
        return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TAsyncIterator(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TBigInt(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TBooleanRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TBoolean(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TConstructor(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function TDate(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TFunction(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function TIntegerRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TInteger(left, right) {
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
      }
      function TIntersectRight(left, right) {
        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TIntersect(left, right) {
        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TIterator(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TLiteral(left, right) {
        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left) : TypeGuard.TNumber(right) ? TNumberRight(left) : TypeGuard.TInteger(right) ? TIntegerRight(left) : TypeGuard.TBoolean(right) ? TBooleanRight(left) : TypeExtendsResult.False;
      }
      function TNeverRight(left, right) {
        return TypeExtendsResult.False;
      }
      function TNever(left, right) {
        return TypeExtendsResult.True;
      }
      function UnwrapTNot(schema) {
        let [current, depth] = [schema, 0];
        while (true) {
          if (!TypeGuard.TNot(current))
            break;
          current = current.not;
          depth += 1;
        }
        return depth % 2 === 0 ? current : exports2.Type.Unknown();
      }
      function TNot(left, right) {
        return TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
      }
      function TNull(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TNumberRight(left, right) {
        return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TNumber(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IsObjectPropertyCount(schema, count) {
        return Object.getOwnPropertyNames(schema.properties).length === count;
      }
      function IsObjectStringLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectSymbolLike(schema) {
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
      }
      function IsObjectNumberLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBooleanLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBigIntLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectDateLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectUint8ArrayLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectFunctionLike(schema) {
        const length = exports2.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectConstructorLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectArrayLike(schema) {
        const length = exports2.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectPromiseLike(schema) {
        const then = exports2.Type.Function([exports2.Type.Any()], exports2.Type.Any());
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === TypeExtendsResult.True;
      }
      function Property(left, right) {
        return Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
      }
      function TObjectRight(left, right) {
        return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
          return right[exports2.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
        })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
          return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
        })() : TypeExtendsResult.False;
      }
      function TObject(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
          for (const key of Object.getOwnPropertyNames(right.properties)) {
            if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {
              return TypeExtendsResult.False;
            }
            if (TypeGuard.TOptional(right.properties[key])) {
              return TypeExtendsResult.True;
            }
            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        })();
      }
      function TPromise(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
      }
      function RecordKey(schema) {
        return exports2.PatternNumberExact in schema.patternProperties ? exports2.Type.Number() : exports2.PatternStringExact in schema.patternProperties ? exports2.Type.String() : Throw("Unknown record key pattern");
      }
      function RecordValue(schema) {
        return exports2.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports2.PatternNumberExact] : exports2.PatternStringExact in schema.patternProperties ? schema.patternProperties[exports2.PatternStringExact] : Throw("Unable to get record value schema");
      }
      function TRecordRight(left, right) {
        const [Key, Value] = [RecordKey(right), RecordValue(right)];
        return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TObject(left) ? (() => {
          for (const key of Object.getOwnPropertyNames(left.properties)) {
            if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        })() : TypeExtendsResult.False;
      }
      function TRecord(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
      }
      function TStringRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TString(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TSymbol(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TTemplateLiteral(left, right) {
        return TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
      }
      function IsArrayOfTuple(left, right) {
        return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
      }
      function TTupleRight(left, right) {
        return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
      }
      function TTuple(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUint8Array(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUndefined(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnionRight(left, right) {
        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnion(left, right) {
        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnknownRight(left, right) {
        return TypeExtendsResult.True;
      }
      function TUnknown(left, right) {
        return TypeGuard.TNever(right) ? TNeverRight() : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight() : TypeGuard.TString(right) ? TStringRight(left) : TypeGuard.TNumber(right) ? TNumberRight(left) : TypeGuard.TInteger(right) ? TIntegerRight(left) : TypeGuard.TBoolean(right) ? TBooleanRight(left) : TypeGuard.TArray(right) ? TArrayRight(left) : TypeGuard.TTuple(right) ? TTupleRight(left) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function VoidRight(left, right) {
        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TVoid(left, right) {
        return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight() : TypeGuard.TAny(right) ? TAnyRight() : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Visit(left, right) {
        return (
          // resolvable
          TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot(left, right) : (
            // standard
            TypeGuard.TAny(left) ? TAny(left, right) : TypeGuard.TArray(left) ? TArray(left, right) : TypeGuard.TBigInt(left) ? TBigInt(left, right) : TypeGuard.TBoolean(left) ? TBoolean(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) : TypeGuard.TConstructor(left) ? TConstructor(left, right) : TypeGuard.TDate(left) ? TDate(left, right) : TypeGuard.TFunction(left) ? TFunction(left, right) : TypeGuard.TInteger(left) ? TInteger(left, right) : TypeGuard.TIntersect(left) ? TIntersect(left, right) : TypeGuard.TIterator(left) ? TIterator(left, right) : TypeGuard.TLiteral(left) ? TLiteral(left, right) : TypeGuard.TNever(left) ? TNever() : TypeGuard.TNull(left) ? TNull(left, right) : TypeGuard.TNumber(left) ? TNumber(left, right) : TypeGuard.TObject(left) ? TObject(left, right) : TypeGuard.TRecord(left) ? TRecord(left, right) : TypeGuard.TString(left) ? TString(left, right) : TypeGuard.TSymbol(left) ? TSymbol(left, right) : TypeGuard.TTuple(left) ? TTuple(left, right) : TypeGuard.TPromise(left) ? TPromise(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array(left, right) : TypeGuard.TUndefined(left) ? TUndefined(left, right) : TypeGuard.TUnion(left) ? TUnion(left, right) : TypeGuard.TUnknown(left) ? TUnknown(left, right) : TypeGuard.TVoid(left) ? TVoid(left, right) : Throw(`Unknown left type operand '${left[exports2.Kind]}'`)
          )
        );
      }
      function Extends(left, right) {
        return Visit(left, right);
      }
      TypeExtends2.Extends = Extends;
    })(TypeExtends || (exports2.TypeExtends = TypeExtends = {}));
    var TypeClone;
    (function(TypeClone2) {
      function ArrayType(value) {
        return value.map((value2) => Visit(value2));
      }
      function DateType(value) {
        return new Date(value.getTime());
      }
      function Uint8ArrayType(value) {
        return new Uint8Array(value);
      }
      function ObjectType(value) {
        const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
        const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
        return { ...clonedProperties, ...clonedSymbols };
      }
      function Visit(value) {
        return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
      }
      function Rest(schemas) {
        return schemas.map((schema) => Type(schema));
      }
      TypeClone2.Rest = Rest;
      function Type(schema, options = {}) {
        return { ...Visit(schema), ...options };
      }
      TypeClone2.Type = Type;
    })(TypeClone || (exports2.TypeClone = TypeClone = {}));
    var IndexedAccessor;
    (function(IndexedAccessor2) {
      function OptionalUnwrap(schema) {
        return schema.map((schema2) => {
          const { [exports2.Optional]: _, ...clone } = TypeClone.Type(schema2);
          return clone;
        });
      }
      function IsIntersectOptional(schema) {
        return schema.every((schema2) => TypeGuard.TOptional(schema2));
      }
      function IsUnionOptional(schema) {
        return schema.some((schema2) => TypeGuard.TOptional(schema2));
      }
      function ResolveIntersect(schema) {
        return IsIntersectOptional(schema.allOf) ? exports2.Type.Optional(exports2.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
      }
      function ResolveUnion(schema) {
        return IsUnionOptional(schema.anyOf) ? exports2.Type.Optional(exports2.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
      }
      function ResolveOptional(schema) {
        return schema[exports2.Kind] === "Intersect" ? ResolveIntersect(schema) : schema[exports2.Kind] === "Union" ? ResolveUnion(schema) : schema;
      }
      function TIntersect(schema, key) {
        const resolved = schema.allOf.reduce((acc, schema2) => {
          const indexed = Visit(schema2, key);
          return indexed[exports2.Kind] === "Never" ? acc : [...acc, indexed];
        }, []);
        return ResolveOptional(exports2.Type.Intersect(resolved));
      }
      function TUnion(schema, key) {
        const resolved = schema.anyOf.map((schema2) => Visit(schema2, key));
        return ResolveOptional(exports2.Type.Union(resolved));
      }
      function TObject(schema, key) {
        const property = schema.properties[key];
        return ValueGuard.IsUndefined(property) ? exports2.Type.Never() : exports2.Type.Union([property]);
      }
      function TTuple(schema, key) {
        const items = schema.items;
        if (ValueGuard.IsUndefined(items))
          return exports2.Type.Never();
        const element = items[key];
        if (ValueGuard.IsUndefined(element))
          return exports2.Type.Never();
        return element;
      }
      function Visit(schema, key) {
        return schema[exports2.Kind] === "Intersect" ? TIntersect(schema, key) : schema[exports2.Kind] === "Union" ? TUnion(schema, key) : schema[exports2.Kind] === "Object" ? TObject(schema, key) : schema[exports2.Kind] === "Tuple" ? TTuple(schema, key) : exports2.Type.Never();
      }
      function Resolve(schema, keys, options = {}) {
        const resolved = keys.map((key) => Visit(schema, key.toString()));
        return ResolveOptional(exports2.Type.Union(resolved, options));
      }
      IndexedAccessor2.Resolve = Resolve;
    })(IndexedAccessor || (exports2.IndexedAccessor = IndexedAccessor = {}));
    var Intrinsic;
    (function(Intrinsic2) {
      function Uncapitalize(value) {
        const [first2, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first2.toLowerCase()}${rest}`;
      }
      function Capitalize(value) {
        const [first2, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first2.toUpperCase()}${rest}`;
      }
      function Uppercase(value) {
        return value.toUpperCase();
      }
      function Lowercase(value) {
        return value.toLowerCase();
      }
      function IntrinsicTemplateLiteral(schema, mode) {
        const expression = TemplateLiteralParser.ParseExact(schema.pattern);
        const finite = TemplateLiteralFinite.Check(expression);
        if (!finite)
          return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };
        const strings = [...TemplateLiteralGenerator.Generate(expression)];
        const literals = strings.map((value) => exports2.Type.Literal(value));
        const mapped = IntrinsicRest(literals, mode);
        const union = exports2.Type.Union(mapped);
        return exports2.Type.TemplateLiteral([union]);
      }
      function IntrinsicLiteral(value, mode) {
        return typeof value === "string" ? mode === "Uncapitalize" ? Uncapitalize(value) : mode === "Capitalize" ? Capitalize(value) : mode === "Uppercase" ? Uppercase(value) : mode === "Lowercase" ? Lowercase(value) : value : value.toString();
      }
      function IntrinsicRest(schema, mode) {
        if (schema.length === 0)
          return [];
        const [L, ...R] = schema;
        return [Map2(L, mode), ...IntrinsicRest(R, mode)];
      }
      function Visit(schema, mode) {
        return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) : TypeGuard.TUnion(schema) ? exports2.Type.Union(IntrinsicRest(schema.anyOf, mode)) : TypeGuard.TLiteral(schema) ? exports2.Type.Literal(IntrinsicLiteral(schema.const, mode)) : schema;
      }
      function Map2(schema, mode) {
        return Visit(schema, mode);
      }
      Intrinsic2.Map = Map2;
    })(Intrinsic || (exports2.Intrinsic = Intrinsic = {}));
    var ObjectMap;
    (function(ObjectMap2) {
      function TIntersect(schema, callback) {
        return exports2.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function TUnion(schema, callback) {
        return exports2.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function TObject(schema, callback) {
        return callback(schema);
      }
      function Visit(schema, callback) {
        return schema[exports2.Kind] === "Intersect" ? TIntersect(schema, callback) : schema[exports2.Kind] === "Union" ? TUnion(schema, callback) : schema[exports2.Kind] === "Object" ? TObject(schema, callback) : schema;
      }
      function Map2(schema, callback, options) {
        return { ...Visit(TypeClone.Type(schema), callback), ...options };
      }
      ObjectMap2.Map = Map2;
    })(ObjectMap || (exports2.ObjectMap = ObjectMap = {}));
    var KeyResolver;
    (function(KeyResolver2) {
      function UnwrapPattern(key) {
        return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
      }
      function TIntersect(schema, options) {
        return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit(schema2, options)], []);
      }
      function TUnion(schema, options) {
        const sets = schema.anyOf.map((inner) => Visit(inner, options));
        return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
      }
      function TObject(schema, options) {
        return Object.getOwnPropertyNames(schema.properties);
      }
      function TRecord(schema, options) {
        return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
      }
      function Visit(schema, options) {
        return TypeGuard.TIntersect(schema) ? TIntersect(schema, options) : TypeGuard.TUnion(schema) ? TUnion(schema, options) : TypeGuard.TObject(schema) ? TObject(schema) : TypeGuard.TRecord(schema) ? TRecord(schema, options) : [];
      }
      function ResolveKeys(schema, options) {
        return [...new Set(Visit(schema, options))];
      }
      KeyResolver2.ResolveKeys = ResolveKeys;
      function ResolvePattern(schema) {
        const keys = ResolveKeys(schema, { includePatterns: true });
        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
        return `^(${pattern.join("|")})$`;
      }
      KeyResolver2.ResolvePattern = ResolvePattern;
    })(KeyResolver || (exports2.KeyResolver = KeyResolver = {}));
    class KeyArrayResolverError extends TypeBoxError {
    }
    exports2.KeyArrayResolverError = KeyArrayResolverError;
    var KeyArrayResolver;
    (function(KeyArrayResolver2) {
      function Resolve(schema) {
        return Array.isArray(schema) ? schema : TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema2) => schema2.const.toString()) : TypeGuard.TLiteral(schema) ? [schema.const] : TypeGuard.TTemplateLiteral(schema) ? (() => {
          const expression = TemplateLiteralParser.ParseExact(schema.pattern);
          if (!TemplateLiteralFinite.Check(expression))
            throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
          return [...TemplateLiteralGenerator.Generate(expression)];
        })() : [];
      }
      KeyArrayResolver2.Resolve = Resolve;
    })(KeyArrayResolver || (exports2.KeyArrayResolver = KeyArrayResolver = {}));
    var UnionResolver;
    (function(UnionResolver2) {
      function* TUnion(union) {
        for (const schema of union.anyOf) {
          if (schema[exports2.Kind] === "Union") {
            yield* TUnion(schema);
          } else {
            yield schema;
          }
        }
      }
      function Resolve(union) {
        return exports2.Type.Union([...TUnion(union)], { ...union });
      }
      UnionResolver2.Resolve = Resolve;
    })(UnionResolver || (exports2.UnionResolver = UnionResolver = {}));
    class TemplateLiteralPatternError extends TypeBoxError {
    }
    exports2.TemplateLiteralPatternError = TemplateLiteralPatternError;
    var TemplateLiteralPattern;
    (function(TemplateLiteralPattern2) {
      function Throw(message2) {
        throw new TemplateLiteralPatternError(message2);
      }
      function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Visit(schema, acc) {
        return TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : TypeGuard.TNumber(schema) ? `${acc}${exports2.PatternNumber}` : TypeGuard.TInteger(schema) ? `${acc}${exports2.PatternNumber}` : TypeGuard.TBigInt(schema) ? `${acc}${exports2.PatternNumber}` : TypeGuard.TString(schema) ? `${acc}${exports2.PatternString}` : TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : TypeGuard.TBoolean(schema) ? `${acc}${exports2.PatternBoolean}` : Throw(`Unexpected Kind '${schema[exports2.Kind]}'`);
      }
      function Create(kinds) {
        return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
      }
      TemplateLiteralPattern2.Create = Create;
    })(TemplateLiteralPattern || (exports2.TemplateLiteralPattern = TemplateLiteralPattern = {}));
    var TemplateLiteralResolver;
    (function(TemplateLiteralResolver2) {
      function Resolve(template) {
        const expression = TemplateLiteralParser.ParseExact(template.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          return exports2.Type.String();
        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports2.Type.Literal(value));
        return exports2.Type.Union(literals);
      }
      TemplateLiteralResolver2.Resolve = Resolve;
    })(TemplateLiteralResolver || (exports2.TemplateLiteralResolver = TemplateLiteralResolver = {}));
    class TemplateLiteralParserError extends TypeBoxError {
    }
    exports2.TemplateLiteralParserError = TemplateLiteralParserError;
    var TemplateLiteralParser;
    (function(TemplateLiteralParser2) {
      function IsNonEscaped(pattern, index, char) {
        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
      }
      function IsOpenParen(pattern, index) {
        return IsNonEscaped(pattern, index, "(");
      }
      function IsCloseParen(pattern, index) {
        return IsNonEscaped(pattern, index, ")");
      }
      function IsSeparator(pattern, index) {
        return IsNonEscaped(pattern, index, "|");
      }
      function IsGroup(pattern) {
        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
          return false;
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (count === 0 && index !== pattern.length - 1)
            return false;
        }
        return true;
      }
      function InGroup(pattern) {
        return pattern.slice(1, pattern.length - 1);
      }
      function IsPrecedenceOr(pattern) {
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0)
            return true;
        }
        return false;
      }
      function IsPrecedenceAnd(pattern) {
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            return true;
        }
        return false;
      }
      function Or(pattern) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0) {
            const range3 = pattern.slice(start, index);
            if (range3.length > 0)
              expressions.push(Parse(range3));
            start = index + 1;
          }
        }
        const range2 = pattern.slice(start);
        if (range2.length > 0)
          expressions.push(Parse(range2));
        if (expressions.length === 0)
          return { type: "const", const: "" };
        if (expressions.length === 1)
          return expressions[0];
        return { type: "or", expr: expressions };
      }
      function And(pattern) {
        function Group(value, index) {
          if (!IsOpenParen(value, index))
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
          let count = 0;
          for (let scan = index; scan < value.length; scan++) {
            if (IsOpenParen(value, scan))
              count += 1;
            if (IsCloseParen(value, scan))
              count -= 1;
            if (count === 0)
              return [index, scan];
          }
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
        }
        function Range2(pattern2, index) {
          for (let scan = index; scan < pattern2.length; scan++) {
            if (IsOpenParen(pattern2, scan))
              return [index, scan];
          }
          return [index, pattern2.length];
        }
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index)) {
            const [start, end] = Group(pattern, index);
            const range2 = pattern.slice(start, end + 1);
            expressions.push(Parse(range2));
            index = end;
          } else {
            const [start, end] = Range2(pattern, index);
            const range2 = pattern.slice(start, end);
            if (range2.length > 0)
              expressions.push(Parse(range2));
            index = end - 1;
          }
        }
        return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
      }
      function Parse(pattern) {
        return IsGroup(pattern) ? Parse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
      }
      TemplateLiteralParser2.Parse = Parse;
      function ParseExact(pattern) {
        return Parse(pattern.slice(1, pattern.length - 1));
      }
      TemplateLiteralParser2.ParseExact = ParseExact;
    })(TemplateLiteralParser || (exports2.TemplateLiteralParser = TemplateLiteralParser = {}));
    class TemplateLiteralFiniteError extends TypeBoxError {
    }
    exports2.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
    var TemplateLiteralFinite;
    (function(TemplateLiteralFinite2) {
      function Throw(message2) {
        throw new TemplateLiteralFiniteError(message2);
      }
      function IsNumber(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
      }
      function IsBoolean(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
      }
      function IsString(expression) {
        return expression.type === "const" && expression.const === ".*";
      }
      function Check(expression) {
        return IsBoolean(expression) ? true : IsNumber(expression) || IsString(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
      }
      TemplateLiteralFinite2.Check = Check;
    })(TemplateLiteralFinite || (exports2.TemplateLiteralFinite = TemplateLiteralFinite = {}));
    class TemplateLiteralGeneratorError extends TypeBoxError {
    }
    exports2.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
    var TemplateLiteralGenerator;
    (function(TemplateLiteralGenerator2) {
      function* Reduce(buffer2) {
        if (buffer2.length === 1)
          return yield* buffer2[0];
        for (const left of buffer2[0]) {
          for (const right of Reduce(buffer2.slice(1))) {
            yield `${left}${right}`;
          }
        }
      }
      function* And(expression) {
        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
      }
      function* Or(expression) {
        for (const expr of expression.expr)
          yield* Generate(expr);
      }
      function* Const(expression) {
        return yield expression.const;
      }
      function* Generate(expression) {
        return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
          throw new TemplateLiteralGeneratorError("Unknown expression");
        })();
      }
      TemplateLiteralGenerator2.Generate = Generate;
    })(TemplateLiteralGenerator || (exports2.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
    var TemplateLiteralDslParser;
    (function(TemplateLiteralDslParser2) {
      function* ParseUnion(template) {
        const trim = template.trim().replace(/"|'/g, "");
        return trim === "boolean" ? yield exports2.Type.Boolean() : trim === "number" ? yield exports2.Type.Number() : trim === "bigint" ? yield exports2.Type.BigInt() : trim === "string" ? yield exports2.Type.String() : yield (() => {
          const literals = trim.split("|").map((literal) => exports2.Type.Literal(literal.trim()));
          return literals.length === 0 ? exports2.Type.Never() : literals.length === 1 ? literals[0] : exports2.Type.Union(literals);
        })();
      }
      function* ParseTerminal(template) {
        if (template[1] !== "{") {
          const L = exports2.Type.Literal("$");
          const R = ParseLiteral(template.slice(1));
          return yield* [L, ...R];
        }
        for (let i = 2; i < template.length; i++) {
          if (template[i] === "}") {
            const L = ParseUnion(template.slice(2, i));
            const R = ParseLiteral(template.slice(i + 1));
            return yield* [...L, ...R];
          }
        }
        yield exports2.Type.Literal(template);
      }
      function* ParseLiteral(template) {
        for (let i = 0; i < template.length; i++) {
          if (template[i] === "$") {
            const L = exports2.Type.Literal(template.slice(0, i));
            const R = ParseTerminal(template.slice(i));
            return yield* [L, ...R];
          }
        }
        yield exports2.Type.Literal(template);
      }
      function Parse(template_dsl) {
        return [...ParseLiteral(template_dsl)];
      }
      TemplateLiteralDslParser2.Parse = Parse;
    })(TemplateLiteralDslParser || (exports2.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
    class TransformDecodeBuilder {
      constructor(schema) {
        this.schema = schema;
      }
      Decode(decode2) {
        return new TransformEncodeBuilder(this.schema, decode2);
      }
    }
    exports2.TransformDecodeBuilder = TransformDecodeBuilder;
    class TransformEncodeBuilder {
      constructor(schema, decode2) {
        this.schema = schema;
        this.decode = decode2;
      }
      Encode(encode2) {
        const schema = TypeClone.Type(this.schema);
        return TypeGuard.TTransform(schema) ? (() => {
          const Encode = (value) => schema[exports2.Transform].Encode(encode2(value));
          const Decode = (value) => this.decode(schema[exports2.Transform].Decode(value));
          const Codec = { Encode, Decode };
          return { ...schema, [exports2.Transform]: Codec };
        })() : (() => {
          const Codec = { Decode: this.decode, Encode: encode2 };
          return { ...schema, [exports2.Transform]: Codec };
        })();
      }
    }
    exports2.TransformEncodeBuilder = TransformEncodeBuilder;
    let TypeOrdinal = 0;
    class TypeBuilderError extends TypeBoxError {
    }
    exports2.TypeBuilderError = TypeBuilderError;
    class TypeBuilder {
      /** `[Internal]` Creates a schema without `static` and `params` types */
      Create(schema) {
        return schema;
      }
      /** `[Internal]` Throws a TypeBuilder error with the given message */
      Throw(message2) {
        throw new TypeBuilderError(message2);
      }
      /** `[Internal]` Discards property keys from the given record type */
      Discard(record, keys) {
        return keys.reduce((acc, key) => {
          const { [key]: _, ...rest } = acc;
          return rest;
        }, record);
      }
      /** `[Json]` Omits compositing symbols from this schema */
      Strict(schema) {
        return JSON.parse(JSON.stringify(schema));
      }
    }
    exports2.TypeBuilder = TypeBuilder;
    class JsonTypeBuilder extends TypeBuilder {
      // ------------------------------------------------------------------------
      // Modifiers
      // ------------------------------------------------------------------------
      /** `[Json]` Creates a Readonly and Optional property */
      ReadonlyOptional(schema) {
        return this.Readonly(this.Optional(schema));
      }
      /** `[Json]` Creates a Readonly property */
      Readonly(schema) {
        return { ...TypeClone.Type(schema), [exports2.Readonly]: "Readonly" };
      }
      /** `[Json]` Creates an Optional property */
      Optional(schema) {
        return { ...TypeClone.Type(schema), [exports2.Optional]: "Optional" };
      }
      // ------------------------------------------------------------------------
      // Types
      // ------------------------------------------------------------------------
      /** `[Json]` Creates an Any type */
      Any(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Any" });
      }
      /** `[Json]` Creates an Array type */
      Array(schema, options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Array", type: "array", items: TypeClone.Type(schema) });
      }
      /** `[Json]` Creates a Boolean type */
      Boolean(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Boolean", type: "boolean" });
      }
      /** `[Json]` Intrinsic function to Capitalize LiteralString types */
      Capitalize(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Capitalize"), ...options };
      }
      /** `[Json]` Creates a Composite object type */
      Composite(objects, options) {
        const intersect = exports2.Type.Intersect(objects, {});
        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports2.Type.Index(intersect, [key]) }), {});
        return exports2.Type.Object(properties, options);
      }
      /** `[Json]` Creates a Enum type */
      Enum(item, options = {}) {
        if (ValueGuard.IsUndefined(item))
          return this.Throw("Enum undefined or empty");
        const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
        const values2 = [...new Set(values1)];
        const anyOf = values2.map((value) => exports2.Type.Literal(value));
        return this.Union(anyOf, { ...options, [exports2.Hint]: "Enum" });
      }
      /** `[Json]` Creates a Conditional type */
      Extends(left, right, trueType, falseType, options = {}) {
        switch (TypeExtends.Extends(left, right)) {
          case TypeExtendsResult.Union:
            return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
          case TypeExtendsResult.True:
            return TypeClone.Type(trueType, options);
          case TypeExtendsResult.False:
            return TypeClone.Type(falseType, options);
        }
      }
      /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
      Exclude(unionType, excludedMembers, options = {}) {
        return TypeGuard.TTemplateLiteral(unionType) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType) ? (() => {
          const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
        })() : TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType, options);
      }
      /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
      Extract(type2, union, options = {}) {
        return TypeGuard.TTemplateLiteral(type2) ? this.Extract(TemplateLiteralResolver.Resolve(type2), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type2, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type2) ? (() => {
          const narrowed = type2.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
        })() : TypeExtends.Extends(type2, union) !== TypeExtendsResult.False ? TypeClone.Type(type2, options) : this.Never(options);
      }
      /** `[Json]` Returns an Indexed property type for the given keys */
      Index(schema, unresolved, options = {}) {
        return TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {
          return TypeClone.Type(schema.items, options);
        })() : TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {
          const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
          const cloned = items.map((schema2) => TypeClone.Type(schema2));
          return this.Union(cloned, options);
        })() : (() => {
          const keys = KeyArrayResolver.Resolve(unresolved);
          const clone = TypeClone.Type(schema);
          return IndexedAccessor.Resolve(clone, keys, options);
        })();
      }
      /** `[Json]` Creates an Integer type */
      Integer(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Integer", type: "integer" });
      }
      /** `[Json]` Creates an Intersect type */
      Intersect(allOf, options = {}) {
        if (allOf.length === 0)
          return exports2.Type.Never();
        if (allOf.length === 1)
          return TypeClone.Type(allOf[0], options);
        if (allOf.some((schema) => TypeGuard.TTransform(schema)))
          this.Throw("Cannot intersect transform types");
        const objects = allOf.every((schema) => TypeGuard.TObject(schema));
        const cloned = TypeClone.Rest(allOf);
        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
        return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports2.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports2.Kind]: "Intersect", allOf: cloned });
      }
      /** `[Json]` Creates a KeyOf type */
      KeyOf(schema, options = {}) {
        return TypeGuard.TRecord(schema) ? (() => {
          const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
          return pattern === exports2.PatternNumberExact ? this.Number(options) : pattern === exports2.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
        })() : TypeGuard.TTuple(schema) ? (() => {
          const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
          const literals = items.map((_, index) => exports2.Type.Literal(index.toString()));
          return this.Union(literals, options);
        })() : TypeGuard.TArray(schema) ? (() => {
          return this.Number(options);
        })() : (() => {
          const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
          if (keys.length === 0)
            return this.Never(options);
          const literals = keys.map((key) => this.Literal(key));
          return this.Union(literals, options);
        })();
      }
      /** `[Json]` Creates a Literal type */
      Literal(value, options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Literal", const: value, type: typeof value });
      }
      /** `[Json]` Intrinsic function to Lowercase LiteralString types */
      Lowercase(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Lowercase"), ...options };
      }
      /** `[Json]` Creates a Never type */
      Never(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Never", not: {} });
      }
      /** `[Json]` Creates a Not type */
      Not(schema, options) {
        return this.Create({ ...options, [exports2.Kind]: "Not", not: TypeClone.Type(schema) });
      }
      /** `[Json]` Creates a Null type */
      Null(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Null", type: "null" });
      }
      /** `[Json]` Creates a Number type */
      Number(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Number", type: "number" });
      }
      /** `[Json]` Creates an Object type */
      Object(properties, options = {}) {
        const propertyKeys = Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
        return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports2.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports2.Kind]: "Object", type: "object", properties: clonedProperties });
      }
      /** `[Json]` Constructs a type whose keys are omitted from the given type */
      Omit(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports2.Transform]), (object2) => {
          if (ValueGuard.IsArray(object2.required)) {
            object2.required = object2.required.filter((key) => !keys.includes(key));
            if (object2.required.length === 0)
              delete object2.required;
          }
          for (const key of Object.getOwnPropertyNames(object2.properties)) {
            if (keys.includes(key))
              delete object2.properties[key];
          }
          return this.Create(object2);
        }, options);
      }
      /** `[Json]` Constructs a type where all properties are optional */
      Partial(schema, options = {}) {
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports2.Transform]), (object2) => {
          const properties = Object.getOwnPropertyNames(object2.properties).reduce((acc, key) => {
            return { ...acc, [key]: this.Optional(object2.properties[key]) };
          }, {});
          return this.Object(
            properties,
            this.Discard(object2, ["required"])
            /* object used as options to retain other constraints */
          );
        }, options);
      }
      /** `[Json]` Constructs a type whose keys are picked from the given type */
      Pick(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports2.Transform]), (object2) => {
          if (ValueGuard.IsArray(object2.required)) {
            object2.required = object2.required.filter((key) => keys.includes(key));
            if (object2.required.length === 0)
              delete object2.required;
          }
          for (const key of Object.getOwnPropertyNames(object2.properties)) {
            if (!keys.includes(key))
              delete object2.properties[key];
          }
          return this.Create(object2);
        }, options);
      }
      /** `[Json]` Creates a Record type */
      Record(key, schema, options = {}) {
        return TypeGuard.TTemplateLiteral(key) ? (() => {
          const expression = TemplateLiteralParser.ParseExact(key.pattern);
          return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema) }), {}), options) : this.Create({ ...options, [exports2.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema) } });
        })() : TypeGuard.TUnion(key) ? (() => {
          const union = UnionResolver.Resolve(key);
          if (TypeGuard.TUnionLiteral(union)) {
            const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});
            return this.Object(properties, { ...options, [exports2.Hint]: "Record" });
          } else
            this.Throw("Record key of type union contains non-literal types");
        })() : TypeGuard.TLiteral(key) ? (() => {
          return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema) }, options) : this.Throw("Record key of type literal is not of type string or number");
        })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
          return this.Create({ ...options, [exports2.Kind]: "Record", type: "object", patternProperties: { [exports2.PatternNumberExact]: TypeClone.Type(schema) } });
        })() : TypeGuard.TString(key) ? (() => {
          const pattern = ValueGuard.IsUndefined(key.pattern) ? exports2.PatternStringExact : key.pattern;
          return this.Create({ ...options, [exports2.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Type(schema) } });
        })() : this.Never();
      }
      /** `[Json]` Creates a Recursive type */
      Recursive(callback, options = {}) {
        if (ValueGuard.IsUndefined(options.$id))
          options.$id = `T${TypeOrdinal++}`;
        const thisType = callback({ [exports2.Kind]: "This", $ref: `${options.$id}` });
        thisType.$id = options.$id;
        return this.Create({ ...options, [exports2.Hint]: "Recursive", ...thisType });
      }
      /** `[Json]` Creates a Ref type. */
      Ref(unresolved, options = {}) {
        if (ValueGuard.IsString(unresolved))
          return this.Create({ ...options, [exports2.Kind]: "Ref", $ref: unresolved });
        if (ValueGuard.IsUndefined(unresolved.$id))
          this.Throw("Reference target type must specify an $id");
        return this.Create({ ...options, [exports2.Kind]: "Ref", $ref: unresolved.$id });
      }
      /** `[Json]` Constructs a type where all properties are required */
      Required(schema, options = {}) {
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports2.Transform]), (object2) => {
          const properties = Object.getOwnPropertyNames(object2.properties).reduce((acc, key) => {
            return { ...acc, [key]: this.Discard(object2.properties[key], [exports2.Optional]) };
          }, {});
          return this.Object(
            properties,
            object2
            /* object used as options to retain other constraints  */
          );
        }, options);
      }
      /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
      Rest(schema) {
        return TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : [];
      }
      /** `[Json]` Creates a String type */
      String(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "String", type: "string" });
      }
      /** `[Json]` Creates a TemplateLiteral type */
      TemplateLiteral(unresolved, options = {}) {
        const pattern = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
        return this.Create({ ...options, [exports2.Kind]: "TemplateLiteral", type: "string", pattern });
      }
      /** `[Json]` Creates a Transform type */
      Transform(schema) {
        return new TransformDecodeBuilder(schema);
      }
      /** `[Json]` Creates a Tuple type */
      Tuple(items, options = {}) {
        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
        const clonedItems = TypeClone.Rest(items);
        const schema = items.length > 0 ? { ...options, [exports2.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports2.Kind]: "Tuple", type: "array", minItems, maxItems };
        return this.Create(schema);
      }
      /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
      Uncapitalize(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Uncapitalize"), ...options };
      }
      /** `[Json]` Creates a Union type */
      Union(union, options = {}) {
        return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {
          const anyOf = union;
          if (anyOf.length === 0)
            return this.Never(options);
          if (anyOf.length === 1)
            return this.Create(TypeClone.Type(anyOf[0], options));
          const clonedAnyOf = TypeClone.Rest(anyOf);
          return this.Create({ ...options, [exports2.Kind]: "Union", anyOf: clonedAnyOf });
        })();
      }
      /** `[Json]` Creates an Unknown type */
      Unknown(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Unknown" });
      }
      /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
      Unsafe(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: options[exports2.Kind] || "Unsafe" });
      }
      /** `[Json]` Intrinsic function to Uppercase LiteralString types */
      Uppercase(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Uppercase"), ...options };
      }
    }
    exports2.JsonTypeBuilder = JsonTypeBuilder;
    class JavaScriptTypeBuilder extends JsonTypeBuilder {
      /** `[JavaScript]` Creates a AsyncIterator type */
      AsyncIterator(items, options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
      }
      /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
      Awaited(schema, options = {}) {
        const Unwrap = (rest) => rest.length > 0 ? (() => {
          const [L, ...R] = rest;
          return [this.Awaited(L), ...Unwrap(R)];
        })() : rest;
        return TypeGuard.TIntersect(schema) ? exports2.Type.Intersect(Unwrap(schema.allOf)) : TypeGuard.TUnion(schema) ? exports2.Type.Union(Unwrap(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Type(schema, options);
      }
      /** `[JavaScript]` Creates a BigInt type */
      BigInt(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "BigInt", type: "bigint" });
      }
      /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
      ConstructorParameters(schema, options = {}) {
        return this.Tuple([...schema.parameters], { ...options });
      }
      /** `[JavaScript]` Creates a Constructor type */
      Constructor(parameters, returns, options) {
        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
        return this.Create({ ...options, [exports2.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[JavaScript]` Creates a Date type */
      Date(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Date", type: "Date" });
      }
      /** `[JavaScript]` Creates a Function type */
      Function(parameters, returns, options) {
        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
        return this.Create({ ...options, [exports2.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
      InstanceType(schema, options = {}) {
        return TypeClone.Type(schema.returns, options);
      }
      /** `[JavaScript]` Creates an Iterator type */
      Iterator(items, options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
      }
      /** `[JavaScript]` Extracts the Parameters from the given Function type */
      Parameters(schema, options = {}) {
        return this.Tuple(schema.parameters, { ...options });
      }
      /** `[JavaScript]` Creates a Promise type */
      Promise(item, options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
      }
      /** `[Extended]` Creates a String type */
      RegExp(unresolved, options = {}) {
        const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
        return this.Create({ ...options, [exports2.Kind]: "String", type: "string", pattern });
      }
      /**
       * @deprecated Use `Type.RegExp`
       */
      RegEx(regex, options = {}) {
        return this.RegExp(regex, options);
      }
      /** `[JavaScript]` Extracts the ReturnType from the given Function type */
      ReturnType(schema, options = {}) {
        return TypeClone.Type(schema.returns, options);
      }
      /** `[JavaScript]` Creates a Symbol type */
      Symbol(options) {
        return this.Create({ ...options, [exports2.Kind]: "Symbol", type: "symbol" });
      }
      /** `[JavaScript]` Creates a Undefined type */
      Undefined(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Undefined", type: "undefined" });
      }
      /** `[JavaScript]` Creates a Uint8Array type */
      Uint8Array(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Uint8Array", type: "Uint8Array" });
      }
      /** `[JavaScript]` Creates a Void type */
      Void(options = {}) {
        return this.Create({ ...options, [exports2.Kind]: "Void", type: "void" });
      }
    }
    exports2.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
    exports2.JsonType = new JsonTypeBuilder();
    exports2.Type = new JavaScriptTypeBuilder();
  })(typebox);
  return typebox;
}
var errors$2 = {};
var errors$1 = {};
var guard = {};
var hasRequiredGuard;
function requireGuard() {
  if (hasRequiredGuard) return guard;
  hasRequiredGuard = 1;
  Object.defineProperty(guard, "__esModule", { value: true });
  guard.IsValueType = guard.IsSymbol = guard.IsFunction = guard.IsString = guard.IsBigInt = guard.IsInteger = guard.IsNumber = guard.IsBoolean = guard.IsNull = guard.IsUndefined = guard.IsArray = guard.IsObject = guard.IsPlainObject = guard.HasPropertyKey = guard.IsDate = guard.IsUint8Array = guard.IsPromise = guard.IsTypedArray = guard.IsIterator = guard.IsAsyncIterator = void 0;
  function IsAsyncIterator(value) {
    return IsObject(value) && Symbol.asyncIterator in value;
  }
  guard.IsAsyncIterator = IsAsyncIterator;
  function IsIterator(value) {
    return IsObject(value) && Symbol.iterator in value;
  }
  guard.IsIterator = IsIterator;
  function IsTypedArray(value) {
    return ArrayBuffer.isView(value);
  }
  guard.IsTypedArray = IsTypedArray;
  function IsPromise(value) {
    return value instanceof Promise;
  }
  guard.IsPromise = IsPromise;
  function IsUint8Array(value) {
    return value instanceof Uint8Array;
  }
  guard.IsUint8Array = IsUint8Array;
  function IsDate(value) {
    return value instanceof Date && Number.isFinite(value.getTime());
  }
  guard.IsDate = IsDate;
  function HasPropertyKey(value, key) {
    return key in value;
  }
  guard.HasPropertyKey = HasPropertyKey;
  function IsPlainObject(value) {
    return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
  }
  guard.IsPlainObject = IsPlainObject;
  function IsObject(value) {
    return value !== null && typeof value === "object";
  }
  guard.IsObject = IsObject;
  function IsArray(value) {
    return Array.isArray(value) && !ArrayBuffer.isView(value);
  }
  guard.IsArray = IsArray;
  function IsUndefined(value) {
    return value === void 0;
  }
  guard.IsUndefined = IsUndefined;
  function IsNull(value) {
    return value === null;
  }
  guard.IsNull = IsNull;
  function IsBoolean(value) {
    return typeof value === "boolean";
  }
  guard.IsBoolean = IsBoolean;
  function IsNumber(value) {
    return typeof value === "number";
  }
  guard.IsNumber = IsNumber;
  function IsInteger(value) {
    return IsNumber(value) && Number.isInteger(value);
  }
  guard.IsInteger = IsInteger;
  function IsBigInt(value) {
    return typeof value === "bigint";
  }
  guard.IsBigInt = IsBigInt;
  function IsString(value) {
    return typeof value === "string";
  }
  guard.IsString = IsString;
  function IsFunction(value) {
    return typeof value === "function";
  }
  guard.IsFunction = IsFunction;
  function IsSymbol(value) {
    return typeof value === "symbol";
  }
  guard.IsSymbol = IsSymbol;
  function IsValueType(value) {
    return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
  }
  guard.IsValueType = IsValueType;
  return guard;
}
var system = {};
var hasRequiredSystem;
function requireSystem() {
  if (hasRequiredSystem) return system;
  hasRequiredSystem = 1;
  Object.defineProperty(system, "__esModule", { value: true });
  system.DefaultErrorFunction = system.TypeSystemPolicy = system.TypeSystemErrorFunction = system.TypeSystem = system.TypeSystemDuplicateFormat = system.TypeSystemDuplicateTypeKind = void 0;
  const guard_1 = requireGuard();
  const errors_12 = requireErrors$2();
  const Types = requireTypebox();
  class TypeSystemDuplicateTypeKind extends Types.TypeBoxError {
    constructor(kind) {
      super(`Duplicate type kind '${kind}' detected`);
    }
  }
  system.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
  class TypeSystemDuplicateFormat extends Types.TypeBoxError {
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  }
  system.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
  var TypeSystem;
  (function(TypeSystem2) {
    function Type(kind, check) {
      if (Types.TypeRegistry.Has(kind))
        throw new TypeSystemDuplicateTypeKind(kind);
      Types.TypeRegistry.Set(kind, check);
      return (options = {}) => Types.Type.Unsafe({ ...options, [Types.Kind]: kind });
    }
    TypeSystem2.Type = Type;
    function Format(format, check) {
      if (Types.FormatRegistry.Has(format))
        throw new TypeSystemDuplicateFormat(format);
      Types.FormatRegistry.Set(format, check);
      return format;
    }
    TypeSystem2.Format = Format;
  })(TypeSystem || (system.TypeSystem = TypeSystem = {}));
  var TypeSystemErrorFunction;
  (function(TypeSystemErrorFunction2) {
    let errorMessageFunction = DefaultErrorFunction;
    function Reset() {
      errorMessageFunction = DefaultErrorFunction;
    }
    TypeSystemErrorFunction2.Reset = Reset;
    function Set2(callback) {
      errorMessageFunction = callback;
    }
    TypeSystemErrorFunction2.Set = Set2;
    function Get() {
      return errorMessageFunction;
    }
    TypeSystemErrorFunction2.Get = Get;
  })(TypeSystemErrorFunction || (system.TypeSystemErrorFunction = TypeSystemErrorFunction = {}));
  var TypeSystemPolicy;
  (function(TypeSystemPolicy2) {
    TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy2.AllowArrayObject = false;
    TypeSystemPolicy2.AllowNaN = false;
    TypeSystemPolicy2.AllowNullVoid = false;
    function IsExactOptionalProperty(value, key) {
      return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
    }
    TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      const isObject2 = (0, guard_1.IsObject)(value);
      return TypeSystemPolicy2.AllowArrayObject ? isObject2 : isObject2 && !(0, guard_1.IsArray)(value);
    }
    TypeSystemPolicy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
    }
    TypeSystemPolicy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      const isNumber = (0, guard_1.IsNumber)(value);
      return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
    }
    TypeSystemPolicy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      const isUndefined = (0, guard_1.IsUndefined)(value);
      return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
    }
    TypeSystemPolicy2.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy || (system.TypeSystemPolicy = TypeSystemPolicy = {}));
  function DefaultErrorFunction(schema, errorType) {
    switch (errorType) {
      case errors_12.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_12.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${schema.maxContains} matching values`;
      case errors_12.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${schema.minContains} matching values`;
      case errors_12.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${schema.maxItems}`;
      case errors_12.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${schema.minItems}`;
      case errors_12.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_12.ValueErrorType.Array:
        return "Expected array";
      case errors_12.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_12.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${schema.exclusiveMaximum}`;
      case errors_12.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${schema.exclusiveMinimum}`;
      case errors_12.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${schema.maximum}`;
      case errors_12.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${schema.minimum}`;
      case errors_12.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${schema.multipleOf}`;
      case errors_12.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_12.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_12.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${schema.exclusiveMinimumTimestamp}`;
      case errors_12.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${schema.exclusiveMaximumTimestamp}`;
      case errors_12.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${schema.minimumTimestamp}`;
      case errors_12.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${schema.maximumTimestamp}`;
      case errors_12.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${schema.multipleOfTimestamp}`;
      case errors_12.ValueErrorType.Date:
        return "Expected Date";
      case errors_12.ValueErrorType.Function:
        return "Expected function";
      case errors_12.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${schema.exclusiveMaximum}`;
      case errors_12.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${schema.exclusiveMinimum}`;
      case errors_12.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${schema.maximum}`;
      case errors_12.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${schema.minimum}`;
      case errors_12.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${schema.multipleOf}`;
      case errors_12.ValueErrorType.Integer:
        return "Expected integer";
      case errors_12.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_12.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_12.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_12.ValueErrorType.Literal:
        return `Expected ${typeof schema.const === "string" ? `'${schema.const}'` : schema.const}`;
      case errors_12.ValueErrorType.Never:
        return "Never";
      case errors_12.ValueErrorType.Not:
        return "Value should not match";
      case errors_12.ValueErrorType.Null:
        return "Expected null";
      case errors_12.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${schema.exclusiveMaximum}`;
      case errors_12.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${schema.exclusiveMinimum}`;
      case errors_12.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${schema.maximum}`;
      case errors_12.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${schema.minimum}`;
      case errors_12.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${schema.multipleOf}`;
      case errors_12.ValueErrorType.Number:
        return "Expected number";
      case errors_12.ValueErrorType.Object:
        return "Expected object";
      case errors_12.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_12.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${schema.maxProperties} properties`;
      case errors_12.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${schema.minProperties} properties`;
      case errors_12.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case errors_12.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_12.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${schema.format}'`;
      case errors_12.ValueErrorType.StringFormat:
        return `Expected string to match '${schema.format}' format`;
      case errors_12.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${schema.maxLength}`;
      case errors_12.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${schema.minLength}`;
      case errors_12.ValueErrorType.StringPattern:
        return `Expected string to match '${schema.pattern}'`;
      case errors_12.ValueErrorType.String:
        return "Expected string";
      case errors_12.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_12.ValueErrorType.TupleLength:
        return `Expected tuple to have ${schema.maxItems || 0} elements`;
      case errors_12.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_12.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${schema.maxByteLength}`;
      case errors_12.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${schema.minByteLength}`;
      case errors_12.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_12.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_12.ValueErrorType.Union:
        return "Expected union value";
      case errors_12.ValueErrorType.Void:
        return "Expected void";
      case errors_12.ValueErrorType.Kind:
        return `Expected kind '${schema[Types.Kind]}'`;
      default:
        return "Unknown error type";
    }
  }
  system.DefaultErrorFunction = DefaultErrorFunction;
  return system;
}
var deref = {};
var hasRequiredDeref;
function requireDeref() {
  if (hasRequiredDeref) return deref;
  hasRequiredDeref = 1;
  Object.defineProperty(deref, "__esModule", { value: true });
  deref.Deref = deref.TypeDereferenceError = void 0;
  const typebox_1 = requireTypebox();
  class TypeDereferenceError extends typebox_1.TypeBoxError {
    constructor(schema) {
      super(`Unable to dereference schema with $id '${schema.$id}'`);
      this.schema = schema;
    }
  }
  deref.TypeDereferenceError = TypeDereferenceError;
  function Deref(schema, references) {
    const index = references.findIndex((target) => target.$id === schema.$ref);
    if (index === -1)
      throw new TypeDereferenceError(schema);
    return references[index];
  }
  deref.Deref = Deref;
  return deref;
}
var hash = {};
var hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash;
  hasRequiredHash = 1;
  Object.defineProperty(hash, "__esModule", { value: true });
  hash.Hash = hash.ByteMarker = hash.ValueHashError = void 0;
  const guard_1 = requireGuard();
  class ValueHashError extends Error {
    constructor(value) {
      super(`Unable to hash value`);
      this.value = value;
    }
  }
  hash.ValueHashError = ValueHashError;
  var ByteMarker;
  (function(ByteMarker2) {
    ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
    ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
    ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
    ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
    ByteMarker2[ByteMarker2["String"] = 4] = "String";
    ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
    ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
    ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
    ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
    ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
    ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
  })(ByteMarker || (hash.ByteMarker = ByteMarker = {}));
  let Accumulator = BigInt("14695981039346656037");
  const [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
  const Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
  const F64 = new Float64Array(1);
  const F64In = new DataView(F64.buffer);
  const F64Out = new Uint8Array(F64.buffer);
  function* NumberToBytes(value) {
    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
    for (let i = 0; i < byteCount; i++) {
      yield value >> 8 * (byteCount - 1 - i) & 255;
    }
  }
  function ArrayType(value) {
    FNV1A64(ByteMarker.Array);
    for (const item of value) {
      Visit(item);
    }
  }
  function BooleanType(value) {
    FNV1A64(ByteMarker.Boolean);
    FNV1A64(value ? 1 : 0);
  }
  function BigIntType(value) {
    FNV1A64(ByteMarker.BigInt);
    F64In.setBigInt64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function DateType(value) {
    FNV1A64(ByteMarker.Date);
    Visit(value.getTime());
  }
  function NullType(value) {
    FNV1A64(ByteMarker.Null);
  }
  function NumberType(value) {
    FNV1A64(ByteMarker.Number);
    F64In.setFloat64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function ObjectType(value) {
    FNV1A64(ByteMarker.Object);
    for (const key of globalThis.Object.keys(value).sort()) {
      Visit(key);
      Visit(value[key]);
    }
  }
  function StringType(value) {
    FNV1A64(ByteMarker.String);
    for (let i = 0; i < value.length; i++) {
      for (const byte of NumberToBytes(value.charCodeAt(i))) {
        FNV1A64(byte);
      }
    }
  }
  function SymbolType(value) {
    FNV1A64(ByteMarker.Symbol);
    Visit(value.description);
  }
  function Uint8ArrayType(value) {
    FNV1A64(ByteMarker.Uint8Array);
    for (let i = 0; i < value.length; i++) {
      FNV1A64(value[i]);
    }
  }
  function UndefinedType(value) {
    return FNV1A64(ByteMarker.Undefined);
  }
  function Visit(value) {
    if ((0, guard_1.IsArray)(value))
      return ArrayType(value);
    if ((0, guard_1.IsBoolean)(value))
      return BooleanType(value);
    if ((0, guard_1.IsBigInt)(value))
      return BigIntType(value);
    if ((0, guard_1.IsDate)(value))
      return DateType(value);
    if ((0, guard_1.IsNull)(value))
      return NullType();
    if ((0, guard_1.IsNumber)(value))
      return NumberType(value);
    if ((0, guard_1.IsPlainObject)(value))
      return ObjectType(value);
    if ((0, guard_1.IsString)(value))
      return StringType(value);
    if ((0, guard_1.IsSymbol)(value))
      return SymbolType(value);
    if ((0, guard_1.IsUint8Array)(value))
      return Uint8ArrayType(value);
    if ((0, guard_1.IsUndefined)(value))
      return UndefinedType();
    throw new ValueHashError(value);
  }
  function FNV1A64(byte) {
    Accumulator = Accumulator ^ Bytes[byte];
    Accumulator = Accumulator * Prime % Size;
  }
  function Hash(value) {
    Accumulator = BigInt("14695981039346656037");
    Visit(value);
    return Accumulator;
  }
  hash.Hash = Hash;
  return hash;
}
var hasRequiredErrors$2;
function requireErrors$2() {
  if (hasRequiredErrors$2) return errors$1;
  hasRequiredErrors$2 = 1;
  Object.defineProperty(errors$1, "__esModule", { value: true });
  errors$1.Errors = errors$1.ValueErrorIterator = errors$1.EscapeKey = errors$1.ValueErrorsUnknownTypeError = errors$1.ValueErrorType = void 0;
  const guard_1 = requireGuard();
  const system_1 = requireSystem();
  const deref_1 = requireDeref();
  const hash_1 = requireHash();
  const Types = requireTypebox();
  var ValueErrorType;
  (function(ValueErrorType2) {
    ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
    ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
    ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
    ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
    ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
    ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
    ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
    ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
    ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
    ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
    ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
    ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
    ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
    ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
    ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 48] = "StringFormatUnknown";
    ValueErrorType2[ValueErrorType2["StringFormat"] = 49] = "StringFormat";
    ValueErrorType2[ValueErrorType2["StringMaxLength"] = 50] = "StringMaxLength";
    ValueErrorType2[ValueErrorType2["StringMinLength"] = 51] = "StringMinLength";
    ValueErrorType2[ValueErrorType2["StringPattern"] = 52] = "StringPattern";
    ValueErrorType2[ValueErrorType2["String"] = 53] = "String";
    ValueErrorType2[ValueErrorType2["Symbol"] = 54] = "Symbol";
    ValueErrorType2[ValueErrorType2["TupleLength"] = 55] = "TupleLength";
    ValueErrorType2[ValueErrorType2["Tuple"] = 56] = "Tuple";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 57] = "Uint8ArrayMaxByteLength";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 58] = "Uint8ArrayMinByteLength";
    ValueErrorType2[ValueErrorType2["Uint8Array"] = 59] = "Uint8Array";
    ValueErrorType2[ValueErrorType2["Undefined"] = 60] = "Undefined";
    ValueErrorType2[ValueErrorType2["Union"] = 61] = "Union";
    ValueErrorType2[ValueErrorType2["Void"] = 62] = "Void";
  })(ValueErrorType || (errors$1.ValueErrorType = ValueErrorType = {}));
  class ValueErrorsUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  errors$1.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
  function EscapeKey(key) {
    return key.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  errors$1.EscapeKey = EscapeKey;
  function IsDefined(value) {
    return value !== void 0;
  }
  class ValueErrorIterator {
    constructor(iterator2) {
      this.iterator = iterator2;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    /** Returns the first value error or undefined if no errors */
    First() {
      const next = this.iterator.next();
      return next.done ? void 0 : next.value;
    }
  }
  errors$1.ValueErrorIterator = ValueErrorIterator;
  function Create(type2, schema, path2, value) {
    return { type: type2, schema, path: path2, value, message: system_1.TypeSystemErrorFunction.Get()(schema, type2) };
  }
  function* TAny(schema, references, path2, value) {
  }
  function* TArray(schema, references, path2, value) {
    if (!(0, guard_1.IsArray)(value)) {
      return yield Create(ValueErrorType.Array, schema, path2, value);
    }
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      yield Create(ValueErrorType.ArrayMinItems, schema, path2, value);
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      yield Create(ValueErrorType.ArrayMaxItems, schema, path2, value);
    }
    for (let i = 0; i < value.length; i++) {
      yield* Visit(schema.items, references, `${path2}/${i}`, value[i]);
    }
    if (schema.uniqueItems === true && !function() {
      const set = /* @__PURE__ */ new Set();
      for (const element of value) {
        const hashed = (0, hash_1.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create(ValueErrorType.ArrayUniqueItems, schema, path2, value);
    }
    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
      return;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();
    const containsCount = value.reduce((acc, value2, index) => Visit(containsSchema, references, `${path2}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create(ValueErrorType.ArrayContains, schema, path2, value);
    }
    if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      yield Create(ValueErrorType.ArrayMinContains, schema, path2, value);
    }
    if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      yield Create(ValueErrorType.ArrayMaxContains, schema, path2, value);
    }
  }
  function* TAsyncIterator(schema, references, path2, value) {
    if (!(0, guard_1.IsAsyncIterator)(value))
      yield Create(ValueErrorType.AsyncIterator, schema, path2, value);
  }
  function* TBigInt(schema, references, path2, value) {
    if (!(0, guard_1.IsBigInt)(value))
      return yield Create(ValueErrorType.BigInt, schema, path2, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path2, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path2, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.BigIntMaximum, schema, path2, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.BigIntMinimum, schema, path2, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      yield Create(ValueErrorType.BigIntMultipleOf, schema, path2, value);
    }
  }
  function* TBoolean(schema, references, path2, value) {
    if (!(0, guard_1.IsBoolean)(value))
      yield Create(ValueErrorType.Boolean, schema, path2, value);
  }
  function* TConstructor(schema, references, path2, value) {
    yield* Visit(schema.returns, references, path2, value.prototype);
  }
  function* TDate(schema, references, path2, value) {
    if (!(0, guard_1.IsDate)(value))
      return yield Create(ValueErrorType.Date, schema, path2, value);
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path2, value);
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path2, value);
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      yield Create(ValueErrorType.DateMaximumTimestamp, schema, path2, value);
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      yield Create(ValueErrorType.DateMinimumTimestamp, schema, path2, value);
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path2, value);
    }
  }
  function* TFunction(schema, references, path2, value) {
    if (!(0, guard_1.IsFunction)(value))
      yield Create(ValueErrorType.Function, schema, path2, value);
  }
  function* TInteger(schema, references, path2, value) {
    if (!(0, guard_1.IsInteger)(value))
      return yield Create(ValueErrorType.Integer, schema, path2, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path2, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path2, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.IntegerMaximum, schema, path2, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.IntegerMinimum, schema, path2, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.IntegerMultipleOf, schema, path2, value);
    }
  }
  function* TIntersect(schema, references, path2, value) {
    for (const inner of schema.allOf) {
      const next = Visit(inner, references, path2, value).next();
      if (!next.done) {
        yield Create(ValueErrorType.Intersect, schema, path2, value);
        yield next.value;
      }
    }
    if (schema.unevaluatedProperties === false) {
      const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path2}/${valueKey}`, value);
        }
      }
    }
    if (typeof schema.unevaluatedProperties === "object") {
      const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          const next = Visit(schema.unevaluatedProperties, references, `${path2}/${valueKey}`, value[valueKey]).next();
          if (!next.done)
            yield next.value;
        }
      }
    }
  }
  function* TIterator(schema, references, path2, value) {
    if (!(0, guard_1.IsIterator)(value))
      yield Create(ValueErrorType.Iterator, schema, path2, value);
  }
  function* TLiteral(schema, references, path2, value) {
    if (!(value === schema.const))
      yield Create(ValueErrorType.Literal, schema, path2, value);
  }
  function* TNever(schema, references, path2, value) {
    yield Create(ValueErrorType.Never, schema, path2, value);
  }
  function* TNot(schema, references, path2, value) {
    if (Visit(schema.not, references, path2, value).next().done === true)
      yield Create(ValueErrorType.Not, schema, path2, value);
  }
  function* TNull(schema, references, path2, value) {
    if (!(0, guard_1.IsNull)(value))
      yield Create(ValueErrorType.Null, schema, path2, value);
  }
  function* TNumber(schema, references, path2, value) {
    if (!system_1.TypeSystemPolicy.IsNumberLike(value))
      return yield Create(ValueErrorType.Number, schema, path2, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path2, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path2, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.NumberMaximum, schema, path2, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.NumberMinimum, schema, path2, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.NumberMultipleOf, schema, path2, value);
    }
  }
  function* TObject(schema, references, path2, value) {
    if (!system_1.TypeSystemPolicy.IsObjectLike(value))
      return yield Create(ValueErrorType.Object, schema, path2, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path2, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path2, value);
    }
    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    const unknownKeys = Object.getOwnPropertyNames(value);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path2}/${EscapeKey(requiredKey)}`, void 0);
    }
    if (schema.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path2}/${EscapeKey(valueKey)}`, value[valueKey]);
        }
      }
    }
    if (typeof schema.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit(schema.additionalProperties, references, `${path2}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit(property, references, `${path2}/${EscapeKey(knownKey)}`, value[knownKey]);
        if (Types.ExtendsUndefined.Check(schema) && !(knownKey in value)) {
          yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path2}/${EscapeKey(knownKey)}`, void 0);
        }
      } else {
        if (system_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
          yield* Visit(property, references, `${path2}/${EscapeKey(knownKey)}`, value[knownKey]);
        }
      }
    }
  }
  function* TPromise(schema, references, path2, value) {
    if (!(0, guard_1.IsPromise)(value))
      yield Create(ValueErrorType.Promise, schema, path2, value);
  }
  function* TRecord(schema, references, path2, value) {
    if (!system_1.TypeSystemPolicy.IsRecordLike(value))
      return yield Create(ValueErrorType.Object, schema, path2, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path2, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path2, value);
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        yield* Visit(patternSchema, references, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
    }
    if (typeof schema.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (!regex.test(propertyKey))
          yield* Visit(schema.additionalProperties, references, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
    if (schema.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex.test(propertyKey))
          continue;
        return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
  }
  function* TRef(schema, references, path2, value) {
    yield* Visit((0, deref_1.Deref)(schema, references), references, path2, value);
  }
  function* TString(schema, references, path2, value) {
    if (!(0, guard_1.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path2, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema, path2, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema, path2, value);
    }
    if ((0, guard_1.IsString)(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value)) {
        yield Create(ValueErrorType.StringPattern, schema, path2, value);
      }
    }
    if ((0, guard_1.IsString)(schema.format)) {
      if (!Types.FormatRegistry.Has(schema.format)) {
        yield Create(ValueErrorType.StringFormatUnknown, schema, path2, value);
      } else {
        const format = Types.FormatRegistry.Get(schema.format);
        if (!format(value)) {
          yield Create(ValueErrorType.StringFormat, schema, path2, value);
        }
      }
    }
  }
  function* TSymbol(schema, references, path2, value) {
    if (!(0, guard_1.IsSymbol)(value))
      yield Create(ValueErrorType.Symbol, schema, path2, value);
  }
  function* TTemplateLiteral(schema, references, path2, value) {
    if (!(0, guard_1.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path2, value);
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path2, value);
    }
  }
  function* TThis(schema, references, path2, value) {
    yield* Visit((0, deref_1.Deref)(schema, references), references, path2, value);
  }
  function* TTuple(schema, references, path2, value) {
    if (!(0, guard_1.IsArray)(value))
      return yield Create(ValueErrorType.Tuple, schema, path2, value);
    if (schema.items === void 0 && !(value.length === 0)) {
      return yield Create(ValueErrorType.TupleLength, schema, path2, value);
    }
    if (!(value.length === schema.maxItems)) {
      return yield Create(ValueErrorType.TupleLength, schema, path2, value);
    }
    if (!schema.items) {
      return;
    }
    for (let i = 0; i < schema.items.length; i++) {
      yield* Visit(schema.items[i], references, `${path2}/${i}`, value[i]);
    }
  }
  function* TUndefined(schema, references, path2, value) {
    if (!(0, guard_1.IsUndefined)(value))
      yield Create(ValueErrorType.Undefined, schema, path2, value);
  }
  function* TUnion(schema, references, path2, value) {
    let count = 0;
    for (const subschema of schema.anyOf) {
      const errors2 = [...Visit(subschema, references, path2, value)];
      if (errors2.length === 0)
        return;
      count += errors2.length;
    }
    if (count > 0) {
      yield Create(ValueErrorType.Union, schema, path2, value);
    }
  }
  function* TUint8Array(schema, references, path2, value) {
    if (!(0, guard_1.IsUint8Array)(value))
      return yield Create(ValueErrorType.Uint8Array, schema, path2, value);
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path2, value);
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path2, value);
    }
  }
  function* TUnknown(schema, references, path2, value) {
  }
  function* TVoid(schema, references, path2, value) {
    if (!system_1.TypeSystemPolicy.IsVoidLike(value))
      yield Create(ValueErrorType.Void, schema, path2, value);
  }
  function* TKind(schema, references, path2, value) {
    const check = Types.TypeRegistry.Get(schema[Types.Kind]);
    if (!check(schema, value))
      yield Create(ValueErrorType.Kind, schema, path2, value);
  }
  function* Visit(schema, references, path2, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[Types.Kind]) {
      case "Any":
        return yield* TAny();
      case "Array":
        return yield* TArray(schema_, references_, path2, value);
      case "AsyncIterator":
        return yield* TAsyncIterator(schema_, references_, path2, value);
      case "BigInt":
        return yield* TBigInt(schema_, references_, path2, value);
      case "Boolean":
        return yield* TBoolean(schema_, references_, path2, value);
      case "Constructor":
        return yield* TConstructor(schema_, references_, path2, value);
      case "Date":
        return yield* TDate(schema_, references_, path2, value);
      case "Function":
        return yield* TFunction(schema_, references_, path2, value);
      case "Integer":
        return yield* TInteger(schema_, references_, path2, value);
      case "Intersect":
        return yield* TIntersect(schema_, references_, path2, value);
      case "Iterator":
        return yield* TIterator(schema_, references_, path2, value);
      case "Literal":
        return yield* TLiteral(schema_, references_, path2, value);
      case "Never":
        return yield* TNever(schema_, references_, path2, value);
      case "Not":
        return yield* TNot(schema_, references_, path2, value);
      case "Null":
        return yield* TNull(schema_, references_, path2, value);
      case "Number":
        return yield* TNumber(schema_, references_, path2, value);
      case "Object":
        return yield* TObject(schema_, references_, path2, value);
      case "Promise":
        return yield* TPromise(schema_, references_, path2, value);
      case "Record":
        return yield* TRecord(schema_, references_, path2, value);
      case "Ref":
        return yield* TRef(schema_, references_, path2, value);
      case "String":
        return yield* TString(schema_, references_, path2, value);
      case "Symbol":
        return yield* TSymbol(schema_, references_, path2, value);
      case "TemplateLiteral":
        return yield* TTemplateLiteral(schema_, references_, path2, value);
      case "This":
        return yield* TThis(schema_, references_, path2, value);
      case "Tuple":
        return yield* TTuple(schema_, references_, path2, value);
      case "Undefined":
        return yield* TUndefined(schema_, references_, path2, value);
      case "Union":
        return yield* TUnion(schema_, references_, path2, value);
      case "Uint8Array":
        return yield* TUint8Array(schema_, references_, path2, value);
      case "Unknown":
        return yield* TUnknown();
      case "Void":
        return yield* TVoid(schema_, references_, path2, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueErrorsUnknownTypeError(schema);
        return yield* TKind(schema_, references_, path2, value);
    }
  }
  function Errors(...args) {
    const iterator2 = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
    return new ValueErrorIterator(iterator2);
  }
  errors$1.Errors = Errors;
  return errors$1;
}
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$2;
  hasRequiredErrors$1 = 1;
  (function(exports2) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(requireErrors$2(), exports2);
  })(errors$2);
  return errors$2;
}
const copyProps = (dest, src2, exclude = []) => {
  const props = Object.getOwnPropertyDescriptors(src2);
  for (let prop of exclude)
    delete props[prop];
  Object.defineProperties(dest, props);
};
const protoChain = (obj, currentChain = [obj]) => {
  const proto = Object.getPrototypeOf(obj);
  if (proto === null)
    return currentChain;
  return protoChain(proto, [...currentChain, proto]);
};
const nearestCommonProto = (...objs) => {
  if (objs.length === 0)
    return void 0;
  let commonProto = void 0;
  const protoChains = objs.map((obj) => protoChain(obj));
  while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
    const protos = protoChains.map((protoChain2) => protoChain2.pop());
    const potentialCommonProto = protos[0];
    if (protos.every((proto) => proto === potentialCommonProto))
      commonProto = potentialCommonProto;
    else
      break;
  }
  return commonProto;
};
const hardMixProtos = (ingredients, constructor, exclude = []) => {
  var _a;
  const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
  const mixedProto = Object.create(base);
  const visitedProtos = protoChain(base);
  for (let prototype of ingredients) {
    let protos = protoChain(prototype);
    for (let i = protos.length - 1; i >= 0; i--) {
      let newProto = protos[i];
      if (visitedProtos.indexOf(newProto) === -1) {
        copyProps(mixedProto, newProto, ["constructor", ...exclude]);
        visitedProtos.push(newProto);
      }
    }
  }
  mixedProto.constructor = constructor;
  return mixedProto;
};
const unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
const getIngredientWithProp = (prop, ingredients) => {
  const protoChains = ingredients.map((ingredient) => protoChain(ingredient));
  let protoDepth = 0;
  let protosAreLeftToSearch = true;
  while (protosAreLeftToSearch) {
    protosAreLeftToSearch = false;
    for (let i = ingredients.length - 1; i >= 0; i--) {
      const searchTarget = protoChains[i][protoDepth];
      if (searchTarget !== void 0 && searchTarget !== null) {
        protosAreLeftToSearch = true;
        if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
          return protoChains[i][0];
        }
      }
    }
    protoDepth++;
  }
  return void 0;
};
const proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
  getPrototypeOf() {
    return prototype;
  },
  setPrototypeOf() {
    throw Error("Cannot set prototype of Proxies created by ts-mixer");
  },
  getOwnPropertyDescriptor(_, prop) {
    return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);
  },
  defineProperty() {
    throw new Error("Cannot define new properties on Proxies created by ts-mixer");
  },
  has(_, prop) {
    return getIngredientWithProp(prop, ingredients) !== void 0 || prototype[prop] !== void 0;
  },
  get(_, prop) {
    return (getIngredientWithProp(prop, ingredients) || prototype)[prop];
  },
  set(_, prop, val) {
    const ingredientWithProp = getIngredientWithProp(prop, ingredients);
    if (ingredientWithProp === void 0)
      throw new Error("Cannot set new properties on Proxies created by ts-mixer");
    ingredientWithProp[prop] = val;
    return true;
  },
  deleteProperty() {
    throw new Error("Cannot delete properties on Proxies created by ts-mixer");
  },
  ownKeys() {
    return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
  }
});
const softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);
const settings$1 = {
  initFunction: null,
  staticsStrategy: "copy",
  prototypeStrategy: "copy",
  decoratorInheritance: "deep"
};
const mixins = /* @__PURE__ */ new WeakMap();
const getMixinsForClass = (clazz) => mixins.get(clazz);
const registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
const hasMixin = (instance, mixin) => {
  if (instance instanceof mixin)
    return true;
  const constructor = instance.constructor;
  const visited = /* @__PURE__ */ new Set();
  let frontier = /* @__PURE__ */ new Set();
  frontier.add(constructor);
  while (frontier.size > 0) {
    if (frontier.has(mixin))
      return true;
    frontier.forEach((item) => visited.add(item));
    const newFrontier = /* @__PURE__ */ new Set();
    frontier.forEach((item) => {
      var _a;
      const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
      if (itemConstituents)
        itemConstituents.forEach((constituent) => {
          if (!visited.has(constituent) && !frontier.has(constituent))
            newFrontier.add(constituent);
        });
    });
    frontier = newFrontier;
  }
  return false;
};
const mergeObjectsOfDecorators = (o1, o2) => {
  var _a, _b;
  const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
  const mergedObject = {};
  for (let key of allKeys)
    mergedObject[key] = unique([...(_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : [], ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []]);
  return mergedObject;
};
const mergePropertyAndMethodDecorators = (d1, d2) => {
  var _a, _b, _c, _d;
  return {
    property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
    method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
  };
};
const mergeDecorators = (d1, d2) => {
  var _a, _b, _c, _d, _e, _f;
  return {
    class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
    static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
    instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
  };
};
const decorators = /* @__PURE__ */ new Map();
const findAllConstituentClasses = (...classes) => {
  var _a;
  const allClasses = /* @__PURE__ */ new Set();
  const frontier = /* @__PURE__ */ new Set([...classes]);
  while (frontier.size > 0) {
    for (let clazz of frontier) {
      const protoChainClasses = protoChain(clazz.prototype).map((proto) => proto.constructor);
      const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];
      const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
      const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
      for (let newClass of newClasses)
        frontier.add(newClass);
      allClasses.add(clazz);
      frontier.delete(clazz);
    }
  }
  return [...allClasses];
};
const deepDecoratorSearch = (...classes) => {
  const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
  if (decoratorsForClassChain.length == 0)
    return {};
  if (decoratorsForClassChain.length == 1)
    return decoratorsForClassChain[0];
  return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
};
const directDecoratorSearch = (...classes) => {
  const classDecorators = classes.map((clazz) => getDecoratorsForClass(clazz));
  if (classDecorators.length === 0)
    return {};
  if (classDecorators.length === 1)
    return classDecorators[0];
  return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
};
const getDecoratorsForClass = (clazz) => {
  let decoratorsForClass = decorators.get(clazz);
  if (!decoratorsForClass) {
    decoratorsForClass = {};
    decorators.set(clazz, decoratorsForClass);
  }
  return decoratorsForClass;
};
const decorateClass = (decorator) => (clazz) => {
  const decoratorsForClass = getDecoratorsForClass(clazz);
  let classDecorators = decoratorsForClass.class;
  if (!classDecorators) {
    classDecorators = [];
    decoratorsForClass.class = classDecorators;
  }
  classDecorators.push(decorator);
  return decorator(clazz);
};
const decorateMember = (decorator) => (object2, key, ...otherArgs) => {
  var _a, _b, _c;
  const decoratorTargetType = typeof object2 === "function" ? "static" : "instance";
  const decoratorType = typeof object2[key] === "function" ? "method" : "property";
  const clazz = decoratorTargetType === "static" ? object2 : object2.constructor;
  const decoratorsForClass = getDecoratorsForClass(clazz);
  const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};
  decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
  let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
  decoratorsForTargetType[decoratorType] = decoratorsForType;
  let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
  decoratorsForType[key] = decoratorsForKey;
  decoratorsForKey.push(decorator);
  return decorator(object2, key, ...otherArgs);
};
const decorate = (decorator) => (...args) => {
  if (args.length === 1)
    return decorateClass(decorator)(args[0]);
  return decorateMember(decorator)(...args);
};
function Mixin(...constructors) {
  var _a, _b, _c;
  const prototypes = constructors.map((constructor) => constructor.prototype);
  const initFunctionName = settings$1.initFunction;
  if (initFunctionName !== null) {
    const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
    const combinedInitFunction = function(...args) {
      for (let initFunction of initFunctions)
        initFunction.apply(this, args);
    };
    const extraProto = { [initFunctionName]: combinedInitFunction };
    prototypes.push(extraProto);
  }
  function MixedClass(...args) {
    for (const constructor of constructors)
      copyProps(this, new constructor(...args));
    if (initFunctionName !== null && typeof this[initFunctionName] === "function")
      this[initFunctionName].apply(this, args);
  }
  MixedClass.prototype = settings$1.prototypeStrategy === "copy" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);
  Object.setPrototypeOf(MixedClass, settings$1.staticsStrategy === "copy" ? hardMixProtos(constructors, null, ["prototype"]) : proxyMix(constructors, Function.prototype));
  let DecoratedMixedClass = MixedClass;
  if (settings$1.decoratorInheritance !== "none") {
    const classDecorators = settings$1.decoratorInheritance === "deep" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);
    for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {
      const result = decorator(DecoratedMixedClass);
      if (result) {
        DecoratedMixedClass = result;
      }
    }
    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
  }
  registerMixins(DecoratedMixedClass, constructors);
  return DecoratedMixedClass;
}
const applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
  const propDecorators = propAndMethodDecorators.property;
  const methodDecorators = propAndMethodDecorators.method;
  if (propDecorators)
    for (let key in propDecorators)
      for (let decorator of propDecorators[key])
        decorator(target, key);
  if (methodDecorators)
    for (let key in methodDecorators)
      for (let decorator of methodDecorators[key])
        decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
};
const mix = (...ingredients) => (decoratedClass) => {
  const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
  Object.defineProperty(mixedClass, "name", {
    value: decoratedClass.name,
    writable: false
  });
  return mixedClass;
};
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Mixin,
  decorate,
  hasMixin,
  mix,
  settings: settings$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(esm);
var customTypes = {};
var arrayBuffer = {};
var hasRequiredArrayBuffer;
function requireArrayBuffer() {
  if (hasRequiredArrayBuffer) return arrayBuffer;
  hasRequiredArrayBuffer = 1;
  Object.defineProperty(arrayBuffer, "__esModule", { value: true });
  arrayBuffer.ArrayBufferBuilder = void 0;
  const typebox_1 = requireTypebox();
  typebox_1.TypeRegistry.Set("ArrayBuffer", (_, value) => value instanceof ArrayBuffer);
  class ArrayBufferBuilder extends typebox_1.JavaScriptTypeBuilder {
    ArrayBuffer(options) {
      return this.Create(Object.assign(Object.assign({}, options), { [typebox_1.Kind]: "ArrayBuffer", type: "ArrayBuffer" }));
    }
  }
  arrayBuffer.ArrayBufferBuilder = ArrayBufferBuilder;
  return arrayBuffer;
}
var buffer = {};
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  Object.defineProperty(buffer, "__esModule", { value: true });
  buffer.BufferBuilder = void 0;
  const typebox_1 = requireTypebox();
  typebox_1.TypeRegistry.Set("Buffer", (_, value) => value instanceof Buffer$1);
  class BufferBuilder extends typebox_1.JavaScriptTypeBuilder {
    Buffer(options) {
      return this.Create(Object.assign(Object.assign({}, options), { [typebox_1.Kind]: "Buffer", type: "Buffer" }));
    }
  }
  buffer.BufferBuilder = BufferBuilder;
  return buffer;
}
var keyofEnum = {};
var hasRequiredKeyofEnum;
function requireKeyofEnum() {
  if (hasRequiredKeyofEnum) return keyofEnum;
  hasRequiredKeyofEnum = 1;
  Object.defineProperty(keyofEnum, "__esModule", { value: true });
  keyofEnum.KeyofEnumBuilder = void 0;
  const typebox_1 = requireTypebox();
  class KeyofEnumBuilder extends typebox_1.JavaScriptTypeBuilder {
    KeyOfEnum(schema, options) {
      const keys = Object.keys(schema).map((key) => this.Literal(key));
      return this.Union(keys, Object.assign(Object.assign({}, options), { [typebox_1.Hint]: "KeyOfEnum" }));
    }
    Enum(schema, options) {
      const anyOf = Object.entries(schema).filter(([key, _value]) => typeof key === "string" || !isNaN(key)).map(([key, value]) => this.Literal(value, { $id: key }));
      return this.Union(anyOf, Object.assign(Object.assign({}, options), { [typebox_1.Hint]: "Enum" }));
    }
  }
  keyofEnum.KeyofEnumBuilder = KeyofEnumBuilder;
  return keyofEnum;
}
var uint = {};
var hasRequiredUint;
function requireUint() {
  if (hasRequiredUint) return uint;
  hasRequiredUint = 1;
  Object.defineProperty(uint, "__esModule", { value: true });
  uint.UintBuilder = void 0;
  const typebox_1 = requireTypebox();
  typebox_1.TypeRegistry.Set("Uint", (schema, value) => {
    if (typeof value !== "string" && typeof value !== "number") {
      return false;
    }
    if (typeof value === "number" && !Number.isSafeInteger(value) || !/^(?:[1-9]\d*|\d)$/.test(value.toString().replace(/^-/, schema.allowNegative ? "" : "-"))) {
      return false;
    }
    return true;
  });
  class UintBuilder extends typebox_1.JavaScriptTypeBuilder {
    Uint(options) {
      return this.Create(Object.assign(Object.assign({}, options), { [typebox_1.Kind]: "Uint", type: "Uint" }));
    }
  }
  uint.UintBuilder = UintBuilder;
  return uint;
}
var hasRequiredCustomTypes;
function requireCustomTypes() {
  if (hasRequiredCustomTypes) return customTypes;
  hasRequiredCustomTypes = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UintBuilder = exports2.KeyofEnumBuilder = exports2.BufferBuilder = exports2.ArrayBufferBuilder = void 0;
    var array_buffer_1 = requireArrayBuffer();
    Object.defineProperty(exports2, "ArrayBufferBuilder", { enumerable: true, get: function() {
      return array_buffer_1.ArrayBufferBuilder;
    } });
    var buffer_1 = requireBuffer();
    Object.defineProperty(exports2, "BufferBuilder", { enumerable: true, get: function() {
      return buffer_1.BufferBuilder;
    } });
    var keyof_enum_1 = requireKeyofEnum();
    Object.defineProperty(exports2, "KeyofEnumBuilder", { enumerable: true, get: function() {
      return keyof_enum_1.KeyofEnumBuilder;
    } });
    var uint_1 = requireUint();
    Object.defineProperty(exports2, "UintBuilder", { enumerable: true, get: function() {
      return uint_1.UintBuilder;
    } });
  })(customTypes);
  return customTypes;
}
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  Object.defineProperty(errors, "__esModule", { value: true });
  errors.InvalidParameter = void 0;
  class InvalidParameter extends Error {
    constructor(reason, field2, type2, value) {
      let message2 = `Invalid parameter`;
      message2 += ` "${field2.substring(1)}"`;
      message2 += ` (= ${JSON.stringify(value)})`;
      message2 += `: ${reason.replace(/'/g, '"')}`;
      super(message2);
      this.name = "InvalidParameter";
      this.field = field2;
      this.type = type2;
    }
  }
  errors.InvalidParameter = InvalidParameter;
  return errors;
}
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  Object.defineProperty(utils$1, "__esModule", { value: true });
  utils$1.getDeepValue = utils$1.setDeepValue = void 0;
  function setDeepValue(obj, [prop, ...path2], value) {
    if (!path2.length) {
      obj[prop] = value;
    } else {
      if (!(prop in obj))
        obj[prop] = {};
      setDeepValue(obj[prop], path2, value);
    }
  }
  utils$1.setDeepValue = setDeepValue;
  function getDeepValue(obj, [prop, ...path2]) {
    if (!path2.length) {
      return obj[prop];
    } else {
      if (!(prop in obj))
        return void 0;
      return getDeepValue(obj[prop], path2);
    }
  }
  utils$1.getDeepValue = getDeepValue;
  return utils$1;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeClone = exports2.Optional = exports2.Type = exports2.AssertWeak = exports2.Assert = exports2.Validate = void 0;
    const typebox_1 = requireTypebox();
    Object.defineProperty(exports2, "Optional", { enumerable: true, get: function() {
      return typebox_1.Optional;
    } });
    Object.defineProperty(exports2, "TypeClone", { enumerable: true, get: function() {
      return typebox_1.TypeClone;
    } });
    const errors_12 = requireErrors$1();
    const ts_mixer_1 = require$$2;
    const custom_types_1 = requireCustomTypes();
    const errors_2 = requireErrors();
    const utils_12 = requireUtils$1();
    class CustomTypeBuilder extends (0, ts_mixer_1.Mixin)(typebox_1.JavaScriptTypeBuilder, custom_types_1.ArrayBufferBuilder, custom_types_1.BufferBuilder, custom_types_1.KeyofEnumBuilder, custom_types_1.UintBuilder) {
    }
    function Validate(schema, value) {
      try {
        Assert(schema, value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.Validate = Validate;
    function FindErrorInUnion(error) {
      const currentValue = error.value;
      const unionMembers = error.schema.anyOf;
      const hasValidMember = unionMembers.find((unionSchema) => Validate(unionSchema, currentValue));
      if (!hasValidMember) {
        const possibleMatchesByLiterals = unionMembers.filter((unionSchema) => {
          if (unionSchema[typebox_1.Kind] !== "Object")
            return false;
          return !Object.entries(unionSchema.properties).find(([property, propertySchema]) => propertySchema.const && propertySchema.const !== currentValue[property]);
        });
        if (possibleMatchesByLiterals.length === 1) {
          Assert(possibleMatchesByLiterals[0], currentValue);
        } else if (possibleMatchesByLiterals.length > 1) {
          const errorsOfPossibleMatches = possibleMatchesByLiterals.map((matchSchema) => ({
            schema: matchSchema,
            errors: [...(0, errors_12.Errors)(matchSchema, currentValue)]
          }));
          const sortedErrors = errorsOfPossibleMatches.sort((a, b) => a.errors.length - b.errors.length);
          const [bestMatch] = sortedErrors;
          Assert(bestMatch.schema, currentValue);
        }
        throw new errors_2.InvalidParameter(error.message, error.path, error.type, error.value);
      }
    }
    function Assert(schema, value) {
      const errors2 = [...(0, errors_12.Errors)(schema, value)];
      let [error] = errors2;
      while (error) {
        if (error.path === "/" && errors2.length > 1) ;
        else if (error.value == null && error.schema[typebox_1.Optional] === "Optional") ;
        else if (error.type === errors_12.ValueErrorType.Union) {
          FindErrorInUnion(error);
        } else if (error.type === errors_12.ValueErrorType.Number && typeof error.value === "string") {
          const currentValue = error.value;
          const parsedNumber = Number(currentValue);
          if (!Number.isNaN(parsedNumber) && currentValue === parsedNumber.toString()) {
            const pathParts = error.path.slice(1).split("/");
            (0, utils_12.setDeepValue)(value, pathParts, parsedNumber);
          } else {
            throw new errors_2.InvalidParameter(error.message, error.path, error.type, error.value);
          }
        } else {
          throw new errors_2.InvalidParameter(error.message, error.path, error.type, error.value);
        }
        errors2.shift();
        [error] = errors2;
      }
    }
    exports2.Assert = Assert;
    function AssertWeak(schema, value) {
      try {
        Assert(schema, value);
      } catch (e) {
        if (e instanceof errors_2.InvalidParameter) {
          if (e.type === errors_12.ValueErrorType.ObjectRequiredProperty) {
            throw e;
          }
          console.warn("Method params validation failed", e);
        } else {
          throw e;
        }
      }
    }
    exports2.AssertWeak = AssertWeak;
    exports2.Type = new CustomTypeBuilder();
  })(lib$1);
  return lib$1;
}
var hasRequiredNem;
function requireNem() {
  if (hasRequiredNem) return nem;
  hasRequiredNem = 1;
  Object.defineProperty(nem, "__esModule", { value: true });
  nem.EnumTxVersion = nem.TxVersion = nem.EnumTxType = nem.TxType = nem.EnumNetworks = nem.Networks = void 0;
  const schema_utils_1 = requireLib$1();
  var Networks;
  (function(Networks2) {
    Networks2[Networks2["mainnet"] = 104] = "mainnet";
    Networks2[Networks2["testnet"] = 152] = "testnet";
    Networks2[Networks2["mijin"] = 96] = "mijin";
  })(Networks || (nem.Networks = Networks = {}));
  nem.EnumNetworks = schema_utils_1.Type.Enum(Networks);
  var TxType;
  (function(TxType2) {
    TxType2[TxType2["TRANSFER"] = 257] = "TRANSFER";
    TxType2[TxType2["COSIGNING"] = 258] = "COSIGNING";
    TxType2[TxType2["IMPORTANCE_TRANSFER"] = 2049] = "IMPORTANCE_TRANSFER";
    TxType2[TxType2["AGGREGATE_MODIFICATION"] = 4097] = "AGGREGATE_MODIFICATION";
    TxType2[TxType2["MULTISIG_SIGNATURE"] = 4098] = "MULTISIG_SIGNATURE";
    TxType2[TxType2["MULTISIG"] = 4100] = "MULTISIG";
    TxType2[TxType2["PROVISION_NAMESPACE"] = 8193] = "PROVISION_NAMESPACE";
    TxType2[TxType2["MOSAIC_CREATION"] = 16385] = "MOSAIC_CREATION";
    TxType2[TxType2["SUPPLY_CHANGE"] = 16386] = "SUPPLY_CHANGE";
  })(TxType || (nem.TxType = TxType = {}));
  nem.EnumTxType = schema_utils_1.Type.Enum(TxType);
  var TxVersion;
  (function(TxVersion2) {
    TxVersion2[TxVersion2["mainnet"] = 1744830464] = "mainnet";
    TxVersion2[TxVersion2["testnet"] = -1744830464] = "testnet";
    TxVersion2[TxVersion2["mijin"] = 1610612736] = "mijin";
  })(TxVersion || (nem.TxVersion = TxVersion = {}));
  nem.EnumTxVersion = schema_utils_1.Type.Enum(TxVersion);
  return nem;
}
var lib = {};
var decode = {};
var utils = {};
var indexLight = { exports: {} };
var indexMinimal = {};
var minimal = {};
var aspromise;
var hasRequiredAspromise;
function requireAspromise() {
  if (hasRequiredAspromise) return aspromise;
  hasRequiredAspromise = 1;
  aspromise = asPromise;
  function asPromise(fn, ctx) {
    var params2 = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while (index < arguments.length)
      params2[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
      params2[offset] = function callback(err) {
        if (pending) {
          pending = false;
          if (err)
            reject(err);
          else {
            var params3 = new Array(arguments.length - 1), offset2 = 0;
            while (offset2 < params3.length)
              params3[offset2++] = arguments[offset2];
            resolve.apply(null, params3);
          }
        }
      };
      try {
        fn.apply(ctx || null, params2);
      } catch (err) {
        if (pending) {
          pending = false;
          reject(err);
        }
      }
    });
  }
  return aspromise;
}
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  (function(exports2) {
    var base642 = exports2;
    base642.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (var i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    base642.encode = function encode2(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t2;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t2 = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t2 | b >> 4];
            t2 = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t2 | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t2];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode2(string, buffer2, offset) {
      var start = offset;
      var j = 0, t2;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t2 = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t2 << 2 | (c & 48) >> 4;
            t2 = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t2 & 15) << 4 | (c & 60) >> 2;
            t2 = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t2 & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  })(base64);
  return base64;
}
var eventemitter;
var hasRequiredEventemitter;
function requireEventemitter() {
  if (hasRequiredEventemitter) return eventemitter;
  hasRequiredEventemitter = 1;
  eventemitter = EventEmitter;
  function EventEmitter() {
    this._listeners = {};
  }
  EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
      fn,
      ctx: ctx || this
    });
    return this;
  };
  EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === void 0)
      this._listeners = {};
    else {
      if (fn === void 0)
        this._listeners[evt] = [];
      else {
        var listeners = this._listeners[evt];
        for (var i = 0; i < listeners.length; )
          if (listeners[i].fn === fn)
            listeners.splice(i, 1);
          else
            ++i;
      }
    }
    return this;
  };
  EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
      var args = [], i = 1;
      for (; i < arguments.length; )
        args.push(arguments[i++]);
      for (i = 0; i < listeners.length; )
        listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
  };
  return eventemitter;
}
var float;
var hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat) return float;
  hasRequiredFloat = 1;
  float = factory2(factory2);
  function factory2(exports2) {
    if (typeof Float32Array !== "undefined") (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[3];
        buf[pos + 1] = f8b[2];
        buf[pos + 2] = f8b[1];
        buf[pos + 3] = f8b[0];
      }
      exports2.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports2.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf, pos) {
        f8b[3] = buf[pos];
        f8b[2] = buf[pos + 1];
        f8b[1] = buf[pos + 2];
        f8b[0] = buf[pos + 3];
        return f32[0];
      }
      exports2.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
      exports2.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
    else (function() {
      function writeFloat_ieee754(writeUint, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf, pos);
        else if (isNaN(val))
          writeUint(2143289344, buf, pos);
        else if (val > 34028234663852886e22)
          writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
        else if (val < 11754943508222875e-54)
          writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
        }
      }
      exports2.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
      exports2.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
      function readFloat_ieee754(readUint, buf, pos) {
        var uint2 = readUint(buf, pos), sign = (uint2 >> 31) * 2 + 1, exponent = uint2 >>> 23 & 255, mantissa = uint2 & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports2.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
      exports2.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
    if (typeof Float64Array !== "undefined") (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
        buf[pos + 4] = f8b[4];
        buf[pos + 5] = f8b[5];
        buf[pos + 6] = f8b[6];
        buf[pos + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[7];
        buf[pos + 1] = f8b[6];
        buf[pos + 2] = f8b[5];
        buf[pos + 3] = f8b[4];
        buf[pos + 4] = f8b[3];
        buf[pos + 5] = f8b[2];
        buf[pos + 6] = f8b[1];
        buf[pos + 7] = f8b[0];
      }
      exports2.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports2.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        f8b[4] = buf[pos + 4];
        f8b[5] = buf[pos + 5];
        f8b[6] = buf[pos + 6];
        f8b[7] = buf[pos + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf, pos) {
        f8b[7] = buf[pos];
        f8b[6] = buf[pos + 1];
        f8b[5] = buf[pos + 2];
        f8b[4] = buf[pos + 3];
        f8b[3] = buf[pos + 4];
        f8b[2] = buf[pos + 5];
        f8b[1] = buf[pos + 6];
        f8b[0] = buf[pos + 7];
        return f64[0];
      }
      exports2.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
      exports2.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
    else (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0) {
          writeUint(0, buf, pos + off0);
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf, pos + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf, pos + off0);
          writeUint(2146959360, buf, pos + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf, pos + off0);
          writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf, pos + off0);
            writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
            writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
          }
        }
      }
      exports2.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
      exports2.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf, pos) {
        var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
        var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports2.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
      exports2.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
    return exports2;
  }
  function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
  }
  function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
  }
  function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
  }
  return float;
}
var inquire_1;
var hasRequiredInquire;
function requireInquire() {
  if (hasRequiredInquire) return inquire_1;
  hasRequiredInquire = 1;
  inquire_1 = inquire;
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e) {
    }
    return null;
  }
  return inquire_1;
}
var utf8 = {};
var hasRequiredUtf8;
function requireUtf8() {
  if (hasRequiredUtf8) return utf8;
  hasRequiredUtf8 = 1;
  (function(exports2) {
    var utf82 = exports2;
    utf82.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf82.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t2;
      while (start < end) {
        t2 = buffer2[start++];
        if (t2 < 128)
          chunk[i++] = t2;
        else if (t2 > 191 && t2 < 224)
          chunk[i++] = (t2 & 31) << 6 | buffer2[start++] & 63;
        else if (t2 > 239 && t2 < 365) {
          t2 = ((t2 & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t2 >> 10);
          chunk[i++] = 56320 + (t2 & 1023);
        } else
          chunk[i++] = (t2 & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf82.write = function utf8_write(string, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  })(utf8);
  return utf8;
}
var pool_1;
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool_1;
  hasRequiredPool = 1;
  pool_1 = pool;
  function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size2) {
      if (size2 < 1 || size2 > MAX)
        return alloc(size2);
      if (offset + size2 > SIZE) {
        slab = alloc(SIZE);
        offset = 0;
      }
      var buf = slice.call(slab, offset, offset += size2);
      if (offset & 7)
        offset = (offset | 7) + 1;
      return buf;
    };
  }
  return pool_1;
}
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits) return longbits;
  hasRequiredLongbits = 1;
  longbits = LongBits;
  var util2 = requireMinimal();
  function LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero = LongBits.zero = new LongBits(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits(lo, hi);
  };
  LongBits.from = function from2(value) {
    if (typeof value === "number")
      return LongBits.fromNumber(value);
    if (util2.isString(value)) {
      if (util2.Long)
        value = util2.Long.fromString(value);
      else
        return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits.prototype.toLong = function toLong(unsigned) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits.fromHash = function fromHash(hash2) {
    if (hash2 === zeroHash)
      return zero;
    return new LongBits(
      (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
      (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
    );
  };
  LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  };
  LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  if (hasRequiredMinimal) return minimal;
  hasRequiredMinimal = 1;
  (function(exports2) {
    var util2 = exports2;
    util2.asPromise = requireAspromise();
    util2.base64 = requireBase64();
    util2.EventEmitter = requireEventemitter();
    util2.float = requireFloat();
    util2.inquire = requireInquire();
    util2.utf8 = requireUtf8();
    util2.pool = requirePool();
    util2.LongBits = requireLongbits();
    util2.isNode = Boolean(typeof commonjsGlobal !== "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);
    util2.global = util2.isNode && commonjsGlobal || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util2.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util2.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer = util2.inquire("buffer").Buffer;
        return Buffer.prototype.utf8Write ? Buffer : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util2.LongBits.fromHash(hash2);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src2[keys[i]];
      return dst;
    }
    util2.merge = merge2;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer = util2.Buffer;
      if (!Buffer) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer(size);
      };
    };
  })(minimal);
  return minimal;
}
var writer;
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  hasRequiredWriter = 1;
  writer = Writer;
  var util2 = requireMinimal();
  var BufferWriter;
  var LongBits = util2.LongBits, base642 = util2.base64, utf82 = util2.utf8;
  function Op(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
  function noop2() {
  }
  function State(writer2) {
    this.head = writer2.head;
    this.tail = writer2.tail;
    this.len = writer2.len;
    this.next = writer2.states;
  }
  function Writer() {
    this.len = 0;
    this.head = new Op(noop2, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  var create = function create2() {
    return util2.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter();
      })();
    } : function create_array() {
      return new Writer();
    };
  };
  Writer.create = create();
  Writer.alloc = function alloc(size) {
    return new util2.Array(size);
  };
  if (util2.Array !== Array)
    Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
  Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  function VarintOp(len, val) {
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp(
      (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
      value
    )).len;
    return this;
  };
  Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  };
  Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.int64 = Writer.prototype.uint64;
  Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  };
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  };
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;
  Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;
  Writer.prototype.float = function write_float(value) {
    return this._push(util2.float.writeFloatLE, 4, value);
  };
  Writer.prototype.double = function write_double(value) {
    return this._push(util2.float.writeDoubleLE, 8, value);
  };
  var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytes_for(val, buf, pos) {
    for (var i = 0; i < val.length; ++i)
      buf[pos + i] = val[i];
  };
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util2.isString(value)) {
      var buf = Writer.alloc(len = base642.length(value));
      base642.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };
  Writer.prototype.string = function write_string(value) {
    var len = utf82.length(value);
    return len ? this.uint32(len)._push(utf82.write, len, value) : this._push(writeByte, 1, 0);
  };
  Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop2, 0, 0);
    this.len = 0;
    return this;
  };
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  };
  Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
  };
  return writer;
}
var writer_buffer;
var hasRequiredWriter_buffer;
function requireWriter_buffer() {
  if (hasRequiredWriter_buffer) return writer_buffer;
  hasRequiredWriter_buffer = 1;
  writer_buffer = BufferWriter;
  var Writer = requireWriter();
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
  var util2 = requireMinimal();
  function BufferWriter() {
    Writer.call(this);
  }
  BufferWriter._configure = function() {
    BufferWriter.alloc = util2._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else for (var i = 0; i < val.length; )
        buf[pos++] = val[i++];
    };
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util2.isString(value))
      value = util2._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
      this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
  };
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40)
      util2.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
      buf.utf8Write(val, pos);
    else
      buf.write(val, pos);
  }
  BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util2.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
      this._push(writeStringBuffer, len, value);
    return this;
  };
  BufferWriter._configure();
  return writer_buffer;
}
var reader;
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  reader = Reader;
  var util2 = requireMinimal();
  var BufferReader;
  var LongBits = util2.LongBits, utf82 = util2.utf8;
  function indexOutOfRange(reader2, writeLength) {
    return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
  }
  function Reader(buffer2) {
    this.buf = buffer2;
    this.pos = 0;
    this.len = buffer2.length;
  }
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
    if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
      return new Reader(buffer2);
    throw Error("illegal buffer");
  } : function create_array2(buffer2) {
    if (Array.isArray(buffer2))
      return new Reader(buffer2);
    throw Error("illegal buffer");
  };
  var create = function create2() {
    return util2.Buffer ? function create_buffer_setup(buffer2) {
      return (Reader.create = function create_buffer(buffer3) {
        return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
      })(buffer2);
    } : create_array;
  };
  Reader.create = create();
  Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
  util2.Array.prototype.slice;
  Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
    var value = 4294967295;
    return function read_uint32() {
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128) return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128) return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128) return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128) return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128) return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    };
  }();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  };
  function readLongVarint() {
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
      for (; i < 4; ++i) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
      i = 0;
    } else {
      for (; i < 3; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (; i < 5; ++i) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    } else {
      for (; i < 5; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  Reader.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  function readFixed64() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }
  Reader.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util2.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  };
  Reader.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util2.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    if (end > this.len)
      throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end);
    if (start === end) {
      var nativeBuffer = util2.Buffer;
      return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
  };
  Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf82.read(bytes, 0, bytes.length);
  };
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
      if (this.pos + length > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util2.Long ? "toLong" : (
      /* istanbul ignore next */
      "toNumber"
    );
    util2.merge(Reader.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn](false);
      }
    });
  };
  return reader;
}
var reader_buffer;
var hasRequiredReader_buffer;
function requireReader_buffer() {
  if (hasRequiredReader_buffer) return reader_buffer;
  hasRequiredReader_buffer = 1;
  reader_buffer = BufferReader;
  var Reader = requireReader();
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
  var util2 = requireMinimal();
  function BufferReader(buffer2) {
    Reader.call(this, buffer2);
  }
  BufferReader._configure = function() {
    if (util2.Buffer)
      BufferReader.prototype._slice = util2.Buffer.prototype.slice;
  };
  BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  };
  BufferReader._configure();
  return reader_buffer;
}
var rpc = {};
var service$1;
var hasRequiredService$1;
function requireService$1() {
  if (hasRequiredService$1) return service$1;
  hasRequiredService$1 = 1;
  service$1 = Service;
  var util2 = requireMinimal();
  (Service.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service;
  function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util2.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service.prototype.rpcCall = function rpcCall(method2, requestCtor, responseCtor, request, callback) {
    if (!request)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util2.asPromise(rpcCall, self2, method2, requestCtor, responseCtor, request);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return void 0;
    }
    try {
      return self2.rpcImpl(
        method2,
        requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
        function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method2);
            return callback(err);
          }
          if (response === null) {
            self2.end(
              /* endedByRPC */
              true
            );
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method2);
              return callback(err2);
            }
          }
          self2.emit("data", response, method2);
          return callback(null, response);
        }
      );
    } catch (err) {
      self2.emit("error", err, method2);
      setTimeout(function() {
        callback(err);
      }, 0);
      return void 0;
    }
  };
  Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
  return service$1;
}
var hasRequiredRpc;
function requireRpc() {
  if (hasRequiredRpc) return rpc;
  hasRequiredRpc = 1;
  (function(exports2) {
    var rpc2 = exports2;
    rpc2.Service = requireService$1();
  })(rpc);
  return rpc;
}
var roots;
var hasRequiredRoots;
function requireRoots() {
  if (hasRequiredRoots) return roots;
  hasRequiredRoots = 1;
  roots = {};
  return roots;
}
var hasRequiredIndexMinimal;
function requireIndexMinimal() {
  if (hasRequiredIndexMinimal) return indexMinimal;
  hasRequiredIndexMinimal = 1;
  (function(exports2) {
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = requireWriter();
    protobuf.BufferWriter = requireWriter_buffer();
    protobuf.Reader = requireReader();
    protobuf.BufferReader = requireReader_buffer();
    protobuf.util = requireMinimal();
    protobuf.rpc = requireRpc();
    protobuf.roots = requireRoots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  })(indexMinimal);
  return indexMinimal;
}
var util = { exports: {} };
var codegen_1;
var hasRequiredCodegen;
function requireCodegen() {
  if (hasRequiredCodegen) return codegen_1;
  hasRequiredCodegen = 1;
  codegen_1 = codegen;
  function codegen(functionParams, functionName) {
    if (typeof functionParams === "string") {
      functionName = functionParams;
      functionParams = void 0;
    }
    var body = [];
    function Codegen(formatStringOrScope) {
      if (typeof formatStringOrScope !== "string") {
        var source = toString();
        if (codegen.verbose)
          console.log("codegen: " + source);
        source = "return " + source;
        if (formatStringOrScope) {
          var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
          while (scopeOffset < scopeKeys.length) {
            scopeParams[scopeOffset] = scopeKeys[scopeOffset];
            scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
          }
          scopeParams[scopeOffset] = source;
          return Function.apply(null, scopeParams).apply(null, scopeValues);
        }
        return Function(source)();
      }
      var formatParams = new Array(arguments.length - 1), formatOffset = 0;
      while (formatOffset < formatParams.length)
        formatParams[formatOffset] = arguments[++formatOffset];
      formatOffset = 0;
      formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
        var value = formatParams[formatOffset++];
        switch ($1) {
          case "d":
          case "f":
            return String(Number(value));
          case "i":
            return String(Math.floor(value));
          case "j":
            return JSON.stringify(value);
          case "s":
            return String(value);
        }
        return "%";
      });
      if (formatOffset !== formatParams.length)
        throw Error("parameter count mismatch");
      body.push(formatStringOrScope);
      return Codegen;
    }
    function toString(functionNameOverride) {
      return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }
    Codegen.toString = toString;
    return Codegen;
  }
  codegen.verbose = false;
  return codegen_1;
}
var fetch_1;
var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch_1;
  hasRequiredFetch = 1;
  fetch_1 = fetch;
  var asPromise = requireAspromise(), inquire2 = requireInquire();
  var fs = inquire2("fs");
  function fetch(filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (!options)
      options = {};
    if (!callback)
      return asPromise(fetch, this, filename, options);
    if (!options.xhr && fs && fs.readFile)
      return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
        return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
      });
    return fetch.xhr(filename, options, callback);
  }
  fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function fetchOnReadyStateChange() {
      if (xhr.readyState !== 4)
        return void 0;
      if (xhr.status !== 0 && xhr.status !== 200)
        return callback(Error("status " + xhr.status));
      if (options.binary) {
        var buffer2 = xhr.response;
        if (!buffer2) {
          buffer2 = [];
          for (var i = 0; i < xhr.responseText.length; ++i)
            buffer2.push(xhr.responseText.charCodeAt(i) & 255);
        }
        return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer2) : buffer2);
      }
      return callback(null, xhr.responseText);
    };
    if (options.binary) {
      if ("overrideMimeType" in xhr)
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.responseType = "arraybuffer";
    }
    xhr.open("GET", filename);
    xhr.send();
  };
  return fetch_1;
}
var path = {};
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath) return path;
  hasRequiredPath = 1;
  (function(exports2) {
    var path2 = exports2;
    var isAbsolute = (
      /**
       * Tests if the specified path is absolute.
       * @param {string} path Path to test
       * @returns {boolean} `true` if path is absolute
       */
      path2.isAbsolute = function isAbsolute2(path3) {
        return /^(?:\/|\w+:)/.test(path3);
      }
    );
    var normalize = (
      /**
       * Normalizes the specified path.
       * @param {string} path Path to normalize
       * @returns {string} Normalized path
       */
      path2.normalize = function normalize2(path3) {
        path3 = path3.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
        var parts = path3.split("/"), absolute = isAbsolute(path3), prefix = "";
        if (absolute)
          prefix = parts.shift() + "/";
        for (var i = 0; i < parts.length; ) {
          if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
              parts.splice(--i, 2);
            else if (absolute)
              parts.splice(i, 1);
            else
              ++i;
          } else if (parts[i] === ".")
            parts.splice(i, 1);
          else
            ++i;
        }
        return prefix + parts.join("/");
      }
    );
    path2.resolve = function resolve(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
    };
  })(path);
  return path;
}
var types$2 = {};
var hasRequiredTypes$2;
function requireTypes$2() {
  if (hasRequiredTypes$2) return types$2;
  hasRequiredTypes$2 = 1;
  (function(exports2) {
    var types2 = exports2;
    var util2 = requireUtil();
    var s = [
      "double",
      // 0
      "float",
      // 1
      "int32",
      // 2
      "uint32",
      // 3
      "sint32",
      // 4
      "fixed32",
      // 5
      "sfixed32",
      // 6
      "int64",
      // 7
      "uint64",
      // 8
      "sint64",
      // 9
      "fixed64",
      // 10
      "sfixed64",
      // 11
      "bool",
      // 12
      "string",
      // 13
      "bytes"
      // 14
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length) o[s[i + offset]] = values[i++];
      return o;
    }
    types2.basic = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2,
      /* bytes    */
      2
    ]);
    types2.defaults = bake([
      /* double   */
      0,
      /* float    */
      0,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      0,
      /* sfixed32 */
      0,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      0,
      /* sfixed64 */
      0,
      /* bool     */
      false,
      /* string   */
      "",
      /* bytes    */
      util2.emptyArray,
      /* message  */
      null
    ]);
    types2.long = bake([
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1
    ], 7);
    types2.mapKey = bake([
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2
    ], 2);
    types2.packed = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0
    ]);
  })(types$2);
  return types$2;
}
var field;
var hasRequiredField;
function requireField() {
  if (hasRequiredField) return field;
  hasRequiredField = 1;
  field = Field;
  var ReflectionObject = requireObject();
  ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
  var Enum = require_enum(), types2 = requireTypes$2(), util2 = requireUtil();
  var Type;
  var ruleRe = /^required|optional|repeated$/;
  Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
  };
  function Field(name, id2, type2, rule, extend, options, comment) {
    if (util2.isObject(rule)) {
      comment = extend;
      options = rule;
      rule = extend = void 0;
    } else if (util2.isObject(extend)) {
      comment = options;
      options = extend;
      extend = void 0;
    }
    ReflectionObject.call(this, name, options);
    if (!util2.isInteger(id2) || id2 < 0)
      throw TypeError("id must be a non-negative integer");
    if (!util2.isString(type2))
      throw TypeError("type must be a string");
    if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
      throw TypeError("rule must be a string rule");
    if (extend !== void 0 && !util2.isString(extend))
      throw TypeError("extend must be a string");
    if (rule === "proto3_optional") {
      rule = "optional";
    }
    this.rule = rule && rule !== "optional" ? rule : void 0;
    this.type = type2;
    this.id = id2;
    this.extend = extend || void 0;
    this.required = rule === "required";
    this.optional = !this.required;
    this.repeated = rule === "repeated";
    this.map = false;
    this.message = null;
    this.partOf = null;
    this.typeDefault = null;
    this.defaultValue = null;
    this.long = util2.Long ? types2.long[type2] !== void 0 : (
      /* istanbul ignore next */
      false
    );
    this.bytes = type2 === "bytes";
    this.resolvedType = null;
    this.extensionField = null;
    this.declaringField = null;
    this._packed = null;
    this.comment = comment;
  }
  Object.defineProperty(Field.prototype, "packed", {
    get: function() {
      if (this._packed === null)
        this._packed = this.getOption("packed") !== false;
      return this._packed;
    }
  });
  Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed")
      this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
  };
  Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "rule",
      this.rule !== "optional" && this.rule || void 0,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  Field.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if ((this.typeDefault = types2.defaults[this.type]) === void 0) {
      this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
      if (this.resolvedType instanceof Type)
        this.typeDefault = null;
      else
        this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
    } else if (this.options && this.options.proto3_optional) {
      this.typeDefault = null;
    }
    if (this.options && this.options["default"] != null) {
      this.typeDefault = this.options["default"];
      if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
        this.typeDefault = this.resolvedType.values[this.typeDefault];
    }
    if (this.options) {
      if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
        delete this.options.packed;
      if (!Object.keys(this.options).length)
        this.options = void 0;
    }
    if (this.long) {
      this.typeDefault = util2.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
      if (Object.freeze)
        Object.freeze(this.typeDefault);
    } else if (this.bytes && typeof this.typeDefault === "string") {
      var buf;
      if (util2.base64.test(this.typeDefault))
        util2.base64.decode(this.typeDefault, buf = util2.newBuffer(util2.base64.length(this.typeDefault)), 0);
      else
        util2.utf8.write(this.typeDefault, buf = util2.newBuffer(util2.utf8.length(this.typeDefault)), 0);
      this.typeDefault = buf;
    }
    if (this.map)
      this.defaultValue = util2.emptyObject;
    else if (this.repeated)
      this.defaultValue = util2.emptyArray;
    else
      this.defaultValue = this.typeDefault;
    if (this.parent instanceof Type)
      this.parent.ctor.prototype[this.name] = this.defaultValue;
    return ReflectionObject.prototype.resolve.call(this);
  };
  Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
    if (typeof fieldType === "function")
      fieldType = util2.decorateType(fieldType).name;
    else if (fieldType && typeof fieldType === "object")
      fieldType = util2.decorateEnum(fieldType).name;
    return function fieldDecorator(prototype, fieldName) {
      util2.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
  };
  Field._configure = function configure(Type_) {
    Type = Type_;
  };
  return field;
}
var oneof;
var hasRequiredOneof;
function requireOneof() {
  if (hasRequiredOneof) return oneof;
  hasRequiredOneof = 1;
  oneof = OneOf;
  var ReflectionObject = requireObject();
  ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
  var Field = requireField(), util2 = requireUtil();
  function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
      options = fieldNames;
      fieldNames = void 0;
    }
    ReflectionObject.call(this, name, options);
    if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
      throw TypeError("fieldNames must be an Array");
    this.oneof = fieldNames || [];
    this.fieldsArray = [];
    this.comment = comment;
  }
  OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
  };
  OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "options",
      this.options,
      "oneof",
      this.oneof,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  function addFieldsToParent(oneof2) {
    if (oneof2.parent) {
      for (var i = 0; i < oneof2.fieldsArray.length; ++i)
        if (!oneof2.fieldsArray[i].parent)
          oneof2.parent.add(oneof2.fieldsArray[i]);
    }
  }
  OneOf.prototype.add = function add(field2) {
    if (!(field2 instanceof Field))
      throw TypeError("field must be a Field");
    if (field2.parent && field2.parent !== this.parent)
      field2.parent.remove(field2);
    this.oneof.push(field2.name);
    this.fieldsArray.push(field2);
    field2.partOf = this;
    addFieldsToParent(this);
    return this;
  };
  OneOf.prototype.remove = function remove(field2) {
    if (!(field2 instanceof Field))
      throw TypeError("field must be a Field");
    var index = this.fieldsArray.indexOf(field2);
    if (index < 0)
      throw Error(field2 + " is not a member of " + this);
    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field2.name);
    if (index > -1)
      this.oneof.splice(index, 1);
    field2.partOf = null;
    return this;
  };
  OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self2 = this;
    for (var i = 0; i < this.oneof.length; ++i) {
      var field2 = parent.get(this.oneof[i]);
      if (field2 && !field2.partOf) {
        field2.partOf = self2;
        self2.fieldsArray.push(field2);
      }
    }
    addFieldsToParent(this);
  };
  OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field2; i < this.fieldsArray.length; ++i)
      if ((field2 = this.fieldsArray[i]).parent)
        field2.parent.remove(field2);
    ReflectionObject.prototype.onRemove.call(this, parent);
  };
  OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length), index = 0;
    while (index < arguments.length)
      fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
      util2.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
      Object.defineProperty(prototype, oneofName, {
        get: util2.oneOfGetter(fieldNames),
        set: util2.oneOfSetter(fieldNames)
      });
    };
  };
  return oneof;
}
var namespace;
var hasRequiredNamespace;
function requireNamespace() {
  if (hasRequiredNamespace) return namespace;
  hasRequiredNamespace = 1;
  namespace = Namespace;
  var ReflectionObject = requireObject();
  ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
  var Field = requireField(), util2 = requireUtil(), OneOf = requireOneof();
  var Type, Service, Enum;
  Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
  };
  function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
      return void 0;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
      obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
  }
  Namespace.arrayToJSON = arrayToJSON;
  Namespace.isReservedId = function isReservedId(reserved, id2) {
    if (reserved) {
      for (var i = 0; i < reserved.length; ++i)
        if (typeof reserved[i] !== "string" && reserved[i][0] <= id2 && reserved[i][1] > id2)
          return true;
    }
    return false;
  };
  Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved) {
      for (var i = 0; i < reserved.length; ++i)
        if (reserved[i] === name)
          return true;
    }
    return false;
  };
  function Namespace(name, options) {
    ReflectionObject.call(this, name, options);
    this.nested = void 0;
    this._nestedArray = null;
  }
  function clearCache(namespace2) {
    namespace2._nestedArray = null;
    return namespace2;
  }
  Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
      return this._nestedArray || (this._nestedArray = util2.toArray(this.nested));
    }
  });
  Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util2.toObject([
      "options",
      this.options,
      "nested",
      arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
  };
  Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    if (nestedJson) {
      for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
        nested = nestedJson[names[i]];
        ns.add(
          // most to least likely
          (nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested)
        );
      }
    }
    return this;
  };
  Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name] || null;
  };
  Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
      return this.nested[name].values;
    throw Error("no such enum: " + name);
  };
  Namespace.prototype.add = function add(object2) {
    if (!(object2 instanceof Field && object2.extend !== void 0 || object2 instanceof Type || object2 instanceof OneOf || object2 instanceof Enum || object2 instanceof Service || object2 instanceof Namespace))
      throw TypeError("object must be a valid nested object");
    if (!this.nested)
      this.nested = {};
    else {
      var prev = this.get(object2.name);
      if (prev) {
        if (prev instanceof Namespace && object2 instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
          var nested = prev.nestedArray;
          for (var i = 0; i < nested.length; ++i)
            object2.add(nested[i]);
          this.remove(prev);
          if (!this.nested)
            this.nested = {};
          object2.setOptions(prev.options, true);
        } else
          throw Error("duplicate name '" + object2.name + "' in " + this);
      }
    }
    this.nested[object2.name] = object2;
    object2.onAdd(this);
    return clearCache(this);
  };
  Namespace.prototype.remove = function remove(object2) {
    if (!(object2 instanceof ReflectionObject))
      throw TypeError("object must be a ReflectionObject");
    if (object2.parent !== this)
      throw Error(object2 + " is not a member of " + this);
    delete this.nested[object2.name];
    if (!Object.keys(this.nested).length)
      this.nested = void 0;
    object2.onRemove(this);
    return clearCache(this);
  };
  Namespace.prototype.define = function define(path2, json) {
    if (util2.isString(path2))
      path2 = path2.split(".");
    else if (!Array.isArray(path2))
      throw TypeError("illegal path");
    if (path2 && path2.length && path2[0] === "")
      throw Error("path must be relative");
    var ptr = this;
    while (path2.length > 0) {
      var part = path2.shift();
      if (ptr.nested && ptr.nested[part]) {
        ptr = ptr.nested[part];
        if (!(ptr instanceof Namespace))
          throw Error("path conflicts with non-namespace objects");
      } else
        ptr.add(ptr = new Namespace(part));
    }
    if (json)
      ptr.addJSON(json);
    return ptr;
  };
  Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
      if (nested[i] instanceof Namespace)
        nested[i++].resolveAll();
      else
        nested[i++].resolve();
    return this.resolve();
  };
  Namespace.prototype.lookup = function lookup(path2, filterTypes, parentAlreadyChecked) {
    if (typeof filterTypes === "boolean") {
      parentAlreadyChecked = filterTypes;
      filterTypes = void 0;
    } else if (filterTypes && !Array.isArray(filterTypes))
      filterTypes = [filterTypes];
    if (util2.isString(path2) && path2.length) {
      if (path2 === ".")
        return this.root;
      path2 = path2.split(".");
    } else if (!path2.length)
      return this;
    if (path2[0] === "")
      return this.root.lookup(path2.slice(1), filterTypes);
    var found = this.get(path2[0]);
    if (found) {
      if (path2.length === 1) {
        if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
          return found;
      } else if (found instanceof Namespace && (found = found.lookup(path2.slice(1), filterTypes, true)))
        return found;
    } else
      for (var i = 0; i < this.nestedArray.length; ++i)
        if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path2, filterTypes, true)))
          return found;
    if (this.parent === null || parentAlreadyChecked)
      return null;
    return this.parent.lookup(path2, filterTypes);
  };
  Namespace.prototype.lookupType = function lookupType(path2) {
    var found = this.lookup(path2, [Type]);
    if (!found)
      throw Error("no such type: " + path2);
    return found;
  };
  Namespace.prototype.lookupEnum = function lookupEnum(path2) {
    var found = this.lookup(path2, [Enum]);
    if (!found)
      throw Error("no such Enum '" + path2 + "' in " + this);
    return found;
  };
  Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path2) {
    var found = this.lookup(path2, [Type, Enum]);
    if (!found)
      throw Error("no such Type or Enum '" + path2 + "' in " + this);
    return found;
  };
  Namespace.prototype.lookupService = function lookupService(path2) {
    var found = this.lookup(path2, [Service]);
    if (!found)
      throw Error("no such Service '" + path2 + "' in " + this);
    return found;
  };
  Namespace._configure = function(Type_, Service_, Enum_) {
    Type = Type_;
    Service = Service_;
    Enum = Enum_;
  };
  return namespace;
}
var mapfield;
var hasRequiredMapfield;
function requireMapfield() {
  if (hasRequiredMapfield) return mapfield;
  hasRequiredMapfield = 1;
  mapfield = MapField;
  var Field = requireField();
  ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
  var types2 = requireTypes$2(), util2 = requireUtil();
  function MapField(name, id2, keyType, type2, options, comment) {
    Field.call(this, name, id2, type2, void 0, void 0, options, comment);
    if (!util2.isString(keyType))
      throw TypeError("keyType must be a string");
    this.keyType = keyType;
    this.resolvedKeyType = null;
    this.map = true;
  }
  MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
  };
  MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "keyType",
      this.keyType,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  MapField.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if (types2.mapKey[this.keyType] === void 0)
      throw Error("invalid key type: " + this.keyType);
    return Field.prototype.resolve.call(this);
  };
  MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
    if (typeof fieldValueType === "function")
      fieldValueType = util2.decorateType(fieldValueType).name;
    else if (fieldValueType && typeof fieldValueType === "object")
      fieldValueType = util2.decorateEnum(fieldValueType).name;
    return function mapFieldDecorator(prototype, fieldName) {
      util2.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
  };
  return mapfield;
}
var method;
var hasRequiredMethod;
function requireMethod() {
  if (hasRequiredMethod) return method;
  hasRequiredMethod = 1;
  method = Method;
  var ReflectionObject = requireObject();
  ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
  var util2 = requireUtil();
  function Method(name, type2, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
    if (util2.isObject(requestStream)) {
      options = requestStream;
      requestStream = responseStream = void 0;
    } else if (util2.isObject(responseStream)) {
      options = responseStream;
      responseStream = void 0;
    }
    if (!(type2 === void 0 || util2.isString(type2)))
      throw TypeError("type must be a string");
    if (!util2.isString(requestType))
      throw TypeError("requestType must be a string");
    if (!util2.isString(responseType))
      throw TypeError("responseType must be a string");
    ReflectionObject.call(this, name, options);
    this.type = type2 || "rpc";
    this.requestType = requestType;
    this.requestStream = requestStream ? true : void 0;
    this.responseType = responseType;
    this.responseStream = responseStream ? true : void 0;
    this.resolvedRequestType = null;
    this.resolvedResponseType = null;
    this.comment = comment;
    this.parsedOptions = parsedOptions;
  }
  Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
  };
  Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "type",
      this.type !== "rpc" && /* istanbul ignore next */
      this.type || void 0,
      "requestType",
      this.requestType,
      "requestStream",
      this.requestStream,
      "responseType",
      this.responseType,
      "responseStream",
      this.responseStream,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : void 0,
      "parsedOptions",
      this.parsedOptions
    ]);
  };
  Method.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);
    return ReflectionObject.prototype.resolve.call(this);
  };
  return method;
}
var service;
var hasRequiredService;
function requireService() {
  if (hasRequiredService) return service;
  hasRequiredService = 1;
  service = Service;
  var Namespace = requireNamespace();
  ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
  var Method = requireMethod(), util2 = requireUtil(), rpc2 = requireRpc();
  function Service(name, options) {
    Namespace.call(this, name, options);
    this.methods = {};
    this._methodsArray = null;
  }
  Service.fromJSON = function fromJSON(name, json) {
    var service2 = new Service(name, json.options);
    if (json.methods)
      for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
        service2.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
      service2.addJSON(json.nested);
    service2.comment = json.comment;
    return service2;
  };
  Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "options",
      inherited && inherited.options || void 0,
      "methods",
      Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */
      {},
      "nested",
      inherited && inherited.nested || void 0,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
      return this._methodsArray || (this._methodsArray = util2.toArray(this.methods));
    }
  });
  function clearCache(service2) {
    service2._methodsArray = null;
    return service2;
  }
  Service.prototype.get = function get(name) {
    return this.methods[name] || Namespace.prototype.get.call(this, name);
  };
  Service.prototype.resolveAll = function resolveAll() {
    var methods2 = this.methodsArray;
    for (var i = 0; i < methods2.length; ++i)
      methods2[i].resolve();
    return Namespace.prototype.resolve.call(this);
  };
  Service.prototype.add = function add(object2) {
    if (this.get(object2.name))
      throw Error("duplicate name '" + object2.name + "' in " + this);
    if (object2 instanceof Method) {
      this.methods[object2.name] = object2;
      object2.parent = this;
      return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object2);
  };
  Service.prototype.remove = function remove(object2) {
    if (object2 instanceof Method) {
      if (this.methods[object2.name] !== object2)
        throw Error(object2 + " is not a member of " + this);
      delete this.methods[object2.name];
      object2.parent = null;
      return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object2);
  };
  Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc2.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method2; i < /* initializes */
    this.methodsArray.length; ++i) {
      var methodName = util2.lcFirst((method2 = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
      rpcService[methodName] = util2.codegen(["r", "c"], util2.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
        m: method2,
        q: method2.resolvedRequestType.ctor,
        s: method2.resolvedResponseType.ctor
      });
    }
    return rpcService;
  };
  return service;
}
var message;
var hasRequiredMessage;
function requireMessage() {
  if (hasRequiredMessage) return message;
  hasRequiredMessage = 1;
  message = Message;
  var util2 = requireMinimal();
  function Message(properties) {
    if (properties)
      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
        this[keys[i]] = properties[keys[i]];
  }
  Message.create = function create(properties) {
    return this.$type.create(properties);
  };
  Message.encode = function encode2(message2, writer2) {
    return this.$type.encode(message2, writer2);
  };
  Message.encodeDelimited = function encodeDelimited(message2, writer2) {
    return this.$type.encodeDelimited(message2, writer2);
  };
  Message.decode = function decode2(reader2) {
    return this.$type.decode(reader2);
  };
  Message.decodeDelimited = function decodeDelimited(reader2) {
    return this.$type.decodeDelimited(reader2);
  };
  Message.verify = function verify(message2) {
    return this.$type.verify(message2);
  };
  Message.fromObject = function fromObject(object2) {
    return this.$type.fromObject(object2);
  };
  Message.toObject = function toObject(message2, options) {
    return this.$type.toObject(message2, options);
  };
  Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util2.toJSONOptions);
  };
  return message;
}
var decoder_1;
var hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder) return decoder_1;
  hasRequiredDecoder = 1;
  decoder_1 = decoder;
  var Enum = require_enum(), types2 = requireTypes$2(), util2 = requireUtil();
  function missing(field2) {
    return "missing required '" + field2.name + "'";
  }
  function decoder(mtype) {
    var gen = util2.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field3) {
      return field3.map;
    }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
    if (mtype.group) gen("if((t&7)===4)")("break");
    gen("switch(t>>>3){");
    var i = 0;
    for (; i < /* initializes */
    mtype.fieldsArray.length; ++i) {
      var field2 = mtype._fieldsArray[i].resolve(), type2 = field2.resolvedType instanceof Enum ? "int32" : field2.type, ref = "m" + util2.safeProp(field2.name);
      gen("case %i: {", field2.id);
      if (field2.map) {
        gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
        if (types2.defaults[field2.keyType] !== void 0) gen("k=%j", types2.defaults[field2.keyType]);
        else gen("k=null");
        if (types2.defaults[type2] !== void 0) gen("value=%j", types2.defaults[type2]);
        else gen("value=null");
        gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field2.keyType)("case 2:");
        if (types2.basic[type2] === void 0) gen("value=types[%i].decode(r,r.uint32())", i);
        else gen("value=r.%s()", type2);
        gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
        if (types2.long[field2.keyType] !== void 0) gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
        else gen("%s[k]=value", ref);
      } else if (field2.repeated) {
        gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
        if (types2.packed[type2] !== void 0) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type2)("}else");
        if (types2.basic[type2] === void 0) gen(field2.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
        else gen("%s.push(r.%s())", ref, type2);
      } else if (types2.basic[type2] === void 0) gen(field2.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);
      else gen("%s=r.%s()", ref, type2);
      gen("break")("}");
    }
    gen("default:")("r.skipType(t&7)")("break")("}")("}");
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
      var rfield = mtype._fieldsArray[i];
      if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }
    return gen("return m");
  }
  return decoder_1;
}
var verifier_1;
var hasRequiredVerifier;
function requireVerifier() {
  if (hasRequiredVerifier) return verifier_1;
  hasRequiredVerifier = 1;
  verifier_1 = verifier;
  var Enum = require_enum(), util2 = requireUtil();
  function invalid(field2, expected) {
    return field2.name + ": " + expected + (field2.repeated && expected !== "array" ? "[]" : field2.map && expected !== "object" ? "{k:" + field2.keyType + "}" : "") + " expected";
  }
  function genVerifyValue(gen, field2, fieldIndex, ref) {
    if (field2.resolvedType) {
      if (field2.resolvedType instanceof Enum) {
        gen("switch(%s){", ref)("default:")("return%j", invalid(field2, "enum value"));
        for (var keys = Object.keys(field2.resolvedType.values), j = 0; j < keys.length; ++j) gen("case %i:", field2.resolvedType.values[keys[j]]);
        gen("break")("}");
      } else {
        gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field2.name + ".")("}");
      }
    } else {
      switch (field2.type) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field2, "integer"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field2, "integer|Long"));
          break;
        case "float":
        case "double":
          gen('if(typeof %s!=="number")', ref)("return%j", invalid(field2, "number"));
          break;
        case "bool":
          gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field2, "boolean"));
          break;
        case "string":
          gen("if(!util.isString(%s))", ref)("return%j", invalid(field2, "string"));
          break;
        case "bytes":
          gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field2, "buffer"));
          break;
      }
    }
    return gen;
  }
  function genVerifyKey(gen, field2, ref) {
    switch (field2.keyType) {
      case "int32":
      case "uint32":
      case "sint32":
      case "fixed32":
      case "sfixed32":
        gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field2, "integer key"));
        break;
      case "int64":
      case "uint64":
      case "sint64":
      case "fixed64":
      case "sfixed64":
        gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field2, "integer|Long key"));
        break;
      case "bool":
        gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field2, "boolean key"));
        break;
    }
    return gen;
  }
  function verifier(mtype) {
    var gen = util2.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
    var oneofs = mtype.oneofsArray, seenFirstField = {};
    if (oneofs.length) gen("var p={}");
    for (var i = 0; i < /* initializes */
    mtype.fieldsArray.length; ++i) {
      var field2 = mtype._fieldsArray[i].resolve(), ref = "m" + util2.safeProp(field2.name);
      if (field2.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field2.name);
      if (field2.map) {
        gen("if(!util.isObject(%s))", ref)("return%j", invalid(field2, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
        genVerifyKey(gen, field2, "k[i]");
        genVerifyValue(gen, field2, i, ref + "[k[i]]")("}");
      } else if (field2.repeated) {
        gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field2, "array"))("for(var i=0;i<%s.length;++i){", ref);
        genVerifyValue(gen, field2, i, ref + "[i]")("}");
      } else {
        if (field2.partOf) {
          var oneofProp = util2.safeProp(field2.partOf.name);
          if (seenFirstField[field2.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field2.partOf.name + ": multiple values");
          seenFirstField[field2.partOf.name] = 1;
          gen("p%s=1", oneofProp);
        }
        genVerifyValue(gen, field2, i, ref);
      }
      if (field2.optional) gen("}");
    }
    return gen("return null");
  }
  return verifier_1;
}
var converter = {};
var hasRequiredConverter;
function requireConverter() {
  if (hasRequiredConverter) return converter;
  hasRequiredConverter = 1;
  (function(exports2) {
    var converter2 = exports2;
    var Enum = require_enum(), util2 = requireUtil();
    function genValuePartial_fromObject(gen, field2, fieldIndex, prop) {
      var defaultAlreadyEmitted = false;
      if (field2.resolvedType) {
        if (field2.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field2.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (values[keys[i]] === field2.typeDefault && !defaultAlreadyEmitted) {
              gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
              if (!field2.repeated) gen("break");
              defaultAlreadyEmitted = true;
            }
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field2.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field2.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter2.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util2.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length) return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field2 = fields[i].resolve(), prop = util2.safeProp(field2.name);
        if (field2.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field2.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field2,
            /* not sorted */
            i,
            prop + "[ks[i]]"
          )("}")("}");
        } else if (field2.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field2.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field2,
            /* not sorted */
            i,
            prop + "[i]"
          )("}")("}");
        } else {
          if (!(field2.resolvedType instanceof Enum)) gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(
            gen,
            field2,
            /* not sorted */
            i,
            prop
          );
          if (!(field2.resolvedType instanceof Enum)) gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field2, fieldIndex, prop) {
      if (field2.resolvedType) {
        if (field2.resolvedType instanceof Enum) gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field2.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter2.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util2.compareFieldsById);
      if (!fields.length)
        return util2.codegen()("return {}");
      var gen = util2.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i)
        if (!fields[i].partOf)
          (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen("d%s=[]", util2.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen("d%s={}", util2.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field2 = normalFields[i], prop = util2.safeProp(field2.name);
          if (field2.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field2.resolvedType.valuesById[field2.typeDefault], field2.typeDefault);
          else if (field2.long) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field2.typeDefault.low, field2.typeDefault.high, field2.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field2.typeDefault.toString(), field2.typeDefault.toNumber());
          else if (field2.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field2.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field2.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else gen("d%s=%j", prop, field2.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field2 = fields[i], index = mtype._fieldsArray.indexOf(field2), prop = util2.safeProp(field2.name);
        if (field2.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(
            gen,
            field2,
            /* sorted */
            index,
            prop + "[ks2[j]]"
          )("}");
        } else if (field2.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(
            gen,
            field2,
            /* sorted */
            index,
            prop + "[j]"
          )("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field2.name);
          genValuePartial_toObject(
            gen,
            field2,
            /* sorted */
            index,
            prop
          );
          if (field2.partOf) gen("if(o.oneofs)")("d%s=%j", util2.safeProp(field2.partOf.name), field2.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  })(converter);
  return converter;
}
var wrappers = {};
var hasRequiredWrappers;
function requireWrappers() {
  if (hasRequiredWrappers) return wrappers;
  hasRequiredWrappers = 1;
  (function(exports2) {
    var wrappers2 = exports2;
    var Message = requireMessage();
    wrappers2[".google.protobuf.Any"] = {
      fromObject: function(object2) {
        if (object2 && object2["@type"]) {
          var name = object2["@type"].substring(object2["@type"].lastIndexOf("/") + 1);
          var type2 = this.lookup(name);
          if (type2) {
            var type_url = object2["@type"].charAt(0) === "." ? object2["@type"].slice(1) : object2["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type2.encode(type2.fromObject(object2)).finish()
            });
          }
        }
        return this.fromObject(object2);
      },
      toObject: function(message2, options) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";
        if (options && options.json && message2.type_url && message2.value) {
          name = message2.type_url.substring(message2.type_url.lastIndexOf("/") + 1);
          prefix = message2.type_url.substring(0, message2.type_url.lastIndexOf("/") + 1);
          var type2 = this.lookup(name);
          if (type2)
            message2 = type2.decode(message2.value);
        }
        if (!(message2 instanceof this.ctor) && message2 instanceof Message) {
          var object2 = message2.$type.toObject(message2, options);
          var messageName = message2.$type.fullName[0] === "." ? message2.$type.fullName.slice(1) : message2.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name = prefix + messageName;
          object2["@type"] = name;
          return object2;
        }
        return this.toObject(message2, options);
      }
    };
  })(wrappers);
  return wrappers;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = Type;
  var Namespace = requireNamespace();
  ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
  var Enum = require_enum(), OneOf = requireOneof(), Field = requireField(), MapField = requireMapfield(), Service = requireService(), Message = requireMessage(), Reader = requireReader(), Writer = requireWriter(), util2 = requireUtil(), encoder = requireEncoder(), decoder = requireDecoder(), verifier = requireVerifier(), converter2 = requireConverter(), wrappers2 = requireWrappers();
  function Type(name, options) {
    Namespace.call(this, name, options);
    this.fields = {};
    this.oneofs = void 0;
    this.extensions = void 0;
    this.reserved = void 0;
    this.group = void 0;
    this._fieldsById = null;
    this._fieldsArray = null;
    this._oneofsArray = null;
    this._ctor = null;
  }
  Object.defineProperties(Type.prototype, {
    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
      get: function() {
        if (this._fieldsById)
          return this._fieldsById;
        this._fieldsById = {};
        for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
          var field2 = this.fields[names[i]], id2 = field2.id;
          if (this._fieldsById[id2])
            throw Error("duplicate id " + id2 + " in " + this);
          this._fieldsById[id2] = field2;
        }
        return this._fieldsById;
      }
    },
    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
      get: function() {
        return this._fieldsArray || (this._fieldsArray = util2.toArray(this.fields));
      }
    },
    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
      get: function() {
        return this._oneofsArray || (this._oneofsArray = util2.toArray(this.oneofs));
      }
    },
    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
      get: function() {
        return this._ctor || (this.ctor = Type.generateConstructor(this)());
      },
      set: function(ctor) {
        var prototype = ctor.prototype;
        if (!(prototype instanceof Message)) {
          (ctor.prototype = new Message()).constructor = ctor;
          util2.merge(ctor.prototype, prototype);
        }
        ctor.$type = ctor.prototype.$type = this;
        util2.merge(ctor, Message, true);
        this._ctor = ctor;
        var i = 0;
        for (; i < /* initializes */
        this.fieldsArray.length; ++i)
          this._fieldsArray[i].resolve();
        var ctorProperties = {};
        for (i = 0; i < /* initializes */
        this.oneofsArray.length; ++i)
          ctorProperties[this._oneofsArray[i].resolve().name] = {
            get: util2.oneOfGetter(this._oneofsArray[i].oneof),
            set: util2.oneOfSetter(this._oneofsArray[i].oneof)
          };
        if (i)
          Object.defineProperties(ctor.prototype, ctorProperties);
      }
    }
  });
  Type.generateConstructor = function generateConstructor(mtype) {
    var gen = util2.codegen(["p"], mtype.name);
    for (var i = 0, field2; i < mtype.fieldsArray.length; ++i)
      if ((field2 = mtype._fieldsArray[i]).map) gen("this%s={}", util2.safeProp(field2.name));
      else if (field2.repeated) gen("this%s=[]", util2.safeProp(field2.name));
    return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
  };
  function clearCache(type2) {
    type2._fieldsById = type2._fieldsArray = type2._oneofsArray = null;
    delete type2.encode;
    delete type2.decode;
    delete type2.verify;
    return type2;
  }
  Type.fromJSON = function fromJSON(name, json) {
    var type2 = new Type(name, json.options);
    type2.extensions = json.extensions;
    type2.reserved = json.reserved;
    var names = Object.keys(json.fields), i = 0;
    for (; i < names.length; ++i)
      type2.add(
        (typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]])
      );
    if (json.oneofs)
      for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
        type2.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
      for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
        var nested = json.nested[names[i]];
        type2.add(
          // most to least likely
          (nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested)
        );
      }
    if (json.extensions && json.extensions.length)
      type2.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
      type2.reserved = json.reserved;
    if (json.group)
      type2.group = true;
    if (json.comment)
      type2.comment = json.comment;
    return type2;
  };
  Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "options",
      inherited && inherited.options || void 0,
      "oneofs",
      Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
      "fields",
      Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
        return !obj.declaringField;
      }), toJSONOptions) || {},
      "extensions",
      this.extensions && this.extensions.length ? this.extensions : void 0,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : void 0,
      "group",
      this.group || void 0,
      "nested",
      inherited && inherited.nested || void 0,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
      fields[i++].resolve();
    var oneofs = this.oneofsArray;
    i = 0;
    while (i < oneofs.length)
      oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
  };
  Type.prototype.get = function get(name) {
    return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
  };
  Type.prototype.add = function add(object2) {
    if (this.get(object2.name))
      throw Error("duplicate name '" + object2.name + "' in " + this);
    if (object2 instanceof Field && object2.extend === void 0) {
      if (this._fieldsById ? (
        /* istanbul ignore next */
        this._fieldsById[object2.id]
      ) : this.fieldsById[object2.id])
        throw Error("duplicate id " + object2.id + " in " + this);
      if (this.isReservedId(object2.id))
        throw Error("id " + object2.id + " is reserved in " + this);
      if (this.isReservedName(object2.name))
        throw Error("name '" + object2.name + "' is reserved in " + this);
      if (object2.parent)
        object2.parent.remove(object2);
      this.fields[object2.name] = object2;
      object2.message = this;
      object2.onAdd(this);
      return clearCache(this);
    }
    if (object2 instanceof OneOf) {
      if (!this.oneofs)
        this.oneofs = {};
      this.oneofs[object2.name] = object2;
      object2.onAdd(this);
      return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object2);
  };
  Type.prototype.remove = function remove(object2) {
    if (object2 instanceof Field && object2.extend === void 0) {
      if (!this.fields || this.fields[object2.name] !== object2)
        throw Error(object2 + " is not a member of " + this);
      delete this.fields[object2.name];
      object2.parent = null;
      object2.onRemove(this);
      return clearCache(this);
    }
    if (object2 instanceof OneOf) {
      if (!this.oneofs || this.oneofs[object2.name] !== object2)
        throw Error(object2 + " is not a member of " + this);
      delete this.oneofs[object2.name];
      object2.parent = null;
      object2.onRemove(this);
      return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object2);
  };
  Type.prototype.isReservedId = function isReservedId(id2) {
    return Namespace.isReservedId(this.reserved, id2);
  };
  Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
  };
  Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
  };
  Type.prototype.setup = function setup() {
    var fullName = this.fullName, types2 = [];
    for (var i = 0; i < /* initializes */
    this.fieldsArray.length; ++i)
      types2.push(this._fieldsArray[i].resolve().resolvedType);
    this.encode = encoder(this)({
      Writer,
      types: types2,
      util: util2
    });
    this.decode = decoder(this)({
      Reader,
      types: types2,
      util: util2
    });
    this.verify = verifier(this)({
      types: types2,
      util: util2
    });
    this.fromObject = converter2.fromObject(this)({
      types: types2,
      util: util2
    });
    this.toObject = converter2.toObject(this)({
      types: types2,
      util: util2
    });
    var wrapper = wrappers2[fullName];
    if (wrapper) {
      var originalThis = Object.create(this);
      originalThis.fromObject = this.fromObject;
      this.fromObject = wrapper.fromObject.bind(originalThis);
      originalThis.toObject = this.toObject;
      this.toObject = wrapper.toObject.bind(originalThis);
    }
    return this;
  };
  Type.prototype.encode = function encode_setup(message2, writer2) {
    return this.setup().encode(message2, writer2);
  };
  Type.prototype.encodeDelimited = function encodeDelimited(message2, writer2) {
    return this.encode(message2, writer2 && writer2.len ? writer2.fork() : writer2).ldelim();
  };
  Type.prototype.decode = function decode_setup(reader2, length) {
    return this.setup().decode(reader2, length);
  };
  Type.prototype.decodeDelimited = function decodeDelimited(reader2) {
    if (!(reader2 instanceof Reader))
      reader2 = Reader.create(reader2);
    return this.decode(reader2, reader2.uint32());
  };
  Type.prototype.verify = function verify_setup(message2) {
    return this.setup().verify(message2);
  };
  Type.prototype.fromObject = function fromObject(object2) {
    return this.setup().fromObject(object2);
  };
  Type.prototype.toObject = function toObject(message2, options) {
    return this.setup().toObject(message2, options);
  };
  Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
      util2.decorateType(target, typeName);
    };
  };
  return type;
}
var root;
var hasRequiredRoot;
function requireRoot() {
  if (hasRequiredRoot) return root;
  hasRequiredRoot = 1;
  root = Root;
  var Namespace = requireNamespace();
  ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
  var Field = requireField(), Enum = require_enum(), OneOf = requireOneof(), util2 = requireUtil();
  var Type, parse2, common;
  function Root(options) {
    Namespace.call(this, "", options);
    this.deferred = [];
    this.files = [];
  }
  Root.fromJSON = function fromJSON(json, root2) {
    if (!root2)
      root2 = new Root();
    if (json.options)
      root2.setOptions(json.options);
    return root2.addJSON(json.nested);
  };
  Root.prototype.resolvePath = util2.path.resolve;
  Root.prototype.fetch = util2.fetch;
  function SYNC() {
  }
  Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    var self2 = this;
    if (!callback)
      return util2.asPromise(load, self2, filename, options);
    var sync = callback === SYNC;
    function finish(err, root2) {
      if (!callback)
        return;
      if (sync)
        throw err;
      var cb = callback;
      callback = null;
      cb(err, root2);
    }
    function getBundledFileName(filename2) {
      var idx = filename2.lastIndexOf("google/protobuf/");
      if (idx > -1) {
        var altname = filename2.substring(idx);
        if (altname in common) return altname;
      }
      return null;
    }
    function process2(filename2, source) {
      try {
        if (util2.isString(source) && source.charAt(0) === "{")
          source = JSON.parse(source);
        if (!util2.isString(source))
          self2.setOptions(source.options).addJSON(source.nested);
        else {
          parse2.filename = filename2;
          var parsed = parse2(source, self2, options), resolved2, i2 = 0;
          if (parsed.imports) {
            for (; i2 < parsed.imports.length; ++i2)
              if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                fetch(resolved2);
          }
          if (parsed.weakImports) {
            for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
              if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                fetch(resolved2, true);
          }
        }
      } catch (err) {
        finish(err);
      }
      if (!sync && !queued)
        finish(null, self2);
    }
    function fetch(filename2, weak) {
      filename2 = getBundledFileName(filename2) || filename2;
      if (self2.files.indexOf(filename2) > -1)
        return;
      self2.files.push(filename2);
      if (filename2 in common) {
        if (sync)
          process2(filename2, common[filename2]);
        else {
          ++queued;
          setTimeout(function() {
            --queued;
            process2(filename2, common[filename2]);
          });
        }
        return;
      }
      if (sync) {
        var source;
        try {
          source = util2.fs.readFileSync(filename2).toString("utf8");
        } catch (err) {
          if (!weak)
            finish(err);
          return;
        }
        process2(filename2, source);
      } else {
        ++queued;
        self2.fetch(filename2, function(err, source2) {
          --queued;
          if (!callback)
            return;
          if (err) {
            if (!weak)
              finish(err);
            else if (!queued)
              finish(null, self2);
            return;
          }
          process2(filename2, source2);
        });
      }
    }
    var queued = 0;
    if (util2.isString(filename))
      filename = [filename];
    for (var i = 0, resolved; i < filename.length; ++i)
      if (resolved = self2.resolvePath("", filename[i]))
        fetch(resolved);
    if (sync)
      return self2;
    if (!queued)
      finish(null, self2);
    return void 0;
  };
  Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util2.isNode)
      throw Error("not supported");
    return this.load(filename, options, SYNC);
  };
  Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
      throw Error("unresolvable extensions: " + this.deferred.map(function(field2) {
        return "'extend " + field2.extend + "' in " + field2.parent.fullName;
      }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
  };
  var exposeRe = /^[A-Z]/;
  function tryHandleExtension(root2, field2) {
    var extendedType = field2.parent.lookup(field2.extend);
    if (extendedType) {
      var sisterField = new Field(field2.fullName, field2.id, field2.type, field2.rule, void 0, field2.options);
      if (extendedType.get(sisterField.name)) {
        return true;
      }
      sisterField.declaringField = field2;
      field2.extensionField = sisterField;
      extendedType.add(sisterField);
      return true;
    }
    return false;
  }
  Root.prototype._handleAdd = function _handleAdd(object2) {
    if (object2 instanceof Field) {
      if (
        /* an extension field (implies not part of a oneof) */
        object2.extend !== void 0 && /* not already handled */
        !object2.extensionField
      ) {
        if (!tryHandleExtension(this, object2))
          this.deferred.push(object2);
      }
    } else if (object2 instanceof Enum) {
      if (exposeRe.test(object2.name))
        object2.parent[object2.name] = object2.values;
    } else if (!(object2 instanceof OneOf)) {
      if (object2 instanceof Type)
        for (var i = 0; i < this.deferred.length; )
          if (tryHandleExtension(this, this.deferred[i]))
            this.deferred.splice(i, 1);
          else
            ++i;
      for (var j = 0; j < /* initializes */
      object2.nestedArray.length; ++j)
        this._handleAdd(object2._nestedArray[j]);
      if (exposeRe.test(object2.name))
        object2.parent[object2.name] = object2;
    }
  };
  Root.prototype._handleRemove = function _handleRemove(object2) {
    if (object2 instanceof Field) {
      if (
        /* an extension field */
        object2.extend !== void 0
      ) {
        if (
          /* already handled */
          object2.extensionField
        ) {
          object2.extensionField.parent.remove(object2.extensionField);
          object2.extensionField = null;
        } else {
          var index = this.deferred.indexOf(object2);
          if (index > -1)
            this.deferred.splice(index, 1);
        }
      }
    } else if (object2 instanceof Enum) {
      if (exposeRe.test(object2.name))
        delete object2.parent[object2.name];
    } else if (object2 instanceof Namespace) {
      for (var i = 0; i < /* initializes */
      object2.nestedArray.length; ++i)
        this._handleRemove(object2._nestedArray[i]);
      if (exposeRe.test(object2.name))
        delete object2.parent[object2.name];
    }
  };
  Root._configure = function(Type_, parse_, common_) {
    Type = Type_;
    parse2 = parse_;
    common = common_;
  };
  return root;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util.exports;
  hasRequiredUtil = 1;
  var util$1 = util.exports = requireMinimal();
  var roots2 = requireRoots();
  var Type, Enum;
  util$1.codegen = requireCodegen();
  util$1.fetch = requireFetch();
  util$1.path = requirePath();
  util$1.fs = util$1.inquire("fs");
  util$1.toArray = function toArray(object2) {
    if (object2) {
      var keys = Object.keys(object2), array = new Array(keys.length), index = 0;
      while (index < keys.length)
        array[index] = object2[keys[index++]];
      return array;
    }
    return [];
  };
  util$1.toObject = function toObject(array) {
    var object2 = {}, index = 0;
    while (index < array.length) {
      var key = array[index++], val = array[index++];
      if (val !== void 0)
        object2[key] = val;
    }
    return object2;
  };
  var safePropBackslashRe = /\\/g, safePropQuoteRe = /"/g;
  util$1.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
  };
  util$1.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util$1.isReserved(prop))
      return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
    return "." + prop;
  };
  util$1.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
  };
  var camelCaseRe = /_([a-z])/g;
  util$1.camelCase = function camelCase(str) {
    return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
      return $1.toUpperCase();
    });
  };
  util$1.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
  };
  util$1.decorateType = function decorateType(ctor, typeName) {
    if (ctor.$type) {
      if (typeName && ctor.$type.name !== typeName) {
        util$1.decorateRoot.remove(ctor.$type);
        ctor.$type.name = typeName;
        util$1.decorateRoot.add(ctor.$type);
      }
      return ctor.$type;
    }
    if (!Type)
      Type = requireType();
    var type2 = new Type(typeName || ctor.name);
    util$1.decorateRoot.add(type2);
    type2.ctor = ctor;
    Object.defineProperty(ctor, "$type", { value: type2, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type2, enumerable: false });
    return type2;
  };
  var decorateEnumIndex = 0;
  util$1.decorateEnum = function decorateEnum(object2) {
    if (object2.$type)
      return object2.$type;
    if (!Enum)
      Enum = require_enum();
    var enm = new Enum("Enum" + decorateEnumIndex++, object2);
    util$1.decorateRoot.add(enm);
    Object.defineProperty(object2, "$type", { value: enm, enumerable: false });
    return enm;
  };
  util$1.setProperty = function setProperty(dst, path2, value) {
    function setProp(dst2, path3, value2) {
      var part = path3.shift();
      if (part === "__proto__" || part === "prototype") {
        return dst2;
      }
      if (path3.length > 0) {
        dst2[part] = setProp(dst2[part] || {}, path3, value2);
      } else {
        var prevValue = dst2[part];
        if (prevValue)
          value2 = [].concat(prevValue).concat(value2);
        dst2[part] = value2;
      }
      return dst2;
    }
    if (typeof dst !== "object")
      throw TypeError("dst must be an object");
    if (!path2)
      throw TypeError("path must be specified");
    path2 = path2.split(".");
    return setProp(dst, path2, value);
  };
  Object.defineProperty(util$1, "decorateRoot", {
    get: function() {
      return roots2["decorated"] || (roots2["decorated"] = new (requireRoot())());
    }
  });
  return util.exports;
}
var object;
var hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object;
  hasRequiredObject = 1;
  object = ReflectionObject;
  ReflectionObject.className = "ReflectionObject";
  var util2 = requireUtil();
  var Root;
  function ReflectionObject(name, options) {
    if (!util2.isString(name))
      throw TypeError("name must be a string");
    if (options && !util2.isObject(options))
      throw TypeError("options must be an object");
    this.options = options;
    this.parsedOptions = null;
    this.name = name;
    this.parent = null;
    this.resolved = false;
    this.comment = null;
    this.filename = null;
  }
  Object.defineProperties(ReflectionObject.prototype, {
    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
      get: function() {
        var ptr = this;
        while (ptr.parent !== null)
          ptr = ptr.parent;
        return ptr;
      }
    },
    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
      get: function() {
        var path2 = [this.name], ptr = this.parent;
        while (ptr) {
          path2.unshift(ptr.name);
          ptr = ptr.parent;
        }
        return path2.join(".");
      }
    }
  });
  ReflectionObject.prototype.toJSON = /* istanbul ignore next */
  function toJSON() {
    throw Error();
  };
  ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
      this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root2 = parent.root;
    if (root2 instanceof Root)
      root2._handleAdd(this);
  };
  ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root2 = parent.root;
    if (root2 instanceof Root)
      root2._handleRemove(this);
    this.parent = null;
    this.resolved = false;
  };
  ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if (this.root instanceof Root)
      this.resolved = true;
    return this;
  };
  ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
      return this.options[name];
    return void 0;
  };
  ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === void 0)
      (this.options || (this.options = {}))[name] = value;
    return this;
  };
  ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
      this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
      var opt = parsedOptions.find(function(opt2) {
        return Object.prototype.hasOwnProperty.call(opt2, name);
      });
      if (opt) {
        var newValue = opt[name];
        util2.setProperty(newValue, propName, value);
      } else {
        opt = {};
        opt[name] = util2.setProperty({}, propName, value);
        parsedOptions.push(opt);
      }
    } else {
      var newOpt = {};
      newOpt[name] = value;
      parsedOptions.push(newOpt);
    }
    return this;
  };
  ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
      for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
        this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
  };
  ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className, fullName = this.fullName;
    if (fullName.length)
      return className + " " + fullName;
    return className;
  };
  ReflectionObject._configure = function(Root_) {
    Root = Root_;
  };
  return object;
}
var _enum;
var hasRequired_enum;
function require_enum() {
  if (hasRequired_enum) return _enum;
  hasRequired_enum = 1;
  _enum = Enum;
  var ReflectionObject = requireObject();
  ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
  var Namespace = requireNamespace(), util2 = requireUtil();
  function Enum(name, values, options, comment, comments, valuesOptions) {
    ReflectionObject.call(this, name, options);
    if (values && typeof values !== "object")
      throw TypeError("values must be an object");
    this.valuesById = {};
    this.values = Object.create(this.valuesById);
    this.comment = comment;
    this.comments = comments || {};
    this.valuesOptions = valuesOptions;
    this.reserved = void 0;
    if (values) {
      for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
        if (typeof values[keys[i]] === "number")
          this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
    }
  }
  Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
  };
  Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "options",
      this.options,
      "valuesOptions",
      this.valuesOptions,
      "values",
      this.values,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : void 0,
      "comment",
      keepComments ? this.comment : void 0,
      "comments",
      keepComments ? this.comments : void 0
    ]);
  };
  Enum.prototype.add = function add(name, id2, comment, options) {
    if (!util2.isString(name))
      throw TypeError("name must be a string");
    if (!util2.isInteger(id2))
      throw TypeError("id must be an integer");
    if (this.values[name] !== void 0)
      throw Error("duplicate name '" + name + "' in " + this);
    if (this.isReservedId(id2))
      throw Error("id " + id2 + " is reserved in " + this);
    if (this.isReservedName(name))
      throw Error("name '" + name + "' is reserved in " + this);
    if (this.valuesById[id2] !== void 0) {
      if (!(this.options && this.options.allow_alias))
        throw Error("duplicate id " + id2 + " in " + this);
      this.values[name] = id2;
    } else
      this.valuesById[this.values[name] = id2] = name;
    if (options) {
      if (this.valuesOptions === void 0)
        this.valuesOptions = {};
      this.valuesOptions[name] = options || null;
    }
    this.comments[name] = comment || null;
    return this;
  };
  Enum.prototype.remove = function remove(name) {
    if (!util2.isString(name))
      throw TypeError("name must be a string");
    var val = this.values[name];
    if (val == null)
      throw Error("name '" + name + "' does not exist in " + this);
    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];
    if (this.valuesOptions)
      delete this.valuesOptions[name];
    return this;
  };
  Enum.prototype.isReservedId = function isReservedId(id2) {
    return Namespace.isReservedId(this.reserved, id2);
  };
  Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
  };
  return _enum;
}
var encoder_1;
var hasRequiredEncoder;
function requireEncoder() {
  if (hasRequiredEncoder) return encoder_1;
  hasRequiredEncoder = 1;
  encoder_1 = encoder;
  var Enum = require_enum(), types2 = requireTypes$2(), util2 = requireUtil();
  function genTypePartial(gen, field2, fieldIndex, ref) {
    return field2.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field2.id << 3 | 3) >>> 0, (field2.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field2.id << 3 | 2) >>> 0);
  }
  function encoder(mtype) {
    var gen = util2.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
    var i, ref;
    var fields = (
      /* initializes */
      mtype.fieldsArray.slice().sort(util2.compareFieldsById)
    );
    for (var i = 0; i < fields.length; ++i) {
      var field2 = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field2), type2 = field2.resolvedType instanceof Enum ? "int32" : field2.type, wireType = types2.basic[type2];
      ref = "m" + util2.safeProp(field2.name);
      if (field2.map) {
        gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field2.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field2.id << 3 | 2) >>> 0, 8 | types2.mapKey[field2.keyType], field2.keyType);
        if (wireType === void 0) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
        else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type2, ref);
        gen("}")("}");
      } else if (field2.repeated) {
        gen("if(%s!=null&&%s.length){", ref, ref);
        if (field2.packed && types2.packed[type2] !== void 0) {
          gen("w.uint32(%i).fork()", (field2.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type2, ref)("w.ldelim()");
        } else {
          gen("for(var i=0;i<%s.length;++i)", ref);
          if (wireType === void 0)
            genTypePartial(gen, field2, index, ref + "[i]");
          else gen("w.uint32(%i).%s(%s[i])", (field2.id << 3 | wireType) >>> 0, type2, ref);
        }
        gen("}");
      } else {
        if (field2.optional) gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field2.name);
        if (wireType === void 0)
          genTypePartial(gen, field2, index, ref);
        else gen("w.uint32(%i).%s(%s)", (field2.id << 3 | wireType) >>> 0, type2, ref);
      }
    }
    return gen("return w");
  }
  return encoder_1;
}
var hasRequiredIndexLight;
function requireIndexLight() {
  if (hasRequiredIndexLight) return indexLight.exports;
  hasRequiredIndexLight = 1;
  var protobuf = indexLight.exports = requireIndexMinimal();
  protobuf.build = "light";
  function load(filename, root2, callback) {
    if (typeof root2 === "function") {
      callback = root2;
      root2 = new protobuf.Root();
    } else if (!root2)
      root2 = new protobuf.Root();
    return root2.load(filename, callback);
  }
  protobuf.load = load;
  function loadSync(filename, root2) {
    if (!root2)
      root2 = new protobuf.Root();
    return root2.loadSync(filename);
  }
  protobuf.loadSync = loadSync;
  protobuf.encoder = requireEncoder();
  protobuf.decoder = requireDecoder();
  protobuf.verifier = requireVerifier();
  protobuf.converter = requireConverter();
  protobuf.ReflectionObject = requireObject();
  protobuf.Namespace = requireNamespace();
  protobuf.Root = requireRoot();
  protobuf.Enum = require_enum();
  protobuf.Type = requireType();
  protobuf.Field = requireField();
  protobuf.OneOf = requireOneof();
  protobuf.MapField = requireMapfield();
  protobuf.Service = requireService();
  protobuf.Method = requireMethod();
  protobuf.Message = requireMessage();
  protobuf.wrappers = requireWrappers();
  protobuf.types = requireTypes$2();
  protobuf.util = requireUtil();
  protobuf.ReflectionObject._configure(protobuf.Root);
  protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
  protobuf.Root._configure(protobuf.Type);
  protobuf.Field._configure(protobuf.Type);
  return indexLight.exports;
}
var light;
var hasRequiredLight;
function requireLight() {
  if (hasRequiredLight) return light;
  hasRequiredLight = 1;
  light = requireIndexLight();
  return light;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", { value: true });
  utils.createMessageFromType = utils.createMessageFromName = utils.parseConfigure = utils.isPrimitiveField = void 0;
  const tslib_12 = require$$0;
  const protobuf = tslib_12.__importStar(requireLight());
  const primitiveTypes = [
    "bool",
    "string",
    "bytes",
    "int32",
    "int64",
    "uint32",
    "uint64",
    "sint32",
    "sint64",
    "fixed32",
    "fixed64",
    "sfixed32",
    "sfixed64",
    "double",
    "float"
  ];
  const isPrimitiveField = (field2) => primitiveTypes.includes(field2);
  utils.isPrimitiveField = isPrimitiveField;
  function parseConfigure(data) {
    if (typeof data === "string") {
      return protobuf.Root.fromJSON(JSON.parse(data));
    }
    return protobuf.Root.fromJSON(data);
  }
  utils.parseConfigure = parseConfigure;
  const createMessageFromName = (messages2, name) => {
    const Message = messages2.lookupType(name);
    const MessageType = messages2.lookupEnum("MessageType");
    let messageTypeId = MessageType.values[`MessageType_${name}`];
    if (typeof messageTypeId !== "number" && Message.options) {
      messageTypeId = Message.options["(wire_type)"];
    }
    return {
      Message,
      messageType: messageTypeId !== null && messageTypeId !== void 0 ? messageTypeId : name
    };
  };
  utils.createMessageFromName = createMessageFromName;
  const createMessageFromType = (messages2, messageType) => {
    if (typeof messageType === "string") {
      const Message2 = messages2.lookupType(messageType);
      return {
        Message: Message2,
        messageName: messageType
      };
    }
    const messageTypes = messages2.lookupEnum("MessageType");
    const messageName = messageTypes.valuesById[messageType].replace("MessageType_", "");
    const Message = messages2.lookupType(messageName);
    return {
      Message,
      messageName
    };
  };
  utils.createMessageFromType = createMessageFromType;
  return utils;
}
var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode) return decode;
  hasRequiredDecode = 1;
  Object.defineProperty(decode, "__esModule", { value: true });
  decode.decode = decode.messageToJSON = void 0;
  const tslib_12 = require$$0;
  const utils_12 = requireUtils();
  const transform = (field2, value) => {
    if ((0, utils_12.isPrimitiveField)(field2.type)) {
      if (field2.optional && typeof value === "undefined") {
        return null;
      }
      if (field2.type === "bytes") {
        return Buffer$1.from(value).toString("hex");
      }
      if (field2.long) {
        if (Number.isSafeInteger(value.toNumber())) {
          return value.toNumber();
        }
        return value.toString();
      }
      return value;
    }
    if ("valuesById" in field2.resolvedType) {
      return field2.resolvedType.valuesById[value];
    }
    if (field2.resolvedType.fields) {
      return messageToJSON(value, field2.resolvedType.fields);
    }
    throw new Error(`transport: decode: case not handled: ${field2}`);
  };
  function messageToJSON(MessageParam, fields) {
    if (!MessageParam) {
      return {};
    }
    const message2 = tslib_12.__rest(MessageParam, []);
    const res = {};
    Object.keys(fields).forEach((key) => {
      const field2 = fields[key];
      const value = message2[key];
      if (field2.repeated) {
        res[key] = value.map((v) => transform(field2, v));
      } else {
        res[key] = transform(field2, value);
      }
    });
    return res;
  }
  decode.messageToJSON = messageToJSON;
  const decode$12 = (MessageParam, data) => {
    const decoded = MessageParam.decode(new Uint8Array(data));
    return messageToJSON(decoded, decoded.$type.fields);
  };
  decode.decode = decode$12;
  return decode;
}
var encode = {};
var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode) return encode;
  hasRequiredEncode = 1;
  Object.defineProperty(encode, "__esModule", { value: true });
  encode.encode = encode.patch = void 0;
  const light_1 = requireLight();
  const utils_12 = requireUtils();
  const transform = (fieldType, value) => {
    if (fieldType === "bytes") {
      if (typeof value === "string" && !value)
        return value;
      return Buffer$1.from(value, "hex");
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new RangeError("field value is not within safe integer range");
    }
    return value;
  };
  function patch2(Message, payload) {
    const patched = {};
    if (!Message.fields) {
      return patched;
    }
    Object.keys(Message.fields).forEach((key) => {
      const field2 = Message.fields[key];
      const value = payload[key];
      if (typeof value === "undefined") {
        return;
      }
      if ((0, utils_12.isPrimitiveField)(field2.type)) {
        if (field2.repeated) {
          patched[key] = value.map((v) => transform(field2.type, v));
        } else {
          patched[key] = transform(field2.type, value);
        }
        return;
      }
      if (field2.repeated) {
        const fieldType = Message.lookupTypeOrEnum(field2.type);
        if (fieldType instanceof light_1.Enum) {
          patched[key] = value;
        } else {
          patched[key] = value.map((v) => patch2(fieldType, v));
        }
      } else if (typeof value === "object" && value !== null) {
        const RefMessage = Message.lookupType(field2.type);
        patched[key] = patch2(RefMessage, value);
      } else if (typeof value === "number") {
        const RefMessage = Message.lookupEnum(field2.type);
        patched[key] = RefMessage.values[value];
      } else {
        patched[key] = value;
      }
    });
    return patched;
  }
  encode.patch = patch2;
  const encode$12 = (Message, data) => {
    const payload = patch2(Message, data);
    const message2 = Message.fromObject(payload);
    const bytes = Message.encode(message2).finish();
    return Buffer$1.from(bytes);
  };
  encode.encode = encode$12;
  return encode;
}
var messages = {};
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages;
  hasRequiredMessages = 1;
  Object.defineProperty(messages, "__esModule", { value: true });
  messages.TezosBallotType = messages.TezosContractType = messages.StellarSignerType = messages.StellarMemoType = messages.StellarAssetType = messages.NEMImportanceTransferMode = messages.NEMModificationType = messages.NEMSupplyChangeType = messages.NEMMosaicLevy = messages.MoneroNetworkType = messages.BootCommand = messages.Enum_WordRequestType = messages.SdProtectOperationType = messages.Enum_RecoveryType = messages.RecoveryDeviceInputMethod = messages.Enum_Capability = messages.Enum_RecoveryStatus = messages.Enum_BackupAvailability = messages.Enum_HomescreenFormat = messages.Enum_SafetyCheckLevel = messages.Enum_BackupType = messages.EthereumDataType = messages.EthereumDefinitionType = messages.DebugPhysicalButton = messages.DebugButton = messages.Enum_PinMatrixRequestType = messages.Enum_ButtonRequestType = messages.FailureType = messages.CardanoTxWitnessType = messages.CardanoTxSigningMode = messages.CardanoCVoteRegistrationFormat = messages.CardanoTxAuxiliaryDataSupplementType = messages.CardanoPoolRelayType = messages.CardanoDRepType = messages.CardanoCertificateType = messages.CardanoTxOutputSerializationFormat = messages.CardanoNativeScriptHashDisplayFormat = messages.CardanoNativeScriptType = messages.CardanoAddressType = messages.CardanoDerivationType = messages.Enum_RequestType = messages.AmountUnit = messages.DecredStakingSpendType = messages.Enum_OutputScriptType = messages.Enum_InputScriptType = messages.BinanceTimeInForce = messages.BinanceOrderSide = messages.BinanceOrderType = messages.DeviceModelInternal = void 0;
  var DeviceModelInternal;
  (function(DeviceModelInternal2) {
    DeviceModelInternal2["T1B1"] = "T1B1";
    DeviceModelInternal2["T2T1"] = "T2T1";
    DeviceModelInternal2["T2B1"] = "T2B1";
    DeviceModelInternal2["T3T1"] = "T3T1";
  })(DeviceModelInternal || (messages.DeviceModelInternal = DeviceModelInternal = {}));
  var BinanceOrderType;
  (function(BinanceOrderType2) {
    BinanceOrderType2[BinanceOrderType2["OT_UNKNOWN"] = 0] = "OT_UNKNOWN";
    BinanceOrderType2[BinanceOrderType2["MARKET"] = 1] = "MARKET";
    BinanceOrderType2[BinanceOrderType2["LIMIT"] = 2] = "LIMIT";
    BinanceOrderType2[BinanceOrderType2["OT_RESERVED"] = 3] = "OT_RESERVED";
  })(BinanceOrderType || (messages.BinanceOrderType = BinanceOrderType = {}));
  var BinanceOrderSide;
  (function(BinanceOrderSide2) {
    BinanceOrderSide2[BinanceOrderSide2["SIDE_UNKNOWN"] = 0] = "SIDE_UNKNOWN";
    BinanceOrderSide2[BinanceOrderSide2["BUY"] = 1] = "BUY";
    BinanceOrderSide2[BinanceOrderSide2["SELL"] = 2] = "SELL";
  })(BinanceOrderSide || (messages.BinanceOrderSide = BinanceOrderSide = {}));
  var BinanceTimeInForce;
  (function(BinanceTimeInForce2) {
    BinanceTimeInForce2[BinanceTimeInForce2["TIF_UNKNOWN"] = 0] = "TIF_UNKNOWN";
    BinanceTimeInForce2[BinanceTimeInForce2["GTE"] = 1] = "GTE";
    BinanceTimeInForce2[BinanceTimeInForce2["TIF_RESERVED"] = 2] = "TIF_RESERVED";
    BinanceTimeInForce2[BinanceTimeInForce2["IOC"] = 3] = "IOC";
  })(BinanceTimeInForce || (messages.BinanceTimeInForce = BinanceTimeInForce = {}));
  var Enum_InputScriptType;
  (function(Enum_InputScriptType2) {
    Enum_InputScriptType2[Enum_InputScriptType2["SPENDADDRESS"] = 0] = "SPENDADDRESS";
    Enum_InputScriptType2[Enum_InputScriptType2["SPENDMULTISIG"] = 1] = "SPENDMULTISIG";
    Enum_InputScriptType2[Enum_InputScriptType2["EXTERNAL"] = 2] = "EXTERNAL";
    Enum_InputScriptType2[Enum_InputScriptType2["SPENDWITNESS"] = 3] = "SPENDWITNESS";
    Enum_InputScriptType2[Enum_InputScriptType2["SPENDP2SHWITNESS"] = 4] = "SPENDP2SHWITNESS";
    Enum_InputScriptType2[Enum_InputScriptType2["SPENDTAPROOT"] = 5] = "SPENDTAPROOT";
  })(Enum_InputScriptType || (messages.Enum_InputScriptType = Enum_InputScriptType = {}));
  var Enum_OutputScriptType;
  (function(Enum_OutputScriptType2) {
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOADDRESS"] = 0] = "PAYTOADDRESS";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOSCRIPTHASH"] = 1] = "PAYTOSCRIPTHASH";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOMULTISIG"] = 2] = "PAYTOMULTISIG";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOOPRETURN"] = 3] = "PAYTOOPRETURN";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOWITNESS"] = 4] = "PAYTOWITNESS";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOP2SHWITNESS"] = 5] = "PAYTOP2SHWITNESS";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOTAPROOT"] = 6] = "PAYTOTAPROOT";
  })(Enum_OutputScriptType || (messages.Enum_OutputScriptType = Enum_OutputScriptType = {}));
  var DecredStakingSpendType;
  (function(DecredStakingSpendType2) {
    DecredStakingSpendType2[DecredStakingSpendType2["SSGen"] = 0] = "SSGen";
    DecredStakingSpendType2[DecredStakingSpendType2["SSRTX"] = 1] = "SSRTX";
  })(DecredStakingSpendType || (messages.DecredStakingSpendType = DecredStakingSpendType = {}));
  var AmountUnit;
  (function(AmountUnit2) {
    AmountUnit2[AmountUnit2["BITCOIN"] = 0] = "BITCOIN";
    AmountUnit2[AmountUnit2["MILLIBITCOIN"] = 1] = "MILLIBITCOIN";
    AmountUnit2[AmountUnit2["MICROBITCOIN"] = 2] = "MICROBITCOIN";
    AmountUnit2[AmountUnit2["SATOSHI"] = 3] = "SATOSHI";
  })(AmountUnit || (messages.AmountUnit = AmountUnit = {}));
  var Enum_RequestType;
  (function(Enum_RequestType2) {
    Enum_RequestType2[Enum_RequestType2["TXINPUT"] = 0] = "TXINPUT";
    Enum_RequestType2[Enum_RequestType2["TXOUTPUT"] = 1] = "TXOUTPUT";
    Enum_RequestType2[Enum_RequestType2["TXMETA"] = 2] = "TXMETA";
    Enum_RequestType2[Enum_RequestType2["TXFINISHED"] = 3] = "TXFINISHED";
    Enum_RequestType2[Enum_RequestType2["TXEXTRADATA"] = 4] = "TXEXTRADATA";
    Enum_RequestType2[Enum_RequestType2["TXORIGINPUT"] = 5] = "TXORIGINPUT";
    Enum_RequestType2[Enum_RequestType2["TXORIGOUTPUT"] = 6] = "TXORIGOUTPUT";
    Enum_RequestType2[Enum_RequestType2["TXPAYMENTREQ"] = 7] = "TXPAYMENTREQ";
  })(Enum_RequestType || (messages.Enum_RequestType = Enum_RequestType = {}));
  var CardanoDerivationType;
  (function(CardanoDerivationType2) {
    CardanoDerivationType2[CardanoDerivationType2["LEDGER"] = 0] = "LEDGER";
    CardanoDerivationType2[CardanoDerivationType2["ICARUS"] = 1] = "ICARUS";
    CardanoDerivationType2[CardanoDerivationType2["ICARUS_TREZOR"] = 2] = "ICARUS_TREZOR";
  })(CardanoDerivationType || (messages.CardanoDerivationType = CardanoDerivationType = {}));
  var CardanoAddressType;
  (function(CardanoAddressType2) {
    CardanoAddressType2[CardanoAddressType2["BASE"] = 0] = "BASE";
    CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_KEY"] = 1] = "BASE_SCRIPT_KEY";
    CardanoAddressType2[CardanoAddressType2["BASE_KEY_SCRIPT"] = 2] = "BASE_KEY_SCRIPT";
    CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_SCRIPT"] = 3] = "BASE_SCRIPT_SCRIPT";
    CardanoAddressType2[CardanoAddressType2["POINTER"] = 4] = "POINTER";
    CardanoAddressType2[CardanoAddressType2["POINTER_SCRIPT"] = 5] = "POINTER_SCRIPT";
    CardanoAddressType2[CardanoAddressType2["ENTERPRISE"] = 6] = "ENTERPRISE";
    CardanoAddressType2[CardanoAddressType2["ENTERPRISE_SCRIPT"] = 7] = "ENTERPRISE_SCRIPT";
    CardanoAddressType2[CardanoAddressType2["BYRON"] = 8] = "BYRON";
    CardanoAddressType2[CardanoAddressType2["REWARD"] = 14] = "REWARD";
    CardanoAddressType2[CardanoAddressType2["REWARD_SCRIPT"] = 15] = "REWARD_SCRIPT";
  })(CardanoAddressType || (messages.CardanoAddressType = CardanoAddressType = {}));
  var CardanoNativeScriptType;
  (function(CardanoNativeScriptType2) {
    CardanoNativeScriptType2[CardanoNativeScriptType2["PUB_KEY"] = 0] = "PUB_KEY";
    CardanoNativeScriptType2[CardanoNativeScriptType2["ALL"] = 1] = "ALL";
    CardanoNativeScriptType2[CardanoNativeScriptType2["ANY"] = 2] = "ANY";
    CardanoNativeScriptType2[CardanoNativeScriptType2["N_OF_K"] = 3] = "N_OF_K";
    CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_BEFORE"] = 4] = "INVALID_BEFORE";
    CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_HEREAFTER"] = 5] = "INVALID_HEREAFTER";
  })(CardanoNativeScriptType || (messages.CardanoNativeScriptType = CardanoNativeScriptType = {}));
  var CardanoNativeScriptHashDisplayFormat;
  (function(CardanoNativeScriptHashDisplayFormat2) {
    CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["HIDE"] = 0] = "HIDE";
    CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["BECH32"] = 1] = "BECH32";
    CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["POLICY_ID"] = 2] = "POLICY_ID";
  })(CardanoNativeScriptHashDisplayFormat || (messages.CardanoNativeScriptHashDisplayFormat = CardanoNativeScriptHashDisplayFormat = {}));
  var CardanoTxOutputSerializationFormat;
  (function(CardanoTxOutputSerializationFormat2) {
    CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["ARRAY_LEGACY"] = 0] = "ARRAY_LEGACY";
    CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["MAP_BABBAGE"] = 1] = "MAP_BABBAGE";
  })(CardanoTxOutputSerializationFormat || (messages.CardanoTxOutputSerializationFormat = CardanoTxOutputSerializationFormat = {}));
  var CardanoCertificateType;
  (function(CardanoCertificateType2) {
    CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION"] = 0] = "STAKE_REGISTRATION";
    CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION"] = 1] = "STAKE_DEREGISTRATION";
    CardanoCertificateType2[CardanoCertificateType2["STAKE_DELEGATION"] = 2] = "STAKE_DELEGATION";
    CardanoCertificateType2[CardanoCertificateType2["STAKE_POOL_REGISTRATION"] = 3] = "STAKE_POOL_REGISTRATION";
    CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION_CONWAY"] = 7] = "STAKE_REGISTRATION_CONWAY";
    CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION_CONWAY"] = 8] = "STAKE_DEREGISTRATION_CONWAY";
    CardanoCertificateType2[CardanoCertificateType2["VOTE_DELEGATION"] = 9] = "VOTE_DELEGATION";
  })(CardanoCertificateType || (messages.CardanoCertificateType = CardanoCertificateType = {}));
  var CardanoDRepType;
  (function(CardanoDRepType2) {
    CardanoDRepType2[CardanoDRepType2["KEY_HASH"] = 0] = "KEY_HASH";
    CardanoDRepType2[CardanoDRepType2["SCRIPT_HASH"] = 1] = "SCRIPT_HASH";
    CardanoDRepType2[CardanoDRepType2["ABSTAIN"] = 2] = "ABSTAIN";
    CardanoDRepType2[CardanoDRepType2["NO_CONFIDENCE"] = 3] = "NO_CONFIDENCE";
  })(CardanoDRepType || (messages.CardanoDRepType = CardanoDRepType = {}));
  var CardanoPoolRelayType;
  (function(CardanoPoolRelayType2) {
    CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_IP"] = 0] = "SINGLE_HOST_IP";
    CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_NAME"] = 1] = "SINGLE_HOST_NAME";
    CardanoPoolRelayType2[CardanoPoolRelayType2["MULTIPLE_HOST_NAME"] = 2] = "MULTIPLE_HOST_NAME";
  })(CardanoPoolRelayType || (messages.CardanoPoolRelayType = CardanoPoolRelayType = {}));
  var CardanoTxAuxiliaryDataSupplementType;
  (function(CardanoTxAuxiliaryDataSupplementType2) {
    CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["NONE"] = 0] = "NONE";
    CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["CVOTE_REGISTRATION_SIGNATURE"] = 1] = "CVOTE_REGISTRATION_SIGNATURE";
  })(CardanoTxAuxiliaryDataSupplementType || (messages.CardanoTxAuxiliaryDataSupplementType = CardanoTxAuxiliaryDataSupplementType = {}));
  var CardanoCVoteRegistrationFormat;
  (function(CardanoCVoteRegistrationFormat2) {
    CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP15"] = 0] = "CIP15";
    CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP36"] = 1] = "CIP36";
  })(CardanoCVoteRegistrationFormat || (messages.CardanoCVoteRegistrationFormat = CardanoCVoteRegistrationFormat = {}));
  var CardanoTxSigningMode;
  (function(CardanoTxSigningMode2) {
    CardanoTxSigningMode2[CardanoTxSigningMode2["ORDINARY_TRANSACTION"] = 0] = "ORDINARY_TRANSACTION";
    CardanoTxSigningMode2[CardanoTxSigningMode2["POOL_REGISTRATION_AS_OWNER"] = 1] = "POOL_REGISTRATION_AS_OWNER";
    CardanoTxSigningMode2[CardanoTxSigningMode2["MULTISIG_TRANSACTION"] = 2] = "MULTISIG_TRANSACTION";
    CardanoTxSigningMode2[CardanoTxSigningMode2["PLUTUS_TRANSACTION"] = 3] = "PLUTUS_TRANSACTION";
  })(CardanoTxSigningMode || (messages.CardanoTxSigningMode = CardanoTxSigningMode = {}));
  var CardanoTxWitnessType;
  (function(CardanoTxWitnessType2) {
    CardanoTxWitnessType2[CardanoTxWitnessType2["BYRON_WITNESS"] = 0] = "BYRON_WITNESS";
    CardanoTxWitnessType2[CardanoTxWitnessType2["SHELLEY_WITNESS"] = 1] = "SHELLEY_WITNESS";
  })(CardanoTxWitnessType || (messages.CardanoTxWitnessType = CardanoTxWitnessType = {}));
  var FailureType;
  (function(FailureType2) {
    FailureType2[FailureType2["Failure_UnexpectedMessage"] = 1] = "Failure_UnexpectedMessage";
    FailureType2[FailureType2["Failure_ButtonExpected"] = 2] = "Failure_ButtonExpected";
    FailureType2[FailureType2["Failure_DataError"] = 3] = "Failure_DataError";
    FailureType2[FailureType2["Failure_ActionCancelled"] = 4] = "Failure_ActionCancelled";
    FailureType2[FailureType2["Failure_PinExpected"] = 5] = "Failure_PinExpected";
    FailureType2[FailureType2["Failure_PinCancelled"] = 6] = "Failure_PinCancelled";
    FailureType2[FailureType2["Failure_PinInvalid"] = 7] = "Failure_PinInvalid";
    FailureType2[FailureType2["Failure_InvalidSignature"] = 8] = "Failure_InvalidSignature";
    FailureType2[FailureType2["Failure_ProcessError"] = 9] = "Failure_ProcessError";
    FailureType2[FailureType2["Failure_NotEnoughFunds"] = 10] = "Failure_NotEnoughFunds";
    FailureType2[FailureType2["Failure_NotInitialized"] = 11] = "Failure_NotInitialized";
    FailureType2[FailureType2["Failure_PinMismatch"] = 12] = "Failure_PinMismatch";
    FailureType2[FailureType2["Failure_WipeCodeMismatch"] = 13] = "Failure_WipeCodeMismatch";
    FailureType2[FailureType2["Failure_InvalidSession"] = 14] = "Failure_InvalidSession";
    FailureType2[FailureType2["Failure_FirmwareError"] = 99] = "Failure_FirmwareError";
  })(FailureType || (messages.FailureType = FailureType = {}));
  var Enum_ButtonRequestType;
  (function(Enum_ButtonRequestType2) {
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Other"] = 1] = "ButtonRequest_Other";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FeeOverThreshold"] = 2] = "ButtonRequest_FeeOverThreshold";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmOutput"] = 3] = "ButtonRequest_ConfirmOutput";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ResetDevice"] = 4] = "ButtonRequest_ResetDevice";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmWord"] = 5] = "ButtonRequest_ConfirmWord";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_WipeDevice"] = 6] = "ButtonRequest_WipeDevice";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ProtectCall"] = 7] = "ButtonRequest_ProtectCall";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_SignTx"] = 8] = "ButtonRequest_SignTx";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FirmwareCheck"] = 9] = "ButtonRequest_FirmwareCheck";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Address"] = 10] = "ButtonRequest_Address";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PublicKey"] = 11] = "ButtonRequest_PublicKey";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicWordCount"] = 12] = "ButtonRequest_MnemonicWordCount";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicInput"] = 13] = "ButtonRequest_MnemonicInput";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["_Deprecated_ButtonRequest_PassphraseType"] = 14] = "_Deprecated_ButtonRequest_PassphraseType";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_UnknownDerivationPath"] = 15] = "ButtonRequest_UnknownDerivationPath";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_RecoveryHomepage"] = 16] = "ButtonRequest_RecoveryHomepage";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Success"] = 17] = "ButtonRequest_Success";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Warning"] = 18] = "ButtonRequest_Warning";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PassphraseEntry"] = 19] = "ButtonRequest_PassphraseEntry";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PinEntry"] = 20] = "ButtonRequest_PinEntry";
  })(Enum_ButtonRequestType || (messages.Enum_ButtonRequestType = Enum_ButtonRequestType = {}));
  var Enum_PinMatrixRequestType;
  (function(Enum_PinMatrixRequestType2) {
    Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_Current"] = 1] = "PinMatrixRequestType_Current";
    Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewFirst"] = 2] = "PinMatrixRequestType_NewFirst";
    Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewSecond"] = 3] = "PinMatrixRequestType_NewSecond";
    Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeFirst"] = 4] = "PinMatrixRequestType_WipeCodeFirst";
    Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeSecond"] = 5] = "PinMatrixRequestType_WipeCodeSecond";
  })(Enum_PinMatrixRequestType || (messages.Enum_PinMatrixRequestType = Enum_PinMatrixRequestType = {}));
  var DebugButton;
  (function(DebugButton2) {
    DebugButton2[DebugButton2["NO"] = 0] = "NO";
    DebugButton2[DebugButton2["YES"] = 1] = "YES";
    DebugButton2[DebugButton2["INFO"] = 2] = "INFO";
  })(DebugButton || (messages.DebugButton = DebugButton = {}));
  var DebugPhysicalButton;
  (function(DebugPhysicalButton2) {
    DebugPhysicalButton2[DebugPhysicalButton2["LEFT_BTN"] = 0] = "LEFT_BTN";
    DebugPhysicalButton2[DebugPhysicalButton2["MIDDLE_BTN"] = 1] = "MIDDLE_BTN";
    DebugPhysicalButton2[DebugPhysicalButton2["RIGHT_BTN"] = 2] = "RIGHT_BTN";
  })(DebugPhysicalButton || (messages.DebugPhysicalButton = DebugPhysicalButton = {}));
  var EthereumDefinitionType;
  (function(EthereumDefinitionType2) {
    EthereumDefinitionType2[EthereumDefinitionType2["NETWORK"] = 0] = "NETWORK";
    EthereumDefinitionType2[EthereumDefinitionType2["TOKEN"] = 1] = "TOKEN";
  })(EthereumDefinitionType || (messages.EthereumDefinitionType = EthereumDefinitionType = {}));
  var EthereumDataType;
  (function(EthereumDataType2) {
    EthereumDataType2[EthereumDataType2["UINT"] = 1] = "UINT";
    EthereumDataType2[EthereumDataType2["INT"] = 2] = "INT";
    EthereumDataType2[EthereumDataType2["BYTES"] = 3] = "BYTES";
    EthereumDataType2[EthereumDataType2["STRING"] = 4] = "STRING";
    EthereumDataType2[EthereumDataType2["BOOL"] = 5] = "BOOL";
    EthereumDataType2[EthereumDataType2["ADDRESS"] = 6] = "ADDRESS";
    EthereumDataType2[EthereumDataType2["ARRAY"] = 7] = "ARRAY";
    EthereumDataType2[EthereumDataType2["STRUCT"] = 8] = "STRUCT";
  })(EthereumDataType || (messages.EthereumDataType = EthereumDataType = {}));
  var Enum_BackupType;
  (function(Enum_BackupType2) {
    Enum_BackupType2[Enum_BackupType2["Bip39"] = 0] = "Bip39";
    Enum_BackupType2[Enum_BackupType2["Slip39_Basic"] = 1] = "Slip39_Basic";
    Enum_BackupType2[Enum_BackupType2["Slip39_Advanced"] = 2] = "Slip39_Advanced";
    Enum_BackupType2[Enum_BackupType2["Slip39_Single_Extendable"] = 3] = "Slip39_Single_Extendable";
    Enum_BackupType2[Enum_BackupType2["Slip39_Basic_Extendable"] = 4] = "Slip39_Basic_Extendable";
    Enum_BackupType2[Enum_BackupType2["Slip39_Advanced_Extendable"] = 5] = "Slip39_Advanced_Extendable";
  })(Enum_BackupType || (messages.Enum_BackupType = Enum_BackupType = {}));
  var Enum_SafetyCheckLevel;
  (function(Enum_SafetyCheckLevel2) {
    Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["Strict"] = 0] = "Strict";
    Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptAlways"] = 1] = "PromptAlways";
    Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptTemporarily"] = 2] = "PromptTemporarily";
  })(Enum_SafetyCheckLevel || (messages.Enum_SafetyCheckLevel = Enum_SafetyCheckLevel = {}));
  var Enum_HomescreenFormat;
  (function(Enum_HomescreenFormat2) {
    Enum_HomescreenFormat2[Enum_HomescreenFormat2["Toif"] = 1] = "Toif";
    Enum_HomescreenFormat2[Enum_HomescreenFormat2["Jpeg"] = 2] = "Jpeg";
    Enum_HomescreenFormat2[Enum_HomescreenFormat2["ToiG"] = 3] = "ToiG";
  })(Enum_HomescreenFormat || (messages.Enum_HomescreenFormat = Enum_HomescreenFormat = {}));
  var Enum_BackupAvailability;
  (function(Enum_BackupAvailability2) {
    Enum_BackupAvailability2[Enum_BackupAvailability2["NotAvailable"] = 0] = "NotAvailable";
    Enum_BackupAvailability2[Enum_BackupAvailability2["Required"] = 1] = "Required";
    Enum_BackupAvailability2[Enum_BackupAvailability2["Available"] = 2] = "Available";
  })(Enum_BackupAvailability || (messages.Enum_BackupAvailability = Enum_BackupAvailability = {}));
  var Enum_RecoveryStatus;
  (function(Enum_RecoveryStatus2) {
    Enum_RecoveryStatus2[Enum_RecoveryStatus2["Nothing"] = 0] = "Nothing";
    Enum_RecoveryStatus2[Enum_RecoveryStatus2["Recovery"] = 1] = "Recovery";
    Enum_RecoveryStatus2[Enum_RecoveryStatus2["Backup"] = 2] = "Backup";
  })(Enum_RecoveryStatus || (messages.Enum_RecoveryStatus = Enum_RecoveryStatus = {}));
  var Enum_Capability;
  (function(Enum_Capability2) {
    Enum_Capability2[Enum_Capability2["Capability_Bitcoin"] = 1] = "Capability_Bitcoin";
    Enum_Capability2[Enum_Capability2["Capability_Bitcoin_like"] = 2] = "Capability_Bitcoin_like";
    Enum_Capability2[Enum_Capability2["Capability_Binance"] = 3] = "Capability_Binance";
    Enum_Capability2[Enum_Capability2["Capability_Cardano"] = 4] = "Capability_Cardano";
    Enum_Capability2[Enum_Capability2["Capability_Crypto"] = 5] = "Capability_Crypto";
    Enum_Capability2[Enum_Capability2["Capability_EOS"] = 6] = "Capability_EOS";
    Enum_Capability2[Enum_Capability2["Capability_Ethereum"] = 7] = "Capability_Ethereum";
    Enum_Capability2[Enum_Capability2["Capability_Lisk"] = 8] = "Capability_Lisk";
    Enum_Capability2[Enum_Capability2["Capability_Monero"] = 9] = "Capability_Monero";
    Enum_Capability2[Enum_Capability2["Capability_NEM"] = 10] = "Capability_NEM";
    Enum_Capability2[Enum_Capability2["Capability_Ripple"] = 11] = "Capability_Ripple";
    Enum_Capability2[Enum_Capability2["Capability_Stellar"] = 12] = "Capability_Stellar";
    Enum_Capability2[Enum_Capability2["Capability_Tezos"] = 13] = "Capability_Tezos";
    Enum_Capability2[Enum_Capability2["Capability_U2F"] = 14] = "Capability_U2F";
    Enum_Capability2[Enum_Capability2["Capability_Shamir"] = 15] = "Capability_Shamir";
    Enum_Capability2[Enum_Capability2["Capability_ShamirGroups"] = 16] = "Capability_ShamirGroups";
    Enum_Capability2[Enum_Capability2["Capability_PassphraseEntry"] = 17] = "Capability_PassphraseEntry";
    Enum_Capability2[Enum_Capability2["Capability_Solana"] = 18] = "Capability_Solana";
    Enum_Capability2[Enum_Capability2["Capability_Translations"] = 19] = "Capability_Translations";
    Enum_Capability2[Enum_Capability2["Capability_Brightness"] = 20] = "Capability_Brightness";
    Enum_Capability2[Enum_Capability2["Capability_Haptic"] = 21] = "Capability_Haptic";
  })(Enum_Capability || (messages.Enum_Capability = Enum_Capability = {}));
  var RecoveryDeviceInputMethod;
  (function(RecoveryDeviceInputMethod2) {
    RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["ScrambledWords"] = 0] = "ScrambledWords";
    RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["Matrix"] = 1] = "Matrix";
  })(RecoveryDeviceInputMethod || (messages.RecoveryDeviceInputMethod = RecoveryDeviceInputMethod = {}));
  var Enum_RecoveryType;
  (function(Enum_RecoveryType2) {
    Enum_RecoveryType2[Enum_RecoveryType2["NormalRecovery"] = 0] = "NormalRecovery";
    Enum_RecoveryType2[Enum_RecoveryType2["DryRun"] = 1] = "DryRun";
    Enum_RecoveryType2[Enum_RecoveryType2["UnlockRepeatedBackup"] = 2] = "UnlockRepeatedBackup";
  })(Enum_RecoveryType || (messages.Enum_RecoveryType = Enum_RecoveryType = {}));
  var SdProtectOperationType;
  (function(SdProtectOperationType2) {
    SdProtectOperationType2[SdProtectOperationType2["DISABLE"] = 0] = "DISABLE";
    SdProtectOperationType2[SdProtectOperationType2["ENABLE"] = 1] = "ENABLE";
    SdProtectOperationType2[SdProtectOperationType2["REFRESH"] = 2] = "REFRESH";
  })(SdProtectOperationType || (messages.SdProtectOperationType = SdProtectOperationType = {}));
  var Enum_WordRequestType;
  (function(Enum_WordRequestType2) {
    Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Plain"] = 0] = "WordRequestType_Plain";
    Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix9"] = 1] = "WordRequestType_Matrix9";
    Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix6"] = 2] = "WordRequestType_Matrix6";
  })(Enum_WordRequestType || (messages.Enum_WordRequestType = Enum_WordRequestType = {}));
  var BootCommand;
  (function(BootCommand2) {
    BootCommand2[BootCommand2["STOP_AND_WAIT"] = 0] = "STOP_AND_WAIT";
    BootCommand2[BootCommand2["INSTALL_UPGRADE"] = 1] = "INSTALL_UPGRADE";
  })(BootCommand || (messages.BootCommand = BootCommand = {}));
  var MoneroNetworkType;
  (function(MoneroNetworkType2) {
    MoneroNetworkType2[MoneroNetworkType2["MAINNET"] = 0] = "MAINNET";
    MoneroNetworkType2[MoneroNetworkType2["TESTNET"] = 1] = "TESTNET";
    MoneroNetworkType2[MoneroNetworkType2["STAGENET"] = 2] = "STAGENET";
    MoneroNetworkType2[MoneroNetworkType2["FAKECHAIN"] = 3] = "FAKECHAIN";
  })(MoneroNetworkType || (messages.MoneroNetworkType = MoneroNetworkType = {}));
  var NEMMosaicLevy;
  (function(NEMMosaicLevy2) {
    NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Absolute"] = 1] = "MosaicLevy_Absolute";
    NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Percentile"] = 2] = "MosaicLevy_Percentile";
  })(NEMMosaicLevy || (messages.NEMMosaicLevy = NEMMosaicLevy = {}));
  var NEMSupplyChangeType;
  (function(NEMSupplyChangeType2) {
    NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Increase"] = 1] = "SupplyChange_Increase";
    NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Decrease"] = 2] = "SupplyChange_Decrease";
  })(NEMSupplyChangeType || (messages.NEMSupplyChangeType = NEMSupplyChangeType = {}));
  var NEMModificationType;
  (function(NEMModificationType2) {
    NEMModificationType2[NEMModificationType2["CosignatoryModification_Add"] = 1] = "CosignatoryModification_Add";
    NEMModificationType2[NEMModificationType2["CosignatoryModification_Delete"] = 2] = "CosignatoryModification_Delete";
  })(NEMModificationType || (messages.NEMModificationType = NEMModificationType = {}));
  var NEMImportanceTransferMode;
  (function(NEMImportanceTransferMode2) {
    NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Activate"] = 1] = "ImportanceTransfer_Activate";
    NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Deactivate"] = 2] = "ImportanceTransfer_Deactivate";
  })(NEMImportanceTransferMode || (messages.NEMImportanceTransferMode = NEMImportanceTransferMode = {}));
  var StellarAssetType;
  (function(StellarAssetType2) {
    StellarAssetType2[StellarAssetType2["NATIVE"] = 0] = "NATIVE";
    StellarAssetType2[StellarAssetType2["ALPHANUM4"] = 1] = "ALPHANUM4";
    StellarAssetType2[StellarAssetType2["ALPHANUM12"] = 2] = "ALPHANUM12";
  })(StellarAssetType || (messages.StellarAssetType = StellarAssetType = {}));
  var StellarMemoType;
  (function(StellarMemoType2) {
    StellarMemoType2[StellarMemoType2["NONE"] = 0] = "NONE";
    StellarMemoType2[StellarMemoType2["TEXT"] = 1] = "TEXT";
    StellarMemoType2[StellarMemoType2["ID"] = 2] = "ID";
    StellarMemoType2[StellarMemoType2["HASH"] = 3] = "HASH";
    StellarMemoType2[StellarMemoType2["RETURN"] = 4] = "RETURN";
  })(StellarMemoType || (messages.StellarMemoType = StellarMemoType = {}));
  var StellarSignerType;
  (function(StellarSignerType2) {
    StellarSignerType2[StellarSignerType2["ACCOUNT"] = 0] = "ACCOUNT";
    StellarSignerType2[StellarSignerType2["PRE_AUTH"] = 1] = "PRE_AUTH";
    StellarSignerType2[StellarSignerType2["HASH"] = 2] = "HASH";
  })(StellarSignerType || (messages.StellarSignerType = StellarSignerType = {}));
  var TezosContractType;
  (function(TezosContractType2) {
    TezosContractType2[TezosContractType2["Implicit"] = 0] = "Implicit";
    TezosContractType2[TezosContractType2["Originated"] = 1] = "Originated";
  })(TezosContractType || (messages.TezosContractType = TezosContractType = {}));
  var TezosBallotType;
  (function(TezosBallotType2) {
    TezosBallotType2[TezosBallotType2["Yay"] = 0] = "Yay";
    TezosBallotType2[TezosBallotType2["Nay"] = 1] = "Nay";
    TezosBallotType2[TezosBallotType2["Pass"] = 2] = "Pass";
  })(TezosBallotType || (messages.TezosBallotType = TezosBallotType = {}));
  return messages;
}
var types$1 = {};
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1;
  hasRequiredTypes$1 = 1;
  Object.defineProperty(types$1, "__esModule", { value: true });
  return types$1;
}
var messagesSchema = {};
var hasRequiredMessagesSchema;
function requireMessagesSchema() {
  if (hasRequiredMessagesSchema) return messagesSchema;
  hasRequiredMessagesSchema = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TxRequest = exports2.TxRequestSerializedType = exports2.TxRequestDetailsType = exports2.RequestType = exports2.EnumEnum_RequestType = exports2.Enum_RequestType = exports2.SignTx = exports2.CoinJoinRequest = exports2.VerifyMessage = exports2.MessageSignature = exports2.SignMessage = exports2.OwnershipId = exports2.GetOwnershipId = exports2.Address = exports2.GetAddress = exports2.PublicKey = exports2.GetPublicKey = exports2.MultisigRedeemScriptType = exports2.HDNodePathType = exports2.HDNodeType = exports2.EnumAmountUnit = exports2.AmountUnit = exports2.EnumDecredStakingSpendType = exports2.DecredStakingSpendType = exports2.OutputScriptType = exports2.EnumEnum_OutputScriptType = exports2.Enum_OutputScriptType = exports2.InputScriptType = exports2.EnumEnum_InputScriptType = exports2.Enum_InputScriptType = exports2.BinanceSignedTx = exports2.BinanceCancelMsg = exports2.BinanceOrderMsg = exports2.EnumBinanceTimeInForce = exports2.BinanceTimeInForce = exports2.EnumBinanceOrderSide = exports2.BinanceOrderSide = exports2.EnumBinanceOrderType = exports2.BinanceOrderType = exports2.BinanceTransferMsg = exports2.BinanceInputOutput = exports2.BinanceCoin = exports2.BinanceTxRequest = exports2.BinanceSignTx = exports2.BinancePublicKey = exports2.BinanceGetPublicKey = exports2.BinanceAddress = exports2.BinanceGetAddress = exports2.EnumDeviceModelInternal = exports2.DeviceModelInternal = void 0;
    exports2.CardanoPoolRelayType = exports2.EnumCardanoDRepType = exports2.CardanoDRepType = exports2.EnumCardanoCertificateType = exports2.CardanoCertificateType = exports2.EnumCardanoTxOutputSerializationFormat = exports2.CardanoTxOutputSerializationFormat = exports2.EnumCardanoNativeScriptHashDisplayFormat = exports2.CardanoNativeScriptHashDisplayFormat = exports2.EnumCardanoNativeScriptType = exports2.CardanoNativeScriptType = exports2.EnumCardanoAddressType = exports2.CardanoAddressType = exports2.EnumCardanoDerivationType = exports2.CardanoDerivationType = exports2.ProdTestT1 = exports2.FirmwareUpload = exports2.FirmwareRequest = exports2.FirmwareErase = exports2.AuthorizeCoinJoin = exports2.OwnershipProof = exports2.GetOwnershipProof = exports2.TxAckPrevExtraData = exports2.TxAckPrevExtraDataWrapper = exports2.TxAckPrevOutput = exports2.TxAckPrevOutputWrapper = exports2.TxAckPrevInput = exports2.TxAckPrevInputWrapper = exports2.TxAckPrevMeta = exports2.TxAckOutput = exports2.TxAckOutputWrapper = exports2.TxAckInput = exports2.TxAckInputWrapper = exports2.TxAck = exports2.TxAckResponse = exports2.TxAckPaymentRequest = exports2.PaymentRequestMemo = exports2.CoinPurchaseMemo = exports2.RefundMemo = exports2.TextMemo = exports2.PrevOutput = exports2.PrevInput = exports2.PrevTx = exports2.TxOutput = exports2.TxOutputType = exports2.ChangeOutputScriptType = exports2.TxOutputBinType = exports2.TxInput = exports2.TxInputType = exports2.InternalInputScriptType = void 0;
    exports2.Failure = exports2.EnumFailureType = exports2.FailureType = exports2.Success = exports2.CardanoSignTxFinished = exports2.CardanoTxBodyHash = exports2.CardanoTxHostAck = exports2.CardanoTxWitnessResponse = exports2.CardanoTxWitnessRequest = exports2.CardanoTxAuxiliaryDataSupplement = exports2.CardanoTxItemAck = exports2.CardanoTxReferenceInput = exports2.CardanoTxRequiredSigner = exports2.CardanoTxCollateralInput = exports2.CardanoTxMint = exports2.CardanoTxAuxiliaryData = exports2.CardanoCVoteRegistrationParametersType = exports2.CardanoCVoteRegistrationDelegation = exports2.CardanoTxWithdrawal = exports2.CardanoTxCertificate = exports2.CardanoDRep = exports2.CardanoPoolParametersType = exports2.CardanoPoolMetadataType = exports2.CardanoPoolRelayParameters = exports2.CardanoPoolOwner = exports2.CardanoTxReferenceScriptChunk = exports2.CardanoTxInlineDatumChunk = exports2.CardanoToken = exports2.CardanoAssetGroup = exports2.CardanoTxOutput = exports2.CardanoTxInput = exports2.CardanoSignTxInit = exports2.CardanoPublicKey = exports2.CardanoGetPublicKey = exports2.CardanoAddress = exports2.CardanoGetAddress = exports2.CardanoAddressParametersType = exports2.CardanoNativeScriptHash = exports2.CardanoGetNativeScriptHash = exports2.CardanoNativeScript = exports2.CardanoBlockchainPointerType = exports2.EnumCardanoTxWitnessType = exports2.CardanoTxWitnessType = exports2.EnumCardanoTxSigningMode = exports2.CardanoTxSigningMode = exports2.EnumCardanoCVoteRegistrationFormat = exports2.CardanoCVoteRegistrationFormat = exports2.EnumCardanoTxAuxiliaryDataSupplementType = exports2.CardanoTxAuxiliaryDataSupplementType = exports2.EnumCardanoPoolRelayType = void 0;
    exports2.EosActionUnlinkAuth = exports2.EosActionLinkAuth = exports2.EosActionDeleteAuth = exports2.EosActionUpdateAuth = exports2.EosActionVoteProducer = exports2.EosActionSellRam = exports2.EosActionBuyRamBytes = exports2.EosActionBuyRam = exports2.EosActionRefund = exports2.EosActionUndelegate = exports2.EosActionDelegate = exports2.EosActionTransfer = exports2.EosActionCommon = exports2.EosAuthorization = exports2.EosAuthorizationWait = exports2.EosAuthorizationAccount = exports2.EosAuthorizationKey = exports2.EosPermissionLevel = exports2.EosAsset = exports2.EosTxActionRequest = exports2.EosSignTx = exports2.EosTxHeader = exports2.EosPublicKey = exports2.EosGetPublicKey = exports2.DebugLinkResetDebugEvents = exports2.EnumDebugPhysicalButton = exports2.DebugPhysicalButton = exports2.EnumDebugButton = exports2.DebugButton = exports2.ECDHSessionKey = exports2.GetECDHSessionKey = exports2.SignedIdentity = exports2.SignIdentity = exports2.IdentityType = exports2.CipheredKeyValue = exports2.CipherKeyValue = exports2.Deprecated_PassphraseStateAck = exports2.Deprecated_PassphraseStateRequest = exports2.PassphraseAck = exports2.PassphraseRequest = exports2.PinMatrixAck = exports2.PinMatrixRequest = exports2.PinMatrixRequestType = exports2.EnumEnum_PinMatrixRequestType = exports2.Enum_PinMatrixRequestType = exports2.ButtonAck = exports2.ButtonRequest = exports2.ButtonRequestType = exports2.EnumEnum_ButtonRequestType = exports2.Enum_ButtonRequestType = void 0;
    exports2.Enum_Capability = exports2.RecoveryStatus = exports2.EnumEnum_RecoveryStatus = exports2.Enum_RecoveryStatus = exports2.BackupAvailability = exports2.EnumEnum_BackupAvailability = exports2.Enum_BackupAvailability = exports2.GetFeatures = exports2.Initialize = exports2.HomescreenFormat = exports2.EnumEnum_HomescreenFormat = exports2.Enum_HomescreenFormat = exports2.SafetyCheckLevel = exports2.EnumEnum_SafetyCheckLevel = exports2.Enum_SafetyCheckLevel = exports2.BackupType = exports2.EnumEnum_BackupType = exports2.Enum_BackupType = exports2.EthereumTypedDataSignature = exports2.EthereumSignTypedHash = exports2.EthereumVerifyMessage = exports2.EthereumMessageSignature = exports2.EthereumSignMessage = exports2.EthereumTxAck = exports2.EthereumTxRequest = exports2.EthereumSignTxEIP1559 = exports2.EthereumAccessList = exports2.EthereumSignTx = exports2.EthereumAddress = exports2.EthereumGetAddress = exports2.EthereumPublicKey = exports2.EthereumGetPublicKey = exports2.EthereumTypedDataValueAck = exports2.EthereumTypedDataValueRequest = exports2.EthereumTypedDataStructAck = exports2.EthereumStructMember = exports2.EthereumFieldType = exports2.EnumEthereumDataType = exports2.EthereumDataType = exports2.EthereumTypedDataStructRequest = exports2.EthereumSignTypedData = exports2.EthereumDefinitions = exports2.EthereumTokenInfo = exports2.EthereumNetworkInfo = exports2.EnumEthereumDefinitionType = exports2.EthereumDefinitionType = exports2.EosSignedTx = exports2.EosTxActionAck = exports2.EosActionUnknown = exports2.EosActionNewAccount = void 0;
    exports2.RebootToBootloader = exports2.EnumBootCommand = exports2.BootCommand = exports2.CancelAuthorization = exports2.PreauthorizedRequest = exports2.DoPreauthorized = exports2.NextU2FCounter = exports2.GetNextU2FCounter = exports2.SetU2FCounter = exports2.WordAck = exports2.WordRequest = exports2.WordRequestType = exports2.EnumEnum_WordRequestType = exports2.Enum_WordRequestType = exports2.EntropyAck = exports2.EntropyRequest = exports2.BackupDevice = exports2.Slip39Group = exports2.ResetDevice = exports2.WipeDevice = exports2.AuthenticityProof = exports2.AuthenticateDevice = exports2.FirmwareHash = exports2.GetFirmwareHash = exports2.Entropy = exports2.GetEntropy = exports2.Cancel = exports2.Ping = exports2.SdProtect = exports2.EnumSdProtectOperationType = exports2.SdProtectOperationType = exports2.ChangeWipeCode = exports2.ChangePin = exports2.ApplyFlags = exports2.TranslationDataAck = exports2.TranslationDataRequest = exports2.ChangeLanguage = exports2.ApplySettings = exports2.EndSession = exports2.SetBusy = exports2.LockDevice = exports2.Features = exports2.RecoveryDevice = exports2.RecoveryType = exports2.EnumEnum_RecoveryType = exports2.Enum_RecoveryType = exports2.EnumRecoveryDeviceInputMethod = exports2.RecoveryDeviceInputMethod = exports2.Capability = exports2.EnumEnum_Capability = void 0;
    exports2.StellarGetAddress = exports2.StellarAsset = exports2.EnumStellarAssetType = exports2.StellarAssetType = exports2.SolanaTxSignature = exports2.SolanaSignTx = exports2.SolanaTxAdditionalInfo = exports2.SolanaTxTokenAccountInfo = exports2.SolanaAddress = exports2.SolanaGetAddress = exports2.SolanaPublicKey = exports2.SolanaGetPublicKey = exports2.RippleSignedTx = exports2.RippleSignTx = exports2.RipplePayment = exports2.RippleAddress = exports2.RippleGetAddress = exports2.NEMDecryptedMessage = exports2.NEMDecryptMessage = exports2.NEMSignedTx = exports2.NEMSignTx = exports2.NEMImportanceTransfer = exports2.EnumNEMImportanceTransferMode = exports2.NEMImportanceTransferMode = exports2.NEMAggregateModification = exports2.NEMCosignatoryModification = exports2.EnumNEMModificationType = exports2.NEMModificationType = exports2.NEMMosaicSupplyChange = exports2.EnumNEMSupplyChangeType = exports2.NEMSupplyChangeType = exports2.NEMMosaicCreation = exports2.NEMMosaicDefinition = exports2.EnumNEMMosaicLevy = exports2.NEMMosaicLevy = exports2.NEMProvisionNamespace = exports2.NEMTransfer = exports2.NEMMosaic = exports2.NEMTransactionCommon = exports2.NEMAddress = exports2.NEMGetAddress = exports2.EnumMoneroNetworkType = exports2.MoneroNetworkType = exports2.SetBrightness = exports2.UnlockBootloader = exports2.ShowDeviceTutorial = exports2.UnlockedPathRequest = exports2.UnlockPath = exports2.Nonce = exports2.GetNonce = void 0;
    exports2.MessageType = exports2.experimental_field = exports2.experimental_message = exports2.TezosSignedTx = exports2.TezosSignTx = exports2.TezosBallotOp = exports2.EnumTezosBallotType = exports2.TezosBallotType = exports2.TezosProposalOp = exports2.TezosDelegationOp = exports2.TezosOriginationOp = exports2.TezosTransactionOp = exports2.TezosParametersManager = exports2.TezosManagerTransfer = exports2.TezosRevealOp = exports2.TezosContractID = exports2.EnumTezosContractType = exports2.TezosContractType = exports2.TezosPublicKey = exports2.TezosGetPublicKey = exports2.TezosAddress = exports2.TezosGetAddress = exports2.StellarSignedTx = exports2.StellarClaimClaimableBalanceOp = exports2.StellarBumpSequenceOp = exports2.StellarManageDataOp = exports2.StellarAccountMergeOp = exports2.StellarAllowTrustOp = exports2.StellarChangeTrustOp = exports2.StellarSetOptionsOp = exports2.EnumStellarSignerType = exports2.StellarSignerType = exports2.StellarCreatePassiveSellOfferOp = exports2.StellarManageBuyOfferOp = exports2.StellarManageSellOfferOp = exports2.StellarPathPaymentStrictSendOp = exports2.StellarPathPaymentStrictReceiveOp = exports2.StellarCreateAccountOp = exports2.StellarPaymentOp = exports2.StellarTxOpRequest = exports2.StellarSignTx = exports2.EnumStellarMemoType = exports2.StellarMemoType = exports2.StellarAddress = void 0;
    const schema_utils_1 = requireLib$1();
    var DeviceModelInternal;
    (function(DeviceModelInternal2) {
      DeviceModelInternal2["T1B1"] = "T1B1";
      DeviceModelInternal2["T2T1"] = "T2T1";
      DeviceModelInternal2["T2B1"] = "T2B1";
      DeviceModelInternal2["T3T1"] = "T3T1";
    })(DeviceModelInternal || (exports2.DeviceModelInternal = DeviceModelInternal = {}));
    exports2.EnumDeviceModelInternal = schema_utils_1.Type.Enum(DeviceModelInternal);
    exports2.BinanceGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "BinanceGetAddress" });
    exports2.BinanceAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    }, { $id: "BinanceAddress" });
    exports2.BinanceGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "BinanceGetPublicKey" });
    exports2.BinancePublicKey = schema_utils_1.Type.Object({
      public_key: schema_utils_1.Type.String()
    }, { $id: "BinancePublicKey" });
    exports2.BinanceSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      msg_count: schema_utils_1.Type.Number(),
      account_number: schema_utils_1.Type.Number(),
      chain_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      memo: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sequence: schema_utils_1.Type.Number(),
      source: schema_utils_1.Type.Number(),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "BinanceSignTx" });
    exports2.BinanceTxRequest = schema_utils_1.Type.Object({}, { $id: "BinanceTxRequest" });
    exports2.BinanceCoin = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      denom: schema_utils_1.Type.String()
    }, { $id: "BinanceCoin" });
    exports2.BinanceInputOutput = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      coins: schema_utils_1.Type.Array(exports2.BinanceCoin)
    }, { $id: "BinanceInputOutput" });
    exports2.BinanceTransferMsg = schema_utils_1.Type.Object({
      inputs: schema_utils_1.Type.Array(exports2.BinanceInputOutput),
      outputs: schema_utils_1.Type.Array(exports2.BinanceInputOutput),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "BinanceTransferMsg" });
    var BinanceOrderType;
    (function(BinanceOrderType2) {
      BinanceOrderType2[BinanceOrderType2["OT_UNKNOWN"] = 0] = "OT_UNKNOWN";
      BinanceOrderType2[BinanceOrderType2["MARKET"] = 1] = "MARKET";
      BinanceOrderType2[BinanceOrderType2["LIMIT"] = 2] = "LIMIT";
      BinanceOrderType2[BinanceOrderType2["OT_RESERVED"] = 3] = "OT_RESERVED";
    })(BinanceOrderType || (exports2.BinanceOrderType = BinanceOrderType = {}));
    exports2.EnumBinanceOrderType = schema_utils_1.Type.Enum(BinanceOrderType);
    var BinanceOrderSide;
    (function(BinanceOrderSide2) {
      BinanceOrderSide2[BinanceOrderSide2["SIDE_UNKNOWN"] = 0] = "SIDE_UNKNOWN";
      BinanceOrderSide2[BinanceOrderSide2["BUY"] = 1] = "BUY";
      BinanceOrderSide2[BinanceOrderSide2["SELL"] = 2] = "SELL";
    })(BinanceOrderSide || (exports2.BinanceOrderSide = BinanceOrderSide = {}));
    exports2.EnumBinanceOrderSide = schema_utils_1.Type.Enum(BinanceOrderSide);
    var BinanceTimeInForce;
    (function(BinanceTimeInForce2) {
      BinanceTimeInForce2[BinanceTimeInForce2["TIF_UNKNOWN"] = 0] = "TIF_UNKNOWN";
      BinanceTimeInForce2[BinanceTimeInForce2["GTE"] = 1] = "GTE";
      BinanceTimeInForce2[BinanceTimeInForce2["TIF_RESERVED"] = 2] = "TIF_RESERVED";
      BinanceTimeInForce2[BinanceTimeInForce2["IOC"] = 3] = "IOC";
    })(BinanceTimeInForce || (exports2.BinanceTimeInForce = BinanceTimeInForce = {}));
    exports2.EnumBinanceTimeInForce = schema_utils_1.Type.Enum(BinanceTimeInForce);
    exports2.BinanceOrderMsg = schema_utils_1.Type.Object({
      id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ordertype: exports2.EnumBinanceOrderType,
      price: schema_utils_1.Type.Number(),
      quantity: schema_utils_1.Type.Number(),
      sender: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      side: exports2.EnumBinanceOrderSide,
      symbol: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      timeinforce: exports2.EnumBinanceTimeInForce
    }, { $id: "BinanceOrderMsg" });
    exports2.BinanceCancelMsg = schema_utils_1.Type.Object({
      refid: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sender: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      symbol: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "BinanceCancelMsg" });
    exports2.BinanceSignedTx = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      public_key: schema_utils_1.Type.String()
    }, { $id: "BinanceSignedTx" });
    var Enum_InputScriptType;
    (function(Enum_InputScriptType2) {
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDADDRESS"] = 0] = "SPENDADDRESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDMULTISIG"] = 1] = "SPENDMULTISIG";
      Enum_InputScriptType2[Enum_InputScriptType2["EXTERNAL"] = 2] = "EXTERNAL";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDWITNESS"] = 3] = "SPENDWITNESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDP2SHWITNESS"] = 4] = "SPENDP2SHWITNESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDTAPROOT"] = 5] = "SPENDTAPROOT";
    })(Enum_InputScriptType || (exports2.Enum_InputScriptType = Enum_InputScriptType = {}));
    exports2.EnumEnum_InputScriptType = schema_utils_1.Type.Enum(Enum_InputScriptType);
    exports2.InputScriptType = schema_utils_1.Type.KeyOfEnum(Enum_InputScriptType, { $id: "InputScriptType" });
    var Enum_OutputScriptType;
    (function(Enum_OutputScriptType2) {
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOADDRESS"] = 0] = "PAYTOADDRESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOSCRIPTHASH"] = 1] = "PAYTOSCRIPTHASH";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOMULTISIG"] = 2] = "PAYTOMULTISIG";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOOPRETURN"] = 3] = "PAYTOOPRETURN";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOWITNESS"] = 4] = "PAYTOWITNESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOP2SHWITNESS"] = 5] = "PAYTOP2SHWITNESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOTAPROOT"] = 6] = "PAYTOTAPROOT";
    })(Enum_OutputScriptType || (exports2.Enum_OutputScriptType = Enum_OutputScriptType = {}));
    exports2.EnumEnum_OutputScriptType = schema_utils_1.Type.Enum(Enum_OutputScriptType);
    exports2.OutputScriptType = schema_utils_1.Type.KeyOfEnum(Enum_OutputScriptType, { $id: "OutputScriptType" });
    var DecredStakingSpendType;
    (function(DecredStakingSpendType2) {
      DecredStakingSpendType2[DecredStakingSpendType2["SSGen"] = 0] = "SSGen";
      DecredStakingSpendType2[DecredStakingSpendType2["SSRTX"] = 1] = "SSRTX";
    })(DecredStakingSpendType || (exports2.DecredStakingSpendType = DecredStakingSpendType = {}));
    exports2.EnumDecredStakingSpendType = schema_utils_1.Type.Enum(DecredStakingSpendType);
    var AmountUnit;
    (function(AmountUnit2) {
      AmountUnit2[AmountUnit2["BITCOIN"] = 0] = "BITCOIN";
      AmountUnit2[AmountUnit2["MILLIBITCOIN"] = 1] = "MILLIBITCOIN";
      AmountUnit2[AmountUnit2["MICROBITCOIN"] = 2] = "MICROBITCOIN";
      AmountUnit2[AmountUnit2["SATOSHI"] = 3] = "SATOSHI";
    })(AmountUnit || (exports2.AmountUnit = AmountUnit = {}));
    exports2.EnumAmountUnit = schema_utils_1.Type.Enum(AmountUnit);
    exports2.HDNodeType = schema_utils_1.Type.Object({
      depth: schema_utils_1.Type.Number(),
      fingerprint: schema_utils_1.Type.Number(),
      child_num: schema_utils_1.Type.Number(),
      chain_code: schema_utils_1.Type.String(),
      private_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      public_key: schema_utils_1.Type.String()
    }, { $id: "HDNodeType" });
    exports2.HDNodePathType = schema_utils_1.Type.Object({
      node: schema_utils_1.Type.Union([exports2.HDNodeType, schema_utils_1.Type.String()]),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, { $id: "HDNodePathType" });
    exports2.MultisigRedeemScriptType = schema_utils_1.Type.Object({
      pubkeys: schema_utils_1.Type.Array(exports2.HDNodePathType),
      signatures: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      m: schema_utils_1.Type.Number(),
      nodes: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.HDNodeType)),
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number()))
    }, { $id: "MultisigRedeemScriptType" });
    exports2.GetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      ecdsa_curve_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType),
      ignore_xpub_magic: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "GetPublicKey" });
    exports2.PublicKey = schema_utils_1.Type.Object({
      node: exports2.HDNodeType,
      xpub: schema_utils_1.Type.String(),
      root_fingerprint: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      descriptor: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "PublicKey" });
    exports2.GetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType),
      ignore_xpub_magic: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "GetAddress" });
    exports2.Address = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "Address" });
    exports2.GetOwnershipId = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType)
    }, { $id: "GetOwnershipId" });
    exports2.OwnershipId = schema_utils_1.Type.Object({
      ownership_id: schema_utils_1.Type.String()
    }, { $id: "OwnershipId" });
    exports2.SignMessage = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      message: schema_utils_1.Type.String(),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType),
      no_script_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "SignMessage" });
    exports2.MessageSignature = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "MessageSignature" });
    exports2.VerifyMessage = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      message: schema_utils_1.Type.String(),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "VerifyMessage" });
    exports2.CoinJoinRequest = schema_utils_1.Type.Object({
      fee_rate: schema_utils_1.Type.Number(),
      no_fee_threshold: schema_utils_1.Type.Number(),
      min_registrable_amount: schema_utils_1.Type.Number(),
      mask_public_key: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "CoinJoinRequest" });
    exports2.SignTx = schema_utils_1.Type.Object({
      outputs_count: schema_utils_1.Type.Number(),
      inputs_count: schema_utils_1.Type.Number(),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      lock_time: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      expiry: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      overwintered: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      version_group_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      timestamp: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      branch_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      amount_unit: schema_utils_1.Type.Optional(exports2.EnumAmountUnit),
      decred_staking_ticket: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      serialize: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      coinjoin_request: schema_utils_1.Type.Optional(exports2.CoinJoinRequest),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "SignTx" });
    var Enum_RequestType;
    (function(Enum_RequestType2) {
      Enum_RequestType2[Enum_RequestType2["TXINPUT"] = 0] = "TXINPUT";
      Enum_RequestType2[Enum_RequestType2["TXOUTPUT"] = 1] = "TXOUTPUT";
      Enum_RequestType2[Enum_RequestType2["TXMETA"] = 2] = "TXMETA";
      Enum_RequestType2[Enum_RequestType2["TXFINISHED"] = 3] = "TXFINISHED";
      Enum_RequestType2[Enum_RequestType2["TXEXTRADATA"] = 4] = "TXEXTRADATA";
      Enum_RequestType2[Enum_RequestType2["TXORIGINPUT"] = 5] = "TXORIGINPUT";
      Enum_RequestType2[Enum_RequestType2["TXORIGOUTPUT"] = 6] = "TXORIGOUTPUT";
      Enum_RequestType2[Enum_RequestType2["TXPAYMENTREQ"] = 7] = "TXPAYMENTREQ";
    })(Enum_RequestType || (exports2.Enum_RequestType = Enum_RequestType = {}));
    exports2.EnumEnum_RequestType = schema_utils_1.Type.Enum(Enum_RequestType);
    exports2.RequestType = schema_utils_1.Type.KeyOfEnum(Enum_RequestType, { $id: "RequestType" });
    exports2.TxRequestDetailsType = schema_utils_1.Type.Object({
      request_index: schema_utils_1.Type.Number(),
      tx_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      extra_data_len: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      extra_data_offset: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "TxRequestDetailsType" });
    exports2.TxRequestSerializedType = schema_utils_1.Type.Object({
      signature_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      serialized_tx: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "TxRequestSerializedType" });
    exports2.TxRequest = schema_utils_1.Type.Object({
      request_type: exports2.RequestType,
      details: exports2.TxRequestDetailsType,
      serialized: schema_utils_1.Type.Optional(exports2.TxRequestSerializedType)
    }, { $id: "TxRequest" });
    exports2.InternalInputScriptType = schema_utils_1.Type.Exclude(exports2.InputScriptType, schema_utils_1.Type.Literal("EXTERNAL"), {
      $id: "InternalInputScriptType"
    });
    const CommonTxInputType = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number(),
      amount: schema_utils_1.Type.Uint(),
      sequence: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
      decred_tree: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      decred_staking_spend: schema_utils_1.Type.Optional(exports2.EnumDecredStakingSpendType),
      script_pubkey: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      coinjoin_flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      script_sig: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      witness: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ownership_proof: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      commitment_data: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CommonTxInputType" });
    exports2.TxInputType = schema_utils_1.Type.Union([
      schema_utils_1.Type.Intersect([
        CommonTxInputType,
        schema_utils_1.Type.Object({
          address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
          script_type: schema_utils_1.Type.Optional(exports2.InternalInputScriptType)
        })
      ]),
      schema_utils_1.Type.Intersect([
        CommonTxInputType,
        schema_utils_1.Type.Object({
          address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
          script_type: schema_utils_1.Type.Literal("EXTERNAL"),
          script_pubkey: schema_utils_1.Type.String()
        })
      ])
    ], { $id: "TxInputType" });
    exports2.TxInput = schema_utils_1.TypeClone.Type(exports2.TxInputType, { $id: "TxInput" });
    exports2.TxOutputBinType = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      script_pubkey: schema_utils_1.Type.String(),
      decred_script_version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "TxOutputBinType" });
    exports2.ChangeOutputScriptType = schema_utils_1.Type.Exclude(exports2.OutputScriptType, schema_utils_1.Type.Literal("PAYTOOPRETURN"), { $id: "ChangeOutputScriptType" });
    exports2.TxOutputType = schema_utils_1.Type.Union([
      schema_utils_1.Type.Object({
        address: schema_utils_1.Type.String(),
        address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        script_type: schema_utils_1.Type.Literal("PAYTOADDRESS"),
        amount: schema_utils_1.Type.Uint(),
        multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
        orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      }),
      schema_utils_1.Type.Object({
        address: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
        script_type: schema_utils_1.Type.Optional(exports2.ChangeOutputScriptType),
        amount: schema_utils_1.Type.Uint(),
        multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
        orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      }),
      schema_utils_1.Type.Object({
        address: schema_utils_1.Type.String(),
        address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        script_type: schema_utils_1.Type.Optional(exports2.ChangeOutputScriptType),
        amount: schema_utils_1.Type.Uint(),
        multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
        orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      }),
      schema_utils_1.Type.Object({
        address: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        amount: schema_utils_1.Type.Union([schema_utils_1.Type.Literal("0"), schema_utils_1.Type.Literal(0)]),
        op_return_data: schema_utils_1.Type.String(),
        script_type: schema_utils_1.Type.Literal("PAYTOOPRETURN"),
        orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      })
    ], { $id: "TxOutputType" });
    exports2.TxOutput = schema_utils_1.TypeClone.Type(exports2.TxOutputType, { $id: "TxOutput" });
    exports2.PrevTx = schema_utils_1.Type.Object({
      version: schema_utils_1.Type.Number(),
      lock_time: schema_utils_1.Type.Number(),
      inputs_count: schema_utils_1.Type.Number(),
      outputs_count: schema_utils_1.Type.Number(),
      extra_data_len: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      expiry: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      version_group_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      timestamp: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      branch_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "PrevTx" });
    exports2.PrevInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number(),
      script_sig: schema_utils_1.Type.String(),
      sequence: schema_utils_1.Type.Number(),
      decred_tree: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "PrevInput" });
    exports2.PrevOutput = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      script_pubkey: schema_utils_1.Type.String(),
      decred_script_version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "PrevOutput" });
    exports2.TextMemo = schema_utils_1.Type.Object({
      text: schema_utils_1.Type.String()
    }, { $id: "TextMemo" });
    exports2.RefundMemo = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.String()
    }, { $id: "RefundMemo" });
    exports2.CoinPurchaseMemo = schema_utils_1.Type.Object({
      coin_type: schema_utils_1.Type.Number(),
      amount: schema_utils_1.Type.Uint(),
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.String()
    }, { $id: "CoinPurchaseMemo" });
    exports2.PaymentRequestMemo = schema_utils_1.Type.Object({
      text_memo: schema_utils_1.Type.Optional(exports2.TextMemo),
      refund_memo: schema_utils_1.Type.Optional(exports2.RefundMemo),
      coin_purchase_memo: schema_utils_1.Type.Optional(exports2.CoinPurchaseMemo)
    }, { $id: "PaymentRequestMemo" });
    exports2.TxAckPaymentRequest = schema_utils_1.Type.Object({
      nonce: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      recipient_name: schema_utils_1.Type.String(),
      memos: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.PaymentRequestMemo)),
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      signature: schema_utils_1.Type.String()
    }, { $id: "TxAckPaymentRequest" });
    exports2.TxAckResponse = schema_utils_1.Type.Union([
      schema_utils_1.Type.Object({
        inputs: schema_utils_1.Type.Array(schema_utils_1.Type.Union([exports2.TxInputType, exports2.PrevInput]))
      }),
      schema_utils_1.Type.Object({
        bin_outputs: schema_utils_1.Type.Array(exports2.TxOutputBinType)
      }),
      schema_utils_1.Type.Object({
        outputs: schema_utils_1.Type.Array(exports2.TxOutputType)
      }),
      schema_utils_1.Type.Object({
        extra_data: schema_utils_1.Type.String()
      }),
      schema_utils_1.Type.Object({
        version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        lock_time: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        inputs_cnt: schema_utils_1.Type.Number(),
        outputs_cnt: schema_utils_1.Type.Number(),
        extra_data: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        extra_data_len: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        timestamp: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        version_group_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        expiry: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        branch_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      })
    ], { $id: "TxAckResponse" });
    exports2.TxAck = schema_utils_1.Type.Object({
      tx: exports2.TxAckResponse
    }, { $id: "TxAck" });
    exports2.TxAckInputWrapper = schema_utils_1.Type.Object({
      input: exports2.TxInput
    }, { $id: "TxAckInputWrapper" });
    exports2.TxAckInput = schema_utils_1.Type.Object({
      tx: exports2.TxAckInputWrapper
    }, { $id: "TxAckInput" });
    exports2.TxAckOutputWrapper = schema_utils_1.Type.Object({
      output: exports2.TxOutput
    }, { $id: "TxAckOutputWrapper" });
    exports2.TxAckOutput = schema_utils_1.Type.Object({
      tx: exports2.TxAckOutputWrapper
    }, { $id: "TxAckOutput" });
    exports2.TxAckPrevMeta = schema_utils_1.Type.Object({
      tx: exports2.PrevTx
    }, { $id: "TxAckPrevMeta" });
    exports2.TxAckPrevInputWrapper = schema_utils_1.Type.Object({
      input: exports2.PrevInput
    }, { $id: "TxAckPrevInputWrapper" });
    exports2.TxAckPrevInput = schema_utils_1.Type.Object({
      tx: exports2.TxAckPrevInputWrapper
    }, { $id: "TxAckPrevInput" });
    exports2.TxAckPrevOutputWrapper = schema_utils_1.Type.Object({
      output: exports2.PrevOutput
    }, { $id: "TxAckPrevOutputWrapper" });
    exports2.TxAckPrevOutput = schema_utils_1.Type.Object({
      tx: exports2.TxAckPrevOutputWrapper
    }, { $id: "TxAckPrevOutput" });
    exports2.TxAckPrevExtraDataWrapper = schema_utils_1.Type.Object({
      extra_data_chunk: schema_utils_1.Type.String()
    }, { $id: "TxAckPrevExtraDataWrapper" });
    exports2.TxAckPrevExtraData = schema_utils_1.Type.Object({
      tx: exports2.TxAckPrevExtraDataWrapper
    }, { $id: "TxAckPrevExtraData" });
    exports2.GetOwnershipProof = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType),
      multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
      user_confirmation: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      ownership_ids: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.String())),
      commitment_data: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "GetOwnershipProof" });
    exports2.OwnershipProof = schema_utils_1.Type.Object({
      ownership_proof: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "OwnershipProof" });
    exports2.AuthorizeCoinJoin = schema_utils_1.Type.Object({
      coordinator: schema_utils_1.Type.String(),
      max_rounds: schema_utils_1.Type.Number(),
      max_coordinator_fee_rate: schema_utils_1.Type.Number(),
      max_fee_per_kvbyte: schema_utils_1.Type.Number(),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType),
      amount_unit: schema_utils_1.Type.Optional(exports2.EnumAmountUnit)
    }, { $id: "AuthorizeCoinJoin" });
    exports2.FirmwareErase = schema_utils_1.Type.Object({
      length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "FirmwareErase" });
    exports2.FirmwareRequest = schema_utils_1.Type.Object({
      offset: schema_utils_1.Type.Number(),
      length: schema_utils_1.Type.Number()
    }, { $id: "FirmwareRequest" });
    exports2.FirmwareUpload = schema_utils_1.Type.Object({
      payload: schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.ArrayBuffer()]),
      hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "FirmwareUpload" });
    exports2.ProdTestT1 = schema_utils_1.Type.Object({
      payload: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "ProdTestT1" });
    var CardanoDerivationType;
    (function(CardanoDerivationType2) {
      CardanoDerivationType2[CardanoDerivationType2["LEDGER"] = 0] = "LEDGER";
      CardanoDerivationType2[CardanoDerivationType2["ICARUS"] = 1] = "ICARUS";
      CardanoDerivationType2[CardanoDerivationType2["ICARUS_TREZOR"] = 2] = "ICARUS_TREZOR";
    })(CardanoDerivationType || (exports2.CardanoDerivationType = CardanoDerivationType = {}));
    exports2.EnumCardanoDerivationType = schema_utils_1.Type.Enum(CardanoDerivationType);
    var CardanoAddressType;
    (function(CardanoAddressType2) {
      CardanoAddressType2[CardanoAddressType2["BASE"] = 0] = "BASE";
      CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_KEY"] = 1] = "BASE_SCRIPT_KEY";
      CardanoAddressType2[CardanoAddressType2["BASE_KEY_SCRIPT"] = 2] = "BASE_KEY_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_SCRIPT"] = 3] = "BASE_SCRIPT_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["POINTER"] = 4] = "POINTER";
      CardanoAddressType2[CardanoAddressType2["POINTER_SCRIPT"] = 5] = "POINTER_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["ENTERPRISE"] = 6] = "ENTERPRISE";
      CardanoAddressType2[CardanoAddressType2["ENTERPRISE_SCRIPT"] = 7] = "ENTERPRISE_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["BYRON"] = 8] = "BYRON";
      CardanoAddressType2[CardanoAddressType2["REWARD"] = 14] = "REWARD";
      CardanoAddressType2[CardanoAddressType2["REWARD_SCRIPT"] = 15] = "REWARD_SCRIPT";
    })(CardanoAddressType || (exports2.CardanoAddressType = CardanoAddressType = {}));
    exports2.EnumCardanoAddressType = schema_utils_1.Type.Enum(CardanoAddressType);
    var CardanoNativeScriptType;
    (function(CardanoNativeScriptType2) {
      CardanoNativeScriptType2[CardanoNativeScriptType2["PUB_KEY"] = 0] = "PUB_KEY";
      CardanoNativeScriptType2[CardanoNativeScriptType2["ALL"] = 1] = "ALL";
      CardanoNativeScriptType2[CardanoNativeScriptType2["ANY"] = 2] = "ANY";
      CardanoNativeScriptType2[CardanoNativeScriptType2["N_OF_K"] = 3] = "N_OF_K";
      CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_BEFORE"] = 4] = "INVALID_BEFORE";
      CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_HEREAFTER"] = 5] = "INVALID_HEREAFTER";
    })(CardanoNativeScriptType || (exports2.CardanoNativeScriptType = CardanoNativeScriptType = {}));
    exports2.EnumCardanoNativeScriptType = schema_utils_1.Type.Enum(CardanoNativeScriptType);
    var CardanoNativeScriptHashDisplayFormat;
    (function(CardanoNativeScriptHashDisplayFormat2) {
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["HIDE"] = 0] = "HIDE";
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["BECH32"] = 1] = "BECH32";
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["POLICY_ID"] = 2] = "POLICY_ID";
    })(CardanoNativeScriptHashDisplayFormat || (exports2.CardanoNativeScriptHashDisplayFormat = CardanoNativeScriptHashDisplayFormat = {}));
    exports2.EnumCardanoNativeScriptHashDisplayFormat = schema_utils_1.Type.Enum(CardanoNativeScriptHashDisplayFormat);
    var CardanoTxOutputSerializationFormat;
    (function(CardanoTxOutputSerializationFormat2) {
      CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["ARRAY_LEGACY"] = 0] = "ARRAY_LEGACY";
      CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["MAP_BABBAGE"] = 1] = "MAP_BABBAGE";
    })(CardanoTxOutputSerializationFormat || (exports2.CardanoTxOutputSerializationFormat = CardanoTxOutputSerializationFormat = {}));
    exports2.EnumCardanoTxOutputSerializationFormat = schema_utils_1.Type.Enum(CardanoTxOutputSerializationFormat);
    var CardanoCertificateType;
    (function(CardanoCertificateType2) {
      CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION"] = 0] = "STAKE_REGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION"] = 1] = "STAKE_DEREGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DELEGATION"] = 2] = "STAKE_DELEGATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_POOL_REGISTRATION"] = 3] = "STAKE_POOL_REGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION_CONWAY"] = 7] = "STAKE_REGISTRATION_CONWAY";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION_CONWAY"] = 8] = "STAKE_DEREGISTRATION_CONWAY";
      CardanoCertificateType2[CardanoCertificateType2["VOTE_DELEGATION"] = 9] = "VOTE_DELEGATION";
    })(CardanoCertificateType || (exports2.CardanoCertificateType = CardanoCertificateType = {}));
    exports2.EnumCardanoCertificateType = schema_utils_1.Type.Enum(CardanoCertificateType);
    var CardanoDRepType;
    (function(CardanoDRepType2) {
      CardanoDRepType2[CardanoDRepType2["KEY_HASH"] = 0] = "KEY_HASH";
      CardanoDRepType2[CardanoDRepType2["SCRIPT_HASH"] = 1] = "SCRIPT_HASH";
      CardanoDRepType2[CardanoDRepType2["ABSTAIN"] = 2] = "ABSTAIN";
      CardanoDRepType2[CardanoDRepType2["NO_CONFIDENCE"] = 3] = "NO_CONFIDENCE";
    })(CardanoDRepType || (exports2.CardanoDRepType = CardanoDRepType = {}));
    exports2.EnumCardanoDRepType = schema_utils_1.Type.Enum(CardanoDRepType);
    var CardanoPoolRelayType;
    (function(CardanoPoolRelayType2) {
      CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_IP"] = 0] = "SINGLE_HOST_IP";
      CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_NAME"] = 1] = "SINGLE_HOST_NAME";
      CardanoPoolRelayType2[CardanoPoolRelayType2["MULTIPLE_HOST_NAME"] = 2] = "MULTIPLE_HOST_NAME";
    })(CardanoPoolRelayType || (exports2.CardanoPoolRelayType = CardanoPoolRelayType = {}));
    exports2.EnumCardanoPoolRelayType = schema_utils_1.Type.Enum(CardanoPoolRelayType);
    var CardanoTxAuxiliaryDataSupplementType;
    (function(CardanoTxAuxiliaryDataSupplementType2) {
      CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["NONE"] = 0] = "NONE";
      CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["CVOTE_REGISTRATION_SIGNATURE"] = 1] = "CVOTE_REGISTRATION_SIGNATURE";
    })(CardanoTxAuxiliaryDataSupplementType || (exports2.CardanoTxAuxiliaryDataSupplementType = CardanoTxAuxiliaryDataSupplementType = {}));
    exports2.EnumCardanoTxAuxiliaryDataSupplementType = schema_utils_1.Type.Enum(CardanoTxAuxiliaryDataSupplementType);
    var CardanoCVoteRegistrationFormat;
    (function(CardanoCVoteRegistrationFormat2) {
      CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP15"] = 0] = "CIP15";
      CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP36"] = 1] = "CIP36";
    })(CardanoCVoteRegistrationFormat || (exports2.CardanoCVoteRegistrationFormat = CardanoCVoteRegistrationFormat = {}));
    exports2.EnumCardanoCVoteRegistrationFormat = schema_utils_1.Type.Enum(CardanoCVoteRegistrationFormat);
    var CardanoTxSigningMode;
    (function(CardanoTxSigningMode2) {
      CardanoTxSigningMode2[CardanoTxSigningMode2["ORDINARY_TRANSACTION"] = 0] = "ORDINARY_TRANSACTION";
      CardanoTxSigningMode2[CardanoTxSigningMode2["POOL_REGISTRATION_AS_OWNER"] = 1] = "POOL_REGISTRATION_AS_OWNER";
      CardanoTxSigningMode2[CardanoTxSigningMode2["MULTISIG_TRANSACTION"] = 2] = "MULTISIG_TRANSACTION";
      CardanoTxSigningMode2[CardanoTxSigningMode2["PLUTUS_TRANSACTION"] = 3] = "PLUTUS_TRANSACTION";
    })(CardanoTxSigningMode || (exports2.CardanoTxSigningMode = CardanoTxSigningMode = {}));
    exports2.EnumCardanoTxSigningMode = schema_utils_1.Type.Enum(CardanoTxSigningMode);
    var CardanoTxWitnessType;
    (function(CardanoTxWitnessType2) {
      CardanoTxWitnessType2[CardanoTxWitnessType2["BYRON_WITNESS"] = 0] = "BYRON_WITNESS";
      CardanoTxWitnessType2[CardanoTxWitnessType2["SHELLEY_WITNESS"] = 1] = "SHELLEY_WITNESS";
    })(CardanoTxWitnessType || (exports2.CardanoTxWitnessType = CardanoTxWitnessType = {}));
    exports2.EnumCardanoTxWitnessType = schema_utils_1.Type.Enum(CardanoTxWitnessType);
    exports2.CardanoBlockchainPointerType = schema_utils_1.Type.Object({
      block_index: schema_utils_1.Type.Number(),
      tx_index: schema_utils_1.Type.Number(),
      certificate_index: schema_utils_1.Type.Number()
    }, { $id: "CardanoBlockchainPointerType" });
    exports2.CardanoNativeScript = schema_utils_1.Type.Recursive((This) => schema_utils_1.Type.Object({
      type: exports2.EnumCardanoNativeScriptType,
      scripts: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(This)),
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      required_signatures_count: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      invalid_before: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      invalid_hereafter: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint())
    }), { $id: "CardanoNativeScript" });
    exports2.CardanoGetNativeScriptHash = schema_utils_1.Type.Object({
      script: exports2.CardanoNativeScript,
      display_format: exports2.EnumCardanoNativeScriptHashDisplayFormat,
      derivation_type: exports2.EnumCardanoDerivationType
    }, { $id: "CardanoGetNativeScriptHash" });
    exports2.CardanoNativeScriptHash = schema_utils_1.Type.Object({
      script_hash: schema_utils_1.Type.String()
    }, { $id: "CardanoNativeScriptHash" });
    exports2.CardanoAddressParametersType = schema_utils_1.Type.Object({
      address_type: exports2.EnumCardanoAddressType,
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      address_n_staking: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      staking_key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      certificate_pointer: schema_utils_1.Type.Optional(exports2.CardanoBlockchainPointerType),
      script_payment_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_staking_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoAddressParametersType" });
    exports2.CardanoGetAddress = schema_utils_1.Type.Object({
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      protocol_magic: schema_utils_1.Type.Number(),
      network_id: schema_utils_1.Type.Number(),
      address_parameters: exports2.CardanoAddressParametersType,
      derivation_type: exports2.EnumCardanoDerivationType,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "CardanoGetAddress" });
    exports2.CardanoAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    }, { $id: "CardanoAddress" });
    exports2.CardanoGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      derivation_type: exports2.EnumCardanoDerivationType
    }, { $id: "CardanoGetPublicKey" });
    exports2.CardanoPublicKey = schema_utils_1.Type.Object({
      xpub: schema_utils_1.Type.String(),
      node: exports2.HDNodeType
    }, { $id: "CardanoPublicKey" });
    exports2.CardanoSignTxInit = schema_utils_1.Type.Object({
      signing_mode: exports2.EnumCardanoTxSigningMode,
      protocol_magic: schema_utils_1.Type.Number(),
      network_id: schema_utils_1.Type.Number(),
      inputs_count: schema_utils_1.Type.Number(),
      outputs_count: schema_utils_1.Type.Number(),
      fee: schema_utils_1.Type.Uint(),
      ttl: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      certificates_count: schema_utils_1.Type.Number(),
      withdrawals_count: schema_utils_1.Type.Number(),
      has_auxiliary_data: schema_utils_1.Type.Boolean(),
      validity_interval_start: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      witness_requests_count: schema_utils_1.Type.Number(),
      minting_asset_groups_count: schema_utils_1.Type.Number(),
      derivation_type: exports2.EnumCardanoDerivationType,
      include_network_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      script_data_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      collateral_inputs_count: schema_utils_1.Type.Number(),
      required_signers_count: schema_utils_1.Type.Number(),
      has_collateral_return: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      total_collateral: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      reference_inputs_count: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      tag_cbor_sets: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "CardanoSignTxInit" });
    exports2.CardanoTxInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    }, { $id: "CardanoTxInput" });
    exports2.CardanoTxOutput = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      address_parameters: schema_utils_1.Type.Optional(exports2.CardanoAddressParametersType),
      amount: schema_utils_1.Type.Uint(),
      asset_groups_count: schema_utils_1.Type.Number(),
      datum_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      format: schema_utils_1.Type.Optional(exports2.EnumCardanoTxOutputSerializationFormat),
      inline_datum_size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      reference_script_size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "CardanoTxOutput" });
    exports2.CardanoAssetGroup = schema_utils_1.Type.Object({
      policy_id: schema_utils_1.Type.String(),
      tokens_count: schema_utils_1.Type.Number()
    }, { $id: "CardanoAssetGroup" });
    exports2.CardanoToken = schema_utils_1.Type.Object({
      asset_name_bytes: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      mint_amount: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint({ allowNegative: true }))
    }, { $id: "CardanoToken" });
    exports2.CardanoTxInlineDatumChunk = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String()
    }, { $id: "CardanoTxInlineDatumChunk" });
    exports2.CardanoTxReferenceScriptChunk = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String()
    }, { $id: "CardanoTxReferenceScriptChunk" });
    exports2.CardanoPoolOwner = schema_utils_1.Type.Object({
      staking_key_path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      staking_key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoPoolOwner" });
    exports2.CardanoPoolRelayParameters = schema_utils_1.Type.Object({
      type: exports2.EnumCardanoPoolRelayType,
      ipv4_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ipv6_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      host_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      port: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "CardanoPoolRelayParameters" });
    exports2.CardanoPoolMetadataType = schema_utils_1.Type.Object({
      url: schema_utils_1.Type.String(),
      hash: schema_utils_1.Type.String()
    }, { $id: "CardanoPoolMetadataType" });
    exports2.CardanoPoolParametersType = schema_utils_1.Type.Object({
      pool_id: schema_utils_1.Type.String(),
      vrf_key_hash: schema_utils_1.Type.String(),
      pledge: schema_utils_1.Type.Uint(),
      cost: schema_utils_1.Type.Uint(),
      margin_numerator: schema_utils_1.Type.Uint(),
      margin_denominator: schema_utils_1.Type.Uint(),
      reward_account: schema_utils_1.Type.String(),
      metadata: schema_utils_1.Type.Optional(exports2.CardanoPoolMetadataType),
      owners_count: schema_utils_1.Type.Number(),
      relays_count: schema_utils_1.Type.Number()
    }, { $id: "CardanoPoolParametersType" });
    exports2.CardanoDRep = schema_utils_1.Type.Object({
      type: exports2.EnumCardanoDRepType,
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoDRep" });
    exports2.CardanoTxCertificate = schema_utils_1.Type.Object({
      type: exports2.EnumCardanoCertificateType,
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      pool: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      pool_parameters: schema_utils_1.Type.Optional(exports2.CardanoPoolParametersType),
      script_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      deposit: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      drep: schema_utils_1.Type.Optional(exports2.CardanoDRep)
    }, { $id: "CardanoTxCertificate" });
    exports2.CardanoTxWithdrawal = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      amount: schema_utils_1.Type.Uint(),
      script_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoTxWithdrawal" });
    exports2.CardanoCVoteRegistrationDelegation = schema_utils_1.Type.Object({
      vote_public_key: schema_utils_1.Type.String(),
      weight: schema_utils_1.Type.Uint()
    }, { $id: "CardanoCVoteRegistrationDelegation" });
    exports2.CardanoCVoteRegistrationParametersType = schema_utils_1.Type.Object({
      vote_public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      staking_path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      payment_address_parameters: schema_utils_1.Type.Optional(exports2.CardanoAddressParametersType),
      nonce: schema_utils_1.Type.Uint(),
      format: schema_utils_1.Type.Optional(exports2.EnumCardanoCVoteRegistrationFormat),
      delegations: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoCVoteRegistrationDelegation)),
      voting_purpose: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      payment_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoCVoteRegistrationParametersType" });
    exports2.CardanoTxAuxiliaryData = schema_utils_1.Type.Object({
      cvote_registration_parameters: schema_utils_1.Type.Optional(exports2.CardanoCVoteRegistrationParametersType),
      hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoTxAuxiliaryData" });
    exports2.CardanoTxMint = schema_utils_1.Type.Object({
      asset_groups_count: schema_utils_1.Type.Number()
    }, { $id: "CardanoTxMint" });
    exports2.CardanoTxCollateralInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    }, { $id: "CardanoTxCollateralInput" });
    exports2.CardanoTxRequiredSigner = schema_utils_1.Type.Object({
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number()))
    }, { $id: "CardanoTxRequiredSigner" });
    exports2.CardanoTxReferenceInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    }, { $id: "CardanoTxReferenceInput" });
    exports2.CardanoTxItemAck = schema_utils_1.Type.Object({}, { $id: "CardanoTxItemAck" });
    exports2.CardanoTxAuxiliaryDataSupplement = schema_utils_1.Type.Object({
      type: exports2.EnumCardanoTxAuxiliaryDataSupplementType,
      auxiliary_data_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      cvote_registration_signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoTxAuxiliaryDataSupplement" });
    exports2.CardanoTxWitnessRequest = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, { $id: "CardanoTxWitnessRequest" });
    exports2.CardanoTxWitnessResponse = schema_utils_1.Type.Object({
      type: exports2.EnumCardanoTxWitnessType,
      pub_key: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      chain_code: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoTxWitnessResponse" });
    exports2.CardanoTxHostAck = schema_utils_1.Type.Object({}, { $id: "CardanoTxHostAck" });
    exports2.CardanoTxBodyHash = schema_utils_1.Type.Object({
      tx_hash: schema_utils_1.Type.String()
    }, { $id: "CardanoTxBodyHash" });
    exports2.CardanoSignTxFinished = schema_utils_1.Type.Object({}, { $id: "CardanoSignTxFinished" });
    exports2.Success = schema_utils_1.Type.Object({
      message: schema_utils_1.Type.String()
    }, { $id: "Success" });
    var FailureType;
    (function(FailureType2) {
      FailureType2[FailureType2["Failure_UnexpectedMessage"] = 1] = "Failure_UnexpectedMessage";
      FailureType2[FailureType2["Failure_ButtonExpected"] = 2] = "Failure_ButtonExpected";
      FailureType2[FailureType2["Failure_DataError"] = 3] = "Failure_DataError";
      FailureType2[FailureType2["Failure_ActionCancelled"] = 4] = "Failure_ActionCancelled";
      FailureType2[FailureType2["Failure_PinExpected"] = 5] = "Failure_PinExpected";
      FailureType2[FailureType2["Failure_PinCancelled"] = 6] = "Failure_PinCancelled";
      FailureType2[FailureType2["Failure_PinInvalid"] = 7] = "Failure_PinInvalid";
      FailureType2[FailureType2["Failure_InvalidSignature"] = 8] = "Failure_InvalidSignature";
      FailureType2[FailureType2["Failure_ProcessError"] = 9] = "Failure_ProcessError";
      FailureType2[FailureType2["Failure_NotEnoughFunds"] = 10] = "Failure_NotEnoughFunds";
      FailureType2[FailureType2["Failure_NotInitialized"] = 11] = "Failure_NotInitialized";
      FailureType2[FailureType2["Failure_PinMismatch"] = 12] = "Failure_PinMismatch";
      FailureType2[FailureType2["Failure_WipeCodeMismatch"] = 13] = "Failure_WipeCodeMismatch";
      FailureType2[FailureType2["Failure_InvalidSession"] = 14] = "Failure_InvalidSession";
      FailureType2[FailureType2["Failure_FirmwareError"] = 99] = "Failure_FirmwareError";
    })(FailureType || (exports2.FailureType = FailureType = {}));
    exports2.EnumFailureType = schema_utils_1.Type.Enum(FailureType);
    exports2.Failure = schema_utils_1.Type.Object({
      code: schema_utils_1.Type.Optional(exports2.EnumFailureType),
      message: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "Failure" });
    var Enum_ButtonRequestType;
    (function(Enum_ButtonRequestType2) {
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Other"] = 1] = "ButtonRequest_Other";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FeeOverThreshold"] = 2] = "ButtonRequest_FeeOverThreshold";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmOutput"] = 3] = "ButtonRequest_ConfirmOutput";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ResetDevice"] = 4] = "ButtonRequest_ResetDevice";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmWord"] = 5] = "ButtonRequest_ConfirmWord";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_WipeDevice"] = 6] = "ButtonRequest_WipeDevice";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ProtectCall"] = 7] = "ButtonRequest_ProtectCall";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_SignTx"] = 8] = "ButtonRequest_SignTx";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FirmwareCheck"] = 9] = "ButtonRequest_FirmwareCheck";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Address"] = 10] = "ButtonRequest_Address";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PublicKey"] = 11] = "ButtonRequest_PublicKey";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicWordCount"] = 12] = "ButtonRequest_MnemonicWordCount";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicInput"] = 13] = "ButtonRequest_MnemonicInput";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["_Deprecated_ButtonRequest_PassphraseType"] = 14] = "_Deprecated_ButtonRequest_PassphraseType";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_UnknownDerivationPath"] = 15] = "ButtonRequest_UnknownDerivationPath";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_RecoveryHomepage"] = 16] = "ButtonRequest_RecoveryHomepage";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Success"] = 17] = "ButtonRequest_Success";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Warning"] = 18] = "ButtonRequest_Warning";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PassphraseEntry"] = 19] = "ButtonRequest_PassphraseEntry";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PinEntry"] = 20] = "ButtonRequest_PinEntry";
    })(Enum_ButtonRequestType || (exports2.Enum_ButtonRequestType = Enum_ButtonRequestType = {}));
    exports2.EnumEnum_ButtonRequestType = schema_utils_1.Type.Enum(Enum_ButtonRequestType);
    exports2.ButtonRequestType = schema_utils_1.Type.KeyOfEnum(Enum_ButtonRequestType, {
      $id: "ButtonRequestType"
    });
    exports2.ButtonRequest = schema_utils_1.Type.Object({
      code: schema_utils_1.Type.Optional(exports2.ButtonRequestType),
      pages: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "ButtonRequest" });
    exports2.ButtonAck = schema_utils_1.Type.Object({}, { $id: "ButtonAck" });
    var Enum_PinMatrixRequestType;
    (function(Enum_PinMatrixRequestType2) {
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_Current"] = 1] = "PinMatrixRequestType_Current";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewFirst"] = 2] = "PinMatrixRequestType_NewFirst";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewSecond"] = 3] = "PinMatrixRequestType_NewSecond";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeFirst"] = 4] = "PinMatrixRequestType_WipeCodeFirst";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeSecond"] = 5] = "PinMatrixRequestType_WipeCodeSecond";
    })(Enum_PinMatrixRequestType || (exports2.Enum_PinMatrixRequestType = Enum_PinMatrixRequestType = {}));
    exports2.EnumEnum_PinMatrixRequestType = schema_utils_1.Type.Enum(Enum_PinMatrixRequestType);
    exports2.PinMatrixRequestType = schema_utils_1.Type.KeyOfEnum(Enum_PinMatrixRequestType, {
      $id: "PinMatrixRequestType"
    });
    exports2.PinMatrixRequest = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Optional(exports2.PinMatrixRequestType)
    }, { $id: "PinMatrixRequest" });
    exports2.PinMatrixAck = schema_utils_1.Type.Object({
      pin: schema_utils_1.Type.String()
    }, { $id: "PinMatrixAck" });
    exports2.PassphraseRequest = schema_utils_1.Type.Object({
      _on_device: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "PassphraseRequest" });
    exports2.PassphraseAck = schema_utils_1.Type.Object({
      passphrase: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      _state: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      on_device: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "PassphraseAck" });
    exports2.Deprecated_PassphraseStateRequest = schema_utils_1.Type.Object({
      state: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "Deprecated_PassphraseStateRequest" });
    exports2.Deprecated_PassphraseStateAck = schema_utils_1.Type.Object({}, { $id: "Deprecated_PassphraseStateAck" });
    exports2.CipherKeyValue = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      key: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.String(),
      encrypt: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      ask_on_encrypt: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      ask_on_decrypt: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      iv: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CipherKeyValue" });
    exports2.CipheredKeyValue = schema_utils_1.Type.Object({
      value: schema_utils_1.Type.String()
    }, { $id: "CipheredKeyValue" });
    exports2.IdentityType = schema_utils_1.Type.Object({
      proto: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      user: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      host: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      port: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "IdentityType" });
    exports2.SignIdentity = schema_utils_1.Type.Object({
      identity: exports2.IdentityType,
      challenge_hidden: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      challenge_visual: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ecdsa_curve_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "SignIdentity" });
    exports2.SignedIdentity = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      public_key: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "SignedIdentity" });
    exports2.GetECDHSessionKey = schema_utils_1.Type.Object({
      identity: exports2.IdentityType,
      peer_public_key: schema_utils_1.Type.String(),
      ecdsa_curve_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "GetECDHSessionKey" });
    exports2.ECDHSessionKey = schema_utils_1.Type.Object({
      session_key: schema_utils_1.Type.String(),
      public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "ECDHSessionKey" });
    var DebugButton;
    (function(DebugButton2) {
      DebugButton2[DebugButton2["NO"] = 0] = "NO";
      DebugButton2[DebugButton2["YES"] = 1] = "YES";
      DebugButton2[DebugButton2["INFO"] = 2] = "INFO";
    })(DebugButton || (exports2.DebugButton = DebugButton = {}));
    exports2.EnumDebugButton = schema_utils_1.Type.Enum(DebugButton);
    var DebugPhysicalButton;
    (function(DebugPhysicalButton2) {
      DebugPhysicalButton2[DebugPhysicalButton2["LEFT_BTN"] = 0] = "LEFT_BTN";
      DebugPhysicalButton2[DebugPhysicalButton2["MIDDLE_BTN"] = 1] = "MIDDLE_BTN";
      DebugPhysicalButton2[DebugPhysicalButton2["RIGHT_BTN"] = 2] = "RIGHT_BTN";
    })(DebugPhysicalButton || (exports2.DebugPhysicalButton = DebugPhysicalButton = {}));
    exports2.EnumDebugPhysicalButton = schema_utils_1.Type.Enum(DebugPhysicalButton);
    exports2.DebugLinkResetDebugEvents = schema_utils_1.Type.Object({}, { $id: "DebugLinkResetDebugEvents" });
    exports2.EosGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EosGetPublicKey" });
    exports2.EosPublicKey = schema_utils_1.Type.Object({
      wif_public_key: schema_utils_1.Type.String(),
      raw_public_key: schema_utils_1.Type.String()
    }, { $id: "EosPublicKey" });
    exports2.EosTxHeader = schema_utils_1.Type.Object({
      expiration: schema_utils_1.Type.Number(),
      ref_block_num: schema_utils_1.Type.Number(),
      ref_block_prefix: schema_utils_1.Type.Number(),
      max_net_usage_words: schema_utils_1.Type.Number(),
      max_cpu_usage_ms: schema_utils_1.Type.Number(),
      delay_sec: schema_utils_1.Type.Number()
    }, { $id: "EosTxHeader" });
    exports2.EosSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      chain_id: schema_utils_1.Type.String(),
      header: exports2.EosTxHeader,
      num_actions: schema_utils_1.Type.Number(),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EosSignTx" });
    exports2.EosTxActionRequest = schema_utils_1.Type.Object({
      data_size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "EosTxActionRequest" });
    exports2.EosAsset = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      symbol: schema_utils_1.Type.String()
    }, { $id: "EosAsset" });
    exports2.EosPermissionLevel = schema_utils_1.Type.Object({
      actor: schema_utils_1.Type.String(),
      permission: schema_utils_1.Type.String()
    }, { $id: "EosPermissionLevel" });
    exports2.EosAuthorizationKey = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      key: schema_utils_1.Type.String(),
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      weight: schema_utils_1.Type.Number()
    }, { $id: "EosAuthorizationKey" });
    exports2.EosAuthorizationAccount = schema_utils_1.Type.Object({
      account: exports2.EosPermissionLevel,
      weight: schema_utils_1.Type.Number()
    }, { $id: "EosAuthorizationAccount" });
    exports2.EosAuthorizationWait = schema_utils_1.Type.Object({
      wait_sec: schema_utils_1.Type.Number(),
      weight: schema_utils_1.Type.Number()
    }, { $id: "EosAuthorizationWait" });
    exports2.EosAuthorization = schema_utils_1.Type.Object({
      threshold: schema_utils_1.Type.Number(),
      keys: schema_utils_1.Type.Array(exports2.EosAuthorizationKey),
      accounts: schema_utils_1.Type.Array(exports2.EosAuthorizationAccount),
      waits: schema_utils_1.Type.Array(exports2.EosAuthorizationWait)
    }, { $id: "EosAuthorization" });
    exports2.EosActionCommon = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String(),
      authorization: schema_utils_1.Type.Array(exports2.EosPermissionLevel)
    }, { $id: "EosActionCommon" });
    exports2.EosActionTransfer = schema_utils_1.Type.Object({
      sender: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      quantity: exports2.EosAsset,
      memo: schema_utils_1.Type.String()
    }, { $id: "EosActionTransfer" });
    exports2.EosActionDelegate = schema_utils_1.Type.Object({
      sender: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      net_quantity: exports2.EosAsset,
      cpu_quantity: exports2.EosAsset,
      transfer: schema_utils_1.Type.Boolean()
    }, { $id: "EosActionDelegate" });
    exports2.EosActionUndelegate = schema_utils_1.Type.Object({
      sender: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      net_quantity: exports2.EosAsset,
      cpu_quantity: exports2.EosAsset
    }, { $id: "EosActionUndelegate" });
    exports2.EosActionRefund = schema_utils_1.Type.Object({
      owner: schema_utils_1.Type.String()
    }, { $id: "EosActionRefund" });
    exports2.EosActionBuyRam = schema_utils_1.Type.Object({
      payer: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      quantity: exports2.EosAsset
    }, { $id: "EosActionBuyRam" });
    exports2.EosActionBuyRamBytes = schema_utils_1.Type.Object({
      payer: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      bytes: schema_utils_1.Type.Number()
    }, { $id: "EosActionBuyRamBytes" });
    exports2.EosActionSellRam = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      bytes: schema_utils_1.Type.Number()
    }, { $id: "EosActionSellRam" });
    exports2.EosActionVoteProducer = schema_utils_1.Type.Object({
      voter: schema_utils_1.Type.String(),
      proxy: schema_utils_1.Type.String(),
      producers: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    }, { $id: "EosActionVoteProducer" });
    exports2.EosActionUpdateAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      permission: schema_utils_1.Type.String(),
      parent: schema_utils_1.Type.String(),
      auth: exports2.EosAuthorization
    }, { $id: "EosActionUpdateAuth" });
    exports2.EosActionDeleteAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      permission: schema_utils_1.Type.String()
    }, { $id: "EosActionDeleteAuth" });
    exports2.EosActionLinkAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      code: schema_utils_1.Type.String(),
      type: schema_utils_1.Type.String(),
      requirement: schema_utils_1.Type.String()
    }, { $id: "EosActionLinkAuth" });
    exports2.EosActionUnlinkAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      code: schema_utils_1.Type.String(),
      type: schema_utils_1.Type.String()
    }, { $id: "EosActionUnlinkAuth" });
    exports2.EosActionNewAccount = schema_utils_1.Type.Object({
      creator: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String(),
      owner: exports2.EosAuthorization,
      active: exports2.EosAuthorization
    }, { $id: "EosActionNewAccount" });
    exports2.EosActionUnknown = schema_utils_1.Type.Object({
      data_size: schema_utils_1.Type.Number(),
      data_chunk: schema_utils_1.Type.String()
    }, { $id: "EosActionUnknown" });
    exports2.EosTxActionAck = schema_utils_1.Type.Object({
      common: exports2.EosActionCommon,
      transfer: schema_utils_1.Type.Optional(exports2.EosActionTransfer),
      delegate: schema_utils_1.Type.Optional(exports2.EosActionDelegate),
      undelegate: schema_utils_1.Type.Optional(exports2.EosActionUndelegate),
      refund: schema_utils_1.Type.Optional(exports2.EosActionRefund),
      buy_ram: schema_utils_1.Type.Optional(exports2.EosActionBuyRam),
      buy_ram_bytes: schema_utils_1.Type.Optional(exports2.EosActionBuyRamBytes),
      sell_ram: schema_utils_1.Type.Optional(exports2.EosActionSellRam),
      vote_producer: schema_utils_1.Type.Optional(exports2.EosActionVoteProducer),
      update_auth: schema_utils_1.Type.Optional(exports2.EosActionUpdateAuth),
      delete_auth: schema_utils_1.Type.Optional(exports2.EosActionDeleteAuth),
      link_auth: schema_utils_1.Type.Optional(exports2.EosActionLinkAuth),
      unlink_auth: schema_utils_1.Type.Optional(exports2.EosActionUnlinkAuth),
      new_account: schema_utils_1.Type.Optional(exports2.EosActionNewAccount),
      unknown: schema_utils_1.Type.Optional(exports2.EosActionUnknown)
    }, { $id: "EosTxActionAck" });
    exports2.EosSignedTx = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String()
    }, { $id: "EosSignedTx" });
    var EthereumDefinitionType;
    (function(EthereumDefinitionType2) {
      EthereumDefinitionType2[EthereumDefinitionType2["NETWORK"] = 0] = "NETWORK";
      EthereumDefinitionType2[EthereumDefinitionType2["TOKEN"] = 1] = "TOKEN";
    })(EthereumDefinitionType || (exports2.EthereumDefinitionType = EthereumDefinitionType = {}));
    exports2.EnumEthereumDefinitionType = schema_utils_1.Type.Enum(EthereumDefinitionType);
    exports2.EthereumNetworkInfo = schema_utils_1.Type.Object({
      chain_id: schema_utils_1.Type.Number(),
      symbol: schema_utils_1.Type.String(),
      slip44: schema_utils_1.Type.Number(),
      name: schema_utils_1.Type.String()
    }, { $id: "EthereumNetworkInfo" });
    exports2.EthereumTokenInfo = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      chain_id: schema_utils_1.Type.Number(),
      symbol: schema_utils_1.Type.String(),
      decimals: schema_utils_1.Type.Number(),
      name: schema_utils_1.Type.String()
    }, { $id: "EthereumTokenInfo" });
    exports2.EthereumDefinitions = schema_utils_1.Type.Object({
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer()),
      encoded_token: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer())
    }, { $id: "EthereumDefinitions" });
    exports2.EthereumSignTypedData = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      primary_type: schema_utils_1.Type.String(),
      metamask_v4_compat: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      definitions: schema_utils_1.Type.Optional(exports2.EthereumDefinitions)
    }, { $id: "EthereumSignTypedData" });
    exports2.EthereumTypedDataStructRequest = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.String()
    }, { $id: "EthereumTypedDataStructRequest" });
    var EthereumDataType;
    (function(EthereumDataType2) {
      EthereumDataType2[EthereumDataType2["UINT"] = 1] = "UINT";
      EthereumDataType2[EthereumDataType2["INT"] = 2] = "INT";
      EthereumDataType2[EthereumDataType2["BYTES"] = 3] = "BYTES";
      EthereumDataType2[EthereumDataType2["STRING"] = 4] = "STRING";
      EthereumDataType2[EthereumDataType2["BOOL"] = 5] = "BOOL";
      EthereumDataType2[EthereumDataType2["ADDRESS"] = 6] = "ADDRESS";
      EthereumDataType2[EthereumDataType2["ARRAY"] = 7] = "ARRAY";
      EthereumDataType2[EthereumDataType2["STRUCT"] = 8] = "STRUCT";
    })(EthereumDataType || (exports2.EthereumDataType = EthereumDataType = {}));
    exports2.EnumEthereumDataType = schema_utils_1.Type.Enum(EthereumDataType);
    exports2.EthereumFieldType = schema_utils_1.Type.Recursive((This) => schema_utils_1.Type.Object({
      data_type: exports2.EnumEthereumDataType,
      size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      entry_type: schema_utils_1.Type.Optional(This),
      struct_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }), { $id: "EthereumFieldType" });
    exports2.EthereumStructMember = schema_utils_1.Type.Object({
      type: exports2.EthereumFieldType,
      name: schema_utils_1.Type.String()
    }, { $id: "EthereumStructMember" });
    exports2.EthereumTypedDataStructAck = schema_utils_1.Type.Object({
      members: schema_utils_1.Type.Array(exports2.EthereumStructMember)
    }, { $id: "EthereumTypedDataStructAck" });
    exports2.EthereumTypedDataValueRequest = schema_utils_1.Type.Object({
      member_path: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, { $id: "EthereumTypedDataValueRequest" });
    exports2.EthereumTypedDataValueAck = schema_utils_1.Type.Object({
      value: schema_utils_1.Type.String()
    }, { $id: "EthereumTypedDataValueAck" });
    exports2.EthereumGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EthereumGetPublicKey" });
    exports2.EthereumPublicKey = schema_utils_1.Type.Object({
      node: exports2.HDNodeType,
      xpub: schema_utils_1.Type.String()
    }, { $id: "EthereumPublicKey" });
    exports2.EthereumGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EthereumGetAddress" });
    exports2.EthereumAddress = schema_utils_1.Type.Object({
      _old_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      address: schema_utils_1.Type.String()
    }, { $id: "EthereumAddress" });
    exports2.EthereumSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      nonce: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      gas_price: schema_utils_1.Type.String(),
      gas_limit: schema_utils_1.Type.String(),
      to: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data_initial_chunk: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      chain_id: schema_utils_1.Type.Number(),
      tx_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      definitions: schema_utils_1.Type.Optional(exports2.EthereumDefinitions),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EthereumSignTx" });
    exports2.EthereumAccessList = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      storage_keys: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    }, { $id: "EthereumAccessList" });
    exports2.EthereumSignTxEIP1559 = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      nonce: schema_utils_1.Type.String(),
      max_gas_fee: schema_utils_1.Type.String(),
      max_priority_fee: schema_utils_1.Type.String(),
      gas_limit: schema_utils_1.Type.String(),
      to: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      value: schema_utils_1.Type.String(),
      data_initial_chunk: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data_length: schema_utils_1.Type.Number(),
      chain_id: schema_utils_1.Type.Number(),
      access_list: schema_utils_1.Type.Array(exports2.EthereumAccessList),
      definitions: schema_utils_1.Type.Optional(exports2.EthereumDefinitions),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EthereumSignTxEIP1559" });
    exports2.EthereumTxRequest = schema_utils_1.Type.Object({
      data_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signature_v: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signature_r: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signature_s: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "EthereumTxRequest" });
    exports2.EthereumTxAck = schema_utils_1.Type.Object({
      data_chunk: schema_utils_1.Type.String()
    }, { $id: "EthereumTxAck" });
    exports2.EthereumSignMessage = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      message: schema_utils_1.Type.String(),
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EthereumSignMessage" });
    exports2.EthereumMessageSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String()
    }, { $id: "EthereumMessageSignature" });
    exports2.EthereumVerifyMessage = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      message: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String(),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EthereumVerifyMessage" });
    exports2.EthereumSignTypedHash = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      domain_separator_hash: schema_utils_1.Type.String(),
      message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer())
    }, { $id: "EthereumSignTypedHash" });
    exports2.EthereumTypedDataSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String()
    }, { $id: "EthereumTypedDataSignature" });
    var Enum_BackupType;
    (function(Enum_BackupType2) {
      Enum_BackupType2[Enum_BackupType2["Bip39"] = 0] = "Bip39";
      Enum_BackupType2[Enum_BackupType2["Slip39_Basic"] = 1] = "Slip39_Basic";
      Enum_BackupType2[Enum_BackupType2["Slip39_Advanced"] = 2] = "Slip39_Advanced";
      Enum_BackupType2[Enum_BackupType2["Slip39_Single_Extendable"] = 3] = "Slip39_Single_Extendable";
      Enum_BackupType2[Enum_BackupType2["Slip39_Basic_Extendable"] = 4] = "Slip39_Basic_Extendable";
      Enum_BackupType2[Enum_BackupType2["Slip39_Advanced_Extendable"] = 5] = "Slip39_Advanced_Extendable";
    })(Enum_BackupType || (exports2.Enum_BackupType = Enum_BackupType = {}));
    exports2.EnumEnum_BackupType = schema_utils_1.Type.Enum(Enum_BackupType);
    exports2.BackupType = schema_utils_1.Type.KeyOfEnum(Enum_BackupType, { $id: "BackupType" });
    var Enum_SafetyCheckLevel;
    (function(Enum_SafetyCheckLevel2) {
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["Strict"] = 0] = "Strict";
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptAlways"] = 1] = "PromptAlways";
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptTemporarily"] = 2] = "PromptTemporarily";
    })(Enum_SafetyCheckLevel || (exports2.Enum_SafetyCheckLevel = Enum_SafetyCheckLevel = {}));
    exports2.EnumEnum_SafetyCheckLevel = schema_utils_1.Type.Enum(Enum_SafetyCheckLevel);
    exports2.SafetyCheckLevel = schema_utils_1.Type.KeyOfEnum(Enum_SafetyCheckLevel, { $id: "SafetyCheckLevel" });
    var Enum_HomescreenFormat;
    (function(Enum_HomescreenFormat2) {
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["Toif"] = 1] = "Toif";
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["Jpeg"] = 2] = "Jpeg";
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["ToiG"] = 3] = "ToiG";
    })(Enum_HomescreenFormat || (exports2.Enum_HomescreenFormat = Enum_HomescreenFormat = {}));
    exports2.EnumEnum_HomescreenFormat = schema_utils_1.Type.Enum(Enum_HomescreenFormat);
    exports2.HomescreenFormat = schema_utils_1.Type.KeyOfEnum(Enum_HomescreenFormat, { $id: "HomescreenFormat" });
    exports2.Initialize = schema_utils_1.Type.Object({
      session_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      _skip_passphrase: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      derive_cardano: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "Initialize" });
    exports2.GetFeatures = schema_utils_1.Type.Object({}, { $id: "GetFeatures" });
    var Enum_BackupAvailability;
    (function(Enum_BackupAvailability2) {
      Enum_BackupAvailability2[Enum_BackupAvailability2["NotAvailable"] = 0] = "NotAvailable";
      Enum_BackupAvailability2[Enum_BackupAvailability2["Required"] = 1] = "Required";
      Enum_BackupAvailability2[Enum_BackupAvailability2["Available"] = 2] = "Available";
    })(Enum_BackupAvailability || (exports2.Enum_BackupAvailability = Enum_BackupAvailability = {}));
    exports2.EnumEnum_BackupAvailability = schema_utils_1.Type.Enum(Enum_BackupAvailability);
    exports2.BackupAvailability = schema_utils_1.Type.KeyOfEnum(Enum_BackupAvailability, {
      $id: "BackupAvailability"
    });
    var Enum_RecoveryStatus;
    (function(Enum_RecoveryStatus2) {
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Nothing"] = 0] = "Nothing";
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Recovery"] = 1] = "Recovery";
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Backup"] = 2] = "Backup";
    })(Enum_RecoveryStatus || (exports2.Enum_RecoveryStatus = Enum_RecoveryStatus = {}));
    exports2.EnumEnum_RecoveryStatus = schema_utils_1.Type.Enum(Enum_RecoveryStatus);
    exports2.RecoveryStatus = schema_utils_1.Type.KeyOfEnum(Enum_RecoveryStatus, { $id: "RecoveryStatus" });
    var Enum_Capability;
    (function(Enum_Capability2) {
      Enum_Capability2[Enum_Capability2["Capability_Bitcoin"] = 1] = "Capability_Bitcoin";
      Enum_Capability2[Enum_Capability2["Capability_Bitcoin_like"] = 2] = "Capability_Bitcoin_like";
      Enum_Capability2[Enum_Capability2["Capability_Binance"] = 3] = "Capability_Binance";
      Enum_Capability2[Enum_Capability2["Capability_Cardano"] = 4] = "Capability_Cardano";
      Enum_Capability2[Enum_Capability2["Capability_Crypto"] = 5] = "Capability_Crypto";
      Enum_Capability2[Enum_Capability2["Capability_EOS"] = 6] = "Capability_EOS";
      Enum_Capability2[Enum_Capability2["Capability_Ethereum"] = 7] = "Capability_Ethereum";
      Enum_Capability2[Enum_Capability2["Capability_Lisk"] = 8] = "Capability_Lisk";
      Enum_Capability2[Enum_Capability2["Capability_Monero"] = 9] = "Capability_Monero";
      Enum_Capability2[Enum_Capability2["Capability_NEM"] = 10] = "Capability_NEM";
      Enum_Capability2[Enum_Capability2["Capability_Ripple"] = 11] = "Capability_Ripple";
      Enum_Capability2[Enum_Capability2["Capability_Stellar"] = 12] = "Capability_Stellar";
      Enum_Capability2[Enum_Capability2["Capability_Tezos"] = 13] = "Capability_Tezos";
      Enum_Capability2[Enum_Capability2["Capability_U2F"] = 14] = "Capability_U2F";
      Enum_Capability2[Enum_Capability2["Capability_Shamir"] = 15] = "Capability_Shamir";
      Enum_Capability2[Enum_Capability2["Capability_ShamirGroups"] = 16] = "Capability_ShamirGroups";
      Enum_Capability2[Enum_Capability2["Capability_PassphraseEntry"] = 17] = "Capability_PassphraseEntry";
      Enum_Capability2[Enum_Capability2["Capability_Solana"] = 18] = "Capability_Solana";
      Enum_Capability2[Enum_Capability2["Capability_Translations"] = 19] = "Capability_Translations";
      Enum_Capability2[Enum_Capability2["Capability_Brightness"] = 20] = "Capability_Brightness";
      Enum_Capability2[Enum_Capability2["Capability_Haptic"] = 21] = "Capability_Haptic";
    })(Enum_Capability || (exports2.Enum_Capability = Enum_Capability = {}));
    exports2.EnumEnum_Capability = schema_utils_1.Type.Enum(Enum_Capability);
    exports2.Capability = schema_utils_1.Type.KeyOfEnum(Enum_Capability, { $id: "Capability" });
    var RecoveryDeviceInputMethod;
    (function(RecoveryDeviceInputMethod2) {
      RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["ScrambledWords"] = 0] = "ScrambledWords";
      RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["Matrix"] = 1] = "Matrix";
    })(RecoveryDeviceInputMethod || (exports2.RecoveryDeviceInputMethod = RecoveryDeviceInputMethod = {}));
    exports2.EnumRecoveryDeviceInputMethod = schema_utils_1.Type.Enum(RecoveryDeviceInputMethod);
    var Enum_RecoveryType;
    (function(Enum_RecoveryType2) {
      Enum_RecoveryType2[Enum_RecoveryType2["NormalRecovery"] = 0] = "NormalRecovery";
      Enum_RecoveryType2[Enum_RecoveryType2["DryRun"] = 1] = "DryRun";
      Enum_RecoveryType2[Enum_RecoveryType2["UnlockRepeatedBackup"] = 2] = "UnlockRepeatedBackup";
    })(Enum_RecoveryType || (exports2.Enum_RecoveryType = Enum_RecoveryType = {}));
    exports2.EnumEnum_RecoveryType = schema_utils_1.Type.Enum(Enum_RecoveryType);
    exports2.RecoveryType = schema_utils_1.Type.KeyOfEnum(Enum_RecoveryType, { $id: "RecoveryType" });
    exports2.RecoveryDevice = schema_utils_1.Type.Object({
      word_count: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      passphrase_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      pin_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      enforce_wordlist: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      input_method: schema_utils_1.Type.Optional(exports2.EnumRecoveryDeviceInputMethod),
      u2f_counter: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      type: schema_utils_1.Type.Optional(exports2.RecoveryType)
    }, { $id: "RecoveryDevice" });
    exports2.Features = schema_utils_1.Type.Object({
      vendor: schema_utils_1.Type.String(),
      major_version: schema_utils_1.Type.Number(),
      minor_version: schema_utils_1.Type.Number(),
      patch_version: schema_utils_1.Type.Number(),
      bootloader_mode: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      device_id: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      pin_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      passphrase_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      language: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      label: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      initialized: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      revision: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      bootloader_hash: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      imported: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      unlocked: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      _passphrase_cached: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      firmware_present: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      backup_availability: schema_utils_1.Type.Union([exports2.BackupAvailability, schema_utils_1.Type.Null()]),
      flags: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      model: schema_utils_1.Type.String(),
      fw_major: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      fw_minor: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      fw_patch: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      fw_vendor: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      unfinished_backup: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      no_backup: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      recovery_status: schema_utils_1.Type.Union([exports2.RecoveryStatus, schema_utils_1.Type.Null()]),
      capabilities: schema_utils_1.Type.Array(exports2.Capability),
      backup_type: schema_utils_1.Type.Union([exports2.BackupType, schema_utils_1.Type.Null()]),
      sd_card_present: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      sd_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      wipe_code_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      session_id: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      passphrase_always_on_device: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      safety_checks: schema_utils_1.Type.Union([exports2.SafetyCheckLevel, schema_utils_1.Type.Null()]),
      auto_lock_delay_ms: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      display_rotation: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      experimental_features: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      busy: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen_format: schema_utils_1.Type.Optional(exports2.HomescreenFormat),
      hide_passphrase_from_host: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      internal_model: exports2.EnumDeviceModelInternal,
      unit_color: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      unit_btconly: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen_width: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      homescreen_height: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      bootloader_locked: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language_version_matches: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      unit_packaging: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      haptic_feedback: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      recovery_type: schema_utils_1.Type.Optional(exports2.RecoveryType)
    }, { $id: "Features" });
    exports2.LockDevice = schema_utils_1.Type.Object({}, { $id: "LockDevice" });
    exports2.SetBusy = schema_utils_1.Type.Object({
      expiry_ms: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "SetBusy" });
    exports2.EndSession = schema_utils_1.Type.Object({}, { $id: "EndSession" });
    exports2.ApplySettings = schema_utils_1.Type.Object({
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      use_passphrase: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      _passphrase_source: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      auto_lock_delay_ms: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      display_rotation: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      passphrase_always_on_device: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      safety_checks: schema_utils_1.Type.Optional(exports2.SafetyCheckLevel),
      experimental_features: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      hide_passphrase_from_host: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      haptic_feedback: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "ApplySettings" });
    exports2.ChangeLanguage = schema_utils_1.Type.Object({
      data_length: schema_utils_1.Type.Number(),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "ChangeLanguage" });
    exports2.TranslationDataRequest = schema_utils_1.Type.Object({
      data_length: schema_utils_1.Type.Number(),
      data_offset: schema_utils_1.Type.Number()
    }, { $id: "TranslationDataRequest" });
    exports2.TranslationDataAck = schema_utils_1.Type.Object({
      data_chunk: schema_utils_1.Type.String()
    }, { $id: "TranslationDataAck" });
    exports2.ApplyFlags = schema_utils_1.Type.Object({
      flags: schema_utils_1.Type.Number()
    }, { $id: "ApplyFlags" });
    exports2.ChangePin = schema_utils_1.Type.Object({
      remove: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "ChangePin" });
    exports2.ChangeWipeCode = schema_utils_1.Type.Object({
      remove: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "ChangeWipeCode" });
    var SdProtectOperationType;
    (function(SdProtectOperationType2) {
      SdProtectOperationType2[SdProtectOperationType2["DISABLE"] = 0] = "DISABLE";
      SdProtectOperationType2[SdProtectOperationType2["ENABLE"] = 1] = "ENABLE";
      SdProtectOperationType2[SdProtectOperationType2["REFRESH"] = 2] = "REFRESH";
    })(SdProtectOperationType || (exports2.SdProtectOperationType = SdProtectOperationType = {}));
    exports2.EnumSdProtectOperationType = schema_utils_1.Type.Enum(SdProtectOperationType);
    exports2.SdProtect = schema_utils_1.Type.Object({
      operation: exports2.EnumSdProtectOperationType
    }, { $id: "SdProtect" });
    exports2.Ping = schema_utils_1.Type.Object({
      message: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      button_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "Ping" });
    exports2.Cancel = schema_utils_1.Type.Object({}, { $id: "Cancel" });
    exports2.GetEntropy = schema_utils_1.Type.Object({
      size: schema_utils_1.Type.Number()
    }, { $id: "GetEntropy" });
    exports2.Entropy = schema_utils_1.Type.Object({
      entropy: schema_utils_1.Type.String()
    }, { $id: "Entropy" });
    exports2.GetFirmwareHash = schema_utils_1.Type.Object({
      challenge: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "GetFirmwareHash" });
    exports2.FirmwareHash = schema_utils_1.Type.Object({
      hash: schema_utils_1.Type.String()
    }, { $id: "FirmwareHash" });
    exports2.AuthenticateDevice = schema_utils_1.Type.Object({
      challenge: schema_utils_1.Type.String()
    }, { $id: "AuthenticateDevice" });
    exports2.AuthenticityProof = schema_utils_1.Type.Object({
      certificates: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      signature: schema_utils_1.Type.String()
    }, { $id: "AuthenticityProof" });
    exports2.WipeDevice = schema_utils_1.Type.Object({}, { $id: "WipeDevice" });
    exports2.ResetDevice = schema_utils_1.Type.Object({
      display_random: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      strength: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      passphrase_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      pin_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      u2f_counter: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      skip_backup: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      no_backup: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      backup_type: schema_utils_1.Type.Optional(exports2.EnumEnum_BackupType)
    }, { $id: "ResetDevice" });
    exports2.Slip39Group = schema_utils_1.Type.Object({
      member_threshold: schema_utils_1.Type.Number(),
      member_count: schema_utils_1.Type.Number()
    }, { $id: "Slip39Group" });
    exports2.BackupDevice = schema_utils_1.Type.Object({
      group_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      groups: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.Slip39Group))
    }, { $id: "BackupDevice" });
    exports2.EntropyRequest = schema_utils_1.Type.Object({}, { $id: "EntropyRequest" });
    exports2.EntropyAck = schema_utils_1.Type.Object({
      entropy: schema_utils_1.Type.String()
    }, { $id: "EntropyAck" });
    var Enum_WordRequestType;
    (function(Enum_WordRequestType2) {
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Plain"] = 0] = "WordRequestType_Plain";
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix9"] = 1] = "WordRequestType_Matrix9";
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix6"] = 2] = "WordRequestType_Matrix6";
    })(Enum_WordRequestType || (exports2.Enum_WordRequestType = Enum_WordRequestType = {}));
    exports2.EnumEnum_WordRequestType = schema_utils_1.Type.Enum(Enum_WordRequestType);
    exports2.WordRequestType = schema_utils_1.Type.KeyOfEnum(Enum_WordRequestType, { $id: "WordRequestType" });
    exports2.WordRequest = schema_utils_1.Type.Object({
      type: exports2.WordRequestType
    }, { $id: "WordRequest" });
    exports2.WordAck = schema_utils_1.Type.Object({
      word: schema_utils_1.Type.String()
    }, { $id: "WordAck" });
    exports2.SetU2FCounter = schema_utils_1.Type.Object({
      u2f_counter: schema_utils_1.Type.Number()
    }, { $id: "SetU2FCounter" });
    exports2.GetNextU2FCounter = schema_utils_1.Type.Object({}, { $id: "GetNextU2FCounter" });
    exports2.NextU2FCounter = schema_utils_1.Type.Object({
      u2f_counter: schema_utils_1.Type.Number()
    }, { $id: "NextU2FCounter" });
    exports2.DoPreauthorized = schema_utils_1.Type.Object({}, { $id: "DoPreauthorized" });
    exports2.PreauthorizedRequest = schema_utils_1.Type.Object({}, { $id: "PreauthorizedRequest" });
    exports2.CancelAuthorization = schema_utils_1.Type.Object({}, { $id: "CancelAuthorization" });
    var BootCommand;
    (function(BootCommand2) {
      BootCommand2[BootCommand2["STOP_AND_WAIT"] = 0] = "STOP_AND_WAIT";
      BootCommand2[BootCommand2["INSTALL_UPGRADE"] = 1] = "INSTALL_UPGRADE";
    })(BootCommand || (exports2.BootCommand = BootCommand = {}));
    exports2.EnumBootCommand = schema_utils_1.Type.Enum(BootCommand);
    exports2.RebootToBootloader = schema_utils_1.Type.Object({
      boot_command: schema_utils_1.Type.Optional(exports2.EnumBootCommand),
      firmware_header: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      language_data_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "RebootToBootloader" });
    exports2.GetNonce = schema_utils_1.Type.Object({}, { $id: "GetNonce" });
    exports2.Nonce = schema_utils_1.Type.Object({
      nonce: schema_utils_1.Type.String()
    }, { $id: "Nonce" });
    exports2.UnlockPath = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "UnlockPath" });
    exports2.UnlockedPathRequest = schema_utils_1.Type.Object({
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "UnlockedPathRequest" });
    exports2.ShowDeviceTutorial = schema_utils_1.Type.Object({}, { $id: "ShowDeviceTutorial" });
    exports2.UnlockBootloader = schema_utils_1.Type.Object({}, { $id: "UnlockBootloader" });
    exports2.SetBrightness = schema_utils_1.Type.Object({
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "SetBrightness" });
    var MoneroNetworkType;
    (function(MoneroNetworkType2) {
      MoneroNetworkType2[MoneroNetworkType2["MAINNET"] = 0] = "MAINNET";
      MoneroNetworkType2[MoneroNetworkType2["TESTNET"] = 1] = "TESTNET";
      MoneroNetworkType2[MoneroNetworkType2["STAGENET"] = 2] = "STAGENET";
      MoneroNetworkType2[MoneroNetworkType2["FAKECHAIN"] = 3] = "FAKECHAIN";
    })(MoneroNetworkType || (exports2.MoneroNetworkType = MoneroNetworkType = {}));
    exports2.EnumMoneroNetworkType = schema_utils_1.Type.Enum(MoneroNetworkType);
    exports2.NEMGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "NEMGetAddress" });
    exports2.NEMAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    }, { $id: "NEMAddress" });
    exports2.NEMTransactionCommon = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      timestamp: schema_utils_1.Type.Number(),
      fee: schema_utils_1.Type.Uint(),
      deadline: schema_utils_1.Type.Number(),
      signer: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "NEMTransactionCommon" });
    exports2.NEMMosaic = schema_utils_1.Type.Object({
      namespace: schema_utils_1.Type.String(),
      mosaic: schema_utils_1.Type.String(),
      quantity: schema_utils_1.Type.Number()
    }, { $id: "NEMMosaic" });
    exports2.NEMTransfer = schema_utils_1.Type.Object({
      recipient: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Uint(),
      payload: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      mosaics: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.NEMMosaic))
    }, { $id: "NEMTransfer" });
    exports2.NEMProvisionNamespace = schema_utils_1.Type.Object({
      namespace: schema_utils_1.Type.String(),
      parent: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sink: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Uint()
    }, { $id: "NEMProvisionNamespace" });
    var NEMMosaicLevy;
    (function(NEMMosaicLevy2) {
      NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Absolute"] = 1] = "MosaicLevy_Absolute";
      NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Percentile"] = 2] = "MosaicLevy_Percentile";
    })(NEMMosaicLevy || (exports2.NEMMosaicLevy = NEMMosaicLevy = {}));
    exports2.EnumNEMMosaicLevy = schema_utils_1.Type.Enum(NEMMosaicLevy);
    exports2.NEMMosaicDefinition = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ticker: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      namespace: schema_utils_1.Type.String(),
      mosaic: schema_utils_1.Type.String(),
      divisibility: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      levy: schema_utils_1.Type.Optional(exports2.EnumNEMMosaicLevy),
      fee: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      levy_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      levy_namespace: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      levy_mosaic: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      supply: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      mutable_supply: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      transferable: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      description: schema_utils_1.Type.String(),
      networks: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number()))
    }, { $id: "NEMMosaicDefinition" });
    exports2.NEMMosaicCreation = schema_utils_1.Type.Object({
      definition: exports2.NEMMosaicDefinition,
      sink: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Uint()
    }, { $id: "NEMMosaicCreation" });
    var NEMSupplyChangeType;
    (function(NEMSupplyChangeType2) {
      NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Increase"] = 1] = "SupplyChange_Increase";
      NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Decrease"] = 2] = "SupplyChange_Decrease";
    })(NEMSupplyChangeType || (exports2.NEMSupplyChangeType = NEMSupplyChangeType = {}));
    exports2.EnumNEMSupplyChangeType = schema_utils_1.Type.Enum(NEMSupplyChangeType);
    exports2.NEMMosaicSupplyChange = schema_utils_1.Type.Object({
      namespace: schema_utils_1.Type.String(),
      mosaic: schema_utils_1.Type.String(),
      type: exports2.EnumNEMSupplyChangeType,
      delta: schema_utils_1.Type.Number()
    }, { $id: "NEMMosaicSupplyChange" });
    var NEMModificationType;
    (function(NEMModificationType2) {
      NEMModificationType2[NEMModificationType2["CosignatoryModification_Add"] = 1] = "CosignatoryModification_Add";
      NEMModificationType2[NEMModificationType2["CosignatoryModification_Delete"] = 2] = "CosignatoryModification_Delete";
    })(NEMModificationType || (exports2.NEMModificationType = NEMModificationType = {}));
    exports2.EnumNEMModificationType = schema_utils_1.Type.Enum(NEMModificationType);
    exports2.NEMCosignatoryModification = schema_utils_1.Type.Object({
      type: exports2.EnumNEMModificationType,
      public_key: schema_utils_1.Type.String()
    }, { $id: "NEMCosignatoryModification" });
    exports2.NEMAggregateModification = schema_utils_1.Type.Object({
      modifications: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.NEMCosignatoryModification)),
      relative_change: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "NEMAggregateModification" });
    var NEMImportanceTransferMode;
    (function(NEMImportanceTransferMode2) {
      NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Activate"] = 1] = "ImportanceTransfer_Activate";
      NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Deactivate"] = 2] = "ImportanceTransfer_Deactivate";
    })(NEMImportanceTransferMode || (exports2.NEMImportanceTransferMode = NEMImportanceTransferMode = {}));
    exports2.EnumNEMImportanceTransferMode = schema_utils_1.Type.Enum(NEMImportanceTransferMode);
    exports2.NEMImportanceTransfer = schema_utils_1.Type.Object({
      mode: exports2.EnumNEMImportanceTransferMode,
      public_key: schema_utils_1.Type.String()
    }, { $id: "NEMImportanceTransfer" });
    exports2.NEMSignTx = schema_utils_1.Type.Object({
      transaction: exports2.NEMTransactionCommon,
      multisig: schema_utils_1.Type.Optional(exports2.NEMTransactionCommon),
      transfer: schema_utils_1.Type.Optional(exports2.NEMTransfer),
      cosigning: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      provision_namespace: schema_utils_1.Type.Optional(exports2.NEMProvisionNamespace),
      mosaic_creation: schema_utils_1.Type.Optional(exports2.NEMMosaicCreation),
      supply_change: schema_utils_1.Type.Optional(exports2.NEMMosaicSupplyChange),
      aggregate_modification: schema_utils_1.Type.Optional(exports2.NEMAggregateModification),
      importance_transfer: schema_utils_1.Type.Optional(exports2.NEMImportanceTransfer),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "NEMSignTx" });
    exports2.NEMSignedTx = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "NEMSignedTx" });
    exports2.NEMDecryptMessage = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      payload: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "NEMDecryptMessage" });
    exports2.NEMDecryptedMessage = schema_utils_1.Type.Object({
      payload: schema_utils_1.Type.String()
    }, { $id: "NEMDecryptedMessage" });
    exports2.RippleGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "RippleGetAddress" });
    exports2.RippleAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    }, { $id: "RippleAddress" });
    exports2.RipplePayment = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      destination: schema_utils_1.Type.String(),
      destination_tag: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "RipplePayment" });
    exports2.RippleSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      fee: schema_utils_1.Type.Uint(),
      flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      sequence: schema_utils_1.Type.Number(),
      last_ledger_sequence: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment: exports2.RipplePayment,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "RippleSignTx" });
    exports2.RippleSignedTx = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      serialized_tx: schema_utils_1.Type.String()
    }, { $id: "RippleSignedTx" });
    exports2.SolanaGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "SolanaGetPublicKey" });
    exports2.SolanaPublicKey = schema_utils_1.Type.Object({
      public_key: schema_utils_1.Type.String()
    }, { $id: "SolanaPublicKey" });
    exports2.SolanaGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "SolanaGetAddress" });
    exports2.SolanaAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    }, { $id: "SolanaAddress" });
    exports2.SolanaTxTokenAccountInfo = schema_utils_1.Type.Object({
      base_address: schema_utils_1.Type.String(),
      token_program: schema_utils_1.Type.String(),
      token_mint: schema_utils_1.Type.String(),
      token_account: schema_utils_1.Type.String()
    }, { $id: "SolanaTxTokenAccountInfo" });
    exports2.SolanaTxAdditionalInfo = schema_utils_1.Type.Object({
      token_accounts_infos: schema_utils_1.Type.Array(exports2.SolanaTxTokenAccountInfo)
    }, { $id: "SolanaTxAdditionalInfo" });
    exports2.SolanaSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      serialized_tx: schema_utils_1.Type.String(),
      additional_info: schema_utils_1.Type.Optional(exports2.SolanaTxAdditionalInfo)
    }, { $id: "SolanaSignTx" });
    exports2.SolanaTxSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String()
    }, { $id: "SolanaTxSignature" });
    var StellarAssetType;
    (function(StellarAssetType2) {
      StellarAssetType2[StellarAssetType2["NATIVE"] = 0] = "NATIVE";
      StellarAssetType2[StellarAssetType2["ALPHANUM4"] = 1] = "ALPHANUM4";
      StellarAssetType2[StellarAssetType2["ALPHANUM12"] = 2] = "ALPHANUM12";
    })(StellarAssetType || (exports2.StellarAssetType = StellarAssetType = {}));
    exports2.EnumStellarAssetType = schema_utils_1.Type.Enum(StellarAssetType);
    exports2.StellarAsset = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Union([
        schema_utils_1.Type.Literal(0),
        schema_utils_1.Type.Literal(1),
        schema_utils_1.Type.Literal(2),
        schema_utils_1.Type.Literal("NATIVE"),
        schema_utils_1.Type.Literal("ALPHANUM4"),
        schema_utils_1.Type.Literal("ALPHANUM12")
      ]),
      code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      issuer: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "StellarAsset" });
    exports2.StellarGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "StellarGetAddress" });
    exports2.StellarAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    }, { $id: "StellarAddress" });
    var StellarMemoType;
    (function(StellarMemoType2) {
      StellarMemoType2[StellarMemoType2["NONE"] = 0] = "NONE";
      StellarMemoType2[StellarMemoType2["TEXT"] = 1] = "TEXT";
      StellarMemoType2[StellarMemoType2["ID"] = 2] = "ID";
      StellarMemoType2[StellarMemoType2["HASH"] = 3] = "HASH";
      StellarMemoType2[StellarMemoType2["RETURN"] = 4] = "RETURN";
    })(StellarMemoType || (exports2.StellarMemoType = StellarMemoType = {}));
    exports2.EnumStellarMemoType = schema_utils_1.Type.Enum(StellarMemoType);
    exports2.StellarSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network_passphrase: schema_utils_1.Type.String(),
      source_account: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Uint(),
      sequence_number: schema_utils_1.Type.Uint(),
      timebounds_start: schema_utils_1.Type.Number(),
      timebounds_end: schema_utils_1.Type.Number(),
      memo_type: exports2.EnumStellarMemoType,
      memo_text: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      memo_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      memo_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.String()])),
      num_operations: schema_utils_1.Type.Number()
    }, { $id: "StellarSignTx" });
    exports2.StellarTxOpRequest = schema_utils_1.Type.Object({}, { $id: "StellarTxOpRequest" });
    exports2.StellarPaymentOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination_account: schema_utils_1.Type.String(),
      asset: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint()
    }, { $id: "StellarPaymentOp" });
    exports2.StellarCreateAccountOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      new_account: schema_utils_1.Type.String(),
      starting_balance: schema_utils_1.Type.Uint()
    }, { $id: "StellarCreateAccountOp" });
    exports2.StellarPathPaymentStrictReceiveOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      send_asset: exports2.StellarAsset,
      send_max: schema_utils_1.Type.Uint(),
      destination_account: schema_utils_1.Type.String(),
      destination_asset: exports2.StellarAsset,
      destination_amount: schema_utils_1.Type.Uint(),
      paths: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.StellarAsset))
    }, { $id: "StellarPathPaymentStrictReceiveOp" });
    exports2.StellarPathPaymentStrictSendOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      send_asset: exports2.StellarAsset,
      send_amount: schema_utils_1.Type.Uint(),
      destination_account: schema_utils_1.Type.String(),
      destination_asset: exports2.StellarAsset,
      destination_min: schema_utils_1.Type.Uint(),
      paths: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.StellarAsset))
    }, { $id: "StellarPathPaymentStrictSendOp" });
    exports2.StellarManageSellOfferOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      selling_asset: exports2.StellarAsset,
      buying_asset: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price_n: schema_utils_1.Type.Number(),
      price_d: schema_utils_1.Type.Number(),
      offer_id: schema_utils_1.Type.Uint()
    }, { $id: "StellarManageSellOfferOp" });
    exports2.StellarManageBuyOfferOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      selling_asset: exports2.StellarAsset,
      buying_asset: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price_n: schema_utils_1.Type.Number(),
      price_d: schema_utils_1.Type.Number(),
      offer_id: schema_utils_1.Type.Uint()
    }, { $id: "StellarManageBuyOfferOp" });
    exports2.StellarCreatePassiveSellOfferOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      selling_asset: exports2.StellarAsset,
      buying_asset: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price_n: schema_utils_1.Type.Number(),
      price_d: schema_utils_1.Type.Number()
    }, { $id: "StellarCreatePassiveSellOfferOp" });
    var StellarSignerType;
    (function(StellarSignerType2) {
      StellarSignerType2[StellarSignerType2["ACCOUNT"] = 0] = "ACCOUNT";
      StellarSignerType2[StellarSignerType2["PRE_AUTH"] = 1] = "PRE_AUTH";
      StellarSignerType2[StellarSignerType2["HASH"] = 2] = "HASH";
    })(StellarSignerType || (exports2.StellarSignerType = StellarSignerType = {}));
    exports2.EnumStellarSignerType = schema_utils_1.Type.Enum(StellarSignerType);
    exports2.StellarSetOptionsOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      inflation_destination_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      clear_flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      set_flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      master_weight: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      low_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      medium_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      high_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      home_domain: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signer_type: schema_utils_1.Type.Optional(exports2.EnumStellarSignerType),
      signer_key: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.String()])),
      signer_weight: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "StellarSetOptionsOp" });
    exports2.StellarChangeTrustOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      asset: exports2.StellarAsset,
      limit: schema_utils_1.Type.Uint()
    }, { $id: "StellarChangeTrustOp" });
    exports2.StellarAllowTrustOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      trusted_account: schema_utils_1.Type.String(),
      asset_type: exports2.EnumStellarAssetType,
      asset_code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      is_authorized: schema_utils_1.Type.Boolean()
    }, { $id: "StellarAllowTrustOp" });
    exports2.StellarAccountMergeOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination_account: schema_utils_1.Type.String()
    }, { $id: "StellarAccountMergeOp" });
    exports2.StellarManageDataOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.String()]))
    }, { $id: "StellarManageDataOp" });
    exports2.StellarBumpSequenceOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      bump_to: schema_utils_1.Type.Uint()
    }, { $id: "StellarBumpSequenceOp" });
    exports2.StellarClaimClaimableBalanceOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      balance_id: schema_utils_1.Type.String()
    }, { $id: "StellarClaimClaimableBalanceOp" });
    exports2.StellarSignedTx = schema_utils_1.Type.Object({
      public_key: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "StellarSignedTx" });
    exports2.TezosGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "TezosGetAddress" });
    exports2.TezosAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    }, { $id: "TezosAddress" });
    exports2.TezosGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "TezosGetPublicKey" });
    exports2.TezosPublicKey = schema_utils_1.Type.Object({
      public_key: schema_utils_1.Type.String()
    }, { $id: "TezosPublicKey" });
    var TezosContractType;
    (function(TezosContractType2) {
      TezosContractType2[TezosContractType2["Implicit"] = 0] = "Implicit";
      TezosContractType2[TezosContractType2["Originated"] = 1] = "Originated";
    })(TezosContractType || (exports2.TezosContractType = TezosContractType = {}));
    exports2.EnumTezosContractType = schema_utils_1.Type.Enum(TezosContractType);
    exports2.TezosContractID = schema_utils_1.Type.Object({
      tag: schema_utils_1.Type.Number(),
      hash: schema_utils_1.Type.Uint8Array()
    }, { $id: "TezosContractID" });
    exports2.TezosRevealOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      public_key: schema_utils_1.Type.Uint8Array()
    }, { $id: "TezosRevealOp" });
    exports2.TezosManagerTransfer = schema_utils_1.Type.Object({
      destination: exports2.TezosContractID,
      amount: schema_utils_1.Type.Uint()
    }, { $id: "TezosManagerTransfer" });
    exports2.TezosParametersManager = schema_utils_1.Type.Object({
      set_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint8Array()),
      cancel_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      transfer: schema_utils_1.Type.Optional(exports2.TezosManagerTransfer)
    }, { $id: "TezosParametersManager" });
    exports2.TezosTransactionOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      amount: schema_utils_1.Type.Uint(),
      destination: exports2.TezosContractID,
      parameters: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      parameters_manager: schema_utils_1.Type.Optional(exports2.TezosParametersManager)
    }, { $id: "TezosTransactionOp" });
    exports2.TezosOriginationOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      manager_pubkey: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      balance: schema_utils_1.Type.Number(),
      spendable: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      delegatable: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint8Array()),
      script: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Array(schema_utils_1.Type.Number())])
    }, { $id: "TezosOriginationOp" });
    exports2.TezosDelegationOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      delegate: schema_utils_1.Type.Uint8Array()
    }, { $id: "TezosDelegationOp" });
    exports2.TezosProposalOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      period: schema_utils_1.Type.Number(),
      proposals: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    }, { $id: "TezosProposalOp" });
    var TezosBallotType;
    (function(TezosBallotType2) {
      TezosBallotType2[TezosBallotType2["Yay"] = 0] = "Yay";
      TezosBallotType2[TezosBallotType2["Nay"] = 1] = "Nay";
      TezosBallotType2[TezosBallotType2["Pass"] = 2] = "Pass";
    })(TezosBallotType || (exports2.TezosBallotType = TezosBallotType = {}));
    exports2.EnumTezosBallotType = schema_utils_1.Type.Enum(TezosBallotType);
    exports2.TezosBallotOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      period: schema_utils_1.Type.Number(),
      proposal: schema_utils_1.Type.String(),
      ballot: exports2.EnumTezosBallotType
    }, { $id: "TezosBallotOp" });
    exports2.TezosSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      branch: schema_utils_1.Type.Uint8Array(),
      reveal: schema_utils_1.Type.Optional(exports2.TezosRevealOp),
      transaction: schema_utils_1.Type.Optional(exports2.TezosTransactionOp),
      origination: schema_utils_1.Type.Optional(exports2.TezosOriginationOp),
      delegation: schema_utils_1.Type.Optional(exports2.TezosDelegationOp),
      proposal: schema_utils_1.Type.Optional(exports2.TezosProposalOp),
      ballot: schema_utils_1.Type.Optional(exports2.TezosBallotOp),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "TezosSignTx" });
    exports2.TezosSignedTx = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      sig_op_contents: schema_utils_1.Type.String(),
      operation_hash: schema_utils_1.Type.String()
    }, { $id: "TezosSignedTx" });
    exports2.experimental_message = schema_utils_1.Type.Object({}, { $id: "experimental_message" });
    exports2.experimental_field = schema_utils_1.Type.Object({}, { $id: "experimental_field" });
    exports2.MessageType = schema_utils_1.Type.Object({
      BinanceGetAddress: exports2.BinanceGetAddress,
      BinanceAddress: exports2.BinanceAddress,
      BinanceGetPublicKey: exports2.BinanceGetPublicKey,
      BinancePublicKey: exports2.BinancePublicKey,
      BinanceSignTx: exports2.BinanceSignTx,
      BinanceTxRequest: exports2.BinanceTxRequest,
      BinanceCoin: exports2.BinanceCoin,
      BinanceInputOutput: exports2.BinanceInputOutput,
      BinanceTransferMsg: exports2.BinanceTransferMsg,
      BinanceOrderMsg: exports2.BinanceOrderMsg,
      BinanceCancelMsg: exports2.BinanceCancelMsg,
      BinanceSignedTx: exports2.BinanceSignedTx,
      HDNodeType: exports2.HDNodeType,
      HDNodePathType: exports2.HDNodePathType,
      MultisigRedeemScriptType: exports2.MultisigRedeemScriptType,
      GetPublicKey: exports2.GetPublicKey,
      PublicKey: exports2.PublicKey,
      GetAddress: exports2.GetAddress,
      Address: exports2.Address,
      GetOwnershipId: exports2.GetOwnershipId,
      OwnershipId: exports2.OwnershipId,
      SignMessage: exports2.SignMessage,
      MessageSignature: exports2.MessageSignature,
      VerifyMessage: exports2.VerifyMessage,
      CoinJoinRequest: exports2.CoinJoinRequest,
      SignTx: exports2.SignTx,
      TxRequestDetailsType: exports2.TxRequestDetailsType,
      TxRequestSerializedType: exports2.TxRequestSerializedType,
      TxRequest: exports2.TxRequest,
      TxInputType: exports2.TxInputType,
      TxOutputBinType: exports2.TxOutputBinType,
      TxOutputType: exports2.TxOutputType,
      PrevTx: exports2.PrevTx,
      PrevInput: exports2.PrevInput,
      PrevOutput: exports2.PrevOutput,
      TextMemo: exports2.TextMemo,
      RefundMemo: exports2.RefundMemo,
      CoinPurchaseMemo: exports2.CoinPurchaseMemo,
      PaymentRequestMemo: exports2.PaymentRequestMemo,
      TxAckPaymentRequest: exports2.TxAckPaymentRequest,
      TxAck: exports2.TxAck,
      TxAckInputWrapper: exports2.TxAckInputWrapper,
      TxAckInput: exports2.TxAckInput,
      TxAckOutputWrapper: exports2.TxAckOutputWrapper,
      TxAckOutput: exports2.TxAckOutput,
      TxAckPrevMeta: exports2.TxAckPrevMeta,
      TxAckPrevInputWrapper: exports2.TxAckPrevInputWrapper,
      TxAckPrevInput: exports2.TxAckPrevInput,
      TxAckPrevOutputWrapper: exports2.TxAckPrevOutputWrapper,
      TxAckPrevOutput: exports2.TxAckPrevOutput,
      TxAckPrevExtraDataWrapper: exports2.TxAckPrevExtraDataWrapper,
      TxAckPrevExtraData: exports2.TxAckPrevExtraData,
      GetOwnershipProof: exports2.GetOwnershipProof,
      OwnershipProof: exports2.OwnershipProof,
      AuthorizeCoinJoin: exports2.AuthorizeCoinJoin,
      FirmwareErase: exports2.FirmwareErase,
      FirmwareRequest: exports2.FirmwareRequest,
      FirmwareUpload: exports2.FirmwareUpload,
      ProdTestT1: exports2.ProdTestT1,
      CardanoBlockchainPointerType: exports2.CardanoBlockchainPointerType,
      CardanoNativeScript: exports2.CardanoNativeScript,
      CardanoGetNativeScriptHash: exports2.CardanoGetNativeScriptHash,
      CardanoNativeScriptHash: exports2.CardanoNativeScriptHash,
      CardanoAddressParametersType: exports2.CardanoAddressParametersType,
      CardanoGetAddress: exports2.CardanoGetAddress,
      CardanoAddress: exports2.CardanoAddress,
      CardanoGetPublicKey: exports2.CardanoGetPublicKey,
      CardanoPublicKey: exports2.CardanoPublicKey,
      CardanoSignTxInit: exports2.CardanoSignTxInit,
      CardanoTxInput: exports2.CardanoTxInput,
      CardanoTxOutput: exports2.CardanoTxOutput,
      CardanoAssetGroup: exports2.CardanoAssetGroup,
      CardanoToken: exports2.CardanoToken,
      CardanoTxInlineDatumChunk: exports2.CardanoTxInlineDatumChunk,
      CardanoTxReferenceScriptChunk: exports2.CardanoTxReferenceScriptChunk,
      CardanoPoolOwner: exports2.CardanoPoolOwner,
      CardanoPoolRelayParameters: exports2.CardanoPoolRelayParameters,
      CardanoPoolMetadataType: exports2.CardanoPoolMetadataType,
      CardanoPoolParametersType: exports2.CardanoPoolParametersType,
      CardanoDRep: exports2.CardanoDRep,
      CardanoTxCertificate: exports2.CardanoTxCertificate,
      CardanoTxWithdrawal: exports2.CardanoTxWithdrawal,
      CardanoCVoteRegistrationDelegation: exports2.CardanoCVoteRegistrationDelegation,
      CardanoCVoteRegistrationParametersType: exports2.CardanoCVoteRegistrationParametersType,
      CardanoTxAuxiliaryData: exports2.CardanoTxAuxiliaryData,
      CardanoTxMint: exports2.CardanoTxMint,
      CardanoTxCollateralInput: exports2.CardanoTxCollateralInput,
      CardanoTxRequiredSigner: exports2.CardanoTxRequiredSigner,
      CardanoTxReferenceInput: exports2.CardanoTxReferenceInput,
      CardanoTxItemAck: exports2.CardanoTxItemAck,
      CardanoTxAuxiliaryDataSupplement: exports2.CardanoTxAuxiliaryDataSupplement,
      CardanoTxWitnessRequest: exports2.CardanoTxWitnessRequest,
      CardanoTxWitnessResponse: exports2.CardanoTxWitnessResponse,
      CardanoTxHostAck: exports2.CardanoTxHostAck,
      CardanoTxBodyHash: exports2.CardanoTxBodyHash,
      CardanoSignTxFinished: exports2.CardanoSignTxFinished,
      Success: exports2.Success,
      Failure: exports2.Failure,
      ButtonRequest: exports2.ButtonRequest,
      ButtonAck: exports2.ButtonAck,
      PinMatrixRequest: exports2.PinMatrixRequest,
      PinMatrixAck: exports2.PinMatrixAck,
      PassphraseRequest: exports2.PassphraseRequest,
      PassphraseAck: exports2.PassphraseAck,
      Deprecated_PassphraseStateRequest: exports2.Deprecated_PassphraseStateRequest,
      Deprecated_PassphraseStateAck: exports2.Deprecated_PassphraseStateAck,
      CipherKeyValue: exports2.CipherKeyValue,
      CipheredKeyValue: exports2.CipheredKeyValue,
      IdentityType: exports2.IdentityType,
      SignIdentity: exports2.SignIdentity,
      SignedIdentity: exports2.SignedIdentity,
      GetECDHSessionKey: exports2.GetECDHSessionKey,
      ECDHSessionKey: exports2.ECDHSessionKey,
      DebugLinkResetDebugEvents: exports2.DebugLinkResetDebugEvents,
      EosGetPublicKey: exports2.EosGetPublicKey,
      EosPublicKey: exports2.EosPublicKey,
      EosTxHeader: exports2.EosTxHeader,
      EosSignTx: exports2.EosSignTx,
      EosTxActionRequest: exports2.EosTxActionRequest,
      EosAsset: exports2.EosAsset,
      EosPermissionLevel: exports2.EosPermissionLevel,
      EosAuthorizationKey: exports2.EosAuthorizationKey,
      EosAuthorizationAccount: exports2.EosAuthorizationAccount,
      EosAuthorizationWait: exports2.EosAuthorizationWait,
      EosAuthorization: exports2.EosAuthorization,
      EosActionCommon: exports2.EosActionCommon,
      EosActionTransfer: exports2.EosActionTransfer,
      EosActionDelegate: exports2.EosActionDelegate,
      EosActionUndelegate: exports2.EosActionUndelegate,
      EosActionRefund: exports2.EosActionRefund,
      EosActionBuyRam: exports2.EosActionBuyRam,
      EosActionBuyRamBytes: exports2.EosActionBuyRamBytes,
      EosActionSellRam: exports2.EosActionSellRam,
      EosActionVoteProducer: exports2.EosActionVoteProducer,
      EosActionUpdateAuth: exports2.EosActionUpdateAuth,
      EosActionDeleteAuth: exports2.EosActionDeleteAuth,
      EosActionLinkAuth: exports2.EosActionLinkAuth,
      EosActionUnlinkAuth: exports2.EosActionUnlinkAuth,
      EosActionNewAccount: exports2.EosActionNewAccount,
      EosActionUnknown: exports2.EosActionUnknown,
      EosTxActionAck: exports2.EosTxActionAck,
      EosSignedTx: exports2.EosSignedTx,
      EthereumNetworkInfo: exports2.EthereumNetworkInfo,
      EthereumTokenInfo: exports2.EthereumTokenInfo,
      EthereumDefinitions: exports2.EthereumDefinitions,
      EthereumSignTypedData: exports2.EthereumSignTypedData,
      EthereumTypedDataStructRequest: exports2.EthereumTypedDataStructRequest,
      EthereumFieldType: exports2.EthereumFieldType,
      EthereumStructMember: exports2.EthereumStructMember,
      EthereumTypedDataStructAck: exports2.EthereumTypedDataStructAck,
      EthereumTypedDataValueRequest: exports2.EthereumTypedDataValueRequest,
      EthereumTypedDataValueAck: exports2.EthereumTypedDataValueAck,
      EthereumGetPublicKey: exports2.EthereumGetPublicKey,
      EthereumPublicKey: exports2.EthereumPublicKey,
      EthereumGetAddress: exports2.EthereumGetAddress,
      EthereumAddress: exports2.EthereumAddress,
      EthereumSignTx: exports2.EthereumSignTx,
      EthereumAccessList: exports2.EthereumAccessList,
      EthereumSignTxEIP1559: exports2.EthereumSignTxEIP1559,
      EthereumTxRequest: exports2.EthereumTxRequest,
      EthereumTxAck: exports2.EthereumTxAck,
      EthereumSignMessage: exports2.EthereumSignMessage,
      EthereumMessageSignature: exports2.EthereumMessageSignature,
      EthereumVerifyMessage: exports2.EthereumVerifyMessage,
      EthereumSignTypedHash: exports2.EthereumSignTypedHash,
      EthereumTypedDataSignature: exports2.EthereumTypedDataSignature,
      Initialize: exports2.Initialize,
      GetFeatures: exports2.GetFeatures,
      RecoveryDevice: exports2.RecoveryDevice,
      Features: exports2.Features,
      LockDevice: exports2.LockDevice,
      SetBusy: exports2.SetBusy,
      EndSession: exports2.EndSession,
      ApplySettings: exports2.ApplySettings,
      ChangeLanguage: exports2.ChangeLanguage,
      TranslationDataRequest: exports2.TranslationDataRequest,
      TranslationDataAck: exports2.TranslationDataAck,
      ApplyFlags: exports2.ApplyFlags,
      ChangePin: exports2.ChangePin,
      ChangeWipeCode: exports2.ChangeWipeCode,
      SdProtect: exports2.SdProtect,
      Ping: exports2.Ping,
      Cancel: exports2.Cancel,
      GetEntropy: exports2.GetEntropy,
      Entropy: exports2.Entropy,
      GetFirmwareHash: exports2.GetFirmwareHash,
      FirmwareHash: exports2.FirmwareHash,
      AuthenticateDevice: exports2.AuthenticateDevice,
      AuthenticityProof: exports2.AuthenticityProof,
      WipeDevice: exports2.WipeDevice,
      ResetDevice: exports2.ResetDevice,
      Slip39Group: exports2.Slip39Group,
      BackupDevice: exports2.BackupDevice,
      EntropyRequest: exports2.EntropyRequest,
      EntropyAck: exports2.EntropyAck,
      WordRequest: exports2.WordRequest,
      WordAck: exports2.WordAck,
      SetU2FCounter: exports2.SetU2FCounter,
      GetNextU2FCounter: exports2.GetNextU2FCounter,
      NextU2FCounter: exports2.NextU2FCounter,
      DoPreauthorized: exports2.DoPreauthorized,
      PreauthorizedRequest: exports2.PreauthorizedRequest,
      CancelAuthorization: exports2.CancelAuthorization,
      RebootToBootloader: exports2.RebootToBootloader,
      GetNonce: exports2.GetNonce,
      Nonce: exports2.Nonce,
      UnlockPath: exports2.UnlockPath,
      UnlockedPathRequest: exports2.UnlockedPathRequest,
      ShowDeviceTutorial: exports2.ShowDeviceTutorial,
      UnlockBootloader: exports2.UnlockBootloader,
      SetBrightness: exports2.SetBrightness,
      NEMGetAddress: exports2.NEMGetAddress,
      NEMAddress: exports2.NEMAddress,
      NEMTransactionCommon: exports2.NEMTransactionCommon,
      NEMMosaic: exports2.NEMMosaic,
      NEMTransfer: exports2.NEMTransfer,
      NEMProvisionNamespace: exports2.NEMProvisionNamespace,
      NEMMosaicDefinition: exports2.NEMMosaicDefinition,
      NEMMosaicCreation: exports2.NEMMosaicCreation,
      NEMMosaicSupplyChange: exports2.NEMMosaicSupplyChange,
      NEMCosignatoryModification: exports2.NEMCosignatoryModification,
      NEMAggregateModification: exports2.NEMAggregateModification,
      NEMImportanceTransfer: exports2.NEMImportanceTransfer,
      NEMSignTx: exports2.NEMSignTx,
      NEMSignedTx: exports2.NEMSignedTx,
      NEMDecryptMessage: exports2.NEMDecryptMessage,
      NEMDecryptedMessage: exports2.NEMDecryptedMessage,
      RippleGetAddress: exports2.RippleGetAddress,
      RippleAddress: exports2.RippleAddress,
      RipplePayment: exports2.RipplePayment,
      RippleSignTx: exports2.RippleSignTx,
      RippleSignedTx: exports2.RippleSignedTx,
      SolanaGetPublicKey: exports2.SolanaGetPublicKey,
      SolanaPublicKey: exports2.SolanaPublicKey,
      SolanaGetAddress: exports2.SolanaGetAddress,
      SolanaAddress: exports2.SolanaAddress,
      SolanaTxTokenAccountInfo: exports2.SolanaTxTokenAccountInfo,
      SolanaTxAdditionalInfo: exports2.SolanaTxAdditionalInfo,
      SolanaSignTx: exports2.SolanaSignTx,
      SolanaTxSignature: exports2.SolanaTxSignature,
      StellarAsset: exports2.StellarAsset,
      StellarGetAddress: exports2.StellarGetAddress,
      StellarAddress: exports2.StellarAddress,
      StellarSignTx: exports2.StellarSignTx,
      StellarTxOpRequest: exports2.StellarTxOpRequest,
      StellarPaymentOp: exports2.StellarPaymentOp,
      StellarCreateAccountOp: exports2.StellarCreateAccountOp,
      StellarPathPaymentStrictReceiveOp: exports2.StellarPathPaymentStrictReceiveOp,
      StellarPathPaymentStrictSendOp: exports2.StellarPathPaymentStrictSendOp,
      StellarManageSellOfferOp: exports2.StellarManageSellOfferOp,
      StellarManageBuyOfferOp: exports2.StellarManageBuyOfferOp,
      StellarCreatePassiveSellOfferOp: exports2.StellarCreatePassiveSellOfferOp,
      StellarSetOptionsOp: exports2.StellarSetOptionsOp,
      StellarChangeTrustOp: exports2.StellarChangeTrustOp,
      StellarAllowTrustOp: exports2.StellarAllowTrustOp,
      StellarAccountMergeOp: exports2.StellarAccountMergeOp,
      StellarManageDataOp: exports2.StellarManageDataOp,
      StellarBumpSequenceOp: exports2.StellarBumpSequenceOp,
      StellarClaimClaimableBalanceOp: exports2.StellarClaimClaimableBalanceOp,
      StellarSignedTx: exports2.StellarSignedTx,
      TezosGetAddress: exports2.TezosGetAddress,
      TezosAddress: exports2.TezosAddress,
      TezosGetPublicKey: exports2.TezosGetPublicKey,
      TezosPublicKey: exports2.TezosPublicKey,
      TezosContractID: exports2.TezosContractID,
      TezosRevealOp: exports2.TezosRevealOp,
      TezosManagerTransfer: exports2.TezosManagerTransfer,
      TezosParametersManager: exports2.TezosParametersManager,
      TezosTransactionOp: exports2.TezosTransactionOp,
      TezosOriginationOp: exports2.TezosOriginationOp,
      TezosDelegationOp: exports2.TezosDelegationOp,
      TezosProposalOp: exports2.TezosProposalOp,
      TezosBallotOp: exports2.TezosBallotOp,
      TezosSignTx: exports2.TezosSignTx,
      TezosSignedTx: exports2.TezosSignedTx,
      experimental_message: exports2.experimental_message,
      experimental_field: exports2.experimental_field
    }, { $id: "MessageType" });
  })(messagesSchema);
  return messagesSchema;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeviceModelInternal = exports2.MessagesSchema = exports2.createMessageFromType = exports2.createMessageFromName = exports2.parseConfigure = exports2.Messages = void 0;
    const tslib_12 = require$$0;
    tslib_12.__exportStar(requireDecode(), exports2);
    tslib_12.__exportStar(requireEncode(), exports2);
    exports2.Messages = tslib_12.__importStar(requireMessages());
    tslib_12.__exportStar(requireTypes$1(), exports2);
    var utils_12 = requireUtils();
    Object.defineProperty(exports2, "parseConfigure", { enumerable: true, get: function() {
      return utils_12.parseConfigure;
    } });
    Object.defineProperty(exports2, "createMessageFromName", { enumerable: true, get: function() {
      return utils_12.createMessageFromName;
    } });
    Object.defineProperty(exports2, "createMessageFromType", { enumerable: true, get: function() {
      return utils_12.createMessageFromType;
    } });
    exports2.MessagesSchema = tslib_12.__importStar(requireMessagesSchema());
    var messages_schema_1 = requireMessagesSchema();
    Object.defineProperty(exports2, "DeviceModelInternal", { enumerable: true, get: function() {
      return messages_schema_1.DeviceModelInternal;
    } });
  })(lib);
  return lib;
}
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PROTO = exports2.NEM = exports2.CARDANO = exports2.NETWORK = exports2.ERRORS = void 0;
    const tslib_12 = require$$0;
    exports2.ERRORS = tslib_12.__importStar(requireErrors$3());
    exports2.NETWORK = tslib_12.__importStar(requireNetwork());
    exports2.CARDANO = tslib_12.__importStar(requireCardano$1());
    exports2.NEM = tslib_12.__importStar(requireNem());
    var protobuf_1 = requireLib();
    Object.defineProperty(exports2, "PROTO", { enumerable: true, get: function() {
      return protobuf_1.MessagesSchema;
    } });
  })(constants);
  return constants;
}
var types = {};
var api = {};
var hasRequiredApi;
function requireApi() {
  if (hasRequiredApi) return api;
  hasRequiredApi = 1;
  Object.defineProperty(api, "__esModule", { value: true });
  return api;
}
var account = {};
var hasRequiredAccount;
function requireAccount() {
  if (hasRequiredAccount) return account;
  hasRequiredAccount = 1;
  Object.defineProperty(account, "__esModule", { value: true });
  return account;
}
var coinInfo = {};
var fees = {};
var hasRequiredFees;
function requireFees() {
  if (hasRequiredFees) return fees;
  hasRequiredFees = 1;
  Object.defineProperty(fees, "__esModule", { value: true });
  fees.SelectFeeLevel = fees.FeeLevel = fees.FeeInfo = void 0;
  const schema_utils_1 = requireLib$1();
  fees.FeeInfo = schema_utils_1.Type.Object({
    blockTime: schema_utils_1.Type.Number(),
    minFee: schema_utils_1.Type.Number(),
    maxFee: schema_utils_1.Type.Number(),
    dustLimit: schema_utils_1.Type.Number()
  });
  fees.FeeLevel = schema_utils_1.Type.Object({
    label: schema_utils_1.Type.Union([
      schema_utils_1.Type.Literal("high"),
      schema_utils_1.Type.Literal("normal"),
      schema_utils_1.Type.Literal("economy"),
      schema_utils_1.Type.Literal("low"),
      schema_utils_1.Type.Literal("custom")
    ]),
    feePerUnit: schema_utils_1.Type.String(),
    blocks: schema_utils_1.Type.Number(),
    feeLimit: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
    feePerTx: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
  });
  fees.SelectFeeLevel = schema_utils_1.Type.Union([
    schema_utils_1.Type.Object({
      name: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Literal("0"),
      feePerByte: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      disabled: schema_utils_1.Type.Literal(true)
    }),
    schema_utils_1.Type.Object({
      name: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.String(),
      feePerByte: schema_utils_1.Type.String(),
      minutes: schema_utils_1.Type.Number(),
      total: schema_utils_1.Type.String()
    })
  ]);
  return fees;
}
var device = {};
var hasRequiredDevice;
function requireDevice() {
  if (hasRequiredDevice) return device;
  hasRequiredDevice = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeviceModelInternal = exports2.FirmwareType = void 0;
    var FirmwareType;
    (function(FirmwareType2) {
      FirmwareType2["BitcoinOnly"] = "bitcoin-only";
      FirmwareType2["Regular"] = "regular";
    })(FirmwareType || (exports2.FirmwareType = FirmwareType = {}));
    var protobuf_1 = requireLib();
    Object.defineProperty(exports2, "DeviceModelInternal", { enumerable: true, get: function() {
      return protobuf_1.DeviceModelInternal;
    } });
  })(device);
  return device;
}
var hasRequiredCoinInfo;
function requireCoinInfo() {
  if (hasRequiredCoinInfo) return coinInfo;
  hasRequiredCoinInfo = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CoinInfo = exports2.MiscNetworkInfo = exports2.EthereumNetworkInfo = exports2.BitcoinNetworkInfo = exports2.BlockchainLink = exports2.CoinSupport = exports2.CoinObj = exports2.Network = exports2.Bip32 = void 0;
    const schema_utils_1 = requireLib$1();
    const fees_1 = requireFees();
    const device_1 = requireDevice();
    exports2.Bip32 = schema_utils_1.Type.Object({
      public: schema_utils_1.Type.Number(),
      private: schema_utils_1.Type.Number()
    });
    exports2.Network = schema_utils_1.Type.Object({
      messagePrefix: schema_utils_1.Type.String(),
      bech32: schema_utils_1.Type.String(),
      bip32: exports2.Bip32,
      pubKeyHash: schema_utils_1.Type.Number(),
      scriptHash: schema_utils_1.Type.Number(),
      wif: schema_utils_1.Type.Number(),
      forkId: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    });
    exports2.CoinObj = schema_utils_1.Type.Object({
      coin: schema_utils_1.Type.String(),
      identity: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CoinSupport = schema_utils_1.Type.Composite([
      schema_utils_1.Type.Object({
        connect: schema_utils_1.Type.Boolean()
      }),
      schema_utils_1.Type.Record(schema_utils_1.Type.KeyOfEnum(device_1.DeviceModelInternal), schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Literal(false)]))
    ]);
    exports2.BlockchainLink = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.String(),
      url: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    });
    const Common = schema_utils_1.Type.Object({
      label: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String(),
      shortcut: schema_utils_1.Type.String(),
      slip44: schema_utils_1.Type.Number(),
      support: exports2.CoinSupport,
      decimals: schema_utils_1.Type.Number(),
      blockchainLink: schema_utils_1.Type.Optional(exports2.BlockchainLink),
      blockTime: schema_utils_1.Type.Number(),
      minFee: schema_utils_1.Type.Number(),
      maxFee: schema_utils_1.Type.Number(),
      defaultFees: schema_utils_1.Type.Array(fees_1.FeeLevel)
    });
    exports2.BitcoinNetworkInfo = schema_utils_1.Type.Intersect([
      Common,
      schema_utils_1.Type.Object({
        type: schema_utils_1.Type.Literal("bitcoin"),
        cashAddrPrefix: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        curveName: schema_utils_1.Type.String(),
        dustLimit: schema_utils_1.Type.Number(),
        forceBip143: schema_utils_1.Type.Boolean(),
        hashGenesisBlock: schema_utils_1.Type.String(),
        maxAddressLength: schema_utils_1.Type.Number(),
        maxFeeSatoshiKb: schema_utils_1.Type.Number(),
        minAddressLength: schema_utils_1.Type.Number(),
        minFeeSatoshiKb: schema_utils_1.Type.Number(),
        segwit: schema_utils_1.Type.Boolean(),
        xPubMagic: schema_utils_1.Type.Number(),
        xPubMagicSegwitNative: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        xPubMagicSegwit: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        taproot: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
        network: exports2.Network,
        isBitcoin: schema_utils_1.Type.Boolean()
      })
    ]);
    exports2.EthereumNetworkInfo = schema_utils_1.Type.Intersect([
      Common,
      schema_utils_1.Type.Object({
        type: schema_utils_1.Type.Literal("ethereum"),
        chainId: schema_utils_1.Type.Number(),
        network: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined())
      })
    ]);
    exports2.MiscNetworkInfo = schema_utils_1.Type.Intersect([
      Common,
      schema_utils_1.Type.Object({
        type: schema_utils_1.Type.Union([schema_utils_1.Type.Literal("misc"), schema_utils_1.Type.Literal("nem")]),
        curve: schema_utils_1.Type.String(),
        network: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined())
      })
    ]);
    exports2.CoinInfo = schema_utils_1.Type.Union([exports2.BitcoinNetworkInfo, exports2.EthereumNetworkInfo, exports2.MiscNetworkInfo]);
  })(coinInfo);
  return coinInfo;
}
var firmware = {};
var hasRequiredFirmware;
function requireFirmware() {
  if (hasRequiredFirmware) return firmware;
  hasRequiredFirmware = 1;
  Object.defineProperty(firmware, "__esModule", { value: true });
  firmware.IntermediaryVersion = void 0;
  const schema_utils_1 = requireLib$1();
  firmware.IntermediaryVersion = schema_utils_1.Type.Union([schema_utils_1.Type.Literal(1), schema_utils_1.Type.Literal(2), schema_utils_1.Type.Literal(3)]);
  return firmware;
}
var params = {};
var hasRequiredParams;
function requireParams() {
  if (hasRequiredParams) return params;
  hasRequiredParams = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKey = exports2.GetPublicKey = exports2.GetAddress = exports2.DerivationPath = exports2.Bundle = void 0;
    const schema_utils_1 = requireLib$1();
    const Bundle = (type2) => schema_utils_1.Type.Object({ bundle: schema_utils_1.Type.Array(type2, { minItems: 1 }) });
    exports2.Bundle = Bundle;
    exports2.DerivationPath = schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Array(schema_utils_1.Type.Number())], {
      description: "Derivation Path (BIP32).",
      $id: "DerivationPath"
    });
    exports2.GetAddress = schema_utils_1.Type.Object({
      path: exports2.DerivationPath,
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      showOnTrezor: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean({ default: true })),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      useEventListener: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.GetPublicKey = schema_utils_1.Type.Object({
      path: exports2.DerivationPath,
      showOnTrezor: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      suppressBackupWarning: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.PublicKey = schema_utils_1.Type.Object({
      publicKey: schema_utils_1.Type.String(),
      path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      serializedPath: schema_utils_1.Type.String()
    });
  })(params);
  return params;
}
var settings = {};
var hasRequiredSettings;
function requireSettings() {
  if (hasRequiredSettings) return settings;
  hasRequiredSettings = 1;
  Object.defineProperty(settings, "__esModule", { value: true });
  return settings;
}
var cardano = {};
var hasRequiredCardano;
function requireCardano() {
  if (hasRequiredCardano) return cardano;
  hasRequiredCardano = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CardanoSignedTxData = exports2.CardanoAuxiliaryDataSupplement = exports2.CardanoSignedTxWitness = exports2.CardanoSignTransactionExtended = exports2.CardanoSignTransaction = exports2.CardanoAuxiliaryData = exports2.CardanoCVoteRegistrationParameters = exports2.CardanoCVoteRegistrationDelegation = exports2.CardanoReferenceInput = exports2.CardanoRequiredSigner = exports2.CardanoCollateralInput = exports2.CardanoMint = exports2.CardanoWithdrawal = exports2.CardanoCertificate = exports2.CardanoDRep = exports2.CardanoPoolParameters = exports2.CardanoPoolMargin = exports2.CardanoPoolMetadata = exports2.CardanoPoolRelay = exports2.CardanoPoolOwner = exports2.CardanoOutput = exports2.CardanoAssetGroup = exports2.CardanoToken = exports2.CardanoInput = exports2.CardanoGetPublicKey = exports2.CardanoNativeScriptHash = exports2.CardanoGetNativeScriptHash = exports2.CardanoNativeScript = exports2.CardanoGetAddress = exports2.CardanoAddressParameters = exports2.CardanoCertificatePointer = void 0;
    const schema_utils_1 = requireLib$1();
    const constants_12 = requireConstants();
    const params_1 = requireParams();
    exports2.CardanoCertificatePointer = schema_utils_1.Type.Object({
      blockIndex: schema_utils_1.Type.Number(),
      txIndex: schema_utils_1.Type.Number(),
      certificateIndex: schema_utils_1.Type.Number()
    });
    exports2.CardanoAddressParameters = schema_utils_1.Type.Object({
      addressType: constants_12.PROTO.EnumCardanoAddressType,
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      stakingPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      stakingKeyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      certificatePointer: schema_utils_1.Type.Optional(exports2.CardanoCertificatePointer),
      paymentScriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      stakingScriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoGetAddress = schema_utils_1.Type.Object({
      addressParameters: exports2.CardanoAddressParameters,
      protocolMagic: schema_utils_1.Type.Number(),
      networkId: schema_utils_1.Type.Number(),
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      showOnTrezor: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      derivationType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoDerivationType),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.CardanoNativeScript = schema_utils_1.Type.Recursive((This) => schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoNativeScriptType,
      scripts: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(This)),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      keyPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      requiredSignaturesCount: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      invalidBefore: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      invalidHereafter: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }));
    exports2.CardanoGetNativeScriptHash = schema_utils_1.Type.Object({
      script: exports2.CardanoNativeScript,
      displayFormat: constants_12.PROTO.EnumCardanoNativeScriptHashDisplayFormat,
      derivationType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoDerivationType)
    });
    exports2.CardanoNativeScriptHash = schema_utils_1.Type.Object({
      scriptHash: schema_utils_1.Type.String()
    });
    exports2.CardanoGetPublicKey = schema_utils_1.Type.Intersect([
      params_1.GetPublicKey,
      schema_utils_1.Type.Object({
        derivationType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoDerivationType)
      })
    ]);
    exports2.CardanoInput = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    });
    exports2.CardanoToken = schema_utils_1.Type.Object({
      assetNameBytes: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      mintAmount: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoAssetGroup = schema_utils_1.Type.Object({
      policyId: schema_utils_1.Type.String(),
      tokenAmounts: schema_utils_1.Type.Array(exports2.CardanoToken)
    });
    exports2.CardanoOutput = schema_utils_1.Type.Intersect([
      schema_utils_1.Type.Union([
        schema_utils_1.Type.Object({
          addressParameters: exports2.CardanoAddressParameters
        }),
        schema_utils_1.Type.Object({
          address: schema_utils_1.Type.String()
        })
      ]),
      schema_utils_1.Type.Object({
        amount: schema_utils_1.Type.String(),
        tokenBundle: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoAssetGroup)),
        datumHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        format: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoTxOutputSerializationFormat),
        inlineDatum: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        referenceScript: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
      })
    ]);
    exports2.CardanoPoolOwner = schema_utils_1.Type.Object({
      stakingKeyPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      stakingKeyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoPoolRelay = schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoPoolRelayType,
      ipv4Address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ipv6Address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      port: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      hostName: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoPoolMetadata = schema_utils_1.Type.Object({
      url: schema_utils_1.Type.String(),
      hash: schema_utils_1.Type.String()
    });
    exports2.CardanoPoolMargin = schema_utils_1.Type.Object({
      numerator: schema_utils_1.Type.String(),
      denominator: schema_utils_1.Type.String()
    });
    exports2.CardanoPoolParameters = schema_utils_1.Type.Object({
      poolId: schema_utils_1.Type.String(),
      vrfKeyHash: schema_utils_1.Type.String(),
      pledge: schema_utils_1.Type.String(),
      cost: schema_utils_1.Type.String(),
      margin: exports2.CardanoPoolMargin,
      rewardAccount: schema_utils_1.Type.String(),
      owners: schema_utils_1.Type.Array(exports2.CardanoPoolOwner, { minItems: 1 }),
      relays: schema_utils_1.Type.Array(exports2.CardanoPoolRelay),
      metadata: schema_utils_1.Type.Optional(exports2.CardanoPoolMetadata)
    });
    exports2.CardanoDRep = schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoDRepType,
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      scriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoCertificate = schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoCertificateType,
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      pool: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      poolParameters: schema_utils_1.Type.Optional(exports2.CardanoPoolParameters),
      scriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      deposit: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      dRep: schema_utils_1.Type.Optional(exports2.CardanoDRep)
    });
    exports2.CardanoWithdrawal = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      amount: schema_utils_1.Type.String(),
      scriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoMint = schema_utils_1.Type.Array(exports2.CardanoAssetGroup);
    exports2.CardanoCollateralInput = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    });
    exports2.CardanoRequiredSigner = schema_utils_1.Type.Object({
      keyPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoReferenceInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    });
    exports2.CardanoCVoteRegistrationDelegation = schema_utils_1.Type.Object({
      votePublicKey: schema_utils_1.Type.String(),
      weight: schema_utils_1.Type.Number()
    });
    exports2.CardanoCVoteRegistrationParameters = schema_utils_1.Type.Object({
      votePublicKey: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      stakingPath: params_1.DerivationPath,
      paymentAddressParameters: schema_utils_1.Type.Optional(exports2.CardanoAddressParameters),
      nonce: schema_utils_1.Type.String(),
      format: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoCVoteRegistrationFormat),
      delegations: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoCVoteRegistrationDelegation)),
      votingPurpose: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      paymentAddress: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoAuxiliaryData = schema_utils_1.Type.Object({
      hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      cVoteRegistrationParameters: schema_utils_1.Type.Optional(exports2.CardanoCVoteRegistrationParameters)
    });
    exports2.CardanoSignTransaction = schema_utils_1.Type.Object({
      inputs: schema_utils_1.Type.Array(exports2.CardanoInput),
      outputs: schema_utils_1.Type.Array(exports2.CardanoOutput),
      fee: schema_utils_1.Type.Uint(),
      ttl: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      certificates: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoCertificate)),
      withdrawals: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoWithdrawal)),
      validityIntervalStart: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      auxiliaryData: schema_utils_1.Type.Optional(exports2.CardanoAuxiliaryData),
      mint: schema_utils_1.Type.Optional(exports2.CardanoMint),
      scriptDataHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      collateralInputs: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoCollateralInput)),
      requiredSigners: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoRequiredSigner)),
      collateralReturn: schema_utils_1.Type.Optional(exports2.CardanoOutput),
      totalCollateral: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      referenceInputs: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoReferenceInput)),
      additionalWitnessRequests: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(params_1.DerivationPath)),
      protocolMagic: schema_utils_1.Type.Number(),
      networkId: schema_utils_1.Type.Number(),
      signingMode: constants_12.PROTO.EnumCardanoTxSigningMode,
      derivationType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoDerivationType),
      includeNetworkId: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      tagCborSets: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.CardanoSignTransactionExtended = schema_utils_1.Type.Intersect([
      exports2.CardanoSignTransaction,
      schema_utils_1.Type.Object({
        unsignedTx: schema_utils_1.Type.Object({
          body: schema_utils_1.Type.String(),
          hash: schema_utils_1.Type.String()
        }),
        testnet: schema_utils_1.Type.Boolean()
      })
    ]);
    exports2.CardanoSignedTxWitness = schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoTxWitnessType,
      pubKey: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      chainCode: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoAuxiliaryDataSupplement = schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoTxAuxiliaryDataSupplementType,
      auxiliaryDataHash: schema_utils_1.Type.String(),
      cVoteRegistrationSignature: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoSignedTxData = schema_utils_1.Type.Object({
      hash: schema_utils_1.Type.String(),
      witnesses: schema_utils_1.Type.Array(exports2.CardanoSignedTxWitness),
      auxiliaryDataSupplement: schema_utils_1.Type.Optional(exports2.CardanoAuxiliaryDataSupplement)
    });
  })(cardano);
  return cardano;
}
var binance = {};
var hasRequiredBinance;
function requireBinance() {
  if (hasRequiredBinance) return binance;
  hasRequiredBinance = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BinanceSignTransaction = exports2.BinancePreparedTransaction = exports2.BinancePreparedMessage = exports2.BinanceSDKTransaction = void 0;
    const constants_12 = requireConstants();
    const params_1 = requireParams();
    const schema_utils_1 = requireLib$1();
    exports2.BinanceSDKTransaction = schema_utils_1.Type.Object({
      chain_id: schema_utils_1.Type.String(),
      account_number: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      memo: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sequence: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      transfer: schema_utils_1.Type.Optional(constants_12.PROTO.BinanceTransferMsg),
      placeOrder: schema_utils_1.Type.Optional(constants_12.PROTO.BinanceOrderMsg),
      cancelOrder: schema_utils_1.Type.Optional(constants_12.PROTO.BinanceCancelMsg)
    });
    exports2.BinancePreparedMessage = schema_utils_1.Type.Union([
      schema_utils_1.Type.Intersect([
        constants_12.PROTO.BinanceTransferMsg,
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("BinanceTransferMsg")
        })
      ]),
      schema_utils_1.Type.Intersect([
        constants_12.PROTO.BinanceOrderMsg,
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("BinanceOrderMsg")
        })
      ]),
      schema_utils_1.Type.Intersect([
        constants_12.PROTO.BinanceCancelMsg,
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("BinanceCancelMsg")
        })
      ])
    ]);
    exports2.BinancePreparedTransaction = schema_utils_1.Type.Intersect([
      exports2.BinanceSDKTransaction,
      schema_utils_1.Type.Object({
        messages: schema_utils_1.Type.Array(exports2.BinancePreparedMessage),
        account_number: schema_utils_1.Type.Number(),
        sequence: schema_utils_1.Type.Number(),
        source: schema_utils_1.Type.Number()
      })
    ]);
    exports2.BinanceSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      transaction: exports2.BinanceSDKTransaction,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
  })(binance);
  return binance;
}
var bitcoin = {};
var hasRequiredBitcoin;
function requireBitcoin() {
  if (hasRequiredBitcoin) return bitcoin;
  hasRequiredBitcoin = 1;
  Object.defineProperty(bitcoin, "__esModule", { value: true });
  bitcoin.VerifyMessage = bitcoin.SignMessage = void 0;
  const params_1 = requireParams();
  const schema_utils_1 = requireLib$1();
  bitcoin.SignMessage = schema_utils_1.Type.Object({
    path: params_1.DerivationPath,
    coin: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
    message: schema_utils_1.Type.String(),
    hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
    no_script_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
  });
  bitcoin.VerifyMessage = schema_utils_1.Type.Object({
    address: schema_utils_1.Type.String(),
    signature: schema_utils_1.Type.String(),
    message: schema_utils_1.Type.String(),
    coin: schema_utils_1.Type.String(),
    hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
  });
  return bitcoin;
}
var eos = {};
var hasRequiredEos;
function requireEos() {
  if (hasRequiredEos) return eos;
  hasRequiredEos = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EosSignTransaction = exports2.EosSDKTransaction = exports2.EosTxAction = exports2.EosTxActionCommon = exports2.EosAuthorization = exports2.EosTxHeader = exports2.EosPublicKey = void 0;
    const constants_12 = requireConstants();
    const params_1 = requireParams();
    const schema_utils_1 = requireLib$1();
    exports2.EosPublicKey = schema_utils_1.Type.Object({
      wifPublicKey: schema_utils_1.Type.String(),
      rawPublicKey: schema_utils_1.Type.String(),
      path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      serializedPath: schema_utils_1.Type.String()
    });
    exports2.EosTxHeader = schema_utils_1.Type.Object({
      expiration: schema_utils_1.Type.Union([schema_utils_1.Type.Uint(), schema_utils_1.Type.String()]),
      refBlockNum: schema_utils_1.Type.Number(),
      refBlockPrefix: schema_utils_1.Type.Number(),
      maxNetUsageWords: schema_utils_1.Type.Number(),
      maxCpuUsageMs: schema_utils_1.Type.Number(),
      delaySec: schema_utils_1.Type.Number()
    });
    exports2.EosAuthorization = schema_utils_1.Type.Object({
      threshold: schema_utils_1.Type.Number(),
      keys: schema_utils_1.Type.Array(constants_12.PROTO.EosAuthorizationKey),
      accounts: schema_utils_1.Type.Array(schema_utils_1.Type.Object({
        permission: constants_12.PROTO.EosPermissionLevel,
        weight: schema_utils_1.Type.Number()
      })),
      waits: schema_utils_1.Type.Array(constants_12.PROTO.EosAuthorizationWait)
    });
    exports2.EosTxActionCommon = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      authorization: schema_utils_1.Type.Array(constants_12.PROTO.EosPermissionLevel)
    });
    exports2.EosTxAction = schema_utils_1.Type.Union([
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("transfer"),
          data: schema_utils_1.Type.Object({
            from: schema_utils_1.Type.String(),
            to: schema_utils_1.Type.String(),
            quantity: schema_utils_1.Type.String(),
            memo: schema_utils_1.Type.String()
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("delegatebw"),
          data: schema_utils_1.Type.Object({
            from: schema_utils_1.Type.String(),
            receiver: schema_utils_1.Type.String(),
            stake_net_quantity: schema_utils_1.Type.String(),
            stake_cpu_quantity: schema_utils_1.Type.String(),
            transfer: schema_utils_1.Type.Boolean()
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("undelegatebw"),
          data: schema_utils_1.Type.Object({
            from: schema_utils_1.Type.String(),
            receiver: schema_utils_1.Type.String(),
            unstake_net_quantity: schema_utils_1.Type.String(),
            unstake_cpu_quantity: schema_utils_1.Type.String()
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("buyram"),
          data: schema_utils_1.Type.Object({
            payer: schema_utils_1.Type.String(),
            receiver: schema_utils_1.Type.String(),
            quant: schema_utils_1.Type.String()
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("buyrambytes"),
          data: constants_12.PROTO.EosActionBuyRamBytes
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("sellram"),
          data: constants_12.PROTO.EosActionSellRam
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("voteproducer"),
          data: schema_utils_1.Type.Object({
            voter: schema_utils_1.Type.String(),
            proxy: schema_utils_1.Type.String(),
            producers: schema_utils_1.Type.Array(schema_utils_1.Type.String())
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("refund"),
          data: constants_12.PROTO.EosActionRefund
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("updateauth"),
          data: schema_utils_1.Type.Object({
            account: schema_utils_1.Type.String(),
            permission: schema_utils_1.Type.String(),
            parent: schema_utils_1.Type.String(),
            auth: exports2.EosAuthorization
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("deleteauth"),
          data: constants_12.PROTO.EosActionDeleteAuth
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("linkauth"),
          data: constants_12.PROTO.EosActionLinkAuth
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("unlinkauth"),
          data: constants_12.PROTO.EosActionUnlinkAuth
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("newaccount"),
          data: schema_utils_1.Type.Object({
            creator: schema_utils_1.Type.String(),
            name: schema_utils_1.Type.String(),
            owner: exports2.EosAuthorization,
            active: exports2.EosAuthorization
          })
        })
      ])
    ]);
    exports2.EosSDKTransaction = schema_utils_1.Type.Object({
      chainId: schema_utils_1.Type.String(),
      header: exports2.EosTxHeader,
      actions: schema_utils_1.Type.Array(schema_utils_1.Type.Union([
        exports2.EosTxAction,
        schema_utils_1.Type.Intersect([
          exports2.EosTxActionCommon,
          schema_utils_1.Type.Object({
            name: schema_utils_1.Type.String(),
            data: schema_utils_1.Type.String()
          })
        ])
      ]))
    });
    exports2.EosSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      transaction: exports2.EosSDKTransaction,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
  })(eos);
  return eos;
}
var ripple = {};
var hasRequiredRipple;
function requireRipple() {
  if (hasRequiredRipple) return ripple;
  hasRequiredRipple = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RippleSignedTx = exports2.RippleSignTransaction = exports2.RippleTransaction = exports2.RipplePayment = void 0;
    const params_1 = requireParams();
    const schema_utils_1 = requireLib$1();
    exports2.RipplePayment = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.String(),
      destination: schema_utils_1.Type.String(),
      destinationTag: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    });
    exports2.RippleTransaction = schema_utils_1.Type.Object({
      fee: schema_utils_1.Type.String(),
      flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      sequence: schema_utils_1.Type.Number(),
      maxLedgerVersion: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment: exports2.RipplePayment
    });
    exports2.RippleSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      transaction: exports2.RippleTransaction,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.RippleSignedTx = schema_utils_1.Type.Object({
      serializedTx: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    });
  })(ripple);
  return ripple;
}
var ethereum = {};
var hasRequiredEthereum;
function requireEthereum() {
  if (hasRequiredEthereum) return ethereum;
  hasRequiredEthereum = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EthereumVerifyMessage = exports2.EthereumSignTypedHash = exports2.EthereumSignTypedData = exports2.EthereumSignTypedDataMessage = exports2.EthereumSignTypedDataTypes = exports2.EthereumSignedTx = exports2.EthereumSignTransaction = exports2.EthereumTransactionEIP1559 = exports2.EthereumAccessList = exports2.EthereumTransaction = exports2.EthereumSignMessage = void 0;
    const schema_utils_1 = requireLib$1();
    const params_1 = requireParams();
    exports2.EthereumSignMessage = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      message: schema_utils_1.Type.String(),
      hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.EthereumTransaction = schema_utils_1.Type.Object({
      to: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.String(),
      gasPrice: schema_utils_1.Type.String(),
      gasLimit: schema_utils_1.Type.String(),
      maxFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      maxPriorityFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      nonce: schema_utils_1.Type.String(),
      data: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chainId: schema_utils_1.Type.Number(),
      txType: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    });
    exports2.EthereumAccessList = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      storageKeys: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    });
    exports2.EthereumTransactionEIP1559 = schema_utils_1.Type.Object({
      to: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.String(),
      gasLimit: schema_utils_1.Type.String(),
      gasPrice: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      nonce: schema_utils_1.Type.String(),
      data: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chainId: schema_utils_1.Type.Number(),
      maxFeePerGas: schema_utils_1.Type.String(),
      maxPriorityFeePerGas: schema_utils_1.Type.String(),
      accessList: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.EthereumAccessList))
    });
    exports2.EthereumSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      transaction: schema_utils_1.Type.Union([exports2.EthereumTransaction, exports2.EthereumTransactionEIP1559]),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.EthereumSignedTx = schema_utils_1.Type.Object({
      v: schema_utils_1.Type.String(),
      r: schema_utils_1.Type.String(),
      s: schema_utils_1.Type.String(),
      serializedTx: schema_utils_1.Type.String()
    });
    const EthereumSignTypedDataTypeProperty = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.String(),
      type: schema_utils_1.Type.String()
    });
    exports2.EthereumSignTypedDataTypes = schema_utils_1.Type.Object({
      EIP712Domain: schema_utils_1.Type.Array(EthereumSignTypedDataTypeProperty)
    }, {
      additionalProperties: schema_utils_1.Type.Array(EthereumSignTypedDataTypeProperty)
    });
    exports2.EthereumSignTypedDataMessage = schema_utils_1.Type.Object({
      types: exports2.EthereumSignTypedDataTypes,
      primaryType: schema_utils_1.Type.String(),
      domain: schema_utils_1.Type.Object({
        name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        version: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        chainId: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.BigInt(), schema_utils_1.Type.String()])),
        verifyingContract: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        salt: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.ArrayBuffer(), schema_utils_1.Type.String()]))
      }),
      message: schema_utils_1.Type.Object({}, {
        additionalProperties: schema_utils_1.Type.Any()
      })
    });
    exports2.EthereumSignTypedData = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      data: exports2.EthereumSignTypedDataMessage,
      metamask_v4_compat: schema_utils_1.Type.Boolean(),
      domain_separator_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined())
    });
    exports2.EthereumSignTypedHash = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      data: exports2.EthereumSignTypedDataMessage,
      metamask_v4_compat: schema_utils_1.Type.Boolean(),
      domain_separator_hash: schema_utils_1.Type.String(),
      message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.EthereumVerifyMessage = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      message: schema_utils_1.Type.String(),
      hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      signature: schema_utils_1.Type.String()
    });
  })(ethereum);
  return ethereum;
}
var solana = {};
var hasRequiredSolana;
function requireSolana() {
  if (hasRequiredSolana) return solana;
  hasRequiredSolana = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SolanaSignedTransaction = exports2.SolanaSignTransaction = exports2.SolanaTxAdditionalInfo = exports2.SolanaTxTokenAccountInfo = exports2.SolanaPublicKey = void 0;
    const params_1 = requireParams();
    const schema_utils_1 = requireLib$1();
    exports2.SolanaPublicKey = schema_utils_1.Type.Intersect([
      params_1.PublicKey,
      schema_utils_1.Type.Object({
        publicKey: schema_utils_1.Type.String()
      })
    ]);
    exports2.SolanaTxTokenAccountInfo = schema_utils_1.Type.Object({
      baseAddress: schema_utils_1.Type.String(),
      tokenProgram: schema_utils_1.Type.String(),
      tokenMint: schema_utils_1.Type.String(),
      tokenAccount: schema_utils_1.Type.String()
    });
    exports2.SolanaTxAdditionalInfo = schema_utils_1.Type.Object({
      tokenAccountsInfos: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.SolanaTxTokenAccountInfo, { minItems: 1 }))
    });
    exports2.SolanaSignTransaction = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Array(schema_utils_1.Type.Number())]),
      serializedTx: schema_utils_1.Type.String(),
      additionalInfo: schema_utils_1.Type.Optional(exports2.SolanaTxAdditionalInfo)
    });
    exports2.SolanaSignedTransaction = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String()
    });
  })(solana);
  return solana;
}
var stellar = {};
var hasRequiredStellar;
function requireStellar() {
  if (hasRequiredStellar) return stellar;
  hasRequiredStellar = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StellarOperationMessage = exports2.StellarSignedTx = exports2.StellarSignTransaction = exports2.StellarTransaction = exports2.StellarOperation = exports2.StellarClaimClaimableBalanceOperation = exports2.StellarInflationOperation = exports2.StellarBumpSequenceOperation = exports2.StellarManageDataOperation = exports2.StellarAccountMergeOperation = exports2.StellarAllowTrustOperation = exports2.StellarChangeTrustOperation = exports2.StellarSetOptionsOperation = exports2.StellarManageBuyOfferOperation = exports2.StellarManageSellOfferOperation = exports2.StellarPassiveSellOfferOperation = exports2.StellarPathPaymentStrictSendOperation = exports2.StellarPathPaymentStrictReceiveOperation = exports2.StellarPaymentOperation = exports2.StellarCreateAccountOperation = exports2.StellarAsset = void 0;
    const constants_12 = requireConstants();
    const params_1 = requireParams();
    const schema_utils_1 = requireLib$1();
    exports2.StellarAsset = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Union([constants_12.PROTO.EnumStellarAssetType, schema_utils_1.Type.KeyOfEnum(constants_12.PROTO.StellarAssetType)]),
      code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      issuer: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.StellarCreateAccountOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("createAccount"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination: schema_utils_1.Type.String(),
      startingBalance: schema_utils_1.Type.String()
    });
    exports2.StellarPaymentOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("payment"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination: schema_utils_1.Type.String(),
      asset: exports2.StellarAsset,
      amount: schema_utils_1.Type.String()
    });
    exports2.StellarPathPaymentStrictReceiveOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("pathPaymentStrictReceive"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sendAsset: exports2.StellarAsset,
      sendMax: schema_utils_1.Type.Uint(),
      destination: schema_utils_1.Type.String(),
      destAsset: exports2.StellarAsset,
      destAmount: schema_utils_1.Type.Uint(),
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.StellarAsset))
    });
    exports2.StellarPathPaymentStrictSendOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("pathPaymentStrictSend"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sendAsset: exports2.StellarAsset,
      sendAmount: schema_utils_1.Type.Uint(),
      destination: schema_utils_1.Type.String(),
      destAsset: exports2.StellarAsset,
      destMin: schema_utils_1.Type.Uint(),
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.StellarAsset))
    });
    exports2.StellarPassiveSellOfferOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("createPassiveSellOffer"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      buying: exports2.StellarAsset,
      selling: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price: schema_utils_1.Type.Object({
        n: schema_utils_1.Type.Number(),
        d: schema_utils_1.Type.Number()
      })
    });
    exports2.StellarManageSellOfferOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("manageSellOffer"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      buying: exports2.StellarAsset,
      selling: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      offerId: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      price: schema_utils_1.Type.Object({
        n: schema_utils_1.Type.Number(),
        d: schema_utils_1.Type.Number()
      })
    });
    exports2.StellarManageBuyOfferOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("manageBuyOffer"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      buying: exports2.StellarAsset,
      selling: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      offerId: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      price: schema_utils_1.Type.Object({
        n: schema_utils_1.Type.Number(),
        d: schema_utils_1.Type.Number()
      })
    });
    exports2.StellarSetOptionsOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("setOptions"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signer: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        type: constants_12.PROTO.EnumStellarSignerType,
        key: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Buffer()]),
        weight: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      })),
      inflationDest: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      clearFlags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      setFlags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      masterWeight: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      lowThreshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      medThreshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      highThreshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      homeDomain: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.StellarChangeTrustOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("changeTrust"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      line: exports2.StellarAsset,
      limit: schema_utils_1.Type.String()
    });
    exports2.StellarAllowTrustOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("allowTrust"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      trustor: schema_utils_1.Type.String(),
      assetCode: schema_utils_1.Type.String(),
      assetType: constants_12.PROTO.EnumStellarAssetType,
      authorize: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Undefined()]))
    });
    exports2.StellarAccountMergeOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("accountMerge"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination: schema_utils_1.Type.String()
    });
    exports2.StellarManageDataOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("manageData"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      name: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Buffer()]))
    });
    exports2.StellarBumpSequenceOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("bumpSequence"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      bumpTo: schema_utils_1.Type.Uint()
    });
    exports2.StellarInflationOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("inflation"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.StellarClaimClaimableBalanceOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("claimClaimableBalance"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      balanceId: schema_utils_1.Type.String()
    });
    exports2.StellarOperation = schema_utils_1.Type.Union([
      exports2.StellarCreateAccountOperation,
      exports2.StellarPaymentOperation,
      exports2.StellarPathPaymentStrictReceiveOperation,
      exports2.StellarPathPaymentStrictSendOperation,
      exports2.StellarPassiveSellOfferOperation,
      exports2.StellarManageSellOfferOperation,
      exports2.StellarManageBuyOfferOperation,
      exports2.StellarSetOptionsOperation,
      exports2.StellarChangeTrustOperation,
      exports2.StellarAllowTrustOperation,
      exports2.StellarAccountMergeOperation,
      exports2.StellarInflationOperation,
      exports2.StellarManageDataOperation,
      exports2.StellarBumpSequenceOperation,
      exports2.StellarClaimClaimableBalanceOperation
    ]);
    exports2.StellarTransaction = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Number(),
      sequence: schema_utils_1.Type.Uint(),
      timebounds: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        minTime: schema_utils_1.Type.Number(),
        maxTime: schema_utils_1.Type.Number()
      })),
      memo: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        type: constants_12.PROTO.EnumStellarMemoType,
        id: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
        text: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Buffer()]))
      })),
      operations: schema_utils_1.Type.Array(exports2.StellarOperation)
    });
    exports2.StellarSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      networkPassphrase: schema_utils_1.Type.String(),
      transaction: exports2.StellarTransaction
    });
    exports2.StellarSignedTx = schema_utils_1.Type.Object({
      publicKey: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    });
    exports2.StellarOperationMessage = schema_utils_1.Type.Union([
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarCreateAccountOp")
        }),
        constants_12.PROTO.StellarCreateAccountOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarPaymentOp")
        }),
        constants_12.PROTO.StellarPaymentOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarPathPaymentStrictReceiveOp")
        }),
        constants_12.PROTO.StellarPathPaymentStrictReceiveOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarPathPaymentStrictSendOp")
        }),
        constants_12.PROTO.StellarPathPaymentStrictSendOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarManageSellOfferOp")
        }),
        constants_12.PROTO.StellarManageSellOfferOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarManageBuyOfferOp")
        }),
        constants_12.PROTO.StellarManageBuyOfferOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarCreatePassiveSellOfferOp")
        }),
        constants_12.PROTO.StellarCreatePassiveSellOfferOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarSetOptionsOp")
        }),
        constants_12.PROTO.StellarSetOptionsOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarChangeTrustOp")
        }),
        constants_12.PROTO.StellarChangeTrustOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarAllowTrustOp")
        }),
        constants_12.PROTO.StellarAllowTrustOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarAccountMergeOp")
        }),
        constants_12.PROTO.StellarAccountMergeOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarManageDataOp")
        }),
        constants_12.PROTO.StellarManageDataOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarBumpSequenceOp")
        }),
        constants_12.PROTO.StellarBumpSequenceOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarClaimClaimableBalanceOp")
        }),
        constants_12.PROTO.StellarClaimClaimableBalanceOp
      ])
    ]);
  })(stellar);
  return stellar;
}
var tezos = {};
var hasRequiredTezos;
function requireTezos() {
  if (hasRequiredTezos) return tezos;
  hasRequiredTezos = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TezosSignTransaction = exports2.TezosOperation = exports2.TezosDelegationOperation = exports2.TezosOriginationOperation = exports2.TezosTransactionOperation = exports2.TezosParametersManager = exports2.TezosManagerTransfer = exports2.TezosRevealOperation = void 0;
    const params_1 = requireParams();
    const schema_utils_1 = requireLib$1();
    exports2.TezosRevealOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      public_key: schema_utils_1.Type.String()
    });
    exports2.TezosManagerTransfer = schema_utils_1.Type.Object({
      destination: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Number()
    });
    exports2.TezosParametersManager = schema_utils_1.Type.Object({
      set_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      cancel_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      transfer: schema_utils_1.Type.Optional(exports2.TezosManagerTransfer)
    });
    exports2.TezosTransactionOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      destination: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      fee: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      parameters: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      parameters_manager: schema_utils_1.Type.Optional(exports2.TezosParametersManager)
    });
    exports2.TezosOriginationOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      balance: schema_utils_1.Type.Number(),
      delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script: params_1.DerivationPath,
      fee: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number()
    });
    exports2.TezosDelegationOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      delegate: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number()
    });
    exports2.TezosOperation = schema_utils_1.Type.Object({
      reveal: schema_utils_1.Type.Optional(exports2.TezosRevealOperation),
      transaction: schema_utils_1.Type.Optional(exports2.TezosTransactionOperation),
      origination: schema_utils_1.Type.Optional(exports2.TezosOriginationOperation),
      delegation: schema_utils_1.Type.Optional(exports2.TezosDelegationOperation)
    });
    exports2.TezosSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      branch: schema_utils_1.Type.String(),
      operation: exports2.TezosOperation,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
  })(tezos);
  return tezos;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_12 = require$$0;
    tslib_12.__exportStar(requireApi(), exports2);
    tslib_12.__exportStar(requireAccount(), exports2);
    tslib_12.__exportStar(requireCoinInfo(), exports2);
    tslib_12.__exportStar(requireDevice(), exports2);
    tslib_12.__exportStar(requireFees(), exports2);
    tslib_12.__exportStar(requireFirmware(), exports2);
    tslib_12.__exportStar(requireParams(), exports2);
    tslib_12.__exportStar(requireSettings(), exports2);
    tslib_12.__exportStar(requireCardano(), exports2);
    tslib_12.__exportStar(requireBinance(), exports2);
    tslib_12.__exportStar(requireBitcoin(), exports2);
    tslib_12.__exportStar(requireEos(), exports2);
    tslib_12.__exportStar(requireRipple(), exports2);
    tslib_12.__exportStar(requireEthereum(), exports2);
    tslib_12.__exportStar(requireSolana(), exports2);
    tslib_12.__exportStar(requireStellar(), exports2);
    tslib_12.__exportStar(requireTezos(), exports2);
  })(types);
  return types;
}
var hasRequiredExports;
function requireExports() {
  if (hasRequiredExports) return exports;
  hasRequiredExports = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseConnectSettings = void 0;
    const tslib_12 = require$$0;
    tslib_12.__exportStar(requireConstants(), exports2);
    tslib_12.__exportStar(events, exports2);
    tslib_12.__exportStar(requireTypes(), exports2);
    var connectSettings_12 = requireConnectSettings$1();
    Object.defineProperty(exports2, "parseConnectSettings", { enumerable: true, get: function() {
      return connectSettings_12.parseConnectSettings;
    } });
  })(exports);
  return exports;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TrezorConnectDynamicImpl = void 0;
  const tslib_12 = require$$0;
  const factory_12 = factory$1;
  const core_in_iframe_1 = coreInIframe;
  const core_in_popup_1 = coreInPopup;
  class ProxyEventEmitter {
    constructor(eventEmitters) {
      this.eventEmitters = eventEmitters;
    }
    emit(eventName, ...args) {
      this.eventEmitters.forEach((emitter) => emitter.emit(eventName, ...args));
      return true;
    }
    on(eventName, listener) {
      this.eventEmitters.forEach((emitter) => emitter.on(eventName, listener));
      return this;
    }
    off(eventName, listener) {
      this.eventEmitters.forEach((emitter) => emitter.off(eventName, listener));
      return this;
    }
    once(eventName, listener) {
      this.eventEmitters.forEach((emitter) => emitter.once(eventName, listener));
      return this;
    }
    addListener(eventName, listener) {
      this.eventEmitters.forEach((emitter) => emitter.addListener(eventName, listener));
      return this;
    }
    prependListener(eventName, listener) {
      this.eventEmitters.forEach((emitter) => emitter.prependListener(eventName, listener));
      return this;
    }
    prependOnceListener(eventName, listener) {
      this.eventEmitters.forEach((emitter) => emitter.prependOnceListener(eventName, listener));
      return this;
    }
    removeAllListeners(event) {
      this.eventEmitters.forEach((emitter) => emitter.removeAllListeners(event));
      return this;
    }
    removeListener(eventName, listener) {
      this.eventEmitters.forEach((emitter) => emitter.removeListener(eventName, listener));
      return this;
    }
    setMaxListeners(n) {
      this.eventEmitters.forEach((emitter) => emitter.setMaxListeners(n));
      return this;
    }
    eventNames() {
      return this.eventEmitters[0].eventNames();
    }
    getMaxListeners() {
      return this.eventEmitters[0].getMaxListeners();
    }
    listenerCount(eventName, listener) {
      return this.eventEmitters[0].listenerCount(eventName, listener);
    }
    rawListeners(eventName) {
      return this.eventEmitters[0].rawListeners(eventName);
    }
    listeners(eventName) {
      return this.eventEmitters[0].listeners(eventName);
    }
  }
  class TrezorConnectDynamicImpl {
    constructor() {
      this.currentTarget = "iframe";
      this.coreInIframeImpl = new core_in_iframe_1.CoreInIframe();
      this.coreInPopupImpl = new core_in_popup_1.CoreInPopup();
      this.eventEmitter = new ProxyEventEmitter([
        this.coreInIframeImpl.eventEmitter,
        this.coreInPopupImpl.eventEmitter
      ]);
    }
    getTarget() {
      return this.currentTarget === "iframe" ? this.coreInIframeImpl : this.coreInPopupImpl;
    }
    manifest(data) {
      this.getTarget().manifest(data);
    }
    init(settings2 = {}) {
      if (settings2.useCoreInPopup) {
        this.currentTarget = "core-in-popup";
      } else {
        this.currentTarget = "iframe";
      }
      return this.getTarget().init(settings2);
    }
    call(params2) {
      return this.getTarget().call(params2);
    }
    requestLogin(params2) {
      return this.getTarget().requestLogin(params2);
    }
    uiResponse(params2) {
      return this.getTarget().uiResponse(params2);
    }
    renderWebUSBButton() {
      return this.getTarget().renderWebUSBButton();
    }
    disableWebUSB() {
      return this.getTarget().disableWebUSB();
    }
    requestWebUSBDevice() {
      return this.getTarget().requestWebUSBDevice();
    }
    cancel(error) {
      return this.getTarget().cancel(error);
    }
    dispose() {
      this.eventEmitter.removeAllListeners();
      return this.getTarget().dispose();
    }
  }
  exports2.TrezorConnectDynamicImpl = TrezorConnectDynamicImpl;
  const methods2 = new TrezorConnectDynamicImpl();
  const TrezorConnect2 = (0, factory_12.factory)({
    eventEmitter: methods2.eventEmitter,
    init: methods2.init.bind(methods2),
    call: methods2.call.bind(methods2),
    manifest: methods2.manifest.bind(methods2),
    requestLogin: methods2.requestLogin.bind(methods2),
    uiResponse: methods2.uiResponse.bind(methods2),
    renderWebUSBButton: methods2.renderWebUSBButton.bind(methods2),
    disableWebUSB: methods2.disableWebUSB.bind(methods2),
    requestWebUSBDevice: methods2.requestWebUSBDevice.bind(methods2),
    cancel: methods2.cancel.bind(methods2),
    dispose: methods2.dispose.bind(methods2)
  });
  exports2.default = TrezorConnect2;
  tslib_12.__exportStar(requireExports(), exports2);
})(lib$5);
const TrezorConnect = /* @__PURE__ */ getDefaultExportFromCjs(lib$5);
const trezorDerivationType = lib$5.PROTO.CardanoDerivationType;
const getTrezorDerivationTypeFromWalletId = (walletId) => {
  switch (walletId.slice(walletId.length - 1)) {
    case "t":
      return trezorDerivationType.ICARUS_TREZOR;
    case "i":
      return trezorDerivationType.ICARUS;
    case "l":
      return trezorDerivationType.LEDGER;
    default:
      return trezorDerivationType.ICARUS_TREZOR;
  }
};
const initiateTrezor = async (signingMode) => {
  TrezorConnect.manifest({
    email: "team@eternl.io",
    appUrl: "https://eternl.io"
  });
  const features = await TrezorConnect.getFeatures();
  if (!features.success) {
    throw new Error(features.payload.error);
  }
  const versionString = features.payload.major_version + "." + features.payload.minor_version + "." + features.payload.patch_version;
  if (signingMode === lib$5.PROTO.CardanoTxSigningMode.PLUTUS_TRANSACTION && !semver.gte(versionString, "2.5.1")) {
    throw new Error("Error: initiateTrezor: outdated Trezor firmware version on device[v" + versionString + "], minimum required version to interact with plutus smart contracts is: v2.5.1");
  } else if (!semver.gte(versionString, "2.4.3")) {
    throw new Error("Error: initiateTrezor: outdated Trezor firmware version on device[v" + versionString + "], minimum required version: v2.4.3");
  }
  return features.payload;
};
const getTrezorPublicKey = async (accPurpose = purpose.hdwallet, accIndex = 0, amountAccounts = 1, accList = [], derivationType) => {
  const list = [];
  let responseList;
  if (accIndex === -1 && accList.length === 0) {
    let paths = [];
    for (let i = 0; i < amountAccounts; i++) {
      paths.push({ path: getStringDerivationPath([accPurpose, coin.ada, i]), showOnTrezor: false, derivationType });
    }
    responseList = await TrezorConnect.cardanoGetPublicKey({
      bundle: paths
    });
  } else if (accList.length === 0) {
    if (accIndex >= 0 || accPurpose !== purpose.hdwallet) {
      responseList = await TrezorConnect.cardanoGetPublicKey({
        bundle: [
          { path: getStringDerivationPath([accPurpose, coin.ada, accIndex]), showOnTrezor: false, derivationType }
        ]
      });
    } else {
      responseList = await TrezorConnect.cardanoGetPublicKey({
        bundle: [
          { path: getStringDerivationPath([purpose.hdwallet, coin.ada, 0]), showOnTrezor: false, derivationType }
          // compare to current wallet account 0
        ]
      });
    }
  } else {
    let paths = [];
    for (let i = 0; i < accList.length; i++) {
      paths.push({ path: getStringDerivationPath([accPurpose, coin.ada, accList[i]]), showOnTrezor: false, derivationType });
    }
    responseList = await TrezorConnect.cardanoGetPublicKey({
      bundle: paths
    });
  }
  if (!responseList.success) throw new Error(responseList.payload.error);
  for (const response of responseList.payload) {
    list.push(getPubKeyFromHex(response.publicKey));
  }
  return list;
};
const signTxWithTrezor = async (appAccount, walletId, txBuildRes, credList) => {
  var _a;
  let cslSignedTx;
  let cslWitnessSetOwned;
  let cslVkeys;
  let cslCatalystMeta;
  let cslCatalystMetaSigned;
  let res = { error: "notExecuted" };
  try {
    if (!(txBuildRes == null ? void 0 : txBuildRes.builtTx)) {
      return { error: ErrorSignTx.missingTx };
    }
    if (!(txBuildRes == null ? void 0 : txBuildRes.txCbor)) {
      return { error: ErrorSignTx.missingTx };
    }
    if (!credList) {
      return { error: ErrorSignTx.missingKeysList };
    }
    const networkId = appAccount.data.state.networkId;
    const epochParams = checkEpochParams(networkId);
    const trezorSign = await getWitnessesWithTrezor(
      appAccount,
      walletId,
      txBuildRes,
      credList,
      false
    );
    cslWitnessSetOwned = TransactionWitnessSet.from_hex(trezorSign.serializedWitnessSet);
    const cslVkeysOwned = cslWitnessSetOwned.vkeys();
    cslVkeys = txBuildRes.cslWitnessSet.vkeys() ?? Vkeywitnesses.new();
    for (let i = 0; i < ((cslVkeysOwned == null ? void 0 : cslVkeysOwned.len()) ?? 0); i++) {
      const vkeyWitness = cslVkeysOwned.get(i);
      if (!hasWitness(cslVkeys, vkeyWitness)) {
        cslVkeys.add(vkeyWitness);
      }
      safeFreeCSLObject(vkeyWitness);
    }
    txBuildRes.cslWitnessSet.set_vkeys(cslVkeys);
    safeFreeCSLObject(cslVkeysOwned);
    if (txBuildRes.cslAuxData && isCatalystVotingRegistrationMetadata(txBuildRes.cslAuxData)) {
      if (!((_a = trezorSign.signedTransactionData.auxiliaryDataSupplement) == null ? void 0 : _a.cVoteRegistrationSignature)) {
        return { error: ErrorSignTx.trezorCatalyst };
      }
      cslCatalystMeta = getCatalystRegistrationMetadata(txBuildRes.cslAuxData);
      cslCatalystMetaSigned = addCatalystRegistrationSignature(
        cslCatalystMeta,
        void 0,
        trezorSign.signedTransactionData.auxiliaryDataSupplement.cVoteRegistrationSignature
      );
      safeFreeCSLObject(txBuildRes.cslAuxData);
      txBuildRes.cslAuxData = generateCatalystRegistration(cslCatalystMetaSigned);
      const cslAuxHash = hash_auxiliary_data(txBuildRes.cslAuxData);
      txBuildRes.builtTx.auxiliary_data = cslToJson(txBuildRes.cslAuxData.to_json());
      txBuildRes.cslTxBody.set_auxiliary_data_hash(cslAuxHash);
      let cslTxHash;
      try {
        const cslFixedTx = FixedTransaction.new_from_body_bytes(txBuildRes.cslTxBody.to_bytes());
        cslTxHash = cslFixedTx.transaction_hash();
        safeFreeCSLObject(cslFixedTx);
      } catch (err) {
        if (err === "NOT_IMPLEMENTED") {
          console.warn("NOT_IMPLEMENTED > fallback cslTxHash");
          cslTxHash = hash_transaction(txBuildRes.cslTxBody);
        } else {
          throw err;
        }
      }
      txBuildRes.txHash = toHexString(cslTxHash.to_bytes());
      txBuildRes.txCbor = null;
      safeFreeCSLObject(cslAuxHash);
      safeFreeCSLObject(cslTxHash);
    }
    cslSignedTx = Transaction.new(txBuildRes.cslTxBody, txBuildRes.cslWitnessSet, txBuildRes.cslAuxData);
    txBuildRes.cslAuxData = cslSignedTx.auxiliary_data();
    const signedTxBytes = cslSignedTx.to_bytes();
    const signedTxHash = txBuildRes.txHash;
    const signedTx = getTransactionJSONFromCSL(networkId, cslSignedTx);
    const signedTxSize = signedTxBytes.byteLength;
    console.log("builtTx", JSON.stringify(txBuildRes));
    if (trezorSign.signedTransactionData.hash !== signedTxHash) {
      console.error("Trezor tx hash:", trezorSign.signedTransactionData.hash);
      console.error("Eternl tx hash:", signedTxHash);
      return { error: ErrorSignTx.trezorTxHashMismatch };
    }
    signedTx.hash = signedTxHash;
    signedTx.size = signedTxSize;
    signedTx.inputUtxoList = txBuildRes.builtTx.inputUtxoList;
    const signedTxHex = reinjectWitnessSet(txBuildRes.txCbor, toHexString(signedTxBytes), txBuildRes.cslWitnessSet);
    const signedTxWitnessSet = toHexString(txBuildRes.cslWitnessSet.to_bytes());
    const maxTxSize = epochParams.maxTxSize;
    signedTx.cbor = signedTxHex;
    res = {
      tx: signedTx,
      hash: signedTxHash,
      cbor: signedTxHex,
      witnessSet: signedTxWitnessSet,
      witnessSetOwned: trezorSign.serializedWitnessSet
    };
    if (signedTxSize > epochParams.maxTxSize) {
      res.error = ErrorSignTx.txSize + "." + signedTxSize + "." + maxTxSize;
    }
  } catch (err) {
    res = { error: (err == null ? void 0 : err.message) ?? err };
  }
  safeFreeCSLObject(cslSignedTx);
  safeFreeCSLObject(cslWitnessSetOwned);
  safeFreeCSLObject(cslVkeys);
  safeFreeCSLObject(cslCatalystMeta);
  safeFreeCSLObject(cslCatalystMetaSigned);
  return res;
};
const getWitnessesWithTrezor = async (appAccount, walletId, txBuildRes, credList, doHashCheck = true) => {
  const derivationType = () => {
    switch (walletId.slice(walletId.length - 1)) {
      case "t":
        return trezorDerivationType.ICARUS_TREZOR;
      case "i":
        return trezorDerivationType.ICARUS;
      case "l":
        return trezorDerivationType.LEDGER;
      default:
        return trezorDerivationType.ICARUS_TREZOR;
    }
  };
  const tx = txBuildRes.builtTx;
  let inputUtxoList = tx.inputUtxoList;
  const accountData = appAccount.data;
  const networkId = accountData.state.networkId;
  if (!inputUtxoList) {
    const { utxoList } = getFilteredUtxoList(appAccount, false);
    inputUtxoList = utxoList;
  }
  const inputs = await generateTrezorInputs(accountData, tx.body.inputs, inputUtxoList);
  const collateralInputs = tx.body.collateral ? await generateTrezorInputs(accountData, tx.body.collateral, inputUtxoList) : null;
  const referenceInputs = tx.body.reference_inputs ? await generateTrezorInputs(accountData, tx.body.reference_inputs, inputUtxoList) : null;
  const outputs = generateTrezorOutputs(accountData, tx, tx.body.outputs, false);
  let collateralOutput = null;
  if (tx.body.collateral_return) {
    collateralOutput = generateTrezorOutputs(accountData, tx, [tx.body.collateral_return], true)[0];
  }
  const additionalWitnessPaths = generateAdditionalWitnessPaths(credList, inputs, collateralInputs, referenceInputs);
  const ttl = tx.body.ttl;
  tx.body.donation;
  const totalCollateral = tx.body.total_collateral;
  const withdrawals = tx.body.withdrawals;
  const certificates = tx.body.certs;
  const validityStart = tx.body.validity_start_interval;
  const scriptDataHash = tx.body.script_data_hash;
  const metadataHash = tx.body.auxiliary_data_hash;
  const mint = tx.body.mint;
  const requiredSigners = tx.body.required_signers;
  const includeNetworkId = !!tx.body.network_id;
  const hasConwaySetTag = tx.hasConwaySetTag;
  let signingMode;
  if (!!collateralInputs || !!tx.witness_set.redeemers || !!tx.body.reference_inputs) {
    signingMode = lib$5.PROTO.CardanoTxSigningMode.PLUTUS_TRANSACTION;
  } else if (additionalWitnessPaths.some((item) => item.startsWith("m/" + purpose.multisig) || item.startsWith("m/" + purpose.minting))) {
    signingMode = lib$5.PROTO.CardanoTxSigningMode.MULTISIG_TRANSACTION;
  } else {
    signingMode = lib$5.PROTO.CardanoTxSigningMode.ORDINARY_TRANSACTION;
  }
  await initiateTrezor(signingMode);
  const isTestnet = isTestnetNetwork(networkId);
  let request = {
    signingMode,
    inputs,
    outputs,
    fee: tx.body.fee,
    protocolMagic: getNetworkMagic(isTestnet ? networkId : "mainnet"),
    networkId: isTestnet ? 0 : 1,
    derivationType: derivationType(),
    tagCborSets: hasConwaySetTag
  };
  if (ttl) {
    request.ttl = ttl;
  }
  if (collateralInputs) {
    request.collateralInputs = collateralInputs;
  }
  if (referenceInputs) {
    request.referenceInputs = referenceInputs;
  }
  if (collateralOutput) {
    request.collateralReturn = collateralOutput;
  }
  if (totalCollateral != null) {
    request.totalCollateral = totalCollateral;
  }
  if (withdrawals) {
    request.withdrawals = generateTrezorWithdrawals(accountData, withdrawals);
  }
  if (certificates) {
    request.certificates = generateTrezorCertificates(accountData, certificates);
  }
  if (txBuildRes.cslAuxData && isCatalystVotingRegistrationMetadata(txBuildRes.cslAuxData)) {
    request.auxiliaryData = generateTrezorMetadata(accountData, txBuildRes.cslAuxData);
  } else if (metadataHash) {
    request.auxiliaryData = generateTrezorMetadataFromHash(metadataHash);
  }
  if (mint) {
    request.mint = generateTrezorMintBundle(mint);
  }
  if (scriptDataHash != null) {
    request.scriptDataHash = scriptDataHash;
  }
  if (additionalWitnessPaths.length > 0) {
    request.additionalWitnessRequests = additionalWitnessPaths;
  }
  if (validityStart != null) {
    request.validityIntervalStart = validityStart;
  }
  if (requiredSigners) {
    request.requiredSigners = generateRequiredSigners(accountData, requiredSigners);
  }
  if (includeNetworkId) {
    request.includeNetworkId = true;
  }
  const req_json = JSON.parse(JSON.stringify(request));
  txBuildRes.hwRequest = req_json;
  console.log("builtTx", txBuildRes);
  console.log("req_json", JSON.stringify(req_json));
  console.log("req_json", req_json);
  const response = await TrezorConnect.cardanoSignTransaction(req_json);
  if (!response.success) {
    throw new Error(response.payload.error);
  }
  console.log("response", response);
  if (txBuildRes.txHash && doHashCheck) {
    if (response.payload.hash !== txBuildRes.txHash) {
      console.error("Trezor tx hash response:", response.payload.hash);
      console.error("Source tx hash from cbor:", txBuildRes.txHash);
      throw new Error("Tx serialization mismatch between Trezor and source transaction");
    }
  }
  const witnessSetHex = assembleWitnesses(accountData, response.payload);
  return {
    serializedWitnessSet: witnessSetHex,
    signedTransactionData: response.payload
  };
};
const assembleWitnesses = (accountData, signedTxData) => {
  const witnesses = TransactionWitnessSet.new();
  const vkeyWitnesses = witnesses.vkeys() ?? Vkeywitnesses.new();
  for (const witness of signedTxData.witnesses) {
    vkeyWitnesses.add(getVkeyWitness(witness.pubKey, witness.signature, true, true));
  }
  witnesses.set_vkeys(vkeyWitnesses);
  const witnessSetHex = witnesses.to_hex();
  safeFreeCSLObject(vkeyWitnesses);
  safeFreeCSLObject(witnesses);
  return witnessSetHex;
};
function generateRequiredSigners(accountData, requiredSigners) {
  const requiredSignerList = [];
  for (const requiredSigner of requiredSigners) {
    const cred = getOwnedCred([accountData.keys], requiredSigner);
    if (cred) {
      requiredSignerList.push({
        keyPath: getStringDerivationPath(cred.path)
      });
    } else {
      requiredSignerList.push({
        keyHash: requiredSigner
      });
    }
  }
  return requiredSignerList;
}
function generateAdditionalWitnessPaths(credList, inputs, collaterals, refInputs, checkInputs) {
  const additionalWitnessPaths = [];
  {
    for (const cred of credList) {
      const hardenedPath = getStringDerivationPath(cred.path);
      if (additionalWitnessPaths.some((i) => i === hardenedPath)) {
        continue;
      }
      const isPartOfInputs = inputs.some((item) => item.path && item.path === hardenedPath);
      const isPartOfCollaterals = collaterals ? collaterals.some((item) => item.path && item.path === hardenedPath) : false;
      const isPartOfRefInputs = refInputs ? refInputs.some((item) => item.path && item.path === hardenedPath) : false;
      if (!isPartOfInputs && !isPartOfCollaterals && !isPartOfRefInputs) {
        additionalWitnessPaths.push(hardenedPath);
      }
    }
  }
  return additionalWitnessPaths;
}
async function generateTrezorInputs(accountData, inputs, utxoList) {
  const trezorInputs = [];
  for (const input of inputs) {
    const utxo = utxoList.find((u) => u.input.transaction_id === input.transaction_id && u.input.index === input.index);
    const cred = utxo ? getAddressCredentials(utxo.output.address) : null;
    const key = cred ? getOwnedCred([accountData.keys], cred.paymentCred) : null;
    trezorInputs.push({
      path: key ? getStringDerivationPath(key.path) : void 0,
      prev_hash: input.transaction_id,
      prev_index: input.index
    });
  }
  return trezorInputs;
}
function generateTrezorOutputs(accountData, tx, outputs, isCollateral) {
  var _a, _b;
  const trezorOutputs = [];
  for (let i = 0; i < outputs.length; i++) {
    const output2 = outputs[i];
    const cred = getAddressCredentials(output2.address, null, true);
    if (!cred) {
      throw new Error("unable to parse output address: " + output2.address);
    }
    const paymentCred = cred.paymentCred ? getOwnedCred([accountData.keys], cred.paymentCred) : null;
    let out;
    let format = lib$5.PROTO.CardanoTxOutputSerializationFormat.ARRAY_LEGACY;
    const outputData = isCollateral ? (_a = tx.colOutputDataList) == null ? void 0 : _a[i] : (_b = tx.outputData) == null ? void 0 : _b[i];
    if (outputData && outputData.isBabbage) {
      format = lib$5.PROTO.CardanoTxOutputSerializationFormat.MAP_BABBAGE;
    }
    try {
      if (paymentCred) {
        out = {
          format,
          addressParameters: generateTrezorAddressParameters(accountData, output2.address, paymentCred, cred.stakeCred),
          amount: output2.amount.coin,
          ...generateTrezorTokenBundle(output2.amount.multiasset)
        };
      }
    } catch (err) {
    }
    if (!out) {
      out = {
        format,
        address: output2.address,
        amount: output2.amount.coin,
        ...generateTrezorTokenBundle(output2.amount.multiasset)
      };
    }
    if (output2.script_ref) {
      let script = null;
      if (outputData == null ? void 0 : outputData.plutusScriptBytes) {
        script = toHexString(outputData.plutusScriptBytes);
      } else {
        script = output2.script_ref["PlutusScript"] ?? output2.script_ref["NativeScript"] ?? null;
      }
      if (script && typeof script === "string") {
        out.referenceScript = script;
      }
    }
    const hvb = getPlutusHVB(output2.plutus_data);
    if (outputData == null ? void 0 : outputData.plutusDataBytes) {
      hvb.bytes = toHexString(outputData.plutusDataBytes);
    }
    if (hvb.bytes) {
      out.inlineDatum = hvb.bytes;
    } else if (hvb.hash) {
      out.datumHash = hvb.hash;
    }
    trezorOutputs.push(out);
  }
  return trezorOutputs;
}
function generateTrezorAddressParameters(accountData, address2, paymentCred, stakeCredBech32) {
  if (stakeCredBech32) {
    const stakeCred = getOwnedCred([accountData.keys], stakeCredBech32, "stake");
    if (!stakeCred) {
      throw new Error("Error: generateTrezorAddressParameters: couldn't find cred for: " + stakeCredBech32);
    }
    return {
      addressType: lib$5.PROTO.CardanoAddressType.BASE,
      path: getStringDerivationPath(paymentCred.path),
      stakingPath: getStringDerivationPath(stakeCred.path)
    };
  }
  return {
    addressType: lib$5.PROTO.CardanoAddressType.ENTERPRISE,
    path: getStringDerivationPath(paymentCred.path)
  };
}
function generateTrezorTokenBundle(assets) {
  if (assets == null) return Object.freeze({});
  const assetGroup = [];
  const sortedPolicyList = Object.entries(assets).sort((a, b) => a[0].localeCompare(b[0], "en-US"));
  for (const policy of sortedPolicyList) {
    const assetList = [];
    const sortedAssetList = Object.entries(policy[1]).sort((a, b) => {
      return a[0].length === b[0].length ? a[0].localeCompare(b[0], "en-US") : a[0].length - b[0].length;
    });
    for (const asset of sortedAssetList) {
      assetList.push({
        assetNameBytes: asset[0],
        amount: asset[1]
      });
    }
    assetGroup.push({
      policyId: policy[0],
      tokenAmounts: assetList
    });
  }
  return assetGroup.length === 0 ? {} : { tokenBundle: assetGroup };
}
function generateTrezorMintBundle(mintList) {
  const assetGroup = [];
  const sortedMintList = [...mintList].sort((a, b) => a[0].localeCompare(b[0], "en-US"));
  for (const mint of sortedMintList) {
    const assetList = [];
    const sortedAssetList = Object.entries(mint[1]).sort((a, b) => {
      return a[0].length === b[0].length ? a[0].localeCompare(b[0], "en-US") : a[0].length - b[0].length;
    });
    for (const asset of sortedAssetList) {
      assetList.push({
        assetNameBytes: asset[0],
        mintAmount: asset[1]
      });
    }
    assetGroup.push({
      policyId: mint[0],
      tokenAmounts: assetList
    });
  }
  return assetGroup;
}
function generateTrezorWithdrawals(accountData, withdrawals) {
  const trezorWithdrawals = [];
  for (const withdrawal of Object.entries(withdrawals)) {
    const cred = getAddressCredentials(withdrawal[0]);
    const stakeCred = getOwnedCred([accountData.keys], cred.stakeCred, "stake");
    const _withdrawal = {
      amount: withdrawal[1]
    };
    if (stakeCred) {
      _withdrawal.path = getStringDerivationPath(stakeCred.path);
    } else if (cred.stakeCred) {
      if (isScriptStakeAddress(withdrawal[0])) {
        _withdrawal.scriptHash = cred.stakeCred;
      } else {
        _withdrawal.keyHash = cred.stakeCred;
      }
    } else {
      throw new Error(`generateTrezorWithdrawals: unsupported withdrawal type`);
    }
    trezorWithdrawals.push(_withdrawal);
  }
  return trezorWithdrawals.length === 0 ? void 0 : trezorWithdrawals;
}
function generateTrezorCertificates(accountData, certificates) {
  const trezorCertificate = [];
  const networkId = accountData.state.networkId;
  for (const cert of certificates) {
    const id2 = CertificateTypes.findIndex((type2) => type2 === Object.keys(cert)[0]);
    switch (id2) {
      case CertificateKind.StakeRegistration: {
        const regCert = cert.StakeRegistration;
        const cred = Object.values(regCert.stake_credential)[0];
        const addr = getRewardAddressFromCred(cred, networkId);
        const ownedCred = getOwnedCred([accountData.keys], cred, "stake");
        const trezorRegCert = {
          type: regCert.coin ? lib$5.PROTO.CardanoCertificateType.STAKE_REGISTRATION_CONWAY : lib$5.PROTO.CardanoCertificateType.STAKE_REGISTRATION
        };
        if (regCert.coin) {
          trezorRegCert.deposit = regCert.coin;
        }
        if (ownedCred) {
          trezorRegCert.path = getStringDerivationPath(ownedCred.path);
        } else if (isScriptStakeAddress(addr)) {
          trezorRegCert.scriptHash = cred;
        } else {
          trezorRegCert.keyHash = cred;
        }
        trezorCertificate.push(trezorRegCert);
        break;
      }
      case CertificateKind.StakeDeregistration: {
        const deregCert = cert.StakeDeregistration;
        const cred = Object.values(deregCert.stake_credential)[0];
        const addr = getRewardAddressFromCred(cred, networkId);
        const ownedCred = getOwnedCred([accountData.keys], cred, "stake");
        const trezorDeregCert = {
          type: deregCert.coin ? lib$5.PROTO.CardanoCertificateType.STAKE_DEREGISTRATION_CONWAY : lib$5.PROTO.CardanoCertificateType.STAKE_DEREGISTRATION
        };
        if (deregCert.coin) {
          trezorDeregCert.deposit = deregCert.coin;
        }
        if (ownedCred) {
          trezorDeregCert.path = getStringDerivationPath(ownedCred.path);
        } else if (isScriptStakeAddress(addr)) {
          trezorDeregCert.scriptHash = cred;
        } else {
          trezorDeregCert.keyHash = cred;
        }
        trezorCertificate.push(trezorDeregCert);
        break;
      }
      case CertificateKind.StakeDelegation: {
        const delegation = cert.StakeDelegation;
        const cred = Object.values(delegation.stake_credential)[0];
        const addr = getRewardAddressFromCred(cred, networkId);
        const ownedCred = getOwnedCred([accountData.keys], cred, "stake");
        const delegCert = {
          type: lib$5.PROTO.CardanoCertificateType.STAKE_DELEGATION,
          pool: delegation.pool_keyhash
        };
        if (ownedCred) {
          delegCert.path = getStringDerivationPath(ownedCred.path);
        } else if (isScriptStakeAddress(addr)) {
          delegCert.scriptHash = cred;
        } else {
          delegCert.keyHash = cred;
        }
        trezorCertificate.push(delegCert);
        break;
      }
      case CertificateKind.PoolRegistration:
      case CertificateKind.PoolRetirement:
        throw new Error("Error: generateTrezorCertificates: pool registration / retire cert no supported yet.");
      case CertificateKind.VoteDelegation: {
        const delegation = cert.VoteDelegation;
        const cred = Object.values(delegation.stake_credential)[0];
        const addr = getRewardAddressFromCred(cred, networkId);
        const drep = delegation.drep;
        const ownedCred = getOwnedCred([accountData.keys], cred, "stake");
        const trezorVoteDelegCert = {
          type: lib$5.PROTO.CardanoCertificateType.VOTE_DELEGATION
        };
        if (ownedCred) {
          trezorVoteDelegCert.path = getStringDerivationPath(ownedCred.path);
        } else if (isScriptStakeAddress(addr)) {
          trezorVoteDelegCert.scriptHash = cred;
        } else {
          trezorVoteDelegCert.keyHash = cred;
        }
        if (typeof drep === "string") {
          if (drep === "AlwaysAbstain") {
            trezorVoteDelegCert.dRep = { type: lib$5.PROTO.CardanoDRepType.ABSTAIN };
          } else {
            trezorVoteDelegCert.dRep = { type: lib$5.PROTO.CardanoDRepType.NO_CONFIDENCE };
          }
        } else {
          const keyHash = drep.KeyHash;
          if (keyHash) {
            trezorVoteDelegCert.dRep = {
              type: lib$5.PROTO.CardanoDRepType.KEY_HASH,
              keyHash
            };
          } else {
            trezorVoteDelegCert.dRep = {
              type: lib$5.PROTO.CardanoDRepType.SCRIPT_HASH,
              scriptHash: drep.ScriptHash
            };
          }
        }
        trezorCertificate.push(trezorVoteDelegCert);
        break;
      }
      default:
        throw new Error(`generateTrezorCertificates: unsupported certificate type`);
    }
  }
  return trezorCertificate;
}
function generateTrezorMetadataFromHash(metadataHash) {
  return {
    hash: metadataHash
  };
}
function generateTrezorMetadata(accountData, metadata) {
  if (isCatalystVotingRegistrationMetadata(metadata)) {
    const metadatum = getCatalystRegistrationMetadata(metadata).get(BigNum.from_str("61284"));
    const catalyst_meta = JSON.parse(decode_metadatum_to_json_str(metadatum, MetadataJsonSchema.BasicConversions));
    const votingPublicKey = catalyst_meta["1"];
    const nonce = catalyst_meta["4"];
    const rewardAddr = Address.from_hex(catalyst_meta["3"].replace(/^0x/, ""));
    const rewardAddrBech32 = rewardAddr.to_bech32();
    safeFreeCSLObject(rewardAddr);
    const cred = getAddressCredentials(rewardAddrBech32);
    const paymentCred = getOwnedCred([accountData.keys], cred.paymentCred);
    const stakeCred = getOwnedCred([accountData.keys], cred.stakeCred, "stake");
    if (!paymentCred || !stakeCred) {
      throw new Error("Error: generateTrezorMetadata: reward address credentials not found");
    }
    const stakingKeyPath = getStringDerivationPath(stakeCred.path);
    return {
      cVoteRegistrationParameters: {
        votePublicKey: votingPublicKey.replace(/^0x/, ""),
        stakingPath: stakingKeyPath,
        paymentAddressParameters: generateTrezorAddressParameters(accountData, rewardAddrBech32, paymentCred, cred.stakeCred),
        nonce: String(nonce),
        format: lib$5.PROTO.CardanoCVoteRegistrationFormat.CIP15
      }
    };
  } else {
    return {
      hash: blake2b256Str(Buffer$1.from(metadata.to_bytes()))
    };
  }
}
function useTrezorDevice() {
  return {
    initiateTrezor,
    getTrezorPublicKey,
    signTxWithTrezor,
    getWitnessesWithTrezor,
    getTrezorDerivationTypeFromWalletId
  };
}
export {
  useTrezorDevice as a,
  trezorDerivationType as t,
  useLedgerDevice as u
};
