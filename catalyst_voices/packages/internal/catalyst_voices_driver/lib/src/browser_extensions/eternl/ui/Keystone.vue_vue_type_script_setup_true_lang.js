import { jk as safeBufferExports, b3 as toHexString, i4 as freeCSLObjects, jl as COSESign1, iq as toHexBuffer, bF as getAccountKeyDetails, a_ as decryptText, b8 as createCSLPrvKey, jm as HeaderMap, jn as Label, jo as AlgorithmId, jp as CBORValue, jq as ProtectedHeaderMap, jr as Headers, js as COSESign1Builder, jt as KeyType, ju as COSEKey, jv as BigNum, jw as Int, dn as getAugmentedNamespace, dw as commonjsGlobal, dq as Buffer$1$1, jx as browser, jy as sha_jsExports, jz as util, dv as process$1, jA as shams, jB as callBound$1, jC as hasPropertyDescriptors_1, jD as defineDataProperty, jE as callBindExports, ji as bignumberExports, dz as require$$0$3, dA as minimalisticAssert, dB as utils$l, dC as inherits_browserExports, dD as hash$3, dE as requireBrorand, dF as hmacDrbg, du as requireCryptoBrowserify, jF as ripemd160, dt as commonjsRequire, dp as eventsExports, jG as sha256$3, ds as getDefaultExportFromCjs, jj as getStringDerivationPath, dc as purpose, j3 as coin$1, jH as Bip32PublicKey, b0 as safeFreeCSLObject, aY as checkEpochParams, ba as TransactionWitnessSet, b7 as Vkeywitnesses, j6 as hasWitness, b4 as Transaction, b5 as getTransactionJSONFromCSL, b6 as reinjectWitnessSet, aZ as ErrorSignTx, j8 as getFilteredUtxoList, e4 as getRandomUUID, ja as createPubKey, jI as getCSLBip32PublicKey, jJ as getChangeAddress, jK as getCSLBip32PrivateKey, iw as getCalculatedChainTip, eI as getAddressCredentials, eJ as getOwnedCred, jL as PublicKey, bz as toHexArray, d as defineComponent, z as ref, C as onMounted, aG as onUnmounted, o as openBlock, c as createElementBlock, a7 as useQuasar, jM as getLastCameraId, D as watch, bL as onBeforeUnmount, a as createBlock, h as withCtx, e as createBaseVNode, q as createVNode, u as unref, t as toDisplayString, j as createCommentVNode, H as Fragment, I as renderList, V as nextTick, jN as setLastCameraId } from "./index.js";
import { u as useTranslation } from "./useTranslation.js";
import { b as browser$1 } from "./browser.js";
import { _ as _sfc_main$3 } from "./GridHeadline.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$5 } from "./GridTextArea.vue_vue_type_script_setup_true_lang.js";
import { _ as _sfc_main$4 } from "./GridLoading.vue_vue_type_script_setup_true_lang.js";
import { M as Modal } from "./Modal.js";
import { G as GridButtonSecondary } from "./GridButtonSecondary.js";
import { _ as _sfc_main$6 } from "./GridButtonPrimary.vue_vue_type_script_setup_true_lang.js";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends$2(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key2, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key2, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
  return c > 3 && r && Object.defineProperty(target, key2, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function") throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key2 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f2) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key2], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key2] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f2, name2, prefix) {
  if (typeof name2 === "symbol") name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter$5(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$5(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding$3 = Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding$3(o, m, p);
}
function __values$1(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f2) {
    return function(v) {
      return Promise.resolve(v).then(f2, reject);
    };
  }
  function verb(n, f2) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f2) i[n] = f2(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v) {
    if (f2(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f2) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f2 ? f2(v) : v;
    } : f2;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values$1 === "function" ? __values$1(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve2, reject) {
        v = o[n](v), settle(resolve2, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve2, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve2({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault$3 = Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
};
var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function(o2) {
    var ar = [];
    for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};
function __importStar$3(mod2) {
  if (mod2 && mod2.__esModule) return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding$3(result, mod2, k[i]);
  }
  __setModuleDefault$3(result, mod2);
  return result;
}
function __importDefault$9(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e = new Error(message2);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next2() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next2);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next2, function(e) {
            fail(e);
            return next2();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next2();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
const tslib_es6 = {
  __extends: __extends$2,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter: __awaiter$5,
  __generator: __generator$5,
  __createBinding: __createBinding$3,
  __exportStar,
  __values: __values$1,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar: __importStar$3,
  __importDefault: __importDefault$9,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter: __awaiter$5,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding: __createBinding$3,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends: __extends$2,
  __generator: __generator$5,
  __importDefault: __importDefault$9,
  __importStar: __importStar$3,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __rewriteRelativeImportExtension,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values: __values$1,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
var _Buffer = safeBufferExports.Buffer;
function base$6(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode3(source) {
    if (Array.isArray(source) || source instanceof Uint8Array) {
      source = _Buffer.from(source);
    }
    if (!_Buffer.isBuffer(source)) {
      throw new TypeError("Expected Buffer");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      pbegin++;
    }
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return _Buffer.alloc(0);
    }
    var psz = 0;
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (psz < source.length) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      psz++;
    }
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
    vch.fill(0, 0, zeroes);
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode3,
    decodeUnsafe,
    decode: decode2
  };
}
var src$1 = base$6;
const prepareSignData = (walletData, accountData, password, address2) => {
  var _a;
  if (!((_a = walletData.wallet.rootKey) == null ? void 0 : _a.prv)) {
    return { prv: null, addressBytes: null };
  }
  const keyDetails = getAccountKeyDetails(address2, accountData);
  const credBytes = keyDetails.credBytes;
  const path = keyDetails.accountCredAndType.cred.path;
  if (!credBytes) {
    return { prv: null, addressBytes: null };
  }
  const rootPrvKey = decryptText(walletData.wallet.rootKey.prv, password ?? "", walletData.wallet.rootKey.v ?? "");
  if (rootPrvKey.length === 0) {
    return { prv: null, addressBytes: null };
  }
  return { prv: createCSLPrvKey(rootPrvKey, path), addressBytes: credBytes };
};
const createSignDataBuilder = (addressBytes, payload, hashed) => {
  const free = [];
  const protectedHeaders = HeaderMap.new();
  free.push(protectedHeaders);
  const labelAlgoid = Label.from_algorithm_id(AlgorithmId.EdDSA);
  free.push(labelAlgoid);
  const labelAddress = Label.new_text("address");
  free.push(labelAddress);
  const valueAddress = CBORValue.new_bytes(addressBytes);
  free.push(valueAddress);
  protectedHeaders.set_algorithm_id(labelAlgoid);
  protectedHeaders.set_header(labelAddress, valueAddress);
  const protectedSerialized = ProtectedHeaderMap.new(protectedHeaders);
  free.push(protectedSerialized);
  const unprotectedHeaders = HeaderMap.new();
  free.push(unprotectedHeaders);
  const headers = Headers.new(protectedSerialized, unprotectedHeaders);
  free.push(headers);
  const builder2 = COSESign1Builder.new(headers, toHexBuffer(payload), false);
  if (hashed) {
    builder2.hash_payload();
  }
  freeCSLObjects(free);
  return builder2;
};
const createCOSEKeyHex = (pubKeyBytes) => {
  const free = [];
  const okpKey = Label.from_key_type(KeyType.OKP);
  free.push(okpKey);
  const key2 = COSEKey.new(okpKey);
  free.push(key2);
  const algId = Label.from_algorithm_id(AlgorithmId.EdDSA);
  free.push(algId);
  const big1 = BigNum.from_str("1");
  free.push(big1);
  const big2 = BigNum.from_str("2");
  free.push(big2);
  const neg1 = Int.new_negative(big1);
  free.push(neg1);
  const neg22 = Int.new_negative(big2);
  free.push(neg22);
  const labelNeg1 = Label.new_int(neg1);
  free.push(labelNeg1);
  const labelNeg2 = Label.new_int(neg22);
  free.push(labelNeg2);
  const int6 = Int.new_i32(6);
  free.push(int6);
  const cborInt6 = CBORValue.new_int(int6);
  free.push(cborInt6);
  const cborPubKey = CBORValue.new_bytes(pubKeyBytes);
  free.push(cborPubKey);
  key2.set_algorithm_id(algId);
  key2.set_header(labelNeg1, cborInt6);
  key2.set_header(labelNeg2, cborPubKey);
  const keyHex = toHexString(key2.to_bytes());
  freeCSLObjects(free);
  return keyHex;
};
const signData = (walletData, accountData, password, address2, payload) => {
  const free = [];
  const keyAndBytes = prepareSignData(walletData, accountData, password, address2);
  if (!keyAndBytes.prv || !keyAndBytes.addressBytes) {
    return null;
  }
  const prvKey = keyAndBytes.prv.to_raw_key();
  free.push(prvKey);
  const pubKey = prvKey.to_public();
  free.push(pubKey);
  const builder2 = createSignDataBuilder(keyAndBytes.addressBytes, payload);
  free.push(builder2);
  const sigStruc = builder2.make_data_to_sign();
  free.push(sigStruc);
  const signedSigStruc = prvKey.sign(sigStruc.to_bytes());
  free.push(signedSigStruc);
  const coseSign1 = builder2.build(signedSigStruc.to_bytes());
  free.push(coseSign1);
  const signatureHex = toHexString(coseSign1.to_bytes());
  const keyHex = createCOSEKeyHex(pubKey.as_bytes());
  freeCSLObjects(free);
  return {
    signature: signatureHex,
    key: keyHex
  };
};
const verifyData = (data, address2, payload) => {
  const coseSign1_verify = COSESign1.from_bytes(toHexBuffer(data.signature));
  const signedSigStruc_verify = coseSign1_verify.signed_data();
  const isSame = toHexString(signedSigStruc_verify.payload()) === payload;
  console.warn("verifyData: isSame:", isSame);
  return isSame;
};
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var dist$j = {};
var utils$k = {};
var stringHelper = {};
var commonjsBrowser$3 = {};
var v1$8 = {};
var rng$8 = {};
Object.defineProperty(rng$8, "__esModule", {
  value: true
});
rng$8.default = rng$7;
let getRandomValues$4;
const rnds8$4 = new Uint8Array(16);
function rng$7() {
  if (!getRandomValues$4) {
    getRandomValues$4 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues$4) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues$4(rnds8$4);
}
var stringify$8 = {};
var validate$8 = {};
var regex$3 = {};
Object.defineProperty(regex$3, "__esModule", {
  value: true
});
regex$3.default = void 0;
var _default$P = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
regex$3.default = _default$P;
Object.defineProperty(validate$8, "__esModule", {
  value: true
});
validate$8.default = void 0;
var _regex$3 = _interopRequireDefault$z(regex$3);
function _interopRequireDefault$z(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function validate$7(uuid) {
  return typeof uuid === "string" && _regex$3.default.test(uuid);
}
var _default$O = validate$7;
validate$8.default = _default$O;
Object.defineProperty(stringify$8, "__esModule", {
  value: true
});
stringify$8.default = void 0;
stringify$8.unsafeStringify = unsafeStringify$3;
var _validate$b = _interopRequireDefault$y(validate$8);
function _interopRequireDefault$y(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const byteToHex$4 = [];
for (let i = 0; i < 256; ++i) {
  byteToHex$4.push((i + 256).toString(16).slice(1));
}
function unsafeStringify$3(arr, offset = 0) {
  return byteToHex$4[arr[offset + 0]] + byteToHex$4[arr[offset + 1]] + byteToHex$4[arr[offset + 2]] + byteToHex$4[arr[offset + 3]] + "-" + byteToHex$4[arr[offset + 4]] + byteToHex$4[arr[offset + 5]] + "-" + byteToHex$4[arr[offset + 6]] + byteToHex$4[arr[offset + 7]] + "-" + byteToHex$4[arr[offset + 8]] + byteToHex$4[arr[offset + 9]] + "-" + byteToHex$4[arr[offset + 10]] + byteToHex$4[arr[offset + 11]] + byteToHex$4[arr[offset + 12]] + byteToHex$4[arr[offset + 13]] + byteToHex$4[arr[offset + 14]] + byteToHex$4[arr[offset + 15]];
}
function stringify$7(arr, offset = 0) {
  const uuid = unsafeStringify$3(arr, offset);
  if (!(0, _validate$b.default)(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _default$N = stringify$7;
stringify$8.default = _default$N;
Object.defineProperty(v1$8, "__esModule", {
  value: true
});
v1$8.default = void 0;
var _rng$7 = _interopRequireDefault$x(rng$8);
var _stringify$b = stringify$8;
function _interopRequireDefault$x(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
let _nodeId$4;
let _clockseq$4;
let _lastMSecs$4 = 0;
let _lastNSecs$4 = 0;
function v1$7(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId$4;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq$4;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng$7.default)();
    if (node == null) {
      node = _nodeId$4 = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq$4 = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs$4 + 1;
  const dt = msecs - _lastMSecs$4 + (nsecs - _lastNSecs$4) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs$4) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs$4 = msecs;
  _lastNSecs$4 = nsecs;
  _clockseq$4 = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || (0, _stringify$b.unsafeStringify)(b);
}
var _default$M = v1$7;
v1$8.default = _default$M;
var v3$8 = {};
var v35$8 = {};
var parse$8 = {};
Object.defineProperty(parse$8, "__esModule", {
  value: true
});
parse$8.default = void 0;
var _validate$a = _interopRequireDefault$w(validate$8);
function _interopRequireDefault$w(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function parse$7(uuid) {
  if (!(0, _validate$a.default)(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var _default$L = parse$7;
parse$8.default = _default$L;
Object.defineProperty(v35$8, "__esModule", {
  value: true
});
v35$8.URL = v35$8.DNS = void 0;
v35$8.default = v35$7;
var _stringify$a = stringify$8;
var _parse$3 = _interopRequireDefault$v(parse$8);
function _interopRequireDefault$v(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function stringToBytes$4(str) {
  str = unescape(encodeURIComponent(str));
  const bytes2 = [];
  for (let i = 0; i < str.length; ++i) {
    bytes2.push(str.charCodeAt(i));
  }
  return bytes2;
}
const DNS$4 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
v35$8.DNS = DNS$4;
const URL$5 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
v35$8.URL = URL$5;
function v35$7(name2, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes$4(value);
    }
    if (typeof namespace === "string") {
      namespace = (0, _parse$3.default)(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes2[i];
      }
      return buf;
    }
    return (0, _stringify$a.unsafeStringify)(bytes2);
  }
  try {
    generateUUID.name = name2;
  } catch (err2) {
  }
  generateUUID.DNS = DNS$4;
  generateUUID.URL = URL$5;
  return generateUUID;
}
var md5$8 = {};
Object.defineProperty(md5$8, "__esModule", {
  value: true
});
md5$8.default = void 0;
function md5$7(bytes2) {
  if (typeof bytes2 === "string") {
    const msg2 = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg2.length);
    for (let i = 0; i < msg2.length; ++i) {
      bytes2[i] = msg2.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray$4(wordsToMd5$4(bytesToWords$4(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray$4(input) {
  const output2 = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output2.push(hex);
  }
  return output2;
}
function getOutputLength$4(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5$4(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength$4(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff$4(a, b, c, d, x[i], 7, -680876936);
    d = md5ff$4(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff$4(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff$4(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff$4(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff$4(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff$4(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff$4(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff$4(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff$4(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff$4(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff$4(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff$4(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff$4(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff$4(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff$4(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg$4(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg$4(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg$4(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg$4(b, c, d, a, x[i], 20, -373897302);
    a = md5gg$4(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg$4(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg$4(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg$4(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg$4(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg$4(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg$4(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg$4(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg$4(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg$4(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg$4(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg$4(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh$4(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh$4(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh$4(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh$4(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh$4(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh$4(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh$4(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh$4(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh$4(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh$4(d, a, b, c, x[i], 11, -358537222);
    c = md5hh$4(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh$4(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh$4(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh$4(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh$4(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh$4(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii$4(a, b, c, d, x[i], 6, -198630844);
    d = md5ii$4(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii$4(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii$4(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii$4(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii$4(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii$4(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii$4(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii$4(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii$4(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii$4(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii$4(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii$4(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii$4(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii$4(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii$4(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd$4(a, olda);
    b = safeAdd$4(b, oldb);
    c = safeAdd$4(c, oldc);
    d = safeAdd$4(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords$4(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output2 = new Uint32Array(getOutputLength$4(length8));
  for (let i = 0; i < length8; i += 8) {
    output2[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output2;
}
function safeAdd$4(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft$4(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn$4(q, a, b, x, s, t) {
  return safeAdd$4(bitRotateLeft$4(safeAdd$4(safeAdd$4(a, q), safeAdd$4(x, t)), s), b);
}
function md5ff$4(a, b, c, d, x, s, t) {
  return md5cmn$4(b & c | ~b & d, a, b, x, s, t);
}
function md5gg$4(a, b, c, d, x, s, t) {
  return md5cmn$4(b & d | c & ~d, a, b, x, s, t);
}
function md5hh$4(a, b, c, d, x, s, t) {
  return md5cmn$4(b ^ c ^ d, a, b, x, s, t);
}
function md5ii$4(a, b, c, d, x, s, t) {
  return md5cmn$4(c ^ (b | ~d), a, b, x, s, t);
}
var _default$K = md5$7;
md5$8.default = _default$K;
Object.defineProperty(v3$8, "__esModule", {
  value: true
});
v3$8.default = void 0;
var _v$7 = _interopRequireDefault$u(v35$8);
var _md$4 = _interopRequireDefault$u(md5$8);
function _interopRequireDefault$u(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const v3$7 = (0, _v$7.default)("v3", 48, _md$4.default);
var _default$J = v3$7;
v3$8.default = _default$J;
var v4$8 = {};
var native$3 = {};
Object.defineProperty(native$3, "__esModule", {
  value: true
});
native$3.default = void 0;
const randomUUID$3 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var _default$I = {
  randomUUID: randomUUID$3
};
native$3.default = _default$I;
Object.defineProperty(v4$8, "__esModule", {
  value: true
});
v4$8.default = void 0;
var _native$3 = _interopRequireDefault$t(native$3);
var _rng$6 = _interopRequireDefault$t(rng$8);
var _stringify$9 = stringify$8;
function _interopRequireDefault$t(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function v4$7(options, buf, offset) {
  if (_native$3.default.randomUUID && !buf && !options) {
    return _native$3.default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || _rng$6.default)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0, _stringify$9.unsafeStringify)(rnds);
}
var _default$H = v4$7;
v4$8.default = _default$H;
var v5$8 = {};
var sha1$8 = {};
Object.defineProperty(sha1$8, "__esModule", {
  value: true
});
sha1$8.default = void 0;
function f$4(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL$4(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1$7(bytes2) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    const msg2 = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (let i = 0; i < msg2.length; ++i) {
      bytes2.push(msg2.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  const l = bytes2.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes2[i * 64 + j * 4] << 24 | bytes2[i * 64 + j * 4 + 1] << 16 | bytes2[i * 64 + j * 4 + 2] << 8 | bytes2[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL$4(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL$4(a, 5) + f$4(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL$4(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var _default$G = sha1$7;
sha1$8.default = _default$G;
Object.defineProperty(v5$8, "__esModule", {
  value: true
});
v5$8.default = void 0;
var _v$6 = _interopRequireDefault$s(v35$8);
var _sha$3 = _interopRequireDefault$s(sha1$8);
function _interopRequireDefault$s(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const v5$7 = (0, _v$6.default)("v5", 80, _sha$3.default);
var _default$F = v5$7;
v5$8.default = _default$F;
var nil$4 = {};
Object.defineProperty(nil$4, "__esModule", {
  value: true
});
nil$4.default = void 0;
var _default$E = "00000000-0000-0000-0000-000000000000";
nil$4.default = _default$E;
var version$9 = {};
Object.defineProperty(version$9, "__esModule", {
  value: true
});
version$9.default = void 0;
var _validate$9 = _interopRequireDefault$r(validate$8);
function _interopRequireDefault$r(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function version$8(uuid) {
  if (!(0, _validate$9.default)(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var _default$D = version$8;
version$9.default = _default$D;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function get() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function get() {
      return _parse2.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function get() {
      return _stringify2.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function get() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function get() {
      return _v22.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function get() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function get() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function get() {
      return _validate2.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function get() {
      return _version.default;
    }
  });
  var _v2 = _interopRequireDefault2(v1$8);
  var _v22 = _interopRequireDefault2(v3$8);
  var _v3 = _interopRequireDefault2(v4$8);
  var _v4 = _interopRequireDefault2(v5$8);
  var _nil = _interopRequireDefault2(nil$4);
  var _version = _interopRequireDefault2(version$9);
  var _validate2 = _interopRequireDefault2(validate$8);
  var _stringify2 = _interopRequireDefault2(stringify$8);
  var _parse2 = _interopRequireDefault2(parse$8);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(commonjsBrowser$3);
var coin = {};
Object.defineProperty(coin, "__esModule", { value: true });
coin.getCoinSymbol = void 0;
function getCoinSymbol(coinType) {
  var _a;
  return (_a = {
    0: "BTC",
    2: "LTC",
    3: "DOGE",
    4: "RDD",
    5: "DASH",
    6: "PPC",
    7: "NMC",
    8: "FTC",
    9: "XCP",
    10: "BLK",
    11: "NSR",
    12: "NBT",
    13: "MZC",
    14: "VIA",
    15: "XCH",
    16: "RBY",
    17: "GRS",
    18: "DGC",
    19: "CCN",
    20: "DGB",
    22: "MONA",
    23: "CLAM",
    24: "XPM",
    25: "NEOS",
    26: "JBS",
    27: "ZRC",
    28: "VTC",
    29: "NXT",
    30: "BURST",
    31: "MUE",
    32: "ZOOM",
    33: "VASH",
    34: "CDN",
    35: "SDC",
    36: "PKB",
    37: "PND",
    38: "START",
    39: "MOIN",
    40: "EXP",
    41: "EMC2",
    42: "DCR",
    43: "XEM",
    44: "PART",
    45: "ARG",
    48: "SHR",
    49: "GCR",
    50: "NVC",
    51: "AC",
    52: "BTCD",
    53: "DOPE",
    54: "TPC",
    55: "AIB",
    56: "EDRC",
    57: "SYS",
    58: "SLR",
    59: "SMLY",
    60: "ETH",
    61: "ETC",
    62: "PSB",
    63: "LDCN",
    65: "XBC",
    66: "IOP",
    67: "NXS",
    68: "INSN",
    69: "OK",
    70: "BRIT",
    71: "CMP",
    72: "CRW",
    73: "BELA",
    74: "ICX",
    75: "FJC",
    76: "MIX",
    77: "XVG",
    78: "EFL",
    79: "CLUB",
    80: "RICHX",
    81: "POT",
    82: "QRK",
    83: "TRC",
    84: "GRC",
    85: "AUR",
    86: "IXC",
    87: "NLG",
    88: "BITB",
    89: "BTA",
    90: "XMY",
    91: "BSD",
    92: "UNO",
    93: "MTR",
    94: "GB",
    95: "SHM",
    96: "CRX",
    97: "BIQ",
    98: "EVO",
    99: "STO",
    100: "BIGUP",
    101: "GAME",
    102: "DLC",
    103: "ZYD",
    104: "DBIC",
    105: "STRAT",
    106: "SH",
    107: "MARS",
    108: "UBQ",
    109: "PTC",
    110: "NRO",
    111: "ARK",
    112: "USC",
    113: "THC",
    114: "LINX",
    115: "ECN",
    116: "DNR",
    117: "PINK",
    118: "ATOM",
    119: "PIVX",
    120: "FLASH",
    121: "ZEN",
    122: "PUT",
    123: "ZNY",
    124: "UNIFY",
    125: "XST",
    126: "BRK",
    127: "VC",
    128: "XMR",
    129: "VOX",
    130: "NAV",
    131: "FCT",
    132: "EC",
    133: "ZEC",
    134: "LSK",
    135: "STEEM",
    136: "XZC",
    137: "RBTC",
    139: "RPT",
    140: "LBC",
    141: "KMD",
    142: "BSQ",
    143: "RIC",
    144: "XRP",
    145: "BCH",
    146: "NEBL",
    147: "ZCL",
    148: "XLM",
    149: "NLC2",
    150: "WHL",
    151: "ERC",
    152: "DMD",
    153: "BTM",
    154: "BIO",
    155: "XWCC",
    156: "BTG",
    157: "BTC2X",
    158: "SSN",
    159: "TOA",
    160: "BTX",
    161: "ACC",
    162: "BCO",
    163: "ELLA",
    164: "PIRL",
    165: "XNO",
    166: "VIVO",
    167: "FRST",
    168: "HNC",
    169: "BUZZ",
    170: "MBRS",
    171: "HC",
    172: "HTML",
    173: "ODN",
    174: "ONX",
    175: "RVN",
    176: "GBX",
    177: "BTCZ",
    178: "POA",
    179: "NYC",
    180: "MXT",
    181: "WC",
    182: "MNX",
    183: "BTCP",
    184: "MUSIC",
    185: "BCA",
    186: "CRAVE",
    187: "STAK",
    188: "WBTC",
    189: "LCH",
    190: "EXCL",
    192: "LCC",
    193: "XFE",
    194: "EOS",
    195: "TRX",
    196: "KOBO",
    197: "HUSH",
    198: "BAN",
    199: "ETF",
    200: "OMNI",
    201: "BIFI",
    202: "UFO",
    203: "CNMC",
    204: "BCN",
    205: "RIN",
    206: "ATP",
    207: "EVT",
    208: "ATN",
    209: "BIS",
    210: "NEET",
    211: "BOPO",
    212: "OOT",
    213: "ALIAS",
    214: "MONK",
    215: "BOXY",
    216: "FLO",
    217: "MEC",
    218: "BTDX",
    219: "XAX",
    220: "ANON",
    221: "LTZ",
    222: "BITG",
    223: "ICP",
    224: "SMART",
    225: "XUEZ",
    226: "HLM",
    227: "WEB",
    228: "ACM",
    229: "NOS",
    230: "BITC",
    231: "HTH",
    232: "TZC",
    233: "VAR",
    234: "IOV",
    235: "FIO",
    236: "BSV",
    237: "DXN",
    238: "QRL",
    239: "PCX",
    240: "LOKI",
    242: "NIM",
    243: "SOV",
    244: "JCT",
    245: "SLP",
    246: "EWT",
    247: "UC",
    248: "EXOS",
    249: "ECA",
    250: "SOOM",
    251: "XRD",
    252: "FREE",
    253: "NPW",
    254: "BST",
    256: "NANO",
    257: "BTCC",
    259: "ZEST",
    260: "ABT",
    261: "PION",
    262: "DT3",
    263: "ZBUX",
    264: "KPL",
    265: "TPAY",
    266: "ZILLA",
    267: "ANK",
    268: "BCC",
    269: "HPB",
    270: "ONE",
    271: "SBC",
    272: "IPC",
    273: "DMTC",
    274: "OGC",
    275: "SHIT",
    276: "ANDES",
    277: "AREPA",
    278: "BOLI",
    279: "RIL",
    280: "HTR",
    281: "FCTID",
    282: "BRAVO",
    283: "ALGO",
    284: "BZX",
    285: "GXX",
    286: "HEAT",
    287: "XDN",
    288: "FSN",
    289: "CPC",
    290: "BOLD",
    291: "IOST",
    292: "TKEY",
    293: "USE",
    294: "BCZ",
    295: "IOC",
    296: "ASF",
    297: "MASS",
    298: "FAIR",
    299: "NUKO",
    300: "GNX",
    301: "DIVI",
    302: "CMT",
    303: "EUNO",
    304: "IOTX",
    305: "ONION",
    306: "8BIT",
    307: "ATC",
    308: "BTS",
    309: "CKB",
    310: "UGAS",
    311: "ADS",
    312: "ARA",
    313: "ZIL",
    314: "MOAC",
    315: "SWTC",
    316: "VNSC",
    317: "PLUG",
    318: "MAN",
    319: "ECC",
    320: "RPD",
    321: "RAP",
    322: "GARD",
    323: "ZER",
    324: "EBST",
    325: "SHARD",
    326: "MRX",
    327: "CMM",
    328: "BLOCK",
    329: "AUDAX",
    330: "LUNA",
    331: "ZPM",
    332: "KUVA",
    333: "MEM",
    334: "CS",
    335: "SWIFT",
    336: "FIX",
    337: "CPC",
    338: "VGO",
    339: "DVT",
    340: "N8V",
    341: "MTNS",
    342: "BLAST",
    343: "DCT",
    344: "AUX",
    345: "USDP",
    346: "HTDF",
    347: "YEC",
    348: "QLC",
    349: "TEA",
    350: "ARW",
    351: "MDM",
    352: "CYB",
    353: "LTO",
    354: "DOT",
    355: "AEON",
    356: "RES",
    357: "AYA",
    358: "DAPS",
    359: "CSC",
    360: "VSYS",
    361: "NOLLAR",
    362: "XNOS",
    363: "CPU",
    364: "LAMB",
    365: "VCT",
    366: "CZR",
    367: "ABBC",
    368: "HET",
    369: "XAS",
    370: "VDL",
    371: "MED",
    372: "ZVC",
    373: "VESTX",
    374: "DBT",
    375: "SEOS",
    376: "MXW",
    377: "ZNZ",
    378: "XCX",
    379: "SOX",
    380: "NYZO",
    381: "ULC",
    382: "RYO",
    383: "KAL",
    384: "XSN",
    385: "DOGEC",
    386: "BMV",
    387: "QBC",
    388: "IMG",
    389: "QOS",
    390: "PKT",
    391: "LHD",
    392: "CENNZ",
    393: "HSN",
    394: "CRO",
    395: "UMBRU",
    396: "EVER",
    397: "NEAR",
    398: "XPC",
    399: "ZOC",
    400: "NIX",
    401: "UC",
    402: "GALI",
    403: "OLT",
    404: "XBI",
    405: "DONU",
    406: "EARTHS",
    407: "HDD",
    408: "SUGAR",
    409: "AILE",
    410: "TENT",
    411: "TAN",
    412: "AIN",
    413: "MSR",
    414: "SUMO",
    415: "ETN",
    416: "BYTZ",
    417: "WOW",
    418: "XTNC",
    419: "LTHN",
    420: "NODE",
    421: "AGM",
    422: "CCX",
    423: "TNET",
    424: "TELOS",
    425: "AION",
    426: "BC",
    427: "KTV",
    428: "ZCR",
    429: "ERG",
    430: "PESO",
    431: "BTC2",
    432: "XRPHD",
    433: "WE",
    434: "KSM",
    435: "PCN",
    436: "NCH",
    437: "ICU",
    438: "LN",
    439: "DTP",
    440: "BTCR",
    441: "AERGO",
    442: "XTH",
    443: "LV",
    444: "PHR",
    445: "VITAE",
    446: "COCOS",
    447: "DIN",
    448: "SPL",
    449: "YCE",
    450: "XLR",
    451: "KTS",
    452: "DGLD",
    453: "XNS",
    454: "EM",
    455: "SHN",
    456: "SEELE",
    457: "AE",
    458: "ODX",
    459: "KAVA",
    460: "GLEEC",
    461: "FIL",
    462: "RUTA",
    463: "CSDT",
    464: "ETI",
    465: "ZSLP",
    466: "ERE",
    467: "DX",
    468: "CPS",
    469: "BTH",
    470: "MESG",
    471: "FIMK",
    472: "AR",
    473: "OGO",
    474: "ROSE",
    475: "BARE",
    476: "GLEEC",
    477: "CLR",
    478: "RNG",
    479: "OLO",
    480: "PEXA",
    481: "MOON",
    482: "OCEAN",
    483: "BNT",
    484: "AMO",
    485: "FCH",
    486: "LAT",
    487: "COIN",
    488: "VEO",
    489: "CCA",
    490: "GFN",
    491: "BIP",
    492: "KPG",
    493: "FIN",
    494: "BAND",
    495: "DROP",
    496: "BHT",
    497: "LYRA",
    498: "CS",
    499: "RUPX",
    500: "THETA",
    501: "SOL",
    502: "THT",
    503: "CFX",
    504: "KUMA",
    505: "HASH",
    506: "CSPR",
    507: "EARTH",
    508: "EGLD",
    509: "CHI",
    510: "KOTO",
    511: "OTC",
    512: "XRD",
    513: "SEELEN",
    514: "AETH",
    515: "DNA",
    516: "VEE",
    517: "SIERRA",
    518: "LET",
    519: "BSC",
    520: "BTCV",
    521: "ABA",
    522: "SCC",
    523: "EDG",
    524: "AMS",
    525: "GOSS",
    526: "BU",
    527: "GRAM",
    528: "YAP",
    529: "SCRT",
    530: "NOVO",
    531: "GHOST",
    532: "HST",
    533: "PRJ",
    534: "YOU",
    535: "XHV",
    536: "BYND",
    537: "JOYS",
    538: "VAL",
    539: "FLOW",
    540: "SMESH",
    541: "SCDO",
    542: "IQS",
    543: "BIND",
    544: "COINEVO",
    545: "SCRIBE",
    546: "HYN",
    547: "BHP",
    548: "BBC",
    549: "MKF",
    550: "XDC",
    551: "STR",
    552: "SUM",
    553: "HBC",
    555: "BCS",
    556: "KTS",
    557: "LKR",
    558: "TAO",
    559: "XWC",
    560: "DEAL",
    561: "NTY",
    562: "TOP",
    564: "AG",
    565: "CICO",
    566: "IRIS",
    567: "NCG",
    568: "LRG",
    569: "SERO",
    570: "BDX",
    571: "CCXX",
    572: "SLS",
    573: "SRM",
    575: "VIVT",
    576: "BPS",
    577: "NKN",
    578: "ICL",
    579: "BONO",
    580: "PLC",
    581: "DUN",
    582: "DMCH",
    583: "CTC",
    584: "KELP",
    585: "GBCR",
    586: "XDAG",
    587: "PRV",
    588: "SCAP",
    589: "TFUEL",
    590: "GTM",
    591: "RNL",
    592: "GRIN",
    593: "MWC",
    594: "DOCK",
    595: "POLYX",
    596: "DIVER",
    597: "XEP",
    598: "APN",
    599: "TFC",
    600: "UTE",
    601: "MTC",
    602: "NC",
    603: "XINY",
    604: "DYN",
    605: "BUFS",
    606: "STOS",
    607: "TON",
    608: "TAFT",
    609: "HYDRA",
    610: "NOR",
    613: "WCN",
    614: "OPT",
    615: "PSWAP",
    616: "VAL",
    617: "XOR",
    618: "SSP",
    619: "DEI",
    621: "ZERO",
    622: "ALPHA",
    623: "BDECO",
    624: "NOBL",
    625: "EAST",
    626: "KDA",
    627: "SOUL",
    628: "LORE",
    629: "FNR",
    630: "NEXUS",
    631: "QTZ",
    632: "XMA",
    633: "CALL",
    634: "VAL",
    635: "POKT",
    636: "EMIT",
    637: "APTOS",
    638: "ADON",
    639: "BTSG",
    640: "LFC",
    641: "KCS",
    642: "KCC",
    643: "AZERO",
    644: "TREE",
    645: "LX",
    646: "XLN",
    647: "CIC",
    648: "ZRB",
    650: "UCO",
    651: "SFX",
    652: "SFT",
    653: "WSFX",
    654: "USDG",
    655: "WMP",
    659: "KOIN",
    660: "PIRATE",
    663: "SFRX",
    666: "ACT",
    667: "PRKL",
    668: "SSC",
    669: "GC",
    670: "PLGR",
    671: "MPLGR",
    672: "KNOX",
    673: "ZED",
    674: "CNDL",
    675: "WLKR",
    676: "WLKRR",
    677: "YUNGE",
    678: "Voken",
    679: "APL",
    680: "Evrynet",
    681: "NENG",
    682: "CHTA",
    685: "OAS",
    686: "KAR",
    688: "CET",
    690: "KLV",
    694: "VTBC",
    698: "VEIL",
    699: "GTB",
    700: "XDAI",
    701: "COM",
    702: "CCC",
    707: "MCOIN",
    711: "CHC",
    712: "SERF",
    713: "XTL",
    714: "BNB",
    715: "SIN",
    716: "DLN",
    717: "BONTE",
    718: "PEER",
    725: "MCX",
    730: "HEALIOS",
    731: "BMK",
    734: "DENTX",
    737: "ATOP",
    747: "CFG",
    750: "XPRT",
    757: "HONEY",
    768: "BALLZ",
    770: "COSA",
    771: "BR",
    775: "PLSR",
    776: "KEY",
    777: "BTW",
    780: "PLCUC",
    781: "PLCUX",
    782: "PLCU",
    784: "SUI",
    786: "UIDD",
    787: "ACA",
    788: "BNC",
    789: "TAU",
    799: "PDEX",
    800: "BEET",
    801: "DST",
    804: "ZKS",
    808: "QVT",
    809: "SDN",
    810: "ASTR",
    813: "MEER",
    818: "VET",
    819: "REEF",
    820: "CLO",
    822: "BDB",
    827: "ACE",
    828: "CCN",
    831: "CRUZ",
    832: "SAPP",
    833: "777",
    834: "KYAN",
    835: "AZR",
    836: "CFL",
    837: "DASHD",
    838: "TRTT",
    839: "UCR",
    840: "PNY",
    841: "BECN",
    842: "MONK",
    843: "SAGA",
    844: "SUV",
    845: "ESK",
    846: "OWO",
    847: "PEPS",
    848: "BIR",
    849: "MOBIC",
    850: "FLS",
    852: "DSM",
    853: "PRCY",
    858: "HVH",
    866: "MOB",
    868: "IF",
    877: "NAM",
    880: "LUM",
    883: "ZBC",
    886: "ADF",
    888: "NEO",
    889: "TOMO",
    890: "XSEL",
    896: "LKSC",
    898: "AS",
    899: "XEC",
    900: "LMO",
    901: "NXT",
    904: "HNT",
    907: "FIS",
    909: "SGE",
    911: "GERT",
    916: "META",
    917: "FRA",
    919: "CCD",
    921: "AVN",
    925: "DIP",
    928: "GHM",
    931: "RUNE",
    945: "UNLOCK",
    955: "LTP",
    960: "VKAX",
    966: "MATIC",
    968: "UNW",
    970: "TWINS",
    977: "TLOS",
    981: "TAFECO",
    985: "AU",
    987: "VCG",
    988: "XAZAB",
    989: "AIOZ",
    990: "CORE",
    991: "PEC",
    992: "UNT",
    993: "XRB",
    994: "QUAI",
    995: "CAPS",
    996: "OKT",
    997: "SUM",
    998: "LBTC",
    999: "BCD",
    1e3: "BTN",
    1001: "TT",
    1002: "BKT",
    1003: "NODL",
    1004: "PCOIN",
    1005: "TAO",
    1006: "HSK",
    1007: "FTM",
    1008: "RPG",
    1010: "HT",
    1011: "ELV",
    1013: "BIC",
    1020: "EVC",
    1022: "XRD",
    1023: "ONE",
    1024: "ONT",
    1025: "CZZ",
    1026: "KEX",
    1027: "MCM",
    1032: "BTCR",
    1042: "MFID",
    1111: "BBC",
    1120: "RISE",
    1122: "CMT",
    1128: "ETSC",
    1129: "DFI",
    1130: "DFI",
    1137: "$DAG",
    1145: "CDY",
    1155: "EFI",
    1170: "HOO",
    1234: "ALPH",
    1284: "GLMR",
    1285: "MOVR",
    1298: "WPC",
    1308: "WEI",
    1337: "DFC",
    1397: "HYC",
    1410: "TENTSLP",
    1510: "XSC",
    1512: "AAC",
    1533: "BEAM",
    1555: "APC",
    1616: "ELF",
    1618: "AUDL",
    1620: "ATH",
    1627: "LUME",
    1642: "NEW",
    1657: "BTA",
    1668: "NEOX",
    1669: "MEWC",
    1688: "BCX",
    1729: "XTZ",
    1776: "LBTC",
    1777: "BBP",
    1784: "JPYS",
    1789: "VEGA",
    1815: "ADA",
    1818: "CUBE",
    1856: "TES",
    1888: "ZTX",
    1899: "XEC",
    1901: "CLC",
    1919: "VIPS",
    1926: "CITY",
    1955: "XX",
    1977: "XMX",
    1984: "TRTL",
    1985: "SLRT",
    1986: "QTH",
    1987: "EGEM",
    1988: "MIRA",
    1989: "HODL",
    1990: "PHL",
    1991: "SC",
    1996: "MYT",
    1997: "POLIS",
    1998: "XMCC",
    1999: "COLX",
    2e3: "GIN",
    2001: "MNP",
    2002: "MLN",
    2017: "KIN",
    2018: "EOSC",
    2019: "GBT",
    2020: "PKC",
    2021: "SKT",
    2022: "XHT",
    2048: "MCASH",
    2049: "TRUE",
    2086: "KILT",
    2109: "SAMA",
    2112: "IoTE",
    2137: "XRG",
    2182: "CHZ",
    2221: "ASK",
    2301: "QTUM",
    2302: "ETP",
    2303: "GXC",
    2304: "CRP",
    2305: "ELA",
    2338: "SNOW",
    2365: "XIN",
    2570: "AOA",
    2718: "NAS",
    2894: "REOSC",
    2941: "BND",
    3003: "LUX",
    3030: "HBAR",
    3077: "COS",
    3276: "CCC",
    3333: "SXP",
    3377: "ROI",
    3381: "DYN",
    3383: "SEQ",
    3552: "DEO",
    3564: "DST",
    3601: "CY",
    4040: "FC8",
    4096: "YEE",
    4218: "IOTA",
    4219: "SMR",
    4242: "AXE",
    4343: "XYM",
    4444: "C4E",
    4919: "XVM",
    5006: "SBC",
    5248: "FIC",
    5353: "HNS",
    5404: "ISK",
    5467: "ALTME",
    5555: "FUND",
    5757: "STX",
    5895: "VOW",
    5920: "SLU",
    6060: "GO",
    6174: "MOI",
    6599: "RSC",
    6666: "BPA",
    6688: "SAFE",
    6779: "COTI",
    6969: "ROGER",
    7091: "TOPL",
    7331: "KLY",
    7341: "SHFT",
    7777: "BTV",
    8e3: "SKY",
    8192: "PAC",
    8217: "KLAY",
    8339: "BTQ",
    8444: "XCH",
    8680: "PLMNT",
    8888: "SBTC",
    8964: "NULS",
    8997: "BBC",
    8998: "JGC",
    8999: "BTP",
    9e3: "AVAX",
    9001: "ARB1",
    9002: "BOBA",
    9003: "LOOP",
    9004: "STRK",
    9005: "AVAXC",
    9006: "BSC",
    9797: "NRG",
    9888: "BTF",
    9999: "GOD",
    1e4: "FO",
    10226: "RTM",
    10291: "XRC",
    10605: "XPI",
    11111: "ESS",
    12345: "IPOS",
    12586: "MINA",
    13107: "BTY",
    13108: "YCC",
    14001: "WAX",
    15845: "SDGO",
    16181: "XTX",
    16754: "ARDR",
    18e3: "MTR",
    19165: "SAFE",
    19167: "FLUX",
    19169: "RITO",
    20036: "XND",
    21004: "C4EI",
    21888: "PCT",
    22504: "PWR",
    25252: "BELL",
    25718: "CHX",
    29223: "NEXA",
    31102: "ESN",
    33416: "TEO",
    33878: "BTCS",
    34952: "BTT",
    37992: "FXTC",
    39321: "AMA",
    42069: "FACT",
    43028: "AXIV",
    49262: "EVE",
    49344: "STASH",
    52752: "CELO",
    61616: "TH",
    65536: "KETH",
    69420: "GRLC",
    70007: "GWL",
    77777: "ZYN",
    88888: "RYO",
    99999: "WICC",
    100500: "HOME",
    101010: "STC",
    105105: "STRAX",
    111111: "KAS",
    161803: "APTA",
    200625: "AKA",
    200665: "GENOM",
    246529: "ATS",
    261131: "ZAMA",
    314159: "PI",
    333332: "VALUE",
    333333: "3333",
    424242: "X42",
    534352: "SCR",
    666666: "VITE",
    888888: "SEA",
    1048576: "AMAX",
    1171337: "ILT",
    1313114: "ETHO",
    1313500: "XERO",
    1712144: "LAX",
    3924011: "EPK",
    4741444: "HYD",
    5249353: "BCO",
    5249354: "BHD",
    5264462: "PTN",
    5655640: "VLX",
    5718350: "WAN",
    5741564: "WAVES",
    5741565: "WEST",
    6382179: "ABC",
    6517357: "CRM",
    7562605: "SEM",
    7567736: "ION",
    7777777: "FCT",
    7825266: "WGR",
    7825267: "OBSR",
    8163271: "AFS",
    15118976: "XDS",
    61717561: "AQUA",
    88888888: "HATCH",
    91927009: "kUSD",
    99999996: "GENS",
    99999997: "EQ",
    99999998: "FLUID",
    99999999: "QKC",
    608589380: "FVDC"
  }[coinType]) !== null && _a !== void 0 ? _a : "";
}
coin.getCoinSymbol = getCoinSymbol;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parsePath = exports.uuidStringify = exports.uuidParse = exports.toBuffer = exports.toHex = exports.uuid = void 0;
  const uuid = __importStar2(commonjsBrowser$3);
  exports.uuid = uuid;
  __exportStar2(coin, exports);
  function toHex2(buf) {
    return buf === void 0 ? "" : Buffer$1$1.from(buf).toString("hex");
  }
  exports.toHex = toHex2;
  function toBuffer(hex) {
    return Buffer$1$1.from(hex !== null && hex !== void 0 ? hex : "", "hex");
  }
  exports.toBuffer = toBuffer;
  function uuidParse(id) {
    return Buffer$1$1.from(uuid.parse(id));
  }
  exports.uuidParse = uuidParse;
  function uuidStringify(id) {
    return uuid.stringify(id);
  }
  exports.uuidStringify = uuidStringify;
  function parsePath(path) {
    const chunks = path.replace(/^m\//i, "").split("/");
    return chunks.map((chunk) => {
      const hardened = chunk.endsWith("'");
      return {
        index: Number(hardened ? chunk.substring(0, chunk.length - 1) : chunk),
        hardened
      };
    });
  }
  exports.parsePath = parsePath;
})(stringHelper);
var crypto$3 = {};
var dist$i = {};
var patchCBOR$1 = {};
var utils$j = {};
var lib$2 = {};
var cborSync$1 = { exports: {} };
var DataItem$3 = {};
Object.defineProperty(DataItem$3, "__esModule", { value: true });
DataItem$3.DataItem = void 0;
let DataItem$2 = class DataItem {
  constructor(data, tag) {
    this.setTag = (tag2) => {
      this.tag = tag2;
    };
    this.clearTag = () => {
      this.tag = void 0;
    };
    this.getTag = () => {
      return this.tag;
    };
    this.getData = () => {
      return this.data;
    };
    this.data = data;
    this.tag = tag;
  }
};
DataItem$3.DataItem = DataItem$2;
(function(module) {
  (function(global, factory) {
    if (module.exports) {
      module.exports = factory();
    } else {
      global.CBOR = factory();
    }
  })(commonjsGlobal, function() {
    const { DataItem: DataItem3 } = DataItem$3;
    var CBOR = function() {
      function BinaryHex(hex) {
        this.$hex = hex;
      }
      BinaryHex.prototype = {
        length: function() {
          return this.$hex.length / 2;
        },
        toString: function(format) {
          if (!format || format === "hex" || format === 16)
            return this.$hex;
          if (format === "utf-8") {
            var encoded = "";
            for (var i = 0; i < this.$hex.length; i += 2) {
              encoded += "%" + this.$hex.substring(i, i + 2);
            }
            return decodeURIComponent(encoded);
          }
          if (format === "latin") {
            var encoded = [];
            for (var i = 0; i < this.$hex.length; i += 2) {
              encoded.push(parseInt(this.$hex.substring(i, i + 2), 16));
            }
            return String.fromCharCode.apply(String, encoded);
          }
          throw new Error("Unrecognised format: " + format);
        }
      };
      BinaryHex.fromLatinString = function(latinString) {
        var hex = "";
        for (var i = 0; i < latinString.length; i++) {
          var pair = latinString.charCodeAt(i).toString(16);
          if (pair.length === 1)
            pair = "0" + pair;
          hex += pair;
        }
        return new BinaryHex(hex);
      };
      BinaryHex.fromUtf8String = function(utf8String) {
        var encoded = encodeURIComponent(utf8String);
        var hex = "";
        for (var i = 0; i < encoded.length; i++) {
          if (encoded.charAt(i) === "%") {
            hex += encoded.substring(i + 1, i + 3);
            i += 2;
          } else {
            var hexPair = encoded.charCodeAt(i).toString(16);
            if (hexPair.length < 2)
              hexPair = "0" + hexPair;
            hex += hexPair;
          }
        }
        return new BinaryHex(hex);
      };
      var semanticEncoders = [];
      var semanticDecoders = {};
      var notImplemented = function(label) {
        return function() {
          throw new Error(label + " not implemented");
        };
      };
      function Reader() {
      }
      Reader.prototype = {
        peekByte: notImplemented("peekByte"),
        readByte: notImplemented("readByte"),
        readChunk: notImplemented("readChunk"),
        readFloat16: function() {
          var half = this.readUint16();
          var exponent = (half & 32767) >> 10;
          var mantissa = half & 1023;
          var negative = half & 32768;
          if (exponent === 31) {
            if (mantissa === 0) {
              return negative ? -Infinity : Infinity;
            }
            return NaN;
          }
          var magnitude = exponent ? Math.pow(2, exponent - 25) * (1024 + mantissa) : Math.pow(2, -24) * mantissa;
          return negative ? -magnitude : magnitude;
        },
        readFloat32: function() {
          var intValue = this.readUint32();
          var exponent = (intValue & 2147483647) >> 23;
          var mantissa = intValue & 8388607;
          var negative = intValue & 2147483648;
          if (exponent === 255) {
            if (mantissa === 0) {
              return negative ? -Infinity : Infinity;
            }
            return NaN;
          }
          var magnitude = exponent ? Math.pow(2, exponent - 23 - 127) * (8388608 + mantissa) : Math.pow(2, -23 - 126) * mantissa;
          return negative ? -magnitude : magnitude;
        },
        readFloat64: function() {
          var int1 = this.readUint32(), int2 = this.readUint32();
          var exponent = int1 >> 20 & 2047;
          var mantissa = (int1 & 1048575) * 4294967296 + int2;
          var negative = int1 & 2147483648;
          if (exponent === 2047) {
            if (mantissa === 0) {
              return negative ? -Infinity : Infinity;
            }
            return NaN;
          }
          var magnitude = exponent ? Math.pow(2, exponent - 52 - 1023) * (4503599627370496 + mantissa) : Math.pow(2, -52 - 1022) * mantissa;
          return negative ? -magnitude : magnitude;
        },
        readUint16: function() {
          return this.readByte() * 256 + this.readByte();
        },
        readUint32: function() {
          return this.readUint16() * 65536 + this.readUint16();
        },
        readUint64: function() {
          return this.readUint32() * 4294967296 + this.readUint32();
        }
      };
      function Writer() {
      }
      Writer.prototype = {
        writeByte: notImplemented("writeByte"),
        result: notImplemented("result"),
        writeFloat16: notImplemented("writeFloat16"),
        writeFloat32: notImplemented("writeFloat32"),
        writeFloat64: notImplemented("writeFloat64"),
        writeUint16: function(value) {
          this.writeByte(value >> 8 & 255);
          this.writeByte(value & 255);
        },
        writeUint32: function(value) {
          this.writeUint16(value >> 16 & 65535);
          this.writeUint16(value & 65535);
        },
        writeUint64: function(value) {
          if (value >= 9007199254740992 || value <= -9007199254740992) {
            throw new Error("Cannot encode Uint64 of: " + value + " magnitude to big (floating point errors)");
          }
          this.writeUint32(Math.floor(value / 4294967296));
          this.writeUint32(value % 4294967296);
        },
        writeString: notImplemented("writeString"),
        canWriteBinary: function(chunk) {
          return false;
        },
        writeBinary: notImplemented("writeChunk")
      };
      function readHeaderRaw(reader) {
        var firstByte = reader.readByte();
        var majorType = firstByte >> 5, value = firstByte & 31;
        return { type: majorType, value };
      }
      function valueFromHeader(header, reader) {
        var value = header.value;
        if (value < 24) {
          return value;
        } else if (value == 24) {
          return reader.readByte();
        } else if (value == 25) {
          return reader.readUint16();
        } else if (value == 26) {
          return reader.readUint32();
        } else if (value == 27) {
          return reader.readUint64();
        } else if (value == 31) {
          return null;
        }
        notImplemented("Additional info: " + value)();
      }
      function writeHeaderRaw(type, value, writer) {
        writer.writeByte(type << 5 | value);
      }
      function writeHeader(type, value, writer) {
        var firstByte = type << 5;
        if (value < 24) {
          writer.writeByte(firstByte | value);
        } else if (value < 256) {
          writer.writeByte(firstByte | 24);
          writer.writeByte(value);
        } else if (value < 65536) {
          writer.writeByte(firstByte | 25);
          writer.writeUint16(value);
        } else if (value < 4294967296) {
          writer.writeByte(firstByte | 26);
          writer.writeUint32(value);
        } else {
          writer.writeByte(firstByte | 27);
          writer.writeUint64(value);
        }
      }
      var stopCode = new Error();
      function decodeReader(reader) {
        var header = readHeaderRaw(reader);
        switch (header.type) {
          case 0:
            return valueFromHeader(header, reader);
          case 1:
            return -1 - valueFromHeader(header, reader);
          case 2:
            return reader.readChunk(valueFromHeader(header, reader));
          case 3:
            var buffer = reader.readChunk(valueFromHeader(header, reader));
            return buffer.toString("utf-8");
          case 4:
          case 5:
            var arrayLength = valueFromHeader(header, reader);
            var result = [];
            if (arrayLength !== null) {
              if (header.type === 5) {
                arrayLength *= 2;
              }
              for (var i = 0; i < arrayLength; i++) {
                result[i] = decodeReader(reader);
              }
            } else {
              var item;
              while ((item = decodeReader(reader)) !== stopCode) {
                result.push(item);
              }
            }
            if (header.type === 5) {
              var objResult = {};
              for (var i = 0; i < result.length; i += 2) {
                objResult[result[i]] = result[i + 1];
              }
              return objResult;
            } else {
              return result;
            }
          case 6:
            var tag = valueFromHeader(header, reader);
            var decoder = semanticDecoders[tag];
            var result = decodeReader(reader);
            return decoder ? decoder(result) : result;
          case 7:
            if (header.value === 25) {
              return reader.readFloat16();
            } else if (header.value === 26) {
              return reader.readFloat32();
            } else if (header.value === 27) {
              return reader.readFloat64();
            }
            switch (valueFromHeader(header, reader)) {
              case 20:
                return false;
              case 21:
                return true;
              case 22:
                return null;
              case 23:
                return void 0;
              case null:
                return stopCode;
              default:
                throw new Error("Unknown fixed value: " + header.value);
            }
          default:
            throw new Error("Unsupported header: " + JSON.stringify(header));
        }
        throw new Error("not implemented yet");
      }
      function encodeWriter(data, writer) {
        for (var i = 0; i < semanticEncoders.length; i++) {
          var replacement = semanticEncoders[i].fn(data);
          if (replacement !== void 0) {
            writeHeader(6, semanticEncoders[i].tag, writer);
            return encodeWriter(replacement, writer);
          }
        }
        if (data && typeof data.toCBOR === "function") {
          data = data.toCBOR();
        }
        if (data === false) {
          writeHeader(7, 20, writer);
        } else if (data === true) {
          writeHeader(7, 21, writer);
        } else if (data === null) {
          writeHeader(7, 22, writer);
        } else if (data === void 0) {
          writeHeader(7, 23, writer);
        } else if (typeof data === "number") {
          if (Math.floor(data) === data && data < 9007199254740992 && data > -9007199254740992) {
            if (data < 0) {
              writeHeader(1, -1 - data, writer);
            } else {
              writeHeader(0, data, writer);
            }
          } else {
            writeHeaderRaw(7, 27, writer);
            writer.writeFloat64(data);
          }
        } else if (typeof data === "string") {
          writer.writeString(data, function(length) {
            writeHeader(3, length, writer);
          });
        } else if (writer.canWriteBinary(data)) {
          writer.writeBinary(data, function(length) {
            writeHeader(2, length, writer);
          });
        } else if (typeof data === "object") {
          if (api.config.useToJSON && typeof data.toJSON === "function") {
            data = data.toJSON();
          }
          if (Array.isArray(data)) {
            writeHeader(4, data.length, writer);
            for (var i = 0; i < data.length; i++) {
              encodeWriter(data[i], writer);
            }
          } else {
            var keys2 = Object.keys(data);
            writeHeader(5, keys2.length, writer);
            for (var i = 0; i < keys2.length; i++) {
              const number2 = parseInt(keys2[i]);
              if (isNaN(number2)) {
                encodeWriter(keys2[i], writer);
                encodeWriter(data[keys2[i]], writer);
              } else {
                encodeWriter(number2, writer);
                encodeWriter(data[keys2[i]], writer);
              }
            }
          }
        } else {
          throw new Error("CBOR encoding not supported: " + data);
        }
      }
      var readerFunctions = [];
      var writerFunctions = [];
      var api = {
        config: {
          useToJSON: true
        },
        addWriter: function(format, writerFunction) {
          if (typeof format === "string") {
            writerFunctions.push(function(f2) {
              if (format === f2)
                return writerFunction(f2);
            });
          } else {
            writerFunctions.push(format);
          }
        },
        addReader: function(format, readerFunction) {
          if (typeof format === "string") {
            readerFunctions.push(function(data, f2) {
              if (format === f2)
                return readerFunction(data, f2);
            });
          } else {
            readerFunctions.push(format);
          }
        },
        encode: function(data, format) {
          for (var i = 0; i < writerFunctions.length; i++) {
            var func = writerFunctions[i];
            var writer = func(format);
            if (writer) {
              encodeWriter(data, writer);
              return writer.result();
            }
          }
          throw new Error("Unsupported output format: " + format);
        },
        encodeDataItem: function(data, format) {
          for (var i = 0; i < writerFunctions.length; i++) {
            var func = writerFunctions[i];
            var writer = func(format);
            if (writer) {
              if (data.getTag() !== void 0) {
                encodeWriter(data, writer);
                return writer.result();
              } else {
                encodeWriter(data.getData(), writer);
                return writer.result();
              }
            }
          }
          throw new Error("Unsupported output format: " + format);
        },
        decode: function(data, format) {
          for (var i = 0; i < readerFunctions.length; i++) {
            var func = readerFunctions[i];
            var reader = func(data, format);
            if (reader) {
              return decodeReader(reader);
            }
          }
          throw new Error("Unsupported input format: " + format);
        },
        decodeToDataItem: function(data, format) {
          for (var i = 0; i < readerFunctions.length; i++) {
            var func = readerFunctions[i];
            var reader = func(data, format);
            if (reader) {
              const result = decodeReader(reader);
              if (result instanceof DataItem3) {
                return result;
              } else {
                return new DataItem3(result);
              }
            }
          }
          throw new Error("Unsupported input format: " + format);
        },
        addSemanticEncode: function(tag, fn) {
          if (typeof tag !== "number" || tag % 1 !== 0 || tag < 0) {
            throw new Error("Tag must be a positive integer");
          }
          semanticEncoders.push({ tag, fn });
          return this;
        },
        addSemanticDecode: function(tag, fn) {
          if (typeof tag !== "number" || tag % 1 !== 0 || tag < 0) {
            throw new Error("Tag must be a positive integer");
          }
          semanticDecoders[tag] = fn;
          return this;
        }
      };
      function BufferReader(buffer) {
        this.buffer = buffer;
        this.pos = 0;
      }
      BufferReader.prototype = Object.create(Reader.prototype);
      BufferReader.prototype.peekByte = function() {
        return this.buffer[this.pos];
      };
      BufferReader.prototype.readByte = function() {
        return this.buffer[this.pos++];
      };
      BufferReader.prototype.readUint16 = function() {
        var result = this.buffer.readUInt16BE(this.pos);
        this.pos += 2;
        return result;
      };
      BufferReader.prototype.readUint32 = function() {
        var result = this.buffer.readUInt32BE(this.pos);
        this.pos += 4;
        return result;
      };
      BufferReader.prototype.readFloat32 = function() {
        var result = this.buffer.readFloatBE(this.pos);
        this.pos += 4;
        return result;
      };
      BufferReader.prototype.readFloat64 = function() {
        var result = this.buffer.readDoubleBE(this.pos);
        this.pos += 8;
        return result;
      };
      BufferReader.prototype.readChunk = function(length) {
        var result = Buffer$1$1.alloc(length);
        this.buffer.copy(result, 0, this.pos, this.pos += length);
        return result;
      };
      function BufferWriter(stringFormat) {
        this.byteLength = 0;
        this.defaultBufferLength = 16384;
        this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
        this.latestBufferOffset = 0;
        this.completeBuffers = [];
        this.stringFormat = stringFormat;
      }
      BufferWriter.prototype = Object.create(Writer.prototype);
      BufferWriter.prototype.writeByte = function(value) {
        this.latestBuffer[this.latestBufferOffset++] = value;
        if (this.latestBufferOffset >= this.latestBuffer.length) {
          this.completeBuffers.push(this.latestBuffer);
          this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
          this.latestBufferOffset = 0;
        }
        this.byteLength++;
      };
      BufferWriter.prototype.writeFloat32 = function(value) {
        var buffer = Buffer$1$1.alloc(4);
        buffer.writeFloatBE(value, 0);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.writeFloat64 = function(value) {
        var buffer = Buffer$1$1.alloc(8);
        buffer.writeDoubleBE(value, 0);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.writeString = function(string, lengthFunc) {
        var buffer = Buffer$1$1.from(string, "utf-8");
        lengthFunc(buffer.length);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.canWriteBinary = function(data) {
        return data instanceof Buffer$1$1;
      };
      BufferWriter.prototype.writeBinary = function(buffer, lengthFunc) {
        lengthFunc(buffer.length);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.writeBuffer = function(chunk) {
        if (!(chunk instanceof Buffer$1$1))
          throw new TypeError("BufferWriter only accepts Buffers");
        if (!this.latestBufferOffset) {
          this.completeBuffers.push(chunk);
        } else if (this.latestBuffer.length - this.latestBufferOffset >= chunk.length) {
          chunk.copy(this.latestBuffer, this.latestBufferOffset);
          this.latestBufferOffset += chunk.length;
          if (this.latestBufferOffset >= this.latestBuffer.length) {
            this.completeBuffers.push(this.latestBuffer);
            this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
            this.latestBufferOffset = 0;
          }
        } else {
          this.completeBuffers.push(this.latestBuffer.slice(0, this.latestBufferOffset));
          this.completeBuffers.push(chunk);
          this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
          this.latestBufferOffset = 0;
        }
        this.byteLength += chunk.length;
      };
      BufferWriter.prototype.result = function() {
        var result = Buffer$1$1.alloc(this.byteLength);
        var offset = 0;
        for (var i = 0; i < this.completeBuffers.length; i++) {
          var buffer = this.completeBuffers[i];
          buffer.copy(result, offset, 0, buffer.length);
          offset += buffer.length;
        }
        if (this.latestBufferOffset) {
          this.latestBuffer.copy(result, offset, 0, this.latestBufferOffset);
        }
        if (this.stringFormat)
          return result.toString(this.stringFormat);
        return result;
      };
      if (typeof Buffer$1$1 === "function") {
        api.addReader(function(data, format) {
          if (Buffer$1$1.isBuffer(data)) {
            return new BufferReader(data);
          }
          if (format === "hex" || format === "base64") {
            var buffer = Buffer$1$1.from(data, format);
            return new BufferReader(buffer);
          }
        });
        api.addWriter(function(format) {
          if (!format || format === "buffer") {
            return new BufferWriter();
          } else if (format === "hex" || format === "base64") {
            return new BufferWriter(format);
          }
        });
      }
      function HexReader(hex) {
        this.hex = hex;
        this.pos = 0;
      }
      HexReader.prototype = Object.create(Reader.prototype);
      HexReader.prototype.peekByte = function() {
        var pair = this.hex.substring(this.pos, 2);
        return parseInt(pair, 16);
      };
      HexReader.prototype.readByte = function() {
        var pair = this.hex.substring(this.pos, this.pos + 2);
        this.pos += 2;
        return parseInt(pair, 16);
      };
      HexReader.prototype.readChunk = function(length) {
        var hex = this.hex.substring(this.pos, this.pos + length * 2);
        this.pos += length * 2;
        if (typeof Buffer$1$1 === "function")
          return Buffer$1$1.from(hex, "hex");
        return new BinaryHex(hex);
      };
      function HexWriter(finalFormat) {
        this.$hex = "";
        this.finalFormat = finalFormat || "hex";
      }
      HexWriter.prototype = Object.create(Writer.prototype);
      HexWriter.prototype.writeByte = function(value) {
        if (value < 0 || value > 255)
          throw new Error("Byte value out of range: " + value);
        var hex = value.toString(16);
        if (hex.length == 1) {
          hex = "0" + hex;
        }
        this.$hex += hex;
      };
      HexWriter.prototype.canWriteBinary = function(chunk) {
        return chunk instanceof BinaryHex || typeof Buffer$1$1 === "function" && chunk instanceof Buffer$1$1;
      };
      HexWriter.prototype.writeBinary = function(chunk, lengthFunction) {
        if (chunk instanceof BinaryHex) {
          lengthFunction(chunk.length());
          this.$hex += chunk.$hex;
        } else if (typeof Buffer$1$1 === "function" && chunk instanceof Buffer$1$1) {
          lengthFunction(chunk.length);
          this.$hex += chunk.toString("hex");
        } else {
          throw new TypeError("HexWriter only accepts BinaryHex or Buffers");
        }
      };
      HexWriter.prototype.result = function() {
        if (this.finalFormat === "buffer" && typeof Buffer$1$1 === "function") {
          return Buffer$1$1.from(this.$hex, "hex");
        }
        return new BinaryHex(this.$hex).toString(this.finalFormat);
      };
      HexWriter.prototype.writeString = function(string, lengthFunction) {
        var buffer = BinaryHex.fromUtf8String(string);
        lengthFunction(buffer.length());
        this.$hex += buffer.$hex;
      };
      api.addReader(function(data, format) {
        if (data instanceof BinaryHex || data.$hex) {
          return new HexReader(data.$hex);
        }
        if (format === "hex") {
          return new HexReader(data);
        }
      });
      api.addWriter(function(format) {
        if (format === "hex") {
          return new HexWriter();
        }
      });
      return api;
    }();
    CBOR.addSemanticEncode(0, function(data) {
      if (data instanceof Date) {
        return data.toISOString();
      }
    }).addSemanticDecode(0, function(isoString) {
      return new Date(isoString);
    }).addSemanticDecode(1, function(isoString) {
      return new Date(isoString);
    });
    return CBOR;
  });
})(cborSync$1);
var cborSyncExports$1 = cborSync$1.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DataItem = exports.addWriter = exports.addReader = exports.addSemanticEncode = exports.addSemanticDecode = exports.decodeToDataItem = exports.encodeDataItem = void 0;
  var cbor_sync_1 = cborSyncExports$1;
  Object.defineProperty(exports, "encodeDataItem", { enumerable: true, get: function() {
    return cbor_sync_1.encodeDataItem;
  } });
  Object.defineProperty(exports, "decodeToDataItem", { enumerable: true, get: function() {
    return cbor_sync_1.decodeToDataItem;
  } });
  Object.defineProperty(exports, "addSemanticDecode", { enumerable: true, get: function() {
    return cbor_sync_1.addSemanticDecode;
  } });
  Object.defineProperty(exports, "addSemanticEncode", { enumerable: true, get: function() {
    return cbor_sync_1.addSemanticEncode;
  } });
  Object.defineProperty(exports, "addReader", { enumerable: true, get: function() {
    return cbor_sync_1.addReader;
  } });
  Object.defineProperty(exports, "addWriter", { enumerable: true, get: function() {
    return cbor_sync_1.addWriter;
  } });
  var DataItem_12 = DataItem$3;
  Object.defineProperty(exports, "DataItem", { enumerable: true, get: function() {
    return DataItem_12.DataItem;
  } });
})(lib$2);
Object.defineProperty(utils$j, "__esModule", { value: true });
utils$j.patchTags = void 0;
const lib_1$j = lib$2;
const alreadyPatchedTag$1 = [];
const patchTags$1 = (tags) => {
  tags.forEach((tag) => {
    if (alreadyPatchedTag$1.find((i) => i === tag))
      return;
    (0, lib_1$j.addSemanticEncode)(tag, (data) => {
      if (data instanceof lib_1$j.DataItem) {
        if (data.getTag() === tag) {
          return data.getData();
        }
      }
    });
    (0, lib_1$j.addSemanticDecode)(tag, (data) => {
      return new lib_1$j.DataItem(data, tag);
    });
    alreadyPatchedTag$1.push(tag);
  });
};
utils$j.patchTags = patchTags$1;
var RegistryType$3 = {};
Object.defineProperty(RegistryType$3, "__esModule", { value: true });
RegistryType$3.RegistryTypes = RegistryType$3.RegistryType = void 0;
let RegistryType$2 = class RegistryType {
  constructor(type, tag) {
    this.type = type;
    this.tag = tag;
    this.getTag = () => this.tag;
    this.getType = () => this.type;
  }
};
RegistryType$3.RegistryType = RegistryType$2;
RegistryType$3.RegistryTypes = {
  UUID: new RegistryType$2("uuid", 37),
  BYTES: new RegistryType$2("bytes", void 0),
  CRYPTO_HDKEY: new RegistryType$2("crypto-hdkey", 303),
  CRYPTO_KEYPATH: new RegistryType$2("crypto-keypath", 304),
  CRYPTO_COIN_INFO: new RegistryType$2("crypto-coin-info", 305),
  CRYPTO_ECKEY: new RegistryType$2("crypto-eckey", 306),
  CRYPTO_OUTPUT: new RegistryType$2("crypto-output", 308),
  CRYPTO_PSBT: new RegistryType$2("crypto-psbt", 310),
  CRYPTO_ACCOUNT: new RegistryType$2("crypto-account", 311),
  CRYPTO_MULTI_ACCOUNTS: new RegistryType$2("crypto-multi-accounts", 1103),
  QR_HARDWARE_CALL: new RegistryType$2("qr-hardware-call", 1201),
  KEY_DERIVATION_CALL: new RegistryType$2("key-derivation-call", 1301),
  KEY_DERIVATION_SCHEMA: new RegistryType$2("key-derivation-schema", 1302)
};
var ScriptExpression$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ScriptExpressions = exports.ScriptExpression = void 0;
  class ScriptExpression2 {
    constructor(tag, expression) {
      this.tag = tag;
      this.expression = expression;
      this.getTag = () => this.tag;
      this.getExpression = () => this.expression;
    }
  }
  exports.ScriptExpression = ScriptExpression2;
  ScriptExpression2.fromTag = (tag) => {
    const se = Object.values(exports.ScriptExpressions).find((se2) => se2.getTag() === tag);
    return se;
  };
  exports.ScriptExpressions = {
    SCRIPT_HASH: new ScriptExpression2(400, "sh"),
    WITNESS_SCRIPT_HASH: new ScriptExpression2(401, "wsh"),
    PUBLIC_KEY: new ScriptExpression2(402, "pk"),
    PUBLIC_KEY_HASH: new ScriptExpression2(403, "pkh"),
    WITNESS_PUBLIC_KEY_HASH: new ScriptExpression2(404, "wpkh"),
    COMBO: new ScriptExpression2(405, "combo"),
    MULTISIG: new ScriptExpression2(406, "multi"),
    SORTED_MULTISIG: new ScriptExpression2(407, "sortedmulti"),
    ADDRESS: new ScriptExpression2(307, "addr"),
    RAW_SCRIPT: new ScriptExpression2(408, "raw")
  };
})(ScriptExpression$1);
Object.defineProperty(patchCBOR$1, "__esModule", { value: true });
const utils_1$r = utils$j;
const RegistryType_1$j = RegistryType$3;
const ScriptExpression_1$3 = ScriptExpression$1;
const registryTags$1 = Object.values(RegistryType_1$j.RegistryTypes).filter((r) => !!r.getTag()).map((r) => r.getTag());
const scriptExpressionTags$1 = Object.values(ScriptExpression_1$3.ScriptExpressions).map((se) => se.getTag());
(0, utils_1$r.patchTags)(registryTags$1.concat(scriptExpressionTags$1));
var dist$h = {};
(function(exports) {
  Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
  var buffer = {};
  var base64Js = {};
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint82, start, end) {
    var tmp;
    var output2 = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint82[i2] << 16 & 16711680) + (uint82[i2 + 1] << 8 & 65280) + (uint82[i2 + 2] & 255);
      output2.push(tripletToBase64(tmp));
    }
    return output2.join("");
  }
  function fromByteArray(uint82) {
    var tmp;
    var len2 = uint82.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint82, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint82[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint82[len2 - 2] << 8) + uint82[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  var ieee754 = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i2];
    i2 += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i2 - d] |= s * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(exports2) {
    const base64 = base64Js;
    const ieee754$1 = ieee754;
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer3;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new GlobalUint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer2(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new GlobalUint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (GlobalArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, GlobalUint8Array.prototype);
    Object.setPrototypeOf(Buffer3, GlobalUint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer2(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer2(size).fill(fill, encoding) : createBuffer2(size).fill(fill);
      }
      return createBuffer2(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer2(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength2(string, encoding) | 0;
      let buf = createBuffer2(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer2(length);
      for (let i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, GlobalUint8Array)) {
        const copy = new GlobalUint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new GlobalUint8Array(array);
      } else if (length === void 0) {
        buf = new GlobalUint8Array(array, byteOffset);
      } else {
        buf = new GlobalUint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len2 = checked(obj.length) | 0;
        const buf = createBuffer2(len2);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len2);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN2(obj.length)) {
          return createBuffer2(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare2(a, b) {
      if (isInstance(a, GlobalUint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, GlobalUint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i2 = 0, len2 = Math.min(x, y); i2 < len2; ++i2) {
        if (a[i2] !== b[i2]) {
          x = a[i2];
          y = b[i2];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length += list[i2].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, GlobalUint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            GlobalUint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength2(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len2 = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len2 === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len2;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len2 * 2;
          case "hex":
            return len2 >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i2 = b[n];
      b[n] = b[m];
      b[m] = i2;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len2 = this.length;
      if (len2 % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len2 = this.length;
      if (len2 % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len2 = this.length;
      if (len2 % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString2() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect6() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, GlobalUint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len2 = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len2; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x = thisCopy[i2];
          y = targetCopy[i2];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN2(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof GlobalUint8Array.prototype.indexOf === "function") {
          if (dir) {
            return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i2 + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i2;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        const parsed = parseInt(string.substr(i2 * 2, 2), 16);
        if (numberIsNaN2(parsed)) return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len2 = codePoints.length;
      if (len2 <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len2) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len2 = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len2) end = len2;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes2 = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice2(start, end) {
      const len2 = this.length;
      start = ~~start;
      end = end === void 0 ? len2 : ~~end;
      if (start < 0) {
        start += len2;
        if (start < 0) start = 0;
      } else if (start > len2) {
        start = len2;
      }
      if (end < 0) {
        end += len2;
        if (end < 0) end = 0;
      } else if (end > len2) {
        end = len2;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul5 = 1;
      let i2 = 0;
      while (++i2 < byteLength3 && (mul5 *= 256)) {
        val += this[offset + i2] * mul5;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      let val = this[offset + --byteLength3];
      let mul5 = 1;
      while (byteLength3 > 0 && (mul5 *= 256)) {
        val += this[offset + --byteLength3] * mul5;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul5 = 1;
      let i2 = 0;
      while (++i2 < byteLength3 && (mul5 *= 256)) {
        val += this[offset + i2] * mul5;
      }
      mul5 *= 128;
      if (val >= mul5) val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      let i2 = byteLength3;
      let mul5 = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul5 *= 256)) {
        val += this[offset + --i2] * mul5;
      }
      mul5 *= 128;
      if (val >= mul5) val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let mul5 = 1;
      let i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul5 *= 256)) {
        this[offset + i2] = value / mul5 & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let i2 = byteLength3 - 1;
      let mul5 = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul5 *= 256)) {
        this[offset + i2] = value / mul5 & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i2 = 0;
      let mul5 = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul5 *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul5 >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i2 = byteLength3 - 1;
      let mul5 = 1;
      let sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul5 *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul5 >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len2 = end - start;
      if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        GlobalUint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len2;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes2 = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len2 = bytes2.length;
        if (len2 === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes2[i2 % len2];
        }
      }
      return this;
    };
    const errors2 = {};
    function E(sym, getMessage, Base2) {
      errors2[sym] = class NodeError extends Base2 {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg2 = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg2 += ` It must be ${range}. Received ${received}`;
        return msg2;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf, offset, byteLength3) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
        boundsError(offset, buf.length - (byteLength3 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength3) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
          }
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength3);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${length}`,
        value
      );
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string, units2) {
      units2 = units2 || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes2 = [];
      for (let i2 = 0; i2 < length; ++i2) {
        codePoint = string.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units2 -= 3) > -1) bytes2.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units2 -= 3) > -1) bytes2.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units2 -= 3) > -1) bytes2.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units2 -= 3) > -1) bytes2.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units2 -= 1) < 0) break;
          bytes2.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units2 -= 2) < 0) break;
          bytes2.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units2 -= 3) < 0) break;
          bytes2.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units2 -= 4) < 0) break;
          bytes2.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes2;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units2) {
      let c, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units2 -= 2) < 0) break;
        c = str.charCodeAt(i2);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length) {
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src2.length) break;
        dst[i2 + offset] = src2[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN2(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i2] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  })(buffer);
  const Buffer2 = buffer.Buffer;
  exports.Blob = buffer.Blob;
  exports.BlobOptions = buffer.BlobOptions;
  exports.Buffer = buffer.Buffer;
  exports.File = buffer.File;
  exports.FileOptions = buffer.FileOptions;
  exports.INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;
  exports.SlowBuffer = buffer.SlowBuffer;
  exports.TranscodeEncoding = buffer.TranscodeEncoding;
  exports.atob = buffer.atob;
  exports.btoa = buffer.btoa;
  exports.constants = buffer.constants;
  exports.default = Buffer2;
  exports.isAscii = buffer.isAscii;
  exports.isUtf8 = buffer.isUtf8;
  exports.kMaxLength = buffer.kMaxLength;
  exports.kStringMaxLength = buffer.kStringMaxLength;
  exports.resolveObjectURL = buffer.resolveObjectURL;
  exports.transcode = buffer.transcode;
})(dist$h);
var CryptoHDKey$3 = {};
var basex$3 = src$1;
var ALPHABET$3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58$3 = basex$3(ALPHABET$3);
var base58$3 = bs58$3;
var Buffer$3 = safeBufferExports.Buffer;
var base$5 = function(checksumFn) {
  function encode3(payload) {
    var checksum = checksumFn(payload);
    return base58$3.encode(Buffer$3.concat([
      payload,
      checksum
    ], payload.length + 4));
  }
  function decodeRaw(buffer) {
    var payload = buffer.slice(0, -4);
    var checksum = buffer.slice(-4);
    var newChecksum = checksumFn(payload);
    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
    return payload;
  }
  function decodeUnsafe(string) {
    var buffer = base58$3.decodeUnsafe(string);
    if (!buffer) return;
    return decodeRaw(buffer);
  }
  function decode2(string) {
    var buffer = base58$3.decode(string);
    var payload = decodeRaw(buffer);
    if (!payload) throw new Error("Invalid checksum");
    return payload;
  }
  return {
    encode: encode3,
    decode: decode2,
    decodeUnsafe
  };
};
var createHash$4 = browser;
var bs58checkBase$3 = base$5;
function sha256x2$3(buffer) {
  var tmp = createHash$4("sha256").update(buffer).digest();
  return createHash$4("sha256").update(tmp).digest();
}
var bs58check$4 = bs58checkBase$3(sha256x2$3);
var CryptoCoinInfo$1 = {};
var RegistryItem$3 = {};
var dist$g = {};
var ur$1 = {};
var errors$4 = {};
Object.defineProperty(errors$4, "__esModule", { value: true });
errors$4.InvalidChecksumError = errors$4.InvalidSequenceComponentError = errors$4.InvalidTypeError = errors$4.InvalidPathLengthError = errors$4.InvalidSchemeError = void 0;
class InvalidSchemeError extends Error {
  constructor() {
    super("Invalid Scheme");
    this.name = "InvalidSchemeError";
  }
}
errors$4.InvalidSchemeError = InvalidSchemeError;
class InvalidPathLengthError extends Error {
  constructor() {
    super("Invalid Path");
    this.name = "InvalidPathLengthError";
  }
}
errors$4.InvalidPathLengthError = InvalidPathLengthError;
class InvalidTypeError extends Error {
  constructor() {
    super("Invalid Type");
    this.name = "InvalidTypeError";
  }
}
errors$4.InvalidTypeError = InvalidTypeError;
class InvalidSequenceComponentError extends Error {
  constructor() {
    super("Invalid Sequence Component");
    this.name = "InvalidSequenceComponentError";
  }
}
errors$4.InvalidSequenceComponentError = InvalidSequenceComponentError;
class InvalidChecksumError extends Error {
  constructor() {
    super("Invalid Checksum");
    this.name = "InvalidChecksumError";
  }
}
errors$4.InvalidChecksumError = InvalidChecksumError;
var utils$i = {};
const createBuffer = Buffer$1$1.from && Buffer$1$1.alloc && Buffer$1$1.allocUnsafe && Buffer$1$1.allocUnsafeSlow ? Buffer$1$1.from : (
  // support for Node < 5.10
  (val) => new Buffer$1$1(val)
);
function defineCrc(model, calc) {
  const fn = (buf, previous) => calc(buf, previous) >>> 0;
  fn.signed = calc;
  fn.unsigned = fn;
  fn.model = model;
  return fn;
}
const crc1 = defineCrc("crc1", function(buf, previous) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = ~~previous;
  let accum = 0;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    accum += byte;
  }
  crc2 += accum % 256;
  return crc2 % 256;
});
let TABLE$9 = [
  0,
  7,
  14,
  9,
  28,
  27,
  18,
  21,
  56,
  63,
  54,
  49,
  36,
  35,
  42,
  45,
  112,
  119,
  126,
  121,
  108,
  107,
  98,
  101,
  72,
  79,
  70,
  65,
  84,
  83,
  90,
  93,
  224,
  231,
  238,
  233,
  252,
  251,
  242,
  245,
  216,
  223,
  214,
  209,
  196,
  195,
  202,
  205,
  144,
  151,
  158,
  153,
  140,
  139,
  130,
  133,
  168,
  175,
  166,
  161,
  180,
  179,
  186,
  189,
  199,
  192,
  201,
  206,
  219,
  220,
  213,
  210,
  255,
  248,
  241,
  246,
  227,
  228,
  237,
  234,
  183,
  176,
  185,
  190,
  171,
  172,
  165,
  162,
  143,
  136,
  129,
  134,
  147,
  148,
  157,
  154,
  39,
  32,
  41,
  46,
  59,
  60,
  53,
  50,
  31,
  24,
  17,
  22,
  3,
  4,
  13,
  10,
  87,
  80,
  89,
  94,
  75,
  76,
  69,
  66,
  111,
  104,
  97,
  102,
  115,
  116,
  125,
  122,
  137,
  142,
  135,
  128,
  149,
  146,
  155,
  156,
  177,
  182,
  191,
  184,
  173,
  170,
  163,
  164,
  249,
  254,
  247,
  240,
  229,
  226,
  235,
  236,
  193,
  198,
  207,
  200,
  221,
  218,
  211,
  212,
  105,
  110,
  103,
  96,
  117,
  114,
  123,
  124,
  81,
  86,
  95,
  88,
  77,
  74,
  67,
  68,
  25,
  30,
  23,
  16,
  5,
  2,
  11,
  12,
  33,
  38,
  47,
  40,
  61,
  58,
  51,
  52,
  78,
  73,
  64,
  71,
  82,
  85,
  92,
  91,
  118,
  113,
  120,
  127,
  106,
  109,
  100,
  99,
  62,
  57,
  48,
  55,
  34,
  37,
  44,
  43,
  6,
  1,
  8,
  15,
  26,
  29,
  20,
  19,
  174,
  169,
  160,
  167,
  178,
  181,
  188,
  187,
  150,
  145,
  152,
  159,
  138,
  141,
  132,
  131,
  222,
  217,
  208,
  215,
  194,
  197,
  204,
  203,
  230,
  225,
  232,
  239,
  250,
  253,
  244,
  243
];
if (typeof Int32Array !== "undefined") TABLE$9 = new Int32Array(TABLE$9);
const crc8 = defineCrc("crc-8", function(buf, previous) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = ~~previous;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = TABLE$9[(crc2 ^ byte) & 255] & 255;
  }
  return crc2;
});
let TABLE$8 = [
  0,
  94,
  188,
  226,
  97,
  63,
  221,
  131,
  194,
  156,
  126,
  32,
  163,
  253,
  31,
  65,
  157,
  195,
  33,
  127,
  252,
  162,
  64,
  30,
  95,
  1,
  227,
  189,
  62,
  96,
  130,
  220,
  35,
  125,
  159,
  193,
  66,
  28,
  254,
  160,
  225,
  191,
  93,
  3,
  128,
  222,
  60,
  98,
  190,
  224,
  2,
  92,
  223,
  129,
  99,
  61,
  124,
  34,
  192,
  158,
  29,
  67,
  161,
  255,
  70,
  24,
  250,
  164,
  39,
  121,
  155,
  197,
  132,
  218,
  56,
  102,
  229,
  187,
  89,
  7,
  219,
  133,
  103,
  57,
  186,
  228,
  6,
  88,
  25,
  71,
  165,
  251,
  120,
  38,
  196,
  154,
  101,
  59,
  217,
  135,
  4,
  90,
  184,
  230,
  167,
  249,
  27,
  69,
  198,
  152,
  122,
  36,
  248,
  166,
  68,
  26,
  153,
  199,
  37,
  123,
  58,
  100,
  134,
  216,
  91,
  5,
  231,
  185,
  140,
  210,
  48,
  110,
  237,
  179,
  81,
  15,
  78,
  16,
  242,
  172,
  47,
  113,
  147,
  205,
  17,
  79,
  173,
  243,
  112,
  46,
  204,
  146,
  211,
  141,
  111,
  49,
  178,
  236,
  14,
  80,
  175,
  241,
  19,
  77,
  206,
  144,
  114,
  44,
  109,
  51,
  209,
  143,
  12,
  82,
  176,
  238,
  50,
  108,
  142,
  208,
  83,
  13,
  239,
  177,
  240,
  174,
  76,
  18,
  145,
  207,
  45,
  115,
  202,
  148,
  118,
  40,
  171,
  245,
  23,
  73,
  8,
  86,
  180,
  234,
  105,
  55,
  213,
  139,
  87,
  9,
  235,
  181,
  54,
  104,
  138,
  212,
  149,
  203,
  41,
  119,
  244,
  170,
  72,
  22,
  233,
  183,
  85,
  11,
  136,
  214,
  52,
  106,
  43,
  117,
  151,
  201,
  74,
  20,
  246,
  168,
  116,
  42,
  200,
  150,
  21,
  75,
  169,
  247,
  182,
  232,
  10,
  84,
  215,
  137,
  107,
  53
];
if (typeof Int32Array !== "undefined") TABLE$8 = new Int32Array(TABLE$8);
const crc81wire = defineCrc("dallas-1-wire", function(buf, previous) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = ~~previous;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = TABLE$8[(crc2 ^ byte) & 255] & 255;
  }
  return crc2;
});
let TABLE$7 = [
  0,
  49345,
  49537,
  320,
  49921,
  960,
  640,
  49729,
  50689,
  1728,
  1920,
  51009,
  1280,
  50625,
  50305,
  1088,
  52225,
  3264,
  3456,
  52545,
  3840,
  53185,
  52865,
  3648,
  2560,
  51905,
  52097,
  2880,
  51457,
  2496,
  2176,
  51265,
  55297,
  6336,
  6528,
  55617,
  6912,
  56257,
  55937,
  6720,
  7680,
  57025,
  57217,
  8e3,
  56577,
  7616,
  7296,
  56385,
  5120,
  54465,
  54657,
  5440,
  55041,
  6080,
  5760,
  54849,
  53761,
  4800,
  4992,
  54081,
  4352,
  53697,
  53377,
  4160,
  61441,
  12480,
  12672,
  61761,
  13056,
  62401,
  62081,
  12864,
  13824,
  63169,
  63361,
  14144,
  62721,
  13760,
  13440,
  62529,
  15360,
  64705,
  64897,
  15680,
  65281,
  16320,
  16e3,
  65089,
  64001,
  15040,
  15232,
  64321,
  14592,
  63937,
  63617,
  14400,
  10240,
  59585,
  59777,
  10560,
  60161,
  11200,
  10880,
  59969,
  60929,
  11968,
  12160,
  61249,
  11520,
  60865,
  60545,
  11328,
  58369,
  9408,
  9600,
  58689,
  9984,
  59329,
  59009,
  9792,
  8704,
  58049,
  58241,
  9024,
  57601,
  8640,
  8320,
  57409,
  40961,
  24768,
  24960,
  41281,
  25344,
  41921,
  41601,
  25152,
  26112,
  42689,
  42881,
  26432,
  42241,
  26048,
  25728,
  42049,
  27648,
  44225,
  44417,
  27968,
  44801,
  28608,
  28288,
  44609,
  43521,
  27328,
  27520,
  43841,
  26880,
  43457,
  43137,
  26688,
  30720,
  47297,
  47489,
  31040,
  47873,
  31680,
  31360,
  47681,
  48641,
  32448,
  32640,
  48961,
  32e3,
  48577,
  48257,
  31808,
  46081,
  29888,
  30080,
  46401,
  30464,
  47041,
  46721,
  30272,
  29184,
  45761,
  45953,
  29504,
  45313,
  29120,
  28800,
  45121,
  20480,
  37057,
  37249,
  20800,
  37633,
  21440,
  21120,
  37441,
  38401,
  22208,
  22400,
  38721,
  21760,
  38337,
  38017,
  21568,
  39937,
  23744,
  23936,
  40257,
  24320,
  40897,
  40577,
  24128,
  23040,
  39617,
  39809,
  23360,
  39169,
  22976,
  22656,
  38977,
  34817,
  18624,
  18816,
  35137,
  19200,
  35777,
  35457,
  19008,
  19968,
  36545,
  36737,
  20288,
  36097,
  19904,
  19584,
  35905,
  17408,
  33985,
  34177,
  17728,
  34561,
  18368,
  18048,
  34369,
  33281,
  17088,
  17280,
  33601,
  16640,
  33217,
  32897,
  16448
];
if (typeof Int32Array !== "undefined") TABLE$7 = new Int32Array(TABLE$7);
const crc16 = defineCrc("crc-16", function(buf, previous) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = ~~previous;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = (TABLE$7[(crc2 ^ byte) & 255] ^ crc2 >> 8) & 65535;
  }
  return crc2;
});
let TABLE$6 = [
  0,
  4129,
  8258,
  12387,
  16516,
  20645,
  24774,
  28903,
  33032,
  37161,
  41290,
  45419,
  49548,
  53677,
  57806,
  61935,
  4657,
  528,
  12915,
  8786,
  21173,
  17044,
  29431,
  25302,
  37689,
  33560,
  45947,
  41818,
  54205,
  50076,
  62463,
  58334,
  9314,
  13379,
  1056,
  5121,
  25830,
  29895,
  17572,
  21637,
  42346,
  46411,
  34088,
  38153,
  58862,
  62927,
  50604,
  54669,
  13907,
  9842,
  5649,
  1584,
  30423,
  26358,
  22165,
  18100,
  46939,
  42874,
  38681,
  34616,
  63455,
  59390,
  55197,
  51132,
  18628,
  22757,
  26758,
  30887,
  2112,
  6241,
  10242,
  14371,
  51660,
  55789,
  59790,
  63919,
  35144,
  39273,
  43274,
  47403,
  23285,
  19156,
  31415,
  27286,
  6769,
  2640,
  14899,
  10770,
  56317,
  52188,
  64447,
  60318,
  39801,
  35672,
  47931,
  43802,
  27814,
  31879,
  19684,
  23749,
  11298,
  15363,
  3168,
  7233,
  60846,
  64911,
  52716,
  56781,
  44330,
  48395,
  36200,
  40265,
  32407,
  28342,
  24277,
  20212,
  15891,
  11826,
  7761,
  3696,
  65439,
  61374,
  57309,
  53244,
  48923,
  44858,
  40793,
  36728,
  37256,
  33193,
  45514,
  41451,
  53516,
  49453,
  61774,
  57711,
  4224,
  161,
  12482,
  8419,
  20484,
  16421,
  28742,
  24679,
  33721,
  37784,
  41979,
  46042,
  49981,
  54044,
  58239,
  62302,
  689,
  4752,
  8947,
  13010,
  16949,
  21012,
  25207,
  29270,
  46570,
  42443,
  38312,
  34185,
  62830,
  58703,
  54572,
  50445,
  13538,
  9411,
  5280,
  1153,
  29798,
  25671,
  21540,
  17413,
  42971,
  47098,
  34713,
  38840,
  59231,
  63358,
  50973,
  55100,
  9939,
  14066,
  1681,
  5808,
  26199,
  30326,
  17941,
  22068,
  55628,
  51565,
  63758,
  59695,
  39368,
  35305,
  47498,
  43435,
  22596,
  18533,
  30726,
  26663,
  6336,
  2273,
  14466,
  10403,
  52093,
  56156,
  60223,
  64286,
  35833,
  39896,
  43963,
  48026,
  19061,
  23124,
  27191,
  31254,
  2801,
  6864,
  10931,
  14994,
  64814,
  60687,
  56684,
  52557,
  48554,
  44427,
  40424,
  36297,
  31782,
  27655,
  23652,
  19525,
  15522,
  11395,
  7392,
  3265,
  61215,
  65342,
  53085,
  57212,
  44955,
  49082,
  36825,
  40952,
  28183,
  32310,
  20053,
  24180,
  11923,
  16050,
  3793,
  7920
];
if (typeof Int32Array !== "undefined") TABLE$6 = new Int32Array(TABLE$6);
const crc16ccitt = defineCrc("ccitt", function(buf, previous) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = typeof previous !== "undefined" ? ~~previous : 65535;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = (TABLE$6[(crc2 >> 8 ^ byte) & 255] ^ crc2 << 8) & 65535;
  }
  return crc2;
});
let TABLE$5 = [
  0,
  49345,
  49537,
  320,
  49921,
  960,
  640,
  49729,
  50689,
  1728,
  1920,
  51009,
  1280,
  50625,
  50305,
  1088,
  52225,
  3264,
  3456,
  52545,
  3840,
  53185,
  52865,
  3648,
  2560,
  51905,
  52097,
  2880,
  51457,
  2496,
  2176,
  51265,
  55297,
  6336,
  6528,
  55617,
  6912,
  56257,
  55937,
  6720,
  7680,
  57025,
  57217,
  8e3,
  56577,
  7616,
  7296,
  56385,
  5120,
  54465,
  54657,
  5440,
  55041,
  6080,
  5760,
  54849,
  53761,
  4800,
  4992,
  54081,
  4352,
  53697,
  53377,
  4160,
  61441,
  12480,
  12672,
  61761,
  13056,
  62401,
  62081,
  12864,
  13824,
  63169,
  63361,
  14144,
  62721,
  13760,
  13440,
  62529,
  15360,
  64705,
  64897,
  15680,
  65281,
  16320,
  16e3,
  65089,
  64001,
  15040,
  15232,
  64321,
  14592,
  63937,
  63617,
  14400,
  10240,
  59585,
  59777,
  10560,
  60161,
  11200,
  10880,
  59969,
  60929,
  11968,
  12160,
  61249,
  11520,
  60865,
  60545,
  11328,
  58369,
  9408,
  9600,
  58689,
  9984,
  59329,
  59009,
  9792,
  8704,
  58049,
  58241,
  9024,
  57601,
  8640,
  8320,
  57409,
  40961,
  24768,
  24960,
  41281,
  25344,
  41921,
  41601,
  25152,
  26112,
  42689,
  42881,
  26432,
  42241,
  26048,
  25728,
  42049,
  27648,
  44225,
  44417,
  27968,
  44801,
  28608,
  28288,
  44609,
  43521,
  27328,
  27520,
  43841,
  26880,
  43457,
  43137,
  26688,
  30720,
  47297,
  47489,
  31040,
  47873,
  31680,
  31360,
  47681,
  48641,
  32448,
  32640,
  48961,
  32e3,
  48577,
  48257,
  31808,
  46081,
  29888,
  30080,
  46401,
  30464,
  47041,
  46721,
  30272,
  29184,
  45761,
  45953,
  29504,
  45313,
  29120,
  28800,
  45121,
  20480,
  37057,
  37249,
  20800,
  37633,
  21440,
  21120,
  37441,
  38401,
  22208,
  22400,
  38721,
  21760,
  38337,
  38017,
  21568,
  39937,
  23744,
  23936,
  40257,
  24320,
  40897,
  40577,
  24128,
  23040,
  39617,
  39809,
  23360,
  39169,
  22976,
  22656,
  38977,
  34817,
  18624,
  18816,
  35137,
  19200,
  35777,
  35457,
  19008,
  19968,
  36545,
  36737,
  20288,
  36097,
  19904,
  19584,
  35905,
  17408,
  33985,
  34177,
  17728,
  34561,
  18368,
  18048,
  34369,
  33281,
  17088,
  17280,
  33601,
  16640,
  33217,
  32897,
  16448
];
if (typeof Int32Array !== "undefined") TABLE$5 = new Int32Array(TABLE$5);
const crc16modbus = defineCrc("crc-16-modbus", function(buf, previous) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = typeof previous !== "undefined" ? ~~previous : 65535;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = (TABLE$5[(crc2 ^ byte) & 255] ^ crc2 >> 8) & 65535;
  }
  return crc2;
});
const crc16xmodem = defineCrc("xmodem", function(buf, previous) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = typeof previous !== "undefined" ? ~~previous : 0;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    let code = crc2 >>> 8 & 255;
    code ^= byte & 255;
    code ^= code >>> 4;
    crc2 = crc2 << 8 & 65535;
    crc2 ^= code;
    code = code << 5 & 65535;
    crc2 ^= code;
    code = code << 7 & 65535;
    crc2 ^= code;
  }
  return crc2;
});
let TABLE$4 = [
  0,
  4489,
  8978,
  12955,
  17956,
  22445,
  25910,
  29887,
  35912,
  40385,
  44890,
  48851,
  51820,
  56293,
  59774,
  63735,
  4225,
  264,
  13203,
  8730,
  22181,
  18220,
  30135,
  25662,
  40137,
  36160,
  49115,
  44626,
  56045,
  52068,
  63999,
  59510,
  8450,
  12427,
  528,
  5017,
  26406,
  30383,
  17460,
  21949,
  44362,
  48323,
  36440,
  40913,
  60270,
  64231,
  51324,
  55797,
  12675,
  8202,
  4753,
  792,
  30631,
  26158,
  21685,
  17724,
  48587,
  44098,
  40665,
  36688,
  64495,
  60006,
  55549,
  51572,
  16900,
  21389,
  24854,
  28831,
  1056,
  5545,
  10034,
  14011,
  52812,
  57285,
  60766,
  64727,
  34920,
  39393,
  43898,
  47859,
  21125,
  17164,
  29079,
  24606,
  5281,
  1320,
  14259,
  9786,
  57037,
  53060,
  64991,
  60502,
  39145,
  35168,
  48123,
  43634,
  25350,
  29327,
  16404,
  20893,
  9506,
  13483,
  1584,
  6073,
  61262,
  65223,
  52316,
  56789,
  43370,
  47331,
  35448,
  39921,
  29575,
  25102,
  20629,
  16668,
  13731,
  9258,
  5809,
  1848,
  65487,
  60998,
  56541,
  52564,
  47595,
  43106,
  39673,
  35696,
  33800,
  38273,
  42778,
  46739,
  49708,
  54181,
  57662,
  61623,
  2112,
  6601,
  11090,
  15067,
  20068,
  24557,
  28022,
  31999,
  38025,
  34048,
  47003,
  42514,
  53933,
  49956,
  61887,
  57398,
  6337,
  2376,
  15315,
  10842,
  24293,
  20332,
  32247,
  27774,
  42250,
  46211,
  34328,
  38801,
  58158,
  62119,
  49212,
  53685,
  10562,
  14539,
  2640,
  7129,
  28518,
  32495,
  19572,
  24061,
  46475,
  41986,
  38553,
  34576,
  62383,
  57894,
  53437,
  49460,
  14787,
  10314,
  6865,
  2904,
  32743,
  28270,
  23797,
  19836,
  50700,
  55173,
  58654,
  62615,
  32808,
  37281,
  41786,
  45747,
  19012,
  23501,
  26966,
  30943,
  3168,
  7657,
  12146,
  16123,
  54925,
  50948,
  62879,
  58390,
  37033,
  33056,
  46011,
  41522,
  23237,
  19276,
  31191,
  26718,
  7393,
  3432,
  16371,
  11898,
  59150,
  63111,
  50204,
  54677,
  41258,
  45219,
  33336,
  37809,
  27462,
  31439,
  18516,
  23005,
  11618,
  15595,
  3696,
  8185,
  63375,
  58886,
  54429,
  50452,
  45483,
  40994,
  37561,
  33584,
  31687,
  27214,
  22741,
  18780,
  15843,
  11370,
  7921,
  3960
];
if (typeof Int32Array !== "undefined") TABLE$4 = new Int32Array(TABLE$4);
const crc16kermit = defineCrc("kermit", function(buf, previous) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = typeof previous !== "undefined" ? ~~previous : 0;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = (TABLE$4[(crc2 ^ byte) & 255] ^ crc2 >> 8) & 65535;
  }
  return crc2;
});
let TABLE$3 = [
  0,
  8801531,
  9098509,
  825846,
  9692897,
  1419802,
  1651692,
  10452759,
  10584377,
  2608578,
  2839604,
  11344079,
  3303384,
  11807523,
  12104405,
  4128302,
  12930697,
  4391538,
  5217156,
  13227903,
  5679208,
  13690003,
  14450021,
  5910942,
  6606768,
  14844747,
  15604413,
  6837830,
  16197969,
  7431594,
  8256604,
  16494759,
  840169,
  9084178,
  8783076,
  18463,
  10434312,
  1670131,
  1434117,
  9678590,
  11358416,
  2825259,
  2590173,
  10602790,
  4109873,
  12122826,
  11821884,
  3289031,
  13213536,
  5231515,
  4409965,
  12912278,
  5929345,
  14431610,
  13675660,
  5693559,
  6823513,
  15618722,
  14863188,
  6588335,
  16513208,
  8238147,
  7417269,
  16212302,
  1680338,
  10481449,
  9664223,
  1391140,
  9061683,
  788936,
  36926,
  8838341,
  12067563,
  4091408,
  3340262,
  11844381,
  2868234,
  11372785,
  10555655,
  2579964,
  14478683,
  5939616,
  5650518,
  13661357,
  5180346,
  13190977,
  12967607,
  4428364,
  8219746,
  16457881,
  16234863,
  7468436,
  15633027,
  6866552,
  6578062,
  14816117,
  1405499,
  9649856,
  10463030,
  1698765,
  8819930,
  55329,
  803287,
  9047340,
  11858690,
  3325945,
  4072975,
  12086004,
  2561507,
  10574104,
  11387118,
  2853909,
  13647026,
  5664841,
  5958079,
  14460228,
  4446803,
  12949160,
  13176670,
  5194661,
  7454091,
  16249200,
  16476294,
  8201341,
  14834538,
  6559633,
  6852199,
  15647388,
  3360676,
  11864927,
  12161705,
  4185682,
  10527045,
  2551230,
  2782280,
  11286707,
  9619101,
  1346150,
  1577872,
  10379115,
  73852,
  8875143,
  9172337,
  899466,
  16124205,
  7357910,
  8182816,
  16421083,
  6680524,
  14918455,
  15678145,
  6911546,
  5736468,
  13747439,
  14507289,
  5968354,
  12873461,
  4334094,
  5159928,
  13170435,
  4167245,
  12180150,
  11879232,
  3346363,
  11301036,
  2767959,
  2532769,
  10545498,
  10360692,
  1596303,
  1360505,
  9604738,
  913813,
  9157998,
  8856728,
  92259,
  16439492,
  8164415,
  7343561,
  16138546,
  6897189,
  15692510,
  14936872,
  6662099,
  5986813,
  14488838,
  13733104,
  5750795,
  13156124,
  5174247,
  4352529,
  12855018,
  2810998,
  11315341,
  10498427,
  2522496,
  12124823,
  4148844,
  3397530,
  11901793,
  9135439,
  862644,
  110658,
  8912057,
  1606574,
  10407765,
  9590435,
  1317464,
  15706879,
  6940164,
  6651890,
  14889737,
  8145950,
  16384229,
  16161043,
  7394792,
  5123014,
  13133629,
  12910283,
  4370992,
  14535975,
  5997020,
  5707818,
  13718737,
  2504095,
  10516836,
  11329682,
  2796649,
  11916158,
  3383173,
  4130419,
  12143240,
  8893606,
  129117,
  876971,
  9121104,
  1331783,
  9576124,
  10389322,
  1625009,
  14908182,
  6633453,
  6925851,
  15721184,
  7380471,
  16175372,
  16402682,
  8127489,
  4389423,
  12891860,
  13119266,
  5137369,
  13704398,
  5722165,
  6015427,
  14517560
];
if (typeof Int32Array !== "undefined") TABLE$3 = new Int32Array(TABLE$3);
const crc24 = defineCrc("crc-24", function(buf, previous) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = typeof previous !== "undefined" ? ~~previous : 11994318;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = (TABLE$3[(crc2 >> 16 ^ byte) & 255] ^ crc2 << 8) & 16777215;
  }
  return crc2;
});
let TABLE$2 = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
if (typeof Int32Array !== "undefined") TABLE$2 = new Int32Array(TABLE$2);
const crc32$3 = defineCrc("crc-32", function(buf, previous) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = previous === 0 ? 0 : ~~previous ^ -1;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = TABLE$2[(crc2 ^ byte) & 255] ^ crc2 >>> 8;
  }
  return crc2 ^ -1;
});
let TABLE$1 = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
if (typeof Int32Array !== "undefined") TABLE$1 = new Int32Array(TABLE$1);
const crcjam = defineCrc("jam", function(buf, previous = -1) {
  if (!Buffer$1$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = previous === 0 ? 0 : ~~previous;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = TABLE$1[(crc2 ^ byte) & 255] ^ crc2 >>> 8;
  }
  return crc2;
});
const index = {
  crc1,
  crc8,
  crc81wire,
  crc16,
  crc16ccitt,
  crc16modbus,
  crc16xmodem,
  crc16kermit,
  crc24,
  crc32: crc32$3,
  crcjam
};
const crc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  crc1,
  crc16,
  crc16ccitt,
  crc16kermit,
  crc16modbus,
  crc16xmodem,
  crc24,
  crc32: crc32$3,
  crc8,
  crc81wire,
  crcjam,
  default: index
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(crc);
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(utils$i, "__esModule", { value: true });
utils$i.bufferXOR = utils$i.setDifference = utils$i.arrayContains = utils$i.arraysEqual = utils$i.hasPrefix = utils$i.isURType = utils$i.intToBytes = utils$i.toUint32 = utils$i.getCRCHex = utils$i.getCRC = utils$i.split = utils$i.partition = utils$i.sha256Hash = void 0;
const sha_js_1 = __importDefault$8(sha_jsExports);
const crc_1 = require$$1$1;
const sha256Hash = (data) => sha_js_1.default("sha256").update(data).digest();
utils$i.sha256Hash = sha256Hash;
const partition = (s, n) => s.match(new RegExp(".{1," + n + "}", "g")) || [s];
utils$i.partition = partition;
const split$1 = (s, length) => [s.slice(0, -length), s.slice(-length)];
utils$i.split = split$1;
const getCRC = (message2) => crc_1.crc32(message2);
utils$i.getCRC = getCRC;
const getCRCHex = (message2) => crc_1.crc32(message2).toString(16).padStart(8, "0");
utils$i.getCRCHex = getCRCHex;
const toUint32 = (number2) => number2 >>> 0;
utils$i.toUint32 = toUint32;
const intToBytes = (num) => {
  const arr = new ArrayBuffer(4);
  const view = new DataView(arr);
  view.setUint32(0, num, false);
  return Buffer$1$1.from(arr);
};
utils$i.intToBytes = intToBytes;
const isURType = (type) => {
  return type.split("").every((_, index2) => {
    let c = type.charCodeAt(index2);
    if ("a".charCodeAt(0) <= c && c <= "z".charCodeAt(0))
      return true;
    if ("0".charCodeAt(0) <= c && c <= "9".charCodeAt(0))
      return true;
    if (c === "-".charCodeAt(0))
      return true;
    return false;
  });
};
utils$i.isURType = isURType;
const hasPrefix = (s, prefix) => s.indexOf(prefix) === 0;
utils$i.hasPrefix = hasPrefix;
const arraysEqual = (ar1, ar2) => {
  if (ar1.length !== ar2.length) {
    return false;
  }
  return ar1.every((el) => ar2.includes(el));
};
utils$i.arraysEqual = arraysEqual;
const arrayContains = (ar1, ar2) => {
  return ar2.every((v) => ar1.includes(v));
};
utils$i.arrayContains = arrayContains;
const setDifference = (ar1, ar2) => {
  return ar1.filter((x) => ar2.indexOf(x) < 0);
};
utils$i.setDifference = setDifference;
const bufferXOR = (a, b) => {
  const length = Math.max(a.length, b.length);
  const buffer = Buffer$1$1.allocUnsafe(length);
  for (let i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i];
  }
  return buffer;
};
utils$i.bufferXOR = bufferXOR;
var cbor$1 = {};
var main$1 = { exports: {} };
(function(module) {
  (function(global, factory) {
    if (module.exports) {
      module.exports = factory();
    } else {
      global.CBOR = factory();
    }
  })(commonjsGlobal, function() {
    var CBOR = function() {
      function BinaryHex(hex) {
        this.$hex = hex;
      }
      BinaryHex.prototype = {
        length: function() {
          return this.$hex.length / 2;
        },
        toString: function(format) {
          if (!format || format === "hex" || format === 16) return this.$hex;
          if (format === "utf-8") {
            var encoded = "";
            for (var i = 0; i < this.$hex.length; i += 2) {
              encoded += "%" + this.$hex.substring(i, i + 2);
            }
            return decodeURIComponent(encoded);
          }
          if (format === "latin") {
            var encoded = [];
            for (var i = 0; i < this.$hex.length; i += 2) {
              encoded.push(parseInt(this.$hex.substring(i, i + 2), 16));
            }
            return String.fromCharCode.apply(String, encoded);
          }
          throw new Error("Unrecognised format: " + format);
        }
      };
      BinaryHex.fromLatinString = function(latinString) {
        var hex = "";
        for (var i = 0; i < latinString.length; i++) {
          var pair = latinString.charCodeAt(i).toString(16);
          if (pair.length === 1) pair = "0" + pair;
          hex += pair;
        }
        return new BinaryHex(hex);
      };
      BinaryHex.fromUtf8String = function(utf8String) {
        var encoded = encodeURIComponent(utf8String);
        var hex = "";
        for (var i = 0; i < encoded.length; i++) {
          if (encoded.charAt(i) === "%") {
            hex += encoded.substring(i + 1, i + 3);
            i += 2;
          } else {
            var hexPair = encoded.charCodeAt(i).toString(16);
            if (hexPair.length < 2) hexPair = "0" + hexPair;
            hex += hexPair;
          }
        }
        return new BinaryHex(hex);
      };
      var semanticEncoders = [];
      var semanticDecoders = {};
      var notImplemented = function(label) {
        return function() {
          throw new Error(label + " not implemented");
        };
      };
      function Reader() {
      }
      Reader.prototype = {
        peekByte: notImplemented("peekByte"),
        readByte: notImplemented("readByte"),
        readChunk: notImplemented("readChunk"),
        readFloat16: function() {
          var half = this.readUint16();
          var exponent = (half & 32767) >> 10;
          var mantissa = half & 1023;
          var negative = half & 32768;
          if (exponent === 31) {
            if (mantissa === 0) {
              return negative ? -Infinity : Infinity;
            }
            return NaN;
          }
          var magnitude = exponent ? Math.pow(2, exponent - 25) * (1024 + mantissa) : Math.pow(2, -24) * mantissa;
          return negative ? -magnitude : magnitude;
        },
        readFloat32: function() {
          var intValue = this.readUint32();
          var exponent = (intValue & 2147483647) >> 23;
          var mantissa = intValue & 8388607;
          var negative = intValue & 2147483648;
          if (exponent === 255) {
            if (mantissa === 0) {
              return negative ? -Infinity : Infinity;
            }
            return NaN;
          }
          var magnitude = exponent ? Math.pow(2, exponent - 23 - 127) * (8388608 + mantissa) : Math.pow(2, -23 - 126) * mantissa;
          return negative ? -magnitude : magnitude;
        },
        readFloat64: function() {
          var int1 = this.readUint32(), int2 = this.readUint32();
          var exponent = int1 >> 20 & 2047;
          var mantissa = (int1 & 1048575) * 4294967296 + int2;
          var negative = int1 & 2147483648;
          if (exponent === 2047) {
            if (mantissa === 0) {
              return negative ? -Infinity : Infinity;
            }
            return NaN;
          }
          var magnitude = exponent ? Math.pow(2, exponent - 52 - 1023) * (4503599627370496 + mantissa) : Math.pow(2, -52 - 1022) * mantissa;
          return negative ? -magnitude : magnitude;
        },
        readUint16: function() {
          return this.readByte() * 256 + this.readByte();
        },
        readUint32: function() {
          return this.readUint16() * 65536 + this.readUint16();
        },
        readUint64: function() {
          return this.readUint32() * 4294967296 + this.readUint32();
        }
      };
      function Writer() {
      }
      Writer.prototype = {
        writeByte: notImplemented("writeByte"),
        result: notImplemented("result"),
        writeFloat16: notImplemented("writeFloat16"),
        writeFloat32: notImplemented("writeFloat32"),
        writeFloat64: notImplemented("writeFloat64"),
        writeUint16: function(value) {
          this.writeByte(value >> 8 & 255);
          this.writeByte(value & 255);
        },
        writeUint32: function(value) {
          this.writeUint16(value >> 16 & 65535);
          this.writeUint16(value & 65535);
        },
        writeUint64: function(value) {
          if (value >= 9007199254740992 || value <= -9007199254740992) {
            throw new Error("Cannot encode Uint64 of: " + value + " magnitude to big (floating point errors)");
          }
          this.writeUint32(Math.floor(value / 4294967296));
          this.writeUint32(value % 4294967296);
        },
        writeString: notImplemented("writeString"),
        canWriteBinary: function(chunk) {
          return false;
        },
        writeBinary: notImplemented("writeChunk")
      };
      function readHeaderRaw(reader) {
        var firstByte = reader.readByte();
        var majorType = firstByte >> 5, value = firstByte & 31;
        return { type: majorType, value };
      }
      function valueFromHeader(header, reader) {
        var value = header.value;
        if (value < 24) {
          return value;
        } else if (value == 24) {
          return reader.readByte();
        } else if (value == 25) {
          return reader.readUint16();
        } else if (value == 26) {
          return reader.readUint32();
        } else if (value == 27) {
          return reader.readUint64();
        } else if (value == 31) {
          return null;
        }
        notImplemented("Additional info: " + value)();
      }
      function writeHeaderRaw(type, value, writer) {
        writer.writeByte(type << 5 | value);
      }
      function writeHeader(type, value, writer) {
        var firstByte = type << 5;
        if (value < 24) {
          writer.writeByte(firstByte | value);
        } else if (value < 256) {
          writer.writeByte(firstByte | 24);
          writer.writeByte(value);
        } else if (value < 65536) {
          writer.writeByte(firstByte | 25);
          writer.writeUint16(value);
        } else if (value < 4294967296) {
          writer.writeByte(firstByte | 26);
          writer.writeUint32(value);
        } else {
          writer.writeByte(firstByte | 27);
          writer.writeUint64(value);
        }
      }
      var stopCode = new Error();
      function decodeReader(reader) {
        var header = readHeaderRaw(reader);
        switch (header.type) {
          case 0:
            return valueFromHeader(header, reader);
          case 1:
            return -1 - valueFromHeader(header, reader);
          case 2:
            return reader.readChunk(valueFromHeader(header, reader));
          case 3:
            var buffer = reader.readChunk(valueFromHeader(header, reader));
            return buffer.toString("utf-8");
          case 4:
          case 5:
            var arrayLength = valueFromHeader(header, reader);
            var result = [];
            if (arrayLength !== null) {
              if (header.type === 5) {
                arrayLength *= 2;
              }
              for (var i = 0; i < arrayLength; i++) {
                result[i] = decodeReader(reader);
              }
            } else {
              var item;
              while ((item = decodeReader(reader)) !== stopCode) {
                result.push(item);
              }
            }
            if (header.type === 5) {
              var objResult = {};
              for (var i = 0; i < result.length; i += 2) {
                objResult[result[i]] = result[i + 1];
              }
              return objResult;
            } else {
              return result;
            }
          case 6:
            var tag = valueFromHeader(header, reader);
            var decoder = semanticDecoders[tag];
            var result = decodeReader(reader);
            return decoder ? decoder(result) : result;
          case 7:
            if (header.value === 25) {
              return reader.readFloat16();
            } else if (header.value === 26) {
              return reader.readFloat32();
            } else if (header.value === 27) {
              return reader.readFloat64();
            }
            switch (valueFromHeader(header, reader)) {
              case 20:
                return false;
              case 21:
                return true;
              case 22:
                return null;
              case 23:
                return void 0;
              case null:
                return stopCode;
              default:
                throw new Error("Unknown fixed value: " + header.value);
            }
          default:
            throw new Error("Unsupported header: " + JSON.stringify(header));
        }
        throw new Error("not implemented yet");
      }
      function encodeWriter(data, writer) {
        for (var i = 0; i < semanticEncoders.length; i++) {
          var replacement = semanticEncoders[i].fn(data);
          if (replacement !== void 0) {
            writeHeader(6, semanticEncoders[i].tag, writer);
            return encodeWriter(replacement, writer);
          }
        }
        if (data && typeof data.toCBOR === "function") {
          data = data.toCBOR();
        }
        if (data === false) {
          writeHeader(7, 20, writer);
        } else if (data === true) {
          writeHeader(7, 21, writer);
        } else if (data === null) {
          writeHeader(7, 22, writer);
        } else if (data === void 0) {
          writeHeader(7, 23, writer);
        } else if (typeof data === "number") {
          if (Math.floor(data) === data && data < 9007199254740992 && data > -9007199254740992) {
            if (data < 0) {
              writeHeader(1, -1 - data, writer);
            } else {
              writeHeader(0, data, writer);
            }
          } else {
            writeHeaderRaw(7, 27, writer);
            writer.writeFloat64(data);
          }
        } else if (typeof data === "string") {
          writer.writeString(data, function(length) {
            writeHeader(3, length, writer);
          });
        } else if (writer.canWriteBinary(data)) {
          writer.writeBinary(data, function(length) {
            writeHeader(2, length, writer);
          });
        } else if (typeof data === "object") {
          if (api.config.useToJSON && typeof data.toJSON === "function") {
            data = data.toJSON();
          }
          if (Array.isArray(data)) {
            writeHeader(4, data.length, writer);
            for (var i = 0; i < data.length; i++) {
              encodeWriter(data[i], writer);
            }
          } else {
            var keys2 = Object.keys(data);
            writeHeader(5, keys2.length, writer);
            for (var i = 0; i < keys2.length; i++) {
              encodeWriter(keys2[i], writer);
              encodeWriter(data[keys2[i]], writer);
            }
          }
        } else {
          throw new Error("CBOR encoding not supported: " + data);
        }
      }
      var readerFunctions = [];
      var writerFunctions = [];
      var api = {
        config: {
          useToJSON: true
        },
        addWriter: function(format, writerFunction) {
          if (typeof format === "string") {
            writerFunctions.push(function(f2) {
              if (format === f2) return writerFunction(f2);
            });
          } else {
            writerFunctions.push(format);
          }
        },
        addReader: function(format, readerFunction) {
          if (typeof format === "string") {
            readerFunctions.push(function(data, f2) {
              if (format === f2) return readerFunction(data, f2);
            });
          } else {
            readerFunctions.push(format);
          }
        },
        encode: function(data, format) {
          for (var i = 0; i < writerFunctions.length; i++) {
            var func = writerFunctions[i];
            var writer = func(format);
            if (writer) {
              encodeWriter(data, writer);
              return writer.result();
            }
          }
          throw new Error("Unsupported output format: " + format);
        },
        decode: function(data, format) {
          for (var i = 0; i < readerFunctions.length; i++) {
            var func = readerFunctions[i];
            var reader = func(data, format);
            if (reader) {
              return decodeReader(reader);
            }
          }
          throw new Error("Unsupported input format: " + format);
        },
        addSemanticEncode: function(tag, fn) {
          if (typeof tag !== "number" || tag % 1 !== 0 || tag < 0) {
            throw new Error("Tag must be a positive integer");
          }
          semanticEncoders.push({ tag, fn });
          return this;
        },
        addSemanticDecode: function(tag, fn) {
          if (typeof tag !== "number" || tag % 1 !== 0 || tag < 0) {
            throw new Error("Tag must be a positive integer");
          }
          semanticDecoders[tag] = fn;
          return this;
        },
        Reader,
        Writer
      };
      function BufferReader(buffer) {
        this.buffer = buffer;
        this.pos = 0;
      }
      BufferReader.prototype = Object.create(Reader.prototype);
      BufferReader.prototype.peekByte = function() {
        return this.buffer[this.pos];
      };
      BufferReader.prototype.readByte = function() {
        return this.buffer[this.pos++];
      };
      BufferReader.prototype.readUint16 = function() {
        var result = this.buffer.readUInt16BE(this.pos);
        this.pos += 2;
        return result;
      };
      BufferReader.prototype.readUint32 = function() {
        var result = this.buffer.readUInt32BE(this.pos);
        this.pos += 4;
        return result;
      };
      BufferReader.prototype.readFloat32 = function() {
        var result = this.buffer.readFloatBE(this.pos);
        this.pos += 4;
        return result;
      };
      BufferReader.prototype.readFloat64 = function() {
        var result = this.buffer.readDoubleBE(this.pos);
        this.pos += 8;
        return result;
      };
      BufferReader.prototype.readChunk = function(length) {
        var result = Buffer$1$1.alloc(length);
        this.buffer.copy(result, 0, this.pos, this.pos += length);
        return result;
      };
      function BufferWriter(stringFormat) {
        this.byteLength = 0;
        this.defaultBufferLength = 16384;
        this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
        this.latestBufferOffset = 0;
        this.completeBuffers = [];
        this.stringFormat = stringFormat;
      }
      BufferWriter.prototype = Object.create(Writer.prototype);
      BufferWriter.prototype.writeByte = function(value) {
        this.latestBuffer[this.latestBufferOffset++] = value;
        if (this.latestBufferOffset >= this.latestBuffer.length) {
          this.completeBuffers.push(this.latestBuffer);
          this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
          this.latestBufferOffset = 0;
        }
        this.byteLength++;
      };
      BufferWriter.prototype.writeFloat32 = function(value) {
        var buffer = Buffer$1$1.alloc(4);
        buffer.writeFloatBE(value, 0);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.writeFloat64 = function(value) {
        var buffer = Buffer$1$1.alloc(8);
        buffer.writeDoubleBE(value, 0);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.writeString = function(string, lengthFunc) {
        var buffer = Buffer$1$1.from(string, "utf-8");
        lengthFunc(buffer.length);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.canWriteBinary = function(data) {
        return data instanceof Buffer$1$1;
      };
      BufferWriter.prototype.writeBinary = function(buffer, lengthFunc) {
        lengthFunc(buffer.length);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.writeBuffer = function(chunk) {
        if (!(chunk instanceof Buffer$1$1)) throw new TypeError("BufferWriter only accepts Buffers");
        if (!this.latestBufferOffset) {
          this.completeBuffers.push(chunk);
        } else if (this.latestBuffer.length - this.latestBufferOffset >= chunk.length) {
          chunk.copy(this.latestBuffer, this.latestBufferOffset);
          this.latestBufferOffset += chunk.length;
          if (this.latestBufferOffset >= this.latestBuffer.length) {
            this.completeBuffers.push(this.latestBuffer);
            this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
            this.latestBufferOffset = 0;
          }
        } else {
          this.completeBuffers.push(this.latestBuffer.slice(0, this.latestBufferOffset));
          this.completeBuffers.push(chunk);
          this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
          this.latestBufferOffset = 0;
        }
        this.byteLength += chunk.length;
      };
      BufferWriter.prototype.result = function() {
        var result = Buffer$1$1.alloc(this.byteLength);
        var offset = 0;
        for (var i = 0; i < this.completeBuffers.length; i++) {
          var buffer = this.completeBuffers[i];
          buffer.copy(result, offset, 0, buffer.length);
          offset += buffer.length;
        }
        if (this.latestBufferOffset) {
          this.latestBuffer.copy(result, offset, 0, this.latestBufferOffset);
        }
        if (this.stringFormat) return result.toString(this.stringFormat);
        return result;
      };
      if (typeof Buffer$1$1 === "function") {
        api.addReader(function(data, format) {
          if (data instanceof Buffer$1$1) {
            return new BufferReader(data);
          }
          if (format === "hex" || format === "base64") {
            var buffer = Buffer$1$1.from(data, format);
            return new BufferReader(buffer);
          }
        });
        api.addWriter(function(format) {
          if (!format || format === "buffer") {
            return new BufferWriter();
          } else if (format === "hex" || format === "base64") {
            return new BufferWriter(format);
          }
        });
      }
      function HexReader(hex) {
        this.hex = hex;
        this.pos = 0;
      }
      HexReader.prototype = Object.create(Reader.prototype);
      HexReader.prototype.peekByte = function() {
        var pair = this.hex.substring(this.pos, 2);
        return parseInt(pair, 16);
      };
      HexReader.prototype.readByte = function() {
        var pair = this.hex.substring(this.pos, this.pos + 2);
        this.pos += 2;
        return parseInt(pair, 16);
      };
      HexReader.prototype.readChunk = function(length) {
        var hex = this.hex.substring(this.pos, this.pos + length * 2);
        this.pos += length * 2;
        if (typeof Buffer$1$1 === "function") return Buffer$1$1.from(hex, "hex");
        return new BinaryHex(hex);
      };
      function HexWriter(finalFormat) {
        this.$hex = "";
        this.finalFormat = finalFormat || "hex";
      }
      HexWriter.prototype = Object.create(Writer.prototype);
      HexWriter.prototype.writeByte = function(value) {
        if (value < 0 || value > 255) throw new Error("Byte value out of range: " + value);
        var hex = value.toString(16);
        if (hex.length == 1) {
          hex = "0" + hex;
        }
        this.$hex += hex;
      };
      HexWriter.prototype.canWriteBinary = function(chunk) {
        return chunk instanceof BinaryHex || typeof Buffer$1$1 === "function" && chunk instanceof Buffer$1$1;
      };
      HexWriter.prototype.writeBinary = function(chunk, lengthFunction) {
        if (chunk instanceof BinaryHex) {
          lengthFunction(chunk.length());
          this.$hex += chunk.$hex;
        } else if (typeof Buffer$1$1 === "function" && chunk instanceof Buffer$1$1) {
          lengthFunction(chunk.length);
          this.$hex += chunk.toString("hex");
        } else {
          throw new TypeError("HexWriter only accepts BinaryHex or Buffers");
        }
      };
      HexWriter.prototype.result = function() {
        if (this.finalFormat === "buffer" && typeof Buffer$1$1 === "function") {
          return Buffer$1$1.from(this.$hex, "hex");
        }
        return new BinaryHex(this.$hex).toString(this.finalFormat);
      };
      HexWriter.prototype.writeString = function(string, lengthFunction) {
        var buffer = BinaryHex.fromUtf8String(string);
        lengthFunction(buffer.length());
        this.$hex += buffer.$hex;
      };
      api.addReader(function(data, format) {
        if (data instanceof BinaryHex || data.$hex) {
          return new HexReader(data.$hex);
        }
        if (format === "hex") {
          return new HexReader(data);
        }
      });
      api.addWriter(function(format) {
        if (format === "hex") {
          return new HexWriter();
        }
      });
      return api;
    }();
    CBOR.addSemanticEncode(0, function(data) {
      if (data instanceof Date) {
        return data.toISOString();
      }
    }).addSemanticDecode(0, function(isoString) {
      return new Date(isoString);
    }).addSemanticDecode(1, function(isoString) {
      return new Date(isoString);
    });
    return CBOR;
  });
})(main$1);
var mainExports = main$1.exports;
Object.defineProperty(cbor$1, "__esModule", { value: true });
cbor$1.cborDecode = cbor$1.cborEncode = void 0;
const cbor = mainExports;
const cborEncode = (data) => {
  return cbor.encode(data);
};
cbor$1.cborEncode = cborEncode;
const cborDecode = (data) => {
  return cbor.decode(Buffer$1$1.isBuffer(data) ? data : Buffer$1$1.from(data, "hex"));
};
cbor$1.cborDecode = cborDecode;
Object.defineProperty(ur$1, "__esModule", { value: true });
const errors_1$2 = errors$4;
const utils_1$q = utils$i;
const cbor_1$1 = cbor$1;
class UR {
  constructor(_cborPayload, _type = "bytes") {
    this._cborPayload = _cborPayload;
    this._type = _type;
    if (!utils_1$q.isURType(this._type)) {
      throw new errors_1$2.InvalidTypeError();
    }
  }
  static fromBuffer(buf) {
    return new UR(cbor_1$1.cborEncode(buf));
  }
  static from(value, encoding) {
    return UR.fromBuffer(Buffer$1$1.from(value, encoding));
  }
  decodeCBOR() {
    return cbor_1$1.cborDecode(this._cborPayload);
  }
  get type() {
    return this._type;
  }
  get cbor() {
    return this._cborPayload;
  }
  equals(ur2) {
    return this.type === ur2.type && this.cbor.equals(ur2.cbor);
  }
}
ur$1.default = UR;
var urEncoder = {};
var fountainEncoder = {};
var assert$h = { exports: {} };
var errors$3 = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors$3;
  hasRequiredErrors = 1;
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _createClass(Constructor, protoProps, staticProps) {
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  var codes = {};
  var assert2;
  var util$1;
  function createErrorType(code, message2, Base2) {
    if (!Base2) {
      Base2 = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message2 === "string") {
        return message2;
      } else {
        return message2(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ function(_Base) {
      _inherits(NodeError2, _Base);
      var _super = _createSuper(NodeError2);
      function NodeError2(arg1, arg2, arg3) {
        var _this;
        _classCallCheck(this, NodeError2);
        _this = _super.call(this, getMessage(arg1, arg2, arg3));
        _this.code = code;
        return _this;
      }
      return _createClass(NodeError2);
    }(Base2);
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i) {
        return String(i);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    if (assert2 === void 0) assert2 = requireAssert();
    assert2(typeof name2 === "string", "'name' must be a string");
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg2;
    if (endsWith(name2, " argument")) {
      msg2 = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type = includes(name2, ".") ? "property" : "argument";
      msg2 = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg2 += ". Received type ".concat(_typeof(actual));
    return msg2;
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_VALUE", function(name2, value) {
    var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    if (util$1 === void 0) util$1 = util;
    var inspected = util$1.inspect(value);
    if (inspected.length > 128) {
      inspected = "".concat(inspected.slice(0, 128), "...");
    }
    return "The argument '".concat(name2, "' ").concat(reason, ". Received ").concat(inspected);
  }, TypeError);
  createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name2, value) {
    var type;
    if (value && value.constructor && value.constructor.name) {
      type = "instance of ".concat(value.constructor.name);
    } else {
      type = "type ".concat(_typeof(value));
    }
    return "Expected ".concat(input, ' to be returned from the "').concat(name2, '"') + " function but got ".concat(type, ".");
  }, TypeError);
  createErrorType("ERR_MISSING_ARGS", function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (assert2 === void 0) assert2 = requireAssert();
    assert2(args.length > 0, "At least one arg needs to be specified");
    var msg2 = "The ";
    var len = args.length;
    args = args.map(function(a) {
      return '"'.concat(a, '"');
    });
    switch (len) {
      case 1:
        msg2 += "".concat(args[0], " argument");
        break;
      case 2:
        msg2 += "".concat(args[0], " and ").concat(args[1], " arguments");
        break;
      default:
        msg2 += args.slice(0, len - 1).join(", ");
        msg2 += ", and ".concat(args[len - 1], " arguments");
        break;
    }
    return "".concat(msg2, " must be specified");
  }, TypeError);
  errors$3.codes = codes;
  return errors$3;
}
var assertion_error;
var hasRequiredAssertion_error;
function requireAssertion_error() {
  if (hasRequiredAssertion_error) return assertion_error;
  hasRequiredAssertion_error = 1;
  function ownKeys2(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function _defineProperty(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return _typeof(key2) === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2)) return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2) _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  var _require = util, inspect6 = _require.inspect;
  var _require2 = requireErrors(), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function repeat(str, count) {
    count = Math.floor(count);
    if (str.length == 0 || count == 0) return "";
    var maxCount = str.length * count;
    count = Math.floor(Math.log(count) / Math.log(2));
    while (count) {
      str += str;
      count--;
    }
    str += str.substring(0, maxCount - str.length);
    return str;
  }
  var blue = "";
  var green = "";
  var red = "";
  var white = "";
  var kReadableOperator = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  };
  var kMaxShortLength = 10;
  function copyError(source) {
    var keys2 = Object.keys(source);
    var target = Object.create(Object.getPrototypeOf(source));
    keys2.forEach(function(key2) {
      target[key2] = source[key2];
    });
    Object.defineProperty(target, "message", {
      value: source.message
    });
    return target;
  }
  function inspectValue(val) {
    return inspect6(val, {
      compact: false,
      customInspect: false,
      depth: 1e3,
      maxArrayLength: Infinity,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: false,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: Infinity,
      // Assert does not detect proxies currently.
      showProxy: false,
      sorted: true,
      // Inspect getters as we also check them when comparing entries.
      getters: true
    });
  }
  function createErrDiff(actual, expected, operator) {
    var other = "";
    var res = "";
    var lastPos = 0;
    var end = "";
    var skipped = false;
    var actualInspected = inspectValue(actual);
    var actualLines = actualInspected.split("\n");
    var expectedLines = inspectValue(expected).split("\n");
    var i = 0;
    var indicator = "";
    if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
      operator = "strictEqualObject";
    }
    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
      var inputLength = actualLines[0].length + expectedLines[0].length;
      if (inputLength <= kMaxShortLength) {
        if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
          return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
        }
      } else if (operator !== "strictEqualObject") {
        var maxLength = process$1.stderr && process$1.stderr.isTTY ? process$1.stderr.columns : 80;
        if (inputLength < maxLength) {
          while (actualLines[0][i] === expectedLines[0][i]) {
            i++;
          }
          if (i > 2) {
            indicator = "\n  ".concat(repeat(" ", i), "^");
            i = 0;
          }
        }
      }
    }
    var a = actualLines[actualLines.length - 1];
    var b = expectedLines[expectedLines.length - 1];
    while (a === b) {
      if (i++ < 2) {
        end = "\n  ".concat(a).concat(end);
      } else {
        other = a;
      }
      actualLines.pop();
      expectedLines.pop();
      if (actualLines.length === 0 || expectedLines.length === 0) break;
      a = actualLines[actualLines.length - 1];
      b = expectedLines[expectedLines.length - 1];
    }
    var maxLines = Math.max(actualLines.length, expectedLines.length);
    if (maxLines === 0) {
      var _actualLines = actualInspected.split("\n");
      if (_actualLines.length > 30) {
        _actualLines[26] = "".concat(blue, "...").concat(white);
        while (_actualLines.length > 27) {
          _actualLines.pop();
        }
      }
      return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
    }
    if (i > 3) {
      end = "\n".concat(blue, "...").concat(white).concat(end);
      skipped = true;
    }
    if (other !== "") {
      end = "\n  ".concat(other).concat(end);
      other = "";
    }
    var printedLines = 0;
    var msg2 = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
    for (i = 0; i < maxLines; i++) {
      var cur = i - lastPos;
      if (actualLines.length < i + 1) {
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(expectedLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(expectedLines[i - 1]);
          printedLines++;
        }
        lastPos = i;
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
        printedLines++;
      } else if (expectedLines.length < i + 1) {
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        lastPos = i;
        res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
        printedLines++;
      } else {
        var expectedLine = expectedLines[i];
        var actualLine = actualLines[i];
        var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
        if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
          divergingLines = false;
          actualLine += ",";
        }
        if (divergingLines) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(actualLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(actualLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
          other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
          printedLines += 2;
        } else {
          res += other;
          other = "";
          if (cur === 1 || i === 0) {
            res += "\n  ".concat(actualLine);
            printedLines++;
          }
        }
      }
      if (printedLines > 20 && i < maxLines - 2) {
        return "".concat(msg2).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
      }
    }
    return "".concat(msg2).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
  }
  var AssertionError = /* @__PURE__ */ function(_Error, _inspect$custom) {
    _inherits(AssertionError2, _Error);
    var _super = _createSuper(AssertionError2);
    function AssertionError2(options) {
      var _this;
      _classCallCheck(this, AssertionError2);
      if (_typeof(options) !== "object" || options === null) {
        throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
      }
      var message2 = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
      var actual = options.actual, expected = options.expected;
      var limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      if (message2 != null) {
        _this = _super.call(this, String(message2));
      } else {
        if (process$1.stderr && process$1.stderr.isTTY) {
          if (process$1.stderr && process$1.stderr.getColorDepth && process$1.stderr.getColorDepth() !== 1) {
            blue = "\x1B[34m";
            green = "\x1B[32m";
            white = "\x1B[39m";
            red = "\x1B[31m";
          } else {
            blue = "";
            green = "";
            white = "";
            red = "";
          }
        }
        if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
          actual = copyError(actual);
          expected = copyError(expected);
        }
        if (operator === "deepStrictEqual" || operator === "strictEqual") {
          _this = _super.call(this, createErrDiff(actual, expected, operator));
        } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
          var base2 = kReadableOperator[operator];
          var res = inspectValue(actual).split("\n");
          if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
            base2 = kReadableOperator.notStrictEqualObject;
          }
          if (res.length > 30) {
            res[26] = "".concat(blue, "...").concat(white);
            while (res.length > 27) {
              res.pop();
            }
          }
          if (res.length === 1) {
            _this = _super.call(this, "".concat(base2, " ").concat(res[0]));
          } else {
            _this = _super.call(this, "".concat(base2, "\n\n").concat(res.join("\n"), "\n"));
          }
        } else {
          var _res = inspectValue(actual);
          var other = "";
          var knownOperators = kReadableOperator[operator];
          if (operator === "notDeepEqual" || operator === "notEqual") {
            _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
            if (_res.length > 1024) {
              _res = "".concat(_res.slice(0, 1021), "...");
            }
          } else {
            other = "".concat(inspectValue(expected));
            if (_res.length > 512) {
              _res = "".concat(_res.slice(0, 509), "...");
            }
            if (other.length > 512) {
              other = "".concat(other.slice(0, 509), "...");
            }
            if (operator === "deepEqual" || operator === "equal") {
              _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
            } else {
              other = " ".concat(operator, " ").concat(other);
            }
          }
          _this = _super.call(this, "".concat(_res).concat(other));
        }
      }
      Error.stackTraceLimit = limit;
      _this.generatedMessage = !message2;
      Object.defineProperty(_assertThisInitialized(_this), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: false,
        writable: true,
        configurable: true
      });
      _this.code = "ERR_ASSERTION";
      _this.actual = actual;
      _this.expected = expected;
      _this.operator = operator;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
      }
      _this.stack;
      _this.name = "AssertionError";
      return _possibleConstructorReturn(_this);
    }
    _createClass(AssertionError2, [{
      key: "toString",
      value: function toString2() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: _inspect$custom,
      value: function value(recurseTimes, ctx) {
        return inspect6(this, _objectSpread(_objectSpread({}, ctx), {}, {
          customInspect: false,
          depth: 0
        }));
      }
    }]);
    return AssertionError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error), inspect6.custom);
  assertion_error = AssertionError;
  return assertion_error;
}
var toStr = Object.prototype.toString;
var isArguments = function isArguments2(value) {
  var str = toStr.call(value);
  var isArgs2 = str === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var implementation$5;
var hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1) return implementation$5;
  hasRequiredImplementation$1 = 1;
  var keysShim2;
  if (!Object.keys) {
    var has = Object.prototype.hasOwnProperty;
    var toStr2 = Object.prototype.toString;
    var isArgs2 = isArguments;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim2 = function keys2(object) {
      var isObject = object !== null && typeof object === "object";
      var isFunction = toStr2.call(object) === "[object Function]";
      var isArguments3 = isArgs2(object);
      var isString = isObject && toStr2.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject && !isFunction && !isArguments3) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction;
      if (isString && object.length > 0 && !has.call(object, 0)) {
        for (var i = 0; i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments3 && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name2 in object) {
          if (!(skipProto && name2 === "prototype") && has.call(object, name2)) {
            theKeys.push(String(name2));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k = 0; k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$5 = keysShim2;
  return implementation$5;
}
var slice = Array.prototype.slice;
var isArgs = isArguments;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : requireImplementation$1();
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys2(object) {
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys$1 = keysShim;
var objectKeys = objectKeys$1;
var hasSymbols = shams();
var callBound = callBound$1;
var toObject = Object;
var $push = callBound("Array.prototype.push");
var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
var implementation$4 = function assign(target, source1) {
  if (target == null) {
    throw new TypeError("target must be an object");
  }
  var to = toObject(target);
  if (arguments.length === 1) {
    return to;
  }
  for (var s = 1; s < arguments.length; ++s) {
    var from = toObject(arguments[s]);
    var keys2 = objectKeys(from);
    var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
    if (getSymbols) {
      var syms = getSymbols(from);
      for (var j = 0; j < syms.length; ++j) {
        var key2 = syms[j];
        if ($propIsEnumerable(from, key2)) {
          $push(keys2, key2);
        }
      }
    }
    for (var i = 0; i < keys2.length; ++i) {
      var nextKey = keys2[i];
      if ($propIsEnumerable(from, nextKey)) {
        var propValue = from[nextKey];
        to[nextKey] = propValue;
      }
    }
  }
  return to;
};
var implementation$3 = implementation$4;
var lacksProperEnumerationOrder = function() {
  if (!Object.assign) {
    return false;
  }
  var str = "abcdefghijklmnopqrst";
  var letters = str.split("");
  var map = {};
  for (var i = 0; i < letters.length; ++i) {
    map[letters[i]] = letters[i];
  }
  var obj = Object.assign({}, map);
  var actual = "";
  for (var k in obj) {
    actual += k;
  }
  return str !== actual;
};
var assignHasPendingExceptions = function() {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  var thrower = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(thrower, "xy");
  } catch (e) {
    return thrower[1] === "y";
  }
  return false;
};
var polyfill$2 = function getPolyfill() {
  if (!Object.assign) {
    return implementation$3;
  }
  if (lacksProperEnumerationOrder()) {
    return implementation$3;
  }
  if (assignHasPendingExceptions()) {
    return implementation$3;
  }
  return Object.assign;
};
var numberIsNaN = function(value) {
  return value !== value;
};
var implementation$2 = function is(a, b) {
  if (a === 0 && b === 0) {
    return 1 / a === 1 / b;
  }
  if (a === b) {
    return true;
  }
  if (numberIsNaN(a) && numberIsNaN(b)) {
    return true;
  }
  return false;
};
var implementation$1 = implementation$2;
var polyfill$1 = function getPolyfill2() {
  return typeof Object.is === "function" ? Object.is : implementation$1;
};
var defineProperties_1;
var hasRequiredDefineProperties;
function requireDefineProperties() {
  if (hasRequiredDefineProperties) return defineProperties_1;
  hasRequiredDefineProperties = 1;
  var keys2 = objectKeys$1;
  var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr2 = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var defineDataProperty$1 = defineDataProperty;
  var isFunction = function(fn) {
    return typeof fn === "function" && toStr2.call(fn) === "[object Function]";
  };
  var supportsDescriptors = hasPropertyDescriptors_1();
  var defineProperty = function(object, name2, value, predicate) {
    if (name2 in object) {
      if (predicate === true) {
        if (object[name2] === value) {
          return;
        }
      } else if (!isFunction(predicate) || !predicate()) {
        return;
      }
    }
    if (supportsDescriptors) {
      defineDataProperty$1(object, name2, value, true);
    } else {
      defineDataProperty$1(object, name2, value);
    }
  };
  var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props2 = keys2(map);
    if (hasSymbols2) {
      props2 = concat.call(props2, Object.getOwnPropertySymbols(map));
    }
    for (var i = 0; i < props2.length; i += 1) {
      defineProperty(object, props2[i], map[props2[i]], predicates[props2[i]]);
    }
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  defineProperties_1 = defineProperties;
  return defineProperties_1;
}
var shim$1;
var hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1) return shim$1;
  hasRequiredShim$1 = 1;
  var getPolyfill3 = polyfill$1;
  var define = requireDefineProperties();
  shim$1 = function shimObjectIs() {
    var polyfill2 = getPolyfill3();
    define(Object, { is: polyfill2 }, {
      is: function testObjectIs() {
        return Object.is !== polyfill2;
      }
    });
    return polyfill2;
  };
  return shim$1;
}
var objectIs;
var hasRequiredObjectIs;
function requireObjectIs() {
  if (hasRequiredObjectIs) return objectIs;
  hasRequiredObjectIs = 1;
  var define = requireDefineProperties();
  var callBind = callBindExports;
  var implementation2 = implementation$2;
  var getPolyfill3 = polyfill$1;
  var shim2 = requireShim$1();
  var polyfill2 = callBind(getPolyfill3(), Object);
  define(polyfill2, {
    getPolyfill: getPolyfill3,
    implementation: implementation2,
    shim: shim2
  });
  objectIs = polyfill2;
  return objectIs;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  implementation = function isNaN2(value) {
    return value !== value;
  };
  return implementation;
}
var polyfill;
var hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill) return polyfill;
  hasRequiredPolyfill = 1;
  var implementation2 = requireImplementation();
  polyfill = function getPolyfill3() {
    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
      return Number.isNaN;
    }
    return implementation2;
  };
  return polyfill;
}
var shim;
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim;
  hasRequiredShim = 1;
  var define = requireDefineProperties();
  var getPolyfill3 = requirePolyfill();
  shim = function shimNumberIsNaN() {
    var polyfill2 = getPolyfill3();
    define(Number, { isNaN: polyfill2 }, {
      isNaN: function testIsNaN() {
        return Number.isNaN !== polyfill2;
      }
    });
    return polyfill2;
  };
  return shim;
}
var isNan;
var hasRequiredIsNan;
function requireIsNan() {
  if (hasRequiredIsNan) return isNan;
  hasRequiredIsNan = 1;
  var callBind = callBindExports;
  var define = requireDefineProperties();
  var implementation2 = requireImplementation();
  var getPolyfill3 = requirePolyfill();
  var shim2 = requireShim();
  var polyfill2 = callBind(getPolyfill3(), Number);
  define(polyfill2, {
    getPolyfill: getPolyfill3,
    implementation: implementation2,
    shim: shim2
  });
  isNan = polyfill2;
  return isNan;
}
var comparisons;
var hasRequiredComparisons;
function requireComparisons() {
  if (hasRequiredComparisons) return comparisons;
  hasRequiredComparisons = 1;
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e, n, i, u, a = [], f2 = true, o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l) ;
        else for (; !(f2 = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f2 = true) ;
      } catch (r2) {
        o = true, n = r2;
      } finally {
        try {
          if (!f2 && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  var regexFlagsSupported = /a/g.flags !== void 0;
  var arrayFromSet = function arrayFromSet2(set) {
    var array = [];
    set.forEach(function(value) {
      return array.push(value);
    });
    return array;
  };
  var arrayFromMap = function arrayFromMap2(map) {
    var array = [];
    map.forEach(function(value, key2) {
      return array.push([key2, value]);
    });
    return array;
  };
  var objectIs2 = Object.is ? Object.is : requireObjectIs();
  var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  };
  var numberIsNaN2 = Number.isNaN ? Number.isNaN : requireIsNan();
  function uncurryThis(f2) {
    return f2.call.bind(f2);
  }
  var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
  var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
  var objectToString = uncurryThis(Object.prototype.toString);
  var _require$types = util.types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
  function isNonIndex(key2) {
    if (key2.length === 0 || key2.length > 10) return true;
    for (var i = 0; i < key2.length; i++) {
      var code = key2.charCodeAt(i);
      if (code < 48 || code > 57) return true;
    }
    return key2.length === 10 && key2 >= Math.pow(2, 32);
  }
  function getOwnNonIndexProperties(value) {
    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function compare2(a, b) {
    if (a === b) {
      return 0;
    }
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) {
      return -1;
    }
    if (y < x) {
      return 1;
    }
    return 0;
  }
  var kStrict = true;
  var kLoose = false;
  var kNoIterator = 0;
  var kIsArray = 1;
  var kIsSet = 2;
  var kIsMap = 3;
  function areSimilarRegExps(a, b) {
    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
  }
  function areSimilarFloatArrays(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (var offset = 0; offset < a.byteLength; offset++) {
      if (a[offset] !== b[offset]) {
        return false;
      }
    }
    return true;
  }
  function areSimilarTypedArrays(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    return compare2(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
  }
  function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && compare2(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
  }
  function isEqualBoxedPrimitive(val1, val2) {
    if (isNumberObject(val1)) {
      return isNumberObject(val2) && objectIs2(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
    }
    if (isStringObject(val1)) {
      return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
    }
    if (isBooleanObject(val1)) {
      return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
    }
    if (isBigIntObject(val1)) {
      return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
    }
    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
  }
  function innerDeepEqual(val1, val2, strict, memos) {
    if (val1 === val2) {
      if (val1 !== 0) return true;
      return strict ? objectIs2(val1, val2) : true;
    }
    if (strict) {
      if (_typeof(val1) !== "object") {
        return typeof val1 === "number" && numberIsNaN2(val1) && numberIsNaN2(val2);
      }
      if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
        return false;
      }
      if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
        return false;
      }
    } else {
      if (val1 === null || _typeof(val1) !== "object") {
        if (val2 === null || _typeof(val2) !== "object") {
          return val1 == val2;
        }
        return false;
      }
      if (val2 === null || _typeof(val2) !== "object") {
        return false;
      }
    }
    var val1Tag = objectToString(val1);
    var val2Tag = objectToString(val2);
    if (val1Tag !== val2Tag) {
      return false;
    }
    if (Array.isArray(val1)) {
      if (val1.length !== val2.length) {
        return false;
      }
      var keys1 = getOwnNonIndexProperties(val1);
      var keys2 = getOwnNonIndexProperties(val2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
    }
    if (val1Tag === "[object Object]") {
      if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
        return false;
      }
    }
    if (isDate(val1)) {
      if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
        return false;
      }
    } else if (isRegExp(val1)) {
      if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
        return false;
      }
    } else if (isNativeError(val1) || val1 instanceof Error) {
      if (val1.message !== val2.message || val1.name !== val2.name) {
        return false;
      }
    } else if (isArrayBufferView(val1)) {
      if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
        if (!areSimilarFloatArrays(val1, val2)) {
          return false;
        }
      } else if (!areSimilarTypedArrays(val1, val2)) {
        return false;
      }
      var _keys = getOwnNonIndexProperties(val1);
      var _keys2 = getOwnNonIndexProperties(val2);
      if (_keys.length !== _keys2.length) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
    } else if (isSet(val1)) {
      if (!isSet(val2) || val1.size !== val2.size) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsSet);
    } else if (isMap(val1)) {
      if (!isMap(val2) || val1.size !== val2.size) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsMap);
    } else if (isAnyArrayBuffer(val1)) {
      if (!areEqualArrayBuffers(val1, val2)) {
        return false;
      }
    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator);
  }
  function getEnumerables(val, keys2) {
    return keys2.filter(function(k) {
      return propertyIsEnumerable(val, k);
    });
  }
  function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
    if (arguments.length === 5) {
      aKeys = Object.keys(val1);
      var bKeys = Object.keys(val2);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
    }
    var i = 0;
    for (; i < aKeys.length; i++) {
      if (!hasOwnProperty(val2, aKeys[i])) {
        return false;
      }
    }
    if (strict && arguments.length === 5) {
      var symbolKeysA = objectGetOwnPropertySymbols(val1);
      if (symbolKeysA.length !== 0) {
        var count = 0;
        for (i = 0; i < symbolKeysA.length; i++) {
          var key2 = symbolKeysA[i];
          if (propertyIsEnumerable(val1, key2)) {
            if (!propertyIsEnumerable(val2, key2)) {
              return false;
            }
            aKeys.push(key2);
            count++;
          } else if (propertyIsEnumerable(val2, key2)) {
            return false;
          }
        }
        var symbolKeysB = objectGetOwnPropertySymbols(val2);
        if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
          return false;
        }
      } else {
        var _symbolKeysB = objectGetOwnPropertySymbols(val2);
        if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
          return false;
        }
      }
    }
    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
      return true;
    }
    if (memos === void 0) {
      memos = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    } else {
      var val2MemoA = memos.val1.get(val1);
      if (val2MemoA !== void 0) {
        var val2MemoB = memos.val2.get(val2);
        if (val2MemoB !== void 0) {
          return val2MemoA === val2MemoB;
        }
      }
      memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
  }
  function setHasEqualElement(set, val1, strict, memo) {
    var setValues = arrayFromSet(set);
    for (var i = 0; i < setValues.length; i++) {
      var val2 = setValues[i];
      if (innerDeepEqual(val1, val2, strict, memo)) {
        set.delete(val2);
        return true;
      }
    }
    return false;
  }
  function findLooseMatchingPrimitives(prim) {
    switch (_typeof(prim)) {
      case "undefined":
        return null;
      case "object":
        return void 0;
      case "symbol":
        return false;
      case "string":
        prim = +prim;
      case "number":
        if (numberIsNaN2(prim)) {
          return false;
        }
    }
    return true;
  }
  function setMightHaveLoosePrim(a, b, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) return altValue;
    return b.has(altValue) && !a.has(altValue);
  }
  function mapMightHaveLoosePrim(a, b, prim, item, memo) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) {
      return altValue;
    }
    var curB = b.get(altValue);
    if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
      return false;
    }
    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
  }
  function setEquiv(a, b, strict, memo) {
    var set = null;
    var aValues = arrayFromSet(a);
    for (var i = 0; i < aValues.length; i++) {
      var val = aValues[i];
      if (_typeof(val) === "object" && val !== null) {
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(val);
      } else if (!b.has(val)) {
        if (strict) return false;
        if (!setMightHaveLoosePrim(a, b, val)) {
          return false;
        }
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(val);
      }
    }
    if (set !== null) {
      var bValues = arrayFromSet(b);
      for (var _i = 0; _i < bValues.length; _i++) {
        var _val = bValues[_i];
        if (_typeof(_val) === "object" && _val !== null) {
          if (!setHasEqualElement(set, _val, strict, memo)) return false;
        } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
          return false;
        }
      }
      return set.size === 0;
    }
    return true;
  }
  function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
    var setValues = arrayFromSet(set);
    for (var i = 0; i < setValues.length; i++) {
      var key2 = setValues[i];
      if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
        set.delete(key2);
        return true;
      }
    }
    return false;
  }
  function mapEquiv(a, b, strict, memo) {
    var set = null;
    var aEntries = arrayFromMap(a);
    for (var i = 0; i < aEntries.length; i++) {
      var _aEntries$i = _slicedToArray(aEntries[i], 2), key2 = _aEntries$i[0], item1 = _aEntries$i[1];
      if (_typeof(key2) === "object" && key2 !== null) {
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(key2);
      } else {
        var item2 = b.get(key2);
        if (item2 === void 0 && !b.has(key2) || !innerDeepEqual(item1, item2, strict, memo)) {
          if (strict) return false;
          if (!mapMightHaveLoosePrim(a, b, key2, item1, memo)) return false;
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(key2);
        }
      }
    }
    if (set !== null) {
      var bEntries = arrayFromMap(b);
      for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
        var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
        if (_typeof(_key) === "object" && _key !== null) {
          if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
        } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
          return false;
        }
      }
      return set.size === 0;
    }
    return true;
  }
  function objEquiv(a, b, strict, keys2, memos, iterationType) {
    var i = 0;
    if (iterationType === kIsSet) {
      if (!setEquiv(a, b, strict, memos)) {
        return false;
      }
    } else if (iterationType === kIsMap) {
      if (!mapEquiv(a, b, strict, memos)) {
        return false;
      }
    } else if (iterationType === kIsArray) {
      for (; i < a.length; i++) {
        if (hasOwnProperty(a, i)) {
          if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
            return false;
          }
        } else if (hasOwnProperty(b, i)) {
          return false;
        } else {
          var keysA = Object.keys(a);
          for (; i < keysA.length; i++) {
            var key2 = keysA[i];
            if (!hasOwnProperty(b, key2) || !innerDeepEqual(a[key2], b[key2], strict, memos)) {
              return false;
            }
          }
          if (keysA.length !== Object.keys(b).length) {
            return false;
          }
          return true;
        }
      }
    }
    for (i = 0; i < keys2.length; i++) {
      var _key2 = keys2[i];
      if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
        return false;
      }
    }
    return true;
  }
  function isDeepEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kLoose);
  }
  function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kStrict);
  }
  comparisons = {
    isDeepEqual,
    isDeepStrictEqual
  };
  return comparisons;
}
var hasRequiredAssert;
function requireAssert() {
  if (hasRequiredAssert) return assert$h.exports;
  hasRequiredAssert = 1;
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _createClass(Constructor, protoProps, staticProps) {
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var _require = requireErrors(), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var AssertionError = requireAssertion_error();
  var _require2 = util, inspect6 = _require2.inspect;
  var _require$types = util.types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
  var objectAssign = polyfill$2();
  var objectIs2 = polyfill$1();
  var RegExpPrototypeTest = callBound$1("RegExp.prototype.test");
  var isDeepEqual;
  var isDeepStrictEqual;
  function lazyLoadComparison() {
    var comparison = requireComparisons();
    isDeepEqual = comparison.isDeepEqual;
    isDeepStrictEqual = comparison.isDeepStrictEqual;
  }
  var warned = false;
  var assert2 = assert$h.exports = ok;
  var NO_EXCEPTION_SENTINEL = {};
  function innerFail(obj) {
    if (obj.message instanceof Error) throw obj.message;
    throw new AssertionError(obj);
  }
  function fail(actual, expected, message2, operator, stackStartFn) {
    var argsLen = arguments.length;
    var internalMessage;
    if (argsLen === 0) {
      internalMessage = "Failed";
    } else if (argsLen === 1) {
      message2 = actual;
      actual = void 0;
    } else {
      if (warned === false) {
        warned = true;
        var warn = process$1.emitWarning ? process$1.emitWarning : console.warn.bind(console);
        warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      if (argsLen === 2) operator = "!=";
    }
    if (message2 instanceof Error) throw message2;
    var errArgs = {
      actual,
      expected,
      operator: operator === void 0 ? "fail" : operator,
      stackStartFn: stackStartFn || fail
    };
    if (message2 !== void 0) {
      errArgs.message = message2;
    }
    var err2 = new AssertionError(errArgs);
    if (internalMessage) {
      err2.message = internalMessage;
      err2.generatedMessage = true;
    }
    throw err2;
  }
  assert2.fail = fail;
  assert2.AssertionError = AssertionError;
  function innerOk(fn, argLen, value, message2) {
    if (!value) {
      var generatedMessage = false;
      if (argLen === 0) {
        generatedMessage = true;
        message2 = "No value argument passed to `assert.ok()`";
      } else if (message2 instanceof Error) {
        throw message2;
      }
      var err2 = new AssertionError({
        actual: value,
        expected: true,
        message: message2,
        operator: "==",
        stackStartFn: fn
      });
      err2.generatedMessage = generatedMessage;
      throw err2;
    }
  }
  function ok() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    innerOk.apply(void 0, [ok, args.length].concat(args));
  }
  assert2.ok = ok;
  assert2.equal = function equal(actual, expected, message2) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (actual != expected) {
      innerFail({
        actual,
        expected,
        message: message2,
        operator: "==",
        stackStartFn: equal
      });
    }
  };
  assert2.notEqual = function notEqual(actual, expected, message2) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (actual == expected) {
      innerFail({
        actual,
        expected,
        message: message2,
        operator: "!=",
        stackStartFn: notEqual
      });
    }
  };
  assert2.deepEqual = function deepEqual(actual, expected, message2) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0) lazyLoadComparison();
    if (!isDeepEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message: message2,
        operator: "deepEqual",
        stackStartFn: deepEqual
      });
    }
  };
  assert2.notDeepEqual = function notDeepEqual(actual, expected, message2) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0) lazyLoadComparison();
    if (isDeepEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message: message2,
        operator: "notDeepEqual",
        stackStartFn: notDeepEqual
      });
    }
  };
  assert2.deepStrictEqual = function deepStrictEqual(actual, expected, message2) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0) lazyLoadComparison();
    if (!isDeepStrictEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message: message2,
        operator: "deepStrictEqual",
        stackStartFn: deepStrictEqual
      });
    }
  };
  assert2.notDeepStrictEqual = notDeepStrictEqual;
  function notDeepStrictEqual(actual, expected, message2) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0) lazyLoadComparison();
    if (isDeepStrictEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message: message2,
        operator: "notDeepStrictEqual",
        stackStartFn: notDeepStrictEqual
      });
    }
  }
  assert2.strictEqual = function strictEqual(actual, expected, message2) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (!objectIs2(actual, expected)) {
      innerFail({
        actual,
        expected,
        message: message2,
        operator: "strictEqual",
        stackStartFn: strictEqual
      });
    }
  };
  assert2.notStrictEqual = function notStrictEqual(actual, expected, message2) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (objectIs2(actual, expected)) {
      innerFail({
        actual,
        expected,
        message: message2,
        operator: "notStrictEqual",
        stackStartFn: notStrictEqual
      });
    }
  };
  var Comparison = /* @__PURE__ */ _createClass(function Comparison2(obj, keys2, actual) {
    var _this = this;
    _classCallCheck(this, Comparison2);
    keys2.forEach(function(key2) {
      if (key2 in obj) {
        if (actual !== void 0 && typeof actual[key2] === "string" && isRegExp(obj[key2]) && RegExpPrototypeTest(obj[key2], actual[key2])) {
          _this[key2] = actual[key2];
        } else {
          _this[key2] = obj[key2];
        }
      }
    });
  });
  function compareExceptionKey(actual, expected, key2, message2, keys2, fn) {
    if (!(key2 in actual) || !isDeepStrictEqual(actual[key2], expected[key2])) {
      if (!message2) {
        var a = new Comparison(actual, keys2);
        var b = new Comparison(expected, keys2, actual);
        var err2 = new AssertionError({
          actual: a,
          expected: b,
          operator: "deepStrictEqual",
          stackStartFn: fn
        });
        err2.actual = actual;
        err2.expected = expected;
        err2.operator = fn.name;
        throw err2;
      }
      innerFail({
        actual,
        expected,
        message: message2,
        operator: fn.name,
        stackStartFn: fn
      });
    }
  }
  function expectedException(actual, expected, msg2, fn) {
    if (typeof expected !== "function") {
      if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
      if (arguments.length === 2) {
        throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
      }
      if (_typeof(actual) !== "object" || actual === null) {
        var err2 = new AssertionError({
          actual,
          expected,
          message: msg2,
          operator: "deepStrictEqual",
          stackStartFn: fn
        });
        err2.operator = fn.name;
        throw err2;
      }
      var keys2 = Object.keys(expected);
      if (expected instanceof Error) {
        keys2.push("name", "message");
      } else if (keys2.length === 0) {
        throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
      }
      if (isDeepEqual === void 0) lazyLoadComparison();
      keys2.forEach(function(key2) {
        if (typeof actual[key2] === "string" && isRegExp(expected[key2]) && RegExpPrototypeTest(expected[key2], actual[key2])) {
          return;
        }
        compareExceptionKey(actual, expected, key2, msg2, keys2, fn);
      });
      return true;
    }
    if (expected.prototype !== void 0 && actual instanceof expected) {
      return true;
    }
    if (Error.isPrototypeOf(expected)) {
      return false;
    }
    return expected.call({}, actual) === true;
  }
  function getActual(fn) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
    }
    try {
      fn();
    } catch (e) {
      return e;
    }
    return NO_EXCEPTION_SENTINEL;
  }
  function checkIsPromise(obj) {
    return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
  }
  function waitForActual(promiseFn) {
    return Promise.resolve().then(function() {
      var resultPromise;
      if (typeof promiseFn === "function") {
        resultPromise = promiseFn();
        if (!checkIsPromise(resultPromise)) {
          throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
        }
      } else if (checkIsPromise(promiseFn)) {
        resultPromise = promiseFn;
      } else {
        throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
      }
      return Promise.resolve().then(function() {
        return resultPromise;
      }).then(function() {
        return NO_EXCEPTION_SENTINEL;
      }).catch(function(e) {
        return e;
      });
    });
  }
  function expectsError(stackStartFn, actual, error, message2) {
    if (typeof error === "string") {
      if (arguments.length === 4) {
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
      }
      if (_typeof(actual) === "object" && actual !== null) {
        if (actual.message === error) {
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
        }
      } else if (actual === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
      }
      message2 = error;
      error = void 0;
    } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
      throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
    }
    if (actual === NO_EXCEPTION_SENTINEL) {
      var details = "";
      if (error && error.name) {
        details += " (".concat(error.name, ")");
      }
      details += message2 ? ": ".concat(message2) : ".";
      var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
      innerFail({
        actual: void 0,
        expected: error,
        operator: stackStartFn.name,
        message: "Missing expected ".concat(fnType).concat(details),
        stackStartFn
      });
    }
    if (error && !expectedException(actual, error, message2, stackStartFn)) {
      throw actual;
    }
  }
  function expectsNoError(stackStartFn, actual, error, message2) {
    if (actual === NO_EXCEPTION_SENTINEL) return;
    if (typeof error === "string") {
      message2 = error;
      error = void 0;
    }
    if (!error || expectedException(actual, error)) {
      var details = message2 ? ": ".concat(message2) : ".";
      var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
      innerFail({
        actual,
        expected: error,
        operator: stackStartFn.name,
        message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
        stackStartFn
      });
    }
    throw actual;
  }
  assert2.throws = function throws(promiseFn) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
  };
  assert2.rejects = function rejects(promiseFn) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return waitForActual(promiseFn).then(function(result) {
      return expectsError.apply(void 0, [rejects, result].concat(args));
    });
  };
  assert2.doesNotThrow = function doesNotThrow(fn) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }
    expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
  };
  assert2.doesNotReject = function doesNotReject(fn) {
    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      args[_key5 - 1] = arguments[_key5];
    }
    return waitForActual(fn).then(function(result) {
      return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
    });
  };
  assert2.ifError = function ifError(err2) {
    if (err2 !== null && err2 !== void 0) {
      var message2 = "ifError got unwanted exception: ";
      if (_typeof(err2) === "object" && typeof err2.message === "string") {
        if (err2.message.length === 0 && err2.constructor) {
          message2 += err2.constructor.name;
        } else {
          message2 += err2.message;
        }
      } else {
        message2 += inspect6(err2);
      }
      var newErr = new AssertionError({
        actual: err2,
        expected: null,
        operator: "ifError",
        message: message2,
        stackStartFn: ifError
      });
      var origStack = err2.stack;
      if (typeof origStack === "string") {
        var tmp2 = origStack.split("\n");
        tmp2.shift();
        var tmp1 = newErr.stack.split("\n");
        for (var i = 0; i < tmp2.length; i++) {
          var pos = tmp1.indexOf(tmp2[i]);
          if (pos !== -1) {
            tmp1 = tmp1.slice(0, pos);
            break;
          }
        }
        newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
      }
      throw newErr;
    }
  };
  function internalMatch(string, regexp, message2, fn, fnName) {
    if (!isRegExp(regexp)) {
      throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
    }
    var match = fnName === "match";
    if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
      if (message2 instanceof Error) {
        throw message2;
      }
      var generatedMessage = !message2;
      message2 = message2 || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect6(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect6(regexp), ". Input:\n\n").concat(inspect6(string), "\n"));
      var err2 = new AssertionError({
        actual: string,
        expected: regexp,
        message: message2,
        operator: fnName,
        stackStartFn: fn
      });
      err2.generatedMessage = generatedMessage;
      throw err2;
    }
  }
  assert2.match = function match(string, regexp, message2) {
    internalMatch(string, regexp, message2, match, "match");
  };
  assert2.doesNotMatch = function doesNotMatch(string, regexp, message2) {
    internalMatch(string, regexp, message2, doesNotMatch, "doesNotMatch");
  };
  function strict() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    innerOk.apply(void 0, [strict, args.length].concat(args));
  }
  assert2.strict = objectAssign(strict, assert2, {
    equal: assert2.strictEqual,
    deepEqual: assert2.deepStrictEqual,
    notEqual: assert2.notStrictEqual,
    notDeepEqual: assert2.notDeepStrictEqual
  });
  assert2.strict.strict = assert2.strict;
  return assert$h.exports;
}
var fountainUtils = {};
var xoshiro = {};
var jsbiUmd = { exports: {} };
(function(module, exports) {
  (function(i, _) {
    module.exports = _();
  })(commonjsGlobal, function() {
    var i = Math.imul, _ = Math.clz32, t = Math.abs, e = Math.max, g = Math.floor;
    class o extends Array {
      constructor(i2, _2) {
        if (super(i2), this.sign = _2, i2 > o.__kMaxLength) throw new RangeError("Maximum BigInt size exceeded");
      }
      static BigInt(i2) {
        var _2 = Number.isFinite;
        if ("number" == typeof i2) {
          if (0 === i2) return o.__zero();
          if (o.__isOneDigitInt(i2)) return 0 > i2 ? o.__oneDigit(-i2, true) : o.__oneDigit(i2, false);
          if (!_2(i2) || g(i2) !== i2) throw new RangeError("The number " + i2 + " cannot be converted to BigInt because it is not an integer");
          return o.__fromDouble(i2);
        }
        if ("string" == typeof i2) {
          const _3 = o.__fromString(i2);
          if (null === _3) throw new SyntaxError("Cannot convert " + i2 + " to a BigInt");
          return _3;
        }
        if ("boolean" == typeof i2) return true === i2 ? o.__oneDigit(1, false) : o.__zero();
        if ("object" == typeof i2) {
          if (i2.constructor === o) return i2;
          const _3 = o.__toPrimitive(i2);
          return o.BigInt(_3);
        }
        throw new TypeError("Cannot convert " + i2 + " to a BigInt");
      }
      toDebugString() {
        const i2 = ["BigInt["];
        for (const _2 of this) i2.push((_2 ? (_2 >>> 0).toString(16) : _2) + ", ");
        return i2.push("]"), i2.join("");
      }
      toString(i2 = 10) {
        if (2 > i2 || 36 < i2) throw new RangeError("toString() radix argument must be between 2 and 36");
        return 0 === this.length ? "0" : 0 == (i2 & i2 - 1) ? o.__toStringBasePowerOfTwo(this, i2) : o.__toStringGeneric(this, i2, false);
      }
      static toNumber(i2) {
        const _2 = i2.length;
        if (0 === _2) return 0;
        if (1 === _2) {
          const _3 = i2.__unsignedDigit(0);
          return i2.sign ? -_3 : _3;
        }
        const t2 = i2.__digit(_2 - 1), e2 = o.__clz30(t2), n = 30 * _2 - e2;
        if (1024 < n) return i2.sign ? -Infinity : 1 / 0;
        let g2 = n - 1, s = t2, l = _2 - 1;
        const r = e2 + 3;
        let a = 32 === r ? 0 : s << r;
        a >>>= 12;
        const u = r - 12;
        let d = 12 <= r ? 0 : s << 20 + r, h = 20 + r;
        for (0 < u && 0 < l && (l--, s = i2.__digit(l), a |= s >>> 30 - u, d = s << u + 2, h = u + 2); 0 < h && 0 < l; ) l--, s = i2.__digit(l), d |= 30 <= h ? s << h - 30 : s >>> 30 - h, h -= 30;
        const m = o.__decideRounding(i2, h, l, s);
        if ((1 === m || 0 === m && 1 == (1 & d)) && (d = d + 1 >>> 0, 0 === d && (a++, 0 != a >>> 20 && (a = 0, g2++, 1023 < g2)))) return i2.sign ? -Infinity : 1 / 0;
        const b = i2.sign ? -2147483648 : 0;
        return g2 = g2 + 1023 << 20, o.__kBitConversionInts[1] = b | g2 | a, o.__kBitConversionInts[0] = d, o.__kBitConversionDouble[0];
      }
      static unaryMinus(i2) {
        if (0 === i2.length) return i2;
        const _2 = i2.__copy();
        return _2.sign = !i2.sign, _2;
      }
      static bitwiseNot(i2) {
        return i2.sign ? o.__absoluteSubOne(i2).__trim() : o.__absoluteAddOne(i2, true);
      }
      static exponentiate(i2, _2) {
        if (_2.sign) throw new RangeError("Exponent must be positive");
        if (0 === _2.length) return o.__oneDigit(1, false);
        if (0 === i2.length) return i2;
        if (1 === i2.length && 1 === i2.__digit(0)) return i2.sign && 0 == (1 & _2.__digit(0)) ? o.unaryMinus(i2) : i2;
        if (1 < _2.length) throw new RangeError("BigInt too big");
        let t2 = _2.__unsignedDigit(0);
        if (1 === t2) return i2;
        if (t2 >= o.__kMaxLengthBits) throw new RangeError("BigInt too big");
        if (1 === i2.length && 2 === i2.__digit(0)) {
          const _3 = 1 + (0 | t2 / 30), e3 = i2.sign && 0 != (1 & t2), n2 = new o(_3, e3);
          n2.__initializeDigits();
          const g2 = 1 << t2 % 30;
          return n2.__setDigit(_3 - 1, g2), n2;
        }
        let e2 = null, n = i2;
        for (0 != (1 & t2) && (e2 = i2), t2 >>= 1; 0 !== t2; t2 >>= 1) n = o.multiply(n, n), 0 != (1 & t2) && (null === e2 ? e2 = n : e2 = o.multiply(e2, n));
        return e2;
      }
      static multiply(_2, t2) {
        if (0 === _2.length) return _2;
        if (0 === t2.length) return t2;
        let i2 = _2.length + t2.length;
        30 <= _2.__clzmsd() + t2.__clzmsd() && i2--;
        const e2 = new o(i2, _2.sign !== t2.sign);
        e2.__initializeDigits();
        for (let n = 0; n < _2.length; n++) o.__multiplyAccumulate(t2, _2.__digit(n), e2, n);
        return e2.__trim();
      }
      static divide(i2, _2) {
        if (0 === _2.length) throw new RangeError("Division by zero");
        if (0 > o.__absoluteCompare(i2, _2)) return o.__zero();
        const t2 = i2.sign !== _2.sign, e2 = _2.__unsignedDigit(0);
        let n;
        if (1 === _2.length && 32767 >= e2) {
          if (1 === e2) return t2 === i2.sign ? i2 : o.unaryMinus(i2);
          n = o.__absoluteDivSmall(i2, e2, null);
        } else n = o.__absoluteDivLarge(i2, _2, true, false);
        return n.sign = t2, n.__trim();
      }
      static remainder(i2, _2) {
        if (0 === _2.length) throw new RangeError("Division by zero");
        if (0 > o.__absoluteCompare(i2, _2)) return i2;
        const t2 = _2.__unsignedDigit(0);
        if (1 === _2.length && 32767 >= t2) {
          if (1 === t2) return o.__zero();
          const _3 = o.__absoluteModSmall(i2, t2);
          return 0 === _3 ? o.__zero() : o.__oneDigit(_3, i2.sign);
        }
        const e2 = o.__absoluteDivLarge(i2, _2, false, true);
        return e2.sign = i2.sign, e2.__trim();
      }
      static add(i2, _2) {
        const t2 = i2.sign;
        return t2 === _2.sign ? o.__absoluteAdd(i2, _2, t2) : 0 <= o.__absoluteCompare(i2, _2) ? o.__absoluteSub(i2, _2, t2) : o.__absoluteSub(_2, i2, !t2);
      }
      static subtract(i2, _2) {
        const t2 = i2.sign;
        return t2 === _2.sign ? 0 <= o.__absoluteCompare(i2, _2) ? o.__absoluteSub(i2, _2, t2) : o.__absoluteSub(_2, i2, !t2) : o.__absoluteAdd(i2, _2, t2);
      }
      static leftShift(i2, _2) {
        return 0 === _2.length || 0 === i2.length ? i2 : _2.sign ? o.__rightShiftByAbsolute(i2, _2) : o.__leftShiftByAbsolute(i2, _2);
      }
      static signedRightShift(i2, _2) {
        return 0 === _2.length || 0 === i2.length ? i2 : _2.sign ? o.__leftShiftByAbsolute(i2, _2) : o.__rightShiftByAbsolute(i2, _2);
      }
      static unsignedRightShift() {
        throw new TypeError("BigInts have no unsigned right shift; use >> instead");
      }
      static lessThan(i2, _2) {
        return 0 > o.__compareToBigInt(i2, _2);
      }
      static lessThanOrEqual(i2, _2) {
        return 0 >= o.__compareToBigInt(i2, _2);
      }
      static greaterThan(i2, _2) {
        return 0 < o.__compareToBigInt(i2, _2);
      }
      static greaterThanOrEqual(i2, _2) {
        return 0 <= o.__compareToBigInt(i2, _2);
      }
      static equal(_2, t2) {
        if (_2.sign !== t2.sign) return false;
        if (_2.length !== t2.length) return false;
        for (let e2 = 0; e2 < _2.length; e2++) if (_2.__digit(e2) !== t2.__digit(e2)) return false;
        return true;
      }
      static notEqual(i2, _2) {
        return !o.equal(i2, _2);
      }
      static bitwiseAnd(i2, _2) {
        if (!i2.sign && !_2.sign) return o.__absoluteAnd(i2, _2).__trim();
        if (i2.sign && _2.sign) {
          const t2 = e(i2.length, _2.length) + 1;
          let n = o.__absoluteSubOne(i2, t2);
          const g2 = o.__absoluteSubOne(_2);
          return n = o.__absoluteOr(n, g2, n), o.__absoluteAddOne(n, true, n).__trim();
        }
        return i2.sign && ([i2, _2] = [_2, i2]), o.__absoluteAndNot(i2, o.__absoluteSubOne(_2)).__trim();
      }
      static bitwiseXor(i2, _2) {
        if (!i2.sign && !_2.sign) return o.__absoluteXor(i2, _2).__trim();
        if (i2.sign && _2.sign) {
          const t3 = e(i2.length, _2.length), n2 = o.__absoluteSubOne(i2, t3), g2 = o.__absoluteSubOne(_2);
          return o.__absoluteXor(n2, g2, n2).__trim();
        }
        const t2 = e(i2.length, _2.length) + 1;
        i2.sign && ([i2, _2] = [_2, i2]);
        let n = o.__absoluteSubOne(_2, t2);
        return n = o.__absoluteXor(n, i2, n), o.__absoluteAddOne(n, true, n).__trim();
      }
      static bitwiseOr(i2, _2) {
        const t2 = e(i2.length, _2.length);
        if (!i2.sign && !_2.sign) return o.__absoluteOr(i2, _2).__trim();
        if (i2.sign && _2.sign) {
          let e2 = o.__absoluteSubOne(i2, t2);
          const n2 = o.__absoluteSubOne(_2);
          return e2 = o.__absoluteAnd(e2, n2, e2), o.__absoluteAddOne(e2, true, e2).__trim();
        }
        i2.sign && ([i2, _2] = [_2, i2]);
        let n = o.__absoluteSubOne(_2, t2);
        return n = o.__absoluteAndNot(n, i2, n), o.__absoluteAddOne(n, true, n).__trim();
      }
      static asIntN(_2, t2) {
        if (0 === t2.length) return t2;
        if (_2 = g(_2), 0 > _2) throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === _2) return o.__zero();
        if (_2 >= o.__kMaxLengthBits) return t2;
        const e2 = 0 | (_2 + 29) / 30;
        if (t2.length < e2) return t2;
        const s = t2.__unsignedDigit(e2 - 1), l = 1 << (_2 - 1) % 30;
        if (t2.length === e2 && s < l) return t2;
        if (!((s & l) === l)) return o.__truncateToNBits(_2, t2);
        if (!t2.sign) return o.__truncateAndSubFromPowerOfTwo(_2, t2, true);
        if (0 == (s & l - 1)) {
          for (let n = e2 - 2; 0 <= n; n--) if (0 !== t2.__digit(n)) return o.__truncateAndSubFromPowerOfTwo(_2, t2, false);
          return t2.length === e2 && s === l ? t2 : o.__truncateToNBits(_2, t2);
        }
        return o.__truncateAndSubFromPowerOfTwo(_2, t2, false);
      }
      static asUintN(i2, _2) {
        if (0 === _2.length) return _2;
        if (i2 = g(i2), 0 > i2) throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === i2) return o.__zero();
        if (_2.sign) {
          if (i2 > o.__kMaxLengthBits) throw new RangeError("BigInt too big");
          return o.__truncateAndSubFromPowerOfTwo(i2, _2, false);
        }
        if (i2 >= o.__kMaxLengthBits) return _2;
        const t2 = 0 | (i2 + 29) / 30;
        if (_2.length < t2) return _2;
        const e2 = i2 % 30;
        if (_2.length == t2) {
          if (0 === e2) return _2;
          const i3 = _2.__digit(t2 - 1);
          if (0 == i3 >>> e2) return _2;
        }
        return o.__truncateToNBits(i2, _2);
      }
      static ADD(i2, _2) {
        if (i2 = o.__toPrimitive(i2), _2 = o.__toPrimitive(_2), "string" == typeof i2) return "string" != typeof _2 && (_2 = _2.toString()), i2 + _2;
        if ("string" == typeof _2) return i2.toString() + _2;
        if (i2 = o.__toNumeric(i2), _2 = o.__toNumeric(_2), o.__isBigInt(i2) && o.__isBigInt(_2)) return o.add(i2, _2);
        if ("number" == typeof i2 && "number" == typeof _2) return i2 + _2;
        throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
      }
      static LT(i2, _2) {
        return o.__compare(i2, _2, 0);
      }
      static LE(i2, _2) {
        return o.__compare(i2, _2, 1);
      }
      static GT(i2, _2) {
        return o.__compare(i2, _2, 2);
      }
      static GE(i2, _2) {
        return o.__compare(i2, _2, 3);
      }
      static EQ(i2, _2) {
        for (; ; ) {
          if (o.__isBigInt(i2)) return o.__isBigInt(_2) ? o.equal(i2, _2) : o.EQ(_2, i2);
          if ("number" == typeof i2) {
            if (o.__isBigInt(_2)) return o.__equalToNumber(_2, i2);
            if ("object" != typeof _2) return i2 == _2;
            _2 = o.__toPrimitive(_2);
          } else if ("string" == typeof i2) {
            if (o.__isBigInt(_2)) return i2 = o.__fromString(i2), null !== i2 && o.equal(i2, _2);
            if ("object" != typeof _2) return i2 == _2;
            _2 = o.__toPrimitive(_2);
          } else if ("boolean" == typeof i2) {
            if (o.__isBigInt(_2)) return o.__equalToNumber(_2, +i2);
            if ("object" != typeof _2) return i2 == _2;
            _2 = o.__toPrimitive(_2);
          } else if ("symbol" == typeof i2) {
            if (o.__isBigInt(_2)) return false;
            if ("object" != typeof _2) return i2 == _2;
            _2 = o.__toPrimitive(_2);
          } else if ("object" == typeof i2) {
            if ("object" == typeof _2 && _2.constructor !== o) return i2 == _2;
            i2 = o.__toPrimitive(i2);
          } else return i2 == _2;
        }
      }
      static NE(i2, _2) {
        return !o.EQ(i2, _2);
      }
      static __zero() {
        return new o(0, false);
      }
      static __oneDigit(i2, _2) {
        const t2 = new o(1, _2);
        return t2.__setDigit(0, i2), t2;
      }
      __copy() {
        const _2 = new o(this.length, this.sign);
        for (let t2 = 0; t2 < this.length; t2++) _2[t2] = this[t2];
        return _2;
      }
      __trim() {
        let i2 = this.length, _2 = this[i2 - 1];
        for (; 0 === _2; ) i2--, _2 = this[i2 - 1], this.pop();
        return 0 === i2 && (this.sign = false), this;
      }
      __initializeDigits() {
        for (let _2 = 0; _2 < this.length; _2++) this[_2] = 0;
      }
      static __decideRounding(i2, _2, t2, e2) {
        if (0 < _2) return -1;
        let n;
        if (0 > _2) n = -_2 - 1;
        else {
          if (0 === t2) return -1;
          t2--, e2 = i2.__digit(t2), n = 29;
        }
        let g2 = 1 << n;
        if (0 == (e2 & g2)) return -1;
        if (g2 -= 1, 0 != (e2 & g2)) return 1;
        for (; 0 < t2; ) if (t2--, 0 !== i2.__digit(t2)) return 1;
        return 0;
      }
      static __fromDouble(i2) {
        o.__kBitConversionDouble[0] = i2;
        const _2 = 2047 & o.__kBitConversionInts[1] >>> 20, t2 = _2 - 1023, e2 = (0 | t2 / 30) + 1, n = new o(e2, 0 > i2);
        let g2 = 1048575 & o.__kBitConversionInts[1] | 1048576, s = o.__kBitConversionInts[0];
        const l = 20, r = t2 % 30;
        let a, u = 0;
        if (20 > r) {
          const i3 = l - r;
          u = i3 + 32, a = g2 >>> i3, g2 = g2 << 32 - i3 | s >>> i3, s <<= 32 - i3;
        } else if (20 === r) u = 32, a = g2, g2 = s, s = 0;
        else {
          const i3 = r - l;
          u = 32 - i3, a = g2 << i3 | s >>> 32 - i3, g2 = s << i3, s = 0;
        }
        n.__setDigit(e2 - 1, a);
        for (let _3 = e2 - 2; 0 <= _3; _3--) 0 < u ? (u -= 30, a = g2 >>> 2, g2 = g2 << 30 | s >>> 2, s <<= 30) : a = 0, n.__setDigit(_3, a);
        return n.__trim();
      }
      static __isWhitespace(i2) {
        return !!(13 >= i2 && 9 <= i2) || (159 >= i2 ? 32 == i2 : 131071 >= i2 ? 160 == i2 || 5760 == i2 : 196607 >= i2 ? (i2 &= 131071, 10 >= i2 || 40 == i2 || 41 == i2 || 47 == i2 || 95 == i2 || 4096 == i2) : 65279 == i2);
      }
      static __fromString(i2, _2 = 0) {
        let t2 = 0;
        const e2 = i2.length;
        let n = 0;
        if (n === e2) return o.__zero();
        let g2 = i2.charCodeAt(n);
        for (; o.__isWhitespace(g2); ) {
          if (++n === e2) return o.__zero();
          g2 = i2.charCodeAt(n);
        }
        if (43 === g2) {
          if (++n === e2) return null;
          g2 = i2.charCodeAt(n), t2 = 1;
        } else if (45 === g2) {
          if (++n === e2) return null;
          g2 = i2.charCodeAt(n), t2 = -1;
        }
        if (0 === _2) {
          if (_2 = 10, 48 === g2) {
            if (++n === e2) return o.__zero();
            if (g2 = i2.charCodeAt(n), 88 === g2 || 120 === g2) {
              if (_2 = 16, ++n === e2) return null;
              g2 = i2.charCodeAt(n);
            } else if (79 === g2 || 111 === g2) {
              if (_2 = 8, ++n === e2) return null;
              g2 = i2.charCodeAt(n);
            } else if (66 === g2 || 98 === g2) {
              if (_2 = 2, ++n === e2) return null;
              g2 = i2.charCodeAt(n);
            }
          }
        } else if (16 === _2 && 48 === g2) {
          if (++n === e2) return o.__zero();
          if (g2 = i2.charCodeAt(n), 88 === g2 || 120 === g2) {
            if (++n === e2) return null;
            g2 = i2.charCodeAt(n);
          }
        }
        if (0 != t2 && 10 !== _2) return null;
        for (; 48 === g2; ) {
          if (++n === e2) return o.__zero();
          g2 = i2.charCodeAt(n);
        }
        const s = e2 - n;
        let l = o.__kMaxBitsPerChar[_2], r = o.__kBitsPerCharTableMultiplier - 1;
        if (s > 1073741824 / l) return null;
        const a = l * s + r >>> o.__kBitsPerCharTableShift, u = new o(0 | (a + 29) / 30, false), h = 10 > _2 ? _2 : 10, b = 10 < _2 ? _2 - 10 : 0;
        if (0 == (_2 & _2 - 1)) {
          l >>= o.__kBitsPerCharTableShift;
          const _3 = [], t3 = [];
          let s2 = false;
          do {
            let o2 = 0, r2 = 0;
            for (; ; ) {
              let _4;
              if (g2 - 48 >>> 0 < h) _4 = g2 - 48;
              else if ((32 | g2) - 97 >>> 0 < b) _4 = (32 | g2) - 87;
              else {
                s2 = true;
                break;
              }
              if (r2 += l, o2 = o2 << l | _4, ++n === e2) {
                s2 = true;
                break;
              }
              if (g2 = i2.charCodeAt(n), 30 < r2 + l) break;
            }
            _3.push(o2), t3.push(r2);
          } while (!s2);
          o.__fillFromParts(u, _3, t3);
        } else {
          u.__initializeDigits();
          let t3 = false, s2 = 0;
          do {
            let a2 = 0, D = 1;
            for (; ; ) {
              let o2;
              if (g2 - 48 >>> 0 < h) o2 = g2 - 48;
              else if ((32 | g2) - 97 >>> 0 < b) o2 = (32 | g2) - 87;
              else {
                t3 = true;
                break;
              }
              const l2 = D * _2;
              if (1073741823 < l2) break;
              if (D = l2, a2 = a2 * _2 + o2, s2++, ++n === e2) {
                t3 = true;
                break;
              }
              g2 = i2.charCodeAt(n);
            }
            r = 30 * o.__kBitsPerCharTableMultiplier - 1;
            const c = 0 | (l * s2 + r >>> o.__kBitsPerCharTableShift) / 30;
            u.__inplaceMultiplyAdd(D, a2, c);
          } while (!t3);
        }
        if (n !== e2) {
          if (!o.__isWhitespace(g2)) return null;
          for (n++; n < e2; n++) if (g2 = i2.charCodeAt(n), !o.__isWhitespace(g2)) return null;
        }
        return u.sign = -1 == t2, u.__trim();
      }
      static __fillFromParts(_2, t2, e2) {
        let n = 0, g2 = 0, o2 = 0;
        for (let s = t2.length - 1; 0 <= s; s--) {
          const i2 = t2[s], l = e2[s];
          g2 |= i2 << o2, o2 += l, 30 === o2 ? (_2.__setDigit(n++, g2), o2 = 0, g2 = 0) : 30 < o2 && (_2.__setDigit(n++, 1073741823 & g2), o2 -= 30, g2 = i2 >>> l - o2);
        }
        if (0 !== g2) {
          if (n >= _2.length) throw new Error("implementation bug");
          _2.__setDigit(n++, g2);
        }
        for (; n < _2.length; n++) _2.__setDigit(n, 0);
      }
      static __toStringBasePowerOfTwo(_2, i2) {
        const t2 = _2.length;
        let e2 = i2 - 1;
        e2 = (85 & e2 >>> 1) + (85 & e2), e2 = (51 & e2 >>> 2) + (51 & e2), e2 = (15 & e2 >>> 4) + (15 & e2);
        const n = e2, g2 = i2 - 1, s = _2.__digit(t2 - 1), l = o.__clz30(s);
        let r = 0 | (30 * t2 - l + n - 1) / n;
        if (_2.sign && r++, 268435456 < r) throw new Error("string too long");
        const a = Array(r);
        let u = r - 1, d = 0, h = 0;
        for (let e3 = 0; e3 < t2 - 1; e3++) {
          const i3 = _2.__digit(e3), t3 = (d | i3 << h) & g2;
          a[u--] = o.__kConversionChars[t3];
          const s2 = n - h;
          for (d = i3 >>> s2, h = 30 - s2; h >= n; ) a[u--] = o.__kConversionChars[d & g2], d >>>= n, h -= n;
        }
        const m = (d | s << h) & g2;
        for (a[u--] = o.__kConversionChars[m], d = s >>> n - h; 0 !== d; ) a[u--] = o.__kConversionChars[d & g2], d >>>= n;
        if (_2.sign && (a[u--] = "-"), -1 != u) throw new Error("implementation bug");
        return a.join("");
      }
      static __toStringGeneric(_2, i2, t2) {
        const e2 = _2.length;
        if (0 === e2) return "";
        if (1 === e2) {
          let e3 = _2.__unsignedDigit(0).toString(i2);
          return false === t2 && _2.sign && (e3 = "-" + e3), e3;
        }
        const n = 30 * e2 - o.__clz30(_2.__digit(e2 - 1)), g2 = o.__kMaxBitsPerChar[i2], s = g2 - 1;
        let l = n * o.__kBitsPerCharTableMultiplier;
        l += s - 1, l = 0 | l / s;
        const r = l + 1 >> 1, a = o.exponentiate(o.__oneDigit(i2, false), o.__oneDigit(r, false));
        let u, d;
        const h = a.__unsignedDigit(0);
        if (1 === a.length && 32767 >= h) {
          u = new o(_2.length, false), u.__initializeDigits();
          let t3 = 0;
          for (let e3 = 2 * _2.length - 1; 0 <= e3; e3--) {
            const i3 = t3 << 15 | _2.__halfDigit(e3);
            u.__setHalfDigit(e3, 0 | i3 / h), t3 = 0 | i3 % h;
          }
          d = t3.toString(i2);
        } else {
          const t3 = o.__absoluteDivLarge(_2, a, true, true);
          u = t3.quotient;
          const e3 = t3.remainder.__trim();
          d = o.__toStringGeneric(e3, i2, true);
        }
        u.__trim();
        let m = o.__toStringGeneric(u, i2, true);
        for (; d.length < r; ) d = "0" + d;
        return false === t2 && _2.sign && (m = "-" + m), m + d;
      }
      static __unequalSign(i2) {
        return i2 ? -1 : 1;
      }
      static __absoluteGreater(i2) {
        return i2 ? -1 : 1;
      }
      static __absoluteLess(i2) {
        return i2 ? 1 : -1;
      }
      static __compareToBigInt(i2, _2) {
        const t2 = i2.sign;
        if (t2 !== _2.sign) return o.__unequalSign(t2);
        const e2 = o.__absoluteCompare(i2, _2);
        return 0 < e2 ? o.__absoluteGreater(t2) : 0 > e2 ? o.__absoluteLess(t2) : 0;
      }
      static __compareToNumber(i2, _2) {
        if (o.__isOneDigitInt(_2)) {
          const e2 = i2.sign, n = 0 > _2;
          if (e2 !== n) return o.__unequalSign(e2);
          if (0 === i2.length) {
            if (n) throw new Error("implementation bug");
            return 0 === _2 ? 0 : -1;
          }
          if (1 < i2.length) return o.__absoluteGreater(e2);
          const g2 = t(_2), s = i2.__unsignedDigit(0);
          return s > g2 ? o.__absoluteGreater(e2) : s < g2 ? o.__absoluteLess(e2) : 0;
        }
        return o.__compareToDouble(i2, _2);
      }
      static __compareToDouble(i2, _2) {
        if (_2 !== _2) return _2;
        if (_2 === 1 / 0) return -1;
        if (_2 === -Infinity) return 1;
        const t2 = i2.sign;
        if (t2 !== 0 > _2) return o.__unequalSign(t2);
        if (0 === _2) throw new Error("implementation bug: should be handled elsewhere");
        if (0 === i2.length) return -1;
        o.__kBitConversionDouble[0] = _2;
        const e2 = 2047 & o.__kBitConversionInts[1] >>> 20;
        if (2047 == e2) throw new Error("implementation bug: handled elsewhere");
        const n = e2 - 1023;
        if (0 > n) return o.__absoluteGreater(t2);
        const g2 = i2.length;
        let s = i2.__digit(g2 - 1);
        const l = o.__clz30(s), r = 30 * g2 - l, a = n + 1;
        if (r < a) return o.__absoluteLess(t2);
        if (r > a) return o.__absoluteGreater(t2);
        let u = 1048576 | 1048575 & o.__kBitConversionInts[1], d = o.__kBitConversionInts[0];
        const h = 20, m = 29 - l;
        if (m !== (0 | (r - 1) % 30)) throw new Error("implementation bug");
        let b, D = 0;
        if (20 > m) {
          const i3 = h - m;
          D = i3 + 32, b = u >>> i3, u = u << 32 - i3 | d >>> i3, d <<= 32 - i3;
        } else if (20 === m) D = 32, b = u, u = d, d = 0;
        else {
          const i3 = m - h;
          D = 32 - i3, b = u << i3 | d >>> 32 - i3, u = d << i3, d = 0;
        }
        if (s >>>= 0, b >>>= 0, s > b) return o.__absoluteGreater(t2);
        if (s < b) return o.__absoluteLess(t2);
        for (let e3 = g2 - 2; 0 <= e3; e3--) {
          0 < D ? (D -= 30, b = u >>> 2, u = u << 30 | d >>> 2, d <<= 30) : b = 0;
          const _3 = i2.__unsignedDigit(e3);
          if (_3 > b) return o.__absoluteGreater(t2);
          if (_3 < b) return o.__absoluteLess(t2);
        }
        if (0 !== u || 0 !== d) {
          if (0 === D) throw new Error("implementation bug");
          return o.__absoluteLess(t2);
        }
        return 0;
      }
      static __equalToNumber(i2, _2) {
        return o.__isOneDigitInt(_2) ? 0 === _2 ? 0 === i2.length : 1 === i2.length && i2.sign === 0 > _2 && i2.__unsignedDigit(0) === t(_2) : 0 === o.__compareToDouble(i2, _2);
      }
      static __comparisonResultToBool(i2, _2) {
        return 0 === _2 ? 0 > i2 : 1 === _2 ? 0 >= i2 : 2 === _2 ? 0 < i2 : 3 === _2 ? 0 <= i2 : void 0;
      }
      static __compare(i2, _2, t2) {
        if (i2 = o.__toPrimitive(i2), _2 = o.__toPrimitive(_2), "string" == typeof i2 && "string" == typeof _2) switch (t2) {
          case 0:
            return i2 < _2;
          case 1:
            return i2 <= _2;
          case 2:
            return i2 > _2;
          case 3:
            return i2 >= _2;
        }
        if (o.__isBigInt(i2) && "string" == typeof _2) return _2 = o.__fromString(_2), null !== _2 && o.__comparisonResultToBool(o.__compareToBigInt(i2, _2), t2);
        if ("string" == typeof i2 && o.__isBigInt(_2)) return i2 = o.__fromString(i2), null !== i2 && o.__comparisonResultToBool(o.__compareToBigInt(i2, _2), t2);
        if (i2 = o.__toNumeric(i2), _2 = o.__toNumeric(_2), o.__isBigInt(i2)) {
          if (o.__isBigInt(_2)) return o.__comparisonResultToBool(o.__compareToBigInt(i2, _2), t2);
          if ("number" != typeof _2) throw new Error("implementation bug");
          return o.__comparisonResultToBool(o.__compareToNumber(i2, _2), t2);
        }
        if ("number" != typeof i2) throw new Error("implementation bug");
        if (o.__isBigInt(_2)) return o.__comparisonResultToBool(o.__compareToNumber(_2, i2), 2 ^ t2);
        if ("number" != typeof _2) throw new Error("implementation bug");
        return 0 === t2 ? i2 < _2 : 1 === t2 ? i2 <= _2 : 2 === t2 ? i2 > _2 : 3 === t2 ? i2 >= _2 : void 0;
      }
      __clzmsd() {
        return o.__clz30(this.__digit(this.length - 1));
      }
      static __absoluteAdd(_2, t2, e2) {
        if (_2.length < t2.length) return o.__absoluteAdd(t2, _2, e2);
        if (0 === _2.length) return _2;
        if (0 === t2.length) return _2.sign === e2 ? _2 : o.unaryMinus(_2);
        let n = _2.length;
        (0 === _2.__clzmsd() || t2.length === _2.length && 0 === t2.__clzmsd()) && n++;
        const g2 = new o(n, e2);
        let s = 0, l = 0;
        for (; l < t2.length; l++) {
          const i2 = _2.__digit(l) + t2.__digit(l) + s;
          s = i2 >>> 30, g2.__setDigit(l, 1073741823 & i2);
        }
        for (; l < _2.length; l++) {
          const i2 = _2.__digit(l) + s;
          s = i2 >>> 30, g2.__setDigit(l, 1073741823 & i2);
        }
        return l < g2.length && g2.__setDigit(l, s), g2.__trim();
      }
      static __absoluteSub(_2, t2, e2) {
        if (0 === _2.length) return _2;
        if (0 === t2.length) return _2.sign === e2 ? _2 : o.unaryMinus(_2);
        const n = new o(_2.length, e2);
        let g2 = 0, s = 0;
        for (; s < t2.length; s++) {
          const i2 = _2.__digit(s) - t2.__digit(s) - g2;
          g2 = 1 & i2 >>> 30, n.__setDigit(s, 1073741823 & i2);
        }
        for (; s < _2.length; s++) {
          const i2 = _2.__digit(s) - g2;
          g2 = 1 & i2 >>> 30, n.__setDigit(s, 1073741823 & i2);
        }
        return n.__trim();
      }
      static __absoluteAddOne(_2, i2, t2 = null) {
        const e2 = _2.length;
        null === t2 ? t2 = new o(e2, i2) : t2.sign = i2;
        let n = 1;
        for (let g2 = 0; g2 < e2; g2++) {
          const i3 = _2.__digit(g2) + n;
          n = i3 >>> 30, t2.__setDigit(g2, 1073741823 & i3);
        }
        return 0 != n && t2.__setDigitGrow(e2, 1), t2;
      }
      static __absoluteSubOne(_2, t2) {
        const e2 = _2.length;
        t2 = t2 || e2;
        const n = new o(t2, false);
        let g2 = 1;
        for (let o2 = 0; o2 < e2; o2++) {
          const i2 = _2.__digit(o2) - g2;
          g2 = 1 & i2 >>> 30, n.__setDigit(o2, 1073741823 & i2);
        }
        if (0 != g2) throw new Error("implementation bug");
        for (let g3 = e2; g3 < t2; g3++) n.__setDigit(g3, 0);
        return n;
      }
      static __absoluteAnd(_2, t2, e2 = null) {
        let n = _2.length, g2 = t2.length, s = g2;
        if (n < g2) {
          s = n;
          const i2 = _2, e3 = n;
          _2 = t2, n = g2, t2 = i2, g2 = e3;
        }
        let l = s;
        null === e2 ? e2 = new o(l, false) : l = e2.length;
        let r = 0;
        for (; r < s; r++) e2.__setDigit(r, _2.__digit(r) & t2.__digit(r));
        for (; r < l; r++) e2.__setDigit(r, 0);
        return e2;
      }
      static __absoluteAndNot(_2, t2, e2 = null) {
        const n = _2.length, g2 = t2.length;
        let s = g2;
        n < g2 && (s = n);
        let l = n;
        null === e2 ? e2 = new o(l, false) : l = e2.length;
        let r = 0;
        for (; r < s; r++) e2.__setDigit(r, _2.__digit(r) & ~t2.__digit(r));
        for (; r < n; r++) e2.__setDigit(r, _2.__digit(r));
        for (; r < l; r++) e2.__setDigit(r, 0);
        return e2;
      }
      static __absoluteOr(_2, t2, e2 = null) {
        let n = _2.length, g2 = t2.length, s = g2;
        if (n < g2) {
          s = n;
          const i2 = _2, e3 = n;
          _2 = t2, n = g2, t2 = i2, g2 = e3;
        }
        let l = n;
        null === e2 ? e2 = new o(l, false) : l = e2.length;
        let r = 0;
        for (; r < s; r++) e2.__setDigit(r, _2.__digit(r) | t2.__digit(r));
        for (; r < n; r++) e2.__setDigit(r, _2.__digit(r));
        for (; r < l; r++) e2.__setDigit(r, 0);
        return e2;
      }
      static __absoluteXor(_2, t2, e2 = null) {
        let n = _2.length, g2 = t2.length, s = g2;
        if (n < g2) {
          s = n;
          const i2 = _2, e3 = n;
          _2 = t2, n = g2, t2 = i2, g2 = e3;
        }
        let l = n;
        null === e2 ? e2 = new o(l, false) : l = e2.length;
        let r = 0;
        for (; r < s; r++) e2.__setDigit(r, _2.__digit(r) ^ t2.__digit(r));
        for (; r < n; r++) e2.__setDigit(r, _2.__digit(r));
        for (; r < l; r++) e2.__setDigit(r, 0);
        return e2;
      }
      static __absoluteCompare(_2, t2) {
        const e2 = _2.length - t2.length;
        if (0 != e2) return e2;
        let n = _2.length - 1;
        for (; 0 <= n && _2.__digit(n) === t2.__digit(n); ) n--;
        return 0 > n ? 0 : _2.__unsignedDigit(n) > t2.__unsignedDigit(n) ? 1 : -1;
      }
      static __multiplyAccumulate(_2, t2, e2, n) {
        if (0 === t2) return;
        const g2 = 32767 & t2, s = t2 >>> 15;
        let l = 0, r = 0;
        for (let a, u = 0; u < _2.length; u++, n++) {
          a = e2.__digit(n);
          const i2 = _2.__digit(u), t3 = 32767 & i2, d = i2 >>> 15, h = o.__imul(t3, g2), m = o.__imul(t3, s), b = o.__imul(d, g2), D = o.__imul(d, s);
          a += r + h + l, l = a >>> 30, a &= 1073741823, a += ((32767 & m) << 15) + ((32767 & b) << 15), l += a >>> 30, r = D + (m >>> 15) + (b >>> 15), e2.__setDigit(n, 1073741823 & a);
        }
        for (; 0 != l || 0 !== r; n++) {
          let i2 = e2.__digit(n);
          i2 += l + r, r = 0, l = i2 >>> 30, e2.__setDigit(n, 1073741823 & i2);
        }
      }
      static __internalMultiplyAdd(_2, t2, e2, g2, s) {
        let l = e2, a = 0;
        for (let n = 0; n < g2; n++) {
          const i2 = _2.__digit(n), e3 = o.__imul(32767 & i2, t2), g3 = o.__imul(i2 >>> 15, t2), u = e3 + ((32767 & g3) << 15) + a + l;
          l = u >>> 30, a = g3 >>> 15, s.__setDigit(n, 1073741823 & u);
        }
        if (s.length > g2) for (s.__setDigit(g2++, l + a); g2 < s.length; ) s.__setDigit(g2++, 0);
        else if (0 !== l + a) throw new Error("implementation bug");
      }
      __inplaceMultiplyAdd(i2, _2, t2) {
        t2 > this.length && (t2 = this.length);
        const e2 = 32767 & i2, n = i2 >>> 15;
        let g2 = 0, s = _2;
        for (let l = 0; l < t2; l++) {
          const i3 = this.__digit(l), _3 = 32767 & i3, t3 = i3 >>> 15, r = o.__imul(_3, e2), a = o.__imul(_3, n), u = o.__imul(t3, e2), d = o.__imul(t3, n);
          let h = s + r + g2;
          g2 = h >>> 30, h &= 1073741823, h += ((32767 & a) << 15) + ((32767 & u) << 15), g2 += h >>> 30, s = d + (a >>> 15) + (u >>> 15), this.__setDigit(l, 1073741823 & h);
        }
        if (0 != g2 || 0 !== s) throw new Error("implementation bug");
      }
      static __absoluteDivSmall(_2, t2, e2 = null) {
        null === e2 && (e2 = new o(_2.length, false));
        let n = 0;
        for (let g2, o2 = 2 * _2.length - 1; 0 <= o2; o2 -= 2) {
          g2 = (n << 15 | _2.__halfDigit(o2)) >>> 0;
          const i2 = 0 | g2 / t2;
          n = 0 | g2 % t2, g2 = (n << 15 | _2.__halfDigit(o2 - 1)) >>> 0;
          const s = 0 | g2 / t2;
          n = 0 | g2 % t2, e2.__setDigit(o2 >>> 1, i2 << 15 | s);
        }
        return e2;
      }
      static __absoluteModSmall(_2, t2) {
        let e2 = 0;
        for (let n = 2 * _2.length - 1; 0 <= n; n--) {
          const i2 = (e2 << 15 | _2.__halfDigit(n)) >>> 0;
          e2 = 0 | i2 % t2;
        }
        return e2;
      }
      static __absoluteDivLarge(i2, _2, t2, e2) {
        const g2 = _2.__halfDigitLength(), n = _2.length, s = i2.__halfDigitLength() - g2;
        let l = null;
        t2 && (l = new o(s + 2 >>> 1, false), l.__initializeDigits());
        const r = new o(g2 + 2 >>> 1, false);
        r.__initializeDigits();
        const a = o.__clz15(_2.__halfDigit(g2 - 1));
        0 < a && (_2 = o.__specialLeftShift(_2, a, 0));
        const d = o.__specialLeftShift(i2, a, 1), u = _2.__halfDigit(g2 - 1);
        let h = 0;
        for (let a2, m = s; 0 <= m; m--) {
          a2 = 32767;
          const i3 = d.__halfDigit(m + g2);
          if (i3 !== u) {
            const t3 = (i3 << 15 | d.__halfDigit(m + g2 - 1)) >>> 0;
            a2 = 0 | t3 / u;
            let e4 = 0 | t3 % u;
            const n2 = _2.__halfDigit(g2 - 2), s2 = d.__halfDigit(m + g2 - 2);
            for (; o.__imul(a2, n2) >>> 0 > (e4 << 16 | s2) >>> 0 && (a2--, e4 += u, !(32767 < e4)); ) ;
          }
          o.__internalMultiplyAdd(_2, a2, 0, n, r);
          let e3 = d.__inplaceSub(r, m, g2 + 1);
          0 !== e3 && (e3 = d.__inplaceAdd(_2, m, g2), d.__setHalfDigit(m + g2, 32767 & d.__halfDigit(m + g2) + e3), a2--), t2 && (1 & m ? h = a2 << 15 : l.__setDigit(m >>> 1, h | a2));
        }
        if (e2) return d.__inplaceRightShift(a), t2 ? { quotient: l, remainder: d } : d;
        if (t2) return l;
        throw new Error("unreachable");
      }
      static __clz15(i2) {
        return o.__clz30(i2) - 15;
      }
      __inplaceAdd(_2, t2, e2) {
        let n = 0;
        for (let g2 = 0; g2 < e2; g2++) {
          const i2 = this.__halfDigit(t2 + g2) + _2.__halfDigit(g2) + n;
          n = i2 >>> 15, this.__setHalfDigit(t2 + g2, 32767 & i2);
        }
        return n;
      }
      __inplaceSub(_2, t2, e2) {
        let n = 0;
        if (1 & t2) {
          t2 >>= 1;
          let g2 = this.__digit(t2), o2 = 32767 & g2, s = 0;
          for (; s < e2 - 1 >>> 1; s++) {
            const i3 = _2.__digit(s), e3 = (g2 >>> 15) - (32767 & i3) - n;
            n = 1 & e3 >>> 15, this.__setDigit(t2 + s, (32767 & e3) << 15 | 32767 & o2), g2 = this.__digit(t2 + s + 1), o2 = (32767 & g2) - (i3 >>> 15) - n, n = 1 & o2 >>> 15;
          }
          const i2 = _2.__digit(s), l = (g2 >>> 15) - (32767 & i2) - n;
          n = 1 & l >>> 15, this.__setDigit(t2 + s, (32767 & l) << 15 | 32767 & o2);
          if (t2 + s + 1 >= this.length) throw new RangeError("out of bounds");
          0 == (1 & e2) && (g2 = this.__digit(t2 + s + 1), o2 = (32767 & g2) - (i2 >>> 15) - n, n = 1 & o2 >>> 15, this.__setDigit(t2 + _2.length, 1073709056 & g2 | 32767 & o2));
        } else {
          t2 >>= 1;
          let g2 = 0;
          for (; g2 < _2.length - 1; g2++) {
            const i3 = this.__digit(t2 + g2), e3 = _2.__digit(g2), o3 = (32767 & i3) - (32767 & e3) - n;
            n = 1 & o3 >>> 15;
            const s2 = (i3 >>> 15) - (e3 >>> 15) - n;
            n = 1 & s2 >>> 15, this.__setDigit(t2 + g2, (32767 & s2) << 15 | 32767 & o3);
          }
          const i2 = this.__digit(t2 + g2), o2 = _2.__digit(g2), s = (32767 & i2) - (32767 & o2) - n;
          n = 1 & s >>> 15;
          let l = 0;
          0 == (1 & e2) && (l = (i2 >>> 15) - (o2 >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t2 + g2, (32767 & l) << 15 | 32767 & s);
        }
        return n;
      }
      __inplaceRightShift(_2) {
        if (0 === _2) return;
        let t2 = this.__digit(0) >>> _2;
        const e2 = this.length - 1;
        for (let n = 0; n < e2; n++) {
          const i2 = this.__digit(n + 1);
          this.__setDigit(n, 1073741823 & i2 << 30 - _2 | t2), t2 = i2 >>> _2;
        }
        this.__setDigit(e2, t2);
      }
      static __specialLeftShift(_2, t2, e2) {
        const g2 = _2.length, n = new o(g2 + e2, false);
        if (0 === t2) {
          for (let t3 = 0; t3 < g2; t3++) n.__setDigit(t3, _2.__digit(t3));
          return 0 < e2 && n.__setDigit(g2, 0), n;
        }
        let s = 0;
        for (let o2 = 0; o2 < g2; o2++) {
          const i2 = _2.__digit(o2);
          n.__setDigit(o2, 1073741823 & i2 << t2 | s), s = i2 >>> 30 - t2;
        }
        return 0 < e2 && n.__setDigit(g2, s), n;
      }
      static __leftShiftByAbsolute(_2, i2) {
        const t2 = o.__toShiftAmount(i2);
        if (0 > t2) throw new RangeError("BigInt too big");
        const e2 = 0 | t2 / 30, n = t2 % 30, g2 = _2.length, s = 0 !== n && 0 != _2.__digit(g2 - 1) >>> 30 - n, l = g2 + e2 + (s ? 1 : 0), r = new o(l, _2.sign);
        if (0 === n) {
          let t3 = 0;
          for (; t3 < e2; t3++) r.__setDigit(t3, 0);
          for (; t3 < l; t3++) r.__setDigit(t3, _2.__digit(t3 - e2));
        } else {
          let t3 = 0;
          for (let _3 = 0; _3 < e2; _3++) r.__setDigit(_3, 0);
          for (let o2 = 0; o2 < g2; o2++) {
            const i3 = _2.__digit(o2);
            r.__setDigit(o2 + e2, 1073741823 & i3 << n | t3), t3 = i3 >>> 30 - n;
          }
          if (s) r.__setDigit(g2 + e2, t3);
          else if (0 !== t3) throw new Error("implementation bug");
        }
        return r.__trim();
      }
      static __rightShiftByAbsolute(_2, i2) {
        const t2 = _2.length, e2 = _2.sign, n = o.__toShiftAmount(i2);
        if (0 > n) return o.__rightShiftByMaximum(e2);
        const g2 = 0 | n / 30, s = n % 30;
        let l = t2 - g2;
        if (0 >= l) return o.__rightShiftByMaximum(e2);
        let r = false;
        if (e2) {
          if (0 != (_2.__digit(g2) & (1 << s) - 1)) r = true;
          else for (let t3 = 0; t3 < g2; t3++) if (0 !== _2.__digit(t3)) {
            r = true;
            break;
          }
        }
        if (r && 0 === s) {
          const i3 = _2.__digit(t2 - 1);
          0 == ~i3 && l++;
        }
        let a = new o(l, e2);
        if (0 === s) {
          a.__setDigit(l - 1, 0);
          for (let e3 = g2; e3 < t2; e3++) a.__setDigit(e3 - g2, _2.__digit(e3));
        } else {
          let e3 = _2.__digit(g2) >>> s;
          const n2 = t2 - g2 - 1;
          for (let t3 = 0; t3 < n2; t3++) {
            const i3 = _2.__digit(t3 + g2 + 1);
            a.__setDigit(t3, 1073741823 & i3 << 30 - s | e3), e3 = i3 >>> s;
          }
          a.__setDigit(n2, e3);
        }
        return r && (a = o.__absoluteAddOne(a, true, a)), a.__trim();
      }
      static __rightShiftByMaximum(i2) {
        return i2 ? o.__oneDigit(1, true) : o.__zero();
      }
      static __toShiftAmount(i2) {
        if (1 < i2.length) return -1;
        const _2 = i2.__unsignedDigit(0);
        return _2 > o.__kMaxLengthBits ? -1 : _2;
      }
      static __toPrimitive(i2, _2 = "default") {
        if ("object" != typeof i2) return i2;
        if (i2.constructor === o) return i2;
        if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive) {
          const t3 = i2[Symbol.toPrimitive];
          if (t3) {
            const i3 = t3(_2);
            if ("object" != typeof i3) return i3;
            throw new TypeError("Cannot convert object to primitive value");
          }
        }
        const t2 = i2.valueOf;
        if (t2) {
          const _3 = t2.call(i2);
          if ("object" != typeof _3) return _3;
        }
        const e2 = i2.toString;
        if (e2) {
          const _3 = e2.call(i2);
          if ("object" != typeof _3) return _3;
        }
        throw new TypeError("Cannot convert object to primitive value");
      }
      static __toNumeric(i2) {
        return o.__isBigInt(i2) ? i2 : +i2;
      }
      static __isBigInt(i2) {
        return "object" == typeof i2 && null !== i2 && i2.constructor === o;
      }
      static __truncateToNBits(i2, _2) {
        const t2 = 0 | (i2 + 29) / 30, e2 = new o(t2, _2.sign), n = t2 - 1;
        for (let t3 = 0; t3 < n; t3++) e2.__setDigit(t3, _2.__digit(t3));
        let g2 = _2.__digit(n);
        if (0 != i2 % 30) {
          const _3 = 32 - i2 % 30;
          g2 = g2 << _3 >>> _3;
        }
        return e2.__setDigit(n, g2), e2.__trim();
      }
      static __truncateAndSubFromPowerOfTwo(_2, t2, e2) {
        var n = Math.min;
        const g2 = 0 | (_2 + 29) / 30, s = new o(g2, e2);
        let l = 0;
        const r = g2 - 1;
        let a = 0;
        for (const i2 = n(r, t2.length); l < i2; l++) {
          const i3 = 0 - t2.__digit(l) - a;
          a = 1 & i3 >>> 30, s.__setDigit(l, 1073741823 & i3);
        }
        for (; l < r; l++) s.__setDigit(l, 0 | 1073741823 & -a);
        let u = r < t2.length ? t2.__digit(r) : 0;
        const d = _2 % 30;
        let h;
        if (0 == d) h = 0 - u - a, h &= 1073741823;
        else {
          const i2 = 32 - d;
          u = u << i2 >>> i2;
          const _3 = 1 << 32 - i2;
          h = _3 - u - a, h &= _3 - 1;
        }
        return s.__setDigit(r, h), s.__trim();
      }
      __digit(_2) {
        return this[_2];
      }
      __unsignedDigit(_2) {
        return this[_2] >>> 0;
      }
      __setDigit(_2, i2) {
        this[_2] = 0 | i2;
      }
      __setDigitGrow(_2, i2) {
        this[_2] = 0 | i2;
      }
      __halfDigitLength() {
        const i2 = this.length;
        return 32767 >= this.__unsignedDigit(i2 - 1) ? 2 * i2 - 1 : 2 * i2;
      }
      __halfDigit(_2) {
        return 32767 & this[_2 >>> 1] >>> 15 * (1 & _2);
      }
      __setHalfDigit(_2, i2) {
        const t2 = _2 >>> 1, e2 = this.__digit(t2), n = 1 & _2 ? 32767 & e2 | i2 << 15 : 1073709056 & e2 | 32767 & i2;
        this.__setDigit(t2, n);
      }
      static __digitPow(i2, _2) {
        let t2 = 1;
        for (; 0 < _2; ) 1 & _2 && (t2 *= i2), _2 >>>= 1, i2 *= i2;
        return t2;
      }
      static __isOneDigitInt(i2) {
        return (1073741823 & i2) === i2;
      }
    }
    return o.__kMaxLength = 33554432, o.__kMaxLengthBits = o.__kMaxLength << 5, o.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], o.__kBitsPerCharTableShift = 5, o.__kBitsPerCharTableMultiplier = 1 << o.__kBitsPerCharTableShift, o.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], o.__kBitConversionBuffer = new ArrayBuffer(8), o.__kBitConversionDouble = new Float64Array(o.__kBitConversionBuffer), o.__kBitConversionInts = new Int32Array(o.__kBitConversionBuffer), o.__clz30 = _ ? function(i2) {
      return _(i2) - 2;
    } : function(i2) {
      var _2 = Math.LN2, t2 = Math.log;
      return 0 === i2 ? 30 : 0 | 29 - (0 | t2(i2 >>> 0) / _2);
    }, o.__imul = i || function(i2, _2) {
      return 0 | i2 * _2;
    }, o;
  });
})(jsbiUmd);
var jsbiUmdExports = jsbiUmd.exports;
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(xoshiro, "__esModule", { value: true });
const utils_1$p = utils$i;
const bignumber_js_1 = __importDefault$7(bignumberExports);
const jsbi_1 = __importDefault$7(jsbiUmdExports);
const MAX_UINT64 = 18446744073709552e3;
const rotl = (x, k) => jsbi_1.default.bitwiseXor(jsbi_1.default.asUintN(64, jsbi_1.default.leftShift(x, jsbi_1.default.BigInt(k))), jsbi_1.default.BigInt(jsbi_1.default.asUintN(64, jsbi_1.default.signedRightShift(x, jsbi_1.default.subtract(jsbi_1.default.BigInt(64), jsbi_1.default.BigInt(k))))));
class Xoshiro {
  constructor(seed) {
    this.next = () => {
      return new bignumber_js_1.default(this.roll().toString());
    };
    this.nextDouble = () => {
      return new bignumber_js_1.default(this.roll().toString()).div(MAX_UINT64 + 1);
    };
    this.nextInt = (low, high) => {
      return Math.floor(this.nextDouble().toNumber() * (high - low + 1) + low);
    };
    this.nextByte = () => this.nextInt(0, 255);
    this.nextData = (count) => [...new Array(count)].map(() => this.nextByte());
    const digest = utils_1$p.sha256Hash(seed);
    this.s = [jsbi_1.default.BigInt(0), jsbi_1.default.BigInt(0), jsbi_1.default.BigInt(0), jsbi_1.default.BigInt(0)];
    this.setS(digest);
  }
  setS(digest) {
    for (let i = 0; i < 4; i++) {
      let o = i * 8;
      let v = jsbi_1.default.BigInt(0);
      for (let n = 0; n < 8; n++) {
        v = jsbi_1.default.asUintN(64, jsbi_1.default.leftShift(v, jsbi_1.default.BigInt(8)));
        v = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseOr(v, jsbi_1.default.BigInt(digest[o + n])));
      }
      this.s[i] = jsbi_1.default.asUintN(64, v);
    }
  }
  roll() {
    const result = jsbi_1.default.asUintN(64, jsbi_1.default.multiply(rotl(jsbi_1.default.asUintN(64, jsbi_1.default.multiply(this.s[1], jsbi_1.default.BigInt(5))), 7), jsbi_1.default.BigInt(9)));
    const t = jsbi_1.default.asUintN(64, jsbi_1.default.leftShift(this.s[1], jsbi_1.default.BigInt(17)));
    this.s[2] = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseXor(this.s[2], jsbi_1.default.BigInt(this.s[0])));
    this.s[3] = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseXor(this.s[3], jsbi_1.default.BigInt(this.s[1])));
    this.s[1] = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseXor(this.s[1], jsbi_1.default.BigInt(this.s[2])));
    this.s[0] = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseXor(this.s[0], jsbi_1.default.BigInt(this.s[3])));
    this.s[2] = jsbi_1.default.asUintN(64, jsbi_1.default.bitwiseXor(this.s[2], jsbi_1.default.BigInt(t)));
    this.s[3] = jsbi_1.default.asUintN(64, rotl(this.s[3], 45));
    return result;
  }
}
xoshiro.default = Xoshiro;
var precomputeAlias = function(p, n) {
  var sum = p.reduce(function(acc, val) {
    if (val < 0) {
      throw new Error("Probability must be a positive: p[" + p.indexOf(val) + "]=" + val);
    }
    return acc + val;
  }, 0);
  if (sum === 0) {
    throw new Error("Probability sum must be greater than zero.");
  }
  var scaledProbabilities = p.map(function(prob) {
    return prob * n / sum;
  });
  var aliasData = { prob: new Array(n), alias: new Array(n) };
  var small = [];
  var large = [];
  for (var i = n - 1; i >= 0; i--) {
    if (scaledProbabilities[i] < 1) {
      small.push(i);
    } else {
      large.push(i);
    }
  }
  while (small.length > 0 && large.length > 0) {
    var less = small.pop();
    var more = large.pop();
    aliasData.prob[less] = scaledProbabilities[less];
    aliasData.alias[less] = more;
    scaledProbabilities[more] = scaledProbabilities[more] + scaledProbabilities[less] - 1;
    if (scaledProbabilities[more] < 1) {
      small.push(more);
    } else {
      large.push(more);
    }
  }
  while (large.length > 0) {
    aliasData.prob[large.pop()] = 1;
  }
  while (small.length > 0) {
    aliasData.prob[small.pop()] = 1;
  }
  return aliasData;
};
var draw = function(aliasData, outcomes, rng2) {
  var c = Math.floor(rng2() * aliasData.prob.length);
  return outcomes[rng2() < aliasData.prob[c] ? c : aliasData.alias[c]];
};
var next = function(aliasData, outcomes, rng2, numOfSamples) {
  if (numOfSamples === void 0) {
    numOfSamples = 1;
  }
  if (numOfSamples === 1) {
    return draw(aliasData, outcomes, rng2);
  }
  var samples = [];
  for (var i = 0; i < numOfSamples; i++) {
    samples.push(draw(aliasData, outcomes, rng2));
  }
  return samples;
};
var sample = function(probabilities, outcomes, rng2) {
  if (rng2 === void 0) {
    rng2 = Math.random;
  }
  if (!Array.isArray(probabilities)) {
    throw new Error("Probabilities must be an array.");
  }
  if (probabilities.length === 0) {
    throw new Error("Probabilities array must not be empty.");
  }
  var n = probabilities.length;
  var indexedOutcomes = outcomes !== null && outcomes !== void 0 ? outcomes : Array.from({ length: n }, function(_, i) {
    return i;
  });
  var aliasData = precomputeAlias(probabilities, n);
  return {
    next: function(numOfSamples) {
      if (numOfSamples === void 0) {
        numOfSamples = 1;
      }
      return next(aliasData, indexedOutcomes, rng2, numOfSamples);
    }
  };
};
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: sample
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(esm);
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chooseFragments = exports.shuffle = exports.chooseDegree = void 0;
  const utils_12 = utils$i;
  const xoshiro_1 = __importDefault2(xoshiro);
  const alias_sampling_1 = __importDefault2(require$$2);
  const chooseDegree = (seqLenth, rng2) => {
    const degreeProbabilities = [...new Array(seqLenth)].map((_, index2) => 1 / (index2 + 1));
    const degreeChooser = alias_sampling_1.default(degreeProbabilities, void 0, rng2.nextDouble);
    return degreeChooser.next() + 1;
  };
  exports.chooseDegree = chooseDegree;
  const shuffle = (items, rng2) => {
    let remaining = [...items];
    let result = [];
    while (remaining.length > 0) {
      let index2 = rng2.nextInt(0, remaining.length - 1);
      let item = remaining[index2];
      remaining.splice(index2, 1);
      result.push(item);
    }
    return result;
  };
  exports.shuffle = shuffle;
  const chooseFragments = (seqNum, seqLength, checksum) => {
    if (seqNum <= seqLength) {
      return [seqNum - 1];
    } else {
      const seed = Buffer$1$1.concat([utils_12.intToBytes(seqNum), utils_12.intToBytes(checksum)]);
      const rng2 = new xoshiro_1.default(seed);
      const degree = exports.chooseDegree(seqLength, rng2);
      const indexes = [...new Array(seqLength)].map((_, index2) => index2);
      const shuffledIndexes = exports.shuffle(indexes, rng2);
      return shuffledIndexes.slice(0, degree);
    }
  };
  exports.chooseFragments = chooseFragments;
})(fountainUtils);
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(fountainEncoder, "__esModule", { value: true });
fountainEncoder.FountainEncoderPart = void 0;
const assert_1$3 = __importDefault$6(requireAssert());
const utils_1$o = utils$i;
const fountainUtils_1$1 = fountainUtils;
const cbor_1 = cbor$1;
class FountainEncoderPart {
  constructor(_seqNum, _seqLength, _messageLength, _checksum, _fragment) {
    this._seqNum = _seqNum;
    this._seqLength = _seqLength;
    this._messageLength = _messageLength;
    this._checksum = _checksum;
    this._fragment = _fragment;
  }
  get messageLength() {
    return this._messageLength;
  }
  get fragment() {
    return this._fragment;
  }
  get seqNum() {
    return this._seqNum;
  }
  get seqLength() {
    return this._seqLength;
  }
  get checksum() {
    return this._checksum;
  }
  cbor() {
    const result = cbor_1.cborEncode([
      this._seqNum,
      this._seqLength,
      this._messageLength,
      this._checksum,
      this._fragment
    ]);
    return Buffer$1$1.from(result);
  }
  description() {
    return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString("hex")}`;
  }
  static fromCBOR(cborPayload) {
    const [seqNum, seqLength, messageLength, checksum, fragment] = cbor_1.cborDecode(cborPayload);
    assert_1$3.default(typeof seqNum === "number");
    assert_1$3.default(typeof seqLength === "number");
    assert_1$3.default(typeof messageLength === "number");
    assert_1$3.default(typeof checksum === "number");
    assert_1$3.default(Buffer$1$1.isBuffer(fragment) && fragment.length > 0);
    return new FountainEncoderPart(seqNum, seqLength, messageLength, checksum, Buffer$1$1.from(fragment));
  }
}
fountainEncoder.FountainEncoderPart = FountainEncoderPart;
class FountainEncoder {
  constructor(message2, maxFragmentLength = 100, firstSeqNum = 0, minFragmentLength = 10) {
    const fragmentLength = FountainEncoder.findNominalFragmentLength(message2.length, minFragmentLength, maxFragmentLength);
    this._messageLength = message2.length;
    this._fragments = FountainEncoder.partitionMessage(message2, fragmentLength);
    this.fragmentLength = fragmentLength;
    this.seqNum = utils_1$o.toUint32(firstSeqNum);
    this.checksum = utils_1$o.getCRC(message2);
  }
  get fragmentsLength() {
    return this._fragments.length;
  }
  get fragments() {
    return this._fragments;
  }
  get messageLength() {
    return this._messageLength;
  }
  isComplete() {
    return this.seqNum >= this._fragments.length;
  }
  isSinglePart() {
    return this._fragments.length === 1;
  }
  seqLength() {
    return this._fragments.length;
  }
  mix(indexes) {
    return indexes.reduce((result, index2) => utils_1$o.bufferXOR(this._fragments[index2], result), Buffer$1$1.alloc(this.fragmentLength, 0));
  }
  nextPart() {
    this.seqNum = utils_1$o.toUint32(this.seqNum + 1);
    const indexes = fountainUtils_1$1.chooseFragments(this.seqNum, this._fragments.length, this.checksum);
    const mixed = this.mix(indexes);
    return new FountainEncoderPart(this.seqNum, this._fragments.length, this._messageLength, this.checksum, mixed);
  }
  static findNominalFragmentLength(messageLength, minFragmentLength, maxFragmentLength) {
    assert_1$3.default(messageLength > 0);
    assert_1$3.default(minFragmentLength > 0);
    assert_1$3.default(maxFragmentLength >= minFragmentLength);
    const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);
    let fragmentLength = 0;
    for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {
      fragmentLength = Math.ceil(messageLength / fragmentCount);
      if (fragmentLength <= maxFragmentLength) {
        break;
      }
    }
    return fragmentLength;
  }
  static partitionMessage(message2, fragmentLength) {
    let remaining = Buffer$1$1.from(message2);
    let fragment;
    let _fragments = [];
    while (remaining.length > 0) {
      [fragment, remaining] = utils_1$o.split(remaining, -fragmentLength);
      fragment = Buffer$1$1.alloc(fragmentLength, 0).fill(fragment, 0, fragment.length);
      _fragments.push(fragment);
    }
    return _fragments;
  }
}
fountainEncoder.default = FountainEncoder;
var bytewords$1 = {};
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(bytewords$1, "__esModule", { value: true });
const assert_1$2 = __importDefault$5(requireAssert());
const utils_1$n = utils$i;
const bytewords = "ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom";
let bytewordsLookUpTable = [];
const BYTEWORDS_NUM = 256;
const BYTEWORD_LENGTH = 4;
const MINIMAL_BYTEWORD_LENGTH = 2;
var STYLES;
(function(STYLES2) {
  STYLES2["STANDARD"] = "standard";
  STYLES2["URI"] = "uri";
  STYLES2["MINIMAL"] = "minimal";
})(STYLES || (STYLES = {}));
const getWord = (index2) => {
  return bytewords.slice(index2 * BYTEWORD_LENGTH, index2 * BYTEWORD_LENGTH + BYTEWORD_LENGTH);
};
const getMinimalWord = (index2) => {
  const byteword = getWord(index2);
  return `${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}`;
};
const addCRC = (string) => {
  const crc2 = utils_1$n.getCRCHex(Buffer$1$1.from(string, "hex"));
  return `${string}${crc2}`;
};
const encodeWithSeparator = (word, separator) => {
  const crcAppendedWord = addCRC(word);
  const crcWordBuff = Buffer$1$1.from(crcAppendedWord, "hex");
  const result = crcWordBuff.reduce((result2, w) => [...result2, getWord(w)], []);
  return result.join(separator);
};
const encodeMinimal = (word) => {
  const crcAppendedWord = addCRC(word);
  const crcWordBuff = Buffer$1$1.from(crcAppendedWord, "hex");
  const result = crcWordBuff.reduce((result2, w) => result2 + getMinimalWord(w), "");
  return result;
};
const decodeWord = (word, wordLength) => {
  assert_1$2.default(word.length === wordLength, "Invalid Bytewords: word.length does not match wordLength provided");
  const dim = 26;
  if (bytewordsLookUpTable.length === 0) {
    const array_len = dim * dim;
    bytewordsLookUpTable = [...new Array(array_len)].map(() => -1);
    for (let i = 0; i < BYTEWORDS_NUM; i++) {
      const byteword = getWord(i);
      let x2 = byteword[0].charCodeAt(0) - "a".charCodeAt(0);
      let y2 = byteword[3].charCodeAt(0) - "a".charCodeAt(0);
      let offset2 = y2 * dim + x2;
      bytewordsLookUpTable[offset2] = i;
    }
  }
  let x = word[0].toLowerCase().charCodeAt(0) - "a".charCodeAt(0);
  let y = word[wordLength == 4 ? 3 : 1].toLowerCase().charCodeAt(0) - "a".charCodeAt(0);
  assert_1$2.default(0 <= x && x < dim && 0 <= y && y < dim, "Invalid Bytewords: invalid word");
  let offset = y * dim + x;
  let value = bytewordsLookUpTable[offset];
  assert_1$2.default(value !== -1, "Invalid Bytewords: value not in lookup table");
  if (wordLength == BYTEWORD_LENGTH) {
    const byteword = getWord(value);
    let c1 = word[1].toLowerCase();
    let c2 = word[2].toLowerCase();
    assert_1$2.default(c1 === byteword[1] && c2 === byteword[2], "Invalid Bytewords: invalid middle letters of word");
  }
  return Buffer$1$1.from([value]).toString("hex");
};
const _decode$1 = (string, separator, wordLength) => {
  const words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : utils_1$n.partition(string, 2);
  const decodedString = words.map((word) => decodeWord(word, wordLength)).join("");
  assert_1$2.default(decodedString.length >= 5, "Invalid Bytewords: invalid decoded string length");
  const [body, bodyChecksum] = utils_1$n.split(Buffer$1$1.from(decodedString, "hex"), 4);
  const checksum = utils_1$n.getCRCHex(body);
  assert_1$2.default(checksum === bodyChecksum.toString("hex"), "Invalid Checksum");
  return body.toString("hex");
};
const decode$1 = (string, style = STYLES.MINIMAL) => {
  switch (style) {
    case STYLES.STANDARD:
      return _decode$1(string, " ", BYTEWORD_LENGTH);
    case STYLES.URI:
      return _decode$1(string, "-", BYTEWORD_LENGTH);
    case STYLES.MINIMAL:
      return _decode$1(string, "", MINIMAL_BYTEWORD_LENGTH);
    default:
      throw new Error(`Invalid style ${style}`);
  }
};
const encode$1 = (string, style = STYLES.MINIMAL) => {
  switch (style) {
    case STYLES.STANDARD:
      return encodeWithSeparator(string, " ");
    case STYLES.URI:
      return encodeWithSeparator(string, "-");
    case STYLES.MINIMAL:
      return encodeMinimal(string);
    default:
      throw new Error(`Invalid style ${style}`);
  }
};
bytewords$1.default = {
  decode: decode$1,
  encode: encode$1,
  STYLES
};
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(urEncoder, "__esModule", { value: true });
const fountainEncoder_1$1 = __importDefault$4(fountainEncoder);
const bytewords_1$1 = __importDefault$4(bytewords$1);
class UREncoder {
  constructor(_ur, maxFragmentLength, firstSeqNum, minFragmentLength) {
    this.ur = _ur;
    this.fountainEncoder = new fountainEncoder_1$1.default(_ur.cbor, maxFragmentLength, firstSeqNum, minFragmentLength);
  }
  get fragmentsLength() {
    return this.fountainEncoder.fragmentsLength;
  }
  get fragments() {
    return this.fountainEncoder.fragments;
  }
  get messageLength() {
    return this.fountainEncoder.messageLength;
  }
  get cbor() {
    return this.ur.cbor;
  }
  encodeWhole() {
    return [...new Array(this.fragmentsLength)].map(() => this.nextPart());
  }
  nextPart() {
    const part = this.fountainEncoder.nextPart();
    if (this.fountainEncoder.isSinglePart()) {
      return UREncoder.encodeSinglePart(this.ur);
    } else {
      return UREncoder.encodePart(this.ur.type, part);
    }
  }
  static encodeUri(scheme, pathComponents) {
    const path = pathComponents.join("/");
    return [scheme, path].join(":");
  }
  static encodeUR(pathComponents) {
    return UREncoder.encodeUri("ur", pathComponents);
  }
  static encodePart(type, part) {
    const seq = `${part.seqNum}-${part.seqLength}`;
    const body = bytewords_1$1.default.encode(part.cbor().toString("hex"), bytewords_1$1.default.STYLES.MINIMAL);
    return UREncoder.encodeUR([type, seq, body]);
  }
  static encodeSinglePart(ur2) {
    const body = bytewords_1$1.default.encode(ur2.cbor.toString("hex"), bytewords_1$1.default.STYLES.MINIMAL);
    return UREncoder.encodeUR([ur2.type, body]);
  }
}
urEncoder.default = UREncoder;
var urDecoder = {};
var fountainDecoder = {};
Object.defineProperty(fountainDecoder, "__esModule", { value: true });
fountainDecoder.FountainDecoderPart = void 0;
const utils_1$m = utils$i;
const fountainUtils_1 = fountainUtils;
const errors_1$1 = errors$4;
class FountainDecoderPart {
  constructor(_indexes, _fragment) {
    this._indexes = _indexes;
    this._fragment = _fragment;
  }
  get indexes() {
    return this._indexes;
  }
  get fragment() {
    return this._fragment;
  }
  static fromEncoderPart(encoderPart) {
    const indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);
    const fragment = encoderPart.fragment;
    return new FountainDecoderPart(indexes, fragment);
  }
  isSimple() {
    return this.indexes.length === 1;
  }
}
fountainDecoder.FountainDecoderPart = FountainDecoderPart;
class FountainDecoder {
  constructor() {
    this.result = void 0;
    this.expectedMessageLength = 0;
    this.expectedChecksum = 0;
    this.expectedFragmentLength = 0;
    this.processedPartsCount = 0;
    this.expectedPartIndexes = [];
    this.lastPartIndexes = [];
    this.queuedParts = [];
    this.receivedPartIndexes = [];
    this.mixedParts = [];
    this.simpleParts = [];
  }
  validatePart(part) {
    if (this.expectedPartIndexes.length === 0) {
      [...new Array(part.seqLength)].forEach((_, index2) => this.expectedPartIndexes.push(index2));
      this.expectedMessageLength = part.messageLength;
      this.expectedChecksum = part.checksum;
      this.expectedFragmentLength = part.fragment.length;
    } else {
      if (this.expectedPartIndexes.length !== part.seqLength) {
        return false;
      }
      if (this.expectedMessageLength !== part.messageLength) {
        return false;
      }
      if (this.expectedChecksum !== part.checksum) {
        return false;
      }
      if (this.expectedFragmentLength !== part.fragment.length) {
        return false;
      }
    }
    return true;
  }
  reducePartByPart(a, b) {
    if (utils_1$m.arrayContains(a.indexes, b.indexes)) {
      const newIndexes = utils_1$m.setDifference(a.indexes, b.indexes);
      const newFragment = utils_1$m.bufferXOR(a.fragment, b.fragment);
      return new FountainDecoderPart(newIndexes, newFragment);
    } else {
      return a;
    }
  }
  reduceMixedBy(part) {
    const newMixed = [];
    this.mixedParts.map(({ value: mixedPart }) => this.reducePartByPart(mixedPart, part)).forEach((reducedPart) => {
      if (reducedPart.isSimple()) {
        this.queuedParts.push(reducedPart);
      } else {
        newMixed.push({ key: reducedPart.indexes, value: reducedPart });
      }
    });
    this.mixedParts = newMixed;
  }
  processSimplePart(part) {
    const fragmentIndex = part.indexes[0];
    if (this.receivedPartIndexes.includes(fragmentIndex)) {
      return;
    }
    this.simpleParts.push({ key: part.indexes, value: part });
    this.receivedPartIndexes.push(fragmentIndex);
    if (utils_1$m.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {
      const sortedParts = this.simpleParts.map(({ value }) => value).sort((a, b) => a.indexes[0] - b.indexes[0]);
      const message2 = FountainDecoder.joinFragments(sortedParts.map((part2) => part2.fragment), this.expectedMessageLength);
      const checksum = utils_1$m.getCRC(message2);
      if (checksum === this.expectedChecksum) {
        this.result = message2;
      } else {
        this.error = new errors_1$1.InvalidChecksumError();
      }
    } else {
      this.reduceMixedBy(part);
    }
  }
  processMixedPart(part) {
    if (this.mixedParts.some(({ key: indexes }) => utils_1$m.arraysEqual(indexes, part.indexes))) {
      return;
    }
    let p2 = this.simpleParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), part);
    p2 = this.mixedParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), p2);
    if (p2.isSimple()) {
      this.queuedParts.push(p2);
    } else {
      this.reduceMixedBy(p2);
      this.mixedParts.push({ key: p2.indexes, value: p2 });
    }
  }
  processQueuedItem() {
    if (this.queuedParts.length === 0) {
      return;
    }
    const part = this.queuedParts.shift();
    if (part.isSimple()) {
      this.processSimplePart(part);
    } else {
      this.processMixedPart(part);
    }
  }
  receivePart(encoderPart) {
    if (this.isComplete()) {
      return false;
    }
    if (!this.validatePart(encoderPart)) {
      return false;
    }
    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);
    this.lastPartIndexes = decoderPart.indexes;
    this.queuedParts.push(decoderPart);
    while (!this.isComplete() && this.queuedParts.length > 0) {
      this.processQueuedItem();
    }
    this.processedPartsCount += 1;
    return true;
  }
  isComplete() {
    return Boolean(this.result !== void 0 && this.result.length > 0);
  }
  isSuccess() {
    return Boolean(this.error === void 0 && this.isComplete());
  }
  resultMessage() {
    return this.isSuccess() ? this.result : Buffer$1$1.from([]);
  }
  isFailure() {
    return this.error !== void 0;
  }
  resultError() {
    return this.error ? this.error.message : "";
  }
  expectedPartCount() {
    return this.expectedPartIndexes.length;
  }
  getExpectedPartIndexes() {
    return [...this.expectedPartIndexes];
  }
  getReceivedPartIndexes() {
    return [...this.receivedPartIndexes];
  }
  getLastPartIndexes() {
    return [...this.lastPartIndexes];
  }
  estimatedPercentComplete() {
    if (this.isComplete()) {
      return 1;
    }
    const expectedPartCount = this.expectedPartCount();
    if (expectedPartCount === 0) {
      return 0;
    }
    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));
  }
  getProgress() {
    if (this.isComplete()) {
      return 1;
    }
    const expectedPartCount = this.expectedPartCount();
    if (expectedPartCount === 0) {
      return 0;
    }
    return this.receivedPartIndexes.length / expectedPartCount;
  }
}
fountainDecoder.default = FountainDecoder;
FountainDecoder.joinFragments = (fragments, messageLength) => {
  return Buffer$1$1.concat(fragments).slice(0, messageLength);
};
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(urDecoder, "__esModule", { value: true });
const fountainDecoder_1 = __importDefault$3(fountainDecoder);
const bytewords_1 = __importDefault$3(bytewords$1);
const assert_1$1 = __importDefault$3(requireAssert());
const utils_1$l = utils$i;
const errors_1 = errors$4;
const ur_1$e = __importDefault$3(ur$1);
const fountainEncoder_1 = fountainEncoder;
class URDecoder {
  constructor(fountainDecoder2 = new fountainDecoder_1.default(), type = "bytes") {
    this.fountainDecoder = fountainDecoder2;
    this.type = type;
    assert_1$1.default(utils_1$l.isURType(type), "Invalid UR type");
    this.expected_type = "";
  }
  static decodeBody(type, message2) {
    const cbor2 = bytewords_1.default.decode(message2, bytewords_1.default.STYLES.MINIMAL);
    return new ur_1$e.default(Buffer$1$1.from(cbor2, "hex"), type);
  }
  validatePart(type) {
    if (this.expected_type) {
      return this.expected_type === type;
    }
    if (!utils_1$l.isURType(type)) {
      return false;
    }
    this.expected_type = type;
    return true;
  }
  static decode(message2) {
    const [type, components] = this.parse(message2);
    if (components.length === 0) {
      throw new errors_1.InvalidPathLengthError();
    }
    const body = components[0];
    return URDecoder.decodeBody(type, body);
  }
  static parse(message2) {
    const lowercase = message2.toLowerCase();
    const prefix = lowercase.slice(0, 3);
    if (prefix !== "ur:") {
      throw new errors_1.InvalidSchemeError();
    }
    const components = lowercase.slice(3).split("/");
    const type = components[0];
    if (components.length < 2) {
      throw new errors_1.InvalidPathLengthError();
    }
    if (!utils_1$l.isURType(type)) {
      throw new errors_1.InvalidTypeError();
    }
    return [type, components.slice(1)];
  }
  static parseSequenceComponent(s) {
    const components = s.split("-");
    if (components.length !== 2) {
      throw new errors_1.InvalidSequenceComponentError();
    }
    const seqNum = utils_1$l.toUint32(Number(components[0]));
    const seqLength = Number(components[1]);
    if (seqNum < 1 || seqLength < 1) {
      throw new errors_1.InvalidSequenceComponentError();
    }
    return [seqNum, seqLength];
  }
  receivePart(s) {
    if (this.result !== void 0) {
      return false;
    }
    const [type, components] = URDecoder.parse(s);
    if (!this.validatePart(type)) {
      return false;
    }
    if (components.length === 1) {
      this.result = URDecoder.decodeBody(type, components[0]);
      return true;
    }
    if (components.length !== 2) {
      throw new errors_1.InvalidPathLengthError();
    }
    const [seq, fragment] = components;
    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);
    const cbor2 = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);
    const part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor2);
    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {
      return false;
    }
    if (!this.fountainDecoder.receivePart(part)) {
      return false;
    }
    if (this.fountainDecoder.isSuccess()) {
      this.result = new ur_1$e.default(this.fountainDecoder.resultMessage(), type);
    } else if (this.fountainDecoder.isFailure()) {
      this.error = new errors_1.InvalidSchemeError();
    }
    return true;
  }
  resultUR() {
    return this.result ? this.result : new ur_1$e.default(Buffer$1$1.from([]));
  }
  isComplete() {
    return this.result && this.result.cbor.length > 0;
  }
  isSuccess() {
    return !this.error && this.isComplete();
  }
  isError() {
    return this.error !== void 0;
  }
  resultError() {
    return this.error ? this.error.message : "";
  }
  expectedPartCount() {
    return this.fountainDecoder.expectedPartCount();
  }
  expectedPartIndexes() {
    return this.fountainDecoder.getExpectedPartIndexes();
  }
  receivedPartIndexes() {
    return this.fountainDecoder.getReceivedPartIndexes();
  }
  lastPartIndexes() {
    return this.fountainDecoder.getLastPartIndexes();
  }
  estimatedPercentComplete() {
    return this.fountainDecoder.estimatedPercentComplete();
  }
  getProgress() {
    return this.fountainDecoder.getProgress();
  }
}
urDecoder.default = URDecoder;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(dist$g, "__esModule", { value: true });
dist$g.URDecoder = dist$g.UREncoder = dist$g.UR = void 0;
const ur_1$d = __importDefault$2(ur$1);
dist$g.UR = ur_1$d.default;
const urEncoder_1 = __importDefault$2(urEncoder);
dist$g.UREncoder = urEncoder_1.default;
const urDecoder_1 = __importDefault$2(urDecoder);
dist$g.URDecoder = urDecoder_1.default;
Object.defineProperty(RegistryItem$3, "__esModule", { value: true });
RegistryItem$3.RegistryItem = void 0;
const bc_ur_1$2 = dist$g;
const lib_1$i = lib$2;
let RegistryItem$2 = class RegistryItem {
  constructor() {
    this.toCBOR = () => {
      if (this.toDataItem() === void 0) {
        throw new Error(`#[ur-registry][RegistryItem][fn.toCBOR]: registry ${this.getRegistryType()}'s method toDataItem returns undefined`);
      }
      return (0, lib_1$i.encodeDataItem)(this.toDataItem());
    };
    this.toUR = () => {
      return new bc_ur_1$2.UR(this.toCBOR(), this.getRegistryType().getType());
    };
    this.toUREncoder = (maxFragmentLength, firstSeqNum, minFragmentLength) => {
      const ur2 = this.toUR();
      const urEncoder2 = new bc_ur_1$2.UREncoder(ur2, maxFragmentLength, firstSeqNum, minFragmentLength);
      return urEncoder2;
    };
  }
};
RegistryItem$3.RegistryItem = RegistryItem$2;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CryptoCoinInfo = exports.Network = exports.Type = void 0;
  const lib_12 = lib$2;
  const RegistryItem_12 = RegistryItem$3;
  const RegistryType_12 = RegistryType$3;
  var Keys2;
  (function(Keys3) {
    Keys3["type"] = "1";
    Keys3["network"] = "2";
  })(Keys2 || (Keys2 = {}));
  var Type2;
  (function(Type3) {
    Type3[Type3["bitcoin"] = 0] = "bitcoin";
  })(Type2 = exports.Type || (exports.Type = {}));
  var Network;
  (function(Network2) {
    Network2[Network2["mainnet"] = 0] = "mainnet";
    Network2[Network2["testnet"] = 1] = "testnet";
  })(Network = exports.Network || (exports.Network = {}));
  class CryptoCoinInfo2 extends RegistryItem_12.RegistryItem {
    constructor(type, network) {
      super();
      this.type = type;
      this.network = network;
      this.getRegistryType = () => {
        return RegistryType_12.RegistryTypes.CRYPTO_COIN_INFO;
      };
      this.getType = () => {
        return this.type || Type2.bitcoin;
      };
      this.getNetwork = () => {
        return this.network || Network.mainnet;
      };
      this.toDataItem = () => {
        const map = {};
        if (this.type) {
          map[Keys2.type] = this.type;
        }
        if (this.network) {
          map[Keys2.network] = this.network;
        }
        return new lib_12.DataItem(map);
      };
    }
  }
  exports.CryptoCoinInfo = CryptoCoinInfo2;
  CryptoCoinInfo2.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const type = map[Keys2.type];
    const network = map[Keys2.network];
    return new CryptoCoinInfo2(type, network);
  };
  CryptoCoinInfo2.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_12.decodeToDataItem)(_cborPayload);
    return CryptoCoinInfo2.fromDataItem(dataItem);
  };
})(CryptoCoinInfo$1);
var CryptoKeypath$3 = {};
var PathComponent$3 = {};
Object.defineProperty(PathComponent$3, "__esModule", { value: true });
PathComponent$3.PathComponent = void 0;
let PathComponent$2 = class PathComponent {
  constructor(args) {
    this.getIndex = () => this.index;
    this.isWildcard = () => this.wildcard;
    this.isHardened = () => this.hardened;
    this.index = args.index;
    this.hardened = args.hardened;
    if (this.index !== void 0) {
      this.wildcard = false;
    } else {
      this.wildcard = true;
    }
    if (this.index && (this.index & PathComponent.HARDENED_BIT) !== 0) {
      throw new Error(`#[ur-registry][PathComponent][fn.constructor]: Invalid index ${this.index} - most significant bit cannot be set`);
    }
  }
};
PathComponent$3.PathComponent = PathComponent$2;
PathComponent$2.HARDENED_BIT = 2147483648;
Object.defineProperty(CryptoKeypath$3, "__esModule", { value: true });
CryptoKeypath$3.CryptoKeypath = void 0;
const lib_1$h = lib$2;
const PathComponent_1$1 = PathComponent$3;
const RegistryItem_1$h = RegistryItem$3;
const RegistryType_1$i = RegistryType$3;
var Keys$b;
(function(Keys2) {
  Keys2[Keys2["components"] = 1] = "components";
  Keys2[Keys2["source_fingerprint"] = 2] = "source_fingerprint";
  Keys2[Keys2["depth"] = 3] = "depth";
})(Keys$b || (Keys$b = {}));
let CryptoKeypath$2 = class CryptoKeypath extends RegistryItem_1$h.RegistryItem {
  constructor(components = [], sourceFingerprint, depth) {
    super();
    this.components = components;
    this.sourceFingerprint = sourceFingerprint;
    this.depth = depth;
    this.getRegistryType = () => {
      return RegistryType_1$i.RegistryTypes.CRYPTO_KEYPATH;
    };
    this.getPath = () => {
      if (this.components.length === 0) {
        return void 0;
      }
      const components2 = this.components.map((component) => {
        return `${component.isWildcard() ? "*" : component.getIndex()}${component.isHardened() ? "'" : ""}`;
      });
      return components2.join("/");
    };
    this.getComponents = () => this.components;
    this.getSourceFingerprint = () => this.sourceFingerprint;
    this.getDepth = () => this.depth;
    this.toDataItem = () => {
      const map = {};
      const components2 = [];
      this.components && this.components.forEach((component) => {
        if (component.isWildcard()) {
          components2.push([]);
        } else {
          components2.push(component.getIndex());
        }
        components2.push(component.isHardened());
      });
      map[Keys$b.components] = components2;
      if (this.sourceFingerprint) {
        map[Keys$b.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);
      }
      if (this.depth !== void 0) {
        map[Keys$b.depth] = this.depth;
      }
      return new lib_1$h.DataItem(map);
    };
  }
};
CryptoKeypath$3.CryptoKeypath = CryptoKeypath$2;
CryptoKeypath$2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const pathComponents = [];
  const components = map[Keys$b.components];
  if (components) {
    for (let i = 0; i < components.length; i += 2) {
      const isHardened = components[i + 1];
      const path = components[i];
      if (typeof path === "number") {
        pathComponents.push(new PathComponent_1$1.PathComponent({ index: path, hardened: isHardened }));
      } else {
        pathComponents.push(new PathComponent_1$1.PathComponent({ hardened: isHardened }));
      }
    }
  }
  const _sourceFingerprint = map[Keys$b.source_fingerprint];
  let sourceFingerprint;
  if (_sourceFingerprint) {
    sourceFingerprint = Buffer$1$1.alloc(4);
    sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);
  }
  const depth = map[Keys$b.depth];
  return new CryptoKeypath$2(pathComponents, sourceFingerprint, depth);
};
CryptoKeypath$2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$h.decodeToDataItem)(_cborPayload);
  return CryptoKeypath$2.fromDataItem(dataItem);
};
Object.defineProperty(CryptoHDKey$3, "__esModule", { value: true });
CryptoHDKey$3.CryptoHDKey = void 0;
const bs58check_1$2 = bs58check$4;
const CryptoCoinInfo_1$1 = CryptoCoinInfo$1;
const CryptoKeypath_1$1 = CryptoKeypath$3;
const lib_1$g = lib$2;
const RegistryItem_1$g = RegistryItem$3;
const RegistryType_1$h = RegistryType$3;
var Keys$a;
(function(Keys2) {
  Keys2[Keys2["is_master"] = 1] = "is_master";
  Keys2[Keys2["is_private"] = 2] = "is_private";
  Keys2[Keys2["key_data"] = 3] = "key_data";
  Keys2[Keys2["chain_code"] = 4] = "chain_code";
  Keys2[Keys2["use_info"] = 5] = "use_info";
  Keys2[Keys2["origin"] = 6] = "origin";
  Keys2[Keys2["children"] = 7] = "children";
  Keys2[Keys2["parent_fingerprint"] = 8] = "parent_fingerprint";
  Keys2[Keys2["name"] = 9] = "name";
  Keys2[Keys2["note"] = 10] = "note";
})(Keys$a || (Keys$a = {}));
let CryptoHDKey$2 = class CryptoHDKey extends RegistryItem_1$g.RegistryItem {
  constructor(args) {
    super();
    this.isECKey = () => {
      return false;
    };
    this.getKey = () => this.key;
    this.getChainCode = () => this.chainCode;
    this.isMaster = () => this.master;
    this.isPrivateKey = () => !!this.privateKey;
    this.getUseInfo = () => this.useInfo;
    this.getOrigin = () => this.origin;
    this.getChildren = () => this.children;
    this.getParentFingerprint = () => this.parentFingerprint;
    this.getName = () => this.name;
    this.getNote = () => this.note;
    this.getBip32Key = () => {
      var _a, _b, _c;
      let version2;
      let depth;
      let index2 = 0;
      let parentFingerprint = Buffer$1$1.alloc(4).fill(0);
      if (this.isMaster()) {
        version2 = Buffer$1$1.from("0488ADE4", "hex");
        depth = 0;
        index2 = 0;
      } else {
        depth = ((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getComponents().length) || ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getDepth());
        const paths = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getComponents();
        const lastPath = paths[paths.length - 1];
        if (lastPath) {
          index2 = lastPath.isHardened() ? lastPath.getIndex() + 2147483648 : lastPath.getIndex();
          if (this.getParentFingerprint()) {
            parentFingerprint = this.getParentFingerprint();
          }
        }
        if (this.isPrivateKey()) {
          version2 = Buffer$1$1.from("0488ADE4", "hex");
        } else {
          version2 = Buffer$1$1.from("0488B21E", "hex");
        }
      }
      const depthBuffer = Buffer$1$1.alloc(1);
      depthBuffer.writeUInt8(depth, 0);
      const indexBuffer = Buffer$1$1.alloc(4);
      indexBuffer.writeUInt32BE(index2, 0);
      const chainCode = this.getChainCode();
      const key2 = this.getKey();
      return (0, bs58check_1$2.encode)(Buffer$1$1.concat([version2, depthBuffer, parentFingerprint, indexBuffer, chainCode, key2]));
    };
    this.getRegistryType = () => {
      return RegistryType_1$h.RegistryTypes.CRYPTO_HDKEY;
    };
    this.getOutputDescriptorContent = () => {
      var _a, _b, _c, _d, _e, _f, _g;
      let result = "";
      if (this.getOrigin()) {
        if (((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getSourceFingerprint()) && ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getPath())) {
          result += `${(_d = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getSourceFingerprint()) === null || _d === void 0 ? void 0 : _d.toString("hex")}/${(_e = this.getOrigin()) === null || _e === void 0 ? void 0 : _e.getPath()}`;
        }
      }
      result += this.getBip32Key();
      if (this.getChildren()) {
        if ((_f = this.getChildren()) === null || _f === void 0 ? void 0 : _f.getPath()) {
          result += `/${(_g = this.getChildren()) === null || _g === void 0 ? void 0 : _g.getPath()}`;
        }
      }
      return result;
    };
    this.setupMasterKey = (args2) => {
      this.master = true;
      this.key = args2.key;
      this.chainCode = args2.chainCode;
    };
    this.setupDeriveKey = (args2) => {
      this.master = false;
      this.privateKey = args2.isPrivateKey;
      this.key = args2.key;
      this.chainCode = args2.chainCode;
      this.useInfo = args2.useInfo;
      this.origin = args2.origin;
      this.children = args2.children;
      this.parentFingerprint = args2.parentFingerprint;
      this.name = args2.name;
      this.note = args2.note;
    };
    this.toDataItem = () => {
      const map = {};
      if (this.master) {
        map[Keys$a.is_master] = true;
        map[Keys$a.key_data] = this.key;
        map[Keys$a.chain_code] = this.chainCode;
      } else {
        if (this.privateKey !== void 0) {
          map[Keys$a.is_private] = this.privateKey;
        }
        map[Keys$a.key_data] = this.key;
        if (this.chainCode) {
          map[Keys$a.chain_code] = this.chainCode;
        }
        if (this.useInfo) {
          const useInfo = this.useInfo.toDataItem();
          useInfo.setTag(this.useInfo.getRegistryType().getTag());
          map[Keys$a.use_info] = useInfo;
        }
        if (this.origin) {
          const origin2 = this.origin.toDataItem();
          origin2.setTag(this.origin.getRegistryType().getTag());
          map[Keys$a.origin] = origin2;
        }
        if (this.children) {
          const children = this.children.toDataItem();
          children.setTag(this.children.getRegistryType().getTag());
          map[Keys$a.children] = children;
        }
        if (this.parentFingerprint) {
          map[Keys$a.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);
        }
        if (this.name !== void 0) {
          map[Keys$a.name] = this.name;
        }
        if (this.note !== void 0) {
          map[Keys$a.note] = this.note;
        }
      }
      return new lib_1$g.DataItem(map);
    };
    if (args.isMaster) {
      this.setupMasterKey(args);
    } else {
      this.setupDeriveKey(args);
    }
  }
};
CryptoHDKey$3.CryptoHDKey = CryptoHDKey$2;
CryptoHDKey$2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const isMaster = !!map[Keys$a.is_master];
  const isPrivateKey = map[Keys$a.is_private];
  const key2 = map[Keys$a.key_data];
  const chainCode = map[Keys$a.chain_code];
  const useInfo = map[Keys$a.use_info] ? CryptoCoinInfo_1$1.CryptoCoinInfo.fromDataItem(map[Keys$a.use_info]) : void 0;
  const origin2 = map[Keys$a.origin] ? CryptoKeypath_1$1.CryptoKeypath.fromDataItem(map[Keys$a.origin]) : void 0;
  const children = map[Keys$a.children] ? CryptoKeypath_1$1.CryptoKeypath.fromDataItem(map[Keys$a.children]) : void 0;
  const _parentFingerprint = map[Keys$a.parent_fingerprint];
  let parentFingerprint = void 0;
  if (_parentFingerprint) {
    parentFingerprint = Buffer$1$1.alloc(4);
    parentFingerprint.writeUInt32BE(_parentFingerprint, 0);
  }
  const name2 = map[Keys$a.name];
  const note = map[Keys$a.note];
  return new CryptoHDKey$2({
    isMaster,
    isPrivateKey,
    key: key2,
    chainCode,
    useInfo,
    origin: origin2,
    children,
    parentFingerprint,
    name: name2,
    note
  });
};
CryptoHDKey$2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$g.decodeToDataItem)(_cborPayload);
  return CryptoHDKey$2.fromDataItem(dataItem);
};
var CryptoECKey$3 = {};
Object.defineProperty(CryptoECKey$3, "__esModule", { value: true });
CryptoECKey$3.CryptoECKey = void 0;
const lib_1$f = lib$2;
const RegistryItem_1$f = RegistryItem$3;
const RegistryType_1$g = RegistryType$3;
var Keys$9;
(function(Keys2) {
  Keys2[Keys2["curve"] = 1] = "curve";
  Keys2[Keys2["private"] = 2] = "private";
  Keys2[Keys2["data"] = 3] = "data";
})(Keys$9 || (Keys$9 = {}));
let CryptoECKey$2 = class CryptoECKey extends RegistryItem_1$f.RegistryItem {
  constructor(args) {
    super();
    this.isECKey = () => {
      return true;
    };
    this.getCurve = () => this.curve || 0;
    this.isPrivateKey = () => this.privateKey || false;
    this.getData = () => this.data;
    this.getRegistryType = () => {
      return RegistryType_1$g.RegistryTypes.CRYPTO_ECKEY;
    };
    this.toDataItem = () => {
      const map = {};
      if (this.curve) {
        map[Keys$9.curve] = this.curve;
      }
      if (this.privateKey !== void 0) {
        map[Keys$9.private] = this.privateKey;
      }
      map[Keys$9.data] = this.data;
      return new lib_1$f.DataItem(map);
    };
    this.getOutputDescriptorContent = () => {
      return this.data.toString("hex");
    };
    this.data = args.data;
    this.curve = args.curve;
    this.privateKey = args.privateKey || void 0;
  }
};
CryptoECKey$3.CryptoECKey = CryptoECKey$2;
CryptoECKey$2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const curve2 = map[Keys$9.curve];
  const privateKey = map[Keys$9.private];
  const data = map[Keys$9.data];
  if (!data) {
    throw new Error(`#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${dataItem}`);
  }
  return new CryptoECKey$2({ data, curve: curve2, privateKey });
};
CryptoECKey$2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$f.decodeToDataItem)(_cborPayload);
  return CryptoECKey$2.fromDataItem(dataItem);
};
var Bytes$4 = {};
Object.defineProperty(Bytes$4, "__esModule", { value: true });
Bytes$4.Bytes = void 0;
const lib_1$e = lib$2;
const RegistryItem_1$e = RegistryItem$3;
const RegistryType_1$f = RegistryType$3;
let Bytes$3 = class Bytes extends RegistryItem_1$e.RegistryItem {
  constructor(bytes2) {
    super();
    this.bytes = bytes2;
    this.getRegistryType = () => {
      return RegistryType_1$f.RegistryTypes.BYTES;
    };
    this.getData = () => this.bytes;
    this.toDataItem = () => {
      return new lib_1$e.DataItem(this.bytes);
    };
  }
};
Bytes$4.Bytes = Bytes$3;
Bytes$3.fromDataItem = (dataItem) => {
  const bytes2 = dataItem.getData();
  if (!bytes2) {
    throw new Error(`#[ur-registry][Bytes][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
  }
  return new Bytes$3(bytes2);
};
Bytes$3.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$e.decodeToDataItem)(_cborPayload);
  return Bytes$3.fromDataItem(dataItem);
};
var CryptoOutput$3 = {};
var MultiKey$3 = {};
Object.defineProperty(MultiKey$3, "__esModule", { value: true });
MultiKey$3.MultiKey = void 0;
const CryptoECKey_1$3 = CryptoECKey$3;
const CryptoHDKey_1$5 = CryptoHDKey$3;
const DataItem_1$1 = DataItem$3;
const RegistryItem_1$d = RegistryItem$3;
const RegistryType_1$e = RegistryType$3;
var Keys$8;
(function(Keys2) {
  Keys2[Keys2["threshold"] = 1] = "threshold";
  Keys2[Keys2["keys"] = 2] = "keys";
})(Keys$8 || (Keys$8 = {}));
let MultiKey$2 = class MultiKey extends RegistryItem_1$d.RegistryItem {
  constructor(threshold, keys2) {
    super();
    this.threshold = threshold;
    this.keys = keys2;
    this.getThreshold = () => this.threshold;
    this.getKeys = () => this.keys;
    this.toDataItem = () => {
      const map = {};
      map[Keys$8.threshold] = this.threshold;
      const keys3 = this.keys.map((k) => {
        const dataItem = k.toDataItem();
        dataItem.setTag(k.getRegistryType().getTag());
        return dataItem;
      });
      map[Keys$8.keys] = keys3;
      return new DataItem_1$1.DataItem(map);
    };
    this.getOutputDescriptorContent = () => {
      return [
        this.getThreshold(),
        this.keys.map((k) => k.getOutputDescriptorContent()).join(",")
      ].join(",");
    };
  }
};
MultiKey$3.MultiKey = MultiKey$2;
MultiKey$2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const threshold = map[Keys$8.threshold];
  const _keys = map[Keys$8.keys];
  const keys2 = [];
  _keys.forEach((k) => {
    if (k.getTag() === RegistryType_1$e.RegistryTypes.CRYPTO_HDKEY.getTag()) {
      keys2.push(CryptoHDKey_1$5.CryptoHDKey.fromDataItem(k));
    } else if (k.getTag() === RegistryType_1$e.RegistryTypes.CRYPTO_ECKEY.getTag()) {
      keys2.push(CryptoECKey_1$3.CryptoECKey.fromDataItem(k));
    }
  });
  return new MultiKey$2(threshold, keys2);
};
Object.defineProperty(CryptoOutput$3, "__esModule", { value: true });
CryptoOutput$3.CryptoOutput = void 0;
const CryptoECKey_1$2 = CryptoECKey$3;
const CryptoHDKey_1$4 = CryptoHDKey$3;
const lib_1$d = lib$2;
const MultiKey_1$1 = MultiKey$3;
const RegistryItem_1$c = RegistryItem$3;
const RegistryType_1$d = RegistryType$3;
const ScriptExpression_1$2 = ScriptExpression$1;
let CryptoOutput$2 = class CryptoOutput extends RegistryItem_1$c.RegistryItem {
  constructor(scriptExpressions, cryptoKey) {
    super();
    this.scriptExpressions = scriptExpressions;
    this.cryptoKey = cryptoKey;
    this.getRegistryType = () => {
      return RegistryType_1$d.RegistryTypes.CRYPTO_OUTPUT;
    };
    this.getCryptoKey = () => this.cryptoKey;
    this.getHDKey = () => {
      if (this.cryptoKey instanceof CryptoHDKey_1$4.CryptoHDKey) {
        return this.cryptoKey;
      } else {
        return void 0;
      }
    };
    this.getECKey = () => {
      if (this.cryptoKey instanceof CryptoECKey_1$2.CryptoECKey) {
        return this.cryptoKey;
      } else {
        return void 0;
      }
    };
    this.getMultiKey = () => {
      if (this.cryptoKey instanceof MultiKey_1$1.MultiKey) {
        return this.cryptoKey;
      } else {
        return void 0;
      }
    };
    this.getScriptExpressions = () => this.scriptExpressions;
    this._toOutputDescriptor = (seIndex) => {
      if (seIndex >= this.scriptExpressions.length) {
        return this.cryptoKey.getOutputDescriptorContent();
      } else {
        return `${this.scriptExpressions[seIndex].getExpression()}(${this._toOutputDescriptor(seIndex + 1)})`;
      }
    };
    this.toString = () => {
      return this._toOutputDescriptor(0);
    };
    this.toDataItem = () => {
      let dataItem = this.cryptoKey.toDataItem();
      if (this.cryptoKey instanceof CryptoECKey_1$2.CryptoECKey || this.cryptoKey instanceof CryptoHDKey_1$4.CryptoHDKey) {
        dataItem.setTag(this.cryptoKey.getRegistryType().getTag());
      }
      const clonedSe = [...this.scriptExpressions];
      clonedSe.reverse().forEach((se) => {
        const tagValue = se.getTag();
        if (dataItem.getTag() === void 0) {
          dataItem.setTag(tagValue);
        } else {
          dataItem = new lib_1$d.DataItem(dataItem, tagValue);
        }
      });
      return dataItem;
    };
  }
};
CryptoOutput$3.CryptoOutput = CryptoOutput$2;
CryptoOutput$2.fromDataItem = (dataItem) => {
  const scriptExpressions = [];
  let _dataItem = dataItem;
  while (true) {
    let _tag = _dataItem.getTag();
    const se = ScriptExpression_1$2.ScriptExpression.fromTag(_tag);
    if (se) {
      scriptExpressions.push(se);
      if (_dataItem.getData() instanceof lib_1$d.DataItem) {
        _dataItem = _dataItem.getData();
        _tag = _dataItem.getTag();
      } else {
        break;
      }
    } else {
      break;
    }
  }
  const seLength = scriptExpressions.length;
  const isMultiKey = seLength > 0 && (scriptExpressions[seLength - 1].getExpression() === ScriptExpression_1$2.ScriptExpressions.MULTISIG.getExpression() || scriptExpressions[seLength - 1].getExpression() === ScriptExpression_1$2.ScriptExpressions.SORTED_MULTISIG.getExpression());
  if (isMultiKey) {
    const multiKey = MultiKey_1$1.MultiKey.fromDataItem(_dataItem);
    return new CryptoOutput$2(scriptExpressions, multiKey);
  }
  if (_dataItem.getTag() === RegistryType_1$d.RegistryTypes.CRYPTO_HDKEY.getTag()) {
    const cryptoHDKey = CryptoHDKey_1$4.CryptoHDKey.fromDataItem(_dataItem);
    return new CryptoOutput$2(scriptExpressions, cryptoHDKey);
  } else {
    const cryptoECKey = CryptoECKey_1$2.CryptoECKey.fromDataItem(_dataItem);
    return new CryptoOutput$2(scriptExpressions, cryptoECKey);
  }
};
CryptoOutput$2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$d.decodeToDataItem)(_cborPayload);
  return CryptoOutput$2.fromDataItem(dataItem);
};
var CryptoPSBT$3 = {};
Object.defineProperty(CryptoPSBT$3, "__esModule", { value: true });
CryptoPSBT$3.CryptoPSBT = void 0;
const lib_1$c = lib$2;
const RegistryItem_1$b = RegistryItem$3;
const RegistryType_1$c = RegistryType$3;
let CryptoPSBT$2 = class CryptoPSBT extends RegistryItem_1$b.RegistryItem {
  constructor(psbt) {
    super();
    this.psbt = psbt;
    this.getRegistryType = () => RegistryType_1$c.RegistryTypes.CRYPTO_PSBT;
    this.getPSBT = () => this.psbt;
    this.toDataItem = () => {
      return new lib_1$c.DataItem(this.psbt);
    };
  }
};
CryptoPSBT$3.CryptoPSBT = CryptoPSBT$2;
CryptoPSBT$2.fromDataItem = (dataItem) => {
  const psbt = dataItem.getData();
  if (!psbt) {
    throw new Error(`#[ur-registry][CryptoPSBT][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
  }
  return new CryptoPSBT$2(psbt);
};
CryptoPSBT$2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$c.decodeToDataItem)(_cborPayload);
  return CryptoPSBT$2.fromDataItem(dataItem);
};
var CryptoAccount$1 = {};
var hasRequiredCryptoAccount$1;
function requireCryptoAccount$1() {
  if (hasRequiredCryptoAccount$1) return CryptoAccount$1;
  hasRequiredCryptoAccount$1 = 1;
  Object.defineProperty(CryptoAccount$1, "__esModule", { value: true });
  CryptoAccount$1.CryptoAccount = void 0;
  const _1 = requireDist$1();
  const lib_12 = lib$2;
  const RegistryItem_12 = RegistryItem$3;
  const RegistryType_12 = RegistryType$3;
  var Keys2;
  (function(Keys3) {
    Keys3[Keys3["masterFingerprint"] = 1] = "masterFingerprint";
    Keys3[Keys3["outputDescriptors"] = 2] = "outputDescriptors";
  })(Keys2 || (Keys2 = {}));
  class CryptoAccount2 extends RegistryItem_12.RegistryItem {
    constructor(masterFingerprint, outputDescriptors) {
      super();
      this.masterFingerprint = masterFingerprint;
      this.outputDescriptors = outputDescriptors;
      this.getRegistryType = () => {
        return RegistryType_12.RegistryTypes.CRYPTO_ACCOUNT;
      };
      this.getMasterFingerprint = () => this.masterFingerprint;
      this.getOutputDescriptors = () => this.outputDescriptors;
      this.toDataItem = () => {
        const map = {};
        if (this.masterFingerprint) {
          map[Keys2.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
        }
        if (this.outputDescriptors) {
          map[Keys2.outputDescriptors] = this.outputDescriptors.map((item) => item.toDataItem());
        }
        return new lib_12.DataItem(map);
      };
    }
  }
  CryptoAccount$1.CryptoAccount = CryptoAccount2;
  CryptoAccount2.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const masterFingerprint = Buffer$1$1.alloc(4);
    const _masterFingerprint = map[Keys2.masterFingerprint];
    if (_masterFingerprint) {
      masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
    }
    const outputDescriptors = map[Keys2.outputDescriptors];
    const cryptoOutputs = outputDescriptors.map((item) => _1.CryptoOutput.fromDataItem(item));
    return new CryptoAccount2(masterFingerprint, cryptoOutputs);
  };
  CryptoAccount2.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_12.decodeToDataItem)(_cborPayload);
    return CryptoAccount2.fromDataItem(dataItem);
  };
  return CryptoAccount$1;
}
var Decoder$1 = {};
var errors$2 = {};
Object.defineProperty(errors$2, "__esModule", { value: true });
errors$2.UnknownURTypeError = void 0;
let UnknownURTypeError$1 = class UnknownURTypeError extends Error {
  constructor(message2) {
    super(message2);
  }
};
errors$2.UnknownURTypeError = UnknownURTypeError$1;
var hasRequiredDecoder$1;
function requireDecoder$1() {
  if (hasRequiredDecoder$1) return Decoder$1;
  hasRequiredDecoder$1 = 1;
  Object.defineProperty(Decoder$1, "__esModule", { value: true });
  Decoder$1.URRegistryDecoder = void 0;
  const bc_ur_12 = dist$g;
  const __1 = requireDist$1();
  const RegistryType_12 = RegistryType$3;
  const errors_12 = errors$2;
  class URRegistryDecoder extends bc_ur_12.URDecoder {
    constructor() {
      super(...arguments);
      this.resultRegistryType = () => {
        const ur2 = this.resultUR();
        switch (ur2.type) {
          case RegistryType_12.RegistryTypes.BYTES.getType():
            return __1.Bytes.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_HDKEY.getType():
            return __1.CryptoHDKey.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_KEYPATH.getType():
            return __1.CryptoKeypath.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_COIN_INFO.getType():
            return __1.CryptoCoinInfo.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_ECKEY.getType():
            return __1.CryptoECKey.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_OUTPUT.getType():
            return __1.CryptoOutput.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_PSBT.getType():
            return __1.CryptoPSBT.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_ACCOUNT.getType():
            return __1.CryptoAccount.fromCBOR(ur2.cbor);
          default:
            throw new errors_12.UnknownURTypeError(`#[ur-registry][Decoder][fn.resultRegistryType]: registry type ${ur2.type} is not supported now`);
        }
      };
    }
  }
  Decoder$1.URRegistryDecoder = URRegistryDecoder;
  return Decoder$1;
}
var CryptoMultiAccounts$3 = {};
Object.defineProperty(CryptoMultiAccounts$3, "__esModule", { value: true });
CryptoMultiAccounts$3.CryptoMultiAccounts = void 0;
const RegistryType_1$b = RegistryType$3;
const CryptoHDKey_1$3 = CryptoHDKey$3;
const RegistryItem_1$a = RegistryItem$3;
const lib_1$b = lib$2;
var Keys$7;
(function(Keys2) {
  Keys2[Keys2["masterFingerprint"] = 1] = "masterFingerprint";
  Keys2[Keys2["keys"] = 2] = "keys";
  Keys2[Keys2["device"] = 3] = "device";
  Keys2[Keys2["deviceId"] = 4] = "deviceId";
  Keys2[Keys2["version"] = 5] = "version";
})(Keys$7 || (Keys$7 = {}));
let CryptoMultiAccounts$2 = class CryptoMultiAccounts extends RegistryItem_1$a.RegistryItem {
  constructor(masterFingerprint, keys2, device, deviceId, version2) {
    super();
    this.masterFingerprint = masterFingerprint;
    this.keys = keys2;
    this.device = device;
    this.deviceId = deviceId;
    this.version = version2;
    this.getRegistryType = () => RegistryType_1$b.RegistryTypes.CRYPTO_MULTI_ACCOUNTS;
    this.getMasterFingerprint = () => this.masterFingerprint;
    this.getKeys = () => this.keys;
    this.getDevice = () => this.device;
    this.getDeviceId = () => this.deviceId;
    this.getVersion = () => this.version;
    this.toDataItem = () => {
      const map = {};
      if (this.masterFingerprint) {
        map[Keys$7.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
      }
      if (this.keys) {
        map[Keys$7.keys] = this.keys.map((item) => {
          const dataItem = item.toDataItem();
          dataItem.setTag(item.getRegistryType().getTag());
          return dataItem;
        });
      }
      if (this.device) {
        map[Keys$7.device] = this.device;
      }
      if (this.deviceId) {
        map[Keys$7.deviceId] = this.deviceId;
      }
      if (this.version) {
        map[Keys$7.version] = this.version;
      }
      return new lib_1$b.DataItem(map);
    };
  }
};
CryptoMultiAccounts$3.CryptoMultiAccounts = CryptoMultiAccounts$2;
CryptoMultiAccounts$2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const masterFingerprint = Buffer$1$1.alloc(4);
  const _masterFingerprint = map[Keys$7.masterFingerprint];
  if (_masterFingerprint) {
    masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
  }
  const keys2 = map[Keys$7.keys];
  const cryptoHDKeys = keys2.map((item) => CryptoHDKey_1$3.CryptoHDKey.fromDataItem(item));
  const device = map[Keys$7.device];
  const deviceId = map[Keys$7.deviceId];
  const version2 = map[Keys$7.version];
  return new CryptoMultiAccounts$2(masterFingerprint, cryptoHDKeys, device, deviceId, version2);
};
CryptoMultiAccounts$2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$b.decodeToDataItem)(_cborPayload);
  return CryptoMultiAccounts$2.fromDataItem(dataItem);
};
var QRHardwareCall$1 = {};
var KeyDerivation$3 = {};
var DerivationSchema$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyDerivationSchema = exports.DerivationAlgorithm = exports.Curve = void 0;
  const RegistryType_12 = RegistryType$3;
  const RegistryItem_12 = RegistryItem$3;
  const lib_12 = lib$2;
  const CryptoKeypath_12 = CryptoKeypath$3;
  var Keys2;
  (function(Keys3) {
    Keys3[Keys3["keyPath"] = 1] = "keyPath";
    Keys3[Keys3["curve"] = 2] = "curve";
    Keys3[Keys3["algo"] = 3] = "algo";
    Keys3[Keys3["chainType"] = 4] = "chainType";
  })(Keys2 || (Keys2 = {}));
  var Curve;
  (function(Curve2) {
    Curve2[Curve2["secp256k1"] = 0] = "secp256k1";
    Curve2[Curve2["ed25519"] = 1] = "ed25519";
  })(Curve = exports.Curve || (exports.Curve = {}));
  var DerivationAlgorithm;
  (function(DerivationAlgorithm2) {
    DerivationAlgorithm2[DerivationAlgorithm2["slip10"] = 0] = "slip10";
    DerivationAlgorithm2[DerivationAlgorithm2["bip32ed25519"] = 1] = "bip32ed25519";
  })(DerivationAlgorithm = exports.DerivationAlgorithm || (exports.DerivationAlgorithm = {}));
  class KeyDerivationSchema extends RegistryItem_12.RegistryItem {
    constructor(keypath, curve2 = Curve.secp256k1, algo2 = DerivationAlgorithm.slip10, chainType) {
      super();
      this.keypath = keypath;
      this.curve = curve2;
      this.algo = algo2;
      this.chainType = chainType;
      this.getRegistryType = () => RegistryType_12.RegistryTypes.KEY_DERIVATION_SCHEMA;
      this.getKeypath = () => this.keypath;
      this.getCurve = () => this.curve;
      this.getAlgo = () => this.algo;
      this.getChainType = () => this.chainType;
      this.toDataItem = () => {
        const map = {};
        const dataItem = this.getKeypath().toDataItem();
        dataItem.setTag(this.getKeypath().getRegistryType().getTag());
        map[Keys2.keyPath] = dataItem;
        map[Keys2.curve] = this.curve;
        map[Keys2.algo] = this.algo;
        if (this.chainType) {
          map[Keys2.chainType] = this.chainType;
        }
        return new lib_12.DataItem(map);
      };
    }
  }
  exports.KeyDerivationSchema = KeyDerivationSchema;
  KeyDerivationSchema.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const keypaths = CryptoKeypath_12.CryptoKeypath.fromDataItem(map[Keys2.keyPath]);
    const curve2 = map[Keys2.curve];
    const algo2 = map[Keys2.algo];
    const chainType = map[Keys2.chainType];
    return new KeyDerivationSchema(keypaths, curve2, algo2, chainType);
  };
  KeyDerivationSchema.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_12.decodeToDataItem)(_cborPayload);
    return KeyDerivationSchema.fromDataItem(dataItem);
  };
})(DerivationSchema$1);
Object.defineProperty(KeyDerivation$3, "__esModule", { value: true });
KeyDerivation$3.KeyDerivation = void 0;
const RegistryType_1$a = RegistryType$3;
const RegistryItem_1$9 = RegistryItem$3;
const lib_1$a = lib$2;
const DerivationSchema_1$1 = DerivationSchema$1;
var Keys$6;
(function(Keys2) {
  Keys2[Keys2["schemas"] = 1] = "schemas";
})(Keys$6 || (Keys$6 = {}));
let KeyDerivation$2 = class KeyDerivation extends RegistryItem_1$9.RegistryItem {
  constructor(schemas) {
    super();
    this.schemas = schemas;
    this.getRegistryType = () => RegistryType_1$a.RegistryTypes.KEY_DERIVATION_CALL;
    this.getSchemas = () => this.schemas;
    this.toDataItem = () => {
      const map = {};
      map[Keys$6.schemas] = this.schemas.map((schema) => {
        const dataItem = schema.toDataItem();
        dataItem.setTag(schema.getRegistryType().getTag());
        return dataItem;
      });
      return new lib_1$a.DataItem(map);
    };
  }
};
KeyDerivation$3.KeyDerivation = KeyDerivation$2;
KeyDerivation$2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const schemas = map[Keys$6.schemas].map((keypath) => DerivationSchema_1$1.KeyDerivationSchema.fromDataItem(keypath));
  return new KeyDerivation$2(schemas);
};
KeyDerivation$2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$a.decodeToDataItem)(_cborPayload);
  return KeyDerivation$2.fromDataItem(dataItem);
};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QRHardwareCall = exports.QRHardwareCallVersion = exports.QRHardwareCallType = void 0;
  const RegistryType_12 = RegistryType$3;
  const RegistryItem_12 = RegistryItem$3;
  const lib_12 = lib$2;
  const KeyDerivation_1 = KeyDerivation$3;
  var Keys2;
  (function(Keys3) {
    Keys3[Keys3["type"] = 1] = "type";
    Keys3[Keys3["params"] = 2] = "params";
    Keys3[Keys3["origin"] = 3] = "origin";
    Keys3[Keys3["version"] = 4] = "version";
  })(Keys2 || (Keys2 = {}));
  var QRHardwareCallType;
  (function(QRHardwareCallType2) {
    QRHardwareCallType2[QRHardwareCallType2["KeyDerivation"] = 0] = "KeyDerivation";
  })(QRHardwareCallType = exports.QRHardwareCallType || (exports.QRHardwareCallType = {}));
  (function(QRHardwareCallVersion) {
    QRHardwareCallVersion[QRHardwareCallVersion["V0"] = 0] = "V0";
    QRHardwareCallVersion[QRHardwareCallVersion["V1"] = 1] = "V1";
  })(exports.QRHardwareCallVersion || (exports.QRHardwareCallVersion = {}));
  class QRHardwareCall2 extends RegistryItem_12.RegistryItem {
    constructor(type, params, origin2, version2) {
      super();
      this.type = type;
      this.params = params;
      this.origin = origin2;
      this.version = version2;
      this.getRegistryType = () => RegistryType_12.RegistryTypes.QR_HARDWARE_CALL;
      this.getType = () => this.type;
      this.getParams = () => this.params;
      this.getOrigin = () => this.origin;
      this.getVersion = () => this.version;
      this.toDataItem = () => {
        const map = {};
        map[Keys2.type] = this.type;
        const param = this.params.toDataItem();
        param.setTag(this.params.getRegistryType().getTag());
        map[Keys2.params] = param;
        if (this.origin) {
          map[Keys2.origin] = this.origin;
        }
        if (this.version) {
          map[Keys2.version] = this.version;
        }
        return new lib_12.DataItem(map);
      };
    }
  }
  exports.QRHardwareCall = QRHardwareCall2;
  QRHardwareCall2.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const type = map[Keys2.type] || QRHardwareCallType.KeyDerivation;
    let params;
    switch (type) {
      case QRHardwareCallType.KeyDerivation:
        params = KeyDerivation_1.KeyDerivation.fromDataItem(map[Keys2.params]);
    }
    const origin2 = map[Keys2.origin];
    const version2 = map[Keys2.version];
    return new QRHardwareCall2(type, params, origin2, version2);
  };
  QRHardwareCall2.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_12.decodeToDataItem)(_cborPayload);
    return QRHardwareCall2.fromDataItem(dataItem);
  };
})(QRHardwareCall$1);
var types$4 = {};
Object.defineProperty(types$4, "__esModule", { value: true });
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$i;
  hasRequiredDist$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Buffer = exports.extend = exports.PathComponent = exports.ScriptExpressions = exports.MultiKey = exports.CryptoPSBT = exports.CryptoOutput = exports.CryptoECKey = exports.CryptoCoinInfoNetwork = exports.CryptoCoinInfoType = exports.CryptoCoinInfo = exports.CryptoKeypath = exports.CryptoMultiAccounts = exports.CryptoHDKey = exports.CryptoAccount = exports.Bytes = exports.URRegistryDecoder = exports.DataItem = void 0;
    const tslib_1 = require$$0$2;
    const buffer_12 = dist$h;
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return buffer_12.Buffer;
    } });
    const CryptoHDKey_12 = CryptoHDKey$3;
    Object.defineProperty(exports, "CryptoHDKey", { enumerable: true, get: function() {
      return CryptoHDKey_12.CryptoHDKey;
    } });
    const CryptoKeypath_12 = CryptoKeypath$3;
    Object.defineProperty(exports, "CryptoKeypath", { enumerable: true, get: function() {
      return CryptoKeypath_12.CryptoKeypath;
    } });
    const CryptoCoinInfo_12 = CryptoCoinInfo$1;
    Object.defineProperty(exports, "CryptoCoinInfo", { enumerable: true, get: function() {
      return CryptoCoinInfo_12.CryptoCoinInfo;
    } });
    Object.defineProperty(exports, "CryptoCoinInfoType", { enumerable: true, get: function() {
      return CryptoCoinInfo_12.Type;
    } });
    Object.defineProperty(exports, "CryptoCoinInfoNetwork", { enumerable: true, get: function() {
      return CryptoCoinInfo_12.Network;
    } });
    const CryptoECKey_12 = CryptoECKey$3;
    Object.defineProperty(exports, "CryptoECKey", { enumerable: true, get: function() {
      return CryptoECKey_12.CryptoECKey;
    } });
    const Bytes_1 = Bytes$4;
    Object.defineProperty(exports, "Bytes", { enumerable: true, get: function() {
      return Bytes_1.Bytes;
    } });
    const CryptoOutput_1 = CryptoOutput$3;
    Object.defineProperty(exports, "CryptoOutput", { enumerable: true, get: function() {
      return CryptoOutput_1.CryptoOutput;
    } });
    const CryptoPSBT_1 = CryptoPSBT$3;
    Object.defineProperty(exports, "CryptoPSBT", { enumerable: true, get: function() {
      return CryptoPSBT_1.CryptoPSBT;
    } });
    const CryptoAccount_1 = requireCryptoAccount$1();
    Object.defineProperty(exports, "CryptoAccount", { enumerable: true, get: function() {
      return CryptoAccount_1.CryptoAccount;
    } });
    const Decoder_1 = requireDecoder$1();
    Object.defineProperty(exports, "URRegistryDecoder", { enumerable: true, get: function() {
      return Decoder_1.URRegistryDecoder;
    } });
    const MultiKey_12 = MultiKey$3;
    Object.defineProperty(exports, "MultiKey", { enumerable: true, get: function() {
      return MultiKey_12.MultiKey;
    } });
    const ScriptExpression_12 = ScriptExpression$1;
    Object.defineProperty(exports, "ScriptExpressions", { enumerable: true, get: function() {
      return ScriptExpression_12.ScriptExpressions;
    } });
    const PathComponent_12 = PathComponent$3;
    Object.defineProperty(exports, "PathComponent", { enumerable: true, get: function() {
      return PathComponent_12.PathComponent;
    } });
    const RegistryItem_12 = RegistryItem$3;
    const RegistryType_12 = RegistryType$3;
    const lib_12 = lib$2;
    var lib_2 = lib$2;
    Object.defineProperty(exports, "DataItem", { enumerable: true, get: function() {
      return lib_2.DataItem;
    } });
    const utils_12 = utils$j;
    const CryptoMultiAccounts_1 = CryptoMultiAccounts$3;
    Object.defineProperty(exports, "CryptoMultiAccounts", { enumerable: true, get: function() {
      return CryptoMultiAccounts_1.CryptoMultiAccounts;
    } });
    const URlib = {
      URRegistryDecoder: Decoder_1.URRegistryDecoder,
      Bytes: Bytes_1.Bytes,
      CryptoAccount: CryptoAccount_1.CryptoAccount,
      CryptoHDKey: CryptoHDKey_12.CryptoHDKey,
      CryptoMultiAccounts: CryptoMultiAccounts_1.CryptoMultiAccounts,
      CryptoKeypath: CryptoKeypath_12.CryptoKeypath,
      CryptoCoinInfo: CryptoCoinInfo_12.CryptoCoinInfo,
      CryptoCoinInfoType: CryptoCoinInfo_12.Type,
      CryptoCoinInfoNetwork: CryptoCoinInfo_12.Network,
      CryptoECKey: CryptoECKey_12.CryptoECKey,
      CryptoOutput: CryptoOutput_1.CryptoOutput,
      CryptoPSBT: CryptoPSBT_1.CryptoPSBT,
      MultiKey: MultiKey_12.MultiKey,
      ScriptExpressions: ScriptExpression_12.ScriptExpressions,
      PathComponent: PathComponent_12.PathComponent
    };
    const cbor2 = {
      addReader: lib_12.addReader,
      addSemanticDecode: lib_12.addSemanticDecode,
      addSemanticEncode: lib_12.addSemanticEncode,
      addWriter: lib_12.addWriter,
      patchTags: utils_12.patchTags
    };
    const extend = {
      RegistryTypes: RegistryType_12.RegistryTypes,
      RegistryItem: RegistryItem_12.RegistryItem,
      RegistryType: RegistryType_12.RegistryType,
      decodeToDataItem: lib_12.decodeToDataItem,
      encodeDataItem: lib_12.encodeDataItem,
      cbor: cbor2
    };
    exports.extend = extend;
    (0, tslib_1.__exportStar)(errors$2, exports);
    (0, tslib_1.__exportStar)(requireDecoder$1(), exports);
    (0, tslib_1.__exportStar)(lib$2, exports);
    (0, tslib_1.__exportStar)(requireCryptoAccount$1(), exports);
    (0, tslib_1.__exportStar)(CryptoPSBT$3, exports);
    (0, tslib_1.__exportStar)(CryptoHDKey$3, exports);
    (0, tslib_1.__exportStar)(CryptoMultiAccounts$3, exports);
    (0, tslib_1.__exportStar)(QRHardwareCall$1, exports);
    (0, tslib_1.__exportStar)(KeyDerivation$3, exports);
    (0, tslib_1.__exportStar)(DerivationSchema$1, exports);
    (0, tslib_1.__exportStar)(CryptoOutput$3, exports);
    (0, tslib_1.__exportStar)(CryptoCoinInfo$1, exports);
    (0, tslib_1.__exportStar)(CryptoECKey$3, exports);
    (0, tslib_1.__exportStar)(MultiKey$3, exports);
    (0, tslib_1.__exportStar)(CryptoKeypath$3, exports);
    (0, tslib_1.__exportStar)(patchCBOR$1, exports);
    (0, tslib_1.__exportStar)(PathComponent$3, exports);
    (0, tslib_1.__exportStar)(RegistryItem$3, exports);
    (0, tslib_1.__exportStar)(RegistryType$3, exports);
    (0, tslib_1.__exportStar)(types$4, exports);
    (0, tslib_1.__exportStar)(utils$j, exports);
    exports.default = URlib;
  })(dist$i);
  return dist$i;
}
Object.defineProperty(crypto$3, "__esModule", { value: true });
crypto$3.pathToKeypath = void 0;
const bc_ur_registry_1$4 = requireDist$1();
const pathToKeypath = (path) => {
  const paths = path.replace(/[m|M]\//, "").split("/");
  const pathComponents = paths.map((path2) => {
    const index2 = parseInt(path2.replace("'", ""), 10);
    const isHardened = path2.endsWith("'");
    return new bc_ur_registry_1$4.PathComponent({ index: index2, hardened: isHardened });
  });
  return new bc_ur_registry_1$4.CryptoKeypath(pathComponents);
};
crypto$3.pathToKeypath = pathToKeypath;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(stringHelper, exports);
  __exportStar2(crypto$3, exports);
  __exportStar2(coin, exports);
})(utils$k);
var sdk$1 = {};
var chains = {};
var bitcoin = {};
var dist$f = { exports: {} };
var bcUrRegistryBtc_cjs_production_min = {};
var dist$e = {};
var patchCBOR = {};
var utils$h = {};
var lib$1 = {};
var cborSync = { exports: {} };
var DataItem$1 = {};
Object.defineProperty(DataItem$1, "__esModule", { value: true });
DataItem$1.DataItem = void 0;
class DataItem2 {
  constructor(data, tag) {
    this.setTag = (tag2) => {
      this.tag = tag2;
    };
    this.clearTag = () => {
      this.tag = void 0;
    };
    this.getTag = () => {
      return this.tag;
    };
    this.getData = () => {
      return this.data;
    };
    this.data = data;
    this.tag = tag;
  }
}
DataItem$1.DataItem = DataItem2;
(function(module) {
  (function(global, factory) {
    if (module.exports) {
      module.exports = factory();
    } else {
      global.CBOR = factory();
    }
  })(commonjsGlobal, function() {
    const { DataItem: DataItem3 } = DataItem$1;
    var CBOR = function() {
      function BinaryHex(hex) {
        this.$hex = hex;
      }
      BinaryHex.prototype = {
        length: function() {
          return this.$hex.length / 2;
        },
        toString: function(format) {
          if (!format || format === "hex" || format === 16)
            return this.$hex;
          if (format === "utf-8") {
            var encoded = "";
            for (var i = 0; i < this.$hex.length; i += 2) {
              encoded += "%" + this.$hex.substring(i, i + 2);
            }
            return decodeURIComponent(encoded);
          }
          if (format === "latin") {
            var encoded = [];
            for (var i = 0; i < this.$hex.length; i += 2) {
              encoded.push(parseInt(this.$hex.substring(i, i + 2), 16));
            }
            return String.fromCharCode.apply(String, encoded);
          }
          throw new Error("Unrecognised format: " + format);
        }
      };
      BinaryHex.fromLatinString = function(latinString) {
        var hex = "";
        for (var i = 0; i < latinString.length; i++) {
          var pair = latinString.charCodeAt(i).toString(16);
          if (pair.length === 1)
            pair = "0" + pair;
          hex += pair;
        }
        return new BinaryHex(hex);
      };
      BinaryHex.fromUtf8String = function(utf8String) {
        var encoded = encodeURIComponent(utf8String);
        var hex = "";
        for (var i = 0; i < encoded.length; i++) {
          if (encoded.charAt(i) === "%") {
            hex += encoded.substring(i + 1, i + 3);
            i += 2;
          } else {
            var hexPair = encoded.charCodeAt(i).toString(16);
            if (hexPair.length < 2)
              hexPair = "0" + hexPair;
            hex += hexPair;
          }
        }
        return new BinaryHex(hex);
      };
      var semanticEncoders = [];
      var semanticDecoders = {};
      var notImplemented = function(label) {
        return function() {
          throw new Error(label + " not implemented");
        };
      };
      function Reader() {
      }
      Reader.prototype = {
        peekByte: notImplemented("peekByte"),
        readByte: notImplemented("readByte"),
        readChunk: notImplemented("readChunk"),
        readFloat16: function() {
          var half = this.readUint16();
          var exponent = (half & 32767) >> 10;
          var mantissa = half & 1023;
          var negative = half & 32768;
          if (exponent === 31) {
            if (mantissa === 0) {
              return negative ? -Infinity : Infinity;
            }
            return NaN;
          }
          var magnitude = exponent ? Math.pow(2, exponent - 25) * (1024 + mantissa) : Math.pow(2, -24) * mantissa;
          return negative ? -magnitude : magnitude;
        },
        readFloat32: function() {
          var intValue = this.readUint32();
          var exponent = (intValue & 2147483647) >> 23;
          var mantissa = intValue & 8388607;
          var negative = intValue & 2147483648;
          if (exponent === 255) {
            if (mantissa === 0) {
              return negative ? -Infinity : Infinity;
            }
            return NaN;
          }
          var magnitude = exponent ? Math.pow(2, exponent - 23 - 127) * (8388608 + mantissa) : Math.pow(2, -23 - 126) * mantissa;
          return negative ? -magnitude : magnitude;
        },
        readFloat64: function() {
          var int1 = this.readUint32(), int2 = this.readUint32();
          var exponent = int1 >> 20 & 2047;
          var mantissa = (int1 & 1048575) * 4294967296 + int2;
          var negative = int1 & 2147483648;
          if (exponent === 2047) {
            if (mantissa === 0) {
              return negative ? -Infinity : Infinity;
            }
            return NaN;
          }
          var magnitude = exponent ? Math.pow(2, exponent - 52 - 1023) * (4503599627370496 + mantissa) : Math.pow(2, -52 - 1022) * mantissa;
          return negative ? -magnitude : magnitude;
        },
        readUint16: function() {
          return this.readByte() * 256 + this.readByte();
        },
        readUint32: function() {
          return this.readUint16() * 65536 + this.readUint16();
        },
        readUint64: function() {
          return this.readUint32() * 4294967296 + this.readUint32();
        }
      };
      function Writer() {
      }
      Writer.prototype = {
        writeByte: notImplemented("writeByte"),
        result: notImplemented("result"),
        writeFloat16: notImplemented("writeFloat16"),
        writeFloat32: notImplemented("writeFloat32"),
        writeFloat64: notImplemented("writeFloat64"),
        writeUint16: function(value) {
          this.writeByte(value >> 8 & 255);
          this.writeByte(value & 255);
        },
        writeUint32: function(value) {
          this.writeUint16(value >> 16 & 65535);
          this.writeUint16(value & 65535);
        },
        writeUint64: function(value) {
          if (value >= 9007199254740992 || value <= -9007199254740992) {
            throw new Error("Cannot encode Uint64 of: " + value + " magnitude to big (floating point errors)");
          }
          this.writeUint32(Math.floor(value / 4294967296));
          this.writeUint32(value % 4294967296);
        },
        writeString: notImplemented("writeString"),
        canWriteBinary: function(chunk) {
          return false;
        },
        writeBinary: notImplemented("writeChunk")
      };
      function readHeaderRaw(reader) {
        var firstByte = reader.readByte();
        var majorType = firstByte >> 5, value = firstByte & 31;
        return { type: majorType, value };
      }
      function valueFromHeader(header, reader) {
        var value = header.value;
        if (value < 24) {
          return value;
        } else if (value == 24) {
          return reader.readByte();
        } else if (value == 25) {
          return reader.readUint16();
        } else if (value == 26) {
          return reader.readUint32();
        } else if (value == 27) {
          return reader.readUint64();
        } else if (value == 31) {
          return null;
        }
        notImplemented("Additional info: " + value)();
      }
      function writeHeaderRaw(type, value, writer) {
        writer.writeByte(type << 5 | value);
      }
      function writeHeader(type, value, writer) {
        var firstByte = type << 5;
        if (value < 24) {
          writer.writeByte(firstByte | value);
        } else if (value < 256) {
          writer.writeByte(firstByte | 24);
          writer.writeByte(value);
        } else if (value < 65536) {
          writer.writeByte(firstByte | 25);
          writer.writeUint16(value);
        } else if (value < 4294967296) {
          writer.writeByte(firstByte | 26);
          writer.writeUint32(value);
        } else {
          writer.writeByte(firstByte | 27);
          writer.writeUint64(value);
        }
      }
      var stopCode = new Error();
      function decodeReader(reader) {
        var header = readHeaderRaw(reader);
        switch (header.type) {
          case 0:
            return valueFromHeader(header, reader);
          case 1:
            return -1 - valueFromHeader(header, reader);
          case 2:
            return reader.readChunk(valueFromHeader(header, reader));
          case 3:
            var buffer = reader.readChunk(valueFromHeader(header, reader));
            return buffer.toString("utf-8");
          case 4:
          case 5:
            var arrayLength = valueFromHeader(header, reader);
            var result = [];
            if (arrayLength !== null) {
              if (header.type === 5) {
                arrayLength *= 2;
              }
              for (var i = 0; i < arrayLength; i++) {
                result[i] = decodeReader(reader);
              }
            } else {
              var item;
              while ((item = decodeReader(reader)) !== stopCode) {
                result.push(item);
              }
            }
            if (header.type === 5) {
              var objResult = {};
              for (var i = 0; i < result.length; i += 2) {
                objResult[result[i]] = result[i + 1];
              }
              return objResult;
            } else {
              return result;
            }
          case 6:
            var tag = valueFromHeader(header, reader);
            var decoder = semanticDecoders[tag];
            var result = decodeReader(reader);
            return decoder ? decoder(result) : result;
          case 7:
            if (header.value === 25) {
              return reader.readFloat16();
            } else if (header.value === 26) {
              return reader.readFloat32();
            } else if (header.value === 27) {
              return reader.readFloat64();
            }
            switch (valueFromHeader(header, reader)) {
              case 20:
                return false;
              case 21:
                return true;
              case 22:
                return null;
              case 23:
                return void 0;
              case null:
                return stopCode;
              default:
                throw new Error("Unknown fixed value: " + header.value);
            }
          default:
            throw new Error("Unsupported header: " + JSON.stringify(header));
        }
        throw new Error("not implemented yet");
      }
      function encodeWriter(data, writer) {
        for (var i = 0; i < semanticEncoders.length; i++) {
          var replacement = semanticEncoders[i].fn(data);
          if (replacement !== void 0) {
            writeHeader(6, semanticEncoders[i].tag, writer);
            return encodeWriter(replacement, writer);
          }
        }
        if (data && typeof data.toCBOR === "function") {
          data = data.toCBOR();
        }
        if (data === false) {
          writeHeader(7, 20, writer);
        } else if (data === true) {
          writeHeader(7, 21, writer);
        } else if (data === null) {
          writeHeader(7, 22, writer);
        } else if (data === void 0) {
          writeHeader(7, 23, writer);
        } else if (typeof data === "number") {
          if (Math.floor(data) === data && data < 9007199254740992 && data > -9007199254740992) {
            if (data < 0) {
              writeHeader(1, -1 - data, writer);
            } else {
              writeHeader(0, data, writer);
            }
          } else {
            writeHeaderRaw(7, 27, writer);
            writer.writeFloat64(data);
          }
        } else if (typeof data === "string") {
          writer.writeString(data, function(length) {
            writeHeader(3, length, writer);
          });
        } else if (writer.canWriteBinary(data)) {
          writer.writeBinary(data, function(length) {
            writeHeader(2, length, writer);
          });
        } else if (typeof data === "object") {
          if (api.config.useToJSON && typeof data.toJSON === "function") {
            data = data.toJSON();
          }
          if (Array.isArray(data)) {
            writeHeader(4, data.length, writer);
            for (var i = 0; i < data.length; i++) {
              encodeWriter(data[i], writer);
            }
          } else {
            var keys2 = Object.keys(data);
            writeHeader(5, keys2.length, writer);
            for (var i = 0; i < keys2.length; i++) {
              const number2 = parseInt(keys2[i]);
              if (isNaN(number2)) {
                encodeWriter(keys2[i], writer);
                encodeWriter(data[keys2[i]], writer);
              } else {
                encodeWriter(number2, writer);
                encodeWriter(data[keys2[i]], writer);
              }
            }
          }
        } else {
          throw new Error("CBOR encoding not supported: " + data);
        }
      }
      var readerFunctions = [];
      var writerFunctions = [];
      var api = {
        config: {
          useToJSON: true
        },
        addWriter: function(format, writerFunction) {
          if (typeof format === "string") {
            writerFunctions.push(function(f2) {
              if (format === f2)
                return writerFunction(f2);
            });
          } else {
            writerFunctions.push(format);
          }
        },
        addReader: function(format, readerFunction) {
          if (typeof format === "string") {
            readerFunctions.push(function(data, f2) {
              if (format === f2)
                return readerFunction(data, f2);
            });
          } else {
            readerFunctions.push(format);
          }
        },
        encode: function(data, format) {
          for (var i = 0; i < writerFunctions.length; i++) {
            var func = writerFunctions[i];
            var writer = func(format);
            if (writer) {
              encodeWriter(data, writer);
              return writer.result();
            }
          }
          throw new Error("Unsupported output format: " + format);
        },
        encodeDataItem: function(data, format) {
          for (var i = 0; i < writerFunctions.length; i++) {
            var func = writerFunctions[i];
            var writer = func(format);
            if (writer) {
              if (data.getTag() !== void 0) {
                encodeWriter(data, writer);
                return writer.result();
              } else {
                encodeWriter(data.getData(), writer);
                return writer.result();
              }
            }
          }
          throw new Error("Unsupported output format: " + format);
        },
        decode: function(data, format) {
          for (var i = 0; i < readerFunctions.length; i++) {
            var func = readerFunctions[i];
            var reader = func(data, format);
            if (reader) {
              return decodeReader(reader);
            }
          }
          throw new Error("Unsupported input format: " + format);
        },
        decodeToDataItem: function(data, format) {
          for (var i = 0; i < readerFunctions.length; i++) {
            var func = readerFunctions[i];
            var reader = func(data, format);
            if (reader) {
              const result = decodeReader(reader);
              if (result instanceof DataItem3) {
                return result;
              } else {
                return new DataItem3(result);
              }
            }
          }
          throw new Error("Unsupported input format: " + format);
        },
        addSemanticEncode: function(tag, fn) {
          if (typeof tag !== "number" || tag % 1 !== 0 || tag < 0) {
            throw new Error("Tag must be a positive integer");
          }
          semanticEncoders.push({ tag, fn });
          return this;
        },
        addSemanticDecode: function(tag, fn) {
          if (typeof tag !== "number" || tag % 1 !== 0 || tag < 0) {
            throw new Error("Tag must be a positive integer");
          }
          semanticDecoders[tag] = fn;
          return this;
        }
      };
      function BufferReader(buffer) {
        this.buffer = buffer;
        this.pos = 0;
      }
      BufferReader.prototype = Object.create(Reader.prototype);
      BufferReader.prototype.peekByte = function() {
        return this.buffer[this.pos];
      };
      BufferReader.prototype.readByte = function() {
        return this.buffer[this.pos++];
      };
      BufferReader.prototype.readUint16 = function() {
        var result = this.buffer.readUInt16BE(this.pos);
        this.pos += 2;
        return result;
      };
      BufferReader.prototype.readUint32 = function() {
        var result = this.buffer.readUInt32BE(this.pos);
        this.pos += 4;
        return result;
      };
      BufferReader.prototype.readFloat32 = function() {
        var result = this.buffer.readFloatBE(this.pos);
        this.pos += 4;
        return result;
      };
      BufferReader.prototype.readFloat64 = function() {
        var result = this.buffer.readDoubleBE(this.pos);
        this.pos += 8;
        return result;
      };
      BufferReader.prototype.readChunk = function(length) {
        var result = Buffer$1$1.alloc(length);
        this.buffer.copy(result, 0, this.pos, this.pos += length);
        return result;
      };
      function BufferWriter(stringFormat) {
        this.byteLength = 0;
        this.defaultBufferLength = 16384;
        this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
        this.latestBufferOffset = 0;
        this.completeBuffers = [];
        this.stringFormat = stringFormat;
      }
      BufferWriter.prototype = Object.create(Writer.prototype);
      BufferWriter.prototype.writeByte = function(value) {
        this.latestBuffer[this.latestBufferOffset++] = value;
        if (this.latestBufferOffset >= this.latestBuffer.length) {
          this.completeBuffers.push(this.latestBuffer);
          this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
          this.latestBufferOffset = 0;
        }
        this.byteLength++;
      };
      BufferWriter.prototype.writeFloat32 = function(value) {
        var buffer = Buffer$1$1.alloc(4);
        buffer.writeFloatBE(value, 0);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.writeFloat64 = function(value) {
        var buffer = Buffer$1$1.alloc(8);
        buffer.writeDoubleBE(value, 0);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.writeString = function(string, lengthFunc) {
        var buffer = Buffer$1$1.from(string, "utf-8");
        lengthFunc(buffer.length);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.canWriteBinary = function(data) {
        return data instanceof Buffer$1$1;
      };
      BufferWriter.prototype.writeBinary = function(buffer, lengthFunc) {
        lengthFunc(buffer.length);
        this.writeBuffer(buffer);
      };
      BufferWriter.prototype.writeBuffer = function(chunk) {
        if (!(chunk instanceof Buffer$1$1))
          throw new TypeError("BufferWriter only accepts Buffers");
        if (!this.latestBufferOffset) {
          this.completeBuffers.push(chunk);
        } else if (this.latestBuffer.length - this.latestBufferOffset >= chunk.length) {
          chunk.copy(this.latestBuffer, this.latestBufferOffset);
          this.latestBufferOffset += chunk.length;
          if (this.latestBufferOffset >= this.latestBuffer.length) {
            this.completeBuffers.push(this.latestBuffer);
            this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
            this.latestBufferOffset = 0;
          }
        } else {
          this.completeBuffers.push(this.latestBuffer.slice(0, this.latestBufferOffset));
          this.completeBuffers.push(chunk);
          this.latestBuffer = Buffer$1$1.alloc(this.defaultBufferLength);
          this.latestBufferOffset = 0;
        }
        this.byteLength += chunk.length;
      };
      BufferWriter.prototype.result = function() {
        var result = Buffer$1$1.alloc(this.byteLength);
        var offset = 0;
        for (var i = 0; i < this.completeBuffers.length; i++) {
          var buffer = this.completeBuffers[i];
          buffer.copy(result, offset, 0, buffer.length);
          offset += buffer.length;
        }
        if (this.latestBufferOffset) {
          this.latestBuffer.copy(result, offset, 0, this.latestBufferOffset);
        }
        if (this.stringFormat)
          return result.toString(this.stringFormat);
        return result;
      };
      if (typeof Buffer$1$1 === "function") {
        api.addReader(function(data, format) {
          if (Buffer$1$1.isBuffer(data)) {
            return new BufferReader(data);
          }
          if (format === "hex" || format === "base64") {
            var buffer = Buffer$1$1.from(data, format);
            return new BufferReader(buffer);
          }
        });
        api.addWriter(function(format) {
          if (!format || format === "buffer") {
            return new BufferWriter();
          } else if (format === "hex" || format === "base64") {
            return new BufferWriter(format);
          }
        });
      }
      function HexReader(hex) {
        this.hex = hex;
        this.pos = 0;
      }
      HexReader.prototype = Object.create(Reader.prototype);
      HexReader.prototype.peekByte = function() {
        var pair = this.hex.substring(this.pos, 2);
        return parseInt(pair, 16);
      };
      HexReader.prototype.readByte = function() {
        var pair = this.hex.substring(this.pos, this.pos + 2);
        this.pos += 2;
        return parseInt(pair, 16);
      };
      HexReader.prototype.readChunk = function(length) {
        var hex = this.hex.substring(this.pos, this.pos + length * 2);
        this.pos += length * 2;
        if (typeof Buffer$1$1 === "function")
          return Buffer$1$1.from(hex, "hex");
        return new BinaryHex(hex);
      };
      function HexWriter(finalFormat) {
        this.$hex = "";
        this.finalFormat = finalFormat || "hex";
      }
      HexWriter.prototype = Object.create(Writer.prototype);
      HexWriter.prototype.writeByte = function(value) {
        if (value < 0 || value > 255)
          throw new Error("Byte value out of range: " + value);
        var hex = value.toString(16);
        if (hex.length == 1) {
          hex = "0" + hex;
        }
        this.$hex += hex;
      };
      HexWriter.prototype.canWriteBinary = function(chunk) {
        return chunk instanceof BinaryHex || typeof Buffer$1$1 === "function" && chunk instanceof Buffer$1$1;
      };
      HexWriter.prototype.writeBinary = function(chunk, lengthFunction) {
        if (chunk instanceof BinaryHex) {
          lengthFunction(chunk.length());
          this.$hex += chunk.$hex;
        } else if (typeof Buffer$1$1 === "function" && chunk instanceof Buffer$1$1) {
          lengthFunction(chunk.length);
          this.$hex += chunk.toString("hex");
        } else {
          throw new TypeError("HexWriter only accepts BinaryHex or Buffers");
        }
      };
      HexWriter.prototype.result = function() {
        if (this.finalFormat === "buffer" && typeof Buffer$1$1 === "function") {
          return Buffer$1$1.from(this.$hex, "hex");
        }
        return new BinaryHex(this.$hex).toString(this.finalFormat);
      };
      HexWriter.prototype.writeString = function(string, lengthFunction) {
        var buffer = BinaryHex.fromUtf8String(string);
        lengthFunction(buffer.length());
        this.$hex += buffer.$hex;
      };
      api.addReader(function(data, format) {
        if (data instanceof BinaryHex || data.$hex) {
          return new HexReader(data.$hex);
        }
        if (format === "hex") {
          return new HexReader(data);
        }
      });
      api.addWriter(function(format) {
        if (format === "hex") {
          return new HexWriter();
        }
      });
      return api;
    }();
    CBOR.addSemanticEncode(0, function(data) {
      if (data instanceof Date) {
        return data.toISOString();
      }
    }).addSemanticDecode(0, function(isoString) {
      return new Date(isoString);
    }).addSemanticDecode(1, function(isoString) {
      return new Date(isoString);
    });
    return CBOR;
  });
})(cborSync);
var cborSyncExports = cborSync.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DataItem = exports.addWriter = exports.addReader = exports.addSemanticEncode = exports.addSemanticDecode = exports.decodeToDataItem = exports.encodeDataItem = void 0;
  var cbor_sync_1 = cborSyncExports;
  Object.defineProperty(exports, "encodeDataItem", { enumerable: true, get: function() {
    return cbor_sync_1.encodeDataItem;
  } });
  Object.defineProperty(exports, "decodeToDataItem", { enumerable: true, get: function() {
    return cbor_sync_1.decodeToDataItem;
  } });
  Object.defineProperty(exports, "addSemanticDecode", { enumerable: true, get: function() {
    return cbor_sync_1.addSemanticDecode;
  } });
  Object.defineProperty(exports, "addSemanticEncode", { enumerable: true, get: function() {
    return cbor_sync_1.addSemanticEncode;
  } });
  Object.defineProperty(exports, "addReader", { enumerable: true, get: function() {
    return cbor_sync_1.addReader;
  } });
  Object.defineProperty(exports, "addWriter", { enumerable: true, get: function() {
    return cbor_sync_1.addWriter;
  } });
  var DataItem_12 = DataItem$1;
  Object.defineProperty(exports, "DataItem", { enumerable: true, get: function() {
    return DataItem_12.DataItem;
  } });
})(lib$1);
Object.defineProperty(utils$h, "__esModule", { value: true });
utils$h.patchTags = void 0;
const lib_1$9 = lib$1;
const alreadyPatchedTag = [];
const patchTags = (tags) => {
  tags.forEach((tag) => {
    if (alreadyPatchedTag.find((i) => i === tag))
      return;
    (0, lib_1$9.addSemanticEncode)(tag, (data) => {
      if (data instanceof lib_1$9.DataItem) {
        if (data.getTag() === tag) {
          return data.getData();
        }
      }
    });
    (0, lib_1$9.addSemanticDecode)(tag, (data) => {
      return new lib_1$9.DataItem(data, tag);
    });
    alreadyPatchedTag.push(tag);
  });
};
utils$h.patchTags = patchTags;
var RegistryType$1 = {};
Object.defineProperty(RegistryType$1, "__esModule", { value: true });
RegistryType$1.RegistryTypes = RegistryType$1.RegistryType = void 0;
class RegistryType2 {
  constructor(type, tag) {
    this.type = type;
    this.tag = tag;
    this.getTag = () => this.tag;
    this.getType = () => this.type;
  }
}
RegistryType$1.RegistryType = RegistryType2;
RegistryType$1.RegistryTypes = {
  UUID: new RegistryType2("uuid", 37),
  BYTES: new RegistryType2("bytes", void 0),
  CRYPTO_HDKEY: new RegistryType2("crypto-hdkey", 303),
  CRYPTO_KEYPATH: new RegistryType2("crypto-keypath", 304),
  CRYPTO_COIN_INFO: new RegistryType2("crypto-coin-info", 305),
  CRYPTO_ECKEY: new RegistryType2("crypto-eckey", 306),
  CRYPTO_OUTPUT: new RegistryType2("crypto-output", 308),
  CRYPTO_PSBT: new RegistryType2("crypto-psbt", 310),
  CRYPTO_ACCOUNT: new RegistryType2("crypto-account", 311),
  CRYPTO_MULTI_ACCOUNTS: new RegistryType2("crypto-multi-accounts", 1103),
  QR_HARDWARE_CALL: new RegistryType2("qr-hardware-call", 1201),
  KEY_DERIVATION_CALL: new RegistryType2("key-derivation-call", 1301),
  KEY_DERIVATION_SCHEMA: new RegistryType2("key-derivation-schema", 1302)
};
var ScriptExpression = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ScriptExpressions = exports.ScriptExpression = void 0;
  class ScriptExpression2 {
    constructor(tag, expression) {
      this.tag = tag;
      this.expression = expression;
      this.getTag = () => this.tag;
      this.getExpression = () => this.expression;
    }
  }
  exports.ScriptExpression = ScriptExpression2;
  ScriptExpression2.fromTag = (tag) => {
    const se = Object.values(exports.ScriptExpressions).find((se2) => se2.getTag() === tag);
    return se;
  };
  exports.ScriptExpressions = {
    SCRIPT_HASH: new ScriptExpression2(400, "sh"),
    WITNESS_SCRIPT_HASH: new ScriptExpression2(401, "wsh"),
    PUBLIC_KEY: new ScriptExpression2(402, "pk"),
    PUBLIC_KEY_HASH: new ScriptExpression2(403, "pkh"),
    WITNESS_PUBLIC_KEY_HASH: new ScriptExpression2(404, "wpkh"),
    COMBO: new ScriptExpression2(405, "combo"),
    MULTISIG: new ScriptExpression2(406, "multi"),
    SORTED_MULTISIG: new ScriptExpression2(407, "sortedmulti"),
    ADDRESS: new ScriptExpression2(307, "addr"),
    RAW_SCRIPT: new ScriptExpression2(408, "raw")
  };
})(ScriptExpression);
Object.defineProperty(patchCBOR, "__esModule", { value: true });
const utils_1$k = utils$h;
const RegistryType_1$9 = RegistryType$1;
const ScriptExpression_1$1 = ScriptExpression;
const registryTags = Object.values(RegistryType_1$9.RegistryTypes).filter((r) => !!r.getTag()).map((r) => r.getTag());
const scriptExpressionTags = Object.values(ScriptExpression_1$1.ScriptExpressions).map((se) => se.getTag());
(0, utils_1$k.patchTags)(registryTags.concat(scriptExpressionTags));
var CryptoHDKey$1 = {};
var basex$2 = src$1;
var ALPHABET$2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58$2 = basex$2(ALPHABET$2);
var base58$2 = bs58$2;
var Buffer$2 = safeBufferExports.Buffer;
var base$4 = function(checksumFn) {
  function encode3(payload) {
    var checksum = checksumFn(payload);
    return base58$2.encode(Buffer$2.concat([
      payload,
      checksum
    ], payload.length + 4));
  }
  function decodeRaw(buffer) {
    var payload = buffer.slice(0, -4);
    var checksum = buffer.slice(-4);
    var newChecksum = checksumFn(payload);
    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
    return payload;
  }
  function decodeUnsafe(string) {
    var buffer = base58$2.decodeUnsafe(string);
    if (!buffer) return;
    return decodeRaw(buffer);
  }
  function decode2(string) {
    var buffer = base58$2.decode(string);
    var payload = decodeRaw(buffer);
    if (!payload) throw new Error("Invalid checksum");
    return payload;
  }
  return {
    encode: encode3,
    decode: decode2,
    decodeUnsafe
  };
};
var createHash$3 = browser;
var bs58checkBase$2 = base$4;
function sha256x2$2(buffer) {
  var tmp = createHash$3("sha256").update(buffer).digest();
  return createHash$3("sha256").update(tmp).digest();
}
var bs58check$3 = bs58checkBase$2(sha256x2$2);
var CryptoCoinInfo = {};
var RegistryItem$1 = {};
Object.defineProperty(RegistryItem$1, "__esModule", { value: true });
RegistryItem$1.RegistryItem = void 0;
const bc_ur_1$1 = dist$g;
const lib_1$8 = lib$1;
class RegistryItem2 {
  constructor() {
    this.toCBOR = () => {
      if (this.toDataItem() === void 0) {
        throw new Error(`#[ur-registry][RegistryItem][fn.toCBOR]: registry ${this.getRegistryType()}'s method toDataItem returns undefined`);
      }
      return (0, lib_1$8.encodeDataItem)(this.toDataItem());
    };
    this.toUR = () => {
      return new bc_ur_1$1.UR(this.toCBOR(), this.getRegistryType().getType());
    };
    this.toUREncoder = (maxFragmentLength, firstSeqNum, minFragmentLength) => {
      const ur2 = this.toUR();
      const urEncoder2 = new bc_ur_1$1.UREncoder(ur2, maxFragmentLength, firstSeqNum, minFragmentLength);
      return urEncoder2;
    };
  }
}
RegistryItem$1.RegistryItem = RegistryItem2;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CryptoCoinInfo = exports.Network = exports.Type = void 0;
  const lib_12 = lib$1;
  const RegistryItem_12 = RegistryItem$1;
  const RegistryType_12 = RegistryType$1;
  var Keys2;
  (function(Keys3) {
    Keys3["type"] = "1";
    Keys3["network"] = "2";
  })(Keys2 || (Keys2 = {}));
  var Type2;
  (function(Type3) {
    Type3[Type3["bitcoin"] = 0] = "bitcoin";
  })(Type2 = exports.Type || (exports.Type = {}));
  var Network;
  (function(Network2) {
    Network2[Network2["mainnet"] = 0] = "mainnet";
    Network2[Network2["testnet"] = 1] = "testnet";
  })(Network = exports.Network || (exports.Network = {}));
  class CryptoCoinInfo2 extends RegistryItem_12.RegistryItem {
    constructor(type, network) {
      super();
      this.type = type;
      this.network = network;
      this.getRegistryType = () => {
        return RegistryType_12.RegistryTypes.CRYPTO_COIN_INFO;
      };
      this.getType = () => {
        return this.type || Type2.bitcoin;
      };
      this.getNetwork = () => {
        return this.network || Network.mainnet;
      };
      this.toDataItem = () => {
        const map = {};
        if (this.type) {
          map[Keys2.type] = this.type;
        }
        if (this.network) {
          map[Keys2.network] = this.network;
        }
        return new lib_12.DataItem(map);
      };
    }
  }
  exports.CryptoCoinInfo = CryptoCoinInfo2;
  CryptoCoinInfo2.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const type = map[Keys2.type];
    const network = map[Keys2.network];
    return new CryptoCoinInfo2(type, network);
  };
  CryptoCoinInfo2.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_12.decodeToDataItem)(_cborPayload);
    return CryptoCoinInfo2.fromDataItem(dataItem);
  };
})(CryptoCoinInfo);
var CryptoKeypath$1 = {};
var PathComponent$1 = {};
Object.defineProperty(PathComponent$1, "__esModule", { value: true });
PathComponent$1.PathComponent = void 0;
class PathComponent2 {
  constructor(args) {
    this.getIndex = () => this.index;
    this.isWildcard = () => this.wildcard;
    this.isHardened = () => this.hardened;
    this.index = args.index;
    this.hardened = args.hardened;
    if (this.index !== void 0) {
      this.wildcard = false;
    } else {
      this.wildcard = true;
    }
    if (this.index && (this.index & PathComponent2.HARDENED_BIT) !== 0) {
      throw new Error(`#[ur-registry][PathComponent][fn.constructor]: Invalid index ${this.index} - most significant bit cannot be set`);
    }
  }
}
PathComponent$1.PathComponent = PathComponent2;
PathComponent2.HARDENED_BIT = 2147483648;
Object.defineProperty(CryptoKeypath$1, "__esModule", { value: true });
CryptoKeypath$1.CryptoKeypath = void 0;
const lib_1$7 = lib$1;
const PathComponent_1 = PathComponent$1;
const RegistryItem_1$8 = RegistryItem$1;
const RegistryType_1$8 = RegistryType$1;
var Keys$5;
(function(Keys2) {
  Keys2[Keys2["components"] = 1] = "components";
  Keys2[Keys2["source_fingerprint"] = 2] = "source_fingerprint";
  Keys2[Keys2["depth"] = 3] = "depth";
})(Keys$5 || (Keys$5 = {}));
class CryptoKeypath2 extends RegistryItem_1$8.RegistryItem {
  constructor(components = [], sourceFingerprint, depth) {
    super();
    this.components = components;
    this.sourceFingerprint = sourceFingerprint;
    this.depth = depth;
    this.getRegistryType = () => {
      return RegistryType_1$8.RegistryTypes.CRYPTO_KEYPATH;
    };
    this.getPath = () => {
      if (this.components.length === 0) {
        return void 0;
      }
      const components2 = this.components.map((component) => {
        return `${component.isWildcard() ? "*" : component.getIndex()}${component.isHardened() ? "'" : ""}`;
      });
      return components2.join("/");
    };
    this.getComponents = () => this.components;
    this.getSourceFingerprint = () => this.sourceFingerprint;
    this.getDepth = () => this.depth;
    this.toDataItem = () => {
      const map = {};
      const components2 = [];
      this.components && this.components.forEach((component) => {
        if (component.isWildcard()) {
          components2.push([]);
        } else {
          components2.push(component.getIndex());
        }
        components2.push(component.isHardened());
      });
      map[Keys$5.components] = components2;
      if (this.sourceFingerprint) {
        map[Keys$5.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);
      }
      if (this.depth !== void 0) {
        map[Keys$5.depth] = this.depth;
      }
      return new lib_1$7.DataItem(map);
    };
  }
}
CryptoKeypath$1.CryptoKeypath = CryptoKeypath2;
CryptoKeypath2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const pathComponents = [];
  const components = map[Keys$5.components];
  if (components) {
    for (let i = 0; i < components.length; i += 2) {
      const isHardened = components[i + 1];
      const path = components[i];
      if (typeof path === "number") {
        pathComponents.push(new PathComponent_1.PathComponent({ index: path, hardened: isHardened }));
      } else {
        pathComponents.push(new PathComponent_1.PathComponent({ hardened: isHardened }));
      }
    }
  }
  const _sourceFingerprint = map[Keys$5.source_fingerprint];
  let sourceFingerprint;
  if (_sourceFingerprint) {
    sourceFingerprint = Buffer$1$1.alloc(4);
    sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);
  }
  const depth = map[Keys$5.depth];
  return new CryptoKeypath2(pathComponents, sourceFingerprint, depth);
};
CryptoKeypath2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$7.decodeToDataItem)(_cborPayload);
  return CryptoKeypath2.fromDataItem(dataItem);
};
Object.defineProperty(CryptoHDKey$1, "__esModule", { value: true });
CryptoHDKey$1.CryptoHDKey = void 0;
const bs58check_1$1 = bs58check$3;
const CryptoCoinInfo_1 = CryptoCoinInfo;
const CryptoKeypath_1 = CryptoKeypath$1;
const lib_1$6 = lib$1;
const RegistryItem_1$7 = RegistryItem$1;
const RegistryType_1$7 = RegistryType$1;
var Keys$4;
(function(Keys2) {
  Keys2[Keys2["is_master"] = 1] = "is_master";
  Keys2[Keys2["is_private"] = 2] = "is_private";
  Keys2[Keys2["key_data"] = 3] = "key_data";
  Keys2[Keys2["chain_code"] = 4] = "chain_code";
  Keys2[Keys2["use_info"] = 5] = "use_info";
  Keys2[Keys2["origin"] = 6] = "origin";
  Keys2[Keys2["children"] = 7] = "children";
  Keys2[Keys2["parent_fingerprint"] = 8] = "parent_fingerprint";
  Keys2[Keys2["name"] = 9] = "name";
  Keys2[Keys2["note"] = 10] = "note";
})(Keys$4 || (Keys$4 = {}));
class CryptoHDKey2 extends RegistryItem_1$7.RegistryItem {
  constructor(args) {
    super();
    this.isECKey = () => {
      return false;
    };
    this.getKey = () => this.key;
    this.getChainCode = () => this.chainCode;
    this.isMaster = () => this.master;
    this.isPrivateKey = () => !!this.privateKey;
    this.getUseInfo = () => this.useInfo;
    this.getOrigin = () => this.origin;
    this.getChildren = () => this.children;
    this.getParentFingerprint = () => this.parentFingerprint;
    this.getName = () => this.name;
    this.getNote = () => this.note;
    this.getBip32Key = () => {
      var _a, _b, _c;
      let version2;
      let depth;
      let index2 = 0;
      let parentFingerprint = Buffer$1$1.alloc(4).fill(0);
      if (this.isMaster()) {
        version2 = Buffer$1$1.from("0488ADE4", "hex");
        depth = 0;
        index2 = 0;
      } else {
        depth = ((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getComponents().length) || ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getDepth());
        const paths = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getComponents();
        const lastPath = paths[paths.length - 1];
        if (lastPath) {
          index2 = lastPath.isHardened() ? lastPath.getIndex() + 2147483648 : lastPath.getIndex();
          if (this.getParentFingerprint()) {
            parentFingerprint = this.getParentFingerprint();
          }
        }
        if (this.isPrivateKey()) {
          version2 = Buffer$1$1.from("0488ADE4", "hex");
        } else {
          version2 = Buffer$1$1.from("0488B21E", "hex");
        }
      }
      const depthBuffer = Buffer$1$1.alloc(1);
      depthBuffer.writeUInt8(depth, 0);
      const indexBuffer = Buffer$1$1.alloc(4);
      indexBuffer.writeUInt32BE(index2, 0);
      const chainCode = this.getChainCode();
      const key2 = this.getKey();
      return (0, bs58check_1$1.encode)(Buffer$1$1.concat([version2, depthBuffer, parentFingerprint, indexBuffer, chainCode, key2]));
    };
    this.getRegistryType = () => {
      return RegistryType_1$7.RegistryTypes.CRYPTO_HDKEY;
    };
    this.getOutputDescriptorContent = () => {
      var _a, _b, _c, _d, _e, _f, _g;
      let result = "";
      if (this.getOrigin()) {
        if (((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getSourceFingerprint()) && ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getPath())) {
          result += `${(_d = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getSourceFingerprint()) === null || _d === void 0 ? void 0 : _d.toString("hex")}/${(_e = this.getOrigin()) === null || _e === void 0 ? void 0 : _e.getPath()}`;
        }
      }
      result += this.getBip32Key();
      if (this.getChildren()) {
        if ((_f = this.getChildren()) === null || _f === void 0 ? void 0 : _f.getPath()) {
          result += `/${(_g = this.getChildren()) === null || _g === void 0 ? void 0 : _g.getPath()}`;
        }
      }
      return result;
    };
    this.setupMasterKey = (args2) => {
      this.master = true;
      this.key = args2.key;
      this.chainCode = args2.chainCode;
    };
    this.setupDeriveKey = (args2) => {
      this.master = false;
      this.privateKey = args2.isPrivateKey;
      this.key = args2.key;
      this.chainCode = args2.chainCode;
      this.useInfo = args2.useInfo;
      this.origin = args2.origin;
      this.children = args2.children;
      this.parentFingerprint = args2.parentFingerprint;
      this.name = args2.name;
      this.note = args2.note;
    };
    this.toDataItem = () => {
      const map = {};
      if (this.master) {
        map[Keys$4.is_master] = true;
        map[Keys$4.key_data] = this.key;
        map[Keys$4.chain_code] = this.chainCode;
      } else {
        if (this.privateKey !== void 0) {
          map[Keys$4.is_private] = this.privateKey;
        }
        map[Keys$4.key_data] = this.key;
        if (this.chainCode) {
          map[Keys$4.chain_code] = this.chainCode;
        }
        if (this.useInfo) {
          const useInfo = this.useInfo.toDataItem();
          useInfo.setTag(this.useInfo.getRegistryType().getTag());
          map[Keys$4.use_info] = useInfo;
        }
        if (this.origin) {
          const origin2 = this.origin.toDataItem();
          origin2.setTag(this.origin.getRegistryType().getTag());
          map[Keys$4.origin] = origin2;
        }
        if (this.children) {
          const children = this.children.toDataItem();
          children.setTag(this.children.getRegistryType().getTag());
          map[Keys$4.children] = children;
        }
        if (this.parentFingerprint) {
          map[Keys$4.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);
        }
        if (this.name !== void 0) {
          map[Keys$4.name] = this.name;
        }
        if (this.note !== void 0) {
          map[Keys$4.note] = this.note;
        }
      }
      return new lib_1$6.DataItem(map);
    };
    if (args.isMaster) {
      this.setupMasterKey(args);
    } else {
      this.setupDeriveKey(args);
    }
  }
}
CryptoHDKey$1.CryptoHDKey = CryptoHDKey2;
CryptoHDKey2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const isMaster = !!map[Keys$4.is_master];
  const isPrivateKey = map[Keys$4.is_private];
  const key2 = map[Keys$4.key_data];
  const chainCode = map[Keys$4.chain_code];
  const useInfo = map[Keys$4.use_info] ? CryptoCoinInfo_1.CryptoCoinInfo.fromDataItem(map[Keys$4.use_info]) : void 0;
  const origin2 = map[Keys$4.origin] ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys$4.origin]) : void 0;
  const children = map[Keys$4.children] ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys$4.children]) : void 0;
  const _parentFingerprint = map[Keys$4.parent_fingerprint];
  let parentFingerprint = void 0;
  if (_parentFingerprint) {
    parentFingerprint = Buffer$1$1.alloc(4);
    parentFingerprint.writeUInt32BE(_parentFingerprint, 0);
  }
  const name2 = map[Keys$4.name];
  const note = map[Keys$4.note];
  return new CryptoHDKey2({
    isMaster,
    isPrivateKey,
    key: key2,
    chainCode,
    useInfo,
    origin: origin2,
    children,
    parentFingerprint,
    name: name2,
    note
  });
};
CryptoHDKey2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$6.decodeToDataItem)(_cborPayload);
  return CryptoHDKey2.fromDataItem(dataItem);
};
var CryptoECKey$1 = {};
Object.defineProperty(CryptoECKey$1, "__esModule", { value: true });
CryptoECKey$1.CryptoECKey = void 0;
const lib_1$5 = lib$1;
const RegistryItem_1$6 = RegistryItem$1;
const RegistryType_1$6 = RegistryType$1;
var Keys$3;
(function(Keys2) {
  Keys2[Keys2["curve"] = 1] = "curve";
  Keys2[Keys2["private"] = 2] = "private";
  Keys2[Keys2["data"] = 3] = "data";
})(Keys$3 || (Keys$3 = {}));
class CryptoECKey2 extends RegistryItem_1$6.RegistryItem {
  constructor(args) {
    super();
    this.isECKey = () => {
      return true;
    };
    this.getCurve = () => this.curve || 0;
    this.isPrivateKey = () => this.privateKey || false;
    this.getData = () => this.data;
    this.getRegistryType = () => {
      return RegistryType_1$6.RegistryTypes.CRYPTO_ECKEY;
    };
    this.toDataItem = () => {
      const map = {};
      if (this.curve) {
        map[Keys$3.curve] = this.curve;
      }
      if (this.privateKey !== void 0) {
        map[Keys$3.private] = this.privateKey;
      }
      map[Keys$3.data] = this.data;
      return new lib_1$5.DataItem(map);
    };
    this.getOutputDescriptorContent = () => {
      return this.data.toString("hex");
    };
    this.data = args.data;
    this.curve = args.curve;
    this.privateKey = args.privateKey || void 0;
  }
}
CryptoECKey$1.CryptoECKey = CryptoECKey2;
CryptoECKey2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const curve2 = map[Keys$3.curve];
  const privateKey = map[Keys$3.private];
  const data = map[Keys$3.data];
  if (!data) {
    throw new Error(`#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${dataItem}`);
  }
  return new CryptoECKey2({ data, curve: curve2, privateKey });
};
CryptoECKey2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$5.decodeToDataItem)(_cborPayload);
  return CryptoECKey2.fromDataItem(dataItem);
};
var Bytes$2 = {};
Object.defineProperty(Bytes$2, "__esModule", { value: true });
Bytes$2.Bytes = void 0;
const lib_1$4 = lib$1;
const RegistryItem_1$5 = RegistryItem$1;
const RegistryType_1$5 = RegistryType$1;
let Bytes$1 = class Bytes2 extends RegistryItem_1$5.RegistryItem {
  constructor(bytes2) {
    super();
    this.bytes = bytes2;
    this.getRegistryType = () => {
      return RegistryType_1$5.RegistryTypes.BYTES;
    };
    this.getData = () => this.bytes;
    this.toDataItem = () => {
      return new lib_1$4.DataItem(this.bytes);
    };
  }
};
Bytes$2.Bytes = Bytes$1;
Bytes$1.fromDataItem = (dataItem) => {
  const bytes2 = dataItem.getData();
  if (!bytes2) {
    throw new Error(`#[ur-registry][Bytes][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
  }
  return new Bytes$1(bytes2);
};
Bytes$1.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$4.decodeToDataItem)(_cborPayload);
  return Bytes$1.fromDataItem(dataItem);
};
var CryptoOutput$1 = {};
var MultiKey$1 = {};
Object.defineProperty(MultiKey$1, "__esModule", { value: true });
MultiKey$1.MultiKey = void 0;
const CryptoECKey_1$1 = CryptoECKey$1;
const CryptoHDKey_1$2 = CryptoHDKey$1;
const DataItem_1 = DataItem$1;
const RegistryItem_1$4 = RegistryItem$1;
const RegistryType_1$4 = RegistryType$1;
var Keys$2;
(function(Keys2) {
  Keys2[Keys2["threshold"] = 1] = "threshold";
  Keys2[Keys2["keys"] = 2] = "keys";
})(Keys$2 || (Keys$2 = {}));
class MultiKey2 extends RegistryItem_1$4.RegistryItem {
  constructor(threshold, keys2) {
    super();
    this.threshold = threshold;
    this.keys = keys2;
    this.getThreshold = () => this.threshold;
    this.getKeys = () => this.keys;
    this.toDataItem = () => {
      const map = {};
      map[Keys$2.threshold] = this.threshold;
      const keys3 = this.keys.map((k) => {
        const dataItem = k.toDataItem();
        dataItem.setTag(k.getRegistryType().getTag());
        return dataItem;
      });
      map[Keys$2.keys] = keys3;
      return new DataItem_1.DataItem(map);
    };
    this.getOutputDescriptorContent = () => {
      return [
        this.getThreshold(),
        this.keys.map((k) => k.getOutputDescriptorContent()).join(",")
      ].join(",");
    };
  }
}
MultiKey$1.MultiKey = MultiKey2;
MultiKey2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const threshold = map[Keys$2.threshold];
  const _keys = map[Keys$2.keys];
  const keys2 = [];
  _keys.forEach((k) => {
    if (k.getTag() === RegistryType_1$4.RegistryTypes.CRYPTO_HDKEY.getTag()) {
      keys2.push(CryptoHDKey_1$2.CryptoHDKey.fromDataItem(k));
    } else if (k.getTag() === RegistryType_1$4.RegistryTypes.CRYPTO_ECKEY.getTag()) {
      keys2.push(CryptoECKey_1$1.CryptoECKey.fromDataItem(k));
    }
  });
  return new MultiKey2(threshold, keys2);
};
Object.defineProperty(CryptoOutput$1, "__esModule", { value: true });
CryptoOutput$1.CryptoOutput = void 0;
const CryptoECKey_1 = CryptoECKey$1;
const CryptoHDKey_1$1 = CryptoHDKey$1;
const lib_1$3 = lib$1;
const MultiKey_1 = MultiKey$1;
const RegistryItem_1$3 = RegistryItem$1;
const RegistryType_1$3 = RegistryType$1;
const ScriptExpression_1 = ScriptExpression;
class CryptoOutput2 extends RegistryItem_1$3.RegistryItem {
  constructor(scriptExpressions, cryptoKey) {
    super();
    this.scriptExpressions = scriptExpressions;
    this.cryptoKey = cryptoKey;
    this.getRegistryType = () => {
      return RegistryType_1$3.RegistryTypes.CRYPTO_OUTPUT;
    };
    this.getCryptoKey = () => this.cryptoKey;
    this.getHDKey = () => {
      if (this.cryptoKey instanceof CryptoHDKey_1$1.CryptoHDKey) {
        return this.cryptoKey;
      } else {
        return void 0;
      }
    };
    this.getECKey = () => {
      if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey) {
        return this.cryptoKey;
      } else {
        return void 0;
      }
    };
    this.getMultiKey = () => {
      if (this.cryptoKey instanceof MultiKey_1.MultiKey) {
        return this.cryptoKey;
      } else {
        return void 0;
      }
    };
    this.getScriptExpressions = () => this.scriptExpressions;
    this._toOutputDescriptor = (seIndex) => {
      if (seIndex >= this.scriptExpressions.length) {
        return this.cryptoKey.getOutputDescriptorContent();
      } else {
        return `${this.scriptExpressions[seIndex].getExpression()}(${this._toOutputDescriptor(seIndex + 1)})`;
      }
    };
    this.toString = () => {
      return this._toOutputDescriptor(0);
    };
    this.toDataItem = () => {
      let dataItem = this.cryptoKey.toDataItem();
      if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey || this.cryptoKey instanceof CryptoHDKey_1$1.CryptoHDKey) {
        dataItem.setTag(this.cryptoKey.getRegistryType().getTag());
      }
      const clonedSe = [...this.scriptExpressions];
      clonedSe.reverse().forEach((se) => {
        const tagValue = se.getTag();
        if (dataItem.getTag() === void 0) {
          dataItem.setTag(tagValue);
        } else {
          dataItem = new lib_1$3.DataItem(dataItem, tagValue);
        }
      });
      return dataItem;
    };
  }
}
CryptoOutput$1.CryptoOutput = CryptoOutput2;
CryptoOutput2.fromDataItem = (dataItem) => {
  const scriptExpressions = [];
  let _dataItem = dataItem;
  while (true) {
    let _tag = _dataItem.getTag();
    const se = ScriptExpression_1.ScriptExpression.fromTag(_tag);
    if (se) {
      scriptExpressions.push(se);
      if (_dataItem.getData() instanceof lib_1$3.DataItem) {
        _dataItem = _dataItem.getData();
        _tag = _dataItem.getTag();
      } else {
        break;
      }
    } else {
      break;
    }
  }
  const seLength = scriptExpressions.length;
  const isMultiKey = seLength > 0 && (scriptExpressions[seLength - 1].getExpression() === ScriptExpression_1.ScriptExpressions.MULTISIG.getExpression() || scriptExpressions[seLength - 1].getExpression() === ScriptExpression_1.ScriptExpressions.SORTED_MULTISIG.getExpression());
  if (isMultiKey) {
    const multiKey = MultiKey_1.MultiKey.fromDataItem(_dataItem);
    return new CryptoOutput2(scriptExpressions, multiKey);
  }
  if (_dataItem.getTag() === RegistryType_1$3.RegistryTypes.CRYPTO_HDKEY.getTag()) {
    const cryptoHDKey = CryptoHDKey_1$1.CryptoHDKey.fromDataItem(_dataItem);
    return new CryptoOutput2(scriptExpressions, cryptoHDKey);
  } else {
    const cryptoECKey = CryptoECKey_1.CryptoECKey.fromDataItem(_dataItem);
    return new CryptoOutput2(scriptExpressions, cryptoECKey);
  }
};
CryptoOutput2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$3.decodeToDataItem)(_cborPayload);
  return CryptoOutput2.fromDataItem(dataItem);
};
var CryptoPSBT$1 = {};
Object.defineProperty(CryptoPSBT$1, "__esModule", { value: true });
CryptoPSBT$1.CryptoPSBT = void 0;
const lib_1$2 = lib$1;
const RegistryItem_1$2 = RegistryItem$1;
const RegistryType_1$2 = RegistryType$1;
class CryptoPSBT2 extends RegistryItem_1$2.RegistryItem {
  constructor(psbt) {
    super();
    this.psbt = psbt;
    this.getRegistryType = () => RegistryType_1$2.RegistryTypes.CRYPTO_PSBT;
    this.getPSBT = () => this.psbt;
    this.toDataItem = () => {
      return new lib_1$2.DataItem(this.psbt);
    };
  }
}
CryptoPSBT$1.CryptoPSBT = CryptoPSBT2;
CryptoPSBT2.fromDataItem = (dataItem) => {
  const psbt = dataItem.getData();
  if (!psbt) {
    throw new Error(`#[ur-registry][CryptoPSBT][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
  }
  return new CryptoPSBT2(psbt);
};
CryptoPSBT2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$2.decodeToDataItem)(_cborPayload);
  return CryptoPSBT2.fromDataItem(dataItem);
};
var CryptoAccount = {};
var hasRequiredCryptoAccount;
function requireCryptoAccount() {
  if (hasRequiredCryptoAccount) return CryptoAccount;
  hasRequiredCryptoAccount = 1;
  Object.defineProperty(CryptoAccount, "__esModule", { value: true });
  CryptoAccount.CryptoAccount = void 0;
  const _1 = requireDist();
  const lib_12 = lib$1;
  const RegistryItem_12 = RegistryItem$1;
  const RegistryType_12 = RegistryType$1;
  var Keys2;
  (function(Keys3) {
    Keys3[Keys3["masterFingerprint"] = 1] = "masterFingerprint";
    Keys3[Keys3["outputDescriptors"] = 2] = "outputDescriptors";
  })(Keys2 || (Keys2 = {}));
  let CryptoAccount$12 = class CryptoAccount extends RegistryItem_12.RegistryItem {
    constructor(masterFingerprint, outputDescriptors) {
      super();
      this.masterFingerprint = masterFingerprint;
      this.outputDescriptors = outputDescriptors;
      this.getRegistryType = () => {
        return RegistryType_12.RegistryTypes.CRYPTO_ACCOUNT;
      };
      this.getMasterFingerprint = () => this.masterFingerprint;
      this.getOutputDescriptors = () => this.outputDescriptors;
      this.toDataItem = () => {
        const map = {};
        if (this.masterFingerprint) {
          map[Keys2.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
        }
        if (this.outputDescriptors) {
          map[Keys2.outputDescriptors] = this.outputDescriptors.map((item) => item.toDataItem());
        }
        return new lib_12.DataItem(map);
      };
    }
  };
  CryptoAccount.CryptoAccount = CryptoAccount$12;
  CryptoAccount$12.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const masterFingerprint = Buffer$1$1.alloc(4);
    const _masterFingerprint = map[Keys2.masterFingerprint];
    if (_masterFingerprint) {
      masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
    }
    const outputDescriptors = map[Keys2.outputDescriptors];
    const cryptoOutputs = outputDescriptors.map((item) => _1.CryptoOutput.fromDataItem(item));
    return new CryptoAccount$12(masterFingerprint, cryptoOutputs);
  };
  CryptoAccount$12.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_12.decodeToDataItem)(_cborPayload);
    return CryptoAccount$12.fromDataItem(dataItem);
  };
  return CryptoAccount;
}
var Decoder = {};
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: true });
errors$1.UnknownURTypeError = void 0;
class UnknownURTypeError2 extends Error {
  constructor(message2) {
    super(message2);
  }
}
errors$1.UnknownURTypeError = UnknownURTypeError2;
var hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder) return Decoder;
  hasRequiredDecoder = 1;
  Object.defineProperty(Decoder, "__esModule", { value: true });
  Decoder.URRegistryDecoder = void 0;
  const bc_ur_12 = dist$g;
  const __1 = requireDist();
  const RegistryType_12 = RegistryType$1;
  const errors_12 = errors$1;
  class URRegistryDecoder extends bc_ur_12.URDecoder {
    constructor() {
      super(...arguments);
      this.resultRegistryType = () => {
        const ur2 = this.resultUR();
        switch (ur2.type) {
          case RegistryType_12.RegistryTypes.BYTES.getType():
            return __1.Bytes.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_HDKEY.getType():
            return __1.CryptoHDKey.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_KEYPATH.getType():
            return __1.CryptoKeypath.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_COIN_INFO.getType():
            return __1.CryptoCoinInfo.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_ECKEY.getType():
            return __1.CryptoECKey.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_OUTPUT.getType():
            return __1.CryptoOutput.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_PSBT.getType():
            return __1.CryptoPSBT.fromCBOR(ur2.cbor);
          case RegistryType_12.RegistryTypes.CRYPTO_ACCOUNT.getType():
            return __1.CryptoAccount.fromCBOR(ur2.cbor);
          default:
            throw new errors_12.UnknownURTypeError(`#[ur-registry][Decoder][fn.resultRegistryType]: registry type ${ur2.type} is not supported now`);
        }
      };
    }
  }
  Decoder.URRegistryDecoder = URRegistryDecoder;
  return Decoder;
}
var CryptoMultiAccounts$1 = {};
Object.defineProperty(CryptoMultiAccounts$1, "__esModule", { value: true });
CryptoMultiAccounts$1.CryptoMultiAccounts = void 0;
const RegistryType_1$1 = RegistryType$1;
const CryptoHDKey_1 = CryptoHDKey$1;
const RegistryItem_1$1 = RegistryItem$1;
const lib_1$1 = lib$1;
var Keys$1;
(function(Keys2) {
  Keys2[Keys2["masterFingerprint"] = 1] = "masterFingerprint";
  Keys2[Keys2["keys"] = 2] = "keys";
  Keys2[Keys2["device"] = 3] = "device";
  Keys2[Keys2["deviceId"] = 4] = "deviceId";
  Keys2[Keys2["version"] = 5] = "version";
})(Keys$1 || (Keys$1 = {}));
class CryptoMultiAccounts2 extends RegistryItem_1$1.RegistryItem {
  constructor(masterFingerprint, keys2, device, deviceId, version2) {
    super();
    this.masterFingerprint = masterFingerprint;
    this.keys = keys2;
    this.device = device;
    this.deviceId = deviceId;
    this.version = version2;
    this.getRegistryType = () => RegistryType_1$1.RegistryTypes.CRYPTO_MULTI_ACCOUNTS;
    this.getMasterFingerprint = () => this.masterFingerprint;
    this.getKeys = () => this.keys;
    this.getDevice = () => this.device;
    this.getDeviceId = () => this.deviceId;
    this.getVersion = () => this.version;
    this.toDataItem = () => {
      const map = {};
      if (this.masterFingerprint) {
        map[Keys$1.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
      }
      if (this.keys) {
        map[Keys$1.keys] = this.keys.map((item) => {
          const dataItem = item.toDataItem();
          dataItem.setTag(item.getRegistryType().getTag());
          return dataItem;
        });
      }
      if (this.device) {
        map[Keys$1.device] = this.device;
      }
      if (this.deviceId) {
        map[Keys$1.deviceId] = this.deviceId;
      }
      if (this.version) {
        map[Keys$1.version] = this.version;
      }
      return new lib_1$1.DataItem(map);
    };
  }
}
CryptoMultiAccounts$1.CryptoMultiAccounts = CryptoMultiAccounts2;
CryptoMultiAccounts2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const masterFingerprint = Buffer$1$1.alloc(4);
  const _masterFingerprint = map[Keys$1.masterFingerprint];
  if (_masterFingerprint) {
    masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
  }
  const keys2 = map[Keys$1.keys];
  const cryptoHDKeys = keys2.map((item) => CryptoHDKey_1.CryptoHDKey.fromDataItem(item));
  const device = map[Keys$1.device];
  const deviceId = map[Keys$1.deviceId];
  const version2 = map[Keys$1.version];
  return new CryptoMultiAccounts2(masterFingerprint, cryptoHDKeys, device, deviceId, version2);
};
CryptoMultiAccounts2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1$1.decodeToDataItem)(_cborPayload);
  return CryptoMultiAccounts2.fromDataItem(dataItem);
};
var QRHardwareCall = {};
var KeyDerivation$1 = {};
var DerivationSchema = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyDerivationSchema = exports.DerivationAlgorithm = exports.Curve = void 0;
  const RegistryType_12 = RegistryType$1;
  const RegistryItem_12 = RegistryItem$1;
  const lib_12 = lib$1;
  const CryptoKeypath_12 = CryptoKeypath$1;
  var Keys2;
  (function(Keys3) {
    Keys3[Keys3["keyPath"] = 1] = "keyPath";
    Keys3[Keys3["curve"] = 2] = "curve";
    Keys3[Keys3["algo"] = 3] = "algo";
  })(Keys2 || (Keys2 = {}));
  var Curve;
  (function(Curve2) {
    Curve2[Curve2["secp256k1"] = 0] = "secp256k1";
    Curve2[Curve2["ed25519"] = 1] = "ed25519";
  })(Curve = exports.Curve || (exports.Curve = {}));
  var DerivationAlgorithm;
  (function(DerivationAlgorithm2) {
    DerivationAlgorithm2[DerivationAlgorithm2["slip10"] = 0] = "slip10";
    DerivationAlgorithm2[DerivationAlgorithm2["bip32ed25519"] = 1] = "bip32ed25519";
  })(DerivationAlgorithm = exports.DerivationAlgorithm || (exports.DerivationAlgorithm = {}));
  class KeyDerivationSchema extends RegistryItem_12.RegistryItem {
    constructor(keypath, curve2 = Curve.secp256k1, algo2 = DerivationAlgorithm.slip10) {
      super();
      this.keypath = keypath;
      this.curve = curve2;
      this.algo = algo2;
      this.getRegistryType = () => RegistryType_12.RegistryTypes.KEY_DERIVATION_SCHEMA;
      this.getKeypath = () => this.keypath;
      this.getCurve = () => this.curve;
      this.getAlgo = () => this.algo;
      this.toDataItem = () => {
        const map = {};
        const dataItem = this.getKeypath().toDataItem();
        dataItem.setTag(this.getKeypath().getRegistryType().getTag());
        map[Keys2.keyPath] = dataItem;
        map[Keys2.curve] = this.curve;
        map[Keys2.algo] = this.algo;
        return new lib_12.DataItem(map);
      };
    }
  }
  exports.KeyDerivationSchema = KeyDerivationSchema;
  KeyDerivationSchema.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const keypaths = CryptoKeypath_12.CryptoKeypath.fromDataItem(map[Keys2.keyPath]);
    const curve2 = map[Keys2.curve];
    const algo2 = map[Keys2.algo];
    return new KeyDerivationSchema(keypaths, curve2, algo2);
  };
  KeyDerivationSchema.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_12.decodeToDataItem)(_cborPayload);
    return KeyDerivationSchema.fromDataItem(dataItem);
  };
})(DerivationSchema);
Object.defineProperty(KeyDerivation$1, "__esModule", { value: true });
KeyDerivation$1.KeyDerivation = void 0;
const RegistryType_1 = RegistryType$1;
const RegistryItem_1 = RegistryItem$1;
const lib_1 = lib$1;
const DerivationSchema_1 = DerivationSchema;
var Keys;
(function(Keys2) {
  Keys2[Keys2["schemas"] = 1] = "schemas";
})(Keys || (Keys = {}));
class KeyDerivation2 extends RegistryItem_1.RegistryItem {
  constructor(schemas) {
    super();
    this.schemas = schemas;
    this.getRegistryType = () => RegistryType_1.RegistryTypes.KEY_DERIVATION_CALL;
    this.getSchemas = () => this.schemas;
    this.toDataItem = () => {
      const map = {};
      map[Keys.schemas] = this.schemas.map((schema) => {
        const dataItem = schema.toDataItem();
        dataItem.setTag(schema.getRegistryType().getTag());
        return dataItem;
      });
      return new lib_1.DataItem(map);
    };
  }
}
KeyDerivation$1.KeyDerivation = KeyDerivation2;
KeyDerivation2.fromDataItem = (dataItem) => {
  const map = dataItem.getData();
  const schemas = map[Keys.schemas].map((keypath) => DerivationSchema_1.KeyDerivationSchema.fromDataItem(keypath));
  return new KeyDerivation2(schemas);
};
KeyDerivation2.fromCBOR = (_cborPayload) => {
  const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
  return KeyDerivation2.fromDataItem(dataItem);
};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QRHardwareCall = exports.QRHardwareCallType = void 0;
  const RegistryType_12 = RegistryType$1;
  const RegistryItem_12 = RegistryItem$1;
  const lib_12 = lib$1;
  const KeyDerivation_1 = KeyDerivation$1;
  var Keys2;
  (function(Keys3) {
    Keys3[Keys3["type"] = 1] = "type";
    Keys3[Keys3["params"] = 2] = "params";
    Keys3[Keys3["origin"] = 3] = "origin";
  })(Keys2 || (Keys2 = {}));
  var QRHardwareCallType;
  (function(QRHardwareCallType2) {
    QRHardwareCallType2[QRHardwareCallType2["KeyDerivation"] = 0] = "KeyDerivation";
  })(QRHardwareCallType = exports.QRHardwareCallType || (exports.QRHardwareCallType = {}));
  class QRHardwareCall2 extends RegistryItem_12.RegistryItem {
    constructor(type, params, origin2) {
      super();
      this.type = type;
      this.params = params;
      this.origin = origin2;
      this.getRegistryType = () => RegistryType_12.RegistryTypes.QR_HARDWARE_CALL;
      this.getType = () => this.type;
      this.getParams = () => this.params;
      this.getOrigin = () => this.origin;
      this.toDataItem = () => {
        const map = {};
        map[Keys2.type] = this.type;
        const param = this.params.toDataItem();
        param.setTag(this.params.getRegistryType().getTag());
        map[Keys2.params] = param;
        if (this.origin) {
          map[Keys2.origin] = this.origin;
        }
        return new lib_12.DataItem(map);
      };
    }
  }
  exports.QRHardwareCall = QRHardwareCall2;
  QRHardwareCall2.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const type = map[Keys2.type] || QRHardwareCallType.KeyDerivation;
    let params;
    switch (type) {
      case QRHardwareCallType.KeyDerivation:
        params = KeyDerivation_1.KeyDerivation.fromDataItem(map[Keys2.params]);
    }
    const origin2 = map[Keys2.origin];
    return new QRHardwareCall2(type, params, origin2);
  };
  QRHardwareCall2.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_12.decodeToDataItem)(_cborPayload);
    return QRHardwareCall2.fromDataItem(dataItem);
  };
})(QRHardwareCall);
var types$3 = {};
Object.defineProperty(types$3, "__esModule", { value: true });
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist$e;
  hasRequiredDist = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Buffer = exports.extend = exports.PathComponent = exports.ScriptExpressions = exports.MultiKey = exports.CryptoPSBT = exports.CryptoOutput = exports.CryptoECKey = exports.CryptoCoinInfoNetwork = exports.CryptoCoinInfoType = exports.CryptoCoinInfo = exports.CryptoKeypath = exports.CryptoMultiAccounts = exports.CryptoHDKey = exports.CryptoAccount = exports.Bytes = exports.URRegistryDecoder = exports.DataItem = void 0;
    const tslib_1 = require$$0$2;
    const buffer_12 = dist$h;
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return buffer_12.Buffer;
    } });
    const CryptoHDKey_12 = CryptoHDKey$1;
    Object.defineProperty(exports, "CryptoHDKey", { enumerable: true, get: function() {
      return CryptoHDKey_12.CryptoHDKey;
    } });
    const CryptoKeypath_12 = CryptoKeypath$1;
    Object.defineProperty(exports, "CryptoKeypath", { enumerable: true, get: function() {
      return CryptoKeypath_12.CryptoKeypath;
    } });
    const CryptoCoinInfo_12 = CryptoCoinInfo;
    Object.defineProperty(exports, "CryptoCoinInfo", { enumerable: true, get: function() {
      return CryptoCoinInfo_12.CryptoCoinInfo;
    } });
    Object.defineProperty(exports, "CryptoCoinInfoType", { enumerable: true, get: function() {
      return CryptoCoinInfo_12.Type;
    } });
    Object.defineProperty(exports, "CryptoCoinInfoNetwork", { enumerable: true, get: function() {
      return CryptoCoinInfo_12.Network;
    } });
    const CryptoECKey_12 = CryptoECKey$1;
    Object.defineProperty(exports, "CryptoECKey", { enumerable: true, get: function() {
      return CryptoECKey_12.CryptoECKey;
    } });
    const Bytes_1 = Bytes$2;
    Object.defineProperty(exports, "Bytes", { enumerable: true, get: function() {
      return Bytes_1.Bytes;
    } });
    const CryptoOutput_1 = CryptoOutput$1;
    Object.defineProperty(exports, "CryptoOutput", { enumerable: true, get: function() {
      return CryptoOutput_1.CryptoOutput;
    } });
    const CryptoPSBT_1 = CryptoPSBT$1;
    Object.defineProperty(exports, "CryptoPSBT", { enumerable: true, get: function() {
      return CryptoPSBT_1.CryptoPSBT;
    } });
    const CryptoAccount_1 = requireCryptoAccount();
    Object.defineProperty(exports, "CryptoAccount", { enumerable: true, get: function() {
      return CryptoAccount_1.CryptoAccount;
    } });
    const Decoder_1 = requireDecoder();
    Object.defineProperty(exports, "URRegistryDecoder", { enumerable: true, get: function() {
      return Decoder_1.URRegistryDecoder;
    } });
    const MultiKey_12 = MultiKey$1;
    Object.defineProperty(exports, "MultiKey", { enumerable: true, get: function() {
      return MultiKey_12.MultiKey;
    } });
    const ScriptExpression_12 = ScriptExpression;
    Object.defineProperty(exports, "ScriptExpressions", { enumerable: true, get: function() {
      return ScriptExpression_12.ScriptExpressions;
    } });
    const PathComponent_12 = PathComponent$1;
    Object.defineProperty(exports, "PathComponent", { enumerable: true, get: function() {
      return PathComponent_12.PathComponent;
    } });
    const RegistryItem_12 = RegistryItem$1;
    const RegistryType_12 = RegistryType$1;
    const lib_12 = lib$1;
    var lib_2 = lib$1;
    Object.defineProperty(exports, "DataItem", { enumerable: true, get: function() {
      return lib_2.DataItem;
    } });
    const utils_12 = utils$h;
    const CryptoMultiAccounts_1 = CryptoMultiAccounts$1;
    Object.defineProperty(exports, "CryptoMultiAccounts", { enumerable: true, get: function() {
      return CryptoMultiAccounts_1.CryptoMultiAccounts;
    } });
    const URlib = {
      URRegistryDecoder: Decoder_1.URRegistryDecoder,
      Bytes: Bytes_1.Bytes,
      CryptoAccount: CryptoAccount_1.CryptoAccount,
      CryptoHDKey: CryptoHDKey_12.CryptoHDKey,
      CryptoMultiAccounts: CryptoMultiAccounts_1.CryptoMultiAccounts,
      CryptoKeypath: CryptoKeypath_12.CryptoKeypath,
      CryptoCoinInfo: CryptoCoinInfo_12.CryptoCoinInfo,
      CryptoCoinInfoType: CryptoCoinInfo_12.Type,
      CryptoCoinInfoNetwork: CryptoCoinInfo_12.Network,
      CryptoECKey: CryptoECKey_12.CryptoECKey,
      CryptoOutput: CryptoOutput_1.CryptoOutput,
      CryptoPSBT: CryptoPSBT_1.CryptoPSBT,
      MultiKey: MultiKey_12.MultiKey,
      ScriptExpressions: ScriptExpression_12.ScriptExpressions,
      PathComponent: PathComponent_12.PathComponent
    };
    const cbor2 = {
      addReader: lib_12.addReader,
      addSemanticDecode: lib_12.addSemanticDecode,
      addSemanticEncode: lib_12.addSemanticEncode,
      addWriter: lib_12.addWriter,
      patchTags: utils_12.patchTags
    };
    const extend = {
      RegistryTypes: RegistryType_12.RegistryTypes,
      RegistryItem: RegistryItem_12.RegistryItem,
      RegistryType: RegistryType_12.RegistryType,
      decodeToDataItem: lib_12.decodeToDataItem,
      encodeDataItem: lib_12.encodeDataItem,
      cbor: cbor2
    };
    exports.extend = extend;
    (0, tslib_1.__exportStar)(errors$1, exports);
    (0, tslib_1.__exportStar)(requireDecoder(), exports);
    (0, tslib_1.__exportStar)(lib$1, exports);
    (0, tslib_1.__exportStar)(requireCryptoAccount(), exports);
    (0, tslib_1.__exportStar)(CryptoPSBT$1, exports);
    (0, tslib_1.__exportStar)(CryptoHDKey$1, exports);
    (0, tslib_1.__exportStar)(CryptoMultiAccounts$1, exports);
    (0, tslib_1.__exportStar)(QRHardwareCall, exports);
    (0, tslib_1.__exportStar)(KeyDerivation$1, exports);
    (0, tslib_1.__exportStar)(DerivationSchema, exports);
    (0, tslib_1.__exportStar)(CryptoOutput$1, exports);
    (0, tslib_1.__exportStar)(CryptoCoinInfo, exports);
    (0, tslib_1.__exportStar)(CryptoECKey$1, exports);
    (0, tslib_1.__exportStar)(MultiKey$1, exports);
    (0, tslib_1.__exportStar)(CryptoKeypath$1, exports);
    (0, tslib_1.__exportStar)(patchCBOR, exports);
    (0, tslib_1.__exportStar)(PathComponent$1, exports);
    (0, tslib_1.__exportStar)(RegistryItem$1, exports);
    (0, tslib_1.__exportStar)(RegistryType$1, exports);
    (0, tslib_1.__exportStar)(types$3, exports);
    (0, tslib_1.__exportStar)(utils$h, exports);
    exports.default = URlib;
  })(dist$e);
  return dist$e;
}
var getRandomValues$3;
var rnds8$3 = new Uint8Array(16);
function rng$6() {
  if (!getRandomValues$3) {
    getRandomValues$3 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues$3) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues$3(rnds8$3);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$6(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex$3 = [];
for (var i = 0; i < 256; ++i) {
  byteToHex$3.push((i + 256).toString(16).substr(1));
}
function stringify$6(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex$3[arr[offset + 0]] + byteToHex$3[arr[offset + 1]] + byteToHex$3[arr[offset + 2]] + byteToHex$3[arr[offset + 3]] + "-" + byteToHex$3[arr[offset + 4]] + byteToHex$3[arr[offset + 5]] + "-" + byteToHex$3[arr[offset + 6]] + byteToHex$3[arr[offset + 7]] + "-" + byteToHex$3[arr[offset + 8]] + byteToHex$3[arr[offset + 9]] + "-" + byteToHex$3[arr[offset + 10]] + byteToHex$3[arr[offset + 11]] + byteToHex$3[arr[offset + 12]] + byteToHex$3[arr[offset + 13]] + byteToHex$3[arr[offset + 14]] + byteToHex$3[arr[offset + 15]]).toLowerCase();
  if (!validate$6(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _nodeId$3;
var _clockseq$3;
var _lastMSecs$3 = 0;
var _lastNSecs$3 = 0;
function v1$6(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId$3;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq$3;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng$6)();
    if (node == null) {
      node = _nodeId$3 = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq$3 = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs$3 + 1;
  var dt = msecs - _lastMSecs$3 + (nsecs - _lastNSecs$3) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs$3) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs$3 = msecs;
  _lastNSecs$3 = nsecs;
  _clockseq$3 = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify$6(b);
}
function parse$6(uuid) {
  if (!validate$6(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
function stringToBytes$3(str) {
  str = unescape(encodeURIComponent(str));
  var bytes2 = [];
  for (var i = 0; i < str.length; ++i) {
    bytes2.push(str.charCodeAt(i));
  }
  return bytes2;
}
var DNS$3 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$4 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35$6(name2, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes$3(value);
    }
    if (typeof namespace === "string") {
      namespace = parse$6(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes2[i];
      }
      return buf;
    }
    return stringify$6(bytes2);
  }
  try {
    generateUUID.name = name2;
  } catch (err2) {
  }
  generateUUID.DNS = DNS$3;
  generateUUID.URL = URL$4;
  return generateUUID;
}
function md5$6(bytes2) {
  if (typeof bytes2 === "string") {
    var msg2 = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg2.length);
    for (var i = 0; i < msg2.length; ++i) {
      bytes2[i] = msg2.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray$3(wordsToMd5$3(bytesToWords$3(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray$3(input) {
  var output2 = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output2.push(hex);
  }
  return output2;
}
function getOutputLength$3(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5$3(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength$3(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff$3(a, b, c, d, x[i], 7, -680876936);
    d = md5ff$3(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff$3(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff$3(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff$3(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff$3(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff$3(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff$3(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff$3(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff$3(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff$3(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff$3(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff$3(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff$3(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff$3(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff$3(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg$3(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg$3(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg$3(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg$3(b, c, d, a, x[i], 20, -373897302);
    a = md5gg$3(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg$3(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg$3(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg$3(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg$3(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg$3(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg$3(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg$3(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg$3(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg$3(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg$3(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg$3(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh$3(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh$3(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh$3(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh$3(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh$3(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh$3(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh$3(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh$3(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh$3(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh$3(d, a, b, c, x[i], 11, -358537222);
    c = md5hh$3(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh$3(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh$3(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh$3(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh$3(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh$3(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii$3(a, b, c, d, x[i], 6, -198630844);
    d = md5ii$3(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii$3(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii$3(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii$3(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii$3(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii$3(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii$3(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii$3(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii$3(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii$3(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii$3(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii$3(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii$3(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii$3(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii$3(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd$3(a, olda);
    b = safeAdd$3(b, oldb);
    c = safeAdd$3(c, oldc);
    d = safeAdd$3(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords$3(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output2 = new Uint32Array(getOutputLength$3(length8));
  for (var i = 0; i < length8; i += 8) {
    output2[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output2;
}
function safeAdd$3(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft$3(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn$3(q, a, b, x, s, t) {
  return safeAdd$3(bitRotateLeft$3(safeAdd$3(safeAdd$3(a, q), safeAdd$3(x, t)), s), b);
}
function md5ff$3(a, b, c, d, x, s, t) {
  return md5cmn$3(b & c | ~b & d, a, b, x, s, t);
}
function md5gg$3(a, b, c, d, x, s, t) {
  return md5cmn$3(b & d | c & ~d, a, b, x, s, t);
}
function md5hh$3(a, b, c, d, x, s, t) {
  return md5cmn$3(b ^ c ^ d, a, b, x, s, t);
}
function md5ii$3(a, b, c, d, x, s, t) {
  return md5cmn$3(c ^ (b | ~d), a, b, x, s, t);
}
var v3$6 = v35$6("v3", 48, md5$6);
function v4$6(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng$6)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify$6(rnds);
}
function f$3(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL$3(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1$6(bytes2) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    var msg2 = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (var i = 0; i < msg2.length; ++i) {
      bytes2.push(msg2.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  var l = bytes2.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes2[_i * 64 + j * 4] << 24 | bytes2[_i * 64 + j * 4 + 1] << 16 | bytes2[_i * 64 + j * 4 + 2] << 8 | bytes2[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL$3(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL$3(a, 5) + f$3(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL$3(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var v5$6 = v35$6("v5", 80, sha1$6);
const nil$3 = "00000000-0000-0000-0000-000000000000";
function version$7(uuid) {
  if (!validate$6(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil$3,
  parse: parse$6,
  stringify: stringify$6,
  v1: v1$6,
  v3: v3$6,
  v4: v4$6,
  v5: v5$6,
  validate: validate$6,
  version: version$7
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist(), e = require$$1;
  const s = { BTC_SIGN_REQUEST: new t.RegistryType("btc-sign-request", 8101), BTC_SIGNATURE: new t.RegistryType("btc-signature", 8102) }, { decodeToDataItem: a, RegistryTypes: i } = t.extend;
  var r, n;
  (r = exports.DataType || (exports.DataType = {}))[r.message = 1] = "message", function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.dataType = 3] = "dataType", t2[t2.derivationPaths = 4] = "derivationPaths", t2[t2.addresses = 5] = "addresses", t2[t2.origin = 6] = "origin";
  }(n || (n = {}));
  class d extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.BTC_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDataype = () => this.dataType, this.getDerivationPaths = () => this.derivationPaths.map((t2) => t2.getPath()), this.getAddress = () => this.addresses, this.getOrigin = () => this.origin, this.toDataItem = () => {
        const e3 = {};
        return e3[n.requestId] = new t.DataItem(this.requestId, i.UUID.getTag()), e3[n.signData] = this.signData, e3[n.dataType] = this.dataType, e3[n.derivationPaths] = this.derivationPaths.map((t2) => {
          const e4 = t2.toDataItem();
          return e4.setTag(t2.getRegistryType().getTag()), e4;
        }), this.addresses && (e3[n.addresses] = this.addresses), this.origin && (e3[n.origin] = this.origin), new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.dataType = e2.dataType, this.derivationPaths = e2.derivationPaths, this.addresses = e2.addresses, this.origin = e2.origin;
    }
    static constructBtcRequest(s2, a2, i2, r2, n2, o2, g2) {
      const u2 = n2.map((e2, s3) => {
        const i3 = e2.replace(/[m|M]\//, "").split("/").map((e3) => {
          const s4 = parseInt(e3.replace("'", ""));
          let a3 = false;
          return e3.endsWith("'") && (a3 = true), new t.PathComponent({ index: s4, hardened: a3 });
        });
        return new t.CryptoKeypath(i3, Buffer$1$1.from(a2[s3], "hex"));
      });
      return new d({ requestId: Buffer$1$1.from(e.parse(s2)), signData: i2, dataType: r2 || exports.DataType.message, derivationPaths: u2, addresses: o2 || void 0, origin: g2 || void 0 });
    }
  }
  d.fromDataItem = (e2) => {
    const s2 = e2.getData(), a2 = s2[n.requestId] ? s2[n.requestId].getData() : void 0, i2 = s2[n.signData], r2 = s2[n.dataType], o2 = s2[n.derivationPaths].map((e3) => t.CryptoKeypath.fromDataItem(e3));
    return new d({ requestId: a2, signData: i2, dataType: r2, derivationPaths: o2, addresses: s2[n.addresses] ? s2[n.addresses] : void 0, origin: s2[n.origin] ? s2[n.origin] : void 0 });
  }, d.fromCBOR = (t2) => {
    const e2 = a(t2);
    return d.fromDataItem(e2);
  };
  const { RegistryTypes: o, decodeToDataItem: g } = t.extend;
  var u;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature", t2[t2.publicKey = 3] = "publicKey";
  }(u || (u = {}));
  class h extends t.RegistryItem {
    constructor(e2, a2, i2) {
      super(), this.getRegistryType = () => s.BTC_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.getPublicKey = () => this.publicKey, this.toDataItem = () => {
        const e3 = {};
        return e3[u.requestId] = new t.DataItem(this.requestId, o.UUID.getTag()), e3[u.signature] = this.signature, e3[u.publicKey] = this.publicKey, new t.DataItem(e3);
      }, this.signature = e2, this.requestId = a2, this.publicKey = i2;
    }
  }
  h.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[u.signature], a2 = e2[u.requestId].getData();
    return new h(s2, a2, e2[u.publicKey]);
  }, h.fromCBOR = (t2) => {
    const e2 = g(t2);
    return h.fromDataItem(e2);
  }, t.patchTags(Object.values(s).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.BtcSignRequest = d, exports.BtcSignature = h;
})(bcUrRegistryBtc_cjs_production_min);
{
  dist$f.exports = bcUrRegistryBtc_cjs_production_min;
}
var distExports$c = dist$f.exports;
var ur = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.URType = exports.UR = void 0;
  var bc_ur_12 = dist$g;
  Object.defineProperty(exports, "UR", { enumerable: true, get: function() {
    return bc_ur_12.UR;
  } });
  (function(URType) {
    URType["CryptoPSBT"] = "crypto-psbt";
    URType["CryptoMultiAccounts"] = "crypto-multi-accounts";
    URType["CryptoHDKey"] = "crypto-hdkey";
    URType["CryptoAccount"] = "crypto-account";
    URType["BtcSignature"] = "btc-signature";
    URType["ArweaveCryptoAccount"] = "arweave-crypto-account";
    URType["EthSignature"] = "eth-signature";
    URType["SolSignature"] = "sol-signature";
    URType["StellarSignature"] = "stellar-signature";
    URType["CosmosSignature"] = "cosmos-signature";
    URType["EvmSignature"] = "evm-signature";
    URType["AptosSignature"] = "aptos-signature";
    URType["CardanoSignature"] = "cardano-signature";
    URType["CardanoSignDataSignature"] = "cardano-sign-data-signature";
    URType["CardanoSignCip8DataSignature"] = "cardano-sign-cip8-data-signature";
    URType["CardanoCatalystSignature"] = "cardano-catalyst-voting-registration-signature";
    URType["TronSignature"] = "keystone-sign-result";
    URType["KeystoneSignResult"] = "keystone-sign-result";
    URType["NearSignature"] = "near-signature";
    URType["ArweaveSignature"] = "arweave-signature";
    URType["SuiSignature"] = "sui-signature";
    URType["XrpAccount"] = "bytes";
    URType["XrpSignRequest"] = "bytes";
    URType["XrpSignature"] = "bytes";
    URType["TonSignature"] = "ton-signature";
  })(exports.URType || (exports.URType = {}));
})(ur);
Object.defineProperty(bitcoin, "__esModule", { value: true });
bitcoin.KeystoneBitcoinSDK = void 0;
const bc_ur_registry_1$3 = requireDist$1();
const bc_ur_registry_btc_1 = distExports$c;
const utils_1$j = utils$k;
const ur_1$c = ur;
class KeystoneBitcoinSDK {
  constructor(config2) {
    this.config = config2;
  }
  parsePSBT(ur2) {
    if (ur2.type !== ur_1$c.URType.CryptoPSBT) {
      throw new Error("type not match");
    }
    return (0, utils_1$j.toHex)(bc_ur_registry_1$3.CryptoPSBT.fromCBOR(ur2.cbor).getPSBT());
  }
  generatePSBT(psbt) {
    return new bc_ur_registry_1$3.CryptoPSBT(psbt).toUR();
  }
  generateSignRequest({ requestId, signData: signData2, dataType, accounts, origin: origin2 }) {
    var _a;
    const derivationPaths = [];
    const addresses = [];
    accounts.forEach((account2) => {
      var _a2;
      derivationPaths.push(new bc_ur_registry_btc_1.CryptoKeypath((0, utils_1$j.parsePath)(account2.path).map((e) => new bc_ur_registry_btc_1.PathComponent(e)), (0, utils_1$j.toBuffer)(account2.xfp)));
      addresses.push((_a2 = account2.address) !== null && _a2 !== void 0 ? _a2 : "");
    });
    return new bc_ur_registry_btc_1.BtcSignRequest({
      signData: (0, utils_1$j.toBuffer)(signData2),
      dataType,
      derivationPaths,
      requestId: (0, utils_1$j.uuidParse)(requestId),
      addresses,
      origin: origin2 !== null && origin2 !== void 0 ? origin2 : (_a = this.config) === null || _a === void 0 ? void 0 : _a.origin
    }).toUR();
  }
  parseSignature(ur2) {
    if (ur2.type !== ur_1$c.URType.BtcSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_btc_1.BtcSignature.fromCBOR(ur2.cbor);
    const requestId = (0, utils_1$j.uuidStringify)(sig.getRequestId());
    return {
      requestId,
      signature: (0, utils_1$j.toHex)(sig.getSignature()),
      publicKey: (0, utils_1$j.toHex)(sig.getPublicKey())
    };
  }
}
KeystoneBitcoinSDK.DataType = bc_ur_registry_btc_1.DataType;
bitcoin.KeystoneBitcoinSDK = KeystoneBitcoinSDK;
var cosmos = {};
var dist$d = { exports: {} };
var bcUrRegistryCosmos_cjs_production_min = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist(), e = require$$1;
  const s = { COSMOS_SIGN_REQUEST: new t.RegistryType("cosmos-sign-request", 4101), COSMOS_SIGNATURE: new t.RegistryType("cosmos-signature", 4102) }, { decodeToDataItem: a, RegistryTypes: i } = t.extend;
  var r, n;
  (r = exports.SignDataType || (exports.SignDataType = {}))[r.amino = 1] = "amino", r[r.direct = 2] = "direct", r[r.textual = 3] = "textual", r[r.message = 4] = "message", function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.dataType = 3] = "dataType", t2[t2.derivationPaths = 4] = "derivationPaths", t2[t2.addresses = 5] = "addresses", t2[t2.origin = 6] = "origin";
  }(n || (n = {}));
  class o extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.COSMOS_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDataype = () => this.dataType, this.getDerivationPaths = () => this.derivationPaths.map((t2) => t2.getPath()), this.getAddress = () => this.addresses, this.getOrigin = () => this.origin, this.toDataItem = () => {
        const e3 = {};
        return e3[n.requestId] = new t.DataItem(this.requestId, i.UUID.getTag()), e3[n.signData] = this.signData, e3[n.dataType] = this.dataType, e3[n.derivationPaths] = this.derivationPaths.map((t2) => {
          const e4 = t2.toDataItem();
          return e4.setTag(t2.getRegistryType().getTag()), e4;
        }), this.addresses && (e3[n.addresses] = this.addresses), this.origin && (e3[n.origin] = this.origin), new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.dataType = e2.dataType, this.derivationPaths = e2.derivationPaths, this.addresses = e2.addresses, this.origin = e2.origin;
    }
    static constructCosmosRequest(s2, a2, i2, r2, n2, d2, g2) {
      const u2 = n2.map((e2, s3) => {
        const i3 = e2.replace(/[m|M]\//, "").split("/").map((e3) => {
          const s4 = parseInt(e3.replace("'", ""));
          let a3 = false;
          return e3.endsWith("'") && (a3 = true), new t.PathComponent({ index: s4, hardened: a3 });
        });
        return new t.CryptoKeypath(i3, Buffer$1$1.from(a2[s3], "hex"));
      });
      return new o({ requestId: Buffer$1$1.from(e.parse(s2)), signData: i2, dataType: r2 || exports.SignDataType.amino, derivationPaths: u2, addresses: d2 || void 0, origin: g2 || void 0 });
    }
  }
  o.fromDataItem = (e2) => {
    const s2 = e2.getData(), a2 = s2[n.requestId] ? s2[n.requestId].getData() : void 0, i2 = s2[n.signData], r2 = s2[n.dataType], d2 = s2[n.derivationPaths].map((e3) => t.CryptoKeypath.fromDataItem(e3));
    return new o({ requestId: a2, signData: i2, dataType: r2, derivationPaths: d2, addresses: s2[n.addresses] ? s2[n.addresses] : void 0, origin: s2[n.origin] ? s2[n.origin] : void 0 });
  }, o.fromCBOR = (t2) => {
    const e2 = a(t2);
    return o.fromDataItem(e2);
  };
  const { RegistryTypes: d, decodeToDataItem: g } = t.extend;
  var u;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature", t2[t2.publicKey = 3] = "publicKey";
  }(u || (u = {}));
  class h extends t.RegistryItem {
    constructor(e2, a2, i2) {
      super(), this.getRegistryType = () => s.COSMOS_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.getPublicKey = () => this.publicKey, this.toDataItem = () => {
        const e3 = {};
        return e3[u.requestId] = new t.DataItem(this.requestId, d.UUID.getTag()), e3[u.signature] = this.signature, e3[u.publicKey] = this.publicKey, new t.DataItem(e3);
      }, this.signature = e2, this.requestId = a2, this.publicKey = i2;
    }
  }
  h.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[u.signature], a2 = e2[u.requestId].getData();
    return new h(s2, a2, e2[u.publicKey]);
  }, h.fromCBOR = (t2) => {
    const e2 = g(t2);
    return h.fromDataItem(e2);
  }, t.patchTags(Object.values(s).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.CosmosSignRequest = o, exports.CosmosSignature = h;
})(bcUrRegistryCosmos_cjs_production_min);
{
  dist$d.exports = bcUrRegistryCosmos_cjs_production_min;
}
var distExports$b = dist$d.exports;
Object.defineProperty(cosmos, "__esModule", { value: true });
cosmos.KeystoneCosmosSDK = void 0;
const utils_1$i = utils$k;
const ur_1$b = ur;
const bc_ur_registry_cosmos_1 = distExports$b;
class KeystoneCosmosSDK {
  constructor(config2) {
    this.config = config2;
  }
  parseSignature(ur2) {
    if (ur2.type !== ur_1$b.URType.CosmosSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_cosmos_1.CosmosSignature.fromCBOR(ur2.cbor);
    const requestId = (0, utils_1$i.uuidStringify)(sig.getRequestId());
    return {
      requestId,
      signature: (0, utils_1$i.toHex)(sig.getSignature()),
      publicKey: (0, utils_1$i.toHex)(sig.getPublicKey())
    };
  }
  generateSignRequest({ requestId, signData: signData2, dataType, accounts, origin: origin2 }) {
    var _a;
    const derivationPaths = [];
    const addresses = [];
    accounts.forEach((account2) => {
      derivationPaths.push(new bc_ur_registry_cosmos_1.CryptoKeypath((0, utils_1$i.parsePath)(account2.path).map((e) => new bc_ur_registry_cosmos_1.PathComponent(e)), (0, utils_1$i.toBuffer)(account2.xfp)));
      addresses.push(account2.address);
    });
    return new bc_ur_registry_cosmos_1.CosmosSignRequest({
      signData: (0, utils_1$i.toBuffer)(signData2),
      dataType,
      derivationPaths,
      requestId: (0, utils_1$i.uuidParse)(requestId),
      addresses,
      origin: origin2 !== null && origin2 !== void 0 ? origin2 : (_a = this.config) === null || _a === void 0 ? void 0 : _a.origin
    }).toUR();
  }
}
KeystoneCosmosSDK.DataType = bc_ur_registry_cosmos_1.SignDataType;
cosmos.KeystoneCosmosSDK = KeystoneCosmosSDK;
var evm = {};
var dist$c = { exports: {} };
var bcUrRegistryEvm_cjs_production_min = {};
var commonjsBrowser$2 = {};
var v1$5 = {};
var rng$5 = {};
Object.defineProperty(rng$5, "__esModule", {
  value: true
});
rng$5.default = rng$4;
let getRandomValues$2;
const rnds8$2 = new Uint8Array(16);
function rng$4() {
  if (!getRandomValues$2) {
    getRandomValues$2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues$2) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues$2(rnds8$2);
}
var stringify$5 = {};
var validate$5 = {};
var regex$2 = {};
Object.defineProperty(regex$2, "__esModule", {
  value: true
});
regex$2.default = void 0;
var _default$C = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
regex$2.default = _default$C;
Object.defineProperty(validate$5, "__esModule", {
  value: true
});
validate$5.default = void 0;
var _regex$2 = _interopRequireDefault$q(regex$2);
function _interopRequireDefault$q(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function validate$4(uuid) {
  return typeof uuid === "string" && _regex$2.default.test(uuid);
}
var _default$B = validate$4;
validate$5.default = _default$B;
Object.defineProperty(stringify$5, "__esModule", {
  value: true
});
stringify$5.default = void 0;
stringify$5.unsafeStringify = unsafeStringify$2;
var _validate$8 = _interopRequireDefault$p(validate$5);
function _interopRequireDefault$p(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const byteToHex$2 = [];
for (let i = 0; i < 256; ++i) {
  byteToHex$2.push((i + 256).toString(16).slice(1));
}
function unsafeStringify$2(arr, offset = 0) {
  return byteToHex$2[arr[offset + 0]] + byteToHex$2[arr[offset + 1]] + byteToHex$2[arr[offset + 2]] + byteToHex$2[arr[offset + 3]] + "-" + byteToHex$2[arr[offset + 4]] + byteToHex$2[arr[offset + 5]] + "-" + byteToHex$2[arr[offset + 6]] + byteToHex$2[arr[offset + 7]] + "-" + byteToHex$2[arr[offset + 8]] + byteToHex$2[arr[offset + 9]] + "-" + byteToHex$2[arr[offset + 10]] + byteToHex$2[arr[offset + 11]] + byteToHex$2[arr[offset + 12]] + byteToHex$2[arr[offset + 13]] + byteToHex$2[arr[offset + 14]] + byteToHex$2[arr[offset + 15]];
}
function stringify$4(arr, offset = 0) {
  const uuid = unsafeStringify$2(arr, offset);
  if (!(0, _validate$8.default)(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _default$A = stringify$4;
stringify$5.default = _default$A;
Object.defineProperty(v1$5, "__esModule", {
  value: true
});
v1$5.default = void 0;
var _rng$5 = _interopRequireDefault$o(rng$5);
var _stringify$8 = stringify$5;
function _interopRequireDefault$o(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
let _nodeId$2;
let _clockseq$2;
let _lastMSecs$2 = 0;
let _lastNSecs$2 = 0;
function v1$4(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId$2;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq$2;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng$5.default)();
    if (node == null) {
      node = _nodeId$2 = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq$2 = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs$2 + 1;
  const dt = msecs - _lastMSecs$2 + (nsecs - _lastNSecs$2) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs$2) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs$2 = msecs;
  _lastNSecs$2 = nsecs;
  _clockseq$2 = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || (0, _stringify$8.unsafeStringify)(b);
}
var _default$z = v1$4;
v1$5.default = _default$z;
var v3$5 = {};
var v35$5 = {};
var parse$5 = {};
Object.defineProperty(parse$5, "__esModule", {
  value: true
});
parse$5.default = void 0;
var _validate$7 = _interopRequireDefault$n(validate$5);
function _interopRequireDefault$n(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function parse$4(uuid) {
  if (!(0, _validate$7.default)(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var _default$y = parse$4;
parse$5.default = _default$y;
Object.defineProperty(v35$5, "__esModule", {
  value: true
});
v35$5.URL = v35$5.DNS = void 0;
v35$5.default = v35$4;
var _stringify$7 = stringify$5;
var _parse$2 = _interopRequireDefault$m(parse$5);
function _interopRequireDefault$m(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function stringToBytes$2(str) {
  str = unescape(encodeURIComponent(str));
  const bytes2 = [];
  for (let i = 0; i < str.length; ++i) {
    bytes2.push(str.charCodeAt(i));
  }
  return bytes2;
}
const DNS$2 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
v35$5.DNS = DNS$2;
const URL$3 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
v35$5.URL = URL$3;
function v35$4(name2, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes$2(value);
    }
    if (typeof namespace === "string") {
      namespace = (0, _parse$2.default)(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes2[i];
      }
      return buf;
    }
    return (0, _stringify$7.unsafeStringify)(bytes2);
  }
  try {
    generateUUID.name = name2;
  } catch (err2) {
  }
  generateUUID.DNS = DNS$2;
  generateUUID.URL = URL$3;
  return generateUUID;
}
var md5$5 = {};
Object.defineProperty(md5$5, "__esModule", {
  value: true
});
md5$5.default = void 0;
function md5$4(bytes2) {
  if (typeof bytes2 === "string") {
    const msg2 = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg2.length);
    for (let i = 0; i < msg2.length; ++i) {
      bytes2[i] = msg2.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray$2(wordsToMd5$2(bytesToWords$2(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray$2(input) {
  const output2 = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output2.push(hex);
  }
  return output2;
}
function getOutputLength$2(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5$2(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength$2(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff$2(a, b, c, d, x[i], 7, -680876936);
    d = md5ff$2(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff$2(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff$2(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff$2(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff$2(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff$2(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff$2(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff$2(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff$2(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff$2(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff$2(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff$2(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff$2(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff$2(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff$2(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg$2(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg$2(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg$2(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg$2(b, c, d, a, x[i], 20, -373897302);
    a = md5gg$2(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg$2(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg$2(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg$2(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg$2(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg$2(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg$2(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg$2(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg$2(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg$2(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg$2(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg$2(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh$2(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh$2(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh$2(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh$2(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh$2(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh$2(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh$2(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh$2(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh$2(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh$2(d, a, b, c, x[i], 11, -358537222);
    c = md5hh$2(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh$2(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh$2(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh$2(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh$2(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh$2(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii$2(a, b, c, d, x[i], 6, -198630844);
    d = md5ii$2(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii$2(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii$2(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii$2(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii$2(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii$2(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii$2(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii$2(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii$2(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii$2(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii$2(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii$2(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii$2(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii$2(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii$2(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd$2(a, olda);
    b = safeAdd$2(b, oldb);
    c = safeAdd$2(c, oldc);
    d = safeAdd$2(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords$2(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output2 = new Uint32Array(getOutputLength$2(length8));
  for (let i = 0; i < length8; i += 8) {
    output2[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output2;
}
function safeAdd$2(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft$2(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn$2(q, a, b, x, s, t) {
  return safeAdd$2(bitRotateLeft$2(safeAdd$2(safeAdd$2(a, q), safeAdd$2(x, t)), s), b);
}
function md5ff$2(a, b, c, d, x, s, t) {
  return md5cmn$2(b & c | ~b & d, a, b, x, s, t);
}
function md5gg$2(a, b, c, d, x, s, t) {
  return md5cmn$2(b & d | c & ~d, a, b, x, s, t);
}
function md5hh$2(a, b, c, d, x, s, t) {
  return md5cmn$2(b ^ c ^ d, a, b, x, s, t);
}
function md5ii$2(a, b, c, d, x, s, t) {
  return md5cmn$2(c ^ (b | ~d), a, b, x, s, t);
}
var _default$x = md5$4;
md5$5.default = _default$x;
Object.defineProperty(v3$5, "__esModule", {
  value: true
});
v3$5.default = void 0;
var _v$5 = _interopRequireDefault$l(v35$5);
var _md$3 = _interopRequireDefault$l(md5$5);
function _interopRequireDefault$l(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const v3$4 = (0, _v$5.default)("v3", 48, _md$3.default);
var _default$w = v3$4;
v3$5.default = _default$w;
var v4$5 = {};
var native$2 = {};
Object.defineProperty(native$2, "__esModule", {
  value: true
});
native$2.default = void 0;
const randomUUID$2 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var _default$v = {
  randomUUID: randomUUID$2
};
native$2.default = _default$v;
Object.defineProperty(v4$5, "__esModule", {
  value: true
});
v4$5.default = void 0;
var _native$2 = _interopRequireDefault$k(native$2);
var _rng$4 = _interopRequireDefault$k(rng$5);
var _stringify$6 = stringify$5;
function _interopRequireDefault$k(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function v4$4(options, buf, offset) {
  if (_native$2.default.randomUUID && !buf && !options) {
    return _native$2.default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || _rng$4.default)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0, _stringify$6.unsafeStringify)(rnds);
}
var _default$u = v4$4;
v4$5.default = _default$u;
var v5$5 = {};
var sha1$5 = {};
Object.defineProperty(sha1$5, "__esModule", {
  value: true
});
sha1$5.default = void 0;
function f$2(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL$2(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1$4(bytes2) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    const msg2 = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (let i = 0; i < msg2.length; ++i) {
      bytes2.push(msg2.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  const l = bytes2.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes2[i * 64 + j * 4] << 24 | bytes2[i * 64 + j * 4 + 1] << 16 | bytes2[i * 64 + j * 4 + 2] << 8 | bytes2[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL$2(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL$2(a, 5) + f$2(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL$2(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var _default$t = sha1$4;
sha1$5.default = _default$t;
Object.defineProperty(v5$5, "__esModule", {
  value: true
});
v5$5.default = void 0;
var _v$4 = _interopRequireDefault$j(v35$5);
var _sha$2 = _interopRequireDefault$j(sha1$5);
function _interopRequireDefault$j(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const v5$4 = (0, _v$4.default)("v5", 80, _sha$2.default);
var _default$s = v5$4;
v5$5.default = _default$s;
var nil$2 = {};
Object.defineProperty(nil$2, "__esModule", {
  value: true
});
nil$2.default = void 0;
var _default$r = "00000000-0000-0000-0000-000000000000";
nil$2.default = _default$r;
var version$6 = {};
Object.defineProperty(version$6, "__esModule", {
  value: true
});
version$6.default = void 0;
var _validate$6 = _interopRequireDefault$i(validate$5);
function _interopRequireDefault$i(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function version$5(uuid) {
  if (!(0, _validate$6.default)(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var _default$q = version$5;
version$6.default = _default$q;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function get() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function get() {
      return _parse2.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function get() {
      return _stringify2.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function get() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function get() {
      return _v22.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function get() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function get() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function get() {
      return _validate2.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function get() {
      return _version.default;
    }
  });
  var _v2 = _interopRequireDefault2(v1$5);
  var _v22 = _interopRequireDefault2(v3$5);
  var _v3 = _interopRequireDefault2(v4$5);
  var _v4 = _interopRequireDefault2(v5$5);
  var _nil = _interopRequireDefault2(nil$2);
  var _version = _interopRequireDefault2(version$6);
  var _validate2 = _interopRequireDefault2(validate$5);
  var _stringify2 = _interopRequireDefault2(stringify$5);
  var _parse2 = _interopRequireDefault2(parse$5);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(commonjsBrowser$2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist(), e = commonjsBrowser$2;
  const s = { EVM_SIGN_REQUEST: new t.RegistryType("evm-sign-request", 4101), EVM_SIGNATURE: new t.RegistryType("evm-signature", 4102) }, { decodeToDataItem: i, RegistryTypes: a } = t.extend;
  var r, n;
  (r = exports.SignDataType || (exports.SignDataType = {}))[r.arbitrary = 1] = "arbitrary", r[r.cosmosAmino = 2] = "cosmosAmino", r[r.cosmosDirect = 3] = "cosmosDirect", function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.dataType = 3] = "dataType", t2[t2.customChainIdentifier = 4] = "customChainIdentifier", t2[t2.derivationPath = 5] = "derivationPath", t2[t2.address = 6] = "address", t2[t2.origin = 7] = "origin";
  }(n || (n = {}));
  class o extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.EVM_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDataype = () => this.dataType, this.getCustomChainIdentifier = () => this.customChainIdentifier, this.getDerivationPath = () => this.derivationPath.getPath(), this.getAddress = () => this.address, this.getOrigin = () => this.origin, this.toDataItem = () => {
        const e3 = {};
        e3[n.requestId] = new t.DataItem(this.requestId, a.UUID.getTag()), e3[n.signData] = this.signData, e3[n.dataType] = this.dataType, e3[n.customChainIdentifier] = this.customChainIdentifier;
        const s2 = this.derivationPath.toDataItem();
        return s2.setTag(this.derivationPath.getRegistryType().getTag()), e3[n.derivationPath] = s2, this.address && (e3[n.address] = this.address), this.origin && (e3[n.origin] = this.origin), new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.dataType = e2.dataType, this.customChainIdentifier = e2.customChainIdentifier, this.derivationPath = e2.derivationPath, this.address = e2.address, this.origin = e2.origin;
    }
    static parsePath(e2, s2) {
      const i2 = e2.replace(/[m|M]\//, "").split("/").map((e3) => {
        const s3 = parseInt(e3.replace("'", ""));
        let i3 = false;
        return e3.endsWith("'") && (i3 = true), new t.PathComponent({ index: s3, hardened: i3 });
      });
      return new t.CryptoKeypath(i2, Buffer$1$1.from(s2, "hex"));
    }
    static constructEvmRequest(t2, s2, i2, a2, r2, n2, d2, g2) {
      return new o({ requestId: Buffer$1$1.from(e.parse(t2)), signData: i2, dataType: a2 || exports.SignDataType.arbitrary, customChainIdentifier: r2, derivationPath: o.parsePath(n2, s2), address: d2, origin: g2 });
    }
  }
  o.fromDataItem = (e2) => {
    const s2 = e2.getData(), i2 = s2[n.requestId] ? s2[n.requestId].getData() : void 0;
    return new o({ requestId: i2, signData: s2[n.signData], dataType: s2[n.dataType], customChainIdentifier: s2[n.customChainIdentifier], derivationPath: t.CryptoKeypath.fromDataItem(s2[n.derivationPath]), address: s2[n.address], origin: s2[n.origin] });
  }, o.fromCBOR = (t2) => {
    const e2 = i(t2);
    return o.fromDataItem(e2);
  };
  const { RegistryTypes: d, decodeToDataItem: g } = t.extend;
  var h;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature";
  }(h || (h = {}));
  class u extends t.RegistryItem {
    constructor(e2, i2) {
      super(), this.getRegistryType = () => s.EVM_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.toDataItem = () => {
        const e3 = {};
        return e3[h.requestId] = new t.DataItem(this.requestId, d.UUID.getTag()), e3[h.signature] = this.signature, new t.DataItem(e3);
      }, this.signature = e2, this.requestId = i2;
    }
  }
  u.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[h.signature], i2 = e2[h.requestId].getData();
    return new u(s2, i2);
  }, u.fromCBOR = (t2) => {
    const e2 = g(t2);
    return u.fromDataItem(e2);
  }, t.patchTags(Object.values(s).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.EvmSignRequest = o, exports.EvmSignature = u;
})(bcUrRegistryEvm_cjs_production_min);
{
  dist$c.exports = bcUrRegistryEvm_cjs_production_min;
}
var distExports$a = dist$c.exports;
Object.defineProperty(evm, "__esModule", { value: true });
evm.KeystoneEvmSDK = void 0;
const utils_1$h = utils$k;
const ur_1$a = ur;
const bc_ur_registry_evm_1 = distExports$a;
class KeystoneEvmSDK {
  constructor(config2) {
    this.config = config2;
  }
  parseSignature(ur2) {
    if (ur2.type !== ur_1$a.URType.EvmSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_evm_1.EvmSignature.fromCBOR(ur2.cbor);
    const requestId = (0, utils_1$h.uuidStringify)(sig.getRequestId());
    return {
      requestId,
      signature: (0, utils_1$h.toHex)(sig.getSignature())
    };
  }
  generateSignRequest({ requestId, signData: signData2, dataType, customChainIdentifier, account: account2, origin: origin2 }) {
    var _a;
    const derivationPath = new bc_ur_registry_evm_1.CryptoKeypath((0, utils_1$h.parsePath)(account2.path).map((e) => new bc_ur_registry_evm_1.PathComponent(e)), (0, utils_1$h.toBuffer)(account2.xfp));
    return new bc_ur_registry_evm_1.EvmSignRequest({
      signData: (0, utils_1$h.toBuffer)(signData2),
      dataType,
      customChainIdentifier,
      derivationPath,
      requestId: (0, utils_1$h.uuidParse)(requestId),
      address: account2.address !== void 0 ? (0, utils_1$h.toBuffer)(account2.address.substring(account2.address.startsWith("0x") ? 2 : 0)) : void 0,
      origin: origin2 !== null && origin2 !== void 0 ? origin2 : (_a = this.config) === null || _a === void 0 ? void 0 : _a.origin
    }).toUR();
  }
}
KeystoneEvmSDK.DataType = bc_ur_registry_evm_1.SignDataType;
evm.KeystoneEvmSDK = KeystoneEvmSDK;
var ethereum = {};
var dist$b = { exports: {} };
var bcUrRegistryEth_cjs_production_min = {};
var basex$1 = src$1;
var ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58$1 = basex$1(ALPHABET$1);
var base58$1 = bs58$1;
var Buffer$1 = safeBufferExports.Buffer;
var base$3 = function(checksumFn) {
  function encode3(payload) {
    var checksum = checksumFn(payload);
    return base58$1.encode(Buffer$1.concat([
      payload,
      checksum
    ], payload.length + 4));
  }
  function decodeRaw(buffer) {
    var payload = buffer.slice(0, -4);
    var checksum = buffer.slice(-4);
    var newChecksum = checksumFn(payload);
    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
    return payload;
  }
  function decodeUnsafe(string) {
    var buffer = base58$1.decodeUnsafe(string);
    if (!buffer) return;
    return decodeRaw(buffer);
  }
  function decode2(string) {
    var buffer = base58$1.decode(string);
    var payload = decodeRaw(buffer);
    if (!payload) throw new Error("Invalid checksum");
    return payload;
  }
  return {
    encode: encode3,
    decode: decode2,
    decodeUnsafe
  };
};
var createHash$2 = browser;
var bs58checkBase$1 = base$3;
function sha256x2$1(buffer) {
  var tmp = createHash$2("sha256").update(buffer).digest();
  return createHash$2("sha256").update(tmp).digest();
}
var bs58check$2 = bs58checkBase$1(sha256x2$1);
const errors = {
  IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
  TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
  TWEAK_MUL: "The tweak was out of range or equal to zero",
  CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
  SECKEY_INVALID: "Private Key is invalid",
  PUBKEY_PARSE: "Public Key could not be parsed",
  PUBKEY_SERIALIZE: "Public Key serialization error",
  PUBKEY_COMBINE: "The sum of the public keys is not valid",
  SIG_PARSE: "Signature could not be parsed",
  SIGN: "The nonce generation function failed, or the private key was invalid",
  RECOVER: "Public key could not be recover",
  ECDH: "Scalar was invalid (zero or overflow)"
};
function assert$g(cond, msg2) {
  if (!cond) throw new Error(msg2);
}
function isUint8Array(name2, value, length) {
  assert$g(value instanceof Uint8Array, `Expected ${name2} to be an Uint8Array`);
  if (length !== void 0) {
    if (Array.isArray(length)) {
      const numbers = length.join(", ");
      const msg2 = `Expected ${name2} to be an Uint8Array with length [${numbers}]`;
      assert$g(length.includes(value.length), msg2);
    } else {
      const msg2 = `Expected ${name2} to be an Uint8Array with length ${length}`;
      assert$g(value.length === length, msg2);
    }
  }
}
function isCompressed(value) {
  assert$g(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
}
function getAssertedOutput(output2 = (len) => new Uint8Array(len), length) {
  if (typeof output2 === "function") output2 = output2(length);
  isUint8Array("output", output2, length);
  return output2;
}
function toTypeString(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
var lib = (secp256k12) => {
  return {
    contextRandomize(seed) {
      assert$g(
        seed === null || seed instanceof Uint8Array,
        "Expected seed to be an Uint8Array or null"
      );
      if (seed !== null) isUint8Array("seed", seed, 32);
      switch (secp256k12.contextRandomize(seed)) {
        case 1:
          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
      }
    },
    privateKeyVerify(seckey) {
      isUint8Array("private key", seckey, 32);
      return secp256k12.privateKeyVerify(seckey) === 0;
    },
    privateKeyNegate(seckey) {
      isUint8Array("private key", seckey, 32);
      switch (secp256k12.privateKeyNegate(seckey)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    },
    privateKeyTweakAdd(seckey, tweak) {
      isUint8Array("private key", seckey, 32);
      isUint8Array("tweak", tweak, 32);
      switch (secp256k12.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors.TWEAK_ADD);
      }
    },
    privateKeyTweakMul(seckey, tweak) {
      isUint8Array("private key", seckey, 32);
      isUint8Array("tweak", tweak, 32);
      switch (secp256k12.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors.TWEAK_MUL);
      }
    },
    publicKeyVerify(pubkey) {
      isUint8Array("public key", pubkey, [33, 65]);
      return secp256k12.publicKeyVerify(pubkey) === 0;
    },
    publicKeyCreate(seckey, compressed = true, output2) {
      isUint8Array("private key", seckey, 32);
      isCompressed(compressed);
      output2 = getAssertedOutput(output2, compressed ? 33 : 65);
      switch (secp256k12.publicKeyCreate(output2, seckey)) {
        case 0:
          return output2;
        case 1:
          throw new Error(errors.SECKEY_INVALID);
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    },
    publicKeyConvert(pubkey, compressed = true, output2) {
      isUint8Array("public key", pubkey, [33, 65]);
      isCompressed(compressed);
      output2 = getAssertedOutput(output2, compressed ? 33 : 65);
      switch (secp256k12.publicKeyConvert(output2, pubkey)) {
        case 0:
          return output2;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    },
    publicKeyNegate(pubkey, compressed = true, output2) {
      isUint8Array("public key", pubkey, [33, 65]);
      isCompressed(compressed);
      output2 = getAssertedOutput(output2, compressed ? 33 : 65);
      switch (secp256k12.publicKeyNegate(output2, pubkey)) {
        case 0:
          return output2;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    },
    publicKeyCombine(pubkeys, compressed = true, output2) {
      assert$g(Array.isArray(pubkeys), "Expected public keys to be an Array");
      assert$g(pubkeys.length > 0, "Expected public keys array will have more than zero items");
      for (const pubkey of pubkeys) {
        isUint8Array("public key", pubkey, [33, 65]);
      }
      isCompressed(compressed);
      output2 = getAssertedOutput(output2, compressed ? 33 : 65);
      switch (secp256k12.publicKeyCombine(output2, pubkeys)) {
        case 0:
          return output2;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.PUBKEY_COMBINE);
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    },
    publicKeyTweakAdd(pubkey, tweak, compressed = true, output2) {
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("tweak", tweak, 32);
      isCompressed(compressed);
      output2 = getAssertedOutput(output2, compressed ? 33 : 65);
      switch (secp256k12.publicKeyTweakAdd(output2, pubkey, tweak)) {
        case 0:
          return output2;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.TWEAK_ADD);
      }
    },
    publicKeyTweakMul(pubkey, tweak, compressed = true, output2) {
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("tweak", tweak, 32);
      isCompressed(compressed);
      output2 = getAssertedOutput(output2, compressed ? 33 : 65);
      switch (secp256k12.publicKeyTweakMul(output2, pubkey, tweak)) {
        case 0:
          return output2;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.TWEAK_MUL);
      }
    },
    signatureNormalize(sig) {
      isUint8Array("signature", sig, 64);
      switch (secp256k12.signatureNormalize(sig)) {
        case 0:
          return sig;
        case 1:
          throw new Error(errors.SIG_PARSE);
      }
    },
    signatureExport(sig, output2) {
      isUint8Array("signature", sig, 64);
      output2 = getAssertedOutput(output2, 72);
      const obj = { output: output2, outputlen: 72 };
      switch (secp256k12.signatureExport(obj, sig)) {
        case 0:
          return output2.slice(0, obj.outputlen);
        case 1:
          throw new Error(errors.SIG_PARSE);
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    },
    signatureImport(sig, output2) {
      isUint8Array("signature", sig);
      output2 = getAssertedOutput(output2, 64);
      switch (secp256k12.signatureImport(output2, sig)) {
        case 0:
          return output2;
        case 1:
          throw new Error(errors.SIG_PARSE);
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    },
    ecdsaSign(msg32, seckey, options = {}, output2) {
      isUint8Array("message", msg32, 32);
      isUint8Array("private key", seckey, 32);
      assert$g(toTypeString(options) === "Object", "Expected options to be an Object");
      if (options.data !== void 0) isUint8Array("options.data", options.data);
      if (options.noncefn !== void 0) assert$g(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
      output2 = getAssertedOutput(output2, 64);
      const obj = { signature: output2, recid: null };
      switch (secp256k12.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj;
        case 1:
          throw new Error(errors.SIGN);
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    },
    ecdsaVerify(sig, msg32, pubkey) {
      isUint8Array("signature", sig, 64);
      isUint8Array("message", msg32, 32);
      isUint8Array("public key", pubkey, [33, 65]);
      switch (secp256k12.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true;
        case 3:
          return false;
        case 1:
          throw new Error(errors.SIG_PARSE);
        case 2:
          throw new Error(errors.PUBKEY_PARSE);
      }
    },
    ecdsaRecover(sig, recid, msg32, compressed = true, output2) {
      isUint8Array("signature", sig, 64);
      assert$g(
        toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
        "Expected recovery id to be a Number within interval [0, 3]"
      );
      isUint8Array("message", msg32, 32);
      isCompressed(compressed);
      output2 = getAssertedOutput(output2, compressed ? 33 : 65);
      switch (secp256k12.ecdsaRecover(output2, sig, recid, msg32)) {
        case 0:
          return output2;
        case 1:
          throw new Error(errors.SIG_PARSE);
        case 2:
          throw new Error(errors.RECOVER);
        case 3:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    },
    ecdh(pubkey, seckey, options = {}, output2) {
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("private key", seckey, 32);
      assert$g(toTypeString(options) === "Object", "Expected options to be an Object");
      if (options.data !== void 0) isUint8Array("options.data", options.data);
      if (options.hashfn !== void 0) {
        assert$g(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
        if (options.xbuf !== void 0) isUint8Array("options.xbuf", options.xbuf, 32);
        if (options.ybuf !== void 0) isUint8Array("options.ybuf", options.ybuf, 32);
        isUint8Array("output", output2);
      } else {
        output2 = getAssertedOutput(output2, 32);
      }
      switch (secp256k12.ecdh(output2, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output2;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.ECDH);
      }
    }
  };
};
var elliptic$2 = {};
const name = "elliptic";
const version$4 = "6.6.0";
const description = "EC cryptography";
const main = "lib/elliptic.js";
const files = [
  "lib"
];
const scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
};
const repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
};
const keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
];
const author = "Fedor Indutny <fedor@indutny.com>";
const license = "MIT";
const bugs = {
  url: "https://github.com/indutny/elliptic/issues"
};
const homepage = "https://github.com/indutny/elliptic";
const devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
};
const dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
};
const require$$0$1 = {
  name,
  version: version$4,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$g = {};
var bn = { exports: {} };
bn.exports;
(function(module) {
  (function(module2, exports) {
    function assert2(val, msg2) {
      if (!val) throw new Error(msg2 || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base2, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number2 || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$3.Buffer;
      }
    } catch (e) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };
    BN2.prototype._init = function init(number2, base2, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base2, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base2 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base2, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le") return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base2, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
          w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number2.length; i += 3) {
          w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits(string, index2) {
      var c = string.charCodeAt(index2);
      if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        return c - 48 & 15;
      }
    }
    function parseHexByte2(string, lowerBound, index2) {
      var r = parseHex4Bits(string, index2);
      if (index2 - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index2 - 1) << 4;
      }
      return r;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number2.length - 1; i >= start; i -= 2) {
          w = parseHexByte2(number2, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
          w = parseHexByte2(number2, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase(str, start, end, mul5) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul5;
        if (c >= 49) {
          r += c - 49 + 10;
        } else if (c >= 17) {
          r += c - 17 + 10;
        } else {
          r += c;
        }
      }
      return r;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number2.length - start;
      var mod2 = total % limbLen;
      var end = Math.min(total, total - mod2) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number2, i, i + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod2 !== 0) {
        var pow3 = 1;
        word = parseBase(number2, i, number2.length, base2);
        for (i = 0; i < mod2; i++) {
          pow3 *= base2;
        }
        this.imuln(pow3);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this.strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN2.prototype.clone = function clone() {
      var r = new BN2(null);
      this.copy(r);
      return r;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN2.prototype.inspect = function inspect6() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base2, padding) {
      base2 = base2 || 10;
      padding = padding | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base2);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON2() {
      return this.toString(16);
    };
    BN2.prototype.toBuffer = function toBuffer(endian, length) {
      assert2(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length);
    };
    BN2.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b, i;
      var q = this.clone();
      if (!littleEndian) {
        for (i = 0; i < reqLength - byteLength; i++) {
          res[i] = 0;
        }
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[reqLength - i - 1] = b;
        }
      } else {
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[i] = b;
        }
        for (; i < reqLength; i++) {
          res[i] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0) return 26;
      var t = w;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }
      return w;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) return 0;
      var r = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26) break;
      }
      return r;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg4() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this.strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length) return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this.strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length) return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this.strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add6(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN2.prototype._countBits(N) - 1;
      for (var i = 0; i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1) return x;
      var rb = 0;
      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0; i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s = 1; s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0; p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0; j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0; N; N = N >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1) return;
      for (var i = 0; i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;
      for (var i = 0; i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;
      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i = 2 * len; i < N; ++i) {
        rws[i] = 0;
      }
      assert2(carry === 0);
      assert2((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);
      for (var i = 0; i < N; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _ = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);
      for (var i = 0; i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    };
    BN2.prototype.mul = function mul5(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow3(num) {
      var w = toBitArray(num);
      if (w.length === 0) return new BN2(1);
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0) break;
      }
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0) continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0; i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this.strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask2 = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) ;
      else if (this.length > s) {
        this.length -= s;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask2;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) return false;
      var w = this.words[s];
      return !!(w & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask2 = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask2;
      }
      return this.strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0) return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0) return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul5, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul5;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0) return this.strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m = a.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q.strip();
      }
      a.strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod2, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.iadd(num);
          }
        }
        return {
          div,
          mod: mod2
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod2
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod2(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero()) return dm.div;
      var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod2.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modn = function modn(num) {
      assert2(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return acc;
    };
    BN2.prototype.idivn = function idivn(num) {
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      return this.strip();
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D = new BN2(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i = s; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative) return -1;
      if (this.negative === 0 && negative) return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0) return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0) return -1;
      if (this.negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0) return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length) return 1;
      if (this.length < num.length) return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq6(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p) {
      this.name = name2;
      this.p = new BN2(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== void 0) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split2(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split2(input, output2) {
      var mask2 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output2.words[i] = input.words[i];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output2.words[output2.length++] = prev & mask2;
      for (i = 10; i < input.length; i++) {
        var next2 = input.words[i] | 0;
        input.words[i - 10] = (next2 & mask2) << 4 | prev >>> 22;
        prev = next2;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2]) return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN2._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert2((a.negative | b.negative) === 0, "red works only with positives");
      assert2(
        a.red && a.red === b.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime) return this.prime.ireduce(a)._forceRed(this);
      return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg4(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add6(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul5(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero()) return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow3 = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow3);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m);
        var b = this.pow(c, new BN2(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow3(a, num) {
      if (num.isZero()) return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0) return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul5(a, b) {
      if (a.isZero() || b.isZero()) return new BN2(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
(function(exports) {
  var utils2 = exports;
  var BN2 = bnExports;
  var minAssert = minimalisticAssert;
  var minUtils = utils$l;
  utils2.assert = minAssert;
  utils2.toArray = minUtils.toArray;
  utils2.zero2 = minUtils.zero2;
  utils2.toHex = minUtils.toHex;
  utils2.encode = minUtils.encode;
  function getNAF2(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    var i;
    for (i = 0; i < naf.length; i += 1) {
      naf[i] = 0;
    }
    var ws = 1 << w + 1;
    var k = num.clone();
    for (i = 0; i < naf.length; i++) {
      var z;
      var mod2 = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod2 > (ws >> 1) - 1)
          z = (ws >> 1) - mod2;
        else
          z = mod2;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty2(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty3() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty2;
  function parseBytes2(bytes2) {
    return typeof bytes2 === "string" ? utils2.toArray(bytes2, "hex") : bytes2;
  }
  utils2.parseBytes = parseBytes2;
  function intFromLE(bytes2) {
    return new BN2(bytes2, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
})(utils$g);
var curve$2 = {};
var BN$8 = bnExports;
var utils$f = utils$g;
var getNAF = utils$f.getNAF;
var getJSF = utils$f.getJSF;
var assert$f = utils$f.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$8(conf.p, 16);
  this.red = conf.prime ? BN$8.red(conf.prime) : BN$8.mont(this.p);
  this.zero = new BN$8(0).toRed(this.red);
  this.one = new BN$8(1).toRed(this.red);
  this.two = new BN$8(2).toRed(this.red);
  this.n = conf.n && new BN$8(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$2 = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$f(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k, w, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);
    if (i < 0)
      break;
    var z = naf[i];
    assert$f(z !== 0);
    if (p.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b]
      /* 7 */
    ];
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index2 = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index2[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero2 = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero2 = false;
      }
      if (!zero2)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve2, type) {
  this.curve = curve2;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
  bytes2 = utils$f.toArray(bytes2, enc);
  var len = this.p.byteLength();
  if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len) {
    if (bytes2[0] === 6)
      assert$f(bytes2[bytes2.length - 1] % 2 === 0);
    else if (bytes2[0] === 7)
      assert$f(bytes2[bytes2.length - 1] % 2 === 1);
    var res = this.point(
      bytes2.slice(1, 1 + len),
      bytes2.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len) {
    return this.pointFromX(bytes2.slice(1, 1 + len), bytes2[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
  return utils$f.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl5 = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl5);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};
var utils$e = utils$g;
var BN$7 = bnExports;
var inherits$2 = inherits_browserExports;
var Base$3 = base$2;
var assert$e = utils$e.assert;
function ShortCurve(conf) {
  Base$3.call(this, "short", conf);
  this.a = new BN$7(conf.a, 16).toRed(this.red);
  this.b = new BN$7(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits$2(ShortCurve, Base$3);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$7(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$7(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$e(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$7(vec.a, 16),
        b: new BN$7(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN$7.mont(num);
  var tinv = new BN$7(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new BN$7(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN$7(1);
  var y1 = new BN$7(0);
  var x2 = new BN$7(0);
  var y2 = new BN$7(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v12 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v12.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v12.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v12.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$7(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
ShortCurve.prototype.validate = function validate3(point5) {
  if (point5.inf)
    return true;
  var x = point5.x;
  var y = point5.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split2 = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split2.k1.negative) {
      split2.k1.ineg();
      p = p.neg(true);
    }
    if (split2.k2.negative) {
      split2.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split2.k1;
    ncoeffs[i * 2 + 1] = split2.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point$2(curve2, x, y, isRed) {
  Base$3.BasePoint.call(this, curve2, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$7(x, 16);
    this.y = new BN$7(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits$2(Point$2, Base$3.BasePoint);
ShortCurve.prototype.point = function point2(x, y, isRed) {
  return new Point$2(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point$2.fromJSON(this, obj, red);
};
Point$2.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve2 = this.curve;
    var endoMul = function(p) {
      return curve2.point(p.x.redMul(curve2.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point$2.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point$2.fromJSON = function fromJSON(curve2, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve2.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve2.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point$2.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point$2.prototype.add = function add(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$2.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$2.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function mul(k) {
  k = new BN$7(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point$2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point$2.prototype.eq = function eq2(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point$2.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate2 = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate2)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate2)
      }
    };
  }
  return res;
};
Point$2.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve2, x, y, z) {
  Base$3.BasePoint.call(this, curve2, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$7(0);
  } else {
    this.x = new BN$7(x, 16);
    this.y = new BN$7(y, 16);
    this.z = new BN$7(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits$2(JPoint, Base$3.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow3) {
  if (pow3 === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow3)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow3; i++)
      r = r.dbl();
    return r;
  }
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow3; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow3)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx);
    var t = m.redSqr().redISub(s).redISub(s);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = b.redSqr();
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    var e = a.redAdd(a).redIAdd(a);
    var f2 = e.redSqr();
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d).redISub(d);
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m.redSqr().redISub(s).redISub(s);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m = xx.redAdd(xx).redIAdd(xx);
  var mm = m.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k, kbase) {
  k = new BN$7(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq3(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var BN$6 = bnExports;
var inherits$1 = inherits_browserExports;
var Base$2 = base$2;
var utils$d = utils$g;
function MontCurve(conf) {
  Base$2.call(this, "mont", conf);
  this.a = new BN$6(conf.a, 16).toRed(this.red);
  this.b = new BN$6(conf.b, 16).toRed(this.red);
  this.i4 = new BN$6(4).toRed(this.red).redInvm();
  this.two = new BN$6(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$1(MontCurve, Base$2);
var mont = MontCurve;
MontCurve.prototype.validate = function validate4(point5) {
  var x = point5.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();
  return y.redSqr().cmp(rhs) === 0;
};
function Point$1(curve2, x, z) {
  Base$2.BasePoint.call(this, curve2, "projective");
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN$6(x, 16);
    this.z = new BN$6(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits$1(Point$1, Base$2.BasePoint);
MontCurve.prototype.decodePoint = function decodePoint2(bytes2, enc) {
  return this.point(utils$d.toArray(bytes2, enc), 1);
};
MontCurve.prototype.point = function point3(x, z) {
  return new Point$1(this, x, z);
};
MontCurve.prototype.pointFromJSON = function pointFromJSON2(obj) {
  return Point$1.fromJSON(this, obj);
};
Point$1.prototype.precompute = function precompute2() {
};
Point$1.prototype._encode = function _encode2() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function fromJSON2(curve2, obj) {
  return new Point$1(curve2, obj[0], obj[1] || curve2.one);
};
Point$1.prototype.inspect = function inspect3() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function isInfinity3() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function dbl3() {
  var a = this.x.redAdd(this.z);
  var aa = a.redSqr();
  var b = this.x.redSub(this.z);
  var bb = b.redSqr();
  var c = aa.redSub(bb);
  var nx = aa.redMul(bb);
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};
Point$1.prototype.add = function add3() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function diffAdd(p, diff) {
  var a = this.x.redAdd(this.z);
  var b = this.x.redSub(this.z);
  var c = p.x.redAdd(p.z);
  var d = p.x.redSub(p.z);
  var da = d.redMul(a);
  var cb = c.redMul(b);
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};
Point$1.prototype.mul = function mul3(k) {
  var t = k.clone();
  var a = this;
  var b = this.curve.point(null, null);
  var c = this;
  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));
  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      a = a.diffAdd(b, c);
      b = b.dbl();
    } else {
      b = a.diffAdd(b, c);
      a = a.dbl();
    }
  }
  return b;
};
Point$1.prototype.mulAdd = function mulAdd2() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function jumlAdd() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function eq4(other) {
  return this.getX().cmp(other.getX()) === 0;
};
Point$1.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};
Point$1.prototype.getX = function getX2() {
  this.normalize();
  return this.x.fromRed();
};
var utils$c = utils$g;
var BN$5 = bnExports;
var inherits = inherits_browserExports;
var Base$1 = base$2;
var assert$d = utils$c.assert;
function EdwardsCurve(conf) {
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;
  Base$1.call(this, "edwards", conf);
  this.a = new BN$5(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN$5(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN$5(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);
  assert$d(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base$1);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};
EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};
EdwardsCurve.prototype.jpoint = function jpoint2(x, y, z, t) {
  return this.point(x, y, z, t);
};
EdwardsCurve.prototype.pointFromX = function pointFromX2(x, odd) {
  x = new BN$5(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN$5(y, 16);
  if (!y.red)
    y = y.toRed(this.red);
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());
  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error("invalid point");
    else
      return this.point(this.zero, y);
  }
  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();
  return this.point(x, y);
};
EdwardsCurve.prototype.validate = function validate5(point5) {
  if (point5.isInfinity())
    return true;
  point5.normalize();
  var x2 = point5.x.redSqr();
  var y2 = point5.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
  return lhs.cmp(rhs) === 0;
};
function Point(curve2, x, y, z, t) {
  Base$1.BasePoint.call(this, curve2, "projective");
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN$5(x, 16);
    this.y = new BN$5(y, 16);
    this.z = z ? new BN$5(z, 16) : this.curve.one;
    this.t = t && new BN$5(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base$1.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function pointFromJSON3(obj) {
  return Point.fromJSON(this, obj);
};
EdwardsCurve.prototype.point = function point4(x, y, z, t) {
  return new Point(this, x, y, z, t);
};
Point.fromJSON = function fromJSON3(curve2, obj) {
  return new Point(curve2, obj[0], obj[1], obj[2]);
};
Point.prototype.inspect = function inspect4() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity4() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function _extDbl() {
  var a = this.x.redSqr();
  var b = this.y.redSqr();
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  var d = this.curve._mulA(a);
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  var g = d.redAdd(b);
  var f2 = g.redSub(c);
  var h = d.redSub(b);
  var nx = e.redMul(f2);
  var ny = g.redMul(h);
  var nt = e.redMul(h);
  var nz = f2.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projDbl = function _projDbl() {
  var b = this.x.redAdd(this.y).redSqr();
  var c = this.x.redSqr();
  var d = this.y.redSqr();
  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    e = this.curve._mulA(c);
    var f2 = e.redAdd(d);
    if (this.zOne) {
      nx = b.redSub(c).redSub(d).redMul(f2.redSub(this.curve.two));
      ny = f2.redMul(e.redSub(d));
      nz = f2.redSqr().redSub(f2).redSub(f2);
    } else {
      h = this.z.redSqr();
      j = f2.redSub(h).redISub(h);
      nx = b.redSub(c).redISub(d).redMul(j);
      ny = f2.redMul(e.redSub(d));
      nz = f2.redMul(j);
    }
  } else {
    e = c.redAdd(d);
    h = this.curve._mulC(this.z).redSqr();
    j = e.redSub(h).redSub(h);
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.dbl = function dbl4() {
  if (this.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};
Point.prototype._extAdd = function _extAdd(p) {
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  var d = this.z.redMul(p.z.redAdd(p.z));
  var e = b.redSub(a);
  var f2 = d.redSub(c);
  var g = d.redAdd(c);
  var h = b.redAdd(a);
  var nx = e.redMul(f2);
  var ny = g.redMul(h);
  var nt = e.redMul(h);
  var nz = f2.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projAdd = function _projAdd(p) {
  var a = this.z.redMul(p.z);
  var b = a.redSqr();
  var c = this.x.redMul(p.x);
  var d = this.y.redMul(p.y);
  var e = this.curve.d.redMul(c).redMul(d);
  var f2 = b.redSub(e);
  var g = b.redAdd(e);
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f2).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    nz = f2.redMul(g);
  } else {
    ny = a.redMul(g).redMul(d.redSub(c));
    nz = this.curve._mulC(f2).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.add = function add4(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};
Point.prototype.mul = function mul4(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd3(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
};
Point.prototype.jmulAdd = function jmulAdd2(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
};
Point.prototype.normalize = function normalize2() {
  if (this.zOne)
    return this;
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};
Point.prototype.neg = function neg3() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function getX3() {
  this.normalize();
  return this.x.fromRed();
};
Point.prototype.getY = function getY2() {
  this.normalize();
  return this.y.fromRed();
};
Point.prototype.eq = function eq5(other) {
  return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
Point.prototype.eqXToP = function eqXToP2(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(exports) {
  var curve2 = exports;
  curve2.base = base$2;
  curve2.short = short;
  curve2.mont = mont;
  curve2.edwards = edwards;
})(curve$2);
var curves$2 = {};
var secp256k1$3;
var hasRequiredSecp256k1;
function requireSecp256k1() {
  if (hasRequiredSecp256k1) return secp256k1$3;
  hasRequiredSecp256k1 = 1;
  secp256k1$3 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
  return secp256k1$3;
}
(function(exports) {
  var curves2 = exports;
  var hash3 = hash$3;
  var curve2 = curve$2;
  var utils2 = utils$g;
  var assert2 = utils2.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve2.short(options);
    else if (options.type === "edwards")
      this.curve = new curve2.edwards(options);
    else
      this.curve = new curve2.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves2.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves2, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve3 = new PresetCurve(options);
        Object.defineProperty(curves2, name2, {
          configurable: true,
          enumerable: true,
          value: curve3
        });
        return curve3;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash3.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash3.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = requireSecp256k1();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash3.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
})(curves$2);
var BN$4 = bnExports;
var utils$b = utils$g;
var assert$c = utils$b.assert;
function KeyPair$3(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$1 = KeyPair$3;
KeyPair$3.fromPublic = function fromPublic(ec2, pub2, enc) {
  if (pub2 instanceof KeyPair$3)
    return pub2;
  return new KeyPair$3(ec2, {
    pub: pub2,
    pubEnc: enc
  });
};
KeyPair$3.fromPrivate = function fromPrivate(ec2, priv2, enc) {
  if (priv2 instanceof KeyPair$3)
    return priv2;
  return new KeyPair$3(ec2, {
    priv: priv2,
    privEnc: enc
  });
};
KeyPair$3.prototype.validate = function validate6() {
  var pub2 = this.getPublic();
  if (pub2.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub2.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub2.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair$3.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$4(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$3.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$c(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$c(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair$3.prototype.derive = function derive(pub2) {
  if (!pub2.validate()) {
    assert$c(pub2.validate(), "public point not validated");
  }
  return pub2.mul(this.priv).getX();
};
KeyPair$3.prototype.sign = function sign(msg2, enc, options) {
  return this.ec.sign(msg2, this, enc, options);
};
KeyPair$3.prototype.verify = function verify(msg2, signature2, options) {
  return this.ec.verify(msg2, signature2, this, void 0, options);
};
KeyPair$3.prototype.inspect = function inspect5() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$3 = bnExports;
var utils$a = utils$g;
var assert$b = utils$a.assert;
function Signature$3(options, enc) {
  if (options instanceof Signature$3)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$b(options.r && options.s, "Signature without r or s");
  this.r = new BN$3(options.r, 16);
  this.s = new BN$3(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$3 = Signature$3;
function Position() {
  this.place = 0;
}
function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  if (buf[p.place] === 0) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature$3.prototype._importDER = function _importDER(data, enc) {
  data = utils$a.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 48) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  if ((data[p.place] & 128) !== 0) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  if ((data[p.place] & 128) !== 0) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 128) {
      r = r.slice(1);
    } else {
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 128) {
      s = s.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$3(r);
  this.s = new BN$3(s);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature$3.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();
  if (r[0] & 128)
    r = [0].concat(r);
  if (s[0] & 128)
    s = [0].concat(s);
  r = rmPadding(r);
  s = rmPadding(s);
  while (!s[0] && !(s[1] & 128)) {
    s = s.slice(1);
  }
  var arr = [2];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(2);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils$a.encode(res, enc);
};
var BN$2 = bnExports;
var HmacDRBG = hmacDrbg;
var utils$9 = utils$g;
var curves$1 = curves$2;
var rand = requireBrorand();
var assert$a = utils$9.assert;
var KeyPair$2 = key$1;
var Signature$2 = signature$3;
function EC$1(options) {
  if (!(this instanceof EC$1))
    return new EC$1(options);
  if (typeof options === "string") {
    assert$a(
      Object.prototype.hasOwnProperty.call(curves$1, options),
      "Unknown curve " + options
    );
    options = curves$1[options];
  }
  if (options instanceof curves$1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec$1 = EC$1;
EC$1.prototype.keyPair = function keyPair(options) {
  return new KeyPair$2(this, options);
};
EC$1.prototype.keyFromPrivate = function keyFromPrivate(priv2, enc) {
  return KeyPair$2.fromPrivate(this, priv2, enc);
};
EC$1.prototype.keyFromPublic = function keyFromPublic(pub2, enc) {
  return KeyPair$2.fromPublic(this, pub2, enc);
};
EC$1.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes2 = this.n.byteLength();
  var ns2 = this.n.sub(new BN$2(2));
  for (; ; ) {
    var priv2 = new BN$2(drbg.generate(bytes2));
    if (priv2.cmp(ns2) > 0)
      continue;
    priv2.iaddn(1);
    return this.keyFromPrivate(priv2);
  }
};
EC$1.prototype._truncateToN = function _truncateToN(msg2, truncOnly, bitLength) {
  var byteLength;
  if (BN$2.isBN(msg2) || typeof msg2 === "number") {
    msg2 = new BN$2(msg2, 16);
    byteLength = msg2.byteLength();
  } else if (typeof msg2 === "object") {
    byteLength = msg2.length;
    msg2 = new BN$2(msg2, 16);
  } else {
    var str = msg2.toString();
    byteLength = str.length + 1 >>> 1;
    msg2 = new BN$2(str, 16);
  }
  if (typeof bitLength !== "number") {
    bitLength = byteLength * 8;
  }
  var delta = bitLength - this.n.bitLength();
  if (delta > 0)
    msg2 = msg2.ushrn(delta);
  if (!truncOnly && msg2.cmp(this.n) >= 0)
    return msg2.sub(this.n);
  else
    return msg2;
};
EC$1.prototype.sign = function sign2(msg2, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg2 = this._truncateToN(msg2, false, options.msgBitLength);
  var bytes2 = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes2);
  var nonce2 = msg2.toArray("be", bytes2);
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce2,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$2(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new BN$2(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;
    var s = k.invm(this.n).mul(r.mul(key2.getPrivate()).iadd(msg2));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }
    return new Signature$2({ r, s, recoveryParam });
  }
};
EC$1.prototype.verify = function verify2(msg2, signature2, key2, enc, options) {
  if (!options)
    options = {};
  msg2 = this._truncateToN(msg2, false, options.msgBitLength);
  key2 = this.keyFromPublic(key2, enc);
  signature2 = new Signature$2(signature2, "hex");
  var r = signature2.r;
  var s = signature2.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg2).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  }
  p = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p.isInfinity())
    return false;
  return p.eqXToP(r);
};
EC$1.prototype.recoverPubKey = function(msg2, signature2, j, enc) {
  assert$a((3 & j) === j, "The recovery param is more than two bits");
  signature2 = new Signature$2(signature2, enc);
  var n = this.n;
  var e = new BN$2(msg2);
  var r = signature2.r;
  var s = signature2.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature2.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r, s2);
};
EC$1.prototype.getKeyRecoveryParam = function(e, signature2, Q, enc) {
  signature2 = new Signature$2(signature2, enc);
  if (signature2.recoveryParam !== null)
    return signature2.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature2, i);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var utils$8 = utils$g;
var assert$9 = utils$8.assert;
var parseBytes$2 = utils$8.parseBytes;
var cachedProperty$1 = utils$8.cachedProperty;
function KeyPair$1(eddsa2, params) {
  this.eddsa = eddsa2;
  this._secret = parseBytes$2(params.secret);
  if (eddsa2.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes$2(params.pub);
}
KeyPair$1.fromPublic = function fromPublic2(eddsa2, pub2) {
  if (pub2 instanceof KeyPair$1)
    return pub2;
  return new KeyPair$1(eddsa2, { pub: pub2 });
};
KeyPair$1.fromSecret = function fromSecret(eddsa2, secret2) {
  if (secret2 instanceof KeyPair$1)
    return secret2;
  return new KeyPair$1(eddsa2, { secret: secret2 });
};
KeyPair$1.prototype.secret = function secret() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function privBytes() {
  var eddsa2 = this.eddsa;
  var hash3 = this.hash();
  var lastIx = eddsa2.encodingLength - 1;
  var a = hash3.slice(0, eddsa2.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;
  return a;
});
cachedProperty$1(KeyPair$1, "priv", function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function sign3(message2) {
  assert$9(this._secret, "KeyPair can only verify");
  return this.eddsa.sign(message2, this);
};
KeyPair$1.prototype.verify = function verify3(message2, sig) {
  return this.eddsa.verify(message2, sig, this);
};
KeyPair$1.prototype.getSecret = function getSecret(enc) {
  assert$9(this._secret, "KeyPair is public only");
  return utils$8.encode(this.secret(), enc);
};
KeyPair$1.prototype.getPublic = function getPublic2(enc) {
  return utils$8.encode(this.pubBytes(), enc);
};
var key = KeyPair$1;
var BN$1 = bnExports;
var utils$7 = utils$g;
var assert$8 = utils$7.assert;
var cachedProperty = utils$7.cachedProperty;
var parseBytes$1 = utils$7.parseBytes;
function Signature$1(eddsa2, sig) {
  this.eddsa = eddsa2;
  if (typeof sig !== "object")
    sig = parseBytes$1(sig);
  if (Array.isArray(sig)) {
    assert$8(sig.length === eddsa2.encodingLength * 2, "Signature has invalid size");
    sig = {
      R: sig.slice(0, eddsa2.encodingLength),
      S: sig.slice(eddsa2.encodingLength)
    };
  }
  assert$8(sig.R && sig.S, "Signature without R or S");
  if (eddsa2.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN$1)
    this._S = sig.S;
  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
cachedProperty(Signature$1, "S", function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function toHex() {
  return utils$7.encode(this.toBytes(), "hex").toUpperCase();
};
var signature$2 = Signature$1;
var hash$2 = hash$3;
var curves = curves$2;
var utils$6 = utils$g;
var assert$7 = utils$6.assert;
var parseBytes = utils$6.parseBytes;
var KeyPair = key;
var Signature = signature$2;
function EDDSA(curve2) {
  assert$7(curve2 === "ed25519", "only tested with ed25519 so far");
  if (!(this instanceof EDDSA))
    return new EDDSA(curve2);
  curve2 = curves[curve2].curve;
  this.curve = curve2;
  this.g = curve2.g;
  this.g.precompute(curve2.n.bitLength() + 1);
  this.pointClass = curve2.point().constructor;
  this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
  this.hash = hash$2.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function sign4(message2, secret2) {
  message2 = parseBytes(message2);
  var key2 = this.keyFromSecret(secret2);
  var r = this.hashInt(key2.messagePrefix(), message2);
  var R2 = this.g.mul(r);
  var Rencoded2 = this.encodePoint(R2);
  var s_ = this.hashInt(Rencoded2, key2.pubBytes(), message2).mul(key2.priv());
  var S2 = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R2, S: S2, Rencoded: Rencoded2 });
};
EDDSA.prototype.verify = function verify4(message2, sig, pub2) {
  message2 = parseBytes(message2);
  sig = this.makeSignature(sig);
  if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
    return false;
  }
  var key2 = this.keyFromPublic(pub2);
  var h = this.hashInt(sig.Rencoded(), key2.pubBytes(), message2);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key2.pub().mul(h));
  return RplusAh.eq(SG);
};
EDDSA.prototype.hashInt = function hashInt() {
  var hash3 = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash3.update(arguments[i]);
  return utils$6.intFromLE(hash3.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function keyFromPublic2(pub2) {
  return KeyPair.fromPublic(this, pub2);
};
EDDSA.prototype.keyFromSecret = function keyFromSecret(secret2) {
  return KeyPair.fromSecret(this, secret2);
};
EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};
EDDSA.prototype.encodePoint = function encodePoint(point5) {
  var enc = point5.getY().toArray("le", this.encodingLength);
  enc[this.encodingLength - 1] |= point5.getX().isOdd() ? 128 : 0;
  return enc;
};
EDDSA.prototype.decodePoint = function decodePoint3(bytes2) {
  bytes2 = utils$6.parseBytes(bytes2);
  var lastIx = bytes2.length - 1;
  var normed = bytes2.slice(0, lastIx).concat(bytes2[lastIx] & ~128);
  var xIsOdd = (bytes2[lastIx] & 128) !== 0;
  var y = utils$6.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};
EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function decodeInt(bytes2) {
  return utils$6.intFromLE(bytes2);
};
EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};
(function(exports) {
  var elliptic2 = exports;
  elliptic2.version = require$$0$1.version;
  elliptic2.utils = utils$g;
  elliptic2.rand = requireBrorand();
  elliptic2.curve = curve$2;
  elliptic2.curves = curves$2;
  elliptic2.ec = ec$1;
  elliptic2.eddsa = eddsa;
})(elliptic$2);
const EC = elliptic$2.ec;
const ec = new EC("secp256k1");
const ecparams = ec.curve;
const BN = ecparams.n.constructor;
function loadCompressedPublicKey(first, xbuf) {
  let x = new BN(xbuf);
  if (x.cmp(ecparams.p) >= 0) return null;
  x = x.toRed(ecparams.red);
  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
  if (first === 3 !== y.isOdd()) y = y.redNeg();
  const x3 = x.redSqr().redIMul(x);
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
  return ec.keyPair({ pub: { x, y } });
}
function loadUncompressedPublicKey(first, xbuf, ybuf) {
  let x = new BN(xbuf);
  let y = new BN(ybuf);
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;
  x = x.toRed(ecparams.red);
  y = y.toRed(ecparams.red);
  if ((first === 6 || first === 7) && y.isOdd() !== (first === 7)) return null;
  const x3 = x.redSqr().redIMul(x);
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
  return ec.keyPair({ pub: { x, y } });
}
function loadPublicKey(pubkey) {
  const first = pubkey[0];
  switch (first) {
    case 2:
    case 3:
      if (pubkey.length !== 33) return null;
      return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
    case 4:
    case 6:
    case 7:
      if (pubkey.length !== 65) return null;
      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
    default:
      return null;
  }
}
function savePublicKey(output2, point5) {
  const pubkey = point5.encode(null, output2.length === 33);
  for (let i = 0; i < output2.length; ++i) output2[i] = pubkey[i];
}
var elliptic$1 = {
  contextRandomize() {
    return 0;
  },
  privateKeyVerify(seckey) {
    const bn2 = new BN(seckey);
    return bn2.cmp(ecparams.n) < 0 && !bn2.isZero() ? 0 : 1;
  },
  privateKeyNegate(seckey) {
    const bn2 = new BN(seckey);
    const negate2 = ecparams.n.sub(bn2).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
    seckey.set(negate2);
    return 0;
  },
  privateKeyTweakAdd(seckey, tweak) {
    const bn2 = new BN(tweak);
    if (bn2.cmp(ecparams.n) >= 0) return 1;
    bn2.iadd(new BN(seckey));
    if (bn2.cmp(ecparams.n) >= 0) bn2.isub(ecparams.n);
    if (bn2.isZero()) return 1;
    const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
    seckey.set(tweaked);
    return 0;
  },
  privateKeyTweakMul(seckey, tweak) {
    let bn2 = new BN(tweak);
    if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero()) return 1;
    bn2.imul(new BN(seckey));
    if (bn2.cmp(ecparams.n) >= 0) bn2 = bn2.umod(ecparams.n);
    const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
    seckey.set(tweaked);
    return 0;
  },
  publicKeyVerify(pubkey) {
    const pair = loadPublicKey(pubkey);
    return pair === null ? 1 : 0;
  },
  publicKeyCreate(output2, seckey) {
    const bn2 = new BN(seckey);
    if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero()) return 1;
    const point5 = ec.keyFromPrivate(seckey).getPublic();
    savePublicKey(output2, point5);
    return 0;
  },
  publicKeyConvert(output2, pubkey) {
    const pair = loadPublicKey(pubkey);
    if (pair === null) return 1;
    const point5 = pair.getPublic();
    savePublicKey(output2, point5);
    return 0;
  },
  publicKeyNegate(output2, pubkey) {
    const pair = loadPublicKey(pubkey);
    if (pair === null) return 1;
    const point5 = pair.getPublic();
    point5.y = point5.y.redNeg();
    savePublicKey(output2, point5);
    return 0;
  },
  publicKeyCombine(output2, pubkeys) {
    const pairs = new Array(pubkeys.length);
    for (let i = 0; i < pubkeys.length; ++i) {
      pairs[i] = loadPublicKey(pubkeys[i]);
      if (pairs[i] === null) return 1;
    }
    let point5 = pairs[0].getPublic();
    for (let i = 1; i < pairs.length; ++i) point5 = point5.add(pairs[i].pub);
    if (point5.isInfinity()) return 2;
    savePublicKey(output2, point5);
    return 0;
  },
  publicKeyTweakAdd(output2, pubkey, tweak) {
    const pair = loadPublicKey(pubkey);
    if (pair === null) return 1;
    tweak = new BN(tweak);
    if (tweak.cmp(ecparams.n) >= 0) return 2;
    const point5 = pair.getPublic().add(ecparams.g.mul(tweak));
    if (point5.isInfinity()) return 2;
    savePublicKey(output2, point5);
    return 0;
  },
  publicKeyTweakMul(output2, pubkey, tweak) {
    const pair = loadPublicKey(pubkey);
    if (pair === null) return 1;
    tweak = new BN(tweak);
    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;
    const point5 = pair.getPublic().mul(tweak);
    savePublicKey(output2, point5);
    return 0;
  },
  signatureNormalize(sig) {
    const r = new BN(sig.subarray(0, 32));
    const s = new BN(sig.subarray(32, 64));
    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;
    if (s.cmp(ec.nh) === 1) {
      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, "be", 32), 32);
    }
    return 0;
  },
  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureExport(obj, sig) {
    const sigR = sig.subarray(0, 32);
    const sigS = sig.subarray(32, 64);
    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;
    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;
    const { output: output2 } = obj;
    let r = output2.subarray(4, 4 + 33);
    r[0] = 0;
    r.set(sigR, 1);
    let lenR = 33;
    let posR = 0;
    for (; lenR > 1 && r[posR] === 0 && !(r[posR + 1] & 128); --lenR, ++posR) ;
    r = r.subarray(posR);
    if (r[0] & 128) return 1;
    if (lenR > 1 && r[0] === 0 && !(r[1] & 128)) return 1;
    let s = output2.subarray(6 + 33, 6 + 33 + 33);
    s[0] = 0;
    s.set(sigS, 1);
    let lenS = 33;
    let posS = 0;
    for (; lenS > 1 && s[posS] === 0 && !(s[posS + 1] & 128); --lenS, ++posS) ;
    s = s.subarray(posS);
    if (s[0] & 128) return 1;
    if (lenS > 1 && s[0] === 0 && !(s[1] & 128)) return 1;
    obj.outputlen = 6 + lenR + lenS;
    output2[0] = 48;
    output2[1] = obj.outputlen - 2;
    output2[2] = 2;
    output2[3] = r.length;
    output2.set(r, 4);
    output2[4 + lenR] = 2;
    output2[5 + lenR] = s.length;
    output2.set(s, 6 + lenR);
    return 0;
  },
  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureImport(output2, sig) {
    if (sig.length < 8) return 1;
    if (sig.length > 72) return 1;
    if (sig[0] !== 48) return 1;
    if (sig[1] !== sig.length - 2) return 1;
    if (sig[2] !== 2) return 1;
    const lenR = sig[3];
    if (lenR === 0) return 1;
    if (5 + lenR >= sig.length) return 1;
    if (sig[4 + lenR] !== 2) return 1;
    const lenS = sig[5 + lenR];
    if (lenS === 0) return 1;
    if (6 + lenR + lenS !== sig.length) return 1;
    if (sig[4] & 128) return 1;
    if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128)) return 1;
    if (sig[lenR + 6] & 128) return 1;
    if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128)) return 1;
    let sigR = sig.subarray(4, 4 + lenR);
    if (sigR.length === 33 && sigR[0] === 0) sigR = sigR.subarray(1);
    if (sigR.length > 32) return 1;
    let sigS = sig.subarray(6 + lenR);
    if (sigS.length === 33 && sigS[0] === 0) sigS = sigS.slice(1);
    if (sigS.length > 32) throw new Error("S length is too long");
    let r = new BN(sigR);
    if (r.cmp(ecparams.n) >= 0) r = new BN(0);
    let s = new BN(sig.subarray(6 + lenR));
    if (s.cmp(ecparams.n) >= 0) s = new BN(0);
    output2.set(r.toArrayLike(Uint8Array, "be", 32), 0);
    output2.set(s.toArrayLike(Uint8Array, "be", 32), 32);
    return 0;
  },
  ecdsaSign(obj, message2, seckey, data, noncefn) {
    if (noncefn) {
      const _noncefn = noncefn;
      noncefn = (counter) => {
        const nonce2 = _noncefn(message2, seckey, null, data, counter);
        const isValid = nonce2 instanceof Uint8Array && nonce2.length === 32;
        if (!isValid) throw new Error("This is the way");
        return new BN(nonce2);
      };
    }
    const d = new BN(seckey);
    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;
    let sig;
    try {
      sig = ec.sign(message2, seckey, { canonical: true, k: noncefn, pers: data });
    } catch (err2) {
      return 1;
    }
    obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
    obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
    obj.recid = sig.recoveryParam;
    return 0;
  },
  ecdsaVerify(sig, msg32, pubkey) {
    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
    const sigr = new BN(sigObj.r);
    const sigs = new BN(sigObj.s);
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;
    const pair = loadPublicKey(pubkey);
    if (pair === null) return 2;
    const point5 = pair.getPublic();
    const isValid = ec.verify(msg32, sigObj, point5);
    return isValid ? 0 : 3;
  },
  ecdsaRecover(output2, sig, recid, msg32) {
    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
    const sigr = new BN(sigObj.r);
    const sigs = new BN(sigObj.s);
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
    if (sigr.isZero() || sigs.isZero()) return 2;
    let point5;
    try {
      point5 = ec.recoverPubKey(msg32, sigObj, recid);
    } catch (err2) {
      return 2;
    }
    savePublicKey(output2, point5);
    return 0;
  },
  ecdh(output2, pubkey, seckey, data, hashfn, xbuf, ybuf) {
    const pair = loadPublicKey(pubkey);
    if (pair === null) return 1;
    const scalar2 = new BN(seckey);
    if (scalar2.cmp(ecparams.n) >= 0 || scalar2.isZero()) return 2;
    const point5 = pair.getPublic().mul(scalar2);
    if (hashfn === void 0) {
      const data2 = point5.encode(null, true);
      const sha2562 = ec.hash().update(data2).digest();
      for (let i = 0; i < 32; ++i) output2[i] = sha2562[i];
    } else {
      if (!xbuf) xbuf = new Uint8Array(32);
      const x = point5.getX().toArray("be", 32);
      for (let i = 0; i < 32; ++i) xbuf[i] = x[i];
      if (!ybuf) ybuf = new Uint8Array(32);
      const y = point5.getY().toArray("be", 32);
      for (let i = 0; i < 32; ++i) ybuf[i] = y[i];
      const hash3 = hashfn(xbuf, ybuf, data);
      const isValid = hash3 instanceof Uint8Array && hash3.length === output2.length;
      if (!isValid) return 2;
      output2.set(hash3);
    }
    return 0;
  }
};
var elliptic = lib(elliptic$1);
var assert$6 = requireAssert();
var Buffer = safeBufferExports.Buffer;
var crypto$2 = requireCryptoBrowserify();
var bs58check$1 = bs58check$2;
var RIPEMD160 = ripemd160;
var secp256k1$2 = elliptic;
var MASTER_SECRET = Buffer.from("Bitcoin seed", "utf8");
var HARDENED_OFFSET = 2147483648;
var LEN$1 = 78;
var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
function HDKey(versions) {
  this.versions = versions || BITCOIN_VERSIONS;
  this.depth = 0;
  this.index = 0;
  this._privateKey = null;
  this._publicKey = null;
  this.chainCode = null;
  this._fingerprint = 0;
  this.parentFingerprint = 0;
}
Object.defineProperty(HDKey.prototype, "fingerprint", { get: function() {
  return this._fingerprint;
} });
Object.defineProperty(HDKey.prototype, "identifier", { get: function() {
  return this._identifier;
} });
Object.defineProperty(HDKey.prototype, "pubKeyHash", { get: function() {
  return this.identifier;
} });
Object.defineProperty(HDKey.prototype, "privateKey", {
  get: function() {
    return this._privateKey;
  },
  set: function(value) {
    assert$6.equal(value.length, 32, "Private key must be 32 bytes.");
    assert$6(secp256k1$2.privateKeyVerify(value) === true, "Invalid private key");
    this._privateKey = value;
    this._publicKey = Buffer.from(secp256k1$2.publicKeyCreate(value, true));
    this._identifier = hash160$1(this.publicKey);
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0);
  }
});
function setPublicKey(hdkey2, publicKey) {
  hdkey2._publicKey = Buffer.from(publicKey);
  hdkey2._identifier = hash160$1(publicKey);
  hdkey2._fingerprint = hdkey2._identifier.slice(0, 4).readUInt32BE(0);
  hdkey2._privateKey = null;
}
Object.defineProperty(HDKey.prototype, "publicKey", {
  get: function() {
    return this._publicKey;
  },
  set: function(value) {
    assert$6(value.length === 33 || value.length === 65, "Public key must be 33 or 65 bytes.");
    assert$6(secp256k1$2.publicKeyVerify(value) === true, "Invalid public key");
    const publicKey = value.length === 65 ? secp256k1$2.publicKeyConvert(value, true) : value;
    setPublicKey(this, publicKey);
  }
});
Object.defineProperty(HDKey.prototype, "privateExtendedKey", {
  get: function() {
    if (this._privateKey) return bs58check$1.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])));
    else return null;
  }
});
Object.defineProperty(HDKey.prototype, "publicExtendedKey", {
  get: function() {
    return bs58check$1.encode(serialize(this, this.versions.public, this.publicKey));
  }
});
HDKey.prototype.derive = function(path) {
  if (path === "m" || path === "M" || path === "m'" || path === "M'") {
    return this;
  }
  var entries = path.split("/");
  var hdkey2 = this;
  entries.forEach(function(c, i) {
    if (i === 0) {
      assert$6(/^[mM]{1}/.test(c), 'Path must start with "m" or "M"');
      return;
    }
    var hardened = c.length > 1 && c[c.length - 1] === "'";
    var childIndex = parseInt(c, 10);
    assert$6(childIndex < HARDENED_OFFSET, "Invalid index");
    if (hardened) childIndex += HARDENED_OFFSET;
    hdkey2 = hdkey2.deriveChild(childIndex);
  });
  return hdkey2;
};
HDKey.prototype.deriveChild = function(index2) {
  var isHardened = index2 >= HARDENED_OFFSET;
  var indexBuffer = Buffer.allocUnsafe(4);
  indexBuffer.writeUInt32BE(index2, 0);
  var data;
  if (isHardened) {
    assert$6(this.privateKey, "Could not derive hardened child key");
    var pk = this.privateKey;
    var zb = Buffer.alloc(1, 0);
    pk = Buffer.concat([zb, pk]);
    data = Buffer.concat([pk, indexBuffer]);
  } else {
    data = Buffer.concat([this.publicKey, indexBuffer]);
  }
  var I = crypto$2.createHmac("sha512", this.chainCode).update(data).digest();
  var IL = I.slice(0, 32);
  var IR = I.slice(32);
  var hd = new HDKey(this.versions);
  if (this.privateKey) {
    try {
      hd.privateKey = Buffer.from(secp256k1$2.privateKeyTweakAdd(Buffer.from(this.privateKey), IL));
    } catch (err2) {
      return this.deriveChild(index2 + 1);
    }
  } else {
    try {
      hd.publicKey = Buffer.from(secp256k1$2.publicKeyTweakAdd(Buffer.from(this.publicKey), IL, true));
    } catch (err2) {
      return this.deriveChild(index2 + 1);
    }
  }
  hd.chainCode = IR;
  hd.depth = this.depth + 1;
  hd.parentFingerprint = this.fingerprint;
  hd.index = index2;
  return hd;
};
HDKey.prototype.sign = function(hash3) {
  return Buffer.from(secp256k1$2.ecdsaSign(Uint8Array.from(hash3), Uint8Array.from(this.privateKey)).signature);
};
HDKey.prototype.verify = function(hash3, signature2) {
  return secp256k1$2.ecdsaVerify(
    Uint8Array.from(signature2),
    Uint8Array.from(hash3),
    Uint8Array.from(this.publicKey)
  );
};
HDKey.prototype.wipePrivateData = function() {
  if (this._privateKey) crypto$2.randomBytes(this._privateKey.length).copy(this._privateKey);
  this._privateKey = null;
  return this;
};
HDKey.prototype.toJSON = function() {
  return {
    xpriv: this.privateExtendedKey,
    xpub: this.publicExtendedKey
  };
};
HDKey.fromMasterSeed = function(seedBuffer, versions) {
  var I = crypto$2.createHmac("sha512", MASTER_SECRET).update(seedBuffer).digest();
  var IL = I.slice(0, 32);
  var IR = I.slice(32);
  var hdkey2 = new HDKey(versions);
  hdkey2.chainCode = IR;
  hdkey2.privateKey = IL;
  return hdkey2;
};
HDKey.fromExtendedKey = function(base58key, versions, skipVerification) {
  versions = versions || BITCOIN_VERSIONS;
  skipVerification = skipVerification || false;
  var hdkey2 = new HDKey(versions);
  var keyBuffer = bs58check$1.decode(base58key);
  var version2 = keyBuffer.readUInt32BE(0);
  assert$6(version2 === versions.private || version2 === versions.public, "Version mismatch: does not match private or public");
  hdkey2.depth = keyBuffer.readUInt8(4);
  hdkey2.parentFingerprint = keyBuffer.readUInt32BE(5);
  hdkey2.index = keyBuffer.readUInt32BE(9);
  hdkey2.chainCode = keyBuffer.slice(13, 45);
  var key2 = keyBuffer.slice(45);
  if (key2.readUInt8(0) === 0) {
    assert$6(version2 === versions.private, "Version mismatch: version does not match private");
    hdkey2.privateKey = key2.slice(1);
  } else {
    assert$6(version2 === versions.public, "Version mismatch: version does not match public");
    if (skipVerification) {
      setPublicKey(hdkey2, key2);
    } else {
      hdkey2.publicKey = key2;
    }
  }
  return hdkey2;
};
HDKey.fromJSON = function(obj) {
  return HDKey.fromExtendedKey(obj.xpriv);
};
function serialize(hdkey2, version2, key2) {
  var buffer = Buffer.allocUnsafe(LEN$1);
  buffer.writeUInt32BE(version2, 0);
  buffer.writeUInt8(hdkey2.depth, 4);
  var fingerprint = hdkey2.depth ? hdkey2.parentFingerprint : 0;
  buffer.writeUInt32BE(fingerprint, 5);
  buffer.writeUInt32BE(hdkey2.index, 9);
  hdkey2.chainCode.copy(buffer, 13);
  key2.copy(buffer, 45);
  return buffer;
}
function hash160$1(buf) {
  var sha = crypto$2.createHash("sha256").update(buf).digest();
  return new RIPEMD160().update(sha).digest();
}
HDKey.HARDENED_OFFSET = HARDENED_OFFSET;
var hdkey = HDKey;
var cjs$2 = {};
var constants$3 = {};
var secp256k1$1 = {};
var secp256k1 = {};
var sha256$2 = {};
var _md$2 = {};
var _assert = {};
Object.defineProperty(_assert, "__esModule", { value: true });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = _assert.isBytes = void 0;
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
_assert.number = number;
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
_assert.bool = bool;
function isBytes$1(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
_assert.isBytes = isBytes$1;
function bytes$3(b, ...lengths) {
  if (!isBytes$1(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
_assert.bytes = bytes$3;
function hash$1(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(h.outputLen);
  number(h.blockLen);
}
_assert.hash = hash$1;
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
_assert.exists = exists;
function output(out, instance) {
  bytes$3(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
_assert.output = output;
const assert$5 = { number, bool, bytes: bytes$3, hash: hash$1, exists, output };
_assert.default = assert$5;
var utils$5 = {};
var crypto$1 = {};
Object.defineProperty(crypto$1, "__esModule", { value: true });
crypto$1.crypto = void 0;
crypto$1.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(exports) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
  const crypto_1 = crypto$1;
  const _assert_js_12 = _assert;
  function isBytes2(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  exports.isBytes = isBytes2;
  const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.u8 = u8;
  const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  exports.u32 = u32;
  const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.createView = createView;
  const rotr = (word, shift) => word << 32 - shift | word >>> shift;
  exports.rotr = rotr;
  const rotl2 = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
  exports.rotl = rotl2;
  exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  exports.byteSwap = byteSwap;
  exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
  function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = (0, exports.byteSwap)(arr[i]);
    }
  }
  exports.byteSwap32 = byteSwap32;
  const hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex2(bytes2) {
    (0, _assert_js_12.bytes)(bytes2);
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes2[bytes2[i]];
    }
    return hex;
  }
  exports.bytesToHex = bytesToHex2;
  const asciis2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function asciiToBase162(char) {
    if (char >= asciis2._0 && char <= asciis2._9)
      return char - asciis2._0;
    if (char >= asciis2._A && char <= asciis2._F)
      return char - (asciis2._A - 10);
    if (char >= asciis2._a && char <= asciis2._f)
      return char - (asciis2._a - 10);
    return;
  }
  function hexToBytes2(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase162(hex.charCodeAt(hi));
      const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  exports.hexToBytes = hexToBytes2;
  const nextTick2 = async () => {
  };
  exports.nextTick = nextTick2;
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await (0, exports.nextTick)();
      ts += diff;
    }
  }
  exports.asyncLoop = asyncLoop;
  function utf8ToBytes2(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  exports.utf8ToBytes = utf8ToBytes2;
  function toBytes3(data) {
    if (typeof data === "string")
      data = utf8ToBytes2(data);
    (0, _assert_js_12.bytes)(data);
    return data;
  }
  exports.toBytes = toBytes3;
  function concatBytes2(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      (0, _assert_js_12.bytes)(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  exports.concatBytes = concatBytes2;
  class Hash2 {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  exports.Hash = Hash2;
  const toStr2 = {}.toString;
  function checkOpts(defaults, opts) {
    if (opts !== void 0 && toStr2.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  exports.checkOpts = checkOpts;
  function wrapConstructor(hashCons) {
    const hashC = (msg2) => hashCons().update(toBytes3(msg2)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  exports.wrapConstructor = wrapConstructor;
  function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg2, opts) => hashCons(opts).update(toBytes3(msg2)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg2, opts) => hashCons(opts).update(toBytes3(msg2)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
  function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
      return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  exports.randomBytes = randomBytes;
})(utils$5);
Object.defineProperty(_md$2, "__esModule", { value: true });
_md$2.HashMD = _md$2.Maj = _md$2.Chi = void 0;
const _assert_js_1$1 = _assert;
const utils_js_1$7 = utils$5;
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
const Chi = (a, b, c) => a & b ^ ~a & c;
_md$2.Chi = Chi;
const Maj = (a, b, c) => a & b ^ a & c ^ b & c;
_md$2.Maj = Maj;
class HashMD extends utils_js_1$7.Hash {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = (0, utils_js_1$7.createView)(this.buffer);
  }
  update(data) {
    (0, _assert_js_1$1.exists)(this);
    const { view, buffer, blockLen } = this;
    data = (0, utils_js_1$7.toBytes)(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = (0, utils_js_1$7.createView)(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    (0, _assert_js_1$1.exists)(this);
    (0, _assert_js_1$1.output)(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = (0, utils_js_1$7.createView)(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}
_md$2.HashMD = HashMD;
Object.defineProperty(sha256$2, "__esModule", { value: true });
sha256$2.sha224 = sha256$2.sha256 = void 0;
const _md_js_1 = _md$2;
const utils_js_1$6 = utils$5;
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1.HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = (0, utils_js_1$6.rotr)(W15, 7) ^ (0, utils_js_1$6.rotr)(W15, 18) ^ W15 >>> 3;
      const s1 = (0, utils_js_1$6.rotr)(W2, 17) ^ (0, utils_js_1$6.rotr)(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = (0, utils_js_1$6.rotr)(E, 6) ^ (0, utils_js_1$6.rotr)(E, 11) ^ (0, utils_js_1$6.rotr)(E, 25);
      const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = (0, utils_js_1$6.rotr)(A, 2) ^ (0, utils_js_1$6.rotr)(A, 13) ^ (0, utils_js_1$6.rotr)(A, 22);
      const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
}
sha256$2.sha256 = (0, utils_js_1$6.wrapConstructor)(() => new SHA256());
sha256$2.sha224 = (0, utils_js_1$6.wrapConstructor)(() => new SHA224());
var _shortw_utils = {};
var hmac = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmac = exports.HMAC = void 0;
  const _assert_js_12 = _assert;
  const utils_js_12 = utils$5;
  class HMAC extends utils_js_12.Hash {
    constructor(hash3, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      (0, _assert_js_12.hash)(hash3);
      const key2 = (0, utils_js_12.toBytes)(_key);
      this.iHash = hash3.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key2.length > blockLen ? hash3.create().update(key2).digest() : key2);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash3.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      (0, _assert_js_12.exists)(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      (0, _assert_js_12.exists)(this);
      (0, _assert_js_12.bytes)(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  }
  exports.HMAC = HMAC;
  const hmac2 = (hash3, key2, message2) => new HMAC(hash3, key2).update(message2).digest();
  exports.hmac = hmac2;
  exports.hmac.create = (hash3, key2) => new HMAC(hash3, key2);
})(hmac);
var weierstrass = {};
var curve$1 = {};
var modular = {};
var utils$4 = {};
Object.defineProperty(utils$4, "__esModule", { value: true });
utils$4.bitMask = void 0;
utils$4.isBytes = isBytes;
utils$4.abytes = abytes;
utils$4.bytesToHex = bytesToHex$1;
utils$4.numberToHexUnpadded = numberToHexUnpadded;
utils$4.hexToNumber = hexToNumber;
utils$4.hexToBytes = hexToBytes$1;
utils$4.bytesToNumberBE = bytesToNumberBE;
utils$4.bytesToNumberLE = bytesToNumberLE;
utils$4.numberToBytesBE = numberToBytesBE;
utils$4.numberToBytesLE = numberToBytesLE;
utils$4.numberToVarBytesBE = numberToVarBytesBE;
utils$4.ensureBytes = ensureBytes;
utils$4.concatBytes = concatBytes$1;
utils$4.equalBytes = equalBytes;
utils$4.utf8ToBytes = utf8ToBytes$1;
utils$4.bitLen = bitLen;
utils$4.bitGet = bitGet;
utils$4.bitSet = bitSet;
utils$4.createHmacDrbg = createHmacDrbg;
utils$4.validateObject = validateObject;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = /* @__PURE__ */ BigInt(0);
const _1n$3 = /* @__PURE__ */ BigInt(1);
const _2n$2 = /* @__PURE__ */ BigInt(2);
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes(item))
    throw new Error("Uint8Array expected");
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex$1(bytes2) {
  abytes(bytes2);
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes$1(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex$1(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes(bytes2);
  return hexToNumber(bytesToHex$1(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes$1(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes$1(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes$1(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes$1(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n$3; n >>= _1n$3, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n$3;
}
function bitSet(n, pos, value) {
  return n | (value ? _1n$3 : _0n$3) << BigInt(pos);
}
const bitMask = (n) => (_2n$2 << BigInt(n - 1)) - _1n$3;
utils$4.bitMask = bitMask;
const u8n = (data) => new Uint8Array(data);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes$1(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
Object.defineProperty(modular, "__esModule", { value: true });
modular.isNegativeLE = void 0;
modular.mod = mod;
modular.pow = pow;
modular.pow2 = pow2;
modular.invert = invert;
modular.tonelliShanks = tonelliShanks;
modular.FpSqrt = FpSqrt;
modular.validateField = validateField;
modular.FpPow = FpPow;
modular.FpInvertBatch = FpInvertBatch;
modular.FpDiv = FpDiv;
modular.FpIsSquare = FpIsSquare;
modular.nLength = nLength;
modular.Field = Field$1;
modular.FpSqrtOdd = FpSqrtOdd;
modular.FpSqrtEven = FpSqrtEven;
modular.hashToPrivateScalar = hashToPrivateScalar;
modular.getFieldBytesLength = getFieldBytesLength;
modular.getMinHashLength = getMinHashLength;
modular.mapHashToField = mapHashToField;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_js_1$5 = utils$4;
const _0n$2 = BigInt(0), _1n$2 = BigInt(1), _2n$1 = BigInt(2), _3n = BigInt(3);
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n$2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$2 || power < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$2)
    return _0n$2;
  let res = _1n$2;
  while (power > _0n$2) {
    if (power & _1n$2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$2 || modulo <= _0n$2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b = modulo;
  let x = _0n$2, u = _1n$2;
  while (a !== _0n$2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    b = a, a = r, x = u, u = m;
  }
  const gcd = b;
  if (gcd !== _1n$2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n$2) / _2n$1;
  let Q, S2, Z;
  for (Q = P - _1n$2, S2 = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S2++)
    ;
  for (Z = _2n$1; Z < P && pow(Z, legendreC, P) !== P - _1n$2; Z++)
    ;
  if (S2 === 1) {
    const p1div4 = (P + _1n$2) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n$2) / _2n$1;
  return function tonelliSlow(Fp, n) {
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S2;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x = Fp.pow(n, Q1div2);
    let b = Fp.pow(n, Q);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t2 = Fp.sqr(b); m < r; m++) {
        if (Fp.eql(t2, Fp.ONE))
          break;
        t2 = Fp.sqr(t2);
      }
      const ge = Fp.pow(g, _1n$2 << BigInt(r - m - 1));
      g = Fp.sqr(ge);
      x = Fp.mul(x, ge);
      b = Fp.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n$2) / _4n;
    return function sqrt3mod4(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp, n) {
      const n2 = Fp.mul(n, _2n$1);
      const v = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n$1), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks(P);
}
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$2) === _1n$2;
modular.isNegativeLE = isNegativeLE;
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field2) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return (0, utils_js_1$5.validateObject)(field2, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$2)
    throw new Error("Expected power > 0");
  if (power === _0n$2)
    return f2.ONE;
  if (power === _1n$2)
    return num;
  let p = f2.ONE;
  let d = num;
  while (power > _0n$2) {
    if (power & _1n$2)
      p = f2.mul(p, d);
    d = f2.sqr(d);
    power >>= _1n$2;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function FpDiv(f2, lhs, rhs) {
  return f2.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f2.ORDER) : f2.inv(rhs));
}
function FpIsSquare(f2) {
  const legendreConst = (f2.ORDER - _1n$2) / _2n$1;
  return (x) => {
    const p = f2.pow(x, legendreConst);
    return f2.eql(p, f2.ZERO) || f2.eql(p, f2.ONE);
  };
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field$1(ORDER, bitLen2, isLE = false, redef = {}) {
  if (ORDER <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: (0, utils_js_1$5.bitMask)(BITS),
    ZERO: _0n$2,
    ONE: _1n$2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$2,
    isOdd: (num) => (num & _1n$2) === _1n$2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f2, n)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE ? (0, utils_js_1$5.numberToBytesLE)(num, BYTES) : (0, utils_js_1$5.numberToBytesBE)(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE ? (0, utils_js_1$5.bytesToNumberLE)(bytes2) : (0, utils_js_1$5.bytesToNumberBE)(bytes2);
    }
  });
  return Object.freeze(f2);
}
function FpSqrtOdd(Fp, elm) {
  if (!Fp.isOdd)
    throw new Error(`Field doesn't have isOdd`);
  const root = Fp.sqrt(elm);
  return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
  if (!Fp.isOdd)
    throw new Error(`Field doesn't have isOdd`);
  const root = Fp.sqrt(elm);
  return Fp.isOdd(root) ? Fp.neg(root) : root;
}
function hashToPrivateScalar(hash3, groupOrder, isLE = false) {
  hash3 = (0, utils_js_1$5.ensureBytes)("privateHash", hash3);
  const hashLen = hash3.length;
  const minLen = nLength(groupOrder).nByteLength + 8;
  if (minLen < 24 || hashLen < minLen || hashLen > 1024)
    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
  const num = isLE ? (0, utils_js_1$5.bytesToNumberLE)(hash3) : (0, utils_js_1$5.bytesToNumberBE)(hash3);
  return mod(num, groupOrder - _1n$2) + _1n$2;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key2, fieldOrder, isLE = false) {
  const len = key2.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE ? (0, utils_js_1$5.bytesToNumberBE)(key2) : (0, utils_js_1$5.bytesToNumberLE)(key2);
  const reduced = mod(num, fieldOrder - _1n$2) + _1n$2;
  return isLE ? (0, utils_js_1$5.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1$5.numberToBytesBE)(reduced, fieldLen);
}
Object.defineProperty(curve$1, "__esModule", { value: true });
curve$1.wNAF = wNAF;
curve$1.validateBasic = validateBasic;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const modular_js_1$1 = modular;
const utils_js_1$4 = utils$4;
const _0n$1 = BigInt(0);
const _1n$1 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg4 = item.negate();
    return condition ? neg4 : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n$1) {
        if (n & _1n$1)
          p = p.add(d);
        d = d.double();
        n >>= _1n$1;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base2 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p;
        points.push(base2);
        for (let i = 1; i < windowSize; i++) {
          base2 = base2.add(p);
          points.push(base2);
        }
        p = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask2);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n$1;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve2) {
  (0, modular_js_1$1.validateField)(curve2.Fp);
  (0, utils_js_1$4.validateObject)(curve2, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...(0, modular_js_1$1.nLength)(curve2.n, curve2.nBitLength),
    ...curve2,
    ...{ p: curve2.Fp.ORDER }
  });
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DER = void 0;
  exports.weierstrassPoints = weierstrassPoints;
  exports.weierstrass = weierstrass2;
  exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
  exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const curve_js_1 = curve$1;
  const mod2 = modular;
  const ut = utils$4;
  const utils_js_12 = utils$4;
  function validatePointOpts(curve2) {
    const opts = (0, curve_js_1.validateBasic)(curve2);
    ut.validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp, a } = opts;
    if (endo) {
      if (!Fp.eql(a, Fp.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
  exports.DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
      constructor(m = "") {
        super(m);
      }
    },
    _parseInt(data) {
      const { Err: E } = exports.DER;
      if (data.length < 2 || data[0] !== 2)
        throw new E("Invalid signature integer tag");
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len)
        throw new E("Invalid signature integer: wrong length");
      if (res[0] & 128)
        throw new E("Invalid signature integer: negative");
      if (res[0] === 0 && !(res[1] & 128))
        throw new E("Invalid signature integer: unnecessary leading zero");
      return { d: b2n(res), l: data.subarray(len + 2) };
    },
    toSig(hex) {
      const { Err: E } = exports.DER;
      const data = typeof hex === "string" ? h2b(hex) : hex;
      ut.abytes(data);
      let l = data.length;
      if (l < 2 || data[0] != 48)
        throw new E("Invalid signature tag");
      if (data[1] !== l - 2)
        throw new E("Invalid signature: incorrect length");
      const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
      const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
      if (rBytesLeft.length)
        throw new E("Invalid signature: left bytes after parsing");
      return { r, s };
    },
    hexFromSig(sig) {
      const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
      const h = (num) => {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      };
      const s = slice2(h(sig.s));
      const r = slice2(h(sig.r));
      const shl = s.length / 2;
      const rhl = r.length / 2;
      const sl = h(shl);
      const rl = h(rhl);
      return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    }
  };
  const _0n2 = BigInt(0), _1n2 = BigInt(1), _2n2 = BigInt(2), _3n2 = BigInt(3), _4n2 = BigInt(4);
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE;
    const toBytes3 = CURVE.toBytes || ((_c, point5, _isCompressed) => {
      const a = point5.toAffine();
      return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
      return { x, y };
    });
    function weierstrassEquation(x) {
      const { a, b } = CURVE;
      const x2 = Fp.sqr(x);
      const x3 = Fp.mul(x2, x);
      return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
    }
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return typeof num === "bigint" && _0n2 < num && num < CURVE.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key2) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
      if (lengths && typeof key2 !== "bigint") {
        if (ut.isBytes(key2))
          key2 = ut.bytesToHex(key2);
        if (typeof key2 !== "string" || !lengths.includes(key2.length))
          throw new Error("Invalid key");
        key2 = key2.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key2 === "bigint" ? key2 : ut.bytesToNumberBE((0, utils_js_12.ensureBytes)("private key", key2, nByteLength));
      } catch (error) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key2}`);
      }
      if (wrapPrivateKey)
        num = mod2.mod(num, n);
      assertGE(num);
      return num;
    }
    const pointPrecomputes = /* @__PURE__ */ new Map();
    function assertPrjPoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }
    class Point2 {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp.isValid(pz))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point2)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp.eql(i, Fp.ZERO);
        if (is0(x) && is0(y))
          return Point2.ZERO;
        return new Point2(x, y, Fp.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(points) {
        const toInv = Fp.invertBatch(points.map((p) => p.pz));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(hex) {
        const P = Point2.fromAffine(fromBytes((0, utils_js_12.ensureBytes)("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(privateKey) {
        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = this.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        if (!Fp.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (Fp.isOdd)
          return !Fp.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
        const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
        return U1 && U2;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new Point2(this.px, Fp.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp.mul(b, _3n2);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
        let t0 = Fp.mul(X1, X1);
        let t1 = Fp.mul(Y1, Y1);
        let t2 = Fp.mul(Z1, Z1);
        let t3 = Fp.mul(X1, Y1);
        t3 = Fp.add(t3, t3);
        Z3 = Fp.mul(X1, Z1);
        Z3 = Fp.add(Z3, Z3);
        X3 = Fp.mul(a, Z3);
        Y3 = Fp.mul(b3, t2);
        Y3 = Fp.add(X3, Y3);
        X3 = Fp.sub(t1, Y3);
        Y3 = Fp.add(t1, Y3);
        Y3 = Fp.mul(X3, Y3);
        X3 = Fp.mul(t3, X3);
        Z3 = Fp.mul(b3, Z3);
        t2 = Fp.mul(a, t2);
        t3 = Fp.sub(t0, t2);
        t3 = Fp.mul(a, t3);
        t3 = Fp.add(t3, Z3);
        Z3 = Fp.add(t0, t0);
        t0 = Fp.add(Z3, t0);
        t0 = Fp.add(t0, t2);
        t0 = Fp.mul(t0, t3);
        Y3 = Fp.add(Y3, t0);
        t2 = Fp.mul(Y1, Z1);
        t2 = Fp.add(t2, t2);
        t0 = Fp.mul(t2, t3);
        X3 = Fp.sub(X3, t0);
        Z3 = Fp.mul(t2, t1);
        Z3 = Fp.add(Z3, Z3);
        Z3 = Fp.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
        const a = CURVE.a;
        const b3 = Fp.mul(CURVE.b, _3n2);
        let t0 = Fp.mul(X1, X2);
        let t1 = Fp.mul(Y1, Y2);
        let t2 = Fp.mul(Z1, Z2);
        let t3 = Fp.add(X1, Y1);
        let t4 = Fp.add(X2, Y2);
        t3 = Fp.mul(t3, t4);
        t4 = Fp.add(t0, t1);
        t3 = Fp.sub(t3, t4);
        t4 = Fp.add(X1, Z1);
        let t5 = Fp.add(X2, Z2);
        t4 = Fp.mul(t4, t5);
        t5 = Fp.add(t0, t2);
        t4 = Fp.sub(t4, t5);
        t5 = Fp.add(Y1, Z1);
        X3 = Fp.add(Y2, Z2);
        t5 = Fp.mul(t5, X3);
        X3 = Fp.add(t1, t2);
        t5 = Fp.sub(t5, X3);
        Z3 = Fp.mul(a, t4);
        X3 = Fp.mul(b3, t2);
        Z3 = Fp.add(X3, Z3);
        X3 = Fp.sub(t1, Z3);
        Z3 = Fp.add(t1, Z3);
        Y3 = Fp.mul(X3, Z3);
        t1 = Fp.add(t0, t0);
        t1 = Fp.add(t1, t0);
        t2 = Fp.mul(a, t2);
        t4 = Fp.mul(b3, t4);
        t1 = Fp.add(t1, t2);
        t2 = Fp.sub(t0, t2);
        t2 = Fp.mul(a, t2);
        t4 = Fp.add(t4, t2);
        t0 = Fp.mul(t1, t4);
        Y3 = Fp.add(Y3, t0);
        t0 = Fp.mul(t5, t4);
        X3 = Fp.mul(t3, X3);
        X3 = Fp.sub(X3, t0);
        t0 = Fp.mul(t3, t1);
        Z3 = Fp.mul(t5, Z3);
        Z3 = Fp.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
          const toInv = Fp.invertBatch(comp.map((p) => p.pz));
          return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(n) {
        const I = Point2.ZERO;
        if (n === _0n2)
          return I;
        assertGE(n);
        if (n === _1n2)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n);
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = I;
        let k2p = I;
        let d = this;
        while (k1 > _0n2 || k2 > _0n2) {
          if (k1 & _1n2)
            k1p = k1p.add(d);
          if (k2 & _1n2)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n2;
          k2 >>= _1n2;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point2(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar2) {
        assertGE(scalar2);
        let n = scalar2;
        let point5, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point2(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point5 = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f: f2 } = this.wNAF(n);
          point5 = p;
          fake = f2;
        }
        return Point2.normalizeZ([point5, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Q, a, b) {
        const G = Point2.BASE;
        const mul5 = (P, a2) => a2 === _0n2 || a2 === _1n2 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul5(this, a).add(mul5(Q, b));
        return sum.is0() ? void 0 : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z) ∋ (x=x/z, y=y/z)
      toAffine(iz) {
        const { px: x, py: y, pz: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n2)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n2)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed2 = true) {
        this.assertValidity();
        return toBytes3(Point2, this, isCompressed2);
      }
      toHex(isCompressed2 = true) {
        return ut.bytesToHex(this.toRawBytes(isCompressed2));
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point2.ZERO = new Point2(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point2,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve2) {
    const opts = (0, curve_js_1.validateBasic)(curve2);
    ut.validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass2(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1;
    const uncompressedLen = 2 * Fp.BYTES + 1;
    function isValidFieldElement(num) {
      return _0n2 < num && num < Fp.ORDER;
    }
    function modN(a) {
      return mod2.mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return mod2.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(_c, point5, isCompressed2) {
        const a = point5.toAffine();
        const x = Fp.toBytes(a.x);
        const cat = ut.concatBytes;
        if (isCompressed2) {
          return cat(Uint8Array.from([point5.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x = ut.bytesToNumberBE(tail);
          if (!isValidFieldElement(x))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y;
          try {
            y = Fp.sqrt(y2);
          } catch (sqrtError) {
            const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("Point is not on curve" + suffix);
          }
          const isYOdd = (y & _1n2) === _1n2;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp.neg(y);
          return { x, y };
        } else if (len === uncompressedLen && head === 4) {
          const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
          const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
          return { x, y };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n2;
      return number2 > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
    class Signature2 {
      constructor(r, s, recovery) {
        this.r = r;
        this.s = s;
        this.recovery = recovery;
        this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex) {
        const l = CURVE.nByteLength;
        hex = (0, utils_js_12.ensureBytes)("compactSignature", hex, l * 2);
        return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex) {
        const { r, s } = exports.DER.toSig((0, utils_js_12.ensureBytes)("DER", hex));
        return new Signature2(r, s);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s, recovery: rec } = this;
        const h = bits2int_modN((0, utils_js_12.ensureBytes)("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R2 = Point2.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN(-h * ir);
        const u2 = modN(s * ir);
        const Q = Point2.BASE.multiplyAndAddUnsafe(R2, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return ut.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return exports.DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return ut.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils2 = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const length = mod2.getMinHashLength(CURVE.n);
        return mod2.mapHashToField(CURVE.randomBytes(length), CURVE.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(windowSize = 8, point5 = Point2.BASE) {
        point5._setWindowSize(windowSize);
        point5.multiply(BigInt(3));
        return point5;
      }
    };
    function getPublicKey(privateKey, isCompressed2 = true) {
      return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed2);
    }
    function isProbPub(item) {
      const arr = ut.isBytes(item);
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point2)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed2 = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b = Point2.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed2);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num = ut.bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN(bits2int(bytes2));
    };
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n2 <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash3, randomBytes } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = (0, utils_js_12.ensureBytes)("msgHash", msgHash);
      if (prehash)
        msgHash = (0, utils_js_12.ensureBytes)("prehashed msgHash", hash3(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e = ent === true ? randomBytes(Fp.BYTES) : ent;
        seedArgs.push((0, utils_js_12.ensureBytes)("extraEntropy", e));
      }
      const seed = ut.concatBytes(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!isWithinCurveOrder(k))
          return;
        const ik = invN(k);
        const q = Point2.BASE.multiply(k).toAffine();
        const r = modN(q.x);
        if (r === _0n2)
          return;
        const s = modN(ik * modN(m + r * d));
        if (s === _0n2)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n2);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature2(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign5(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE;
      const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point2.BASE._setWindowSize(8);
    function verify5(signature2, msgHash, publicKey, opts = defaultVerOpts) {
      var _a;
      const sg = signature2;
      msgHash = (0, utils_js_12.ensureBytes)("msgHash", msgHash);
      publicKey = (0, utils_js_12.ensureBytes)("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = void 0;
      let P;
      try {
        if (typeof sg === "string" || ut.isBytes(sg)) {
          try {
            _sig = Signature2.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof exports.DER.Err))
              throw derError;
            _sig = Signature2.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s2 } = sg;
          _sig = new Signature2(r2, s2);
        } else {
          throw new Error("PARSE");
        }
        P = Point2.fromHex(publicKey);
      } catch (error) {
        if (error.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is2 = invN(s);
      const u1 = modN(h * is2);
      const u2 = modN(r * is2);
      const R2 = (_a = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
      if (!R2)
        return false;
      const v = modN(R2.x);
      return v === r;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign: sign5,
      verify: verify5,
      ProjectivePoint: Point2,
      Signature: Signature2,
      utils: utils2
    };
  }
  function SWUFpSqrtRatio(Fp, Z) {
    const q = Fp.ORDER;
    let l = _0n2;
    for (let o = q - _1n2; o % _2n2 === _0n2; o /= _2n2)
      l += _1n2;
    const c1 = l;
    const _2n_pow_c1_1 = _2n2 << c1 - _1n2 - _1n2;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n2;
    const c2 = (q - _1n2) / _2n_pow_c1;
    const c3 = (c2 - _1n2) / _2n2;
    const c4 = _2n_pow_c1 - _1n2;
    const c5 = _2n_pow_c1_1;
    const c6 = Fp.pow(Z, c2);
    const c7 = Fp.pow(Z, (c2 + _1n2) / _2n2);
    let sqrtRatio = (u, v) => {
      let tv1 = c6;
      let tv2 = Fp.pow(v, c4);
      let tv3 = Fp.sqr(tv2);
      tv3 = Fp.mul(tv3, v);
      let tv5 = Fp.mul(u, tv3);
      tv5 = Fp.pow(tv5, c3);
      tv5 = Fp.mul(tv5, tv2);
      tv2 = Fp.mul(tv5, v);
      tv3 = Fp.mul(tv5, u);
      let tv4 = Fp.mul(tv3, tv2);
      tv5 = Fp.pow(tv4, c5);
      let isQR = Fp.eql(tv5, Fp.ONE);
      tv2 = Fp.mul(tv3, c7);
      tv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, isQR);
      tv4 = Fp.cmov(tv5, tv4, isQR);
      for (let i = c1; i > _1n2; i--) {
        let tv52 = i - _2n2;
        tv52 = _2n2 << tv52 - _1n2;
        let tvv5 = Fp.pow(tv4, tv52);
        const e1 = Fp.eql(tvv5, Fp.ONE);
        tv2 = Fp.mul(tv3, tv1);
        tv1 = Fp.mul(tv1, tv1);
        tvv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, e1);
        tv4 = Fp.cmov(tvv5, tv4, e1);
      }
      return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n2 === _3n2) {
      const c12 = (Fp.ORDER - _3n2) / _4n2;
      const c22 = Fp.sqrt(Fp.neg(Z));
      sqrtRatio = (u, v) => {
        let tv1 = Fp.sqr(v);
        const tv2 = Fp.mul(u, v);
        tv1 = Fp.mul(tv1, tv2);
        let y1 = Fp.pow(tv1, c12);
        y1 = Fp.mul(y1, tv2);
        const y2 = Fp.mul(y1, c22);
        const tv3 = Fp.mul(Fp.sqr(y1), v);
        const isQR = Fp.eql(tv3, u);
        let y = Fp.cmov(y2, y1, isQR);
        return { isValid: isQR, value: y };
      };
    }
    return sqrtRatio;
  }
  function mapToCurveSimpleSWU(Fp, opts) {
    mod2.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (u) => {
      let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
      tv1 = Fp.sqr(u);
      tv1 = Fp.mul(tv1, opts.Z);
      tv2 = Fp.sqr(tv1);
      tv2 = Fp.add(tv2, tv1);
      tv3 = Fp.add(tv2, Fp.ONE);
      tv3 = Fp.mul(tv3, opts.B);
      tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
      tv4 = Fp.mul(tv4, opts.A);
      tv2 = Fp.sqr(tv3);
      tv6 = Fp.sqr(tv4);
      tv5 = Fp.mul(tv6, opts.A);
      tv2 = Fp.add(tv2, tv5);
      tv2 = Fp.mul(tv2, tv3);
      tv6 = Fp.mul(tv6, tv4);
      tv5 = Fp.mul(tv6, opts.B);
      tv2 = Fp.add(tv2, tv5);
      x = Fp.mul(tv1, tv3);
      const { isValid, value } = sqrtRatio(tv2, tv6);
      y = Fp.mul(tv1, u);
      y = Fp.mul(y, value);
      x = Fp.cmov(x, tv3, isValid);
      y = Fp.cmov(y, value, isValid);
      const e1 = Fp.isOdd(u) === Fp.isOdd(y);
      y = Fp.cmov(Fp.neg(y), y, e1);
      x = Fp.div(x, tv4);
      return { x, y };
    };
  }
})(weierstrass);
Object.defineProperty(_shortw_utils, "__esModule", { value: true });
_shortw_utils.getHash = getHash;
_shortw_utils.createCurve = createCurve;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_1 = hmac;
const utils_1$g = utils$5;
const weierstrass_js_1 = weierstrass;
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key2, ...msgs) => (0, hmac_1.hmac)(hash3, key2, (0, utils_1$g.concatBytes)(...msgs)),
    randomBytes: utils_1$g.randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash3) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create(defHash), create });
}
var hashToCurve = {};
Object.defineProperty(hashToCurve, "__esModule", { value: true });
hashToCurve.expand_message_xmd = expand_message_xmd;
hashToCurve.expand_message_xof = expand_message_xof;
hashToCurve.hash_to_field = hash_to_field;
hashToCurve.isogenyMap = isogenyMap;
hashToCurve.createHasher = createHasher;
const modular_js_1 = modular;
const utils_js_1$3 = utils$4;
const os2ip = utils_js_1$3.bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg2, DST, lenInBytes, H) {
  (0, utils_js_1$3.abytes)(msg2);
  (0, utils_js_1$3.abytes)(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H((0, utils_js_1$3.concatBytes)((0, utils_js_1$3.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = (0, utils_js_1$3.concatBytes)(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H((0, utils_js_1$3.concatBytes)(Z_pad, msg2, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H((0, utils_js_1$3.concatBytes)(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H((0, utils_js_1$3.concatBytes)(...args));
  }
  const pseudo_random_bytes = (0, utils_js_1$3.concatBytes)(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg2, DST, lenInBytes, k, H) {
  (0, utils_js_1$3.abytes)(msg2);
  (0, utils_js_1$3.abytes)(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update((0, utils_js_1$3.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg2).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg2, count, options) {
  (0, utils_js_1$3.validateObject)(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash3, expand, DST: _DST } = options;
  (0, utils_js_1$3.abytes)(msg2);
  anum(count);
  const DST = typeof _DST === "string" ? (0, utils_js_1$3.utf8ToBytes)(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg2, DST, len_in_bytes, hash3);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg2, DST, len_in_bytes, k, hash3);
  } else if (expand === "_internal_pass") {
    prb = msg2;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field2, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field2.add(field2.mul(acc, x), i)));
    x = field2.div(xNum, xDen);
    y = field2.mul(y, field2.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point2, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg2, options) {
      const u = hash_to_field(msg2, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point2.fromAffine(mapToCurve(u[0]));
      const u1 = Point2.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg2, options) {
      const u = hash_to_field(msg2, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars2) {
      if (!Array.isArray(scalars2))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i of scalars2)
        if (typeof i !== "bigint")
          throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);
      const P = Point2.fromAffine(mapToCurve(scalars2)).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const sha256_12 = sha256$2;
  const utils_12 = utils$5;
  const _shortw_utils_js_1 = _shortw_utils;
  const hash_to_curve_js_1 = hashToCurve;
  const modular_js_12 = modular;
  const utils_js_12 = utils$4;
  const weierstrass_js_12 = weierstrass;
  const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  const _1n2 = BigInt(1);
  const _2n2 = BigInt(2);
  const divNearest = (a, b) => (a + b / _2n2) / b;
  function sqrtMod(y) {
    const P = secp256k1P;
    const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = (0, modular_js_12.pow2)(b3, _3n2, P) * b3 % P;
    const b9 = (0, modular_js_12.pow2)(b6, _3n2, P) * b3 % P;
    const b11 = (0, modular_js_12.pow2)(b9, _2n2, P) * b2 % P;
    const b22 = (0, modular_js_12.pow2)(b11, _11n, P) * b11 % P;
    const b44 = (0, modular_js_12.pow2)(b22, _22n, P) * b22 % P;
    const b88 = (0, modular_js_12.pow2)(b44, _44n, P) * b44 % P;
    const b176 = (0, modular_js_12.pow2)(b88, _88n, P) * b88 % P;
    const b220 = (0, modular_js_12.pow2)(b176, _44n, P) * b44 % P;
    const b223 = (0, modular_js_12.pow2)(b220, _3n2, P) * b3 % P;
    const t1 = (0, modular_js_12.pow2)(b223, _23n, P) * b22 % P;
    const t2 = (0, modular_js_12.pow2)(t1, _6n, P) * b2 % P;
    const root = (0, modular_js_12.pow2)(t2, _2n2, P);
    if (!Fp.eql(Fp.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  const Fp = (0, modular_js_12.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
  exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
    a: BigInt(0),
    // equation params: a, b
    b: BigInt(7),
    // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
    Fp,
    // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
    n: secp256k1N,
    // Curve order, total count of valid points in the field
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    // Cofactor
    lowS: true,
    // Allow only low-S signatures by default in sign() and verify()
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n2 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = (0, modular_js_12.mod)(k - c1 * a1 - c2 * a2, n);
        let k2 = (0, modular_js_12.mod)(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256_12.sha256);
  const _0n2 = BigInt(0);
  const fe = (x) => typeof x === "bigint" && _0n2 < x && x < secp256k1P;
  const ge = (x) => typeof x === "bigint" && _0n2 < x && x < secp256k1N;
  const TAGGED_HASH_PREFIXES = {};
  function taggedHash(tag, ...messages2) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = (0, sha256_12.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = (0, utils_js_12.concatBytes)(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_12.sha256)((0, utils_js_12.concatBytes)(tagP, ...messages2));
  }
  const pointToBytes = (point5) => point5.toRawBytes(true).slice(1);
  const numTo32b = (n) => (0, utils_js_12.numberToBytesBE)(n, 32);
  const modP = (x) => (0, modular_js_12.mod)(x, secp256k1P);
  const modN = (x) => (0, modular_js_12.mod)(x, secp256k1N);
  const Point2 = exports.secp256k1.ProjectivePoint;
  const GmulAdd = (Q, a, b) => Point2.BASE.multiplyAndAddUnsafe(Q, a, b);
  function schnorrGetExtPubKey(priv2) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv2);
    let p = Point2.fromPrivateKey(d_);
    const scalar2 = p.hasEvenY() ? d_ : modN(-d_);
    return { scalar: scalar2, bytes: pointToBytes(p) };
  }
  function lift_x(x) {
    if (!fe(x))
      throw new Error("bad x: need 0 < x < p");
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7));
    let y = sqrtMod(c);
    if (y % _2n2 !== _0n2)
      y = modP(-y);
    const p = new Point2(x, y, _1n2);
    p.assertValidity();
    return p;
  }
  function challenge(...args) {
    return modN((0, utils_js_12.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
  }
  function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes;
  }
  function schnorrSign(message2, privateKey, auxRand = (0, utils_12.randomBytes)(32)) {
    const m = (0, utils_js_12.ensureBytes)("message", message2);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
    const a = (0, utils_js_12.ensureBytes)("auxRand", auxRand, 32);
    const t = numTo32b(d ^ (0, utils_js_12.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
    const rand2 = taggedHash("BIP0340/nonce", t, px, m);
    const k_ = modN((0, utils_js_12.bytesToNumberBE)(rand2));
    if (k_ === _0n2)
      throw new Error("sign failed: k is zero");
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
    const e = challenge(rx, px, m);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    if (!schnorrVerify(sig, m, px))
      throw new Error("sign: Invalid signature produced");
    return sig;
  }
  function schnorrVerify(signature2, message2, publicKey) {
    const sig = (0, utils_js_12.ensureBytes)("signature", signature2, 64);
    const m = (0, utils_js_12.ensureBytes)("message", message2);
    const pub2 = (0, utils_js_12.ensureBytes)("publicKey", publicKey, 32);
    try {
      const P = lift_x((0, utils_js_12.bytesToNumberBE)(pub2));
      const r = (0, utils_js_12.bytesToNumberBE)(sig.subarray(0, 32));
      if (!fe(r))
        return false;
      const s = (0, utils_js_12.bytesToNumberBE)(sig.subarray(32, 64));
      if (!ge(s))
        return false;
      const e = challenge(numTo32b(r), pointToBytes(P), m);
      const R2 = GmulAdd(P, s, modN(-e));
      if (!R2 || !R2.hasEvenY() || R2.toAffine().x !== r)
        return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
      lift_x,
      pointToBytes,
      numberToBytesBE: utils_js_12.numberToBytesBE,
      bytesToNumberBE: utils_js_12.bytesToNumberBE,
      taggedHash,
      mod: modular_js_12.mod
    }
  }))();
  const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
    // xNum
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    // xDen
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ],
    // yNum
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    // yDen
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ]
  ].map((i) => i.map((j) => BigInt(j)))))();
  const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_12.mapToCurveSimpleSWU)(Fp, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Fp.create(BigInt("-11"))
  }))();
  const htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars2) => {
    const { x, y } = mapSWU(Fp.create(scalars2[0]));
    return isoMap(x, y);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha256_12.sha256
  }))();
  exports.hashToCurve = (() => htf.hashToCurve)();
  exports.encodeToCurve = (() => htf.encodeToCurve)();
})(secp256k1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.secp256k1 = void 0;
  var secp256k1_1 = secp256k1;
  Object.defineProperty(exports, "secp256k1", { enumerable: true, get: function() {
    return secp256k1_1.secp256k1;
  } });
})(secp256k1$1);
var bytes$2 = {};
var random = {};
Object.defineProperty(random, "__esModule", { value: true });
random.getRandomBytesSync = getRandomBytesSync;
random.getRandomBytes = getRandomBytes;
const utils_1$f = utils$5;
function getRandomBytesSync(bytes2) {
  return (0, utils_1$f.randomBytes)(bytes2);
}
async function getRandomBytes(bytes2) {
  return (0, utils_1$f.randomBytes)(bytes2);
}
var utils$3 = { exports: {} };
utils$3.exports;
(function(module, exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crypto = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
  exports.bytesToUtf8 = bytesToUtf8;
  exports.hexToBytes = hexToBytes2;
  exports.equalsBytes = equalsBytes;
  exports.wrapHash = wrapHash;
  const _assert_1 = __importDefault2(_assert);
  const utils_12 = utils$5;
  const assertBool = _assert_1.default.bool;
  exports.assertBool = assertBool;
  const assertBytes = _assert_1.default.bytes;
  exports.assertBytes = assertBytes;
  var utils_2 = utils$5;
  Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
    return utils_2.bytesToHex;
  } });
  Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
    return utils_2.bytesToHex;
  } });
  Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
    return utils_2.concatBytes;
  } });
  Object.defineProperty(exports, "createView", { enumerable: true, get: function() {
    return utils_2.createView;
  } });
  Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
    return utils_2.utf8ToBytes;
  } });
  function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
      throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
  }
  function hexToBytes2(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return (0, utils_12.hexToBytes)(sliced);
  }
  function equalsBytes(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  function wrapHash(hash3) {
    return (msg2) => {
      _assert_1.default.bytes(msg2);
      return hash3(msg2);
    };
  }
  exports.crypto = (() => {
    const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    const nodeRequire = typeof commonjsRequire === "function" && commonjsRequire.bind(module);
    return {
      node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
      web: webCrypto
    };
  })();
})(utils$3, utils$3.exports);
var utilsExports = utils$3.exports;
var helpers = {};
var internal = {};
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  Object.defineProperty(internal, "__esModule", { value: true });
  internal.getKeys = internal.fromAscii = internal.fromUtf8 = internal.toAscii = internal.arrayContainsArray = internal.getBinarySize = internal.padToEven = internal.stripHexPrefix = internal.isHexString = void 0;
  const bytes_js_12 = requireBytes();
  function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
      return false;
    if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
      return false;
    return true;
  }
  internal.isHexString = isHexString;
  const stripHexPrefix2 = (str) => {
    if (typeof str !== "string")
      throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
    return isHexString(str) ? str.slice(2) : str;
  };
  internal.stripHexPrefix = stripHexPrefix2;
  function padToEven2(value) {
    let a = value;
    if (typeof a !== "string") {
      throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
    }
    if (a.length % 2)
      a = `0${a}`;
    return a;
  }
  internal.padToEven = padToEven2;
  function getBinarySize(str) {
    if (typeof str !== "string") {
      throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);
    }
    return (0, bytes_js_12.utf8ToBytes)(str).byteLength;
  }
  internal.getBinarySize = getBinarySize;
  function arrayContainsArray(superset, subset, some) {
    if (Array.isArray(superset) !== true) {
      throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);
    }
    if (Array.isArray(subset) !== true) {
      throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);
    }
    return subset[some === true ? "some" : "every"]((value) => superset.indexOf(value) >= 0);
  }
  internal.arrayContainsArray = arrayContainsArray;
  function toAscii(hex) {
    let str = "";
    let i = 0;
    const l = hex.length;
    if (hex.substring(0, 2) === "0x")
      i = 2;
    for (; i < l; i += 2) {
      const code = parseInt(hex.substr(i, 2), 16);
      str += String.fromCharCode(code);
    }
    return str;
  }
  internal.toAscii = toAscii;
  function fromUtf8(stringValue) {
    const str = (0, bytes_js_12.utf8ToBytes)(stringValue);
    return `0x${padToEven2((0, bytes_js_12.bytesToUnprefixedHex)(str)).replace(/^0+|0+$/g, "")}`;
  }
  internal.fromUtf8 = fromUtf8;
  function fromAscii(stringValue) {
    let hex = "";
    for (let i = 0; i < stringValue.length; i++) {
      const code = stringValue.charCodeAt(i);
      const n = code.toString(16);
      hex += n.length < 2 ? `0${n}` : n;
    }
    return `0x${hex}`;
  }
  internal.fromAscii = fromAscii;
  function getKeys(params, key2, allowEmpty) {
    if (!Array.isArray(params)) {
      throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);
    }
    if (typeof key2 !== "string") {
      throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);
    }
    const result = [];
    for (let i = 0; i < params.length; i++) {
      let value = params[i][key2];
      if (allowEmpty === true && !value) {
        value = "";
      } else if (typeof value !== "string") {
        throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);
      }
      result.push(value);
    }
    return result;
  }
  internal.getKeys = getKeys;
  return internal;
}
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers;
  hasRequiredHelpers = 1;
  Object.defineProperty(helpers, "__esModule", { value: true });
  helpers.assertIsString = helpers.assertIsArray = helpers.assertIsBytes = helpers.assertIsHexString = void 0;
  const internal_js_12 = requireInternal();
  const assertIsHexString = function(input) {
    if (!(0, internal_js_12.isHexString)(input)) {
      const msg2 = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
      throw new Error(msg2);
    }
  };
  helpers.assertIsHexString = assertIsHexString;
  const assertIsBytes = function(input) {
    if (!(input instanceof Uint8Array)) {
      const msg2 = `This method only supports Uint8Array but input was: ${input}`;
      throw new Error(msg2);
    }
  };
  helpers.assertIsBytes = assertIsBytes;
  const assertIsArray = function(input) {
    if (!Array.isArray(input)) {
      const msg2 = `This method only supports number arrays but input was: ${input}`;
      throw new Error(msg2);
    }
  };
  helpers.assertIsArray = assertIsArray;
  const assertIsString = function(input) {
    if (typeof input !== "string") {
      const msg2 = `This method only supports strings but input was: ${input}`;
      throw new Error(msg2);
    }
  };
  helpers.assertIsString = assertIsString;
  return helpers;
}
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes) return bytes$2;
  hasRequiredBytes = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBigInt = exports.utf8ToBytes = exports.equalsBytes = exports.bytesToUtf8 = exports.bigInt64ToBytes = exports.int32ToBytes = exports.bytesToBigInt64 = exports.bytesToInt32 = exports.concatBytes = exports.randomBytes = exports.compareBytes = exports.intToUnpaddedBytes = exports.bigIntToAddressBytes = exports.bigIntToUnpaddedBytes = exports.bigIntMin = exports.bigIntMax = exports.bigIntToHex = exports.validateNoLeadingZeroes = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.toBytes = exports.unpadHex = exports.unpadArray = exports.unpadBytes = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.bigIntToBytes = exports.intToBytes = exports.intToHex = exports.hexToBytes = exports.bytesToInt = exports.bytesToBigInt = exports.bytesToHex = exports.unprefixedHexToBytes = exports.bytesToUnprefixedHex = void 0;
    const random_js_1 = random;
    const utils_js_12 = utilsExports;
    const helpers_js_12 = requireHelpers();
    const internal_js_12 = requireInternal();
    const BIGINT_0 = BigInt(0);
    exports.bytesToUnprefixedHex = utils_js_12.bytesToHex;
    const hexToBytesMapFirstKey = {};
    const hexToBytesMapSecondKey = {};
    for (let i = 0; i < 16; i++) {
      const vSecondKey = i;
      const vFirstKey = i * 16;
      const key2 = i.toString(16).toLowerCase();
      hexToBytesMapSecondKey[key2] = vSecondKey;
      hexToBytesMapSecondKey[key2.toUpperCase()] = vSecondKey;
      hexToBytesMapFirstKey[key2] = vFirstKey;
      hexToBytesMapFirstKey[key2.toUpperCase()] = vFirstKey;
    }
    function _unprefixedHexToBytes(hex) {
      const byteLen = hex.length;
      const bytes2 = new Uint8Array(byteLen / 2);
      for (let i = 0; i < byteLen; i += 2) {
        bytes2[i / 2] = hexToBytesMapFirstKey[hex[i]] + hexToBytesMapSecondKey[hex[i + 1]];
      }
      return bytes2;
    }
    const unprefixedHexToBytes = (inp) => {
      if (inp.slice(0, 2) === "0x") {
        throw new Error("hex string is prefixed with 0x, should be unprefixed");
      } else {
        return _unprefixedHexToBytes((0, internal_js_12.padToEven)(inp));
      }
    };
    exports.unprefixedHexToBytes = unprefixedHexToBytes;
    const hexByByte = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    const bytesToHex2 = (bytes2) => {
      let hex = `0x`;
      if (bytes2 === void 0 || bytes2.length === 0)
        return hex;
      for (const byte of bytes2) {
        hex = `${hex}${hexByByte[byte]}`;
      }
      return hex;
    };
    exports.bytesToHex = bytesToHex2;
    const BIGINT_CACHE = [];
    for (let i = 0; i <= 256 * 256 - 1; i++) {
      BIGINT_CACHE[i] = BigInt(i);
    }
    const bytesToBigInt = (bytes2, littleEndian = false) => {
      if (littleEndian) {
        bytes2.reverse();
      }
      const hex = (0, exports.bytesToHex)(bytes2);
      if (hex === "0x") {
        return BIGINT_0;
      }
      if (hex.length === 4) {
        return BIGINT_CACHE[bytes2[0]];
      }
      if (hex.length === 6) {
        return BIGINT_CACHE[bytes2[0] * 256 + bytes2[1]];
      }
      return BigInt(hex);
    };
    exports.bytesToBigInt = bytesToBigInt;
    const bytesToInt = (bytes2) => {
      const res = Number((0, exports.bytesToBigInt)(bytes2));
      if (!Number.isSafeInteger(res))
        throw new Error("Number exceeds 53 bits");
      return res;
    };
    exports.bytesToInt = bytesToInt;
    const hexToBytes2 = (hex) => {
      if (typeof hex !== "string") {
        throw new Error(`hex argument type ${typeof hex} must be of type string`);
      }
      if (!/^0x[0-9a-fA-F]*$/.test(hex)) {
        throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`);
      }
      const unprefixedHex = hex.slice(2);
      return _unprefixedHexToBytes(unprefixedHex.length % 2 === 0 ? unprefixedHex : (0, internal_js_12.padToEven)(unprefixedHex));
    };
    exports.hexToBytes = hexToBytes2;
    const intToHex = (i) => {
      if (!Number.isSafeInteger(i) || i < 0) {
        throw new Error(`Received an invalid integer type: ${i}`);
      }
      return `0x${i.toString(16)}`;
    };
    exports.intToHex = intToHex;
    const intToBytes2 = (i) => {
      const hex = (0, exports.intToHex)(i);
      return (0, exports.hexToBytes)(hex);
    };
    exports.intToBytes = intToBytes2;
    const bigIntToBytes = (num, littleEndian = false) => {
      const bytes2 = (0, exports.toBytes)(`0x${(0, internal_js_12.padToEven)(num.toString(16))}`);
      return littleEndian ? bytes2.reverse() : bytes2;
    };
    exports.bigIntToBytes = bigIntToBytes;
    const zeros = (bytes2) => {
      return new Uint8Array(bytes2);
    };
    exports.zeros = zeros;
    const setLength = (msg2, length, right) => {
      if (right) {
        if (msg2.length < length) {
          return new Uint8Array([...msg2, ...(0, exports.zeros)(length - msg2.length)]);
        }
        return msg2.subarray(0, length);
      } else {
        if (msg2.length < length) {
          return new Uint8Array([...(0, exports.zeros)(length - msg2.length), ...msg2]);
        }
        return msg2.subarray(-length);
      }
    };
    const setLengthLeft = (msg2, length) => {
      (0, helpers_js_12.assertIsBytes)(msg2);
      return setLength(msg2, length, false);
    };
    exports.setLengthLeft = setLengthLeft;
    const setLengthRight = (msg2, length) => {
      (0, helpers_js_12.assertIsBytes)(msg2);
      return setLength(msg2, length, true);
    };
    exports.setLengthRight = setLengthRight;
    const stripZeros = (a) => {
      let first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    const unpadBytes = (a) => {
      (0, helpers_js_12.assertIsBytes)(a);
      return stripZeros(a);
    };
    exports.unpadBytes = unpadBytes;
    const unpadArray = (a) => {
      (0, helpers_js_12.assertIsArray)(a);
      return stripZeros(a);
    };
    exports.unpadArray = unpadArray;
    const unpadHex = (a) => {
      (0, helpers_js_12.assertIsHexString)(a);
      return `0x${stripZeros((0, internal_js_12.stripHexPrefix)(a))}`;
    };
    exports.unpadHex = unpadHex;
    const toBytes3 = (v) => {
      if (v === null || v === void 0) {
        return new Uint8Array();
      }
      if (Array.isArray(v) || v instanceof Uint8Array) {
        return Uint8Array.from(v);
      }
      if (typeof v === "string") {
        if (!(0, internal_js_12.isHexString)(v)) {
          throw new Error(`Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`);
        }
        return (0, exports.hexToBytes)(v);
      }
      if (typeof v === "number") {
        return (0, exports.intToBytes)(v);
      }
      if (typeof v === "bigint") {
        if (v < BIGINT_0) {
          throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);
        }
        let n = v.toString(16);
        if (n.length % 2)
          n = "0" + n;
        return (0, exports.unprefixedHexToBytes)(n);
      }
      if (v.toBytes !== void 0) {
        return v.toBytes();
      }
      throw new Error("invalid type");
    };
    exports.toBytes = toBytes3;
    const fromSigned = (num) => {
      return BigInt.asIntN(256, (0, exports.bytesToBigInt)(num));
    };
    exports.fromSigned = fromSigned;
    const toUnsigned2 = (num) => {
      return (0, exports.bigIntToBytes)(BigInt.asUintN(256, num));
    };
    exports.toUnsigned = toUnsigned2;
    const addHexPrefix = (str) => {
      if (typeof str !== "string") {
        return str;
      }
      return (0, internal_js_12.isHexString)(str) ? str : `0x${str}`;
    };
    exports.addHexPrefix = addHexPrefix;
    const short2 = (bytes2, maxLength = 50) => {
      const byteStr = bytes2 instanceof Uint8Array ? (0, exports.bytesToHex)(bytes2) : bytes2;
      const len = byteStr.slice(0, 2) === "0x" ? maxLength + 2 : maxLength;
      if (byteStr.length <= len) {
        return byteStr;
      }
      return byteStr.slice(0, len) + "…";
    };
    exports.short = short2;
    const validateNoLeadingZeroes = (values) => {
      for (const [k, v] of Object.entries(values)) {
        if (v !== void 0 && v.length > 0 && v[0] === 0) {
          throw new Error(`${k} cannot have leading zeroes, received: ${(0, exports.bytesToHex)(v)}`);
        }
      }
    };
    exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
    const bigIntToHex = (num) => {
      return `0x${num.toString(16)}`;
    };
    exports.bigIntToHex = bigIntToHex;
    const bigIntMax = (...args) => args.reduce((m, e) => e > m ? e : m);
    exports.bigIntMax = bigIntMax;
    const bigIntMin = (...args) => args.reduce((m, e) => e < m ? e : m);
    exports.bigIntMin = bigIntMin;
    const bigIntToUnpaddedBytes = (value) => {
      return (0, exports.unpadBytes)((0, exports.bigIntToBytes)(value));
    };
    exports.bigIntToUnpaddedBytes = bigIntToUnpaddedBytes;
    const bigIntToAddressBytes = (value, strict = true) => {
      const addressBytes = (0, exports.bigIntToBytes)(value);
      if (strict && addressBytes.length > 20) {
        throw Error(`Invalid address bytes length=${addressBytes.length} strict=${strict}`);
      }
      return (0, exports.setLengthLeft)(addressBytes, 20);
    };
    exports.bigIntToAddressBytes = bigIntToAddressBytes;
    const intToUnpaddedBytes = (value) => {
      return (0, exports.unpadBytes)((0, exports.intToBytes)(value));
    };
    exports.intToUnpaddedBytes = intToUnpaddedBytes;
    const compareBytes = (value1, value2) => {
      const bigIntValue1 = (0, exports.bytesToBigInt)(value1);
      const bigIntValue2 = (0, exports.bytesToBigInt)(value2);
      return bigIntValue1 > bigIntValue2 ? 1 : bigIntValue1 < bigIntValue2 ? -1 : 0;
    };
    exports.compareBytes = compareBytes;
    const randomBytes = (length) => {
      return (0, random_js_1.getRandomBytesSync)(length);
    };
    exports.randomBytes = randomBytes;
    const concatBytes2 = (...arrays) => {
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    };
    exports.concatBytes = concatBytes2;
    function bytesToInt32(bytes2, littleEndian = false) {
      if (bytes2.length < 4) {
        bytes2 = setLength(bytes2, 4, littleEndian);
      }
      const dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
      return dataView.getUint32(0, littleEndian);
    }
    exports.bytesToInt32 = bytesToInt32;
    function bytesToBigInt64(bytes2, littleEndian = false) {
      if (bytes2.length < 8) {
        bytes2 = setLength(bytes2, 8, littleEndian);
      }
      const dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
      return dataView.getBigUint64(0, littleEndian);
    }
    exports.bytesToBigInt64 = bytesToBigInt64;
    function int32ToBytes(value, littleEndian = false) {
      const buffer = new ArrayBuffer(4);
      const dataView = new DataView(buffer);
      dataView.setUint32(0, value, littleEndian);
      return new Uint8Array(buffer);
    }
    exports.int32ToBytes = int32ToBytes;
    function bigInt64ToBytes(value, littleEndian = false) {
      const buffer = new ArrayBuffer(8);
      const dataView = new DataView(buffer);
      dataView.setBigUint64(0, value, littleEndian);
      return new Uint8Array(buffer);
    }
    exports.bigInt64ToBytes = bigInt64ToBytes;
    var utils_js_2 = utilsExports;
    Object.defineProperty(exports, "bytesToUtf8", { enumerable: true, get: function() {
      return utils_js_2.bytesToUtf8;
    } });
    Object.defineProperty(exports, "equalsBytes", { enumerable: true, get: function() {
      return utils_js_2.equalsBytes;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_js_2.utf8ToBytes;
    } });
    function hexToBigInt(input) {
      return (0, exports.bytesToBigInt)((0, exports.hexToBytes)((0, internal_js_12.isHexString)(input) ? input : `0x${input}`));
    }
    exports.hexToBigInt = hexToBigInt;
  })(bytes$2);
  return bytes$2;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BIGINT_2EXP256 = exports.BIGINT_2EXP224 = exports.BIGINT_2EXP160 = exports.BIGINT_2EXP96 = exports.BIGINT_224 = exports.BIGINT_160 = exports.BIGINT_100 = exports.BIGINT_96 = exports.BIGINT_256 = exports.BIGINT_255 = exports.BIGINT_128 = exports.BIGINT_64 = exports.BIGINT_32 = exports.BIGINT_31 = exports.BIGINT_28 = exports.BIGINT_27 = exports.BIGINT_8 = exports.BIGINT_7 = exports.BIGINT_3 = exports.BIGINT_2 = exports.BIGINT_1 = exports.BIGINT_0 = exports.BIGINT_NEG1 = exports.RIPEMD160_ADDRESS_STRING = exports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
  const secp256k1_js_12 = secp256k1$1;
  const bytes_js_12 = requireBytes();
  exports.MAX_UINT64 = BigInt("0xffffffffffffffff");
  exports.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  exports.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
  exports.SECP256K1_ORDER = secp256k1_js_12.secp256k1.CURVE.n;
  exports.SECP256K1_ORDER_DIV_2 = secp256k1_js_12.secp256k1.CURVE.n / BigInt(2);
  exports.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  exports.KECCAK256_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
  exports.KECCAK256_NULL = (0, bytes_js_12.hexToBytes)(exports.KECCAK256_NULL_S);
  exports.KECCAK256_RLP_ARRAY_S = "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
  exports.KECCAK256_RLP_ARRAY = (0, bytes_js_12.hexToBytes)(exports.KECCAK256_RLP_ARRAY_S);
  exports.KECCAK256_RLP_S = "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
  exports.KECCAK256_RLP = (0, bytes_js_12.hexToBytes)(exports.KECCAK256_RLP_S);
  exports.RLP_EMPTY_STRING = Uint8Array.from([128]);
  exports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
  exports.RIPEMD160_ADDRESS_STRING = "0000000000000000000000000000000000000003";
  exports.BIGINT_NEG1 = BigInt(-1);
  exports.BIGINT_0 = BigInt(0);
  exports.BIGINT_1 = BigInt(1);
  exports.BIGINT_2 = BigInt(2);
  exports.BIGINT_3 = BigInt(3);
  exports.BIGINT_7 = BigInt(7);
  exports.BIGINT_8 = BigInt(8);
  exports.BIGINT_27 = BigInt(27);
  exports.BIGINT_28 = BigInt(28);
  exports.BIGINT_31 = BigInt(31);
  exports.BIGINT_32 = BigInt(32);
  exports.BIGINT_64 = BigInt(64);
  exports.BIGINT_128 = BigInt(128);
  exports.BIGINT_255 = BigInt(255);
  exports.BIGINT_256 = BigInt(256);
  exports.BIGINT_96 = BigInt(96);
  exports.BIGINT_100 = BigInt(100);
  exports.BIGINT_160 = BigInt(160);
  exports.BIGINT_224 = BigInt(224);
  exports.BIGINT_2EXP96 = BigInt(7922816251426434e13);
  exports.BIGINT_2EXP160 = BigInt(1461501637330903e33);
  exports.BIGINT_2EXP224 = BigInt(2695994666715064e52);
  exports.BIGINT_2EXP256 = exports.BIGINT_2 ** exports.BIGINT_256;
})(constants$3);
var units = {};
Object.defineProperty(units, "__esModule", { value: true });
units.formatBigDecimal = units.GWEI_TO_WEI = void 0;
const constants_js_1$3 = constants$3;
units.GWEI_TO_WEI = BigInt(1e9);
function formatBigDecimal(numerator, denominator, maxDecimalFactor) {
  if (denominator === constants_js_1$3.BIGINT_0) {
    denominator = constants_js_1$3.BIGINT_1;
  }
  const full = numerator / denominator;
  const fraction = (numerator - full * denominator) * maxDecimalFactor / denominator;
  const zerosPostDecimal = String(maxDecimalFactor).length - 1 - String(fraction).length;
  return `${full}.${"0".repeat(zerosPostDecimal)}${fraction}`;
}
units.formatBigDecimal = formatBigDecimal;
var account$2 = {};
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: true });
cjs$1.RLP = cjs$1.utils = cjs$1.decode = cjs$1.encode = void 0;
function encode2(input) {
  if (Array.isArray(input)) {
    const output2 = [];
    let outputLength = 0;
    for (let i = 0; i < input.length; i++) {
      const encoded = encode2(input[i]);
      output2.push(encoded);
      outputLength += encoded.length;
    }
    return concatBytes(encodeLength(outputLength, 192), ...output2);
  }
  const inputBuf = toBytes2(input);
  if (inputBuf.length === 1 && inputBuf[0] < 128) {
    return inputBuf;
  }
  return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
cjs$1.encode = encode2;
function safeSlice(input, start, end) {
  if (end > input.length) {
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  }
  return input.slice(start, end);
}
function decodeLength(v) {
  if (v[0] === 0) {
    throw new Error("invalid RLP: extra zeros");
  }
  return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
  if (len < 56) {
    return Uint8Array.from([len + offset]);
  }
  const hexLength = numberToHex(len);
  const lLength = hexLength.length / 2;
  const firstByte = numberToHex(offset + 55 + lLength);
  return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
  if (typeof input === "undefined" || input === null || input.length === 0) {
    return Uint8Array.from([]);
  }
  const inputBytes = toBytes2(input);
  const decoded = _decode(inputBytes);
  if (stream) {
    return {
      data: decoded.data,
      remainder: decoded.remainder.slice()
    };
  }
  if (decoded.remainder.length !== 0) {
    throw new Error("invalid RLP: remainder must be zero");
  }
  return decoded.data;
}
cjs$1.decode = decode;
function _decode(input) {
  let length, llength, data, innerRemainder, d;
  const decoded = [];
  const firstByte = input[0];
  if (firstByte <= 127) {
    return {
      data: input.slice(0, 1),
      remainder: input.subarray(1)
    };
  } else if (firstByte <= 183) {
    length = firstByte - 127;
    if (firstByte === 128) {
      data = Uint8Array.from([]);
    } else {
      data = safeSlice(input, 1, length);
    }
    if (length === 2 && data[0] < 128) {
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    }
    return {
      data,
      remainder: input.subarray(length)
    };
  } else if (firstByte <= 191) {
    llength = firstByte - 182;
    if (input.length - 1 < llength) {
      throw new Error("invalid RLP: not enough bytes for string length");
    }
    length = decodeLength(safeSlice(input, 1, llength));
    if (length <= 55) {
      throw new Error("invalid RLP: expected string length to be greater than 55");
    }
    data = safeSlice(input, llength, length + llength);
    return {
      data,
      remainder: input.subarray(length + llength)
    };
  } else if (firstByte <= 247) {
    length = firstByte - 191;
    innerRemainder = safeSlice(input, 1, length);
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.subarray(length)
    };
  } else {
    llength = firstByte - 246;
    length = decodeLength(safeSlice(input, 1, llength));
    if (length < 56) {
      throw new Error("invalid RLP: encoded list too short");
    }
    const totalLength = llength + length;
    if (totalLength > input.length) {
      throw new Error("invalid RLP: total length is larger than the data");
    }
    innerRemainder = safeSlice(input, llength, totalLength);
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.subarray(totalLength)
    };
  }
}
const cachedHexes = Array.from({ length: 256 }, (_v2, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += cachedHexes[uint8a[i]];
  }
  return hex;
}
function parseHexByte(hexByte) {
  const byte = Number.parseInt(hexByte, 16);
  if (Number.isNaN(byte))
    throw new Error("Invalid byte sequence");
  return byte;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    array[i] = parseHexByte(hex.slice(j, j + 2));
  }
  return array;
}
function concatBytes(...arrays) {
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function utf8ToBytes(utf) {
  return new TextEncoder().encode(utf);
}
function numberToHex(integer) {
  if (integer < 0) {
    throw new Error("Invalid integer as argument, must be unsigned!");
  }
  const hex = integer.toString(16);
  return hex.length % 2 ? `0${hex}` : hex;
}
function padToEven(a) {
  return a.length % 2 ? `0${a}` : a;
}
function isHexPrefixed(str) {
  return str.length >= 2 && str[0] === "0" && str[1] === "x";
}
function stripHexPrefix(str) {
  if (typeof str !== "string") {
    return str;
  }
  return isHexPrefixed(str) ? str.slice(2) : str;
}
function toBytes2(v) {
  if (v instanceof Uint8Array) {
    return v;
  }
  if (typeof v === "string") {
    if (isHexPrefixed(v)) {
      return hexToBytes(padToEven(stripHexPrefix(v)));
    }
    return utf8ToBytes(v);
  }
  if (typeof v === "number" || typeof v === "bigint") {
    if (!v) {
      return Uint8Array.from([]);
    }
    return hexToBytes(numberToHex(v));
  }
  if (v === null || v === void 0) {
    return Uint8Array.from([]);
  }
  throw new Error("toBytes: received unsupported type " + typeof v);
}
cjs$1.utils = {
  bytesToHex,
  concatBytes,
  hexToBytes,
  utf8ToBytes
};
cjs$1.RLP = { encode: encode2, decode };
var keccak = {};
var sha3 = {};
var _u64 = {};
Object.defineProperty(_u64, "__esModule", { value: true });
_u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.add = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = _u64.split = _u64.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
_u64.fromBig = fromBig;
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
_u64.split = split;
const toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
_u64.toBig = toBig;
const shrSH = (h, _l, s) => h >>> s;
_u64.shrSH = shrSH;
const shrSL = (h, l, s) => h << 32 - s | l >>> s;
_u64.shrSL = shrSL;
const rotrSH = (h, l, s) => h >>> s | l << 32 - s;
_u64.rotrSH = rotrSH;
const rotrSL = (h, l, s) => h << 32 - s | l >>> s;
_u64.rotrSL = rotrSL;
const rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
_u64.rotrBH = rotrBH;
const rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
_u64.rotrBL = rotrBL;
const rotr32H = (_h, l) => l;
_u64.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
_u64.rotr32L = rotr32L;
const rotlSH = (h, l, s) => h << s | l >>> 32 - s;
_u64.rotlSH = rotlSH;
const rotlSL = (h, l, s) => l << s | h >>> 32 - s;
_u64.rotlSL = rotlSL;
const rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
_u64.rotlBH = rotlBH;
const rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
_u64.rotlBL = rotlBL;
function add5(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
_u64.add = add5;
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
_u64.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
_u64.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
_u64.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
_u64.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
_u64.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
_u64.add5H = add5H;
const u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add: add5,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
_u64.default = u64;
Object.defineProperty(sha3, "__esModule", { value: true });
sha3.shake256 = sha3.shake128 = sha3.keccak_512 = sha3.keccak_384 = sha3.keccak_256 = sha3.keccak_224 = sha3.sha3_512 = sha3.sha3_384 = sha3.sha3_256 = sha3.sha3_224 = sha3.Keccak = sha3.keccakP = void 0;
const _assert_js_1 = _assert;
const _u64_js_1 = _u64;
const utils_js_1$2 = utils$5;
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R2 = _1n, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R2 = (R2 << _1n ^ (R2 >> _7n) * _0x71n) % _256n;
    if (R2 & _2n)
      t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
const rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
const rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
sha3.keccakP = keccakP;
class Keccak extends utils_js_1$2.Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    (0, _assert_js_1.number)(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = (0, utils_js_1$2.u32)(this.state);
  }
  keccak() {
    if (!utils_js_1$2.isLE)
      (0, utils_js_1$2.byteSwap32)(this.state32);
    keccakP(this.state32, this.rounds);
    if (!utils_js_1$2.isLE)
      (0, utils_js_1$2.byteSwap32)(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    (0, _assert_js_1.exists)(this);
    const { blockLen, state } = this;
    data = (0, utils_js_1$2.toBytes)(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    (0, _assert_js_1.exists)(this, false);
    (0, _assert_js_1.bytes)(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    (0, _assert_js_1.number)(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    (0, _assert_js_1.output)(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
sha3.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1$2.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
sha3.sha3_224 = gen(6, 144, 224 / 8);
sha3.sha3_256 = gen(6, 136, 256 / 8);
sha3.sha3_384 = gen(6, 104, 384 / 8);
sha3.sha3_512 = gen(6, 72, 512 / 8);
sha3.keccak_224 = gen(1, 144, 224 / 8);
sha3.keccak_256 = gen(1, 136, 256 / 8);
sha3.keccak_384 = gen(1, 104, 384 / 8);
sha3.keccak_512 = gen(1, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1$2.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
sha3.shake128 = genShake(31, 168, 128 / 8);
sha3.shake256 = genShake(31, 136, 256 / 8);
Object.defineProperty(keccak, "__esModule", { value: true });
keccak.keccak512 = keccak.keccak384 = keccak.keccak256 = keccak.keccak224 = void 0;
const sha3_1 = sha3;
const utils_js_1$1 = utilsExports;
keccak.keccak224 = (0, utils_js_1$1.wrapHash)(sha3_1.keccak_224);
keccak.keccak256 = (() => {
  const k = (0, utils_js_1$1.wrapHash)(sha3_1.keccak_256);
  k.create = sha3_1.keccak_256.create;
  return k;
})();
keccak.keccak384 = (0, utils_js_1$1.wrapHash)(sha3_1.keccak_384);
keccak.keccak512 = (0, utils_js_1$1.wrapHash)(sha3_1.keccak_512);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
  const rlp_1 = cjs$1;
  const keccak_js_12 = keccak;
  const secp256k1_js_12 = secp256k1$1;
  const bytes_js_12 = requireBytes();
  const constants_js_12 = constants$3;
  const helpers_js_12 = requireHelpers();
  const internal_js_12 = requireInternal();
  class Account {
    /**
     * This constructor assigns and validates the values.
     * Use the static factory methods to assist in creating an Account from varying data types.
     * undefined get assigned with the defaults present, but null args are retained as is
     */
    constructor(nonce2 = constants_js_12.BIGINT_0, balance = constants_js_12.BIGINT_0, storageRoot = constants_js_12.KECCAK256_RLP, codeHash = constants_js_12.KECCAK256_NULL, codeSize = null, version2 = 0) {
      this._nonce = null;
      this._balance = null;
      this._storageRoot = null;
      this._codeHash = null;
      this._codeSize = null;
      this._version = null;
      this._nonce = nonce2;
      this._balance = balance;
      this._storageRoot = storageRoot;
      this._codeHash = codeHash;
      if (codeSize === null && codeHash !== null && !this.isContract()) {
        codeSize = 0;
      }
      this._codeSize = codeSize;
      this._version = version2;
      this._validate();
    }
    get version() {
      if (this._version !== null) {
        return this._version;
      } else {
        throw Error(`version=${this._version} not loaded`);
      }
    }
    set version(_version) {
      this._version = _version;
    }
    get nonce() {
      if (this._nonce !== null) {
        return this._nonce;
      } else {
        throw Error(`nonce=${this._nonce} not loaded`);
      }
    }
    set nonce(_nonce) {
      this._nonce = _nonce;
    }
    get balance() {
      if (this._balance !== null) {
        return this._balance;
      } else {
        throw Error(`balance=${this._balance} not loaded`);
      }
    }
    set balance(_balance) {
      this._balance = _balance;
    }
    get storageRoot() {
      if (this._storageRoot !== null) {
        return this._storageRoot;
      } else {
        throw Error(`storageRoot=${this._storageRoot} not loaded`);
      }
    }
    set storageRoot(_storageRoot) {
      this._storageRoot = _storageRoot;
    }
    get codeHash() {
      if (this._codeHash !== null) {
        return this._codeHash;
      } else {
        throw Error(`codeHash=${this._codeHash} not loaded`);
      }
    }
    set codeHash(_codeHash) {
      this._codeHash = _codeHash;
    }
    get codeSize() {
      if (this._codeSize !== null) {
        return this._codeSize;
      } else {
        throw Error(`codeHash=${this._codeSize} not loaded`);
      }
    }
    set codeSize(_codeSize) {
      this._codeSize = _codeSize;
    }
    static fromAccountData(accountData) {
      const { nonce: nonce2, balance, storageRoot, codeHash } = accountData;
      if (nonce2 === null || balance === null || storageRoot === null || codeHash === null) {
        throw Error(`Partial fields not supported in fromAccountData`);
      }
      return new Account(nonce2 !== void 0 ? (0, bytes_js_12.bytesToBigInt)((0, bytes_js_12.toBytes)(nonce2)) : void 0, balance !== void 0 ? (0, bytes_js_12.bytesToBigInt)((0, bytes_js_12.toBytes)(balance)) : void 0, storageRoot !== void 0 ? (0, bytes_js_12.toBytes)(storageRoot) : void 0, codeHash !== void 0 ? (0, bytes_js_12.toBytes)(codeHash) : void 0);
    }
    static fromPartialAccountData(partialAccountData) {
      const { nonce: nonce2, balance, storageRoot, codeHash, codeSize, version: version2 } = partialAccountData;
      if (nonce2 === null && balance === null && storageRoot === null && codeHash === null && codeSize === null && version2 === null) {
        throw Error(`All partial fields null`);
      }
      return new Account(nonce2 !== void 0 && nonce2 !== null ? (0, bytes_js_12.bytesToBigInt)((0, bytes_js_12.toBytes)(nonce2)) : nonce2, balance !== void 0 && balance !== null ? (0, bytes_js_12.bytesToBigInt)((0, bytes_js_12.toBytes)(balance)) : balance, storageRoot !== void 0 && storageRoot !== null ? (0, bytes_js_12.toBytes)(storageRoot) : storageRoot, codeHash !== void 0 && codeHash !== null ? (0, bytes_js_12.toBytes)(codeHash) : codeHash, codeSize !== void 0 && codeSize !== null ? (0, bytes_js_12.bytesToInt)((0, bytes_js_12.toBytes)(codeSize)) : codeSize, version2 !== void 0 && version2 !== null ? (0, bytes_js_12.bytesToInt)((0, bytes_js_12.toBytes)(version2)) : version2);
    }
    static fromRlpSerializedAccount(serialized) {
      const values = rlp_1.RLP.decode(serialized);
      if (!Array.isArray(values)) {
        throw new Error("Invalid serialized account input. Must be array");
      }
      return this.fromValuesArray(values);
    }
    static fromRlpSerializedPartialAccount(serialized) {
      const values = rlp_1.RLP.decode(serialized);
      if (!Array.isArray(values)) {
        throw new Error("Invalid serialized account input. Must be array");
      }
      let nonce2 = null;
      if (!Array.isArray(values[0])) {
        throw new Error("Invalid partial nonce encoding. Must be array");
      } else {
        const isNotNullIndicator = (0, bytes_js_12.bytesToInt)(values[0][0]);
        if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {
          throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for nonce`);
        }
        if (isNotNullIndicator === 1) {
          nonce2 = (0, bytes_js_12.bytesToBigInt)(values[0][1]);
        }
      }
      let balance = null;
      if (!Array.isArray(values[1])) {
        throw new Error("Invalid partial balance encoding. Must be array");
      } else {
        const isNotNullIndicator = (0, bytes_js_12.bytesToInt)(values[1][0]);
        if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {
          throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for balance`);
        }
        if (isNotNullIndicator === 1) {
          balance = (0, bytes_js_12.bytesToBigInt)(values[1][1]);
        }
      }
      let storageRoot = null;
      if (!Array.isArray(values[2])) {
        throw new Error("Invalid partial storageRoot encoding. Must be array");
      } else {
        const isNotNullIndicator = (0, bytes_js_12.bytesToInt)(values[2][0]);
        if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {
          throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for storageRoot`);
        }
        if (isNotNullIndicator === 1) {
          storageRoot = values[2][1];
        }
      }
      let codeHash = null;
      if (!Array.isArray(values[3])) {
        throw new Error("Invalid partial codeHash encoding. Must be array");
      } else {
        const isNotNullIndicator = (0, bytes_js_12.bytesToInt)(values[3][0]);
        if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {
          throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for codeHash`);
        }
        if (isNotNullIndicator === 1) {
          codeHash = values[3][1];
        }
      }
      let codeSize = null;
      if (!Array.isArray(values[4])) {
        throw new Error("Invalid partial codeSize encoding. Must be array");
      } else {
        const isNotNullIndicator = (0, bytes_js_12.bytesToInt)(values[4][0]);
        if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {
          throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for codeSize`);
        }
        if (isNotNullIndicator === 1) {
          codeSize = (0, bytes_js_12.bytesToInt)(values[4][1]);
        }
      }
      let version2 = null;
      if (!Array.isArray(values[5])) {
        throw new Error("Invalid partial version encoding. Must be array");
      } else {
        const isNotNullIndicator = (0, bytes_js_12.bytesToInt)(values[5][0]);
        if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {
          throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for version`);
        }
        if (isNotNullIndicator === 1) {
          version2 = (0, bytes_js_12.bytesToInt)(values[5][1]);
        }
      }
      return this.fromPartialAccountData({ balance, nonce: nonce2, storageRoot, codeHash, codeSize, version: version2 });
    }
    static fromValuesArray(values) {
      const [nonce2, balance, storageRoot, codeHash] = values;
      return new Account((0, bytes_js_12.bytesToBigInt)(nonce2), (0, bytes_js_12.bytesToBigInt)(balance), storageRoot, codeHash);
    }
    _validate() {
      if (this._nonce !== null && this._nonce < constants_js_12.BIGINT_0) {
        throw new Error("nonce must be greater than zero");
      }
      if (this._balance !== null && this._balance < constants_js_12.BIGINT_0) {
        throw new Error("balance must be greater than zero");
      }
      if (this._storageRoot !== null && this._storageRoot.length !== 32) {
        throw new Error("storageRoot must have a length of 32");
      }
      if (this._codeHash !== null && this._codeHash.length !== 32) {
        throw new Error("codeHash must have a length of 32");
      }
      if (this._codeSize !== null && this._codeSize < constants_js_12.BIGINT_0) {
        throw new Error("codeSize must be greater than zero");
      }
    }
    /**
     * Returns an array of Uint8Arrays of the raw bytes for the account, in order.
     */
    raw() {
      return [
        (0, bytes_js_12.bigIntToUnpaddedBytes)(this.nonce),
        (0, bytes_js_12.bigIntToUnpaddedBytes)(this.balance),
        this.storageRoot,
        this.codeHash
      ];
    }
    /**
     * Returns the RLP serialization of the account as a `Uint8Array`.
     */
    serialize() {
      return rlp_1.RLP.encode(this.raw());
    }
    serializeWithPartialInfo() {
      const partialData = [];
      const zeroEncoded = (0, bytes_js_12.intToUnpaddedBytes)(0);
      const oneEncoded = (0, bytes_js_12.intToUnpaddedBytes)(1);
      if (this._nonce !== null) {
        partialData.push([oneEncoded, (0, bytes_js_12.bigIntToUnpaddedBytes)(this._nonce)]);
      } else {
        partialData.push([zeroEncoded]);
      }
      if (this._balance !== null) {
        partialData.push([oneEncoded, (0, bytes_js_12.bigIntToUnpaddedBytes)(this._balance)]);
      } else {
        partialData.push([zeroEncoded]);
      }
      if (this._storageRoot !== null) {
        partialData.push([oneEncoded, this._storageRoot]);
      } else {
        partialData.push([zeroEncoded]);
      }
      if (this._codeHash !== null) {
        partialData.push([oneEncoded, this._codeHash]);
      } else {
        partialData.push([zeroEncoded]);
      }
      if (this._codeSize !== null) {
        partialData.push([oneEncoded, (0, bytes_js_12.intToUnpaddedBytes)(this._codeSize)]);
      } else {
        partialData.push([zeroEncoded]);
      }
      if (this._version !== null) {
        partialData.push([oneEncoded, (0, bytes_js_12.intToUnpaddedBytes)(this._version)]);
      } else {
        partialData.push([zeroEncoded]);
      }
      return rlp_1.RLP.encode(partialData);
    }
    /**
     * Returns a `Boolean` determining if the account is a contract.
     */
    isContract() {
      if (this._codeHash === null && this._codeSize === null) {
        throw Error(`Insufficient data as codeHash=null and codeSize=null`);
      }
      return this._codeHash !== null && !(0, bytes_js_12.equalsBytes)(this._codeHash, constants_js_12.KECCAK256_NULL) || this._codeSize !== null && this._codeSize !== 0;
    }
    /**
     * Returns a `Boolean` determining if the account is empty complying to the definition of
     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
     * "An account is considered empty when it has no code and zero nonce and zero balance."
     */
    isEmpty() {
      if (this._balance !== null && this.balance !== constants_js_12.BIGINT_0 || this._nonce === null && this.nonce !== constants_js_12.BIGINT_0 || this._codeHash !== null && !(0, bytes_js_12.equalsBytes)(this.codeHash, constants_js_12.KECCAK256_NULL)) {
        return false;
      }
      return this.balance === constants_js_12.BIGINT_0 && this.nonce === constants_js_12.BIGINT_0 && (0, bytes_js_12.equalsBytes)(this.codeHash, constants_js_12.KECCAK256_NULL);
    }
  }
  exports.Account = Account;
  const isValidAddress = function(hexAddress) {
    try {
      (0, helpers_js_12.assertIsString)(hexAddress);
    } catch (e) {
      return false;
    }
    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
  };
  exports.isValidAddress = isValidAddress;
  const toChecksumAddress = function(hexAddress, eip1191ChainId) {
    (0, helpers_js_12.assertIsHexString)(hexAddress);
    const address2 = (0, internal_js_12.stripHexPrefix)(hexAddress).toLowerCase();
    let prefix = "";
    if (eip1191ChainId !== void 0) {
      const chainId = (0, bytes_js_12.bytesToBigInt)((0, bytes_js_12.toBytes)(eip1191ChainId));
      prefix = chainId.toString() + "0x";
    }
    const bytes2 = (0, bytes_js_12.utf8ToBytes)(prefix + address2);
    const hash3 = (0, bytes_js_12.bytesToHex)((0, keccak_js_12.keccak256)(bytes2)).slice(2);
    let ret = "";
    for (let i = 0; i < address2.length; i++) {
      if (parseInt(hash3[i], 16) >= 8) {
        ret += address2[i].toUpperCase();
      } else {
        ret += address2[i];
      }
    }
    return `0x${ret}`;
  };
  exports.toChecksumAddress = toChecksumAddress;
  const isValidChecksumAddress = function(hexAddress, eip1191ChainId) {
    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
  };
  exports.isValidChecksumAddress = isValidChecksumAddress;
  const generateAddress = function(from, nonce2) {
    (0, helpers_js_12.assertIsBytes)(from);
    (0, helpers_js_12.assertIsBytes)(nonce2);
    if ((0, bytes_js_12.bytesToBigInt)(nonce2) === constants_js_12.BIGINT_0) {
      return (0, keccak_js_12.keccak256)(rlp_1.RLP.encode([from, Uint8Array.from([])])).subarray(-20);
    }
    return (0, keccak_js_12.keccak256)(rlp_1.RLP.encode([from, nonce2])).subarray(-20);
  };
  exports.generateAddress = generateAddress;
  const generateAddress2 = function(from, salt, initCode) {
    (0, helpers_js_12.assertIsBytes)(from);
    (0, helpers_js_12.assertIsBytes)(salt);
    (0, helpers_js_12.assertIsBytes)(initCode);
    if (from.length !== 20) {
      throw new Error("Expected from to be of length 20");
    }
    if (salt.length !== 32) {
      throw new Error("Expected salt to be of length 32");
    }
    const address2 = (0, keccak_js_12.keccak256)((0, bytes_js_12.concatBytes)((0, bytes_js_12.hexToBytes)("0xff"), from, salt, (0, keccak_js_12.keccak256)(initCode)));
    return address2.subarray(-20);
  };
  exports.generateAddress2 = generateAddress2;
  const isValidPrivate = function(privateKey) {
    return secp256k1_js_12.secp256k1.utils.isValidPrivateKey(privateKey);
  };
  exports.isValidPrivate = isValidPrivate;
  const isValidPublic = function(publicKey, sanitize = false) {
    (0, helpers_js_12.assertIsBytes)(publicKey);
    if (publicKey.length === 64) {
      try {
        secp256k1_js_12.secp256k1.ProjectivePoint.fromHex((0, bytes_js_12.concatBytes)(Uint8Array.from([4]), publicKey));
        return true;
      } catch (e) {
        return false;
      }
    }
    if (!sanitize) {
      return false;
    }
    try {
      secp256k1_js_12.secp256k1.ProjectivePoint.fromHex(publicKey);
      return true;
    } catch (e) {
      return false;
    }
  };
  exports.isValidPublic = isValidPublic;
  const pubToAddress = function(pubKey, sanitize = false) {
    (0, helpers_js_12.assertIsBytes)(pubKey);
    if (sanitize && pubKey.length !== 64) {
      pubKey = secp256k1_js_12.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);
    }
    if (pubKey.length !== 64) {
      throw new Error("Expected pubKey to be of length 64");
    }
    return (0, keccak_js_12.keccak256)(pubKey).subarray(-20);
  };
  exports.pubToAddress = pubToAddress;
  exports.publicToAddress = exports.pubToAddress;
  const privateToPublic = function(privateKey) {
    (0, helpers_js_12.assertIsBytes)(privateKey);
    return secp256k1_js_12.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1);
  };
  exports.privateToPublic = privateToPublic;
  const privateToAddress = function(privateKey) {
    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
  };
  exports.privateToAddress = privateToAddress;
  const importPublic = function(publicKey) {
    (0, helpers_js_12.assertIsBytes)(publicKey);
    if (publicKey.length !== 64) {
      publicKey = secp256k1_js_12.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1);
    }
    return publicKey;
  };
  exports.importPublic = importPublic;
  const zeroAddress = function() {
    const addressLength = 20;
    const addr = (0, bytes_js_12.zeros)(addressLength);
    return (0, bytes_js_12.bytesToHex)(addr);
  };
  exports.zeroAddress = zeroAddress;
  const isZeroAddress = function(hexAddress) {
    try {
      (0, helpers_js_12.assertIsString)(hexAddress);
    } catch (e) {
      return false;
    }
    const zeroAddr = (0, exports.zeroAddress)();
    return zeroAddr === hexAddress;
  };
  exports.isZeroAddress = isZeroAddress;
  function accountBodyFromSlim(body) {
    const [nonce2, balance, storageRoot, codeHash] = body;
    return [
      nonce2,
      balance,
      storageRoot.length === 0 ? constants_js_12.KECCAK256_RLP : storageRoot,
      codeHash.length === 0 ? constants_js_12.KECCAK256_NULL : codeHash
    ];
  }
  exports.accountBodyFromSlim = accountBodyFromSlim;
  const emptyUint8Arr = new Uint8Array(0);
  function accountBodyToSlim(body) {
    const [nonce2, balance, storageRoot, codeHash] = body;
    return [
      nonce2,
      balance,
      (0, bytes_js_12.equalsBytes)(storageRoot, constants_js_12.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,
      (0, bytes_js_12.equalsBytes)(codeHash, constants_js_12.KECCAK256_NULL) ? emptyUint8Arr : codeHash
    ];
  }
  exports.accountBodyToSlim = accountBodyToSlim;
  function accountBodyToRLP(body, couldBeSlim = true) {
    const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;
    return rlp_1.RLP.encode(accountBody);
  }
  exports.accountBodyToRLP = accountBodyToRLP;
})(account$2);
var address = {};
Object.defineProperty(address, "__esModule", { value: true });
address.Address = void 0;
const account_js_1 = account$2;
const bytes_js_1$4 = requireBytes();
const constants_js_1$2 = constants$3;
class Address {
  constructor(bytes2) {
    if (bytes2.length !== 20) {
      throw new Error("Invalid address length");
    }
    this.bytes = bytes2;
  }
  /**
   * Returns the zero address.
   */
  static zero() {
    return new Address((0, bytes_js_1$4.zeros)(20));
  }
  /**
   * Returns an Address object from a hex-encoded string.
   * @param str - Hex-encoded address
   */
  static fromString(str) {
    if (!(0, account_js_1.isValidAddress)(str)) {
      throw new Error(`Invalid address input=${str}`);
    }
    return new Address((0, bytes_js_1$4.hexToBytes)(str));
  }
  /**
   * Returns an address for a given public key.
   * @param pubKey The two points of an uncompressed key
   */
  static fromPublicKey(pubKey) {
    if (!(pubKey instanceof Uint8Array)) {
      throw new Error("Public key should be Uint8Array");
    }
    const bytes2 = (0, account_js_1.pubToAddress)(pubKey);
    return new Address(bytes2);
  }
  /**
   * Returns an address for a given private key.
   * @param privateKey A private key must be 256 bits wide
   */
  static fromPrivateKey(privateKey) {
    if (!(privateKey instanceof Uint8Array)) {
      throw new Error("Private key should be Uint8Array");
    }
    const bytes2 = (0, account_js_1.privateToAddress)(privateKey);
    return new Address(bytes2);
  }
  /**
   * Generates an address for a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */
  static generate(from, nonce2) {
    if (typeof nonce2 !== "bigint") {
      throw new Error("Expected nonce to be a bigint");
    }
    return new Address((0, account_js_1.generateAddress)(from.bytes, (0, bytes_js_1$4.bigIntToBytes)(nonce2)));
  }
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */
  static generate2(from, salt, initCode) {
    if (!(salt instanceof Uint8Array)) {
      throw new Error("Expected salt to be a Uint8Array");
    }
    if (!(initCode instanceof Uint8Array)) {
      throw new Error("Expected initCode to be a Uint8Array");
    }
    return new Address((0, account_js_1.generateAddress2)(from.bytes, salt, initCode));
  }
  /**
   * Is address equal to another.
   */
  equals(address2) {
    return (0, bytes_js_1$4.equalsBytes)(this.bytes, address2.bytes);
  }
  /**
   * Is address zero.
   */
  isZero() {
    return this.equals(Address.zero());
  }
  /**
   * True if address is in the address range defined
   * by EIP-1352
   */
  isPrecompileOrSystemAddress() {
    const address2 = (0, bytes_js_1$4.bytesToBigInt)(this.bytes);
    const rangeMin = constants_js_1$2.BIGINT_0;
    const rangeMax = BigInt("0xffff");
    return address2 >= rangeMin && address2 <= rangeMax;
  }
  /**
   * Returns hex encoding of address.
   */
  toString() {
    return (0, bytes_js_1$4.bytesToHex)(this.bytes);
  }
  /**
   * Returns a new Uint8Array representation of address.
   */
  toBytes() {
    return new Uint8Array(this.bytes);
  }
}
address.Address = Address;
var db = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueEncoding = exports.KeyEncoding = void 0;
  (function(KeyEncoding) {
    KeyEncoding["String"] = "string";
    KeyEncoding["Bytes"] = "view";
    KeyEncoding["Number"] = "number";
  })(exports.KeyEncoding || (exports.KeyEncoding = {}));
  (function(ValueEncoding) {
    ValueEncoding["String"] = "string";
    ValueEncoding["Bytes"] = "view";
    ValueEncoding["JSON"] = "json";
  })(exports.ValueEncoding || (exports.ValueEncoding = {}));
})(db);
var withdrawal = {};
var types$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toType = exports.TypeOutput = exports.isNestedUint8Array = void 0;
  const bytes_js_12 = requireBytes();
  const internal_js_12 = requireInternal();
  function isNestedUint8Array(value) {
    if (!Array.isArray(value)) {
      return false;
    }
    for (const item of value) {
      if (Array.isArray(item)) {
        if (!isNestedUint8Array(item)) {
          return false;
        }
      } else if (!(item instanceof Uint8Array)) {
        return false;
      }
    }
    return true;
  }
  exports.isNestedUint8Array = isNestedUint8Array;
  var TypeOutput;
  (function(TypeOutput2) {
    TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
    TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
    TypeOutput2[TypeOutput2["Uint8Array"] = 2] = "Uint8Array";
    TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
  })(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
  function toType(input, outputType) {
    if (input === null) {
      return null;
    }
    if (input === void 0) {
      return void 0;
    }
    if (typeof input === "string" && !(0, internal_js_12.isHexString)(input)) {
      throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
    } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
      throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
    }
    const output2 = (0, bytes_js_12.toBytes)(input);
    switch (outputType) {
      case TypeOutput.Uint8Array:
        return output2;
      case TypeOutput.BigInt:
        return (0, bytes_js_12.bytesToBigInt)(output2);
      case TypeOutput.Number: {
        const bigInt2 = (0, bytes_js_12.bytesToBigInt)(output2);
        if (bigInt2 > BigInt(Number.MAX_SAFE_INTEGER)) {
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        }
        return Number(bigInt2);
      }
      case TypeOutput.PrefixedHexString:
        return (0, bytes_js_12.bytesToHex)(output2);
      default:
        throw new Error("unknown outputType");
    }
  }
  exports.toType = toType;
})(types$2);
Object.defineProperty(withdrawal, "__esModule", { value: true });
withdrawal.Withdrawal = void 0;
const address_js_1 = address;
const bytes_js_1$3 = requireBytes();
const constants_js_1$1 = constants$3;
const types_js_1 = types$2;
class Withdrawal {
  /**
   * This constructor assigns and validates the values.
   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
   */
  constructor(index2, validatorIndex, address2, amount2) {
    this.index = index2;
    this.validatorIndex = validatorIndex;
    this.address = address2;
    this.amount = amount2;
  }
  static fromWithdrawalData(withdrawalData) {
    const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData } = withdrawalData;
    const index2 = (0, types_js_1.toType)(indexData, types_js_1.TypeOutput.BigInt);
    const validatorIndex = (0, types_js_1.toType)(validatorIndexData, types_js_1.TypeOutput.BigInt);
    const address2 = addressData instanceof address_js_1.Address ? addressData : new address_js_1.Address((0, bytes_js_1$3.toBytes)(addressData));
    const amount2 = (0, types_js_1.toType)(amountData, types_js_1.TypeOutput.BigInt);
    return new Withdrawal(index2, validatorIndex, address2, amount2);
  }
  static fromValuesArray(withdrawalArray) {
    if (withdrawalArray.length !== 4) {
      throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);
    }
    const [index2, validatorIndex, address2, amount2] = withdrawalArray;
    return Withdrawal.fromWithdrawalData({ index: index2, validatorIndex, address: address2, amount: amount2 });
  }
  /**
   * Convert a withdrawal to a buffer array
   * @param withdrawal the withdrawal to convert
   * @returns buffer array of the withdrawal
   */
  static toBytesArray(withdrawal2) {
    const { index: index2, validatorIndex, address: address2, amount: amount2 } = withdrawal2;
    const indexBytes = (0, types_js_1.toType)(index2, types_js_1.TypeOutput.BigInt) === constants_js_1$1.BIGINT_0 ? new Uint8Array() : (0, types_js_1.toType)(index2, types_js_1.TypeOutput.Uint8Array);
    const validatorIndexBytes = (0, types_js_1.toType)(validatorIndex, types_js_1.TypeOutput.BigInt) === constants_js_1$1.BIGINT_0 ? new Uint8Array() : (0, types_js_1.toType)(validatorIndex, types_js_1.TypeOutput.Uint8Array);
    const addressBytes = address2 instanceof address_js_1.Address ? address2.bytes : (0, types_js_1.toType)(address2, types_js_1.TypeOutput.Uint8Array);
    const amountBytes = (0, types_js_1.toType)(amount2, types_js_1.TypeOutput.BigInt) === constants_js_1$1.BIGINT_0 ? new Uint8Array() : (0, types_js_1.toType)(amount2, types_js_1.TypeOutput.Uint8Array);
    return [indexBytes, validatorIndexBytes, addressBytes, amountBytes];
  }
  raw() {
    return Withdrawal.toBytesArray(this);
  }
  toValue() {
    return {
      index: this.index,
      validatorIndex: this.validatorIndex,
      address: this.address.bytes,
      amount: this.amount
    };
  }
  toJSON() {
    return {
      index: (0, bytes_js_1$3.bigIntToHex)(this.index),
      validatorIndex: (0, bytes_js_1$3.bigIntToHex)(this.validatorIndex),
      address: (0, bytes_js_1$3.bytesToHex)(this.address.bytes),
      amount: (0, bytes_js_1$3.bigIntToHex)(this.amount)
    };
  }
}
withdrawal.Withdrawal = Withdrawal;
var signature$1 = {};
Object.defineProperty(signature$1, "__esModule", { value: true });
signature$1.hashPersonalMessage = signature$1.isValidSignature = signature$1.fromRpcSig = signature$1.toCompactSig = signature$1.toRpcSig = signature$1.ecrecover = signature$1.calculateSigRecovery = signature$1.ecsign = void 0;
const keccak_js_1 = keccak;
const secp256k1_js_1 = secp256k1$1;
const bytes_js_1$2 = requireBytes();
const constants_js_1 = constants$3;
const helpers_js_1 = requireHelpers();
function ecsign(msgHash, privateKey, chainId) {
  const sig = secp256k1_js_1.secp256k1.sign(msgHash, privateKey);
  const buf = sig.toCompactRawBytes();
  const r = buf.slice(0, 32);
  const s = buf.slice(32, 64);
  const v = chainId === void 0 ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * constants_js_1.BIGINT_2;
  return { r, s, v };
}
signature$1.ecsign = ecsign;
function calculateSigRecovery(v, chainId) {
  if (v === constants_js_1.BIGINT_0 || v === constants_js_1.BIGINT_1)
    return v;
  if (chainId === void 0) {
    return v - constants_js_1.BIGINT_27;
  }
  return v - (chainId * constants_js_1.BIGINT_2 + BigInt(35));
}
signature$1.calculateSigRecovery = calculateSigRecovery;
function isValidSigRecovery(recovery) {
  return recovery === constants_js_1.BIGINT_0 || recovery === constants_js_1.BIGINT_1;
}
const ecrecover = function(msgHash, v, r, s, chainId) {
  const signature2 = (0, bytes_js_1$2.concatBytes)((0, bytes_js_1$2.setLengthLeft)(r, 32), (0, bytes_js_1$2.setLengthLeft)(s, 32));
  const recovery = calculateSigRecovery(v, chainId);
  if (!isValidSigRecovery(recovery)) {
    throw new Error("Invalid signature v value");
  }
  const sig = secp256k1_js_1.secp256k1.Signature.fromCompact(signature2).addRecoveryBit(Number(recovery));
  const senderPubKey = sig.recoverPublicKey(msgHash);
  return senderPubKey.toRawBytes(false).slice(1);
};
signature$1.ecrecover = ecrecover;
const toRpcSig = function(v, r, s, chainId) {
  const recovery = calculateSigRecovery(v, chainId);
  if (!isValidSigRecovery(recovery)) {
    throw new Error("Invalid signature v value");
  }
  return (0, bytes_js_1$2.bytesToHex)((0, bytes_js_1$2.concatBytes)((0, bytes_js_1$2.setLengthLeft)(r, 32), (0, bytes_js_1$2.setLengthLeft)(s, 32), (0, bytes_js_1$2.toBytes)(v)));
};
signature$1.toRpcSig = toRpcSig;
const toCompactSig = function(v, r, s, chainId) {
  const recovery = calculateSigRecovery(v, chainId);
  if (!isValidSigRecovery(recovery)) {
    throw new Error("Invalid signature v value");
  }
  const ss = Uint8Array.from([...s]);
  if (v > BigInt(28) && v % constants_js_1.BIGINT_2 === constants_js_1.BIGINT_1 || v === constants_js_1.BIGINT_1 || v === BigInt(28)) {
    ss[0] |= 128;
  }
  return (0, bytes_js_1$2.bytesToHex)((0, bytes_js_1$2.concatBytes)((0, bytes_js_1$2.setLengthLeft)(r, 32), (0, bytes_js_1$2.setLengthLeft)(ss, 32)));
};
signature$1.toCompactSig = toCompactSig;
const fromRpcSig = function(sig) {
  const bytes2 = (0, bytes_js_1$2.toBytes)(sig);
  let r;
  let s;
  let v;
  if (bytes2.length >= 65) {
    r = bytes2.subarray(0, 32);
    s = bytes2.subarray(32, 64);
    v = (0, bytes_js_1$2.bytesToBigInt)(bytes2.subarray(64));
  } else if (bytes2.length === 64) {
    r = bytes2.subarray(0, 32);
    s = bytes2.subarray(32, 64);
    v = BigInt((0, bytes_js_1$2.bytesToInt)(bytes2.subarray(32, 33)) >> 7);
    s[0] &= 127;
  } else {
    throw new Error("Invalid signature length");
  }
  if (v < 27) {
    v = v + constants_js_1.BIGINT_27;
  }
  return {
    v,
    r,
    s
  };
};
signature$1.fromRpcSig = fromRpcSig;
const isValidSignature = function(v, r, s, homesteadOrLater = true, chainId) {
  if (r.length !== 32 || s.length !== 32) {
    return false;
  }
  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
    return false;
  }
  const rBigInt = (0, bytes_js_1$2.bytesToBigInt)(r);
  const sBigInt = (0, bytes_js_1$2.bytesToBigInt)(s);
  if (rBigInt === constants_js_1.BIGINT_0 || rBigInt >= constants_js_1.SECP256K1_ORDER || sBigInt === constants_js_1.BIGINT_0 || sBigInt >= constants_js_1.SECP256K1_ORDER) {
    return false;
  }
  if (homesteadOrLater && sBigInt >= constants_js_1.SECP256K1_ORDER_DIV_2) {
    return false;
  }
  return true;
};
signature$1.isValidSignature = isValidSignature;
const hashPersonalMessage = function(message2) {
  (0, helpers_js_1.assertIsBytes)(message2);
  const prefix = (0, bytes_js_1$2.utf8ToBytes)(`Ethereum Signed Message:
${message2.length}`);
  return (0, keccak_js_1.keccak256)((0, bytes_js_1$2.concatBytes)(prefix, message2));
};
signature$1.hashPersonalMessage = hashPersonalMessage;
var asyncEventEmitter = {};
Object.defineProperty(asyncEventEmitter, "__esModule", { value: true });
asyncEventEmitter.AsyncEventEmitter = void 0;
const events_1 = eventsExports;
async function runInSeries(context, tasks, data) {
  let error;
  for await (const task of tasks) {
    try {
      if (task.length < 2) {
        task.call(context, data);
      } else {
        await new Promise((resolve2, reject) => {
          task.call(context, data, (error2) => {
            if (error2) {
              reject(error2);
            } else {
              resolve2();
            }
          });
        });
      }
    } catch (e) {
      error = e;
    }
  }
  if (error) {
    throw error;
  }
}
class AsyncEventEmitter extends events_1.EventEmitter {
  emit(event, ...args) {
    let [data, callback] = args;
    const self2 = this;
    let listeners = self2._events[event] ?? [];
    if (callback === void 0 && typeof data === "function") {
      callback = data;
      data = void 0;
    }
    if (event === "newListener" || event === "removeListener") {
      data = {
        event: data,
        fn: callback
      };
      callback = void 0;
    }
    listeners = Array.isArray(listeners) ? listeners : [listeners];
    runInSeries(self2, listeners.slice(), data).then(callback).catch(callback);
    return self2.listenerCount(event) > 0;
  }
  once(event, listener) {
    const self2 = this;
    let g;
    if (typeof listener !== "function") {
      throw new TypeError("listener must be a function");
    }
    if (listener.length >= 2) {
      g = function(e, next2) {
        self2.removeListener(event, g);
        void listener(e, next2);
      };
    } else {
      g = function(e) {
        self2.removeListener(event, g);
        void listener(e, g);
      };
    }
    self2.on(event, g);
    return self2;
  }
  first(event, listener) {
    let listeners = this._events[event] ?? [];
    if (typeof listener !== "function") {
      throw new TypeError("listener must be a function");
    }
    if (!Array.isArray(listeners)) {
      this._events[event] = listeners = [listeners];
    }
    listeners.unshift(listener);
    return this;
  }
  before(event, target, listener) {
    return this.beforeOrAfter(event, target, listener);
  }
  after(event, target, listener) {
    return this.beforeOrAfter(event, target, listener, "after");
  }
  beforeOrAfter(event, target, listener, beforeOrAfter) {
    let listeners = this._events[event] ?? [];
    let i;
    let index2;
    const add6 = beforeOrAfter === "after" ? 1 : 0;
    if (typeof listener !== "function") {
      throw new TypeError("listener must be a function");
    }
    if (typeof target !== "function") {
      throw new TypeError("target must be a function");
    }
    if (!Array.isArray(listeners)) {
      this._events[event] = listeners = [listeners];
    }
    index2 = listeners.length;
    for (i = listeners.length; i--; ) {
      if (listeners[i] === target) {
        index2 = i + add6;
        break;
      }
    }
    listeners.splice(index2, 0, listener);
    return this;
  }
  on(event, listener) {
    return super.on(event, listener);
  }
  addListener(event, listener) {
    return super.addListener(event, listener);
  }
  prependListener(event, listener) {
    return super.prependListener(event, listener);
  }
  prependOnceListener(event, listener) {
    return super.prependOnceListener(event, listener);
  }
  removeAllListeners(event) {
    return super.removeAllListeners(event);
  }
  removeListener(event, listener) {
    return super.removeListener(event, listener);
  }
  eventNames() {
    return super.eventNames();
  }
  listeners(event) {
    return super.listeners(event);
  }
  listenerCount(event) {
    return super.listenerCount(event);
  }
  getMaxListeners() {
    return super.getMaxListeners();
  }
  setMaxListeners(maxListeners) {
    return super.setMaxListeners(maxListeners);
  }
}
asyncEventEmitter.AsyncEventEmitter = AsyncEventEmitter;
var blobs = {};
var sha256$1 = {};
Object.defineProperty(sha256$1, "__esModule", { value: true });
sha256$1.sha256 = void 0;
const sha256_1 = sha256$2;
const utils_js_1 = utilsExports;
sha256$1.sha256 = (0, utils_js_1.wrapHash)(sha256_1.sha256);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.commitmentsToVersionedHashes = exports.computeVersionedHash = exports.blobsToProofs = exports.blobsToCommitments = exports.getBlobs = void 0;
  const sha256_js_1 = sha256$1;
  const bytes_js_12 = requireBytes();
  const BYTES_PER_FIELD_ELEMENT = 32;
  const FIELD_ELEMENTS_PER_BLOB = 4096;
  const USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;
  const MAX_BLOBS_PER_TX = 2;
  const MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;
  const BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;
  function get_padded(data, blobs_len) {
    const pdata = new Uint8Array(blobs_len * USEFUL_BYTES_PER_BLOB).fill(0);
    pdata.set(data);
    pdata[data.byteLength] = 128;
    return pdata;
  }
  function get_blob(data) {
    const blob2 = new Uint8Array(BLOB_SIZE);
    for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {
      const chunk = new Uint8Array(32);
      chunk.set(data.subarray(i * 31, (i + 1) * 31), 0);
      blob2.set(chunk, i * 32);
    }
    return blob2;
  }
  const getBlobs = (input) => {
    const data = (0, bytes_js_12.utf8ToBytes)(input);
    const len = data.byteLength;
    if (len === 0) {
      throw Error("invalid blob data");
    }
    if (len > MAX_USEFUL_BYTES_PER_TX) {
      throw Error("blob data is too large");
    }
    const blobs_len = Math.ceil(len / USEFUL_BYTES_PER_BLOB);
    const pdata = get_padded(data, blobs_len);
    const blobs2 = [];
    for (let i = 0; i < blobs_len; i++) {
      const chunk = pdata.subarray(i * USEFUL_BYTES_PER_BLOB, (i + 1) * USEFUL_BYTES_PER_BLOB);
      const blob2 = get_blob(chunk);
      blobs2.push(blob2);
    }
    return blobs2;
  };
  exports.getBlobs = getBlobs;
  const blobsToCommitments = (kzg2, blobs2) => {
    const commitments = [];
    for (const blob2 of blobs2) {
      commitments.push(kzg2.blobToKzgCommitment(blob2));
    }
    return commitments;
  };
  exports.blobsToCommitments = blobsToCommitments;
  const blobsToProofs = (kzg2, blobs2, commitments) => {
    const proofs = blobs2.map((blob2, ctx) => kzg2.computeBlobKzgProof(blob2, commitments[ctx]));
    return proofs;
  };
  exports.blobsToProofs = blobsToProofs;
  const computeVersionedHash = (commitment, blobCommitmentVersion) => {
    const computedVersionedHash = new Uint8Array(32);
    computedVersionedHash.set([blobCommitmentVersion], 0);
    computedVersionedHash.set((0, sha256_js_1.sha256)(commitment).subarray(1), 1);
    return computedVersionedHash;
  };
  exports.computeVersionedHash = computeVersionedHash;
  const commitmentsToVersionedHashes = (commitments) => {
    const hashes2 = [];
    for (const commitment of commitments) {
      hashes2.push((0, exports.computeVersionedHash)(commitment, 1));
    }
    return hashes2;
  };
  exports.commitmentsToVersionedHashes = commitmentsToVersionedHashes;
})(blobs);
var genesis = {};
Object.defineProperty(genesis, "__esModule", { value: true });
genesis.parseGethGenesisState = void 0;
const bytes_js_1$1 = requireBytes();
const internal_js_1 = requireInternal();
function parseGethGenesisState(json) {
  const state = {};
  for (const address2 of Object.keys(json.alloc)) {
    let { balance, code, storage, nonce: nonce2 } = json.alloc[address2];
    const prefixedAddress = (0, bytes_js_1$1.addHexPrefix)(address2.toLowerCase());
    balance = (0, internal_js_1.isHexString)(balance) ? balance : (0, bytes_js_1$1.bigIntToHex)(BigInt(balance));
    code = code !== void 0 ? (0, bytes_js_1$1.addHexPrefix)(code) : void 0;
    storage = storage !== void 0 ? Object.entries(storage) : void 0;
    nonce2 = nonce2 !== void 0 ? (0, bytes_js_1$1.addHexPrefix)(nonce2) : void 0;
    state[prefixedAddress] = [balance, code, storage, nonce2];
  }
  return state;
}
genesis.parseGethGenesisState = parseGethGenesisState;
var kzg = {};
Object.defineProperty(kzg, "__esModule", { value: true });
kzg.initKZG = void 0;
function initKZG(kzg2, _trustedSetupPath) {
  kzg2.loadTrustedSetup();
}
kzg.initKZG = initKZG;
var lock = {};
Object.defineProperty(lock, "__esModule", { value: true });
lock.Lock = void 0;
class Lock {
  constructor() {
    this.permits = 1;
    this.promiseResolverQueue = [];
  }
  /**
   * Returns a promise used to wait for a permit to become available. This method should be awaited on.
   * @returns  A promise that gets resolved when execution is allowed to proceed.
   */
  async acquire() {
    if (this.permits > 0) {
      this.permits -= 1;
      return Promise.resolve(true);
    }
    return new Promise((resolver) => this.promiseResolverQueue.push(resolver));
  }
  /**
   * Increases the number of permits by one. If there are other functions waiting, one of them will
   * continue to execute in a future iteration of the event loop.
   */
  release() {
    this.permits += 1;
    if (this.permits > 1 && this.promiseResolverQueue.length > 0) {
      console.warn("Lock.permits should never be > 0 when there is someone waiting.");
    } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
      this.permits -= 1;
      const nextResolver = this.promiseResolverQueue.shift();
      if (nextResolver) {
        nextResolver(true);
      }
    }
  }
}
lock.Lock = Lock;
var mapDB = {};
Object.defineProperty(mapDB, "__esModule", { value: true });
mapDB.MapDB = void 0;
const bytes_js_1 = requireBytes();
class MapDB {
  constructor(database) {
    this._database = database ?? /* @__PURE__ */ new Map();
  }
  async get(key2) {
    const dbKey = key2 instanceof Uint8Array ? (0, bytes_js_1.bytesToUnprefixedHex)(key2) : key2.toString();
    return this._database.get(dbKey);
  }
  async put(key2, val) {
    const dbKey = key2 instanceof Uint8Array ? (0, bytes_js_1.bytesToUnprefixedHex)(key2) : key2.toString();
    this._database.set(dbKey, val);
  }
  async del(key2) {
    const dbKey = key2 instanceof Uint8Array ? (0, bytes_js_1.bytesToUnprefixedHex)(key2) : key2.toString();
    this._database.delete(dbKey);
  }
  async batch(opStack) {
    for (const op of opStack) {
      if (op.type === "del") {
        await this.del(op.key);
      }
      if (op.type === "put") {
        await this.put(op.key, op.value);
      }
    }
  }
  /**
   * Note that the returned shallow copy will share the underlying database with the original
   *
   * @returns DB
   */
  shallowCopy() {
    return new MapDB(this._database);
  }
  open() {
    return Promise.resolve();
  }
}
mapDB.MapDB = MapDB;
var provider = {};
Object.defineProperty(provider, "__esModule", { value: true });
provider.getProvider = provider.fetchFromProvider = void 0;
const fetchFromProvider = async (url, params) => {
  const data = JSON.stringify({
    method: params.method,
    params: params.params,
    jsonrpc: "2.0",
    id: 1
  });
  const res = await fetch(url, {
    headers: {
      "content-type": "application/json"
    },
    method: "POST",
    body: data
  });
  if (!res.ok) {
    throw new Error(`JSONRpcError: ${JSON.stringify({
      method: params.method,
      status: res.status,
      message: await res.text().catch(() => {
        return "Could not parse error message likely because of a network error";
      })
    }, null, 2)}`);
  }
  const json = await res.json();
  return json.result;
};
provider.fetchFromProvider = fetchFromProvider;
const getProvider = (provider2) => {
  if (typeof provider2 === "string") {
    return provider2;
  } else if (typeof provider2 === "object" && provider2._getConnection !== void 0) {
    return provider2._getConnection().url;
  } else {
    throw new Error("Must provide valid provider URL or Web3Provider");
  }
};
provider.getProvider = getProvider;
var requests = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CLRequestFactory = exports.ConsolidationRequest = exports.WithdrawalRequest = exports.DepositRequest = exports.CLRequest = exports.CLRequestType = void 0;
  const rlp_1 = cjs$1;
  const utils_12 = utilsExports;
  const bytes_js_12 = requireBytes();
  const constants_js_12 = constants$3;
  var CLRequestType;
  (function(CLRequestType2) {
    CLRequestType2[CLRequestType2["Deposit"] = 0] = "Deposit";
    CLRequestType2[CLRequestType2["Withdrawal"] = 1] = "Withdrawal";
    CLRequestType2[CLRequestType2["Consolidation"] = 2] = "Consolidation";
  })(CLRequestType = exports.CLRequestType || (exports.CLRequestType = {}));
  class CLRequest {
    constructor(type) {
      this.type = type;
    }
  }
  exports.CLRequest = CLRequest;
  class DepositRequest extends CLRequest {
    constructor(pubkey, withdrawalCredentials, amount2, signature2, index2) {
      super(CLRequestType.Deposit);
      this.pubkey = pubkey;
      this.withdrawalCredentials = withdrawalCredentials;
      this.amount = amount2;
      this.signature = signature2;
      this.index = index2;
    }
    static fromRequestData(depositData) {
      const { pubkey, withdrawalCredentials, amount: amount2, signature: signature2, index: index2 } = depositData;
      return new DepositRequest(pubkey, withdrawalCredentials, amount2, signature2, index2);
    }
    static fromJSON(jsonData) {
      const { pubkey, withdrawalCredentials, amount: amount2, signature: signature2, index: index2 } = jsonData;
      return this.fromRequestData({
        pubkey: (0, bytes_js_12.hexToBytes)(pubkey),
        withdrawalCredentials: (0, bytes_js_12.hexToBytes)(withdrawalCredentials),
        amount: (0, bytes_js_12.hexToBigInt)(amount2),
        signature: (0, bytes_js_12.hexToBytes)(signature2),
        index: (0, bytes_js_12.hexToBigInt)(index2)
      });
    }
    serialize() {
      const indexBytes = this.index === constants_js_12.BIGINT_0 ? new Uint8Array() : (0, bytes_js_12.bigIntToBytes)(this.index);
      const amountBytes = this.amount === constants_js_12.BIGINT_0 ? new Uint8Array() : (0, bytes_js_12.bigIntToBytes)(this.amount);
      return (0, utils_12.concatBytes)(Uint8Array.from([this.type]), rlp_1.RLP.encode([this.pubkey, this.withdrawalCredentials, amountBytes, this.signature, indexBytes]));
    }
    toJSON() {
      return {
        pubkey: (0, bytes_js_12.bytesToHex)(this.pubkey),
        withdrawalCredentials: (0, bytes_js_12.bytesToHex)(this.withdrawalCredentials),
        amount: (0, bytes_js_12.bigIntToHex)(this.amount),
        signature: (0, bytes_js_12.bytesToHex)(this.signature),
        index: (0, bytes_js_12.bigIntToHex)(this.index)
      };
    }
    static deserialize(bytes2) {
      const [pubkey, withdrawalCredentials, amount2, signature2, index2] = rlp_1.RLP.decode(bytes2.slice(1));
      return this.fromRequestData({
        pubkey,
        withdrawalCredentials,
        amount: (0, bytes_js_12.bytesToBigInt)(amount2),
        signature: signature2,
        index: (0, bytes_js_12.bytesToBigInt)(index2)
      });
    }
  }
  exports.DepositRequest = DepositRequest;
  class WithdrawalRequest extends CLRequest {
    constructor(sourceAddress, validatorPubkey, amount2) {
      super(CLRequestType.Withdrawal);
      this.sourceAddress = sourceAddress;
      this.validatorPubkey = validatorPubkey;
      this.amount = amount2;
    }
    static fromRequestData(withdrawalData) {
      const { sourceAddress, validatorPubkey, amount: amount2 } = withdrawalData;
      return new WithdrawalRequest(sourceAddress, validatorPubkey, amount2);
    }
    static fromJSON(jsonData) {
      const { sourceAddress, validatorPubkey, amount: amount2 } = jsonData;
      return this.fromRequestData({
        sourceAddress: (0, bytes_js_12.hexToBytes)(sourceAddress),
        validatorPubkey: (0, bytes_js_12.hexToBytes)(validatorPubkey),
        amount: (0, bytes_js_12.hexToBigInt)(amount2)
      });
    }
    serialize() {
      const amountBytes = this.amount === constants_js_12.BIGINT_0 ? new Uint8Array() : (0, bytes_js_12.bigIntToBytes)(this.amount);
      return (0, utils_12.concatBytes)(Uint8Array.from([this.type]), rlp_1.RLP.encode([this.sourceAddress, this.validatorPubkey, amountBytes]));
    }
    toJSON() {
      return {
        sourceAddress: (0, bytes_js_12.bytesToHex)(this.sourceAddress),
        validatorPubkey: (0, bytes_js_12.bytesToHex)(this.validatorPubkey),
        amount: (0, bytes_js_12.bigIntToHex)(this.amount)
      };
    }
    static deserialize(bytes2) {
      const [sourceAddress, validatorPubkey, amount2] = rlp_1.RLP.decode(bytes2.slice(1));
      return this.fromRequestData({
        sourceAddress,
        validatorPubkey,
        amount: (0, bytes_js_12.bytesToBigInt)(amount2)
      });
    }
  }
  exports.WithdrawalRequest = WithdrawalRequest;
  class ConsolidationRequest extends CLRequest {
    constructor(sourceAddress, sourcePubkey, targetPubkey) {
      super(CLRequestType.Consolidation);
      this.sourceAddress = sourceAddress;
      this.sourcePubkey = sourcePubkey;
      this.targetPubkey = targetPubkey;
    }
    static fromRequestData(consolidationData) {
      const { sourceAddress, sourcePubkey, targetPubkey } = consolidationData;
      return new ConsolidationRequest(sourceAddress, sourcePubkey, targetPubkey);
    }
    static fromJSON(jsonData) {
      const { sourceAddress, sourcePubkey, targetPubkey } = jsonData;
      return this.fromRequestData({
        sourceAddress: (0, bytes_js_12.hexToBytes)(sourceAddress),
        sourcePubkey: (0, bytes_js_12.hexToBytes)(sourcePubkey),
        targetPubkey: (0, bytes_js_12.hexToBytes)(targetPubkey)
      });
    }
    serialize() {
      return (0, utils_12.concatBytes)(Uint8Array.from([this.type]), rlp_1.RLP.encode([this.sourceAddress, this.sourcePubkey, this.targetPubkey]));
    }
    toJSON() {
      return {
        sourceAddress: (0, bytes_js_12.bytesToHex)(this.sourceAddress),
        sourcePubkey: (0, bytes_js_12.bytesToHex)(this.sourcePubkey),
        targetPubkey: (0, bytes_js_12.bytesToHex)(this.targetPubkey)
      };
    }
    static deserialize(bytes2) {
      const [sourceAddress, sourcePubkey, targetPubkey] = rlp_1.RLP.decode(bytes2.slice(1));
      return this.fromRequestData({
        sourceAddress,
        sourcePubkey,
        targetPubkey
      });
    }
  }
  exports.ConsolidationRequest = ConsolidationRequest;
  class CLRequestFactory {
    static fromSerializedRequest(bytes2) {
      switch (bytes2[0]) {
        case CLRequestType.Deposit:
          return DepositRequest.deserialize(bytes2);
        case CLRequestType.Withdrawal:
          return WithdrawalRequest.deserialize(bytes2);
        case CLRequestType.Consolidation:
          return ConsolidationRequest.deserialize(bytes2);
        default:
          throw Error(`Invalid request type=${bytes2[0]}`);
      }
    }
  }
  exports.CLRequestFactory = CLRequestFactory;
})(requests);
var verkle = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getVerkleTreeKeyForStorageSlot = exports.chunkifyCode = exports.getVerkleTreeKeyForCodeChunk = exports.getVerkleTreeIndicesForCodeChunk = exports.getVerkleTreeIndexesForStorageSlot = exports.getVerkleKey = exports.VERKLE_MAIN_STORAGE_OFFSET = exports.VERKLE_NODE_WIDTH = exports.VERKLE_CODE_OFFSET = exports.VERKLE_HEADER_STORAGE_OFFSET = exports.VERKLE_CODE_SIZE_LEAF_KEY = exports.VERKLE_CODE_HASH_LEAF_KEY = exports.VERKLE_NONCE_LEAF_KEY = exports.VERKLE_BALANCE_LEAF_KEY = exports.VERKLE_VERSION_LEAF_KEY = exports.VerkleLeafType = exports.verifyVerkleProof = exports.getVerkleStem = void 0;
  const bytes_js_12 = requireBytes();
  function getVerkleStem(ffi, address2, treeIndex = 0) {
    const address32 = (0, bytes_js_12.setLengthLeft)(address2.toBytes(), 32);
    let treeIndexBytes;
    if (typeof treeIndex === "number") {
      treeIndexBytes = (0, bytes_js_12.setLengthRight)((0, bytes_js_12.int32ToBytes)(Number(treeIndex), true), 32);
    } else {
      treeIndexBytes = (0, bytes_js_12.setLengthRight)((0, bytes_js_12.bigIntToBytes)(BigInt(treeIndex), true).slice(0, 32), 32);
    }
    const treeStem = ffi.getTreeKey(address32, treeIndexBytes, 0).slice(0, 31);
    return treeStem;
  }
  exports.getVerkleStem = getVerkleStem;
  function verifyVerkleProof(ffi, prestateRoot, executionWitness) {
    return ffi.verifyExecutionWitnessPreState((0, bytes_js_12.bytesToHex)(prestateRoot), JSON.stringify(executionWitness));
  }
  exports.verifyVerkleProof = verifyVerkleProof;
  var VerkleLeafType;
  (function(VerkleLeafType2) {
    VerkleLeafType2[VerkleLeafType2["Version"] = 0] = "Version";
    VerkleLeafType2[VerkleLeafType2["Balance"] = 1] = "Balance";
    VerkleLeafType2[VerkleLeafType2["Nonce"] = 2] = "Nonce";
    VerkleLeafType2[VerkleLeafType2["CodeHash"] = 3] = "CodeHash";
    VerkleLeafType2[VerkleLeafType2["CodeSize"] = 4] = "CodeSize";
  })(VerkleLeafType = exports.VerkleLeafType || (exports.VerkleLeafType = {}));
  exports.VERKLE_VERSION_LEAF_KEY = (0, bytes_js_12.intToBytes)(VerkleLeafType.Version);
  exports.VERKLE_BALANCE_LEAF_KEY = (0, bytes_js_12.intToBytes)(VerkleLeafType.Balance);
  exports.VERKLE_NONCE_LEAF_KEY = (0, bytes_js_12.intToBytes)(VerkleLeafType.Nonce);
  exports.VERKLE_CODE_HASH_LEAF_KEY = (0, bytes_js_12.intToBytes)(VerkleLeafType.CodeHash);
  exports.VERKLE_CODE_SIZE_LEAF_KEY = (0, bytes_js_12.intToBytes)(VerkleLeafType.CodeSize);
  exports.VERKLE_HEADER_STORAGE_OFFSET = 64;
  exports.VERKLE_CODE_OFFSET = 128;
  exports.VERKLE_NODE_WIDTH = 256;
  exports.VERKLE_MAIN_STORAGE_OFFSET = BigInt(256) ** BigInt(31);
  const getVerkleKey = (stem, leaf) => {
    switch (leaf) {
      case VerkleLeafType.Version:
        return (0, bytes_js_12.concatBytes)(stem, exports.VERKLE_VERSION_LEAF_KEY);
      case VerkleLeafType.Balance:
        return (0, bytes_js_12.concatBytes)(stem, exports.VERKLE_BALANCE_LEAF_KEY);
      case VerkleLeafType.Nonce:
        return (0, bytes_js_12.concatBytes)(stem, exports.VERKLE_NONCE_LEAF_KEY);
      case VerkleLeafType.CodeHash:
        return (0, bytes_js_12.concatBytes)(stem, exports.VERKLE_CODE_HASH_LEAF_KEY);
      case VerkleLeafType.CodeSize:
        return (0, bytes_js_12.concatBytes)(stem, exports.VERKLE_CODE_SIZE_LEAF_KEY);
      default:
        return (0, bytes_js_12.concatBytes)(stem, leaf);
    }
  };
  exports.getVerkleKey = getVerkleKey;
  function getVerkleTreeIndexesForStorageSlot(storageKey) {
    let position;
    if (storageKey < exports.VERKLE_CODE_OFFSET - exports.VERKLE_HEADER_STORAGE_OFFSET) {
      position = BigInt(exports.VERKLE_HEADER_STORAGE_OFFSET) + storageKey;
    } else {
      position = exports.VERKLE_MAIN_STORAGE_OFFSET + storageKey;
    }
    const treeIndex = position / BigInt(exports.VERKLE_NODE_WIDTH);
    const subIndex = Number(position % BigInt(exports.VERKLE_NODE_WIDTH));
    return { treeIndex, subIndex };
  }
  exports.getVerkleTreeIndexesForStorageSlot = getVerkleTreeIndexesForStorageSlot;
  function getVerkleTreeIndicesForCodeChunk(chunkId) {
    const treeIndex = Math.floor((exports.VERKLE_CODE_OFFSET + chunkId) / exports.VERKLE_NODE_WIDTH);
    const subIndex = (exports.VERKLE_CODE_OFFSET + chunkId) % exports.VERKLE_NODE_WIDTH;
    return { treeIndex, subIndex };
  }
  exports.getVerkleTreeIndicesForCodeChunk = getVerkleTreeIndicesForCodeChunk;
  const getVerkleTreeKeyForCodeChunk = async (address2, chunkId, verkleCrypto) => {
    const { treeIndex, subIndex } = getVerkleTreeIndicesForCodeChunk(chunkId);
    return (0, bytes_js_12.concatBytes)(getVerkleStem(verkleCrypto, address2, treeIndex), (0, bytes_js_12.toBytes)(subIndex));
  };
  exports.getVerkleTreeKeyForCodeChunk = getVerkleTreeKeyForCodeChunk;
  const chunkifyCode = (code) => {
    if (code.length % 31 !== 0) {
      const paddingLength = 31 - code.length % 31;
      code = (0, bytes_js_12.setLengthRight)(code, code.length + paddingLength);
    }
    throw new Error("Not implemented");
  };
  exports.chunkifyCode = chunkifyCode;
  const getVerkleTreeKeyForStorageSlot = async (address2, storageKey, verkleCrypto) => {
    const { treeIndex, subIndex } = getVerkleTreeIndexesForStorageSlot(storageKey);
    return (0, bytes_js_12.concatBytes)(getVerkleStem(verkleCrypto, address2, treeIndex), (0, bytes_js_12.toBytes)(subIndex));
  };
  exports.getVerkleTreeKeyForStorageSlot = getVerkleTreeKeyForStorageSlot;
})(verkle);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = void 0;
  __exportStar2(constants$3, exports);
  __exportStar2(units, exports);
  __exportStar2(account$2, exports);
  __exportStar2(address, exports);
  __exportStar2(db, exports);
  __exportStar2(withdrawal, exports);
  __exportStar2(signature$1, exports);
  __exportStar2(requireBytes(), exports);
  __exportStar2(types$2, exports);
  __exportStar2(asyncEventEmitter, exports);
  __exportStar2(blobs, exports);
  __exportStar2(genesis, exports);
  var internal_js_12 = requireInternal();
  Object.defineProperty(exports, "arrayContainsArray", { enumerable: true, get: function() {
    return internal_js_12.arrayContainsArray;
  } });
  Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
    return internal_js_12.fromAscii;
  } });
  Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
    return internal_js_12.fromUtf8;
  } });
  Object.defineProperty(exports, "getBinarySize", { enumerable: true, get: function() {
    return internal_js_12.getBinarySize;
  } });
  Object.defineProperty(exports, "getKeys", { enumerable: true, get: function() {
    return internal_js_12.getKeys;
  } });
  Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
    return internal_js_12.isHexString;
  } });
  Object.defineProperty(exports, "padToEven", { enumerable: true, get: function() {
    return internal_js_12.padToEven;
  } });
  Object.defineProperty(exports, "stripHexPrefix", { enumerable: true, get: function() {
    return internal_js_12.stripHexPrefix;
  } });
  Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
    return internal_js_12.toAscii;
  } });
  __exportStar2(kzg, exports);
  __exportStar2(lock, exports);
  __exportStar2(mapDB, exports);
  __exportStar2(provider, exports);
  __exportStar2(requests, exports);
  __exportStar2(verkle, exports);
})(cjs$2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t, e = requireDist(), a = require$$1, s = (t = hdkey) && "object" == typeof t && "default" in t ? t.default : t, i = cjs$2;
  const r = { ETH_SIGN_REQUEST: new e.RegistryType("eth-sign-request", 401), ETH_SIGNATURE: new e.RegistryType("eth-signature", 402), ETH_NFT_ITEM: new e.RegistryType("eth-nft-item", 403) }, { decodeToDataItem: n, RegistryTypes: d } = e.extend;
  var o, h;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.dataType = 3] = "dataType", t2[t2.chainId = 4] = "chainId", t2[t2.derivationPath = 5] = "derivationPath", t2[t2.address = 6] = "address", t2[t2.origin = 7] = "origin";
  }(o || (o = {})), (h = exports.DataType || (exports.DataType = {}))[h.transaction = 1] = "transaction", h[h.typedData = 2] = "typedData", h[h.personalMessage = 3] = "personalMessage", h[h.typedTransaction = 4] = "typedTransaction";
  class c extends e.RegistryItem {
    constructor(t2) {
      super(), this.getRegistryType = () => r.ETH_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDataType = () => this.dataType, this.getChainId = () => this.chainId, this.getDerivationPath = () => this.derivationPath.getPath(), this.getSourceFingerprint = () => this.derivationPath.getSourceFingerprint(), this.getSignRequestAddress = () => this.address, this.getOrigin = () => this.origin, this.toDataItem = () => {
        const t3 = {};
        this.requestId && (t3[o.requestId] = new e.DataItem(this.requestId, d.UUID.getTag())), this.address && (t3[o.address] = this.address), this.chainId && (t3[o.chainId] = Number(this.chainId)), this.origin && (t3[o.origin] = this.origin), t3[o.signData] = this.signData, t3[o.dataType] = this.dataType;
        const a2 = this.derivationPath.toDataItem();
        return a2.setTag(this.derivationPath.getRegistryType().getTag()), t3[o.derivationPath] = a2, new e.DataItem(t3);
      }, this.requestId = t2.requestId, this.signData = t2.signData, this.dataType = t2.dataType, this.chainId = t2.chainId, this.derivationPath = t2.derivationPath, this.address = t2.address, this.origin = t2.origin;
    }
    static constructETHRequest(t2, s2, i2, r2, n2, d2, o2, h2) {
      const g2 = i2.replace(/[m|M]\//, "").split("/"), u2 = new e.CryptoKeypath(g2.map((t3) => {
        const a2 = parseInt(t3.replace("'", ""));
        let s3 = false;
        return t3.endsWith("'") && (s3 = true), new e.PathComponent({ index: a2, hardened: s3 });
      }), Buffer$1$1.from(r2, "hex"));
      return new c({ requestId: n2 ? Buffer$1$1.from(a.parse(n2)) : void 0, signData: t2, dataType: s2, derivationPath: u2, chainId: d2, address: o2 ? Buffer$1$1.from(o2.replace("0x", ""), "hex") : void 0, origin: h2 || void 0 });
    }
  }
  c.fromDataItem = (t2) => {
    const a2 = t2.getData(), s2 = a2[o.signData], i2 = a2[o.dataType], r2 = e.CryptoKeypath.fromDataItem(a2[o.derivationPath]), n2 = a2[o.chainId] ? a2[o.chainId] : void 0, d2 = a2[o.address] ? a2[o.address] : void 0, h2 = a2[o.requestId] ? a2[o.requestId].getData() : void 0;
    return new c({ requestId: h2, signData: s2, dataType: i2, chainId: n2, derivationPath: r2, address: d2, origin: a2[o.origin] ? a2[o.origin] : void 0 });
  }, c.fromCBOR = (t2) => {
    const e2 = n(t2);
    return c.fromDataItem(e2);
  };
  const { RegistryTypes: g, decodeToDataItem: u } = e.extend;
  var m;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature", t2[t2.origin = 3] = "origin";
  }(m || (m = {}));
  class I extends e.RegistryItem {
    constructor(t2, a2, s2) {
      super(), this.getRegistryType = () => r.ETH_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.getOrigin = () => this.origin, this.toDataItem = () => {
        const t3 = {};
        return this.requestId && (t3[m.requestId] = new e.DataItem(this.requestId, g.UUID.getTag())), this.origin && (t3[m.origin] = this.origin), t3[m.signature] = this.signature, new e.DataItem(t3);
      }, this.signature = t2, this.requestId = a2, this.origin = s2;
    }
  }
  I.fromDataItem = (t2) => {
    const e2 = t2.getData(), a2 = e2[m.signature], s2 = e2[m.requestId] ? e2[m.requestId].getData() : void 0;
    return new I(a2, s2, e2[m.origin]);
  }, I.fromCBOR = (t2) => {
    const e2 = u(t2);
    return I.fromDataItem(e2);
  };
  const { decodeToDataItem: p } = e.extend;
  var D;
  !function(t2) {
    t2[t2.chainId = 1] = "chainId", t2[t2.contractAddress = 2] = "contractAddress", t2[t2.contractName = 3] = "contractName", t2[t2.name = 4] = "name", t2[t2.mediaData = 5] = "mediaData";
  }(D || (D = {}));
  class T extends e.RegistryItem {
    constructor(t2) {
      super(), this.getRegistryType = () => r.ETH_NFT_ITEM, this.getChainId = () => this.chainId, this.getName = () => this.name, this.getmediaData = () => this.mediaData, this.getContractAddress = () => this.contractAddress, this.getContractName = () => this.contractName, this.toDataItem = () => {
        const t3 = {};
        return t3[D.chainId] = this.chainId, t3[D.name] = this.name, t3[D.contractAddress] = this.contractAddress, t3[D.contractName] = this.contractName, t3[D.mediaData] = this.mediaData, new e.DataItem(t3);
      }, this.chainId = t2.chainId, this.name = t2.name, this.contractAddress = t2.contractAddress, this.contractName = t2.contractName, this.mediaData = t2.mediaData;
    }
    static constructETHNFTItem(t2, e2, a2, s2, i2) {
      return new T({ chainId: t2, contractAddress: e2, contractName: a2, mediaData: i2, name: s2 });
    }
  }
  T.fromDataItem = (t2) => {
    const e2 = t2.getData();
    return new T({ chainId: e2[D.chainId], name: e2[D.name], contractAddress: e2[D.contractAddress], contractName: e2[D.contractName], mediaData: e2[D.mediaData] });
  }, T.fromCBOR = (t2) => {
    const e2 = p(t2);
    return T.fromDataItem(e2);
  };
  const y = (t2, e2) => {
    const a2 = s.fromExtendedKey(t2).derive(e2), r2 = "0x" + Buffer$1$1.from(i.publicToAddress(a2.publicKey, true)).toString("hex");
    return i.toChecksumAddress(r2);
  };
  e.patchTags(Object.values(r).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(e).forEach(function(t2) {
    "default" !== t2 && Object.defineProperty(exports, t2, { enumerable: true, get: function() {
      return e[t2];
    } });
  }), exports.ETHNFTItem = T, exports.ETHSignature = I, exports.EthSignRequest = c, exports.findHDPathFromAddress = (t2, e2, a2, s2) => {
    for (let i2 = 0; i2 < a2; i2++) {
      const a3 = y(e2, "M/0/" + i2);
      if (t2.toLowerCase() == a3.toLowerCase()) return `${s2}/0/${i2}`;
    }
    return null;
  }, exports.generateAddressFromXpub = y;
})(bcUrRegistryEth_cjs_production_min);
{
  dist$b.exports = bcUrRegistryEth_cjs_production_min;
}
var distExports$9 = dist$b.exports;
Object.defineProperty(ethereum, "__esModule", { value: true });
ethereum.KeystoneEthereumSDK = void 0;
const bc_ur_registry_eth_1 = distExports$9;
const utils_1$e = utils$k;
const ur_1$9 = ur;
class KeystoneEthereumSDK {
  constructor(config2) {
    this.config = config2;
  }
  parseSignature(ur2) {
    if (ur2.type !== ur_1$9.URType.EthSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_eth_1.ETHSignature.fromCBOR(ur2.cbor);
    const requestId = sig.getRequestId();
    return {
      requestId: requestId === void 0 ? void 0 : (0, utils_1$e.uuidStringify)(requestId),
      signature: (0, utils_1$e.toHex)(sig.getSignature()),
      origin: sig.getOrigin()
    };
  }
  generateSignRequest({ requestId, signData: signData2, dataType, path, xfp, chainId, address: address2, origin: origin2 }) {
    var _a;
    return new bc_ur_registry_eth_1.EthSignRequest({
      requestId: (0, utils_1$e.uuidParse)(requestId),
      signData: (0, utils_1$e.toBuffer)(signData2),
      dataType,
      derivationPath: new bc_ur_registry_eth_1.CryptoKeypath((0, utils_1$e.parsePath)(path).map((e) => new bc_ur_registry_eth_1.PathComponent(e)), (0, utils_1$e.toBuffer)(xfp)),
      chainId,
      address: address2 !== void 0 ? (0, utils_1$e.toBuffer)(address2) : void 0,
      origin: origin2 !== null && origin2 !== void 0 ? origin2 : (_a = this.config) === null || _a === void 0 ? void 0 : _a.origin
    }).toUR();
  }
}
KeystoneEthereumSDK.DataType = bc_ur_registry_eth_1.DataType;
ethereum.KeystoneEthereumSDK = KeystoneEthereumSDK;
var solana = {};
var dist$a = { exports: {} };
var bcUrRegistrySol_cjs_production_min = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist(), e = require$$1;
  const s = { SOL_SIGN_REQUEST: new t.RegistryType("sol-sign-request", 1101), SOL_SIGNATURE: new t.RegistryType("sol-signature", 1102), SOL_NFT_ITEM: new t.RegistryType("sol-nft-item", 1104) }, { decodeToDataItem: i, RegistryTypes: a } = t.extend;
  var r, n;
  (r = exports.SignType || (exports.SignType = {}))[r.Transaction = 1] = "Transaction", r[r.Message = 2] = "Message", function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.derivationPath = 3] = "derivationPath", t2[t2.address = 4] = "address", t2[t2.origin = 5] = "origin", t2[t2.signType = 6] = "signType";
  }(n || (n = {}));
  class o extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.SOL_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDerivationPath = () => this.derivationPath.getPath(), this.getSignRequestAddress = () => this.address, this.getOrigin = () => this.origin, this.getSignType = () => this.signType, this.toDataItem = () => {
        const e3 = {};
        this.requestId && (e3[n.requestId] = new t.DataItem(this.requestId, a.UUID.getTag())), this.address && (e3[n.address] = this.address), this.origin && (e3[n.origin] = this.origin), e3[n.signData] = this.signData, e3[n.signType] = this.signType;
        const s2 = this.derivationPath.toDataItem();
        return s2.setTag(this.derivationPath.getRegistryType().getTag()), e3[n.derivationPath] = s2, new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.derivationPath = e2.derivationPath, this.address = e2.address, this.origin = e2.origin, this.signType = e2.signType;
    }
    static constructSOLRequest(s2, i2, a2, r2, n2, d2, g2) {
      const m2 = i2.replace(/[m|M]\//, "").split("/"), h2 = new t.CryptoKeypath(m2.map((e2) => {
        const s3 = parseInt(e2.replace("'", ""));
        let i3 = false;
        return e2.endsWith("'") && (i3 = true), new t.PathComponent({ index: s3, hardened: i3 });
      }), Buffer$1$1.from(a2, "hex"));
      return new o({ requestId: n2 ? Buffer$1$1.from(e.parse(n2)) : void 0, signData: s2, derivationPath: h2, address: d2 ? Buffer$1$1.from(d2.replace("0x", ""), "hex") : void 0, origin: g2 || void 0, signType: r2 });
    }
  }
  o.fromDataItem = (e2) => {
    const s2 = e2.getData(), i2 = s2[n.signData], a2 = t.CryptoKeypath.fromDataItem(s2[n.derivationPath]), r2 = s2[n.address] ? s2[n.address] : void 0, d2 = s2[n.requestId] ? s2[n.requestId].getData() : void 0;
    return new o({ requestId: d2, signData: i2, derivationPath: a2, address: r2, origin: s2[n.origin] ? s2[n.origin] : void 0, signType: s2[n.signType] });
  }, o.fromCBOR = (t2) => {
    const e2 = i(t2);
    return o.fromDataItem(e2);
  };
  const { RegistryTypes: d, decodeToDataItem: g } = t.extend;
  var m;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature";
  }(m || (m = {}));
  class h extends t.RegistryItem {
    constructor(e2, i2) {
      super(), this.getRegistryType = () => s.SOL_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[m.requestId] = new t.DataItem(this.requestId, d.UUID.getTag())), e3[m.signature] = this.signature, new t.DataItem(e3);
      }, this.signature = e2, this.requestId = i2;
    }
  }
  h.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[m.signature], i2 = e2[m.requestId] ? e2[m.requestId].getData() : void 0;
    return new h(s2, i2);
  }, h.fromCBOR = (t2) => {
    const e2 = g(t2);
    return h.fromDataItem(e2);
  };
  const { decodeToDataItem: u } = t.extend;
  var c;
  !function(t2) {
    t2[t2.mintAddress = 1] = "mintAddress", t2[t2.collectionName = 2] = "collectionName", t2[t2.name = 3] = "name", t2[t2.mediaData = 4] = "mediaData";
  }(c || (c = {}));
  class I extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.SOL_NFT_ITEM, this.getName = () => this.name, this.getMediaData = () => this.mediaData, this.getMintAddress = () => this.mintAddress, this.getCollectionName = () => this.collectionName, this.toDataItem = () => {
        const e3 = {};
        return e3[c.name] = this.name, e3[c.mintAddress] = this.mintAddress, e3[c.collectionName] = this.collectionName, e3[c.mediaData] = this.mediaData, new t.DataItem(e3);
      }, this.name = e2.name, this.mintAddress = e2.mintAddress, this.collectionName = e2.collectionName, this.mediaData = e2.mediaData;
    }
    static constructETHNFTItem(t2, e2, s2, i2) {
      return new I({ mintAddress: t2, collectionName: e2, mediaData: i2, name: s2 });
    }
  }
  I.fromDataItem = (t2) => {
    const e2 = t2.getData();
    return new I({ name: e2[c.name], mintAddress: e2[c.mintAddress], collectionName: e2[c.collectionName], mediaData: e2[c.mediaData] });
  }, I.fromCBOR = (t2) => {
    const e2 = u(t2);
    return I.fromDataItem(e2);
  }, t.patchTags(Object.values(s).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.SOLNFTItem = I, exports.SolSignRequest = o, exports.SolSignature = h;
})(bcUrRegistrySol_cjs_production_min);
{
  dist$a.exports = bcUrRegistrySol_cjs_production_min;
}
var distExports$8 = dist$a.exports;
Object.defineProperty(solana, "__esModule", { value: true });
solana.KeystoneSolanaSDK = void 0;
const bc_ur_registry_sol_1 = distExports$8;
const utils_1$d = utils$k;
const ur_1$8 = ur;
class KeystoneSolanaSDK {
  parseSignature(ur2) {
    if (ur2.type !== ur_1$8.URType.SolSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_sol_1.SolSignature.fromCBOR(ur2.cbor);
    const requestId = sig.getRequestId();
    return {
      requestId: requestId === void 0 ? void 0 : (0, utils_1$d.uuidStringify)(requestId),
      signature: (0, utils_1$d.toHex)(sig.getSignature())
    };
  }
  generateSignRequest({ requestId, signData: signData2, dataType, path, xfp, address: address2, origin: origin2 }) {
    return new bc_ur_registry_sol_1.SolSignRequest({
      requestId: (0, utils_1$d.uuidParse)(requestId),
      signData: (0, utils_1$d.toBuffer)(signData2),
      signType: dataType,
      derivationPath: new bc_ur_registry_sol_1.CryptoKeypath((0, utils_1$d.parsePath)(path).map((e) => new bc_ur_registry_sol_1.PathComponent(e)), (0, utils_1$d.toBuffer)(xfp)),
      address: address2 !== void 0 ? (0, utils_1$d.toBuffer)(address2) : void 0,
      origin: origin2
    }).toUR();
  }
}
KeystoneSolanaSDK.DataType = bc_ur_registry_sol_1.SignType;
solana.KeystoneSolanaSDK = KeystoneSolanaSDK;
var tron = {};
var transfer = {};
function base$1(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode3(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      pbegin++;
    }
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      psz++;
    }
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode3,
    decodeUnsafe,
    decode: decode2
  };
}
var src = base$1;
const basex = src;
const ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET);
var base58 = bs58;
var base = function(checksumFn) {
  function encode3(payload) {
    var payloadU8 = Uint8Array.from(payload);
    var checksum = checksumFn(payloadU8);
    var length = payloadU8.length + 4;
    var both = new Uint8Array(length);
    both.set(payloadU8, 0);
    both.set(checksum.subarray(0, 4), payloadU8.length);
    return base58.encode(both, length);
  }
  function decodeRaw(buffer) {
    var payload = buffer.slice(0, -4);
    var checksum = buffer.slice(-4);
    var newChecksum = checksumFn(payload);
    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
    return payload;
  }
  function decodeUnsafe(string) {
    var buffer = base58.decodeUnsafe(string);
    if (!buffer) return;
    return decodeRaw(buffer);
  }
  function decode2(string) {
    var buffer = base58.decode(string);
    var payload = decodeRaw(buffer);
    if (!payload) throw new Error("Invalid checksum");
    return payload;
  }
  return {
    encode: encode3,
    decode: decode2,
    decodeUnsafe
  };
};
var { sha256 } = sha256$3;
var bs58checkBase = base;
function sha256x2(buffer) {
  return sha256(sha256(buffer));
}
var bs58check = bs58checkBase(sha256x2);
var contract_pb = {};
var cjs = {};
var proto3 = {};
var protoRuntime = {};
var _enum = {};
var assert$4 = {};
Object.defineProperty(assert$4, "__esModule", { value: true });
assert$4.assertFloat32 = assert$4.assertUInt32 = assert$4.assertInt32 = assert$4.assert = void 0;
function assert$3(condition, msg2) {
  if (!condition) {
    throw new Error(msg2);
  }
}
assert$4.assert = assert$3;
const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
assert$4.assertInt32 = assertInt32;
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
assert$4.assertUInt32 = assertUInt32;
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}
assert$4.assertFloat32 = assertFloat32;
Object.defineProperty(_enum, "__esModule", { value: true });
_enum.makeEnum = _enum.makeEnumType = _enum.setEnumType = _enum.getEnumType = void 0;
const assert_js_1$9 = assert$4;
const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(enumObject) {
  const t = enumObject[enumTypeSymbol];
  (0, assert_js_1$9.assert)(t, "missing enum type on enum object");
  return t;
}
_enum.getEnumType = getEnumType;
function setEnumType(enumObject, typeName, values, opt) {
  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v) => ({
    no: v.no,
    name: v.name,
    localName: enumObject[v.no]
  })));
}
_enum.setEnumType = setEnumType;
function makeEnumType(typeName, values, _opt) {
  const names2 = /* @__PURE__ */ Object.create(null);
  const numbers = /* @__PURE__ */ Object.create(null);
  const normalValues = [];
  for (const value of values) {
    const n = normalizeEnumValue(value);
    normalValues.push(n);
    names2[value.name] = n;
    numbers[value.no] = n;
  }
  return {
    typeName,
    values: normalValues,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(name2) {
      return names2[name2];
    },
    findNumber(no) {
      return numbers[no];
    }
  };
}
_enum.makeEnumType = makeEnumType;
function makeEnum(typeName, values, opt) {
  const enumObject = {};
  for (const value of values) {
    const n = normalizeEnumValue(value);
    enumObject[n.localName] = n.no;
    enumObject[n.no] = n.localName;
  }
  setEnumType(enumObject, typeName, values);
  return enumObject;
}
_enum.makeEnum = makeEnum;
function normalizeEnumValue(value) {
  if ("localName" in value) {
    return value;
  }
  return Object.assign(Object.assign({}, value), { localName: value.name });
}
var messageType = {};
var message = {};
Object.defineProperty(message, "__esModule", { value: true });
message.Message = void 0;
class Message {
  /**
   * Compare with a message of the same type.
   * Note that this function disregards extensions and unknown fields.
   */
  equals(other) {
    return this.getType().runtime.util.equals(this.getType(), this, other);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(bytes2, options) {
    const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
    format.readMessage(this, opt.readerFactory(bytes2), bytes2.byteLength, opt);
    return this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(jsonValue, options) {
    const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
    format.readMessage(type, jsonValue, opt, this);
    return this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(jsonString, options) {
    let json;
    try {
      json = JSON.parse(jsonString);
    } catch (e) {
      throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);
    }
    return this.fromJson(json, options);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(options) {
    const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();
    bin.writeMessage(this, writer, opt);
    return writer.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(options) {
    const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
    return json.writeMessage(this, opt);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(options) {
    var _a;
    const value = this.toJson(options);
    return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: true
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
}
message.Message = Message;
Object.defineProperty(messageType, "__esModule", { value: true });
messageType.makeMessageType = void 0;
const message_js_1$d = message;
function makeMessageType(runtime, typeName, fields, opt) {
  var _a;
  const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(".") + 1);
  const type = {
    [localName]: function(data) {
      runtime.util.initFields(this);
      runtime.util.initPartial(data, this);
    }
  }[localName];
  Object.setPrototypeOf(type.prototype, new message_js_1$d.Message());
  Object.assign(type, {
    runtime,
    typeName,
    fields: runtime.util.newFieldList(fields),
    fromBinary(bytes2, options) {
      return new type().fromBinary(bytes2, options);
    },
    fromJson(jsonValue, options) {
      return new type().fromJson(jsonValue, options);
    },
    fromJsonString(jsonString, options) {
      return new type().fromJsonString(jsonString, options);
    },
    equals(a, b) {
      return runtime.util.equals(type, a, b);
    }
  });
  return type;
}
messageType.makeMessageType = makeMessageType;
var extensions = {};
var scalars = {};
var protoInt64 = {};
var varint = {};
Object.defineProperty(varint, "__esModule", { value: true });
varint.varint32read = varint.varint32write = varint.uInt64ToString = varint.int64ToString = varint.int64FromString = varint.varint64write = varint.varint64read = void 0;
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
varint.varint64read = varint64read;
function varint64write(lo, hi, bytes2) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes2.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes2.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes2.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes2.push(hi >>> 31 & 1);
}
varint.varint64write = varint64write;
const TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base2 = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base2;
    lowBits = lowBits * base2 + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
varint.int64FromString = int64FromString;
function int64ToString(lo, hi) {
  let bits = newBits(lo, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate(bits.lo, bits.hi);
  }
  const result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
varint.int64ToString = int64ToString;
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base2 = 1e7;
  if (digitA >= base2) {
    digitB += Math.floor(digitA / base2);
    digitA %= base2;
  }
  if (digitB >= base2) {
    digitC += Math.floor(digitB / base2);
    digitB %= base2;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
varint.uInt64ToString = uInt64ToString;
function toUnsigned(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
const decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes2) {
  if (value >= 0) {
    while (value > 127) {
      bytes2.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes2.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes2.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes2.push(1);
  }
}
varint.varint32write = varint32write;
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}
varint.varint32read = varint32read;
var define_process_env_default = {};
Object.defineProperty(protoInt64, "__esModule", { value: true });
protoInt64.protoInt64 = void 0;
const assert_js_1$8 = assert$4;
const varint_js_1$1 = varint;
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process$1 != "object" || typeof define_process_env_default != "object" || define_process_env_default.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`int64 invalid: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`uint64 invalid: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  const assertInt64String = (value) => (0, assert_js_1$8.assert)(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);
  const assertUInt64String = (value) => (0, assert_js_1$8.assert)(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return (0, varint_js_1$1.int64FromString)(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return (0, varint_js_1$1.int64FromString)(value);
    },
    dec(lo, hi) {
      return (0, varint_js_1$1.int64ToString)(lo, hi);
    },
    uDec(lo, hi) {
      return (0, varint_js_1$1.uInt64ToString)(lo, hi);
    }
  };
}
protoInt64.protoInt64 = makeInt64Support();
var scalar = {};
Object.defineProperty(scalar, "__esModule", { value: true });
scalar.LongType = scalar.ScalarType = void 0;
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (scalar.ScalarType = ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
})(LongType || (scalar.LongType = LongType = {}));
Object.defineProperty(scalars, "__esModule", { value: true });
scalars.isScalarZeroValue = scalars.scalarZeroValue = scalars.scalarEquals = void 0;
const proto_int64_js_1$6 = protoInt64;
const scalar_js_1$9 = scalar;
function scalarEquals(type, a, b) {
  if (a === b) {
    return true;
  }
  if (type == scalar_js_1$9.ScalarType.BYTES) {
    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  switch (type) {
    case scalar_js_1$9.ScalarType.UINT64:
    case scalar_js_1$9.ScalarType.FIXED64:
    case scalar_js_1$9.ScalarType.INT64:
    case scalar_js_1$9.ScalarType.SFIXED64:
    case scalar_js_1$9.ScalarType.SINT64:
      return a == b;
  }
  return false;
}
scalars.scalarEquals = scalarEquals;
function scalarZeroValue(type, longType) {
  switch (type) {
    case scalar_js_1$9.ScalarType.BOOL:
      return false;
    case scalar_js_1$9.ScalarType.UINT64:
    case scalar_js_1$9.ScalarType.FIXED64:
    case scalar_js_1$9.ScalarType.INT64:
    case scalar_js_1$9.ScalarType.SFIXED64:
    case scalar_js_1$9.ScalarType.SINT64:
      return longType == 0 ? proto_int64_js_1$6.protoInt64.zero : "0";
    case scalar_js_1$9.ScalarType.DOUBLE:
    case scalar_js_1$9.ScalarType.FLOAT:
      return 0;
    case scalar_js_1$9.ScalarType.BYTES:
      return new Uint8Array(0);
    case scalar_js_1$9.ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
scalars.scalarZeroValue = scalarZeroValue;
function isScalarZeroValue(type, value) {
  switch (type) {
    case scalar_js_1$9.ScalarType.BOOL:
      return value === false;
    case scalar_js_1$9.ScalarType.STRING:
      return value === "";
    case scalar_js_1$9.ScalarType.BYTES:
      return value instanceof Uint8Array && !value.byteLength;
    default:
      return value == 0;
  }
}
scalars.isScalarZeroValue = isScalarZeroValue;
Object.defineProperty(extensions, "__esModule", { value: true });
extensions.filterUnknownFields = extensions.createExtensionContainer = extensions.makeExtension = void 0;
const scalars_js_1$6 = scalars;
function makeExtension(runtime, typeName, extendee, field2) {
  let fi;
  return {
    typeName,
    extendee,
    get field() {
      if (!fi) {
        const i = typeof field2 == "function" ? field2() : field2;
        i.name = typeName.split(".").pop();
        i.jsonName = `[${typeName}]`;
        fi = runtime.util.newFieldList([i]).list()[0];
      }
      return fi;
    },
    runtime
  };
}
extensions.makeExtension = makeExtension;
function createExtensionContainer(extension) {
  const localName = extension.field.localName;
  const container = /* @__PURE__ */ Object.create(null);
  container[localName] = initExtensionField(extension);
  return [container, () => container[localName]];
}
extensions.createExtensionContainer = createExtensionContainer;
function initExtensionField(ext) {
  const field2 = ext.field;
  if (field2.repeated) {
    return [];
  }
  if (field2.default !== void 0) {
    return field2.default;
  }
  switch (field2.kind) {
    case "enum":
      return field2.T.values[0].no;
    case "scalar":
      return (0, scalars_js_1$6.scalarZeroValue)(field2.T, field2.L);
    case "message":
      const T = field2.T, value = new T();
      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(unknownFields, field2) {
  if (!field2.repeated && (field2.kind == "enum" || field2.kind == "scalar")) {
    for (let i = unknownFields.length - 1; i >= 0; --i) {
      if (unknownFields[i].no == field2.no) {
        return [unknownFields[i]];
      }
    }
    return [];
  }
  return unknownFields.filter((uf) => uf.no === field2.no);
}
extensions.filterUnknownFields = filterUnknownFields;
var jsonFormat = {};
var protoBase64 = {};
Object.defineProperty(protoBase64, "__esModule", { value: true });
protoBase64.protoBase64 = void 0;
let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
let decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
protoBase64.protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(base64Str) {
    let es = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=")
      es -= 2;
    else if (base64Str[base64Str.length - 1] == "=")
      es -= 1;
    let bytes2 = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
    for (let i = 0; i < base64Str.length; i++) {
      b = decTable[base64Str.charCodeAt(i)];
      if (b === void 0) {
        switch (base64Str[i]) {
          case "=":
            groupPos = 0;
          case "\n":
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      }
      switch (groupPos) {
        case 0:
          p = b;
          groupPos = 1;
          break;
        case 1:
          bytes2[bytePos++] = p << 2 | (b & 48) >> 4;
          p = b;
          groupPos = 2;
          break;
        case 2:
          bytes2[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
          p = b;
          groupPos = 3;
          break;
        case 3:
          bytes2[bytePos++] = (p & 3) << 6 | b;
          groupPos = 0;
          break;
      }
    }
    if (groupPos == 1)
      throw Error("invalid base64 string.");
    return bytes2.subarray(0, bytePos);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(bytes2) {
    let base64 = "", groupPos = 0, b, p = 0;
    for (let i = 0; i < bytes2.length; i++) {
      b = bytes2[i];
      switch (groupPos) {
        case 0:
          base64 += encTable[b >> 2];
          p = (b & 3) << 4;
          groupPos = 1;
          break;
        case 1:
          base64 += encTable[p | b >> 4];
          p = (b & 15) << 2;
          groupPos = 2;
          break;
        case 2:
          base64 += encTable[p | b >> 6];
          base64 += encTable[b & 63];
          groupPos = 0;
          break;
      }
    }
    if (groupPos) {
      base64 += encTable[p];
      base64 += "=";
      if (groupPos == 1)
        base64 += "=";
    }
    return base64;
  }
};
var extensionAccessor = {};
Object.defineProperty(extensionAccessor, "__esModule", { value: true });
extensionAccessor.hasExtension = extensionAccessor.clearExtension = extensionAccessor.setExtension = extensionAccessor.getExtension = void 0;
const assert_js_1$7 = assert$4;
const extensions_js_1$2 = extensions;
function getExtension(message2, extension, options) {
  assertExtendee(extension, message2);
  const opt = extension.runtime.bin.makeReadOptions(options);
  const ufs = (0, extensions_js_1$2.filterUnknownFields)(message2.getType().runtime.bin.listUnknownFields(message2), extension.field);
  const [container, get] = (0, extensions_js_1$2.createExtensionContainer)(extension);
  for (const uf of ufs) {
    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
  }
  return get();
}
extensionAccessor.getExtension = getExtension;
function setExtension(message2, extension, value, options) {
  assertExtendee(extension, message2);
  const readOpt = extension.runtime.bin.makeReadOptions(options);
  const writeOpt = extension.runtime.bin.makeWriteOptions(options);
  if (hasExtension(message2, extension)) {
    const ufs = message2.getType().runtime.bin.listUnknownFields(message2).filter((uf) => uf.no != extension.field.no);
    message2.getType().runtime.bin.discardUnknownFields(message2);
    for (const uf of ufs) {
      message2.getType().runtime.bin.onUnknownField(message2, uf.no, uf.wireType, uf.data);
    }
  }
  const writer = writeOpt.writerFactory();
  let f2 = extension.field;
  if (!f2.opt && !f2.repeated && (f2.kind == "enum" || f2.kind == "scalar")) {
    f2 = Object.assign(Object.assign({}, extension.field), { opt: true });
  }
  extension.runtime.bin.writeField(f2, value, writer, writeOpt);
  const reader = readOpt.readerFactory(writer.finish());
  while (reader.pos < reader.len) {
    const [no, wireType] = reader.tag();
    const data = reader.skip(wireType, no);
    message2.getType().runtime.bin.onUnknownField(message2, no, wireType, data);
  }
}
extensionAccessor.setExtension = setExtension;
function clearExtension(message2, extension) {
  assertExtendee(extension, message2);
  if (hasExtension(message2, extension)) {
    const bin = message2.getType().runtime.bin;
    const ufs = bin.listUnknownFields(message2).filter((uf) => uf.no != extension.field.no);
    bin.discardUnknownFields(message2);
    for (const uf of ufs) {
      bin.onUnknownField(message2, uf.no, uf.wireType, uf.data);
    }
  }
}
extensionAccessor.clearExtension = clearExtension;
function hasExtension(message2, extension) {
  const messageType2 = message2.getType();
  return extension.extendee.typeName === messageType2.typeName && !!messageType2.runtime.bin.listUnknownFields(message2).find((uf) => uf.no == extension.field.no);
}
extensionAccessor.hasExtension = hasExtension;
function assertExtendee(extension, message2) {
  (0, assert_js_1$7.assert)(extension.extendee.typeName == message2.getType().typeName, `extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
}
var reflect = {};
Object.defineProperty(reflect, "__esModule", { value: true });
reflect.clearField = reflect.isFieldSet = void 0;
const scalars_js_1$5 = scalars;
function isFieldSet(field2, target) {
  const localName = field2.localName;
  if (field2.repeated) {
    return target[localName].length > 0;
  }
  if (field2.oneof) {
    return target[field2.oneof.localName].case === localName;
  }
  switch (field2.kind) {
    case "enum":
    case "scalar":
      if (field2.opt || field2.req) {
        return target[localName] !== void 0;
      }
      if (field2.kind == "enum") {
        return target[localName] !== field2.T.values[0].no;
      }
      return !(0, scalars_js_1$5.isScalarZeroValue)(field2.T, target[localName]);
    case "message":
      return target[localName] !== void 0;
    case "map":
      return Object.keys(target[localName]).length > 0;
  }
}
reflect.isFieldSet = isFieldSet;
function clearField(field2, target) {
  const localName = field2.localName;
  const implicitPresence = !field2.opt && !field2.req;
  if (field2.repeated) {
    target[localName] = [];
  } else if (field2.oneof) {
    target[field2.oneof.localName] = { case: void 0 };
  } else {
    switch (field2.kind) {
      case "map":
        target[localName] = {};
        break;
      case "enum":
        target[localName] = implicitPresence ? field2.T.values[0].no : void 0;
        break;
      case "scalar":
        target[localName] = implicitPresence ? (0, scalars_js_1$5.scalarZeroValue)(field2.T, field2.L) : void 0;
        break;
      case "message":
        target[localName] = void 0;
        break;
    }
  }
}
reflect.clearField = clearField;
var fieldWrapper = {};
var isMessage$1 = {};
Object.defineProperty(isMessage$1, "__esModule", { value: true });
isMessage$1.isMessage = void 0;
const message_js_1$c = message;
function isMessage(arg, type) {
  if (arg === null || typeof arg != "object") {
    return false;
  }
  if (!Object.getOwnPropertyNames(message_js_1$c.Message.prototype).every((m) => m in arg && typeof arg[m] == "function")) {
    return false;
  }
  const actualType = arg.getType();
  if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
    return false;
  }
  return type === void 0 ? true : actualType.typeName == type.typeName;
}
isMessage$1.isMessage = isMessage;
Object.defineProperty(fieldWrapper, "__esModule", { value: true });
fieldWrapper.getUnwrappedFieldType = fieldWrapper.wrapField = void 0;
const scalar_js_1$8 = scalar;
const is_message_js_1$6 = isMessage$1;
function wrapField(type, value) {
  if ((0, is_message_js_1$6.isMessage)(value) || !type.fieldWrapper) {
    return value;
  }
  return type.fieldWrapper.wrapField(value);
}
fieldWrapper.wrapField = wrapField;
function getUnwrappedFieldType(field2) {
  if (field2.fieldKind !== "message") {
    return void 0;
  }
  if (field2.repeated) {
    return void 0;
  }
  if (field2.oneof != void 0) {
    return void 0;
  }
  return wktWrapperToScalarType[field2.message.typeName];
}
fieldWrapper.getUnwrappedFieldType = getUnwrappedFieldType;
const wktWrapperToScalarType = {
  "google.protobuf.DoubleValue": scalar_js_1$8.ScalarType.DOUBLE,
  "google.protobuf.FloatValue": scalar_js_1$8.ScalarType.FLOAT,
  "google.protobuf.Int64Value": scalar_js_1$8.ScalarType.INT64,
  "google.protobuf.UInt64Value": scalar_js_1$8.ScalarType.UINT64,
  "google.protobuf.Int32Value": scalar_js_1$8.ScalarType.INT32,
  "google.protobuf.UInt32Value": scalar_js_1$8.ScalarType.UINT32,
  "google.protobuf.BoolValue": scalar_js_1$8.ScalarType.BOOL,
  "google.protobuf.StringValue": scalar_js_1$8.ScalarType.STRING,
  "google.protobuf.BytesValue": scalar_js_1$8.ScalarType.BYTES
};
Object.defineProperty(jsonFormat, "__esModule", { value: true });
jsonFormat.makeJsonFormat = void 0;
const assert_js_1$6 = assert$4;
const proto_int64_js_1$5 = protoInt64;
const proto_base64_js_1$1 = protoBase64;
const extensions_js_1$1 = extensions;
const extension_accessor_js_1 = extensionAccessor;
const reflect_js_1$1 = reflect;
const field_wrapper_js_1$2 = fieldWrapper;
const scalars_js_1$4 = scalars;
const scalars_js_2 = scalars;
const scalar_js_1$7 = scalar;
const is_message_js_1$5 = isMessage$1;
const jsonReadDefaults = {
  ignoreUnknownFields: false
};
const jsonWriteDefaults = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
function makeReadOptions$1(options) {
  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
}
function makeWriteOptions$1(options) {
  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
}
const tokenNull = Symbol();
const tokenIgnoredUnknownEnum = Symbol();
function makeJsonFormat() {
  return {
    makeReadOptions: makeReadOptions$1,
    makeWriteOptions: makeWriteOptions$1,
    readMessage(type, json, options, message2) {
      if (json == null || Array.isArray(json) || typeof json != "object") {
        throw new Error(`cannot decode message ${type.typeName} from JSON: ${debugJsonValue(json)}`);
      }
      message2 = message2 !== null && message2 !== void 0 ? message2 : new type();
      const oneofSeen = /* @__PURE__ */ new Map();
      const registry = options.typeRegistry;
      for (const [jsonKey, jsonValue] of Object.entries(json)) {
        const field2 = type.fields.findJsonName(jsonKey);
        if (field2) {
          if (field2.oneof) {
            if (jsonValue === null && field2.kind == "scalar") {
              continue;
            }
            const seen = oneofSeen.get(field2.oneof);
            if (seen !== void 0) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof "${field2.oneof.name}" present: "${seen}", "${jsonKey}"`);
            }
            oneofSeen.set(field2.oneof, jsonKey);
          }
          readField$1(message2, jsonValue, field2, options, type);
        } else {
          let found = false;
          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
            if (ext && ext.extendee.typeName == type.typeName) {
              found = true;
              const [container, get] = (0, extensions_js_1$1.createExtensionContainer)(ext);
              readField$1(container, jsonValue, ext.field, options, ext);
              (0, extension_accessor_js_1.setExtension)(message2, ext, get(), options);
            }
          }
          if (!found && !options.ignoreUnknownFields) {
            throw new Error(`cannot decode message ${type.typeName} from JSON: key "${jsonKey}" is unknown`);
          }
        }
      }
      return message2;
    },
    writeMessage(message2, options) {
      const type = message2.getType();
      const json = {};
      let field2;
      try {
        for (field2 of type.fields.byNumber()) {
          if (!(0, reflect_js_1$1.isFieldSet)(field2, message2)) {
            if (field2.req) {
              throw `required field not set`;
            }
            if (!options.emitDefaultValues) {
              continue;
            }
            if (!canEmitFieldDefaultValue(field2)) {
              continue;
            }
          }
          const value = field2.oneof ? message2[field2.oneof.localName].value : message2[field2.localName];
          const jsonValue = writeField$1(field2, value, options);
          if (jsonValue !== void 0) {
            json[options.useProtoFieldName ? field2.name : field2.jsonName] = jsonValue;
          }
        }
        const registry = options.typeRegistry;
        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
          for (const uf of type.runtime.bin.listUnknownFields(message2)) {
            const ext = registry.findExtensionFor(type.typeName, uf.no);
            if (ext && (0, extension_accessor_js_1.hasExtension)(message2, ext)) {
              const value = (0, extension_accessor_js_1.getExtension)(message2, ext, options);
              const jsonValue = writeField$1(ext.field, value, options);
              if (jsonValue !== void 0) {
                json[ext.field.jsonName] = jsonValue;
              }
            }
          }
        }
      } catch (e) {
        const m = field2 ? `cannot encode field ${type.typeName}.${field2.name} to JSON` : `cannot encode message ${type.typeName} to JSON`;
        const r = e instanceof Error ? e.message : String(e);
        throw new Error(m + (r.length > 0 ? `: ${r}` : ""));
      }
      return json;
    },
    readScalar(type, json, longType) {
      return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : scalar_js_1$7.LongType.BIGINT, true);
    },
    writeScalar(type, value, emitDefaultValues) {
      if (value === void 0) {
        return void 0;
      }
      if (emitDefaultValues || (0, scalars_js_2.isScalarZeroValue)(type, value)) {
        return writeScalar$1(type, value);
      }
      return void 0;
    },
    debug: debugJsonValue
  };
}
jsonFormat.makeJsonFormat = makeJsonFormat;
function debugJsonValue(json) {
  if (json === null) {
    return "null";
  }
  switch (typeof json) {
    case "object":
      return Array.isArray(json) ? "array" : "object";
    case "string":
      return json.length > 100 ? "string" : `"${json.split('"').join('\\"')}"`;
    default:
      return String(json);
  }
}
function readField$1(target, jsonValue, field2, options, parentType) {
  let localName = field2.localName;
  if (field2.repeated) {
    (0, assert_js_1$6.assert)(field2.kind != "map");
    if (jsonValue === null) {
      return;
    }
    if (!Array.isArray(jsonValue)) {
      throw new Error(`cannot decode field ${parentType.typeName}.${field2.name} from JSON: ${debugJsonValue(jsonValue)}`);
    }
    const targetArray = target[localName];
    for (const jsonItem of jsonValue) {
      if (jsonItem === null) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field2.name} from JSON: ${debugJsonValue(jsonItem)}`);
      }
      switch (field2.kind) {
        case "message":
          targetArray.push(field2.T.fromJson(jsonItem, options));
          break;
        case "enum":
          const enumValue = readEnum(field2.T, jsonItem, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetArray.push(enumValue);
          }
          break;
        case "scalar":
          try {
            targetArray.push(readScalar$1(field2.T, jsonItem, field2.L, true));
          } catch (e) {
            let m = `cannot decode field ${parentType.typeName}.${field2.name} from JSON: ${debugJsonValue(jsonItem)}`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          break;
      }
    }
  } else if (field2.kind == "map") {
    if (jsonValue === null) {
      return;
    }
    if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
      throw new Error(`cannot decode field ${parentType.typeName}.${field2.name} from JSON: ${debugJsonValue(jsonValue)}`);
    }
    const targetMap = target[localName];
    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
      if (jsonMapValue === null) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field2.name} from JSON: map value null`);
      }
      let key2;
      try {
        key2 = readMapKey(field2.K, jsonMapKey);
      } catch (e) {
        let m = `cannot decode map key for field ${parentType.typeName}.${field2.name} from JSON: ${debugJsonValue(jsonValue)}`;
        if (e instanceof Error && e.message.length > 0) {
          m += `: ${e.message}`;
        }
        throw new Error(m);
      }
      switch (field2.V.kind) {
        case "message":
          targetMap[key2] = field2.V.T.fromJson(jsonMapValue, options);
          break;
        case "enum":
          const enumValue = readEnum(field2.V.T, jsonMapValue, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetMap[key2] = enumValue;
          }
          break;
        case "scalar":
          try {
            targetMap[key2] = readScalar$1(field2.V.T, jsonMapValue, scalar_js_1$7.LongType.BIGINT, true);
          } catch (e) {
            let m = `cannot decode map value for field ${parentType.typeName}.${field2.name} from JSON: ${debugJsonValue(jsonValue)}`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          break;
      }
    }
  } else {
    if (field2.oneof) {
      target = target[field2.oneof.localName] = { case: localName };
      localName = "value";
    }
    switch (field2.kind) {
      case "message":
        const messageType2 = field2.T;
        if (jsonValue === null && messageType2.typeName != "google.protobuf.Value") {
          return;
        }
        let currentValue = target[localName];
        if ((0, is_message_js_1$5.isMessage)(currentValue)) {
          currentValue.fromJson(jsonValue, options);
        } else {
          target[localName] = currentValue = messageType2.fromJson(jsonValue, options);
          if (messageType2.fieldWrapper && !field2.oneof) {
            target[localName] = messageType2.fieldWrapper.unwrapField(currentValue);
          }
        }
        break;
      case "enum":
        const enumValue = readEnum(field2.T, jsonValue, options.ignoreUnknownFields, false);
        switch (enumValue) {
          case tokenNull:
            (0, reflect_js_1$1.clearField)(field2, target);
            break;
          case tokenIgnoredUnknownEnum:
            break;
          default:
            target[localName] = enumValue;
            break;
        }
        break;
      case "scalar":
        try {
          const scalarValue = readScalar$1(field2.T, jsonValue, field2.L, false);
          switch (scalarValue) {
            case tokenNull:
              (0, reflect_js_1$1.clearField)(field2, target);
              break;
            default:
              target[localName] = scalarValue;
              break;
          }
        } catch (e) {
          let m = `cannot decode field ${parentType.typeName}.${field2.name} from JSON: ${debugJsonValue(jsonValue)}`;
          if (e instanceof Error && e.message.length > 0) {
            m += `: ${e.message}`;
          }
          throw new Error(m);
        }
        break;
    }
  }
}
function readMapKey(type, json) {
  if (type === scalar_js_1$7.ScalarType.BOOL) {
    switch (json) {
      case "true":
        json = true;
        break;
      case "false":
        json = false;
        break;
    }
  }
  return readScalar$1(type, json, scalar_js_1$7.LongType.BIGINT, true).toString();
}
function readScalar$1(type, json, longType, nullAsZeroValue) {
  if (json === null) {
    if (nullAsZeroValue) {
      return (0, scalars_js_1$4.scalarZeroValue)(type, longType);
    }
    return tokenNull;
  }
  switch (type) {
    case scalar_js_1$7.ScalarType.DOUBLE:
    case scalar_js_1$7.ScalarType.FLOAT:
      if (json === "NaN")
        return Number.NaN;
      if (json === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (json === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (json === "") {
        break;
      }
      if (typeof json == "string" && json.trim().length !== json.length) {
        break;
      }
      if (typeof json != "string" && typeof json != "number") {
        break;
      }
      const float = Number(json);
      if (Number.isNaN(float)) {
        break;
      }
      if (!Number.isFinite(float)) {
        break;
      }
      if (type == scalar_js_1$7.ScalarType.FLOAT)
        (0, assert_js_1$6.assertFloat32)(float);
      return float;
    case scalar_js_1$7.ScalarType.INT32:
    case scalar_js_1$7.ScalarType.FIXED32:
    case scalar_js_1$7.ScalarType.SFIXED32:
    case scalar_js_1$7.ScalarType.SINT32:
    case scalar_js_1$7.ScalarType.UINT32:
      let int32;
      if (typeof json == "number")
        int32 = json;
      else if (typeof json == "string" && json.length > 0) {
        if (json.trim().length === json.length)
          int32 = Number(json);
      }
      if (int32 === void 0)
        break;
      if (type == scalar_js_1$7.ScalarType.UINT32 || type == scalar_js_1$7.ScalarType.FIXED32)
        (0, assert_js_1$6.assertUInt32)(int32);
      else
        (0, assert_js_1$6.assertInt32)(int32);
      return int32;
    case scalar_js_1$7.ScalarType.INT64:
    case scalar_js_1$7.ScalarType.SFIXED64:
    case scalar_js_1$7.ScalarType.SINT64:
      if (typeof json != "number" && typeof json != "string")
        break;
      const long = proto_int64_js_1$5.protoInt64.parse(json);
      return longType ? long.toString() : long;
    case scalar_js_1$7.ScalarType.FIXED64:
    case scalar_js_1$7.ScalarType.UINT64:
      if (typeof json != "number" && typeof json != "string")
        break;
      const uLong = proto_int64_js_1$5.protoInt64.uParse(json);
      return longType ? uLong.toString() : uLong;
    case scalar_js_1$7.ScalarType.BOOL:
      if (typeof json !== "boolean")
        break;
      return json;
    case scalar_js_1$7.ScalarType.STRING:
      if (typeof json !== "string") {
        break;
      }
      try {
        encodeURIComponent(json);
      } catch (e) {
        throw new Error("invalid UTF8");
      }
      return json;
    case scalar_js_1$7.ScalarType.BYTES:
      if (json === "")
        return new Uint8Array(0);
      if (typeof json !== "string")
        break;
      return proto_base64_js_1$1.protoBase64.dec(json);
  }
  throw new Error();
}
function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
  if (json === null) {
    if (type.typeName == "google.protobuf.NullValue") {
      return 0;
    }
    return nullAsZeroValue ? type.values[0].no : tokenNull;
  }
  switch (typeof json) {
    case "number":
      if (Number.isInteger(json)) {
        return json;
      }
      break;
    case "string":
      const value = type.findName(json);
      if (value !== void 0) {
        return value.no;
      }
      if (ignoreUnknownFields) {
        return tokenIgnoredUnknownEnum;
      }
      break;
  }
  throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);
}
function canEmitFieldDefaultValue(field2) {
  if (field2.repeated || field2.kind == "map") {
    return true;
  }
  if (field2.oneof) {
    return false;
  }
  if (field2.kind == "message") {
    return false;
  }
  if (field2.opt || field2.req) {
    return false;
  }
  return true;
}
function writeField$1(field2, value, options) {
  if (field2.kind == "map") {
    (0, assert_js_1$6.assert)(typeof value == "object" && value != null);
    const jsonObj = {};
    const entries = Object.entries(value);
    switch (field2.V.kind) {
      case "scalar":
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = writeScalar$1(field2.V.T, entryValue);
        }
        break;
      case "message":
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = entryValue.toJson(options);
        }
        break;
      case "enum":
        const enumType = field2.V.T;
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
        }
        break;
    }
    return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
  }
  if (field2.repeated) {
    (0, assert_js_1$6.assert)(Array.isArray(value));
    const jsonArr = [];
    switch (field2.kind) {
      case "scalar":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(writeScalar$1(field2.T, value[i]));
        }
        break;
      case "enum":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(writeEnum(field2.T, value[i], options.enumAsInteger));
        }
        break;
      case "message":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(value[i].toJson(options));
        }
        break;
    }
    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
  }
  switch (field2.kind) {
    case "scalar":
      return writeScalar$1(field2.T, value);
    case "enum":
      return writeEnum(field2.T, value, options.enumAsInteger);
    case "message":
      return (0, field_wrapper_js_1$2.wrapField)(field2.T, value).toJson(options);
  }
}
function writeEnum(type, value, enumAsInteger) {
  var _a;
  (0, assert_js_1$6.assert)(typeof value == "number");
  if (type.typeName == "google.protobuf.NullValue") {
    return null;
  }
  if (enumAsInteger) {
    return value;
  }
  const val = type.findNumber(value);
  return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
}
function writeScalar$1(type, value) {
  switch (type) {
    case scalar_js_1$7.ScalarType.INT32:
    case scalar_js_1$7.ScalarType.SFIXED32:
    case scalar_js_1$7.ScalarType.SINT32:
    case scalar_js_1$7.ScalarType.FIXED32:
    case scalar_js_1$7.ScalarType.UINT32:
      (0, assert_js_1$6.assert)(typeof value == "number");
      return value;
    case scalar_js_1$7.ScalarType.FLOAT:
    case scalar_js_1$7.ScalarType.DOUBLE:
      (0, assert_js_1$6.assert)(typeof value == "number");
      if (Number.isNaN(value))
        return "NaN";
      if (value === Number.POSITIVE_INFINITY)
        return "Infinity";
      if (value === Number.NEGATIVE_INFINITY)
        return "-Infinity";
      return value;
    case scalar_js_1$7.ScalarType.STRING:
      (0, assert_js_1$6.assert)(typeof value == "string");
      return value;
    case scalar_js_1$7.ScalarType.BOOL:
      (0, assert_js_1$6.assert)(typeof value == "boolean");
      return value;
    case scalar_js_1$7.ScalarType.UINT64:
    case scalar_js_1$7.ScalarType.FIXED64:
    case scalar_js_1$7.ScalarType.INT64:
    case scalar_js_1$7.ScalarType.SFIXED64:
    case scalar_js_1$7.ScalarType.SINT64:
      (0, assert_js_1$6.assert)(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
      return value.toString();
    case scalar_js_1$7.ScalarType.BYTES:
      (0, assert_js_1$6.assert)(value instanceof Uint8Array);
      return proto_base64_js_1$1.protoBase64.enc(value);
  }
}
var binaryFormat = {};
var binaryEncoding = {};
Object.defineProperty(binaryEncoding, "__esModule", { value: true });
binaryEncoding.BinaryReader = binaryEncoding.BinaryWriter = binaryEncoding.WireType = void 0;
const varint_js_1 = varint;
const assert_js_1$5 = assert$4;
const proto_int64_js_1$4 = protoInt64;
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (binaryEncoding.WireType = WireType = {}));
class BinaryWriter {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes2 = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes2.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes2;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    (0, assert_js_1$5.assertUInt32)(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    (0, assert_js_1$5.assertInt32)(value);
    (0, varint_js_1.varint32write)(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.textEncoder.encode(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    (0, assert_js_1$5.assertFloat32)(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    (0, assert_js_1$5.assertUInt32)(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    (0, assert_js_1$5.assertInt32)(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    (0, assert_js_1$5.assertInt32)(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    (0, varint_js_1.varint32write)(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = proto_int64_js_1$4.protoInt64.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = proto_int64_js_1$4.protoInt64.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let tc = proto_int64_js_1$4.protoInt64.enc(value);
    (0, varint_js_1.varint64write)(tc.lo, tc.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let tc = proto_int64_js_1$4.protoInt64.enc(value), sign5 = tc.hi >> 31, lo = tc.lo << 1 ^ sign5, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign5;
    (0, varint_js_1.varint64write)(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let tc = proto_int64_js_1$4.protoInt64.uEnc(value);
    (0, varint_js_1.varint64write)(tc.lo, tc.hi, this.buf);
    return this;
  }
}
binaryEncoding.BinaryWriter = BinaryWriter;
class BinaryReader {
  constructor(buf, textDecoder) {
    this.varint64 = varint_js_1.varint64read;
    this.uint32 = varint_js_1.varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        for (; ; ) {
          const [fn, wt] = this.tag();
          if (wt === WireType.EndGroup) {
            if (fieldNo !== void 0 && fn !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return proto_int64_js_1$4.protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return proto_int64_js_1$4.protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return proto_int64_js_1$4.protoInt64.dec(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return proto_int64_js_1$4.protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return proto_int64_js_1$4.protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
binaryEncoding.BinaryReader = BinaryReader;
Object.defineProperty(binaryFormat, "__esModule", { value: true });
binaryFormat.writeMapEntry = binaryFormat.makeBinaryFormat = void 0;
const binary_encoding_js_1 = binaryEncoding;
const field_wrapper_js_1$1 = fieldWrapper;
const scalars_js_1$3 = scalars;
const assert_js_1$4 = assert$4;
const reflect_js_1 = reflect;
const scalar_js_1$6 = scalar;
const is_message_js_1$4 = isMessage$1;
const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
const readDefaults = {
  readUnknownFields: true,
  readerFactory: (bytes2) => new binary_encoding_js_1.BinaryReader(bytes2)
};
const writeDefaults = {
  writeUnknownFields: true,
  writerFactory: () => new binary_encoding_js_1.BinaryWriter()
};
function makeReadOptions(options) {
  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
}
function makeWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
}
function makeBinaryFormat() {
  return {
    makeReadOptions,
    makeWriteOptions,
    listUnknownFields(message2) {
      var _a;
      return (_a = message2[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
    },
    discardUnknownFields(message2) {
      delete message2[unknownFieldsSymbol];
    },
    writeUnknownFields(message2, writer) {
      const m = message2;
      const c = m[unknownFieldsSymbol];
      if (c) {
        for (const f2 of c) {
          writer.tag(f2.no, f2.wireType).raw(f2.data);
        }
      }
    },
    onUnknownField(message2, no, wireType, data) {
      const m = message2;
      if (!Array.isArray(m[unknownFieldsSymbol])) {
        m[unknownFieldsSymbol] = [];
      }
      m[unknownFieldsSymbol].push({ no, wireType, data });
    },
    readMessage(message2, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
      const type = message2.getType();
      const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
      let fieldNo, wireType;
      while (reader.pos < end) {
        [fieldNo, wireType] = reader.tag();
        if (delimitedMessageEncoding === true && wireType == binary_encoding_js_1.WireType.EndGroup) {
          break;
        }
        const field2 = type.fields.find(fieldNo);
        if (!field2) {
          const data = reader.skip(wireType, fieldNo);
          if (options.readUnknownFields) {
            this.onUnknownField(message2, fieldNo, wireType, data);
          }
          continue;
        }
        readField(message2, reader, field2, wireType, options);
      }
      if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (wireType != binary_encoding_js_1.WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
        throw new Error(`invalid end group tag`);
      }
    },
    readField,
    writeMessage(message2, writer, options) {
      const type = message2.getType();
      for (const field2 of type.fields.byNumber()) {
        if (!(0, reflect_js_1.isFieldSet)(field2, message2)) {
          if (field2.req) {
            throw new Error(`cannot encode field ${type.typeName}.${field2.name} to binary: required field not set`);
          }
          continue;
        }
        const value = field2.oneof ? message2[field2.oneof.localName].value : message2[field2.localName];
        writeField(field2, value, writer, options);
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message2, writer);
      }
      return writer;
    },
    writeField(field2, value, writer, options) {
      if (value === void 0) {
        return void 0;
      }
      writeField(field2, value, writer, options);
    }
  };
}
binaryFormat.makeBinaryFormat = makeBinaryFormat;
function readField(target, reader, field2, wireType, options) {
  let { repeated, localName } = field2;
  if (field2.oneof) {
    target = target[field2.oneof.localName];
    if (target.case != localName) {
      delete target.value;
    }
    target.case = localName;
    localName = "value";
  }
  switch (field2.kind) {
    case "scalar":
    case "enum":
      const scalarType = field2.kind == "enum" ? scalar_js_1$6.ScalarType.INT32 : field2.T;
      let read = readScalar;
      if (field2.kind == "scalar" && field2.L > 0) {
        read = readScalarLTString;
      }
      if (repeated) {
        let arr = target[localName];
        const isPacked = wireType == binary_encoding_js_1.WireType.LengthDelimited && scalarType != scalar_js_1$6.ScalarType.STRING && scalarType != scalar_js_1$6.ScalarType.BYTES;
        if (isPacked) {
          let e = reader.uint32() + reader.pos;
          while (reader.pos < e) {
            arr.push(read(reader, scalarType));
          }
        } else {
          arr.push(read(reader, scalarType));
        }
      } else {
        target[localName] = read(reader, scalarType);
      }
      break;
    case "message":
      const messageType2 = field2.T;
      if (repeated) {
        target[localName].push(readMessageField(reader, new messageType2(), options, field2));
      } else {
        if ((0, is_message_js_1$4.isMessage)(target[localName])) {
          readMessageField(reader, target[localName], options, field2);
        } else {
          target[localName] = readMessageField(reader, new messageType2(), options, field2);
          if (messageType2.fieldWrapper && !field2.oneof && !field2.repeated) {
            target[localName] = messageType2.fieldWrapper.unwrapField(target[localName]);
          }
        }
      }
      break;
    case "map":
      let [mapKey, mapVal] = readMapEntry(field2, reader, options);
      target[localName][mapKey] = mapVal;
      break;
  }
}
function readMessageField(reader, message2, options, field2) {
  const format = message2.getType().runtime.bin;
  const delimited = field2 === null || field2 === void 0 ? void 0 : field2.delimited;
  format.readMessage(
    message2,
    reader,
    delimited ? field2.no : reader.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    options,
    delimited
  );
  return message2;
}
function readMapEntry(field2, reader, options) {
  const length = reader.uint32(), end = reader.pos + length;
  let key2, val;
  while (reader.pos < end) {
    const [fieldNo] = reader.tag();
    switch (fieldNo) {
      case 1:
        key2 = readScalar(reader, field2.K);
        break;
      case 2:
        switch (field2.V.kind) {
          case "scalar":
            val = readScalar(reader, field2.V.T);
            break;
          case "enum":
            val = reader.int32();
            break;
          case "message":
            val = readMessageField(reader, new field2.V.T(), options, void 0);
            break;
        }
        break;
    }
  }
  if (key2 === void 0) {
    key2 = (0, scalars_js_1$3.scalarZeroValue)(field2.K, scalar_js_1$6.LongType.BIGINT);
  }
  if (typeof key2 != "string" && typeof key2 != "number") {
    key2 = key2.toString();
  }
  if (val === void 0) {
    switch (field2.V.kind) {
      case "scalar":
        val = (0, scalars_js_1$3.scalarZeroValue)(field2.V.T, scalar_js_1$6.LongType.BIGINT);
        break;
      case "enum":
        val = field2.V.T.values[0].no;
        break;
      case "message":
        val = new field2.V.T();
        break;
    }
  }
  return [key2, val];
}
function readScalarLTString(reader, type) {
  const v = readScalar(reader, type);
  return typeof v == "bigint" ? v.toString() : v;
}
function readScalar(reader, type) {
  switch (type) {
    case scalar_js_1$6.ScalarType.STRING:
      return reader.string();
    case scalar_js_1$6.ScalarType.BOOL:
      return reader.bool();
    case scalar_js_1$6.ScalarType.DOUBLE:
      return reader.double();
    case scalar_js_1$6.ScalarType.FLOAT:
      return reader.float();
    case scalar_js_1$6.ScalarType.INT32:
      return reader.int32();
    case scalar_js_1$6.ScalarType.INT64:
      return reader.int64();
    case scalar_js_1$6.ScalarType.UINT64:
      return reader.uint64();
    case scalar_js_1$6.ScalarType.FIXED64:
      return reader.fixed64();
    case scalar_js_1$6.ScalarType.BYTES:
      return reader.bytes();
    case scalar_js_1$6.ScalarType.FIXED32:
      return reader.fixed32();
    case scalar_js_1$6.ScalarType.SFIXED32:
      return reader.sfixed32();
    case scalar_js_1$6.ScalarType.SFIXED64:
      return reader.sfixed64();
    case scalar_js_1$6.ScalarType.SINT64:
      return reader.sint64();
    case scalar_js_1$6.ScalarType.UINT32:
      return reader.uint32();
    case scalar_js_1$6.ScalarType.SINT32:
      return reader.sint32();
  }
}
function writeField(field2, value, writer, options) {
  (0, assert_js_1$4.assert)(value !== void 0);
  const repeated = field2.repeated;
  switch (field2.kind) {
    case "scalar":
    case "enum":
      let scalarType = field2.kind == "enum" ? scalar_js_1$6.ScalarType.INT32 : field2.T;
      if (repeated) {
        (0, assert_js_1$4.assert)(Array.isArray(value));
        if (field2.packed) {
          writePacked(writer, scalarType, field2.no, value);
        } else {
          for (const item of value) {
            writeScalar(writer, scalarType, field2.no, item);
          }
        }
      } else {
        writeScalar(writer, scalarType, field2.no, value);
      }
      break;
    case "message":
      if (repeated) {
        (0, assert_js_1$4.assert)(Array.isArray(value));
        for (const item of value) {
          writeMessageField(writer, options, field2, item);
        }
      } else {
        writeMessageField(writer, options, field2, value);
      }
      break;
    case "map":
      (0, assert_js_1$4.assert)(typeof value == "object" && value != null);
      for (const [key2, val] of Object.entries(value)) {
        writeMapEntry(writer, options, field2, key2, val);
      }
      break;
  }
}
function writeMapEntry(writer, options, field2, key2, value) {
  writer.tag(field2.no, binary_encoding_js_1.WireType.LengthDelimited);
  writer.fork();
  let keyValue = key2;
  switch (field2.K) {
    case scalar_js_1$6.ScalarType.INT32:
    case scalar_js_1$6.ScalarType.FIXED32:
    case scalar_js_1$6.ScalarType.UINT32:
    case scalar_js_1$6.ScalarType.SFIXED32:
    case scalar_js_1$6.ScalarType.SINT32:
      keyValue = Number.parseInt(key2);
      break;
    case scalar_js_1$6.ScalarType.BOOL:
      (0, assert_js_1$4.assert)(key2 == "true" || key2 == "false");
      keyValue = key2 == "true";
      break;
  }
  writeScalar(writer, field2.K, 1, keyValue);
  switch (field2.V.kind) {
    case "scalar":
      writeScalar(writer, field2.V.T, 2, value);
      break;
    case "enum":
      writeScalar(writer, scalar_js_1$6.ScalarType.INT32, 2, value);
      break;
    case "message":
      (0, assert_js_1$4.assert)(value !== void 0);
      writer.tag(2, binary_encoding_js_1.WireType.LengthDelimited).bytes(value.toBinary(options));
      break;
  }
  writer.join();
}
binaryFormat.writeMapEntry = writeMapEntry;
function writeMessageField(writer, options, field2, value) {
  const message2 = (0, field_wrapper_js_1$1.wrapField)(field2.T, value);
  if (field2.delimited)
    writer.tag(field2.no, binary_encoding_js_1.WireType.StartGroup).raw(message2.toBinary(options)).tag(field2.no, binary_encoding_js_1.WireType.EndGroup);
  else
    writer.tag(field2.no, binary_encoding_js_1.WireType.LengthDelimited).bytes(message2.toBinary(options));
}
function writeScalar(writer, type, fieldNo, value) {
  (0, assert_js_1$4.assert)(value !== void 0);
  let [wireType, method] = scalarTypeInfo(type);
  writer.tag(fieldNo, wireType)[method](value);
}
function writePacked(writer, type, fieldNo, value) {
  if (!value.length) {
    return;
  }
  writer.tag(fieldNo, binary_encoding_js_1.WireType.LengthDelimited).fork();
  let [, method] = scalarTypeInfo(type);
  for (let i = 0; i < value.length; i++) {
    writer[method](value[i]);
  }
  writer.join();
}
function scalarTypeInfo(type) {
  let wireType = binary_encoding_js_1.WireType.Varint;
  switch (type) {
    case scalar_js_1$6.ScalarType.BYTES:
    case scalar_js_1$6.ScalarType.STRING:
      wireType = binary_encoding_js_1.WireType.LengthDelimited;
      break;
    case scalar_js_1$6.ScalarType.DOUBLE:
    case scalar_js_1$6.ScalarType.FIXED64:
    case scalar_js_1$6.ScalarType.SFIXED64:
      wireType = binary_encoding_js_1.WireType.Bit64;
      break;
    case scalar_js_1$6.ScalarType.FIXED32:
    case scalar_js_1$6.ScalarType.SFIXED32:
    case scalar_js_1$6.ScalarType.FLOAT:
      wireType = binary_encoding_js_1.WireType.Bit32;
      break;
  }
  const method = scalar_js_1$6.ScalarType[type].toLowerCase();
  return [wireType, method];
}
var utilCommon = {};
Object.defineProperty(utilCommon, "__esModule", { value: true });
utilCommon.makeUtilCommon = void 0;
const enum_js_1$2 = _enum;
const scalars_js_1$2 = scalars;
const scalar_js_1$5 = scalar;
const is_message_js_1$3 = isMessage$1;
function makeUtilCommon() {
  return {
    setEnumType: enum_js_1$2.setEnumType,
    initPartial(source, target) {
      if (source === void 0) {
        return;
      }
      const type = target.getType();
      for (const member of type.fields.byMember()) {
        const localName = member.localName, t = target, s = source;
        if (s[localName] == null) {
          continue;
        }
        switch (member.kind) {
          case "oneof":
            const sk = s[localName].case;
            if (sk === void 0) {
              continue;
            }
            const sourceField = member.findField(sk);
            let val = s[localName].value;
            if (sourceField && sourceField.kind == "message" && !(0, is_message_js_1$3.isMessage)(val, sourceField.T)) {
              val = new sourceField.T(val);
            } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === scalar_js_1$5.ScalarType.BYTES) {
              val = toU8Arr(val);
            }
            t[localName] = { case: sk, value: val };
            break;
          case "scalar":
          case "enum":
            let copy = s[localName];
            if (member.T === scalar_js_1$5.ScalarType.BYTES) {
              copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
            }
            t[localName] = copy;
            break;
          case "map":
            switch (member.V.kind) {
              case "scalar":
              case "enum":
                if (member.V.T === scalar_js_1$5.ScalarType.BYTES) {
                  for (const [k, v] of Object.entries(s[localName])) {
                    t[localName][k] = toU8Arr(v);
                  }
                } else {
                  Object.assign(t[localName], s[localName]);
                }
                break;
              case "message":
                const messageType2 = member.V.T;
                for (const k of Object.keys(s[localName])) {
                  let val2 = s[localName][k];
                  if (!messageType2.fieldWrapper) {
                    val2 = new messageType2(val2);
                  }
                  t[localName][k] = val2;
                }
                break;
            }
            break;
          case "message":
            const mt = member.T;
            if (member.repeated) {
              t[localName] = s[localName].map((val2) => (0, is_message_js_1$3.isMessage)(val2, mt) ? val2 : new mt(val2));
            } else {
              const val2 = s[localName];
              if (mt.fieldWrapper) {
                if (
                  // We can't use BytesValue.typeName as that will create a circular import
                  mt.typeName === "google.protobuf.BytesValue"
                ) {
                  t[localName] = toU8Arr(val2);
                } else {
                  t[localName] = val2;
                }
              } else {
                t[localName] = (0, is_message_js_1$3.isMessage)(val2, mt) ? val2 : new mt(val2);
              }
            }
            break;
        }
      }
    },
    // TODO use isFieldSet() here to support future field presence
    equals(type, a, b) {
      if (a === b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      return type.fields.byMember().every((m) => {
        const va = a[m.localName];
        const vb = b[m.localName];
        if (m.repeated) {
          if (va.length !== vb.length) {
            return false;
          }
          switch (m.kind) {
            case "message":
              return va.every((a2, i) => m.T.equals(a2, vb[i]));
            case "scalar":
              return va.every((a2, i) => (0, scalars_js_1$2.scalarEquals)(m.T, a2, vb[i]));
            case "enum":
              return va.every((a2, i) => (0, scalars_js_1$2.scalarEquals)(scalar_js_1$5.ScalarType.INT32, a2, vb[i]));
          }
          throw new Error(`repeated cannot contain ${m.kind}`);
        }
        switch (m.kind) {
          case "message":
            return m.T.equals(va, vb);
          case "enum":
            return (0, scalars_js_1$2.scalarEquals)(scalar_js_1$5.ScalarType.INT32, va, vb);
          case "scalar":
            return (0, scalars_js_1$2.scalarEquals)(m.T, va, vb);
          case "oneof":
            if (va.case !== vb.case) {
              return false;
            }
            const s = m.findField(va.case);
            if (s === void 0) {
              return true;
            }
            switch (s.kind) {
              case "message":
                return s.T.equals(va.value, vb.value);
              case "enum":
                return (0, scalars_js_1$2.scalarEquals)(scalar_js_1$5.ScalarType.INT32, va.value, vb.value);
              case "scalar":
                return (0, scalars_js_1$2.scalarEquals)(s.T, va.value, vb.value);
            }
            throw new Error(`oneof cannot contain ${s.kind}`);
          case "map":
            const keys2 = Object.keys(va).concat(Object.keys(vb));
            switch (m.V.kind) {
              case "message":
                const messageType2 = m.V.T;
                return keys2.every((k) => messageType2.equals(va[k], vb[k]));
              case "enum":
                return keys2.every((k) => (0, scalars_js_1$2.scalarEquals)(scalar_js_1$5.ScalarType.INT32, va[k], vb[k]));
              case "scalar":
                const scalarType = m.V.T;
                return keys2.every((k) => (0, scalars_js_1$2.scalarEquals)(scalarType, va[k], vb[k]));
            }
            break;
        }
      });
    },
    // TODO use isFieldSet() here to support future field presence
    clone(message2) {
      const type = message2.getType(), target = new type(), any = target;
      for (const member of type.fields.byMember()) {
        const source = message2[member.localName];
        let copy;
        if (member.repeated) {
          copy = source.map(cloneSingularField);
        } else if (member.kind == "map") {
          copy = any[member.localName];
          for (const [key2, v] of Object.entries(source)) {
            copy[key2] = cloneSingularField(v);
          }
        } else if (member.kind == "oneof") {
          const f2 = member.findField(source.case);
          copy = f2 ? { case: source.case, value: cloneSingularField(source.value) } : { case: void 0 };
        } else {
          copy = cloneSingularField(source);
        }
        any[member.localName] = copy;
      }
      for (const uf of type.runtime.bin.listUnknownFields(message2)) {
        type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
      }
      return target;
    }
  };
}
utilCommon.makeUtilCommon = makeUtilCommon;
function cloneSingularField(value) {
  if (value === void 0) {
    return value;
  }
  if ((0, is_message_js_1$3.isMessage)(value)) {
    return value.clone();
  }
  if (value instanceof Uint8Array) {
    const c = new Uint8Array(value.byteLength);
    c.set(value);
    return c;
  }
  return value;
}
function toU8Arr(input) {
  return input instanceof Uint8Array ? input : new Uint8Array(input);
}
Object.defineProperty(protoRuntime, "__esModule", { value: true });
protoRuntime.makeProtoRuntime = void 0;
const enum_js_1$1 = _enum;
const message_type_js_1 = messageType;
const extensions_js_1 = extensions;
const json_format_js_1 = jsonFormat;
const binary_format_js_1 = binaryFormat;
const util_common_js_1 = utilCommon;
function makeProtoRuntime(syntax, newFieldList, initFields) {
  return {
    syntax,
    json: (0, json_format_js_1.makeJsonFormat)(),
    bin: (0, binary_format_js_1.makeBinaryFormat)(),
    util: Object.assign(Object.assign({}, (0, util_common_js_1.makeUtilCommon)()), {
      newFieldList,
      initFields
    }),
    makeMessageType(typeName, fields, opt) {
      return (0, message_type_js_1.makeMessageType)(this, typeName, fields, opt);
    },
    makeEnum: enum_js_1$1.makeEnum,
    makeEnumType: enum_js_1$1.makeEnumType,
    getEnumType: enum_js_1$1.getEnumType,
    makeExtension(typeName, extendee, field2) {
      return (0, extensions_js_1.makeExtension)(this, typeName, extendee, field2);
    }
  };
}
protoRuntime.makeProtoRuntime = makeProtoRuntime;
var fieldList = {};
Object.defineProperty(fieldList, "__esModule", { value: true });
fieldList.InternalFieldList = void 0;
class InternalFieldList {
  constructor(fields, normalizer) {
    this._fields = fields;
    this._normalizer = normalizer;
  }
  findJsonName(jsonName) {
    if (!this.jsonNames) {
      const t = {};
      for (const f2 of this.list()) {
        t[f2.jsonName] = t[f2.name] = f2;
      }
      this.jsonNames = t;
    }
    return this.jsonNames[jsonName];
  }
  find(fieldNo) {
    if (!this.numbers) {
      const t = {};
      for (const f2 of this.list()) {
        t[f2.no] = f2;
      }
      this.numbers = t;
    }
    return this.numbers[fieldNo];
  }
  list() {
    if (!this.all) {
      this.all = this._normalizer(this._fields);
    }
    return this.all;
  }
  byNumber() {
    if (!this.numbersAsc) {
      this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);
    }
    return this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const a = this.members;
      let o;
      for (const f2 of this.list()) {
        if (f2.oneof) {
          if (f2.oneof !== o) {
            o = f2.oneof;
            a.push(o);
          }
        } else {
          a.push(f2);
        }
      }
    }
    return this.members;
  }
}
fieldList.InternalFieldList = InternalFieldList;
var fieldNormalize = {};
var field$1 = {};
var names = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.safeIdentifier = exports.safeObjectProperty = exports.findEnumSharedPrefix = exports.fieldJsonName = exports.localOneofName = exports.localFieldName = exports.localName = void 0;
  function localName(desc) {
    switch (desc.kind) {
      case "field":
        return localFieldName(desc.name, desc.oneof !== void 0);
      case "oneof":
        return localOneofName(desc.name);
      case "enum":
      case "message":
      case "service":
      case "extension": {
        const pkg = desc.file.proto.package;
        const offset = pkg === void 0 ? 0 : pkg.length + 1;
        const name2 = desc.typeName.substring(offset).replace(/\./g, "_");
        return (0, exports.safeObjectProperty)((0, exports.safeIdentifier)(name2));
      }
      case "enum_value": {
        let name2 = desc.name;
        const sharedPrefix = desc.parent.sharedPrefix;
        if (sharedPrefix !== void 0) {
          name2 = name2.substring(sharedPrefix.length);
        }
        return (0, exports.safeObjectProperty)(name2);
      }
      case "rpc": {
        let name2 = desc.name;
        if (name2.length == 0) {
          return name2;
        }
        name2 = name2[0].toLowerCase() + name2.substring(1);
        return (0, exports.safeObjectProperty)(name2);
      }
    }
  }
  exports.localName = localName;
  function localFieldName(protoName, inOneof) {
    const name2 = protoCamelCase(protoName);
    if (inOneof) {
      return name2;
    }
    return (0, exports.safeObjectProperty)(safeMessageProperty(name2));
  }
  exports.localFieldName = localFieldName;
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  exports.localOneofName = localOneofName;
  exports.fieldJsonName = protoCamelCase;
  function findEnumSharedPrefix(enumName, valueNames) {
    const prefix = camelToSnakeCase(enumName) + "_";
    for (const name2 of valueNames) {
      if (!name2.toLowerCase().startsWith(prefix)) {
        return void 0;
      }
      const shortName = name2.substring(prefix.length);
      if (shortName.length == 0) {
        return void 0;
      }
      if (/^\d/.test(shortName)) {
        return void 0;
      }
    }
    return prefix;
  }
  exports.findEnumSharedPrefix = findEnumSharedPrefix;
  function camelToSnakeCase(camel) {
    return (camel.substring(0, 1) + camel.substring(1).replace(/[A-Z]/g, (c) => "_" + c)).toLowerCase();
  }
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b = [];
    for (let i = 0; i < snakeCase.length; i++) {
      let c = snakeCase.charAt(i);
      switch (c) {
        case "_":
          capNext = true;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b.push(c);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c = c.toUpperCase();
          }
          b.push(c);
          break;
      }
    }
    return b.join("");
  }
  const reservedIdentifiers = /* @__PURE__ */ new Set([
    // ECMAScript 2015 keywords
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "else",
    "export",
    "extends",
    "false",
    "finally",
    "for",
    "function",
    "if",
    "import",
    "in",
    "instanceof",
    "new",
    "null",
    "return",
    "super",
    "switch",
    "this",
    "throw",
    "true",
    "try",
    "typeof",
    "var",
    "void",
    "while",
    "with",
    "yield",
    // ECMAScript 2015 future reserved keywords
    "enum",
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    // Class name cannot be 'Object' when targeting ES5 with module CommonJS
    "Object",
    // TypeScript keywords that cannot be used for types (as opposed to variables)
    "bigint",
    "number",
    "boolean",
    "string",
    "object",
    // Identifiers reserved for the runtime, so we can generate legible code
    "globalThis",
    "Uint8Array",
    "Partial"
  ]);
  const reservedObjectProperties = /* @__PURE__ */ new Set([
    // names reserved by JavaScript
    "constructor",
    "toString",
    "toJSON",
    "valueOf"
  ]);
  const reservedMessageProperties = /* @__PURE__ */ new Set([
    // names reserved by the runtime
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    // names reserved by the runtime for the future
    "toObject"
  ]);
  const fallback = (name2) => `${name2}$`;
  const safeMessageProperty = (name2) => {
    if (reservedMessageProperties.has(name2)) {
      return fallback(name2);
    }
    return name2;
  };
  const safeObjectProperty = (name2) => {
    if (reservedObjectProperties.has(name2)) {
      return fallback(name2);
    }
    return name2;
  };
  exports.safeObjectProperty = safeObjectProperty;
  const safeIdentifier = (name2) => {
    if (reservedIdentifiers.has(name2)) {
      return fallback(name2);
    }
    return name2;
  };
  exports.safeIdentifier = safeIdentifier;
})(names);
Object.defineProperty(field$1, "__esModule", { value: true });
field$1.InternalOneofInfo = void 0;
const names_js_1$4 = names;
const assert_js_1$3 = assert$4;
class InternalOneofInfo {
  constructor(name2) {
    this.kind = "oneof";
    this.repeated = false;
    this.packed = false;
    this.opt = false;
    this.req = false;
    this.default = void 0;
    this.fields = [];
    this.name = name2;
    this.localName = (0, names_js_1$4.localOneofName)(name2);
  }
  addField(field2) {
    (0, assert_js_1$3.assert)(field2.oneof === this, `field ${field2.name} not one of ${this.name}`);
    this.fields.push(field2);
  }
  findField(localName) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < this.fields.length; i++) {
        this._lookup[this.fields[i].localName] = this.fields[i];
      }
    }
    return this._lookup[localName];
  }
}
field$1.InternalOneofInfo = InternalOneofInfo;
Object.defineProperty(fieldNormalize, "__esModule", { value: true });
fieldNormalize.normalizeFieldInfos = void 0;
const field_js_1 = field$1;
const names_js_1$3 = names;
const scalar_js_1$4 = scalar;
function normalizeFieldInfos(fieldInfos, packedByDefault) {
  var _a, _b, _c, _d, _e, _f;
  const r = [];
  let o;
  for (const field2 of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
    const f2 = field2;
    f2.localName = (0, names_js_1$3.localFieldName)(field2.name, field2.oneof !== void 0);
    f2.jsonName = (_a = field2.jsonName) !== null && _a !== void 0 ? _a : (0, names_js_1$3.fieldJsonName)(field2.name);
    f2.repeated = (_b = field2.repeated) !== null && _b !== void 0 ? _b : false;
    if (field2.kind == "scalar") {
      f2.L = (_c = field2.L) !== null && _c !== void 0 ? _c : scalar_js_1$4.LongType.BIGINT;
    }
    f2.delimited = (_d = field2.delimited) !== null && _d !== void 0 ? _d : false;
    f2.req = (_e = field2.req) !== null && _e !== void 0 ? _e : false;
    f2.opt = (_f = field2.opt) !== null && _f !== void 0 ? _f : false;
    if (field2.packed === void 0) {
      if (packedByDefault) {
        f2.packed = field2.kind == "enum" || field2.kind == "scalar" && field2.T != scalar_js_1$4.ScalarType.BYTES && field2.T != scalar_js_1$4.ScalarType.STRING;
      } else {
        f2.packed = false;
      }
    }
    if (field2.oneof !== void 0) {
      const ooname = typeof field2.oneof == "string" ? field2.oneof : field2.oneof.name;
      if (!o || o.name != ooname) {
        o = new field_js_1.InternalOneofInfo(ooname);
      }
      f2.oneof = o;
      o.addField(f2);
    }
    r.push(f2);
  }
  return r;
}
fieldNormalize.normalizeFieldInfos = normalizeFieldInfos;
Object.defineProperty(proto3, "__esModule", { value: true });
proto3.proto3 = void 0;
const proto_runtime_js_1$1 = protoRuntime;
const field_list_js_1$1 = fieldList;
const scalars_js_1$1 = scalars;
const field_normalize_js_1$1 = fieldNormalize;
proto3.proto3 = (0, proto_runtime_js_1$1.makeProtoRuntime)(
  "proto3",
  (fields) => {
    return new field_list_js_1$1.InternalFieldList(fields, (source) => (0, field_normalize_js_1$1.normalizeFieldInfos)(source, true));
  },
  // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
  (target) => {
    for (const member of target.getType().fields.byMember()) {
      if (member.opt) {
        continue;
      }
      const name2 = member.localName, t = target;
      if (member.repeated) {
        t[name2] = [];
        continue;
      }
      switch (member.kind) {
        case "oneof":
          t[name2] = { case: void 0 };
          break;
        case "enum":
          t[name2] = 0;
          break;
        case "map":
          t[name2] = {};
          break;
        case "scalar":
          t[name2] = (0, scalars_js_1$1.scalarZeroValue)(member.T, member.L);
          break;
      }
    }
  }
);
var proto2 = {};
Object.defineProperty(proto2, "__esModule", { value: true });
proto2.proto2 = void 0;
const proto_runtime_js_1 = protoRuntime;
const field_list_js_1 = fieldList;
const field_normalize_js_1 = fieldNormalize;
proto2.proto2 = (0, proto_runtime_js_1.makeProtoRuntime)(
  "proto2",
  (fields) => {
    return new field_list_js_1.InternalFieldList(fields, (source) => (0, field_normalize_js_1.normalizeFieldInfos)(source, false));
  },
  // TODO merge with proto3 and initExtensionField, also see initPartial, equals, clone
  (target) => {
    for (const member of target.getType().fields.byMember()) {
      const name2 = member.localName, t = target;
      if (member.repeated) {
        t[name2] = [];
        continue;
      }
      switch (member.kind) {
        case "oneof":
          t[name2] = { case: void 0 };
          break;
        case "map":
          t[name2] = {};
          break;
      }
    }
  }
);
var protoDouble = {};
Object.defineProperty(protoDouble, "__esModule", { value: true });
protoDouble.protoDouble = void 0;
protoDouble.protoDouble = {
  NaN: Number.NaN,
  POSITIVE_INFINITY: Number.POSITIVE_INFINITY,
  NEGATIVE_INFINITY: Number.NEGATIVE_INFINITY
};
var protoDelimited = {};
(function(exports) {
  var __asyncValues2 = commonjsGlobal && commonjsGlobal.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve2, reject) {
          v = o[n](v), settle(resolve2, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve2, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve2({ value: v2, done: d });
      }, reject);
    }
  };
  var __await2 = commonjsGlobal && commonjsGlobal.__await || function(v) {
    return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
  };
  var __asyncGenerator2 = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f2) {
      return function(v) {
        return Promise.resolve(v).then(f2, reject);
      };
    }
    function verb(n, f2) {
      if (g[n]) {
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f2) i[n] = f2(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f2, v) {
      if (f2(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.protoDelimited = void 0;
  const binary_encoding_js_12 = binaryEncoding;
  exports.protoDelimited = {
    /**
     * Serialize a message, prefixing it with its size.
     */
    enc(message2, options) {
      const opt = message2.getType().runtime.bin.makeWriteOptions(options);
      return opt.writerFactory().bytes(message2.toBinary(opt)).finish();
    },
    /**
     * Parse a size-delimited message, ignoring extra bytes.
     */
    dec(type, bytes2, options) {
      const opt = type.runtime.bin.makeReadOptions(options);
      return type.fromBinary(opt.readerFactory(bytes2).bytes(), opt);
    },
    /**
     * Parse a stream of size-delimited messages.
     */
    decStream(type, iterable) {
      return __asyncGenerator2(this, arguments, function* decStream_1() {
        var _a, e_1, _b, _c;
        function append(buffer2, chunk) {
          const n = new Uint8Array(buffer2.byteLength + chunk.byteLength);
          n.set(buffer2);
          n.set(chunk, buffer2.length);
          return n;
        }
        let buffer = new Uint8Array(0);
        try {
          for (var _d = true, iterable_1 = __asyncValues2(iterable), iterable_1_1; iterable_1_1 = yield __await2(iterable_1.next()), _a = iterable_1_1.done, !_a; _d = true) {
            _c = iterable_1_1.value;
            _d = false;
            const chunk = _c;
            buffer = append(buffer, chunk);
            for (; ; ) {
              const size = exports.protoDelimited.peekSize(buffer);
              if (size.eof) {
                break;
              }
              if (size.offset + size.size > buffer.byteLength) {
                break;
              }
              yield yield __await2(exports.protoDelimited.dec(type, buffer));
              buffer = buffer.subarray(size.offset + size.size);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = iterable_1.return)) yield __await2(_b.call(iterable_1));
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (buffer.byteLength > 0) {
          throw new Error("incomplete data");
        }
      });
    },
    /**
     * Decodes the size from the given size-delimited message, which may be
     * incomplete.
     *
     * Returns an object with the following properties:
     * - size: The size of the delimited message in bytes
     * - offset: The offset in the given byte array where the message starts
     * - eof: true
     *
     * If the size-delimited data does not include all bytes of the varint size,
     * the following object is returned:
     * - size: null
     * - offset: null
     * - eof: false
     *
     * This function can be used to implement parsing of size-delimited messages
     * from a stream.
     */
    peekSize(data) {
      const sizeEof = { eof: true, size: null, offset: null };
      for (let i = 0; i < 10; i++) {
        if (i > data.byteLength) {
          return sizeEof;
        }
        if ((data[i] & 128) == 0) {
          const reader = new binary_encoding_js_12.BinaryReader(data);
          let size;
          try {
            size = reader.uint32();
          } catch (e) {
            if (e instanceof RangeError) {
              return sizeEof;
            }
            throw e;
          }
          return {
            eof: false,
            size,
            offset: reader.pos
          };
        }
      }
      throw new Error("invalid varint");
    }
  };
})(protoDelimited);
var codegenInfo = {};
var reifyWkt$1 = {};
Object.defineProperty(reifyWkt$1, "__esModule", { value: true });
reifyWkt$1.reifyWkt = void 0;
const scalar_js_1$3 = scalar;
function reifyWkt(message2) {
  switch (message2.typeName) {
    case "google.protobuf.Any": {
      const typeUrl = message2.fields.find((f2) => f2.number == 1 && f2.fieldKind == "scalar" && f2.scalar === scalar_js_1$3.ScalarType.STRING);
      const value = message2.fields.find((f2) => f2.number == 2 && f2.fieldKind == "scalar" && f2.scalar === scalar_js_1$3.ScalarType.BYTES);
      if (typeUrl && value) {
        return {
          typeName: message2.typeName,
          typeUrl,
          value
        };
      }
      break;
    }
    case "google.protobuf.Timestamp": {
      const seconds = message2.fields.find((f2) => f2.number == 1 && f2.fieldKind == "scalar" && f2.scalar === scalar_js_1$3.ScalarType.INT64);
      const nanos = message2.fields.find((f2) => f2.number == 2 && f2.fieldKind == "scalar" && f2.scalar === scalar_js_1$3.ScalarType.INT32);
      if (seconds && nanos) {
        return {
          typeName: message2.typeName,
          seconds,
          nanos
        };
      }
      break;
    }
    case "google.protobuf.Duration": {
      const seconds = message2.fields.find((f2) => f2.number == 1 && f2.fieldKind == "scalar" && f2.scalar === scalar_js_1$3.ScalarType.INT64);
      const nanos = message2.fields.find((f2) => f2.number == 2 && f2.fieldKind == "scalar" && f2.scalar === scalar_js_1$3.ScalarType.INT32);
      if (seconds && nanos) {
        return {
          typeName: message2.typeName,
          seconds,
          nanos
        };
      }
      break;
    }
    case "google.protobuf.Struct": {
      const fields = message2.fields.find((f2) => f2.number == 1 && !f2.repeated);
      if ((fields === null || fields === void 0 ? void 0 : fields.fieldKind) !== "map" || fields.mapValue.kind !== "message" || fields.mapValue.message.typeName !== "google.protobuf.Value") {
        break;
      }
      return { typeName: message2.typeName, fields };
    }
    case "google.protobuf.Value": {
      const kind = message2.oneofs.find((o) => o.name === "kind");
      const nullValue = message2.fields.find((f2) => f2.number == 1 && f2.oneof === kind);
      if ((nullValue === null || nullValue === void 0 ? void 0 : nullValue.fieldKind) !== "enum" || nullValue.enum.typeName !== "google.protobuf.NullValue") {
        return void 0;
      }
      const numberValue = message2.fields.find((f2) => f2.number == 2 && f2.fieldKind == "scalar" && f2.scalar === scalar_js_1$3.ScalarType.DOUBLE && f2.oneof === kind);
      const stringValue = message2.fields.find((f2) => f2.number == 3 && f2.fieldKind == "scalar" && f2.scalar === scalar_js_1$3.ScalarType.STRING && f2.oneof === kind);
      const boolValue = message2.fields.find((f2) => f2.number == 4 && f2.fieldKind == "scalar" && f2.scalar === scalar_js_1$3.ScalarType.BOOL && f2.oneof === kind);
      const structValue = message2.fields.find((f2) => f2.number == 5 && f2.oneof === kind);
      if ((structValue === null || structValue === void 0 ? void 0 : structValue.fieldKind) !== "message" || structValue.message.typeName !== "google.protobuf.Struct") {
        return void 0;
      }
      const listValue = message2.fields.find((f2) => f2.number == 6 && f2.oneof === kind);
      if ((listValue === null || listValue === void 0 ? void 0 : listValue.fieldKind) !== "message" || listValue.message.typeName !== "google.protobuf.ListValue") {
        return void 0;
      }
      if (kind && numberValue && stringValue && boolValue) {
        return {
          typeName: message2.typeName,
          kind,
          nullValue,
          numberValue,
          stringValue,
          boolValue,
          structValue,
          listValue
        };
      }
      break;
    }
    case "google.protobuf.ListValue": {
      const values = message2.fields.find((f2) => f2.number == 1 && f2.repeated);
      if ((values === null || values === void 0 ? void 0 : values.fieldKind) != "message" || values.message.typeName !== "google.protobuf.Value") {
        break;
      }
      return { typeName: message2.typeName, values };
    }
    case "google.protobuf.FieldMask": {
      const paths = message2.fields.find((f2) => f2.number == 1 && f2.fieldKind == "scalar" && f2.scalar === scalar_js_1$3.ScalarType.STRING && f2.repeated);
      if (paths) {
        return { typeName: message2.typeName, paths };
      }
      break;
    }
    case "google.protobuf.DoubleValue":
    case "google.protobuf.FloatValue":
    case "google.protobuf.Int64Value":
    case "google.protobuf.UInt64Value":
    case "google.protobuf.Int32Value":
    case "google.protobuf.UInt32Value":
    case "google.protobuf.BoolValue":
    case "google.protobuf.StringValue":
    case "google.protobuf.BytesValue": {
      const value = message2.fields.find((f2) => f2.number == 1 && f2.name == "value");
      if (!value) {
        break;
      }
      if (value.fieldKind !== "scalar") {
        break;
      }
      return { typeName: message2.typeName, value };
    }
  }
  return void 0;
}
reifyWkt$1.reifyWkt = reifyWkt;
Object.defineProperty(codegenInfo, "__esModule", { value: true });
codegenInfo.codegenInfo = void 0;
const names_js_1$2 = names;
const field_wrapper_js_1 = fieldWrapper;
const scalars_js_1 = scalars;
const reify_wkt_js_1 = reifyWkt$1;
const packageName = "@bufbuild/protobuf";
codegenInfo.codegenInfo = {
  packageName: "@bufbuild/protobuf",
  localName: names_js_1$2.localName,
  reifyWkt: reify_wkt_js_1.reifyWkt,
  getUnwrappedFieldType: field_wrapper_js_1.getUnwrappedFieldType,
  scalarDefaultValue: scalars_js_1.scalarZeroValue,
  scalarZeroValue: scalars_js_1.scalarZeroValue,
  safeIdentifier: names_js_1$2.safeIdentifier,
  safeObjectProperty: names_js_1$2.safeObjectProperty,
  // prettier-ignore
  symbols: {
    proto2: { typeOnly: false, privateImportPath: "./proto2.js", publicImportPath: packageName },
    proto3: { typeOnly: false, privateImportPath: "./proto3.js", publicImportPath: packageName },
    Message: { typeOnly: false, privateImportPath: "./message.js", publicImportPath: packageName },
    PartialMessage: { typeOnly: true, privateImportPath: "./message.js", publicImportPath: packageName },
    PlainMessage: { typeOnly: true, privateImportPath: "./message.js", publicImportPath: packageName },
    FieldList: { typeOnly: true, privateImportPath: "./field-list.js", publicImportPath: packageName },
    MessageType: { typeOnly: true, privateImportPath: "./message-type.js", publicImportPath: packageName },
    Extension: { typeOnly: true, privateImportPath: "./extension.js", publicImportPath: packageName },
    BinaryReadOptions: { typeOnly: true, privateImportPath: "./binary-format.js", publicImportPath: packageName },
    BinaryWriteOptions: { typeOnly: true, privateImportPath: "./binary-format.js", publicImportPath: packageName },
    JsonReadOptions: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
    JsonWriteOptions: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
    JsonValue: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
    JsonObject: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
    protoDouble: { typeOnly: false, privateImportPath: "./proto-double.js", publicImportPath: packageName },
    protoInt64: { typeOnly: false, privateImportPath: "./proto-int64.js", publicImportPath: packageName },
    ScalarType: { typeOnly: false, privateImportPath: "./scalar.js", publicImportPath: packageName },
    LongType: { typeOnly: false, privateImportPath: "./scalar.js", publicImportPath: packageName },
    MethodKind: { typeOnly: false, privateImportPath: "./service-type.js", publicImportPath: packageName },
    MethodIdempotency: { typeOnly: false, privateImportPath: "./service-type.js", publicImportPath: packageName },
    IMessageTypeRegistry: { typeOnly: true, privateImportPath: "./type-registry.js", publicImportPath: packageName }
  },
  wktSourceFiles: [
    "google/protobuf/compiler/plugin.proto",
    "google/protobuf/any.proto",
    "google/protobuf/api.proto",
    "google/protobuf/descriptor.proto",
    "google/protobuf/duration.proto",
    "google/protobuf/empty.proto",
    "google/protobuf/field_mask.proto",
    "google/protobuf/source_context.proto",
    "google/protobuf/struct.proto",
    "google/protobuf/timestamp.proto",
    "google/protobuf/type.proto",
    "google/protobuf/wrappers.proto"
  ]
};
var serviceType = {};
Object.defineProperty(serviceType, "__esModule", { value: true });
serviceType.MethodIdempotency = serviceType.MethodKind = void 0;
var MethodKind;
(function(MethodKind2) {
  MethodKind2[MethodKind2["Unary"] = 0] = "Unary";
  MethodKind2[MethodKind2["ServerStreaming"] = 1] = "ServerStreaming";
  MethodKind2[MethodKind2["ClientStreaming"] = 2] = "ClientStreaming";
  MethodKind2[MethodKind2["BiDiStreaming"] = 3] = "BiDiStreaming";
})(MethodKind || (serviceType.MethodKind = MethodKind = {}));
var MethodIdempotency;
(function(MethodIdempotency2) {
  MethodIdempotency2[MethodIdempotency2["NoSideEffects"] = 1] = "NoSideEffects";
  MethodIdempotency2[MethodIdempotency2["Idempotent"] = 2] = "Idempotent";
})(MethodIdempotency || (serviceType.MethodIdempotency = MethodIdempotency = {}));
var createDescriptorSet$1 = {};
var descriptor_pb = {};
Object.defineProperty(descriptor_pb, "__esModule", { value: true });
descriptor_pb.GeneratedCodeInfo_Annotation_Semantic = descriptor_pb.GeneratedCodeInfo_Annotation = descriptor_pb.GeneratedCodeInfo = descriptor_pb.SourceCodeInfo_Location = descriptor_pb.SourceCodeInfo = descriptor_pb.FeatureSetDefaults_FeatureSetEditionDefault = descriptor_pb.FeatureSetDefaults = descriptor_pb.FeatureSet_JsonFormat = descriptor_pb.FeatureSet_MessageEncoding = descriptor_pb.FeatureSet_Utf8Validation = descriptor_pb.FeatureSet_RepeatedFieldEncoding = descriptor_pb.FeatureSet_EnumType = descriptor_pb.FeatureSet_FieldPresence = descriptor_pb.FeatureSet = descriptor_pb.UninterpretedOption_NamePart = descriptor_pb.UninterpretedOption = descriptor_pb.MethodOptions_IdempotencyLevel = descriptor_pb.MethodOptions = descriptor_pb.ServiceOptions = descriptor_pb.EnumValueOptions = descriptor_pb.EnumOptions = descriptor_pb.OneofOptions = descriptor_pb.FieldOptions_FeatureSupport = descriptor_pb.FieldOptions_EditionDefault = descriptor_pb.FieldOptions_OptionTargetType = descriptor_pb.FieldOptions_OptionRetention = descriptor_pb.FieldOptions_JSType = descriptor_pb.FieldOptions_CType = descriptor_pb.FieldOptions = descriptor_pb.MessageOptions = descriptor_pb.FileOptions_OptimizeMode = descriptor_pb.FileOptions = descriptor_pb.MethodDescriptorProto = descriptor_pb.ServiceDescriptorProto = descriptor_pb.EnumValueDescriptorProto = descriptor_pb.EnumDescriptorProto_EnumReservedRange = descriptor_pb.EnumDescriptorProto = descriptor_pb.OneofDescriptorProto = descriptor_pb.FieldDescriptorProto_Label = descriptor_pb.FieldDescriptorProto_Type = descriptor_pb.FieldDescriptorProto = descriptor_pb.ExtensionRangeOptions_Declaration = descriptor_pb.ExtensionRangeOptions_VerificationState = descriptor_pb.ExtensionRangeOptions = descriptor_pb.DescriptorProto_ReservedRange = descriptor_pb.DescriptorProto_ExtensionRange = descriptor_pb.DescriptorProto = descriptor_pb.FileDescriptorProto = descriptor_pb.FileDescriptorSet = descriptor_pb.Edition = void 0;
const proto2_js_1$2 = proto2;
const message_js_1$b = message;
var Edition;
(function(Edition2) {
  Edition2[Edition2["EDITION_UNKNOWN"] = 0] = "EDITION_UNKNOWN";
  Edition2[Edition2["EDITION_LEGACY"] = 900] = "EDITION_LEGACY";
  Edition2[Edition2["EDITION_PROTO2"] = 998] = "EDITION_PROTO2";
  Edition2[Edition2["EDITION_PROTO3"] = 999] = "EDITION_PROTO3";
  Edition2[Edition2["EDITION_2023"] = 1e3] = "EDITION_2023";
  Edition2[Edition2["EDITION_2024"] = 1001] = "EDITION_2024";
  Edition2[Edition2["EDITION_1_TEST_ONLY"] = 1] = "EDITION_1_TEST_ONLY";
  Edition2[Edition2["EDITION_2_TEST_ONLY"] = 2] = "EDITION_2_TEST_ONLY";
  Edition2[Edition2["EDITION_99997_TEST_ONLY"] = 99997] = "EDITION_99997_TEST_ONLY";
  Edition2[Edition2["EDITION_99998_TEST_ONLY"] = 99998] = "EDITION_99998_TEST_ONLY";
  Edition2[Edition2["EDITION_99999_TEST_ONLY"] = 99999] = "EDITION_99999_TEST_ONLY";
  Edition2[Edition2["EDITION_MAX"] = 2147483647] = "EDITION_MAX";
})(Edition || (descriptor_pb.Edition = Edition = {}));
proto2_js_1$2.proto2.util.setEnumType(Edition, "google.protobuf.Edition", [
  { no: 0, name: "EDITION_UNKNOWN" },
  { no: 900, name: "EDITION_LEGACY" },
  { no: 998, name: "EDITION_PROTO2" },
  { no: 999, name: "EDITION_PROTO3" },
  { no: 1e3, name: "EDITION_2023" },
  { no: 1001, name: "EDITION_2024" },
  { no: 1, name: "EDITION_1_TEST_ONLY" },
  { no: 2, name: "EDITION_2_TEST_ONLY" },
  { no: 99997, name: "EDITION_99997_TEST_ONLY" },
  { no: 99998, name: "EDITION_99998_TEST_ONLY" },
  { no: 99999, name: "EDITION_99999_TEST_ONLY" },
  { no: 2147483647, name: "EDITION_MAX" }
]);
class FileDescriptorSet extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.file = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new FileDescriptorSet().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FileDescriptorSet().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FileDescriptorSet().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(FileDescriptorSet, a, b);
  }
}
descriptor_pb.FileDescriptorSet = FileDescriptorSet;
FileDescriptorSet.runtime = proto2_js_1$2.proto2;
FileDescriptorSet.typeName = "google.protobuf.FileDescriptorSet";
FileDescriptorSet.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "file", kind: "message", T: FileDescriptorProto, repeated: true }
]);
class FileDescriptorProto extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.dependency = [];
    this.publicDependency = [];
    this.weakDependency = [];
    this.messageType = [];
    this.enumType = [];
    this.service = [];
    this.extension = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new FileDescriptorProto().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FileDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FileDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(FileDescriptorProto, a, b);
  }
}
descriptor_pb.FileDescriptorProto = FileDescriptorProto;
FileDescriptorProto.runtime = proto2_js_1$2.proto2;
FileDescriptorProto.typeName = "google.protobuf.FileDescriptorProto";
FileDescriptorProto.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "package", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "dependency", kind: "scalar", T: 9, repeated: true },
  { no: 10, name: "public_dependency", kind: "scalar", T: 5, repeated: true },
  { no: 11, name: "weak_dependency", kind: "scalar", T: 5, repeated: true },
  { no: 4, name: "message_type", kind: "message", T: DescriptorProto, repeated: true },
  { no: 5, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
  { no: 6, name: "service", kind: "message", T: ServiceDescriptorProto, repeated: true },
  { no: 7, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 8, name: "options", kind: "message", T: FileOptions, opt: true },
  { no: 9, name: "source_code_info", kind: "message", T: SourceCodeInfo, opt: true },
  { no: 12, name: "syntax", kind: "scalar", T: 9, opt: true },
  { no: 14, name: "edition", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(Edition), opt: true }
]);
class DescriptorProto extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.field = [];
    this.extension = [];
    this.nestedType = [];
    this.enumType = [];
    this.extensionRange = [];
    this.oneofDecl = [];
    this.reservedRange = [];
    this.reservedName = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new DescriptorProto().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new DescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new DescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(DescriptorProto, a, b);
  }
}
descriptor_pb.DescriptorProto = DescriptorProto;
DescriptorProto.runtime = proto2_js_1$2.proto2;
DescriptorProto.typeName = "google.protobuf.DescriptorProto";
DescriptorProto.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "field", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 6, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 3, name: "nested_type", kind: "message", T: DescriptorProto, repeated: true },
  { no: 4, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
  { no: 5, name: "extension_range", kind: "message", T: DescriptorProto_ExtensionRange, repeated: true },
  { no: 8, name: "oneof_decl", kind: "message", T: OneofDescriptorProto, repeated: true },
  { no: 7, name: "options", kind: "message", T: MessageOptions, opt: true },
  { no: 9, name: "reserved_range", kind: "message", T: DescriptorProto_ReservedRange, repeated: true },
  { no: 10, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
]);
class DescriptorProto_ExtensionRange extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new DescriptorProto_ExtensionRange().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new DescriptorProto_ExtensionRange().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new DescriptorProto_ExtensionRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(DescriptorProto_ExtensionRange, a, b);
  }
}
descriptor_pb.DescriptorProto_ExtensionRange = DescriptorProto_ExtensionRange;
DescriptorProto_ExtensionRange.runtime = proto2_js_1$2.proto2;
DescriptorProto_ExtensionRange.typeName = "google.protobuf.DescriptorProto.ExtensionRange";
DescriptorProto_ExtensionRange.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "options", kind: "message", T: ExtensionRangeOptions, opt: true }
]);
class DescriptorProto_ReservedRange extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new DescriptorProto_ReservedRange().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new DescriptorProto_ReservedRange().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new DescriptorProto_ReservedRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(DescriptorProto_ReservedRange, a, b);
  }
}
descriptor_pb.DescriptorProto_ReservedRange = DescriptorProto_ReservedRange;
DescriptorProto_ReservedRange.runtime = proto2_js_1$2.proto2;
DescriptorProto_ReservedRange.typeName = "google.protobuf.DescriptorProto.ReservedRange";
DescriptorProto_ReservedRange.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
]);
class ExtensionRangeOptions extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    this.declaration = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new ExtensionRangeOptions().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new ExtensionRangeOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new ExtensionRangeOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(ExtensionRangeOptions, a, b);
  }
}
descriptor_pb.ExtensionRangeOptions = ExtensionRangeOptions;
ExtensionRangeOptions.runtime = proto2_js_1$2.proto2;
ExtensionRangeOptions.typeName = "google.protobuf.ExtensionRangeOptions";
ExtensionRangeOptions.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true },
  { no: 2, name: "declaration", kind: "message", T: ExtensionRangeOptions_Declaration, repeated: true },
  { no: 50, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 3, name: "verification", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(ExtensionRangeOptions_VerificationState), opt: true, default: ExtensionRangeOptions_VerificationState.UNVERIFIED }
]);
var ExtensionRangeOptions_VerificationState;
(function(ExtensionRangeOptions_VerificationState2) {
  ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["DECLARATION"] = 0] = "DECLARATION";
  ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["UNVERIFIED"] = 1] = "UNVERIFIED";
})(ExtensionRangeOptions_VerificationState || (descriptor_pb.ExtensionRangeOptions_VerificationState = ExtensionRangeOptions_VerificationState = {}));
proto2_js_1$2.proto2.util.setEnumType(ExtensionRangeOptions_VerificationState, "google.protobuf.ExtensionRangeOptions.VerificationState", [
  { no: 0, name: "DECLARATION" },
  { no: 1, name: "UNVERIFIED" }
]);
class ExtensionRangeOptions_Declaration extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new ExtensionRangeOptions_Declaration().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new ExtensionRangeOptions_Declaration().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new ExtensionRangeOptions_Declaration().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(ExtensionRangeOptions_Declaration, a, b);
  }
}
descriptor_pb.ExtensionRangeOptions_Declaration = ExtensionRangeOptions_Declaration;
ExtensionRangeOptions_Declaration.runtime = proto2_js_1$2.proto2;
ExtensionRangeOptions_Declaration.typeName = "google.protobuf.ExtensionRangeOptions.Declaration";
ExtensionRangeOptions_Declaration.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "full_name", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "type", kind: "scalar", T: 9, opt: true },
  { no: 5, name: "reserved", kind: "scalar", T: 8, opt: true },
  { no: 6, name: "repeated", kind: "scalar", T: 8, opt: true }
]);
class FieldDescriptorProto extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new FieldDescriptorProto().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FieldDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FieldDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(FieldDescriptorProto, a, b);
  }
}
descriptor_pb.FieldDescriptorProto = FieldDescriptorProto;
FieldDescriptorProto.runtime = proto2_js_1$2.proto2;
FieldDescriptorProto.typeName = "google.protobuf.FieldDescriptorProto";
FieldDescriptorProto.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "label", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FieldDescriptorProto_Label), opt: true },
  { no: 5, name: "type", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FieldDescriptorProto_Type), opt: true },
  { no: 6, name: "type_name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "extendee", kind: "scalar", T: 9, opt: true },
  { no: 7, name: "default_value", kind: "scalar", T: 9, opt: true },
  { no: 9, name: "oneof_index", kind: "scalar", T: 5, opt: true },
  { no: 10, name: "json_name", kind: "scalar", T: 9, opt: true },
  { no: 8, name: "options", kind: "message", T: FieldOptions, opt: true },
  { no: 17, name: "proto3_optional", kind: "scalar", T: 8, opt: true }
]);
var FieldDescriptorProto_Type;
(function(FieldDescriptorProto_Type2) {
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["DOUBLE"] = 1] = "DOUBLE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FLOAT"] = 2] = "FLOAT";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT64"] = 3] = "INT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT64"] = 4] = "UINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT32"] = 5] = "INT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED64"] = 6] = "FIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED32"] = 7] = "FIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BOOL"] = 8] = "BOOL";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["STRING"] = 9] = "STRING";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["GROUP"] = 10] = "GROUP";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["MESSAGE"] = 11] = "MESSAGE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BYTES"] = 12] = "BYTES";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT32"] = 13] = "UINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["ENUM"] = 14] = "ENUM";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED32"] = 15] = "SFIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED64"] = 16] = "SFIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT32"] = 17] = "SINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT64"] = 18] = "SINT64";
})(FieldDescriptorProto_Type || (descriptor_pb.FieldDescriptorProto_Type = FieldDescriptorProto_Type = {}));
proto2_js_1$2.proto2.util.setEnumType(FieldDescriptorProto_Type, "google.protobuf.FieldDescriptorProto.Type", [
  { no: 1, name: "TYPE_DOUBLE" },
  { no: 2, name: "TYPE_FLOAT" },
  { no: 3, name: "TYPE_INT64" },
  { no: 4, name: "TYPE_UINT64" },
  { no: 5, name: "TYPE_INT32" },
  { no: 6, name: "TYPE_FIXED64" },
  { no: 7, name: "TYPE_FIXED32" },
  { no: 8, name: "TYPE_BOOL" },
  { no: 9, name: "TYPE_STRING" },
  { no: 10, name: "TYPE_GROUP" },
  { no: 11, name: "TYPE_MESSAGE" },
  { no: 12, name: "TYPE_BYTES" },
  { no: 13, name: "TYPE_UINT32" },
  { no: 14, name: "TYPE_ENUM" },
  { no: 15, name: "TYPE_SFIXED32" },
  { no: 16, name: "TYPE_SFIXED64" },
  { no: 17, name: "TYPE_SINT32" },
  { no: 18, name: "TYPE_SINT64" }
]);
var FieldDescriptorProto_Label;
(function(FieldDescriptorProto_Label2) {
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["OPTIONAL"] = 1] = "OPTIONAL";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REPEATED"] = 3] = "REPEATED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REQUIRED"] = 2] = "REQUIRED";
})(FieldDescriptorProto_Label || (descriptor_pb.FieldDescriptorProto_Label = FieldDescriptorProto_Label = {}));
proto2_js_1$2.proto2.util.setEnumType(FieldDescriptorProto_Label, "google.protobuf.FieldDescriptorProto.Label", [
  { no: 1, name: "LABEL_OPTIONAL" },
  { no: 3, name: "LABEL_REPEATED" },
  { no: 2, name: "LABEL_REQUIRED" }
]);
class OneofDescriptorProto extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new OneofDescriptorProto().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new OneofDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new OneofDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(OneofDescriptorProto, a, b);
  }
}
descriptor_pb.OneofDescriptorProto = OneofDescriptorProto;
OneofDescriptorProto.runtime = proto2_js_1$2.proto2;
OneofDescriptorProto.typeName = "google.protobuf.OneofDescriptorProto";
OneofDescriptorProto.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "options", kind: "message", T: OneofOptions, opt: true }
]);
class EnumDescriptorProto extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.value = [];
    this.reservedRange = [];
    this.reservedName = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new EnumDescriptorProto().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new EnumDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new EnumDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(EnumDescriptorProto, a, b);
  }
}
descriptor_pb.EnumDescriptorProto = EnumDescriptorProto;
EnumDescriptorProto.runtime = proto2_js_1$2.proto2;
EnumDescriptorProto.typeName = "google.protobuf.EnumDescriptorProto";
EnumDescriptorProto.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "value", kind: "message", T: EnumValueDescriptorProto, repeated: true },
  { no: 3, name: "options", kind: "message", T: EnumOptions, opt: true },
  { no: 4, name: "reserved_range", kind: "message", T: EnumDescriptorProto_EnumReservedRange, repeated: true },
  { no: 5, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
]);
class EnumDescriptorProto_EnumReservedRange extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new EnumDescriptorProto_EnumReservedRange().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new EnumDescriptorProto_EnumReservedRange().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new EnumDescriptorProto_EnumReservedRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(EnumDescriptorProto_EnumReservedRange, a, b);
  }
}
descriptor_pb.EnumDescriptorProto_EnumReservedRange = EnumDescriptorProto_EnumReservedRange;
EnumDescriptorProto_EnumReservedRange.runtime = proto2_js_1$2.proto2;
EnumDescriptorProto_EnumReservedRange.typeName = "google.protobuf.EnumDescriptorProto.EnumReservedRange";
EnumDescriptorProto_EnumReservedRange.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
]);
class EnumValueDescriptorProto extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new EnumValueDescriptorProto().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new EnumValueDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new EnumValueDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(EnumValueDescriptorProto, a, b);
  }
}
descriptor_pb.EnumValueDescriptorProto = EnumValueDescriptorProto;
EnumValueDescriptorProto.runtime = proto2_js_1$2.proto2;
EnumValueDescriptorProto.typeName = "google.protobuf.EnumValueDescriptorProto";
EnumValueDescriptorProto.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "options", kind: "message", T: EnumValueOptions, opt: true }
]);
class ServiceDescriptorProto extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.method = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new ServiceDescriptorProto().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new ServiceDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new ServiceDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(ServiceDescriptorProto, a, b);
  }
}
descriptor_pb.ServiceDescriptorProto = ServiceDescriptorProto;
ServiceDescriptorProto.runtime = proto2_js_1$2.proto2;
ServiceDescriptorProto.typeName = "google.protobuf.ServiceDescriptorProto";
ServiceDescriptorProto.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "method", kind: "message", T: MethodDescriptorProto, repeated: true },
  { no: 3, name: "options", kind: "message", T: ServiceOptions, opt: true }
]);
class MethodDescriptorProto extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new MethodDescriptorProto().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new MethodDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new MethodDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(MethodDescriptorProto, a, b);
  }
}
descriptor_pb.MethodDescriptorProto = MethodDescriptorProto;
MethodDescriptorProto.runtime = proto2_js_1$2.proto2;
MethodDescriptorProto.typeName = "google.protobuf.MethodDescriptorProto";
MethodDescriptorProto.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "input_type", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "output_type", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "options", kind: "message", T: MethodOptions, opt: true },
  { no: 5, name: "client_streaming", kind: "scalar", T: 8, opt: true, default: false },
  { no: 6, name: "server_streaming", kind: "scalar", T: 8, opt: true, default: false }
]);
class FileOptions extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new FileOptions().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FileOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FileOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(FileOptions, a, b);
  }
}
descriptor_pb.FileOptions = FileOptions;
FileOptions.runtime = proto2_js_1$2.proto2;
FileOptions.typeName = "google.protobuf.FileOptions";
FileOptions.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "java_package", kind: "scalar", T: 9, opt: true },
  { no: 8, name: "java_outer_classname", kind: "scalar", T: 9, opt: true },
  { no: 10, name: "java_multiple_files", kind: "scalar", T: 8, opt: true, default: false },
  { no: 20, name: "java_generate_equals_and_hash", kind: "scalar", T: 8, opt: true },
  { no: 27, name: "java_string_check_utf8", kind: "scalar", T: 8, opt: true, default: false },
  { no: 9, name: "optimize_for", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FileOptions_OptimizeMode), opt: true, default: FileOptions_OptimizeMode.SPEED },
  { no: 11, name: "go_package", kind: "scalar", T: 9, opt: true },
  { no: 16, name: "cc_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 17, name: "java_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 18, name: "py_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 23, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 31, name: "cc_enable_arenas", kind: "scalar", T: 8, opt: true, default: true },
  { no: 36, name: "objc_class_prefix", kind: "scalar", T: 9, opt: true },
  { no: 37, name: "csharp_namespace", kind: "scalar", T: 9, opt: true },
  { no: 39, name: "swift_prefix", kind: "scalar", T: 9, opt: true },
  { no: 40, name: "php_class_prefix", kind: "scalar", T: 9, opt: true },
  { no: 41, name: "php_namespace", kind: "scalar", T: 9, opt: true },
  { no: 44, name: "php_metadata_namespace", kind: "scalar", T: 9, opt: true },
  { no: 45, name: "ruby_package", kind: "scalar", T: 9, opt: true },
  { no: 50, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FileOptions_OptimizeMode;
(function(FileOptions_OptimizeMode2) {
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
})(FileOptions_OptimizeMode || (descriptor_pb.FileOptions_OptimizeMode = FileOptions_OptimizeMode = {}));
proto2_js_1$2.proto2.util.setEnumType(FileOptions_OptimizeMode, "google.protobuf.FileOptions.OptimizeMode", [
  { no: 1, name: "SPEED" },
  { no: 2, name: "CODE_SIZE" },
  { no: 3, name: "LITE_RUNTIME" }
]);
class MessageOptions extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new MessageOptions().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new MessageOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new MessageOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(MessageOptions, a, b);
  }
}
descriptor_pb.MessageOptions = MessageOptions;
MessageOptions.runtime = proto2_js_1$2.proto2;
MessageOptions.typeName = "google.protobuf.MessageOptions";
MessageOptions.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "message_set_wire_format", kind: "scalar", T: 8, opt: true, default: false },
  { no: 2, name: "no_standard_descriptor_accessor", kind: "scalar", T: 8, opt: true, default: false },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 7, name: "map_entry", kind: "scalar", T: 8, opt: true },
  { no: 11, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
  { no: 12, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
class FieldOptions extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.targets = [];
    this.editionDefaults = [];
    this.uninterpretedOption = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new FieldOptions().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FieldOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FieldOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(FieldOptions, a, b);
  }
}
descriptor_pb.FieldOptions = FieldOptions;
FieldOptions.runtime = proto2_js_1$2.proto2;
FieldOptions.typeName = "google.protobuf.FieldOptions";
FieldOptions.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "ctype", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FieldOptions_CType), opt: true, default: FieldOptions_CType.STRING },
  { no: 2, name: "packed", kind: "scalar", T: 8, opt: true },
  { no: 6, name: "jstype", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FieldOptions_JSType), opt: true, default: FieldOptions_JSType.JS_NORMAL },
  { no: 5, name: "lazy", kind: "scalar", T: 8, opt: true, default: false },
  { no: 15, name: "unverified_lazy", kind: "scalar", T: 8, opt: true, default: false },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 10, name: "weak", kind: "scalar", T: 8, opt: true, default: false },
  { no: 16, name: "debug_redact", kind: "scalar", T: 8, opt: true, default: false },
  { no: 17, name: "retention", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FieldOptions_OptionRetention), opt: true },
  { no: 19, name: "targets", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FieldOptions_OptionTargetType), repeated: true },
  { no: 20, name: "edition_defaults", kind: "message", T: FieldOptions_EditionDefault, repeated: true },
  { no: 21, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 22, name: "feature_support", kind: "message", T: FieldOptions_FeatureSupport, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FieldOptions_CType;
(function(FieldOptions_CType2) {
  FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
  FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
  FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
})(FieldOptions_CType || (descriptor_pb.FieldOptions_CType = FieldOptions_CType = {}));
proto2_js_1$2.proto2.util.setEnumType(FieldOptions_CType, "google.protobuf.FieldOptions.CType", [
  { no: 0, name: "STRING" },
  { no: 1, name: "CORD" },
  { no: 2, name: "STRING_PIECE" }
]);
var FieldOptions_JSType;
(function(FieldOptions_JSType2) {
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
})(FieldOptions_JSType || (descriptor_pb.FieldOptions_JSType = FieldOptions_JSType = {}));
proto2_js_1$2.proto2.util.setEnumType(FieldOptions_JSType, "google.protobuf.FieldOptions.JSType", [
  { no: 0, name: "JS_NORMAL" },
  { no: 1, name: "JS_STRING" },
  { no: 2, name: "JS_NUMBER" }
]);
var FieldOptions_OptionRetention;
(function(FieldOptions_OptionRetention2) {
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
})(FieldOptions_OptionRetention || (descriptor_pb.FieldOptions_OptionRetention = FieldOptions_OptionRetention = {}));
proto2_js_1$2.proto2.util.setEnumType(FieldOptions_OptionRetention, "google.protobuf.FieldOptions.OptionRetention", [
  { no: 0, name: "RETENTION_UNKNOWN" },
  { no: 1, name: "RETENTION_RUNTIME" },
  { no: 2, name: "RETENTION_SOURCE" }
]);
var FieldOptions_OptionTargetType;
(function(FieldOptions_OptionTargetType2) {
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
})(FieldOptions_OptionTargetType || (descriptor_pb.FieldOptions_OptionTargetType = FieldOptions_OptionTargetType = {}));
proto2_js_1$2.proto2.util.setEnumType(FieldOptions_OptionTargetType, "google.protobuf.FieldOptions.OptionTargetType", [
  { no: 0, name: "TARGET_TYPE_UNKNOWN" },
  { no: 1, name: "TARGET_TYPE_FILE" },
  { no: 2, name: "TARGET_TYPE_EXTENSION_RANGE" },
  { no: 3, name: "TARGET_TYPE_MESSAGE" },
  { no: 4, name: "TARGET_TYPE_FIELD" },
  { no: 5, name: "TARGET_TYPE_ONEOF" },
  { no: 6, name: "TARGET_TYPE_ENUM" },
  { no: 7, name: "TARGET_TYPE_ENUM_ENTRY" },
  { no: 8, name: "TARGET_TYPE_SERVICE" },
  { no: 9, name: "TARGET_TYPE_METHOD" }
]);
class FieldOptions_EditionDefault extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new FieldOptions_EditionDefault().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FieldOptions_EditionDefault().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FieldOptions_EditionDefault().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(FieldOptions_EditionDefault, a, b);
  }
}
descriptor_pb.FieldOptions_EditionDefault = FieldOptions_EditionDefault;
FieldOptions_EditionDefault.runtime = proto2_js_1$2.proto2;
FieldOptions_EditionDefault.typeName = "google.protobuf.FieldOptions.EditionDefault";
FieldOptions_EditionDefault.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 3, name: "edition", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(Edition), opt: true },
  { no: 2, name: "value", kind: "scalar", T: 9, opt: true }
]);
class FieldOptions_FeatureSupport extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new FieldOptions_FeatureSupport().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FieldOptions_FeatureSupport().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FieldOptions_FeatureSupport().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(FieldOptions_FeatureSupport, a, b);
  }
}
descriptor_pb.FieldOptions_FeatureSupport = FieldOptions_FeatureSupport;
FieldOptions_FeatureSupport.runtime = proto2_js_1$2.proto2;
FieldOptions_FeatureSupport.typeName = "google.protobuf.FieldOptions.FeatureSupport";
FieldOptions_FeatureSupport.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "edition_introduced", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(Edition), opt: true },
  { no: 2, name: "edition_deprecated", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(Edition), opt: true },
  { no: 3, name: "deprecation_warning", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "edition_removed", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(Edition), opt: true }
]);
class OneofOptions extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new OneofOptions().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new OneofOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new OneofOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(OneofOptions, a, b);
  }
}
descriptor_pb.OneofOptions = OneofOptions;
OneofOptions.runtime = proto2_js_1$2.proto2;
OneofOptions.typeName = "google.protobuf.OneofOptions";
OneofOptions.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
class EnumOptions extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new EnumOptions().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new EnumOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new EnumOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(EnumOptions, a, b);
  }
}
descriptor_pb.EnumOptions = EnumOptions;
EnumOptions.runtime = proto2_js_1$2.proto2;
EnumOptions.typeName = "google.protobuf.EnumOptions";
EnumOptions.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 2, name: "allow_alias", kind: "scalar", T: 8, opt: true },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 6, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
  { no: 7, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
class EnumValueOptions extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new EnumValueOptions().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new EnumValueOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new EnumValueOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(EnumValueOptions, a, b);
  }
}
descriptor_pb.EnumValueOptions = EnumValueOptions;
EnumValueOptions.runtime = proto2_js_1$2.proto2;
EnumValueOptions.typeName = "google.protobuf.EnumValueOptions";
EnumValueOptions.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 2, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 3, name: "debug_redact", kind: "scalar", T: 8, opt: true, default: false },
  { no: 4, name: "feature_support", kind: "message", T: FieldOptions_FeatureSupport, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
class ServiceOptions extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new ServiceOptions().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new ServiceOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new ServiceOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(ServiceOptions, a, b);
  }
}
descriptor_pb.ServiceOptions = ServiceOptions;
ServiceOptions.runtime = proto2_js_1$2.proto2;
ServiceOptions.typeName = "google.protobuf.ServiceOptions";
ServiceOptions.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 34, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
class MethodOptions extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new MethodOptions().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new MethodOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new MethodOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(MethodOptions, a, b);
  }
}
descriptor_pb.MethodOptions = MethodOptions;
MethodOptions.runtime = proto2_js_1$2.proto2;
MethodOptions.typeName = "google.protobuf.MethodOptions";
MethodOptions.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 34, name: "idempotency_level", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(MethodOptions_IdempotencyLevel), opt: true, default: MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN },
  { no: 35, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var MethodOptions_IdempotencyLevel;
(function(MethodOptions_IdempotencyLevel2) {
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
})(MethodOptions_IdempotencyLevel || (descriptor_pb.MethodOptions_IdempotencyLevel = MethodOptions_IdempotencyLevel = {}));
proto2_js_1$2.proto2.util.setEnumType(MethodOptions_IdempotencyLevel, "google.protobuf.MethodOptions.IdempotencyLevel", [
  { no: 0, name: "IDEMPOTENCY_UNKNOWN" },
  { no: 1, name: "NO_SIDE_EFFECTS" },
  { no: 2, name: "IDEMPOTENT" }
]);
class UninterpretedOption extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.name = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new UninterpretedOption().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new UninterpretedOption().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new UninterpretedOption().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(UninterpretedOption, a, b);
  }
}
descriptor_pb.UninterpretedOption = UninterpretedOption;
UninterpretedOption.runtime = proto2_js_1$2.proto2;
UninterpretedOption.typeName = "google.protobuf.UninterpretedOption";
UninterpretedOption.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 2, name: "name", kind: "message", T: UninterpretedOption_NamePart, repeated: true },
  { no: 3, name: "identifier_value", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "positive_int_value", kind: "scalar", T: 4, opt: true },
  { no: 5, name: "negative_int_value", kind: "scalar", T: 3, opt: true },
  { no: 6, name: "double_value", kind: "scalar", T: 1, opt: true },
  { no: 7, name: "string_value", kind: "scalar", T: 12, opt: true },
  { no: 8, name: "aggregate_value", kind: "scalar", T: 9, opt: true }
]);
class UninterpretedOption_NamePart extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new UninterpretedOption_NamePart().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new UninterpretedOption_NamePart().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new UninterpretedOption_NamePart().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(UninterpretedOption_NamePart, a, b);
  }
}
descriptor_pb.UninterpretedOption_NamePart = UninterpretedOption_NamePart;
UninterpretedOption_NamePart.runtime = proto2_js_1$2.proto2;
UninterpretedOption_NamePart.typeName = "google.protobuf.UninterpretedOption.NamePart";
UninterpretedOption_NamePart.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "name_part", kind: "scalar", T: 9, req: true },
  { no: 2, name: "is_extension", kind: "scalar", T: 8, req: true }
]);
class FeatureSet extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new FeatureSet().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FeatureSet().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FeatureSet().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(FeatureSet, a, b);
  }
}
descriptor_pb.FeatureSet = FeatureSet;
FeatureSet.runtime = proto2_js_1$2.proto2;
FeatureSet.typeName = "google.protobuf.FeatureSet";
FeatureSet.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "field_presence", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FeatureSet_FieldPresence), opt: true },
  { no: 2, name: "enum_type", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FeatureSet_EnumType), opt: true },
  { no: 3, name: "repeated_field_encoding", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FeatureSet_RepeatedFieldEncoding), opt: true },
  { no: 4, name: "utf8_validation", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FeatureSet_Utf8Validation), opt: true },
  { no: 5, name: "message_encoding", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FeatureSet_MessageEncoding), opt: true },
  { no: 6, name: "json_format", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(FeatureSet_JsonFormat), opt: true }
]);
var FeatureSet_FieldPresence;
(function(FeatureSet_FieldPresence2) {
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["FIELD_PRESENCE_UNKNOWN"] = 0] = "FIELD_PRESENCE_UNKNOWN";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["EXPLICIT"] = 1] = "EXPLICIT";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["IMPLICIT"] = 2] = "IMPLICIT";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["LEGACY_REQUIRED"] = 3] = "LEGACY_REQUIRED";
})(FeatureSet_FieldPresence || (descriptor_pb.FeatureSet_FieldPresence = FeatureSet_FieldPresence = {}));
proto2_js_1$2.proto2.util.setEnumType(FeatureSet_FieldPresence, "google.protobuf.FeatureSet.FieldPresence", [
  { no: 0, name: "FIELD_PRESENCE_UNKNOWN" },
  { no: 1, name: "EXPLICIT" },
  { no: 2, name: "IMPLICIT" },
  { no: 3, name: "LEGACY_REQUIRED" }
]);
var FeatureSet_EnumType;
(function(FeatureSet_EnumType2) {
  FeatureSet_EnumType2[FeatureSet_EnumType2["ENUM_TYPE_UNKNOWN"] = 0] = "ENUM_TYPE_UNKNOWN";
  FeatureSet_EnumType2[FeatureSet_EnumType2["OPEN"] = 1] = "OPEN";
  FeatureSet_EnumType2[FeatureSet_EnumType2["CLOSED"] = 2] = "CLOSED";
})(FeatureSet_EnumType || (descriptor_pb.FeatureSet_EnumType = FeatureSet_EnumType = {}));
proto2_js_1$2.proto2.util.setEnumType(FeatureSet_EnumType, "google.protobuf.FeatureSet.EnumType", [
  { no: 0, name: "ENUM_TYPE_UNKNOWN" },
  { no: 1, name: "OPEN" },
  { no: 2, name: "CLOSED" }
]);
var FeatureSet_RepeatedFieldEncoding;
(function(FeatureSet_RepeatedFieldEncoding2) {
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["REPEATED_FIELD_ENCODING_UNKNOWN"] = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN";
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["PACKED"] = 1] = "PACKED";
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["EXPANDED"] = 2] = "EXPANDED";
})(FeatureSet_RepeatedFieldEncoding || (descriptor_pb.FeatureSet_RepeatedFieldEncoding = FeatureSet_RepeatedFieldEncoding = {}));
proto2_js_1$2.proto2.util.setEnumType(FeatureSet_RepeatedFieldEncoding, "google.protobuf.FeatureSet.RepeatedFieldEncoding", [
  { no: 0, name: "REPEATED_FIELD_ENCODING_UNKNOWN" },
  { no: 1, name: "PACKED" },
  { no: 2, name: "EXPANDED" }
]);
var FeatureSet_Utf8Validation;
(function(FeatureSet_Utf8Validation2) {
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["UTF8_VALIDATION_UNKNOWN"] = 0] = "UTF8_VALIDATION_UNKNOWN";
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["VERIFY"] = 2] = "VERIFY";
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["NONE"] = 3] = "NONE";
})(FeatureSet_Utf8Validation || (descriptor_pb.FeatureSet_Utf8Validation = FeatureSet_Utf8Validation = {}));
proto2_js_1$2.proto2.util.setEnumType(FeatureSet_Utf8Validation, "google.protobuf.FeatureSet.Utf8Validation", [
  { no: 0, name: "UTF8_VALIDATION_UNKNOWN" },
  { no: 2, name: "VERIFY" },
  { no: 3, name: "NONE" }
]);
var FeatureSet_MessageEncoding;
(function(FeatureSet_MessageEncoding2) {
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["MESSAGE_ENCODING_UNKNOWN"] = 0] = "MESSAGE_ENCODING_UNKNOWN";
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["LENGTH_PREFIXED"] = 1] = "LENGTH_PREFIXED";
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["DELIMITED"] = 2] = "DELIMITED";
})(FeatureSet_MessageEncoding || (descriptor_pb.FeatureSet_MessageEncoding = FeatureSet_MessageEncoding = {}));
proto2_js_1$2.proto2.util.setEnumType(FeatureSet_MessageEncoding, "google.protobuf.FeatureSet.MessageEncoding", [
  { no: 0, name: "MESSAGE_ENCODING_UNKNOWN" },
  { no: 1, name: "LENGTH_PREFIXED" },
  { no: 2, name: "DELIMITED" }
]);
var FeatureSet_JsonFormat;
(function(FeatureSet_JsonFormat2) {
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["JSON_FORMAT_UNKNOWN"] = 0] = "JSON_FORMAT_UNKNOWN";
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["ALLOW"] = 1] = "ALLOW";
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["LEGACY_BEST_EFFORT"] = 2] = "LEGACY_BEST_EFFORT";
})(FeatureSet_JsonFormat || (descriptor_pb.FeatureSet_JsonFormat = FeatureSet_JsonFormat = {}));
proto2_js_1$2.proto2.util.setEnumType(FeatureSet_JsonFormat, "google.protobuf.FeatureSet.JsonFormat", [
  { no: 0, name: "JSON_FORMAT_UNKNOWN" },
  { no: 1, name: "ALLOW" },
  { no: 2, name: "LEGACY_BEST_EFFORT" }
]);
class FeatureSetDefaults extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.defaults = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new FeatureSetDefaults().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FeatureSetDefaults().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FeatureSetDefaults().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(FeatureSetDefaults, a, b);
  }
}
descriptor_pb.FeatureSetDefaults = FeatureSetDefaults;
FeatureSetDefaults.runtime = proto2_js_1$2.proto2;
FeatureSetDefaults.typeName = "google.protobuf.FeatureSetDefaults";
FeatureSetDefaults.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "defaults", kind: "message", T: FeatureSetDefaults_FeatureSetEditionDefault, repeated: true },
  { no: 4, name: "minimum_edition", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(Edition), opt: true },
  { no: 5, name: "maximum_edition", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(Edition), opt: true }
]);
class FeatureSetDefaults_FeatureSetEditionDefault extends message_js_1$b.Message {
  constructor(data) {
    super();
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new FeatureSetDefaults_FeatureSetEditionDefault().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FeatureSetDefaults_FeatureSetEditionDefault().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FeatureSetDefaults_FeatureSetEditionDefault().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(FeatureSetDefaults_FeatureSetEditionDefault, a, b);
  }
}
descriptor_pb.FeatureSetDefaults_FeatureSetEditionDefault = FeatureSetDefaults_FeatureSetEditionDefault;
FeatureSetDefaults_FeatureSetEditionDefault.runtime = proto2_js_1$2.proto2;
FeatureSetDefaults_FeatureSetEditionDefault.typeName = "google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault";
FeatureSetDefaults_FeatureSetEditionDefault.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 3, name: "edition", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(Edition), opt: true },
  { no: 4, name: "overridable_features", kind: "message", T: FeatureSet, opt: true },
  { no: 5, name: "fixed_features", kind: "message", T: FeatureSet, opt: true }
]);
class SourceCodeInfo extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.location = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new SourceCodeInfo().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new SourceCodeInfo().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new SourceCodeInfo().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(SourceCodeInfo, a, b);
  }
}
descriptor_pb.SourceCodeInfo = SourceCodeInfo;
SourceCodeInfo.runtime = proto2_js_1$2.proto2;
SourceCodeInfo.typeName = "google.protobuf.SourceCodeInfo";
SourceCodeInfo.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "location", kind: "message", T: SourceCodeInfo_Location, repeated: true }
]);
class SourceCodeInfo_Location extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.path = [];
    this.span = [];
    this.leadingDetachedComments = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new SourceCodeInfo_Location().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new SourceCodeInfo_Location().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new SourceCodeInfo_Location().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(SourceCodeInfo_Location, a, b);
  }
}
descriptor_pb.SourceCodeInfo_Location = SourceCodeInfo_Location;
SourceCodeInfo_Location.runtime = proto2_js_1$2.proto2;
SourceCodeInfo_Location.typeName = "google.protobuf.SourceCodeInfo.Location";
SourceCodeInfo_Location.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 2, name: "span", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 3, name: "leading_comments", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "trailing_comments", kind: "scalar", T: 9, opt: true },
  { no: 6, name: "leading_detached_comments", kind: "scalar", T: 9, repeated: true }
]);
class GeneratedCodeInfo extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.annotation = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new GeneratedCodeInfo().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new GeneratedCodeInfo().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new GeneratedCodeInfo().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(GeneratedCodeInfo, a, b);
  }
}
descriptor_pb.GeneratedCodeInfo = GeneratedCodeInfo;
GeneratedCodeInfo.runtime = proto2_js_1$2.proto2;
GeneratedCodeInfo.typeName = "google.protobuf.GeneratedCodeInfo";
GeneratedCodeInfo.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "annotation", kind: "message", T: GeneratedCodeInfo_Annotation, repeated: true }
]);
class GeneratedCodeInfo_Annotation extends message_js_1$b.Message {
  constructor(data) {
    super();
    this.path = [];
    proto2_js_1$2.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new GeneratedCodeInfo_Annotation().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new GeneratedCodeInfo_Annotation().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new GeneratedCodeInfo_Annotation().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1$2.proto2.util.equals(GeneratedCodeInfo_Annotation, a, b);
  }
}
descriptor_pb.GeneratedCodeInfo_Annotation = GeneratedCodeInfo_Annotation;
GeneratedCodeInfo_Annotation.runtime = proto2_js_1$2.proto2;
GeneratedCodeInfo_Annotation.typeName = "google.protobuf.GeneratedCodeInfo.Annotation";
GeneratedCodeInfo_Annotation.fields = proto2_js_1$2.proto2.util.newFieldList(() => [
  { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 2, name: "source_file", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "begin", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "end", kind: "scalar", T: 5, opt: true },
  { no: 5, name: "semantic", kind: "enum", T: proto2_js_1$2.proto2.getEnumType(GeneratedCodeInfo_Annotation_Semantic), opt: true }
]);
var GeneratedCodeInfo_Annotation_Semantic;
(function(GeneratedCodeInfo_Annotation_Semantic2) {
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["NONE"] = 0] = "NONE";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["SET"] = 1] = "SET";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["ALIAS"] = 2] = "ALIAS";
})(GeneratedCodeInfo_Annotation_Semantic || (descriptor_pb.GeneratedCodeInfo_Annotation_Semantic = GeneratedCodeInfo_Annotation_Semantic = {}));
proto2_js_1$2.proto2.util.setEnumType(GeneratedCodeInfo_Annotation_Semantic, "google.protobuf.GeneratedCodeInfo.Annotation.Semantic", [
  { no: 0, name: "NONE" },
  { no: 1, name: "SET" },
  { no: 2, name: "ALIAS" }
]);
var textFormat = {};
Object.defineProperty(textFormat, "__esModule", { value: true });
textFormat.parseTextFormatScalarValue = textFormat.parseTextFormatEnumValue = void 0;
const assert_js_1$2 = assert$4;
const proto_int64_js_1$3 = protoInt64;
const scalar_js_1$2 = scalar;
function parseTextFormatEnumValue(descEnum, value) {
  const enumValue = descEnum.values.find((v) => v.name === value);
  (0, assert_js_1$2.assert)(enumValue, `cannot parse ${descEnum.name} default value: ${value}`);
  return enumValue.number;
}
textFormat.parseTextFormatEnumValue = parseTextFormatEnumValue;
function parseTextFormatScalarValue(type, value) {
  switch (type) {
    case scalar_js_1$2.ScalarType.STRING:
      return value;
    case scalar_js_1$2.ScalarType.BYTES: {
      const u = unescapeBytesDefaultValue(value);
      if (u === false) {
        throw new Error(`cannot parse ${scalar_js_1$2.ScalarType[type]} default value: ${value}`);
      }
      return u;
    }
    case scalar_js_1$2.ScalarType.INT64:
    case scalar_js_1$2.ScalarType.SFIXED64:
    case scalar_js_1$2.ScalarType.SINT64:
      return proto_int64_js_1$3.protoInt64.parse(value);
    case scalar_js_1$2.ScalarType.UINT64:
    case scalar_js_1$2.ScalarType.FIXED64:
      return proto_int64_js_1$3.protoInt64.uParse(value);
    case scalar_js_1$2.ScalarType.DOUBLE:
    case scalar_js_1$2.ScalarType.FLOAT:
      switch (value) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(value);
      }
    case scalar_js_1$2.ScalarType.BOOL:
      return value === "true";
    case scalar_js_1$2.ScalarType.INT32:
    case scalar_js_1$2.ScalarType.UINT32:
    case scalar_js_1$2.ScalarType.SINT32:
    case scalar_js_1$2.ScalarType.FIXED32:
    case scalar_js_1$2.ScalarType.SFIXED32:
      return parseInt(value, 10);
  }
}
textFormat.parseTextFormatScalarValue = parseTextFormatScalarValue;
function unescapeBytesDefaultValue(str) {
  const b = [];
  const input = {
    tail: str,
    c: "",
    next() {
      if (this.tail.length == 0) {
        return false;
      }
      this.c = this.tail[0];
      this.tail = this.tail.substring(1);
      return true;
    },
    take(n) {
      if (this.tail.length >= n) {
        const r = this.tail.substring(0, n);
        this.tail = this.tail.substring(n);
        return r;
      }
      return false;
    }
  };
  while (input.next()) {
    switch (input.c) {
      case "\\":
        if (input.next()) {
          switch (input.c) {
            case "\\":
              b.push(input.c.charCodeAt(0));
              break;
            case "b":
              b.push(8);
              break;
            case "f":
              b.push(12);
              break;
            case "n":
              b.push(10);
              break;
            case "r":
              b.push(13);
              break;
            case "t":
              b.push(9);
              break;
            case "v":
              b.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const s = input.c;
              const t = input.take(2);
              if (t === false) {
                return false;
              }
              const n = parseInt(s + t, 8);
              if (isNaN(n)) {
                return false;
              }
              b.push(n);
              break;
            }
            case "x": {
              const s = input.c;
              const t = input.take(2);
              if (t === false) {
                return false;
              }
              const n = parseInt(s + t, 16);
              if (isNaN(n)) {
                return false;
              }
              b.push(n);
              break;
            }
            case "u": {
              const s = input.c;
              const t = input.take(4);
              if (t === false) {
                return false;
              }
              const n = parseInt(s + t, 16);
              if (isNaN(n)) {
                return false;
              }
              const chunk = new Uint8Array(4);
              const view = new DataView(chunk.buffer);
              view.setInt32(0, n, true);
              b.push(chunk[0], chunk[1], chunk[2], chunk[3]);
              break;
            }
            case "U": {
              const s = input.c;
              const t = input.take(8);
              if (t === false) {
                return false;
              }
              const tc = proto_int64_js_1$3.protoInt64.uEnc(s + t);
              const chunk = new Uint8Array(8);
              const view = new DataView(chunk.buffer);
              view.setInt32(0, tc.lo, true);
              view.setInt32(4, tc.hi, true);
              b.push(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4], chunk[5], chunk[6], chunk[7]);
              break;
            }
          }
        }
        break;
      default:
        b.push(input.c.charCodeAt(0));
    }
  }
  return new Uint8Array(b);
}
var featureSet = {};
Object.defineProperty(featureSet, "__esModule", { value: true });
featureSet.createFeatureResolver = void 0;
const descriptor_pb_js_1$3 = descriptor_pb;
const proto_base64_js_1 = protoBase64;
function getFeatureSetDefaults(options) {
  return descriptor_pb_js_1$3.FeatureSetDefaults.fromBinary(proto_base64_js_1.protoBase64.dec(
    /*upstream-inject-feature-defaults-start*/
    "ChMY5gciACoMCAEQAhgCIAMoATACChMY5wciACoMCAIQARgBIAIoATABChMY6AciDAgBEAEYASACKAEwASoAIOYHKOgH"
    /*upstream-inject-feature-defaults-end*/
  ), options);
}
function createFeatureResolver(edition, compiledFeatureSetDefaults, serializationOptions) {
  var _a;
  const fds = compiledFeatureSetDefaults !== null && compiledFeatureSetDefaults !== void 0 ? compiledFeatureSetDefaults : getFeatureSetDefaults(serializationOptions);
  const min = fds.minimumEdition;
  const max = fds.maximumEdition;
  if (min === void 0 || max === void 0 || fds.defaults.some((d) => d.edition === void 0)) {
    throw new Error("Invalid FeatureSetDefaults");
  }
  if (edition < min) {
    throw new Error(`Edition ${descriptor_pb_js_1$3.Edition[edition]} is earlier than the minimum supported edition ${descriptor_pb_js_1$3.Edition[min]}`);
  }
  if (max < edition) {
    throw new Error(`Edition ${descriptor_pb_js_1$3.Edition[edition]} is later than the maximum supported edition ${descriptor_pb_js_1$3.Edition[max]}`);
  }
  let highestMatch = void 0;
  for (const c of fds.defaults) {
    const e = (_a = c.edition) !== null && _a !== void 0 ? _a : 0;
    if (e > edition) {
      continue;
    }
    if (highestMatch !== void 0 && highestMatch.e > e) {
      continue;
    }
    let f2;
    if (c.fixedFeatures && c.overridableFeatures) {
      f2 = c.fixedFeatures;
      f2.fromBinary(c.overridableFeatures.toBinary());
    } else if (c.fixedFeatures) {
      f2 = c.fixedFeatures;
    } else if (c.overridableFeatures) {
      f2 = c.overridableFeatures;
    } else {
      f2 = new descriptor_pb_js_1$3.FeatureSet();
    }
    highestMatch = {
      e,
      f: f2
    };
  }
  if (highestMatch === void 0) {
    throw new Error(`No valid default found for edition ${descriptor_pb_js_1$3.Edition[edition]}`);
  }
  const featureSetBin = highestMatch.f.toBinary(serializationOptions);
  return (...rest) => {
    const f2 = descriptor_pb_js_1$3.FeatureSet.fromBinary(featureSetBin, serializationOptions);
    for (const c of rest) {
      if (c !== void 0) {
        f2.fromBinary(c.toBinary(serializationOptions), serializationOptions);
      }
    }
    if (!validateMergedFeatures(f2)) {
      throw new Error(`Invalid FeatureSet for edition ${descriptor_pb_js_1$3.Edition[edition]}`);
    }
    return f2;
  };
}
featureSet.createFeatureResolver = createFeatureResolver;
function validateMergedFeatures(featureSet2) {
  for (const fi of descriptor_pb_js_1$3.FeatureSet.fields.list()) {
    const v = featureSet2[fi.localName];
    if (v === void 0) {
      return false;
    }
    if (fi.kind == "enum" && v === 0) {
      return false;
    }
  }
  return true;
}
Object.defineProperty(createDescriptorSet$1, "__esModule", { value: true });
createDescriptorSet$1.createDescriptorSet = void 0;
const descriptor_pb_js_1$2 = descriptor_pb;
const assert_js_1$1 = assert$4;
const service_type_js_1 = serviceType;
const names_js_1$1 = names;
const text_format_js_1 = textFormat;
const feature_set_js_1 = featureSet;
const scalar_js_1$1 = scalar;
const is_message_js_1$2 = isMessage$1;
function createDescriptorSet(input, options) {
  var _a;
  const cart = {
    files: [],
    enums: /* @__PURE__ */ new Map(),
    messages: /* @__PURE__ */ new Map(),
    services: /* @__PURE__ */ new Map(),
    extensions: /* @__PURE__ */ new Map(),
    mapEntries: /* @__PURE__ */ new Map()
  };
  const fileDescriptors = (0, is_message_js_1$2.isMessage)(input, descriptor_pb_js_1$2.FileDescriptorSet) ? input.file : input instanceof Uint8Array ? descriptor_pb_js_1$2.FileDescriptorSet.fromBinary(input).file : input;
  const resolverByEdition = /* @__PURE__ */ new Map();
  for (const proto of fileDescriptors) {
    const edition = (_a = proto.edition) !== null && _a !== void 0 ? _a : parseFileSyntax(proto.syntax, proto.edition).edition;
    let resolveFeatures = resolverByEdition.get(edition);
    if (resolveFeatures === void 0) {
      resolveFeatures = (0, feature_set_js_1.createFeatureResolver)(edition, options === null || options === void 0 ? void 0 : options.featureSetDefaults, options === null || options === void 0 ? void 0 : options.serializationOptions);
      resolverByEdition.set(edition, resolveFeatures);
    }
    addFile(proto, cart, resolveFeatures);
  }
  return cart;
}
createDescriptorSet$1.createDescriptorSet = createDescriptorSet;
function addFile(proto, cart, resolveFeatures) {
  var _a, _b;
  (0, assert_js_1$1.assert)(proto.name, `invalid FileDescriptorProto: missing name`);
  const file = Object.assign(Object.assign({ kind: "file", proto, deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false }, parseFileSyntax(proto.syntax, proto.edition)), {
    name: proto.name.replace(/\.proto/, ""),
    dependencies: findFileDependencies(proto, cart),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${this.proto.name}`;
    },
    getSyntaxComments() {
      return findComments(this.proto.sourceCodeInfo, [
        FieldNumber.FileDescriptorProto_Syntax
      ]);
    },
    getPackageComments() {
      return findComments(this.proto.sourceCodeInfo, [
        FieldNumber.FileDescriptorProto_Package
      ]);
    },
    getFeatures() {
      var _a2;
      return resolveFeatures((_a2 = proto.options) === null || _a2 === void 0 ? void 0 : _a2.features);
    }
  });
  cart.mapEntries.clear();
  for (const enumProto of proto.enumType) {
    addEnum(enumProto, file, void 0, cart, resolveFeatures);
  }
  for (const messageProto of proto.messageType) {
    addMessage(messageProto, file, void 0, cart, resolveFeatures);
  }
  for (const serviceProto of proto.service) {
    addService(serviceProto, file, cart, resolveFeatures);
  }
  addExtensions(file, cart, resolveFeatures);
  for (const mapEntry of cart.mapEntries.values()) {
    addFields(mapEntry, cart, resolveFeatures);
  }
  for (const message2 of file.messages) {
    addFields(message2, cart, resolveFeatures);
    addExtensions(message2, cart, resolveFeatures);
  }
  cart.mapEntries.clear();
  cart.files.push(file);
}
function addExtensions(desc, cart, resolveFeatures) {
  switch (desc.kind) {
    case "file":
      for (const proto of desc.proto.extension) {
        const ext = newExtension(proto, desc, void 0, cart, resolveFeatures);
        desc.extensions.push(ext);
        cart.extensions.set(ext.typeName, ext);
      }
      break;
    case "message":
      for (const proto of desc.proto.extension) {
        const ext = newExtension(proto, desc.file, desc, cart, resolveFeatures);
        desc.nestedExtensions.push(ext);
        cart.extensions.set(ext.typeName, ext);
      }
      for (const message2 of desc.nestedMessages) {
        addExtensions(message2, cart, resolveFeatures);
      }
      break;
  }
}
function addFields(message2, cart, resolveFeatures) {
  const allOneofs = message2.proto.oneofDecl.map((proto) => newOneof(proto, message2, resolveFeatures));
  const oneofsSeen = /* @__PURE__ */ new Set();
  for (const proto of message2.proto.field) {
    const oneof = findOneof(proto, allOneofs);
    const field2 = newField(proto, message2.file, message2, oneof, cart, resolveFeatures);
    message2.fields.push(field2);
    if (oneof === void 0) {
      message2.members.push(field2);
    } else {
      oneof.fields.push(field2);
      if (!oneofsSeen.has(oneof)) {
        oneofsSeen.add(oneof);
        message2.members.push(oneof);
      }
    }
  }
  for (const oneof of allOneofs.filter((o) => oneofsSeen.has(o))) {
    message2.oneofs.push(oneof);
  }
  for (const child of message2.nestedMessages) {
    addFields(child, cart, resolveFeatures);
  }
}
function addEnum(proto, file, parent, cart, resolveFeatures) {
  var _a, _b, _c;
  (0, assert_js_1$1.assert)(proto.name, `invalid EnumDescriptorProto: missing name`);
  const desc = {
    kind: "enum",
    proto,
    deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
    file,
    parent,
    name: proto.name,
    typeName: makeTypeName(proto, parent, file),
    values: [],
    sharedPrefix: (0, names_js_1$1.findEnumSharedPrefix)(proto.name, proto.value.map((v) => {
      var _a2;
      return (_a2 = v.name) !== null && _a2 !== void 0 ? _a2 : "";
    })),
    toString() {
      return `enum ${this.typeName}`;
    },
    getComments() {
      const path = this.parent ? [
        ...this.parent.getComments().sourcePath,
        FieldNumber.DescriptorProto_EnumType,
        this.parent.proto.enumType.indexOf(this.proto)
      ] : [
        FieldNumber.FileDescriptorProto_EnumType,
        this.file.proto.enumType.indexOf(this.proto)
      ];
      return findComments(file.proto.sourceCodeInfo, path);
    },
    getFeatures() {
      var _a2, _b2;
      return resolveFeatures((_a2 = parent === null || parent === void 0 ? void 0 : parent.getFeatures()) !== null && _a2 !== void 0 ? _a2 : file.getFeatures(), (_b2 = proto.options) === null || _b2 === void 0 ? void 0 : _b2.features);
    }
  };
  cart.enums.set(desc.typeName, desc);
  proto.value.forEach((proto4) => {
    var _a2, _b2;
    (0, assert_js_1$1.assert)(proto4.name, `invalid EnumValueDescriptorProto: missing name`);
    (0, assert_js_1$1.assert)(proto4.number !== void 0, `invalid EnumValueDescriptorProto: missing number`);
    desc.values.push({
      kind: "enum_value",
      proto: proto4,
      deprecated: (_b2 = (_a2 = proto4.options) === null || _a2 === void 0 ? void 0 : _a2.deprecated) !== null && _b2 !== void 0 ? _b2 : false,
      parent: desc,
      name: proto4.name,
      number: proto4.number,
      toString() {
        return `enum value ${desc.typeName}.${this.name}`;
      },
      declarationString() {
        var _a3;
        let str = `${this.name} = ${this.number}`;
        if (((_a3 = this.proto.options) === null || _a3 === void 0 ? void 0 : _a3.deprecated) === true) {
          str += " [deprecated = true]";
        }
        return str;
      },
      getComments() {
        const path = [
          ...this.parent.getComments().sourcePath,
          FieldNumber.EnumDescriptorProto_Value,
          this.parent.proto.value.indexOf(this.proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      },
      getFeatures() {
        var _a3;
        return resolveFeatures(desc.getFeatures(), (_a3 = proto4.options) === null || _a3 === void 0 ? void 0 : _a3.features);
      }
    });
  });
  ((_c = parent === null || parent === void 0 ? void 0 : parent.nestedEnums) !== null && _c !== void 0 ? _c : file.enums).push(desc);
}
function addMessage(proto, file, parent, cart, resolveFeatures) {
  var _a, _b, _c, _d;
  (0, assert_js_1$1.assert)(proto.name, `invalid DescriptorProto: missing name`);
  const desc = {
    kind: "message",
    proto,
    deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
    file,
    parent,
    name: proto.name,
    typeName: makeTypeName(proto, parent, file),
    fields: [],
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    },
    getComments() {
      const path = this.parent ? [
        ...this.parent.getComments().sourcePath,
        FieldNumber.DescriptorProto_NestedType,
        this.parent.proto.nestedType.indexOf(this.proto)
      ] : [
        FieldNumber.FileDescriptorProto_MessageType,
        this.file.proto.messageType.indexOf(this.proto)
      ];
      return findComments(file.proto.sourceCodeInfo, path);
    },
    getFeatures() {
      var _a2, _b2;
      return resolveFeatures((_a2 = parent === null || parent === void 0 ? void 0 : parent.getFeatures()) !== null && _a2 !== void 0 ? _a2 : file.getFeatures(), (_b2 = proto.options) === null || _b2 === void 0 ? void 0 : _b2.features);
    }
  };
  if (((_c = proto.options) === null || _c === void 0 ? void 0 : _c.mapEntry) === true) {
    cart.mapEntries.set(desc.typeName, desc);
  } else {
    ((_d = parent === null || parent === void 0 ? void 0 : parent.nestedMessages) !== null && _d !== void 0 ? _d : file.messages).push(desc);
    cart.messages.set(desc.typeName, desc);
  }
  for (const enumProto of proto.enumType) {
    addEnum(enumProto, file, desc, cart, resolveFeatures);
  }
  for (const messageProto of proto.nestedType) {
    addMessage(messageProto, file, desc, cart, resolveFeatures);
  }
}
function addService(proto, file, cart, resolveFeatures) {
  var _a, _b;
  (0, assert_js_1$1.assert)(proto.name, `invalid ServiceDescriptorProto: missing name`);
  const desc = {
    kind: "service",
    proto,
    deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
    file,
    name: proto.name,
    typeName: makeTypeName(proto, void 0, file),
    methods: [],
    toString() {
      return `service ${this.typeName}`;
    },
    getComments() {
      const path = [
        FieldNumber.FileDescriptorProto_Service,
        this.file.proto.service.indexOf(this.proto)
      ];
      return findComments(file.proto.sourceCodeInfo, path);
    },
    getFeatures() {
      var _a2;
      return resolveFeatures(file.getFeatures(), (_a2 = proto.options) === null || _a2 === void 0 ? void 0 : _a2.features);
    }
  };
  file.services.push(desc);
  cart.services.set(desc.typeName, desc);
  for (const methodProto of proto.method) {
    desc.methods.push(newMethod(methodProto, desc, cart, resolveFeatures));
  }
}
function newMethod(proto, parent, cart, resolveFeatures) {
  var _a, _b, _c;
  (0, assert_js_1$1.assert)(proto.name, `invalid MethodDescriptorProto: missing name`);
  (0, assert_js_1$1.assert)(proto.inputType, `invalid MethodDescriptorProto: missing input_type`);
  (0, assert_js_1$1.assert)(proto.outputType, `invalid MethodDescriptorProto: missing output_type`);
  let methodKind;
  if (proto.clientStreaming === true && proto.serverStreaming === true) {
    methodKind = service_type_js_1.MethodKind.BiDiStreaming;
  } else if (proto.clientStreaming === true) {
    methodKind = service_type_js_1.MethodKind.ClientStreaming;
  } else if (proto.serverStreaming === true) {
    methodKind = service_type_js_1.MethodKind.ServerStreaming;
  } else {
    methodKind = service_type_js_1.MethodKind.Unary;
  }
  let idempotency;
  switch ((_a = proto.options) === null || _a === void 0 ? void 0 : _a.idempotencyLevel) {
    case descriptor_pb_js_1$2.MethodOptions_IdempotencyLevel.IDEMPOTENT:
      idempotency = service_type_js_1.MethodIdempotency.Idempotent;
      break;
    case descriptor_pb_js_1$2.MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS:
      idempotency = service_type_js_1.MethodIdempotency.NoSideEffects;
      break;
    case descriptor_pb_js_1$2.MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN:
    case void 0:
      idempotency = void 0;
      break;
  }
  const input = cart.messages.get(trimLeadingDot(proto.inputType));
  const output2 = cart.messages.get(trimLeadingDot(proto.outputType));
  (0, assert_js_1$1.assert)(input, `invalid MethodDescriptorProto: input_type ${proto.inputType} not found`);
  (0, assert_js_1$1.assert)(output2, `invalid MethodDescriptorProto: output_type ${proto.inputType} not found`);
  const name2 = proto.name;
  return {
    kind: "rpc",
    proto,
    deprecated: (_c = (_b = proto.options) === null || _b === void 0 ? void 0 : _b.deprecated) !== null && _c !== void 0 ? _c : false,
    parent,
    name: name2,
    methodKind,
    input,
    output: output2,
    idempotency,
    toString() {
      return `rpc ${parent.typeName}.${name2}`;
    },
    getComments() {
      const path = [
        ...this.parent.getComments().sourcePath,
        FieldNumber.ServiceDescriptorProto_Method,
        this.parent.proto.method.indexOf(this.proto)
      ];
      return findComments(parent.file.proto.sourceCodeInfo, path);
    },
    getFeatures() {
      var _a2;
      return resolveFeatures(parent.getFeatures(), (_a2 = proto.options) === null || _a2 === void 0 ? void 0 : _a2.features);
    }
  };
}
function newOneof(proto, parent, resolveFeatures) {
  (0, assert_js_1$1.assert)(proto.name, `invalid OneofDescriptorProto: missing name`);
  return {
    kind: "oneof",
    proto,
    deprecated: false,
    parent,
    fields: [],
    name: proto.name,
    toString() {
      return `oneof ${parent.typeName}.${this.name}`;
    },
    getComments() {
      const path = [
        ...this.parent.getComments().sourcePath,
        FieldNumber.DescriptorProto_OneofDecl,
        this.parent.proto.oneofDecl.indexOf(this.proto)
      ];
      return findComments(parent.file.proto.sourceCodeInfo, path);
    },
    getFeatures() {
      var _a;
      return resolveFeatures(parent.getFeatures(), (_a = proto.options) === null || _a === void 0 ? void 0 : _a.features);
    }
  };
}
function newField(proto, file, parent, oneof, cart, resolveFeatures) {
  var _a, _b, _c;
  (0, assert_js_1$1.assert)(proto.name, `invalid FieldDescriptorProto: missing name`);
  (0, assert_js_1$1.assert)(proto.number, `invalid FieldDescriptorProto: missing number`);
  (0, assert_js_1$1.assert)(proto.type, `invalid FieldDescriptorProto: missing type`);
  const common2 = {
    proto,
    deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
    name: proto.name,
    number: proto.number,
    parent,
    oneof,
    optional: isOptionalField(proto, file.syntax),
    packedByDefault: isPackedFieldByDefault(proto, resolveFeatures),
    packed: isPackedField(file, parent, proto, resolveFeatures),
    jsonName: proto.jsonName === (0, names_js_1$1.fieldJsonName)(proto.name) ? void 0 : proto.jsonName,
    scalar: void 0,
    longType: void 0,
    message: void 0,
    enum: void 0,
    mapKey: void 0,
    mapValue: void 0,
    declarationString,
    // toString, getComments, getFeatures are overridden in newExtension
    toString() {
      return `field ${this.parent.typeName}.${this.name}`;
    },
    getComments() {
      const path = [
        ...this.parent.getComments().sourcePath,
        FieldNumber.DescriptorProto_Field,
        this.parent.proto.field.indexOf(this.proto)
      ];
      return findComments(file.proto.sourceCodeInfo, path);
    },
    getFeatures() {
      var _a2;
      return resolveFeatures(parent.getFeatures(), (_a2 = proto.options) === null || _a2 === void 0 ? void 0 : _a2.features);
    }
  };
  const repeated = proto.label === descriptor_pb_js_1$2.FieldDescriptorProto_Label.REPEATED;
  switch (proto.type) {
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.MESSAGE:
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.GROUP: {
      (0, assert_js_1$1.assert)(proto.typeName, `invalid FieldDescriptorProto: missing type_name`);
      const mapEntry = cart.mapEntries.get(trimLeadingDot(proto.typeName));
      if (mapEntry !== void 0) {
        (0, assert_js_1$1.assert)(repeated, `invalid FieldDescriptorProto: expected map entry to be repeated`);
        return Object.assign(Object.assign(Object.assign({}, common2), { kind: "field", fieldKind: "map", repeated: false }), getMapFieldTypes(mapEntry));
      }
      const message2 = cart.messages.get(trimLeadingDot(proto.typeName));
      (0, assert_js_1$1.assert)(message2 !== void 0, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);
      return Object.assign(Object.assign({}, common2), {
        kind: "field",
        fieldKind: "message",
        repeated,
        message: message2
      });
    }
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.ENUM: {
      (0, assert_js_1$1.assert)(proto.typeName, `invalid FieldDescriptorProto: missing type_name`);
      const e = cart.enums.get(trimLeadingDot(proto.typeName));
      (0, assert_js_1$1.assert)(e !== void 0, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);
      return Object.assign(Object.assign({}, common2), {
        kind: "field",
        fieldKind: "enum",
        getDefaultValue,
        repeated,
        enum: e
      });
    }
    default: {
      const scalar2 = fieldTypeToScalarType[proto.type];
      (0, assert_js_1$1.assert)(scalar2, `invalid FieldDescriptorProto: unknown type ${proto.type}`);
      return Object.assign(Object.assign({}, common2), {
        kind: "field",
        fieldKind: "scalar",
        getDefaultValue,
        repeated,
        scalar: scalar2,
        longType: ((_c = proto.options) === null || _c === void 0 ? void 0 : _c.jstype) == descriptor_pb_js_1$2.FieldOptions_JSType.JS_STRING ? scalar_js_1$1.LongType.STRING : scalar_js_1$1.LongType.BIGINT
      });
    }
  }
}
function newExtension(proto, file, parent, cart, resolveFeatures) {
  (0, assert_js_1$1.assert)(proto.extendee, `invalid FieldDescriptorProto: missing extendee`);
  const field2 = newField(
    proto,
    file,
    null,
    // to safe us many lines of duplicated code, we trick the type system
    void 0,
    cart,
    resolveFeatures
  );
  const extendee = cart.messages.get(trimLeadingDot(proto.extendee));
  (0, assert_js_1$1.assert)(extendee, `invalid FieldDescriptorProto: extendee ${proto.extendee} not found`);
  return Object.assign(Object.assign({}, field2), {
    kind: "extension",
    typeName: makeTypeName(proto, parent, file),
    parent,
    file,
    extendee,
    // Must override toString, getComments, getFeatures from newField, because we
    // call newField with parent undefined.
    toString() {
      return `extension ${this.typeName}`;
    },
    getComments() {
      const path = this.parent ? [
        ...this.parent.getComments().sourcePath,
        FieldNumber.DescriptorProto_Extension,
        this.parent.proto.extension.indexOf(proto)
      ] : [
        FieldNumber.FileDescriptorProto_Extension,
        this.file.proto.extension.indexOf(proto)
      ];
      return findComments(file.proto.sourceCodeInfo, path);
    },
    getFeatures() {
      var _a;
      return resolveFeatures((parent !== null && parent !== void 0 ? parent : file).getFeatures(), (_a = proto.options) === null || _a === void 0 ? void 0 : _a.features);
    }
  });
}
function parseFileSyntax(syntax, edition) {
  let e;
  let s;
  switch (syntax) {
    case void 0:
    case "proto2":
      s = "proto2";
      e = descriptor_pb_js_1$2.Edition.EDITION_PROTO2;
      break;
    case "proto3":
      s = "proto3";
      e = descriptor_pb_js_1$2.Edition.EDITION_PROTO3;
      break;
    case "editions":
      s = "editions";
      switch (edition) {
        case void 0:
        case descriptor_pb_js_1$2.Edition.EDITION_1_TEST_ONLY:
        case descriptor_pb_js_1$2.Edition.EDITION_2_TEST_ONLY:
        case descriptor_pb_js_1$2.Edition.EDITION_99997_TEST_ONLY:
        case descriptor_pb_js_1$2.Edition.EDITION_99998_TEST_ONLY:
        case descriptor_pb_js_1$2.Edition.EDITION_99999_TEST_ONLY:
        case descriptor_pb_js_1$2.Edition.EDITION_UNKNOWN:
          e = descriptor_pb_js_1$2.Edition.EDITION_UNKNOWN;
          break;
        default:
          e = edition;
          break;
      }
      break;
    default:
      throw new Error(`invalid FileDescriptorProto: unsupported syntax: ${syntax}`);
  }
  if (syntax === "editions" && edition === descriptor_pb_js_1$2.Edition.EDITION_UNKNOWN) {
    throw new Error(`invalid FileDescriptorProto: syntax ${syntax} cannot have edition ${String(edition)}`);
  }
  return {
    syntax: s,
    edition: e
  };
}
function findFileDependencies(proto, cart) {
  return proto.dependency.map((wantName) => {
    const dep = cart.files.find((f2) => f2.proto.name === wantName);
    (0, assert_js_1$1.assert)(dep);
    return dep;
  });
}
function makeTypeName(proto, parent, file) {
  (0, assert_js_1$1.assert)(proto.name, `invalid ${proto.getType().typeName}: missing name`);
  let typeName;
  if (parent) {
    typeName = `${parent.typeName}.${proto.name}`;
  } else if (file.proto.package !== void 0) {
    typeName = `${file.proto.package}.${proto.name}`;
  } else {
    typeName = `${proto.name}`;
  }
  return typeName;
}
function trimLeadingDot(typeName) {
  return typeName.startsWith(".") ? typeName.substring(1) : typeName;
}
function getMapFieldTypes(mapEntry) {
  var _a, _b;
  (0, assert_js_1$1.assert)((_a = mapEntry.proto.options) === null || _a === void 0 ? void 0 : _a.mapEntry, `invalid DescriptorProto: expected ${mapEntry.toString()} to be a map entry`);
  (0, assert_js_1$1.assert)(mapEntry.fields.length === 2, `invalid DescriptorProto: map entry ${mapEntry.toString()} has ${mapEntry.fields.length} fields`);
  const keyField = mapEntry.fields.find((f2) => f2.proto.number === 1);
  (0, assert_js_1$1.assert)(keyField, `invalid DescriptorProto: map entry ${mapEntry.toString()} is missing key field`);
  const mapKey = keyField.scalar;
  (0, assert_js_1$1.assert)(mapKey !== void 0 && mapKey !== scalar_js_1$1.ScalarType.BYTES && mapKey !== scalar_js_1$1.ScalarType.FLOAT && mapKey !== scalar_js_1$1.ScalarType.DOUBLE, `invalid DescriptorProto: map entry ${mapEntry.toString()} has unexpected key type ${(_b = keyField.proto.type) !== null && _b !== void 0 ? _b : -1}`);
  const valueField = mapEntry.fields.find((f2) => f2.proto.number === 2);
  (0, assert_js_1$1.assert)(valueField, `invalid DescriptorProto: map entry ${mapEntry.toString()} is missing value field`);
  switch (valueField.fieldKind) {
    case "scalar":
      return {
        mapKey,
        mapValue: Object.assign(Object.assign({}, valueField), { kind: "scalar" })
      };
    case "message":
      return {
        mapKey,
        mapValue: Object.assign(Object.assign({}, valueField), { kind: "message" })
      };
    case "enum":
      return {
        mapKey,
        mapValue: Object.assign(Object.assign({}, valueField), { kind: "enum" })
      };
    default:
      throw new Error("invalid DescriptorProto: unsupported map entry value field");
  }
}
function findOneof(proto, allOneofs) {
  var _a;
  const oneofIndex = proto.oneofIndex;
  if (oneofIndex === void 0) {
    return void 0;
  }
  let oneof;
  if (proto.proto3Optional !== true) {
    oneof = allOneofs[oneofIndex];
    (0, assert_js_1$1.assert)(oneof, `invalid FieldDescriptorProto: oneof #${oneofIndex} for field #${(_a = proto.number) !== null && _a !== void 0 ? _a : -1} not found`);
  }
  return oneof;
}
function isOptionalField(proto, syntax) {
  switch (syntax) {
    case "proto2":
      return proto.oneofIndex === void 0 && proto.label === descriptor_pb_js_1$2.FieldDescriptorProto_Label.OPTIONAL;
    case "proto3":
      return proto.proto3Optional === true;
    case "editions":
      return false;
  }
}
function isPackedFieldByDefault(proto, resolveFeatures) {
  const { repeatedFieldEncoding } = resolveFeatures();
  if (repeatedFieldEncoding != descriptor_pb_js_1$2.FeatureSet_RepeatedFieldEncoding.PACKED) {
    return false;
  }
  switch (proto.type) {
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.STRING:
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.BYTES:
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.GROUP:
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.MESSAGE:
      return false;
    default:
      return true;
  }
}
function isPackedField(file, parent, proto, resolveFeatures) {
  var _a, _b, _c, _d, _e, _f;
  switch (proto.type) {
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.STRING:
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.BYTES:
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.GROUP:
    case descriptor_pb_js_1$2.FieldDescriptorProto_Type.MESSAGE:
      return false;
    default:
      switch (file.edition) {
        case descriptor_pb_js_1$2.Edition.EDITION_PROTO2:
          return (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.packed) !== null && _b !== void 0 ? _b : false;
        case descriptor_pb_js_1$2.Edition.EDITION_PROTO3:
          return (_d = (_c = proto.options) === null || _c === void 0 ? void 0 : _c.packed) !== null && _d !== void 0 ? _d : true;
        default: {
          const { repeatedFieldEncoding } = resolveFeatures((_e = parent === null || parent === void 0 ? void 0 : parent.getFeatures()) !== null && _e !== void 0 ? _e : file.getFeatures(), (_f = proto.options) === null || _f === void 0 ? void 0 : _f.features);
          return repeatedFieldEncoding == descriptor_pb_js_1$2.FeatureSet_RepeatedFieldEncoding.PACKED;
        }
      }
  }
}
const fieldTypeToScalarType = {
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.DOUBLE]: scalar_js_1$1.ScalarType.DOUBLE,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.FLOAT]: scalar_js_1$1.ScalarType.FLOAT,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.INT64]: scalar_js_1$1.ScalarType.INT64,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.UINT64]: scalar_js_1$1.ScalarType.UINT64,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.INT32]: scalar_js_1$1.ScalarType.INT32,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.FIXED64]: scalar_js_1$1.ScalarType.FIXED64,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.FIXED32]: scalar_js_1$1.ScalarType.FIXED32,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.BOOL]: scalar_js_1$1.ScalarType.BOOL,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.STRING]: scalar_js_1$1.ScalarType.STRING,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.GROUP]: void 0,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.MESSAGE]: void 0,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.BYTES]: scalar_js_1$1.ScalarType.BYTES,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.UINT32]: scalar_js_1$1.ScalarType.UINT32,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.ENUM]: void 0,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.SFIXED32]: scalar_js_1$1.ScalarType.SFIXED32,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.SFIXED64]: scalar_js_1$1.ScalarType.SFIXED64,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.SINT32]: scalar_js_1$1.ScalarType.SINT32,
  [descriptor_pb_js_1$2.FieldDescriptorProto_Type.SINT64]: scalar_js_1$1.ScalarType.SINT64
};
function findComments(sourceCodeInfo, sourcePath) {
  if (!sourceCodeInfo) {
    return {
      leadingDetached: [],
      sourcePath
    };
  }
  for (const location2 of sourceCodeInfo.location) {
    if (location2.path.length !== sourcePath.length) {
      continue;
    }
    if (location2.path.some((value, index2) => sourcePath[index2] !== value)) {
      continue;
    }
    return {
      leadingDetached: location2.leadingDetachedComments,
      leading: location2.leadingComments,
      trailing: location2.trailingComments,
      sourcePath
    };
  }
  return {
    leadingDetached: [],
    sourcePath
  };
}
var FieldNumber;
(function(FieldNumber2) {
  FieldNumber2[FieldNumber2["FileDescriptorProto_Package"] = 2] = "FileDescriptorProto_Package";
  FieldNumber2[FieldNumber2["FileDescriptorProto_MessageType"] = 4] = "FileDescriptorProto_MessageType";
  FieldNumber2[FieldNumber2["FileDescriptorProto_EnumType"] = 5] = "FileDescriptorProto_EnumType";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Service"] = 6] = "FileDescriptorProto_Service";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Extension"] = 7] = "FileDescriptorProto_Extension";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Syntax"] = 12] = "FileDescriptorProto_Syntax";
  FieldNumber2[FieldNumber2["DescriptorProto_Field"] = 2] = "DescriptorProto_Field";
  FieldNumber2[FieldNumber2["DescriptorProto_NestedType"] = 3] = "DescriptorProto_NestedType";
  FieldNumber2[FieldNumber2["DescriptorProto_EnumType"] = 4] = "DescriptorProto_EnumType";
  FieldNumber2[FieldNumber2["DescriptorProto_Extension"] = 6] = "DescriptorProto_Extension";
  FieldNumber2[FieldNumber2["DescriptorProto_OneofDecl"] = 8] = "DescriptorProto_OneofDecl";
  FieldNumber2[FieldNumber2["EnumDescriptorProto_Value"] = 2] = "EnumDescriptorProto_Value";
  FieldNumber2[FieldNumber2["ServiceDescriptorProto_Method"] = 2] = "ServiceDescriptorProto_Method";
})(FieldNumber || (FieldNumber = {}));
function declarationString() {
  var _a, _b, _c;
  const parts = [];
  if (this.repeated) {
    parts.push("repeated");
  }
  if (this.optional) {
    parts.push("optional");
  }
  const file = this.kind === "extension" ? this.file : this.parent.file;
  if (file.syntax == "proto2" && this.proto.label === descriptor_pb_js_1$2.FieldDescriptorProto_Label.REQUIRED) {
    parts.push("required");
  }
  let type;
  switch (this.fieldKind) {
    case "scalar":
      type = scalar_js_1$1.ScalarType[this.scalar].toLowerCase();
      break;
    case "enum":
      type = this.enum.typeName;
      break;
    case "message":
      type = this.message.typeName;
      break;
    case "map": {
      const k = scalar_js_1$1.ScalarType[this.mapKey].toLowerCase();
      let v;
      switch (this.mapValue.kind) {
        case "scalar":
          v = scalar_js_1$1.ScalarType[this.mapValue.scalar].toLowerCase();
          break;
        case "enum":
          v = this.mapValue.enum.typeName;
          break;
        case "message":
          v = this.mapValue.message.typeName;
          break;
      }
      type = `map<${k}, ${v}>`;
      break;
    }
  }
  parts.push(`${type} ${this.name} = ${this.number}`);
  const options = [];
  if (((_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.packed) !== void 0) {
    options.push(`packed = ${this.proto.options.packed.toString()}`);
  }
  let defaultValue = this.proto.defaultValue;
  if (defaultValue !== void 0) {
    if (this.proto.type == descriptor_pb_js_1$2.FieldDescriptorProto_Type.BYTES || this.proto.type == descriptor_pb_js_1$2.FieldDescriptorProto_Type.STRING) {
      defaultValue = '"' + defaultValue.replace('"', '\\"') + '"';
    }
    options.push(`default = ${defaultValue}`);
  }
  if (this.jsonName !== void 0) {
    options.push(`json_name = "${this.jsonName}"`);
  }
  if (((_b = this.proto.options) === null || _b === void 0 ? void 0 : _b.jstype) !== void 0) {
    options.push(`jstype = ${descriptor_pb_js_1$2.FieldOptions_JSType[this.proto.options.jstype]}`);
  }
  if (((_c = this.proto.options) === null || _c === void 0 ? void 0 : _c.deprecated) === true) {
    options.push(`deprecated = true`);
  }
  if (options.length > 0) {
    parts.push("[" + options.join(", ") + "]");
  }
  return parts.join(" ");
}
function getDefaultValue() {
  const d = this.proto.defaultValue;
  if (d === void 0) {
    return void 0;
  }
  switch (this.fieldKind) {
    case "enum":
      return (0, text_format_js_1.parseTextFormatEnumValue)(this.enum, d);
    case "scalar":
      return (0, text_format_js_1.parseTextFormatScalarValue)(this.scalar, d);
    default:
      return void 0;
  }
}
var createRegistry$1 = {};
Object.defineProperty(createRegistry$1, "__esModule", { value: true });
createRegistry$1.createRegistry = void 0;
function createRegistry(...types2) {
  const messages2 = {};
  const enums2 = {};
  const services = {};
  const extensionsByName = /* @__PURE__ */ new Map();
  const extensionsByExtendee = /* @__PURE__ */ new Map();
  const registry = {
    findMessage(typeName) {
      return messages2[typeName];
    },
    findEnum(typeName) {
      return enums2[typeName];
    },
    findService(typeName) {
      return services[typeName];
    },
    findExtensionFor(typeName, no) {
      var _a, _b;
      return (_b = (_a = extensionsByExtendee.get(typeName)) === null || _a === void 0 ? void 0 : _a.get(no)) !== null && _b !== void 0 ? _b : void 0;
    },
    findExtension(typeName) {
      var _a;
      return (_a = extensionsByName.get(typeName)) !== null && _a !== void 0 ? _a : void 0;
    }
  };
  function addType(type) {
    var _a;
    if ("fields" in type) {
      if (!registry.findMessage(type.typeName)) {
        messages2[type.typeName] = type;
        type.fields.list().forEach(addField);
      }
    } else if ("methods" in type) {
      if (!registry.findService(type.typeName)) {
        services[type.typeName] = type;
        for (const method of Object.values(type.methods)) {
          addType(method.I);
          addType(method.O);
        }
      }
    } else if ("extendee" in type) {
      if (!extensionsByName.has(type.typeName)) {
        extensionsByName.set(type.typeName, type);
        const extendeeName = type.extendee.typeName;
        if (!extensionsByExtendee.has(extendeeName)) {
          extensionsByExtendee.set(extendeeName, /* @__PURE__ */ new Map());
        }
        (_a = extensionsByExtendee.get(extendeeName)) === null || _a === void 0 ? void 0 : _a.set(type.field.no, type);
        addType(type.extendee);
        addField(type.field);
      }
    } else {
      enums2[type.typeName] = type;
    }
  }
  function addField(field2) {
    if (field2.kind == "message") {
      addType(field2.T);
    } else if (field2.kind == "map" && field2.V.kind == "message") {
      addType(field2.V.T);
    } else if (field2.kind == "enum") {
      addType(field2.T);
    }
  }
  for (const type of types2) {
    addType(type);
  }
  return registry;
}
createRegistry$1.createRegistry = createRegistry;
var createRegistryFromDesc = {};
var timestamp_pb = {};
Object.defineProperty(timestamp_pb, "__esModule", { value: true });
timestamp_pb.Timestamp = void 0;
const message_js_1$a = message;
const proto_int64_js_1$2 = protoInt64;
const proto3_js_1$a = proto3;
class Timestamp extends message_js_1$a.Message {
  constructor(data) {
    super();
    this.seconds = proto_int64_js_1$2.protoInt64.zero;
    this.nanos = 0;
    proto3_js_1$a.proto3.util.initPartial(data, this);
  }
  fromJson(json, options) {
    if (typeof json !== "string") {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: ${proto3_js_1$a.proto3.json.debug(json)}`);
    }
    const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!matches) {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
    }
    const ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
    if (Number.isNaN(ms)) {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
    }
    if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
      throw new Error(`cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
    }
    this.seconds = proto_int64_js_1$2.protoInt64.parse(ms / 1e3);
    this.nanos = 0;
    if (matches[7]) {
      this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
    }
    return this;
  }
  toJson(options) {
    const ms = Number(this.seconds) * 1e3;
    if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
      throw new Error(`cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
    }
    if (this.nanos < 0) {
      throw new Error(`cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative`);
    }
    let z = "Z";
    if (this.nanos > 0) {
      const nanosStr = (this.nanos + 1e9).toString().substring(1);
      if (nanosStr.substring(3) === "000000") {
        z = "." + nanosStr.substring(0, 3) + "Z";
      } else if (nanosStr.substring(6) === "000") {
        z = "." + nanosStr.substring(0, 6) + "Z";
      } else {
        z = "." + nanosStr + "Z";
      }
    }
    return new Date(ms).toISOString().replace(".000Z", z);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(date) {
    const ms = date.getTime();
    return new Timestamp({
      seconds: proto_int64_js_1$2.protoInt64.parse(Math.floor(ms / 1e3)),
      nanos: ms % 1e3 * 1e6
    });
  }
  static fromBinary(bytes2, options) {
    return new Timestamp().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Timestamp().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Timestamp().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$a.proto3.util.equals(Timestamp, a, b);
  }
}
timestamp_pb.Timestamp = Timestamp;
Timestamp.runtime = proto3_js_1$a.proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3_js_1$a.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);
var duration_pb = {};
Object.defineProperty(duration_pb, "__esModule", { value: true });
duration_pb.Duration = void 0;
const message_js_1$9 = message;
const proto_int64_js_1$1 = protoInt64;
const proto3_js_1$9 = proto3;
class Duration extends message_js_1$9.Message {
  constructor(data) {
    super();
    this.seconds = proto_int64_js_1$1.protoInt64.zero;
    this.nanos = 0;
    proto3_js_1$9.proto3.util.initPartial(data, this);
  }
  fromJson(json, options) {
    if (typeof json !== "string") {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3_js_1$9.proto3.json.debug(json)}`);
    }
    const match = json.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
    if (match === null) {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3_js_1$9.proto3.json.debug(json)}`);
    }
    const longSeconds = Number(match[1]);
    if (longSeconds > 315576e6 || longSeconds < -315576e6) {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3_js_1$9.proto3.json.debug(json)}`);
    }
    this.seconds = proto_int64_js_1$1.protoInt64.parse(longSeconds);
    if (typeof match[2] == "string") {
      const nanosStr = match[2] + "0".repeat(9 - match[2].length);
      this.nanos = parseInt(nanosStr);
      if (longSeconds < 0 || Object.is(longSeconds, -0)) {
        this.nanos = -this.nanos;
      }
    }
    return this;
  }
  toJson(options) {
    if (Number(this.seconds) > 315576e6 || Number(this.seconds) < -315576e6) {
      throw new Error(`cannot encode google.protobuf.Duration to JSON: value out of range`);
    }
    let text = this.seconds.toString();
    if (this.nanos !== 0) {
      let nanosStr = Math.abs(this.nanos).toString();
      nanosStr = "0".repeat(9 - nanosStr.length) + nanosStr;
      if (nanosStr.substring(3) === "000000") {
        nanosStr = nanosStr.substring(0, 3);
      } else if (nanosStr.substring(6) === "000") {
        nanosStr = nanosStr.substring(0, 6);
      }
      text += "." + nanosStr;
      if (this.nanos < 0 && Number(this.seconds) == 0) {
        text = "-" + text;
      }
    }
    return text + "s";
  }
  static fromBinary(bytes2, options) {
    return new Duration().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Duration().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Duration().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$9.proto3.util.equals(Duration, a, b);
  }
}
duration_pb.Duration = Duration;
Duration.runtime = proto3_js_1$9.proto3;
Duration.typeName = "google.protobuf.Duration";
Duration.fields = proto3_js_1$9.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);
var any_pb = {};
Object.defineProperty(any_pb, "__esModule", { value: true });
any_pb.Any = void 0;
const message_js_1$8 = message;
const proto3_js_1$8 = proto3;
class Any extends message_js_1$8.Message {
  constructor(data) {
    super();
    this.typeUrl = "";
    this.value = new Uint8Array(0);
    proto3_js_1$8.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    var _a;
    if (this.typeUrl === "") {
      return {};
    }
    const typeName = this.typeUrlToName(this.typeUrl);
    const messageType2 = (_a = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a === void 0 ? void 0 : _a.findMessage(typeName);
    if (!messageType2) {
      throw new Error(`cannot encode message google.protobuf.Any to JSON: "${this.typeUrl}" is not in the type registry`);
    }
    const message2 = messageType2.fromBinary(this.value);
    let json = message2.toJson(options);
    if (typeName.startsWith("google.protobuf.") || (json === null || Array.isArray(json) || typeof json !== "object")) {
      json = { value: json };
    }
    json["@type"] = this.typeUrl;
    return json;
  }
  fromJson(json, options) {
    var _a;
    if (json === null || Array.isArray(json) || typeof json != "object") {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: expected object but got ${json === null ? "null" : Array.isArray(json) ? "array" : typeof json}`);
    }
    if (Object.keys(json).length == 0) {
      return this;
    }
    const typeUrl = json["@type"];
    if (typeof typeUrl != "string" || typeUrl == "") {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: "@type" is empty`);
    }
    const typeName = this.typeUrlToName(typeUrl), messageType2 = (_a = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a === void 0 ? void 0 : _a.findMessage(typeName);
    if (!messageType2) {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: ${typeUrl} is not in the type registry`);
    }
    let message2;
    if (typeName.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(json, "value")) {
      message2 = messageType2.fromJson(json["value"], options);
    } else {
      const copy = Object.assign({}, json);
      delete copy["@type"];
      message2 = messageType2.fromJson(copy, options);
    }
    this.packFrom(message2);
    return this;
  }
  packFrom(message2) {
    this.value = message2.toBinary();
    this.typeUrl = this.typeNameToUrl(message2.getType().typeName);
  }
  unpackTo(target) {
    if (!this.is(target.getType())) {
      return false;
    }
    target.fromBinary(this.value);
    return true;
  }
  unpack(registry) {
    if (this.typeUrl === "") {
      return void 0;
    }
    const messageType2 = registry.findMessage(this.typeUrlToName(this.typeUrl));
    if (!messageType2) {
      return void 0;
    }
    return messageType2.fromBinary(this.value);
  }
  is(type) {
    if (this.typeUrl === "") {
      return false;
    }
    const name2 = this.typeUrlToName(this.typeUrl);
    let typeName = "";
    if (typeof type === "string") {
      typeName = type;
    } else {
      typeName = type.typeName;
    }
    return name2 === typeName;
  }
  typeNameToUrl(name2) {
    return `type.googleapis.com/${name2}`;
  }
  typeUrlToName(url) {
    if (!url.length) {
      throw new Error(`invalid type url: ${url}`);
    }
    const slash = url.lastIndexOf("/");
    const name2 = slash >= 0 ? url.substring(slash + 1) : url;
    if (!name2.length) {
      throw new Error(`invalid type url: ${url}`);
    }
    return name2;
  }
  static pack(message2) {
    const any = new Any();
    any.packFrom(message2);
    return any;
  }
  static fromBinary(bytes2, options) {
    return new Any().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Any().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Any().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$8.proto3.util.equals(Any, a, b);
  }
}
any_pb.Any = Any;
Any.runtime = proto3_js_1$8.proto3;
Any.typeName = "google.protobuf.Any";
Any.fields = proto3_js_1$8.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "value",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]);
var empty_pb = {};
Object.defineProperty(empty_pb, "__esModule", { value: true });
empty_pb.Empty = void 0;
const message_js_1$7 = message;
const proto3_js_1$7 = proto3;
class Empty extends message_js_1$7.Message {
  constructor(data) {
    super();
    proto3_js_1$7.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Empty().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Empty().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Empty().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$7.proto3.util.equals(Empty, a, b);
  }
}
empty_pb.Empty = Empty;
Empty.runtime = proto3_js_1$7.proto3;
Empty.typeName = "google.protobuf.Empty";
Empty.fields = proto3_js_1$7.proto3.util.newFieldList(() => []);
var field_mask_pb = {};
Object.defineProperty(field_mask_pb, "__esModule", { value: true });
field_mask_pb.FieldMask = void 0;
const message_js_1$6 = message;
const proto3_js_1$6 = proto3;
class FieldMask extends message_js_1$6.Message {
  constructor(data) {
    super();
    this.paths = [];
    proto3_js_1$6.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    function protoCamelCase(snakeCase) {
      let capNext = false;
      const b = [];
      for (let i = 0; i < snakeCase.length; i++) {
        let c = snakeCase.charAt(i);
        switch (c) {
          case "_":
            capNext = true;
            break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            b.push(c);
            capNext = false;
            break;
          default:
            if (capNext) {
              capNext = false;
              c = c.toUpperCase();
            }
            b.push(c);
            break;
        }
      }
      return b.join("");
    }
    return this.paths.map((p) => {
      if (p.match(/_[0-9]?_/g) || p.match(/[A-Z]/g)) {
        throw new Error('cannot encode google.protobuf.FieldMask to JSON: lowerCamelCase of path name "' + p + '" is irreversible');
      }
      return protoCamelCase(p);
    }).join(",");
  }
  fromJson(json, options) {
    if (typeof json !== "string") {
      throw new Error("cannot decode google.protobuf.FieldMask from JSON: " + proto3_js_1$6.proto3.json.debug(json));
    }
    if (json === "") {
      return this;
    }
    function camelToSnake(str) {
      if (str.includes("_")) {
        throw new Error("cannot decode google.protobuf.FieldMask from JSON: path names must be lowerCamelCase");
      }
      const sc = str.replace(/[A-Z]/g, (letter) => "_" + letter.toLowerCase());
      return sc[0] === "_" ? sc.substring(1) : sc;
    }
    this.paths = json.split(",").map(camelToSnake);
    return this;
  }
  static fromBinary(bytes2, options) {
    return new FieldMask().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FieldMask().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FieldMask().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$6.proto3.util.equals(FieldMask, a, b);
  }
}
field_mask_pb.FieldMask = FieldMask;
FieldMask.runtime = proto3_js_1$6.proto3;
FieldMask.typeName = "google.protobuf.FieldMask";
FieldMask.fields = proto3_js_1$6.proto3.util.newFieldList(() => [
  { no: 1, name: "paths", kind: "scalar", T: 9, repeated: true }
]);
var struct_pb = {};
Object.defineProperty(struct_pb, "__esModule", { value: true });
struct_pb.ListValue = struct_pb.Value = struct_pb.Struct = struct_pb.NullValue = void 0;
const proto3_js_1$5 = proto3;
const message_js_1$5 = message;
var NullValue;
(function(NullValue2) {
  NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
})(NullValue || (struct_pb.NullValue = NullValue = {}));
proto3_js_1$5.proto3.util.setEnumType(NullValue, "google.protobuf.NullValue", [
  { no: 0, name: "NULL_VALUE" }
]);
class Struct extends message_js_1$5.Message {
  constructor(data) {
    super();
    this.fields = {};
    proto3_js_1$5.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    const json = {};
    for (const [k, v] of Object.entries(this.fields)) {
      json[k] = v.toJson(options);
    }
    return json;
  }
  fromJson(json, options) {
    if (typeof json != "object" || json == null || Array.isArray(json)) {
      throw new Error("cannot decode google.protobuf.Struct from JSON " + proto3_js_1$5.proto3.json.debug(json));
    }
    for (const [k, v] of Object.entries(json)) {
      this.fields[k] = Value.fromJson(v);
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new Struct().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Struct().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Struct().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$5.proto3.util.equals(Struct, a, b);
  }
}
struct_pb.Struct = Struct;
Struct.runtime = proto3_js_1$5.proto3;
Struct.typeName = "google.protobuf.Struct";
Struct.fields = proto3_js_1$5.proto3.util.newFieldList(() => [
  { no: 1, name: "fields", kind: "map", K: 9, V: { kind: "message", T: Value } }
]);
class Value extends message_js_1$5.Message {
  constructor(data) {
    super();
    this.kind = { case: void 0 };
    proto3_js_1$5.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    switch (this.kind.case) {
      case "nullValue":
        return null;
      case "numberValue":
        if (!Number.isFinite(this.kind.value)) {
          throw new Error("google.protobuf.Value cannot be NaN or Infinity");
        }
        return this.kind.value;
      case "boolValue":
        return this.kind.value;
      case "stringValue":
        return this.kind.value;
      case "structValue":
      case "listValue":
        return this.kind.value.toJson(Object.assign(Object.assign({}, options), { emitDefaultValues: true }));
    }
    throw new Error("google.protobuf.Value must have a value");
  }
  fromJson(json, options) {
    switch (typeof json) {
      case "number":
        this.kind = { case: "numberValue", value: json };
        break;
      case "string":
        this.kind = { case: "stringValue", value: json };
        break;
      case "boolean":
        this.kind = { case: "boolValue", value: json };
        break;
      case "object":
        if (json === null) {
          this.kind = { case: "nullValue", value: NullValue.NULL_VALUE };
        } else if (Array.isArray(json)) {
          this.kind = { case: "listValue", value: ListValue.fromJson(json) };
        } else {
          this.kind = { case: "structValue", value: Struct.fromJson(json) };
        }
        break;
      default:
        throw new Error("cannot decode google.protobuf.Value from JSON " + proto3_js_1$5.proto3.json.debug(json));
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new Value().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$5.proto3.util.equals(Value, a, b);
  }
}
struct_pb.Value = Value;
Value.runtime = proto3_js_1$5.proto3;
Value.typeName = "google.protobuf.Value";
Value.fields = proto3_js_1$5.proto3.util.newFieldList(() => [
  { no: 1, name: "null_value", kind: "enum", T: proto3_js_1$5.proto3.getEnumType(NullValue), oneof: "kind" },
  { no: 2, name: "number_value", kind: "scalar", T: 1, oneof: "kind" },
  { no: 3, name: "string_value", kind: "scalar", T: 9, oneof: "kind" },
  { no: 4, name: "bool_value", kind: "scalar", T: 8, oneof: "kind" },
  { no: 5, name: "struct_value", kind: "message", T: Struct, oneof: "kind" },
  { no: 6, name: "list_value", kind: "message", T: ListValue, oneof: "kind" }
]);
class ListValue extends message_js_1$5.Message {
  constructor(data) {
    super();
    this.values = [];
    proto3_js_1$5.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return this.values.map((v) => v.toJson());
  }
  fromJson(json, options) {
    if (!Array.isArray(json)) {
      throw new Error("cannot decode google.protobuf.ListValue from JSON " + proto3_js_1$5.proto3.json.debug(json));
    }
    for (let e of json) {
      this.values.push(Value.fromJson(e));
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new ListValue().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new ListValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new ListValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$5.proto3.util.equals(ListValue, a, b);
  }
}
struct_pb.ListValue = ListValue;
ListValue.runtime = proto3_js_1$5.proto3;
ListValue.typeName = "google.protobuf.ListValue";
ListValue.fields = proto3_js_1$5.proto3.util.newFieldList(() => [
  { no: 1, name: "values", kind: "message", T: Value, repeated: true }
]);
var wrappers_pb = {};
Object.defineProperty(wrappers_pb, "__esModule", { value: true });
wrappers_pb.BytesValue = wrappers_pb.StringValue = wrappers_pb.BoolValue = wrappers_pb.UInt32Value = wrappers_pb.Int32Value = wrappers_pb.UInt64Value = wrappers_pb.Int64Value = wrappers_pb.FloatValue = wrappers_pb.DoubleValue = void 0;
const message_js_1$4 = message;
const proto3_js_1$4 = proto3;
const scalar_js_1 = scalar;
const proto_int64_js_1 = protoInt64;
class DoubleValue extends message_js_1$4.Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3_js_1$4.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3_js_1$4.proto3.json.writeScalar(scalar_js_1.ScalarType.DOUBLE, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3_js_1$4.proto3.json.readScalar(scalar_js_1.ScalarType.DOUBLE, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.DoubleValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new DoubleValue().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new DoubleValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new DoubleValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$4.proto3.util.equals(DoubleValue, a, b);
  }
}
wrappers_pb.DoubleValue = DoubleValue;
DoubleValue.runtime = proto3_js_1$4.proto3;
DoubleValue.typeName = "google.protobuf.DoubleValue";
DoubleValue.fields = proto3_js_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }
]);
DoubleValue.fieldWrapper = {
  wrapField(value) {
    return new DoubleValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
class FloatValue extends message_js_1$4.Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3_js_1$4.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3_js_1$4.proto3.json.writeScalar(scalar_js_1.ScalarType.FLOAT, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3_js_1$4.proto3.json.readScalar(scalar_js_1.ScalarType.FLOAT, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.FloatValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new FloatValue().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new FloatValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FloatValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$4.proto3.util.equals(FloatValue, a, b);
  }
}
wrappers_pb.FloatValue = FloatValue;
FloatValue.runtime = proto3_js_1$4.proto3;
FloatValue.typeName = "google.protobuf.FloatValue";
FloatValue.fields = proto3_js_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }
]);
FloatValue.fieldWrapper = {
  wrapField(value) {
    return new FloatValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
class Int64Value extends message_js_1$4.Message {
  constructor(data) {
    super();
    this.value = proto_int64_js_1.protoInt64.zero;
    proto3_js_1$4.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3_js_1$4.proto3.json.writeScalar(scalar_js_1.ScalarType.INT64, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3_js_1$4.proto3.json.readScalar(scalar_js_1.ScalarType.INT64, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.Int64Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new Int64Value().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Int64Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Int64Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$4.proto3.util.equals(Int64Value, a, b);
  }
}
wrappers_pb.Int64Value = Int64Value;
Int64Value.runtime = proto3_js_1$4.proto3;
Int64Value.typeName = "google.protobuf.Int64Value";
Int64Value.fields = proto3_js_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }
]);
Int64Value.fieldWrapper = {
  wrapField(value) {
    return new Int64Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
class UInt64Value extends message_js_1$4.Message {
  constructor(data) {
    super();
    this.value = proto_int64_js_1.protoInt64.zero;
    proto3_js_1$4.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3_js_1$4.proto3.json.writeScalar(scalar_js_1.ScalarType.UINT64, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3_js_1$4.proto3.json.readScalar(scalar_js_1.ScalarType.UINT64, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.UInt64Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new UInt64Value().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new UInt64Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new UInt64Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$4.proto3.util.equals(UInt64Value, a, b);
  }
}
wrappers_pb.UInt64Value = UInt64Value;
UInt64Value.runtime = proto3_js_1$4.proto3;
UInt64Value.typeName = "google.protobuf.UInt64Value";
UInt64Value.fields = proto3_js_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }
]);
UInt64Value.fieldWrapper = {
  wrapField(value) {
    return new UInt64Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
class Int32Value extends message_js_1$4.Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3_js_1$4.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3_js_1$4.proto3.json.writeScalar(scalar_js_1.ScalarType.INT32, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3_js_1$4.proto3.json.readScalar(scalar_js_1.ScalarType.INT32, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.Int32Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new Int32Value().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Int32Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Int32Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$4.proto3.util.equals(Int32Value, a, b);
  }
}
wrappers_pb.Int32Value = Int32Value;
Int32Value.runtime = proto3_js_1$4.proto3;
Int32Value.typeName = "google.protobuf.Int32Value";
Int32Value.fields = proto3_js_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);
Int32Value.fieldWrapper = {
  wrapField(value) {
    return new Int32Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
class UInt32Value extends message_js_1$4.Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3_js_1$4.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3_js_1$4.proto3.json.writeScalar(scalar_js_1.ScalarType.UINT32, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3_js_1$4.proto3.json.readScalar(scalar_js_1.ScalarType.UINT32, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.UInt32Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new UInt32Value().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new UInt32Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new UInt32Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$4.proto3.util.equals(UInt32Value, a, b);
  }
}
wrappers_pb.UInt32Value = UInt32Value;
UInt32Value.runtime = proto3_js_1$4.proto3;
UInt32Value.typeName = "google.protobuf.UInt32Value";
UInt32Value.fields = proto3_js_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
]);
UInt32Value.fieldWrapper = {
  wrapField(value) {
    return new UInt32Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
class BoolValue extends message_js_1$4.Message {
  constructor(data) {
    super();
    this.value = false;
    proto3_js_1$4.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3_js_1$4.proto3.json.writeScalar(scalar_js_1.ScalarType.BOOL, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3_js_1$4.proto3.json.readScalar(scalar_js_1.ScalarType.BOOL, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.BoolValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new BoolValue().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new BoolValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new BoolValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$4.proto3.util.equals(BoolValue, a, b);
  }
}
wrappers_pb.BoolValue = BoolValue;
BoolValue.runtime = proto3_js_1$4.proto3;
BoolValue.typeName = "google.protobuf.BoolValue";
BoolValue.fields = proto3_js_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }
]);
BoolValue.fieldWrapper = {
  wrapField(value) {
    return new BoolValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
class StringValue extends message_js_1$4.Message {
  constructor(data) {
    super();
    this.value = "";
    proto3_js_1$4.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3_js_1$4.proto3.json.writeScalar(scalar_js_1.ScalarType.STRING, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3_js_1$4.proto3.json.readScalar(scalar_js_1.ScalarType.STRING, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.StringValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new StringValue().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new StringValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new StringValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$4.proto3.util.equals(StringValue, a, b);
  }
}
wrappers_pb.StringValue = StringValue;
StringValue.runtime = proto3_js_1$4.proto3;
StringValue.typeName = "google.protobuf.StringValue";
StringValue.fields = proto3_js_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
StringValue.fieldWrapper = {
  wrapField(value) {
    return new StringValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
class BytesValue extends message_js_1$4.Message {
  constructor(data) {
    super();
    this.value = new Uint8Array(0);
    proto3_js_1$4.proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3_js_1$4.proto3.json.writeScalar(scalar_js_1.ScalarType.BYTES, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3_js_1$4.proto3.json.readScalar(scalar_js_1.ScalarType.BYTES, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.BytesValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes2, options) {
    return new BytesValue().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new BytesValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new BytesValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$4.proto3.util.equals(BytesValue, a, b);
  }
}
wrappers_pb.BytesValue = BytesValue;
BytesValue.runtime = proto3_js_1$4.proto3;
BytesValue.typeName = "google.protobuf.BytesValue";
BytesValue.fields = proto3_js_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]);
BytesValue.fieldWrapper = {
  wrapField(value) {
    return new BytesValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
Object.defineProperty(createRegistryFromDesc, "__esModule", { value: true });
createRegistryFromDesc.createRegistryFromDescriptors = void 0;
const assert_js_1 = assert$4;
const proto3_js_1$3 = proto3;
const proto2_js_1$1 = proto2;
const names_js_1 = names;
const timestamp_pb_js_1 = timestamp_pb;
const duration_pb_js_1 = duration_pb;
const any_pb_js_1$1 = any_pb;
const empty_pb_js_1 = empty_pb;
const field_mask_pb_js_1 = field_mask_pb;
const struct_pb_js_1 = struct_pb;
const enum_js_1 = _enum;
const wrappers_pb_js_1 = wrappers_pb;
const descriptor_pb_js_1$1 = descriptor_pb;
const create_descriptor_set_js_1 = createDescriptorSet$1;
const is_message_js_1$1 = isMessage$1;
const wkMessages = [
  any_pb_js_1$1.Any,
  duration_pb_js_1.Duration,
  empty_pb_js_1.Empty,
  field_mask_pb_js_1.FieldMask,
  struct_pb_js_1.Struct,
  struct_pb_js_1.Value,
  struct_pb_js_1.ListValue,
  timestamp_pb_js_1.Timestamp,
  duration_pb_js_1.Duration,
  wrappers_pb_js_1.DoubleValue,
  wrappers_pb_js_1.FloatValue,
  wrappers_pb_js_1.Int64Value,
  wrappers_pb_js_1.Int32Value,
  wrappers_pb_js_1.UInt32Value,
  wrappers_pb_js_1.UInt64Value,
  wrappers_pb_js_1.BoolValue,
  wrappers_pb_js_1.StringValue,
  wrappers_pb_js_1.BytesValue
];
const wkEnums = [(0, enum_js_1.getEnumType)(struct_pb_js_1.NullValue)];
function createRegistryFromDescriptors(input, replaceWkt = true) {
  const set = input instanceof Uint8Array || (0, is_message_js_1$1.isMessage)(input, descriptor_pb_js_1$1.FileDescriptorSet) ? (0, create_descriptor_set_js_1.createDescriptorSet)(input) : input;
  const enums2 = /* @__PURE__ */ new Map();
  const messages2 = /* @__PURE__ */ new Map();
  const extensions2 = /* @__PURE__ */ new Map();
  const extensionsByExtendee = /* @__PURE__ */ new Map();
  const services = {};
  if (replaceWkt) {
    for (const mt of wkMessages) {
      messages2.set(mt.typeName, mt);
    }
    for (const et of wkEnums) {
      enums2.set(et.typeName, et);
    }
  }
  return {
    /**
     * May raise an error on invalid descriptors.
     */
    findEnum(typeName) {
      const existing = enums2.get(typeName);
      if (existing) {
        return existing;
      }
      const desc = set.enums.get(typeName);
      if (!desc) {
        return void 0;
      }
      const runtime = desc.file.syntax == "proto3" ? proto3_js_1$3.proto3 : proto2_js_1$1.proto2;
      const type = runtime.makeEnumType(typeName, desc.values.map((u) => ({
        no: u.number,
        name: u.name,
        localName: (0, names_js_1.localName)(u)
      })), {});
      enums2.set(typeName, type);
      return type;
    },
    /**
     * May raise an error on invalid descriptors.
     */
    findMessage(typeName) {
      const existing = messages2.get(typeName);
      if (existing) {
        return existing;
      }
      const desc = set.messages.get(typeName);
      if (!desc) {
        return void 0;
      }
      const runtime = desc.file.syntax == "proto3" ? proto3_js_1$3.proto3 : proto2_js_1$1.proto2;
      const fields = [];
      const type = runtime.makeMessageType(typeName, () => fields, {
        localName: (0, names_js_1.localName)(desc)
      });
      messages2.set(typeName, type);
      for (const field2 of desc.fields) {
        fields.push(makeFieldInfo(field2, this));
      }
      return type;
    },
    /**
     * May raise an error on invalid descriptors.
     */
    findService(typeName) {
      const existing = services[typeName];
      if (existing) {
        return existing;
      }
      const desc = set.services.get(typeName);
      if (!desc) {
        return void 0;
      }
      const methods = {};
      for (const method of desc.methods) {
        const I = resolve(method.input, this, method);
        const O = resolve(method.output, this, method);
        methods[(0, names_js_1.localName)(method)] = {
          name: method.name,
          I,
          O,
          kind: method.methodKind,
          idempotency: method.idempotency
          // We do not surface options at this time
          // options: {},
        };
      }
      return services[typeName] = {
        typeName: desc.typeName,
        methods
      };
    },
    /**
     * May raise an error on invalid descriptors.
     */
    findExtensionFor(typeName, no) {
      var _a;
      if (!set.messages.has(typeName)) {
        return void 0;
      }
      let extensionsByNo = extensionsByExtendee.get(typeName);
      if (!extensionsByNo) {
        extensionsByNo = /* @__PURE__ */ new Map();
        extensionsByExtendee.set(typeName, extensionsByNo);
        for (const desc2 of set.extensions.values()) {
          if (desc2.extendee.typeName == typeName) {
            extensionsByNo.set(desc2.number, desc2);
          }
        }
      }
      const desc = (_a = extensionsByExtendee.get(typeName)) === null || _a === void 0 ? void 0 : _a.get(no);
      return desc ? this.findExtension(desc.typeName) : void 0;
    },
    /**
     * May raise an error on invalid descriptors.
     */
    findExtension(typeName) {
      const existing = extensions2.get(typeName);
      if (existing) {
        return existing;
      }
      const desc = set.extensions.get(typeName);
      if (!desc) {
        return void 0;
      }
      const extendee = resolve(desc.extendee, this, desc);
      const runtime = desc.file.syntax == "proto3" ? proto3_js_1$3.proto3 : proto2_js_1$1.proto2;
      const ext = runtime.makeExtension(typeName, extendee, makeFieldInfo(desc, this));
      extensions2.set(typeName, ext);
      return ext;
    }
  };
}
createRegistryFromDesc.createRegistryFromDescriptors = createRegistryFromDescriptors;
function makeFieldInfo(desc, registry) {
  var _a;
  const f2 = {
    kind: desc.fieldKind,
    no: desc.number,
    name: desc.name,
    jsonName: desc.jsonName,
    delimited: desc.proto.type == descriptor_pb_js_1$1.FieldDescriptorProto_Type.GROUP,
    repeated: desc.repeated,
    packed: desc.packed,
    oneof: (_a = desc.oneof) === null || _a === void 0 ? void 0 : _a.name,
    opt: desc.optional,
    req: desc.proto.label === descriptor_pb_js_1$1.FieldDescriptorProto_Label.REQUIRED
  };
  switch (desc.fieldKind) {
    case "map": {
      (0, assert_js_1.assert)(desc.kind == "field");
      let T;
      switch (desc.mapValue.kind) {
        case "scalar":
          T = desc.mapValue.scalar;
          break;
        case "enum": {
          T = resolve(desc.mapValue.enum, registry, desc);
          break;
        }
        case "message": {
          T = resolve(desc.mapValue.message, registry, desc);
          break;
        }
      }
      f2.K = desc.mapKey;
      f2.V = {
        kind: desc.mapValue.kind,
        T
      };
      break;
    }
    case "message": {
      f2.T = resolve(desc.message, registry, desc);
      break;
    }
    case "enum": {
      f2.T = resolve(desc.enum, registry, desc);
      f2.default = desc.getDefaultValue();
      break;
    }
    case "scalar": {
      f2.L = desc.longType;
      f2.T = desc.scalar;
      f2.default = desc.getDefaultValue();
      break;
    }
  }
  return f2;
}
function resolve(desc, registry, context) {
  const type = desc.kind == "message" ? registry.findMessage(desc.typeName) : registry.findEnum(desc.typeName);
  (0, assert_js_1.assert)(type, `${desc.toString()}" for ${context.toString()} not found`);
  return type;
}
var toPlainMessage$1 = {};
Object.defineProperty(toPlainMessage$1, "__esModule", { value: true });
toPlainMessage$1.toPlainMessage = void 0;
const is_message_js_1 = isMessage$1;
function toPlainMessage(message2) {
  if (!(0, is_message_js_1.isMessage)(message2)) {
    return message2;
  }
  const type = message2.getType();
  const target = {};
  for (const member of type.fields.byMember()) {
    const source = message2[member.localName];
    let copy;
    if (member.repeated) {
      copy = source.map((e) => toPlainValue(e));
    } else if (member.kind == "map") {
      copy = {};
      for (const [key2, v] of Object.entries(source)) {
        copy[key2] = toPlainValue(v);
      }
    } else if (member.kind == "oneof") {
      const f2 = member.findField(source.case);
      copy = f2 ? { case: source.case, value: toPlainValue(source.value) } : { case: void 0 };
    } else {
      copy = toPlainValue(source);
    }
    target[member.localName] = copy;
  }
  return target;
}
toPlainMessage$1.toPlainMessage = toPlainMessage;
function toPlainValue(value) {
  if (value === void 0) {
    return value;
  }
  if ((0, is_message_js_1.isMessage)(value)) {
    return toPlainMessage(value);
  }
  if (value instanceof Uint8Array) {
    const c = new Uint8Array(value.byteLength);
    c.set(value);
    return c;
  }
  return value;
}
var plugin_pb = {};
Object.defineProperty(plugin_pb, "__esModule", { value: true });
plugin_pb.CodeGeneratorResponse_File = plugin_pb.CodeGeneratorResponse_Feature = plugin_pb.CodeGeneratorResponse = plugin_pb.CodeGeneratorRequest = plugin_pb.Version = void 0;
const message_js_1$3 = message;
const proto2_js_1 = proto2;
const descriptor_pb_js_1 = descriptor_pb;
class Version extends message_js_1$3.Message {
  constructor(data) {
    super();
    proto2_js_1.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Version().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Version().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Version().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1.proto2.util.equals(Version, a, b);
  }
}
plugin_pb.Version = Version;
Version.runtime = proto2_js_1.proto2;
Version.typeName = "google.protobuf.compiler.Version";
Version.fields = proto2_js_1.proto2.util.newFieldList(() => [
  { no: 1, name: "major", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "minor", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "patch", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "suffix", kind: "scalar", T: 9, opt: true }
]);
class CodeGeneratorRequest extends message_js_1$3.Message {
  constructor(data) {
    super();
    this.fileToGenerate = [];
    this.protoFile = [];
    this.sourceFileDescriptors = [];
    proto2_js_1.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new CodeGeneratorRequest().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new CodeGeneratorRequest().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new CodeGeneratorRequest().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1.proto2.util.equals(CodeGeneratorRequest, a, b);
  }
}
plugin_pb.CodeGeneratorRequest = CodeGeneratorRequest;
CodeGeneratorRequest.runtime = proto2_js_1.proto2;
CodeGeneratorRequest.typeName = "google.protobuf.compiler.CodeGeneratorRequest";
CodeGeneratorRequest.fields = proto2_js_1.proto2.util.newFieldList(() => [
  { no: 1, name: "file_to_generate", kind: "scalar", T: 9, repeated: true },
  { no: 2, name: "parameter", kind: "scalar", T: 9, opt: true },
  { no: 15, name: "proto_file", kind: "message", T: descriptor_pb_js_1.FileDescriptorProto, repeated: true },
  { no: 17, name: "source_file_descriptors", kind: "message", T: descriptor_pb_js_1.FileDescriptorProto, repeated: true },
  { no: 3, name: "compiler_version", kind: "message", T: Version, opt: true }
]);
class CodeGeneratorResponse extends message_js_1$3.Message {
  constructor(data) {
    super();
    this.file = [];
    proto2_js_1.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new CodeGeneratorResponse().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new CodeGeneratorResponse().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new CodeGeneratorResponse().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1.proto2.util.equals(CodeGeneratorResponse, a, b);
  }
}
plugin_pb.CodeGeneratorResponse = CodeGeneratorResponse;
CodeGeneratorResponse.runtime = proto2_js_1.proto2;
CodeGeneratorResponse.typeName = "google.protobuf.compiler.CodeGeneratorResponse";
CodeGeneratorResponse.fields = proto2_js_1.proto2.util.newFieldList(() => [
  { no: 1, name: "error", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "supported_features", kind: "scalar", T: 4, opt: true },
  { no: 3, name: "minimum_edition", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "maximum_edition", kind: "scalar", T: 5, opt: true },
  { no: 15, name: "file", kind: "message", T: CodeGeneratorResponse_File, repeated: true }
]);
var CodeGeneratorResponse_Feature;
(function(CodeGeneratorResponse_Feature2) {
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["NONE"] = 0] = "NONE";
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["PROTO3_OPTIONAL"] = 1] = "PROTO3_OPTIONAL";
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["SUPPORTS_EDITIONS"] = 2] = "SUPPORTS_EDITIONS";
})(CodeGeneratorResponse_Feature || (plugin_pb.CodeGeneratorResponse_Feature = CodeGeneratorResponse_Feature = {}));
proto2_js_1.proto2.util.setEnumType(CodeGeneratorResponse_Feature, "google.protobuf.compiler.CodeGeneratorResponse.Feature", [
  { no: 0, name: "FEATURE_NONE" },
  { no: 1, name: "FEATURE_PROTO3_OPTIONAL" },
  { no: 2, name: "FEATURE_SUPPORTS_EDITIONS" }
]);
class CodeGeneratorResponse_File extends message_js_1$3.Message {
  constructor(data) {
    super();
    proto2_js_1.proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new CodeGeneratorResponse_File().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new CodeGeneratorResponse_File().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new CodeGeneratorResponse_File().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2_js_1.proto2.util.equals(CodeGeneratorResponse_File, a, b);
  }
}
plugin_pb.CodeGeneratorResponse_File = CodeGeneratorResponse_File;
CodeGeneratorResponse_File.runtime = proto2_js_1.proto2;
CodeGeneratorResponse_File.typeName = "google.protobuf.compiler.CodeGeneratorResponse.File";
CodeGeneratorResponse_File.fields = proto2_js_1.proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "insertion_point", kind: "scalar", T: 9, opt: true },
  { no: 15, name: "content", kind: "scalar", T: 9, opt: true },
  { no: 16, name: "generated_code_info", kind: "message", T: descriptor_pb_js_1.GeneratedCodeInfo, opt: true }
]);
var api_pb = {};
var type_pb = {};
var source_context_pb = {};
Object.defineProperty(source_context_pb, "__esModule", { value: true });
source_context_pb.SourceContext = void 0;
const message_js_1$2 = message;
const proto3_js_1$2 = proto3;
class SourceContext extends message_js_1$2.Message {
  constructor(data) {
    super();
    this.fileName = "";
    proto3_js_1$2.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new SourceContext().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new SourceContext().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new SourceContext().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$2.proto3.util.equals(SourceContext, a, b);
  }
}
source_context_pb.SourceContext = SourceContext;
SourceContext.runtime = proto3_js_1$2.proto3;
SourceContext.typeName = "google.protobuf.SourceContext";
SourceContext.fields = proto3_js_1$2.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "file_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
Object.defineProperty(type_pb, "__esModule", { value: true });
type_pb.Option = type_pb.EnumValue = type_pb.Enum = type_pb.Field_Cardinality = type_pb.Field_Kind = type_pb.Field = type_pb.Type = type_pb.Syntax = void 0;
const proto3_js_1$1 = proto3;
const message_js_1$1 = message;
const source_context_pb_js_1$1 = source_context_pb;
const any_pb_js_1 = any_pb;
var Syntax;
(function(Syntax2) {
  Syntax2[Syntax2["PROTO2"] = 0] = "PROTO2";
  Syntax2[Syntax2["PROTO3"] = 1] = "PROTO3";
  Syntax2[Syntax2["EDITIONS"] = 2] = "EDITIONS";
})(Syntax || (type_pb.Syntax = Syntax = {}));
proto3_js_1$1.proto3.util.setEnumType(Syntax, "google.protobuf.Syntax", [
  { no: 0, name: "SYNTAX_PROTO2" },
  { no: 1, name: "SYNTAX_PROTO3" },
  { no: 2, name: "SYNTAX_EDITIONS" }
]);
class Type extends message_js_1$1.Message {
  constructor(data) {
    super();
    this.name = "";
    this.fields = [];
    this.oneofs = [];
    this.options = [];
    this.syntax = Syntax.PROTO2;
    this.edition = "";
    proto3_js_1$1.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Type().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Type().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Type().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$1.proto3.util.equals(Type, a, b);
  }
}
type_pb.Type = Type;
Type.runtime = proto3_js_1$1.proto3;
Type.typeName = "google.protobuf.Type";
Type.fields = proto3_js_1$1.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "fields", kind: "message", T: Field, repeated: true },
  { no: 3, name: "oneofs", kind: "scalar", T: 9, repeated: true },
  { no: 4, name: "options", kind: "message", T: Option, repeated: true },
  { no: 5, name: "source_context", kind: "message", T: source_context_pb_js_1$1.SourceContext },
  { no: 6, name: "syntax", kind: "enum", T: proto3_js_1$1.proto3.getEnumType(Syntax) },
  {
    no: 7,
    name: "edition",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
class Field extends message_js_1$1.Message {
  constructor(data) {
    super();
    this.kind = Field_Kind.TYPE_UNKNOWN;
    this.cardinality = Field_Cardinality.UNKNOWN;
    this.number = 0;
    this.name = "";
    this.typeUrl = "";
    this.oneofIndex = 0;
    this.packed = false;
    this.options = [];
    this.jsonName = "";
    this.defaultValue = "";
    proto3_js_1$1.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Field().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Field().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Field().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$1.proto3.util.equals(Field, a, b);
  }
}
type_pb.Field = Field;
Field.runtime = proto3_js_1$1.proto3;
Field.typeName = "google.protobuf.Field";
Field.fields = proto3_js_1$1.proto3.util.newFieldList(() => [
  { no: 1, name: "kind", kind: "enum", T: proto3_js_1$1.proto3.getEnumType(Field_Kind) },
  { no: 2, name: "cardinality", kind: "enum", T: proto3_js_1$1.proto3.getEnumType(Field_Cardinality) },
  {
    no: 3,
    name: "number",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 4,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 6,
    name: "type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 7,
    name: "oneof_index",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 8,
    name: "packed",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  { no: 9, name: "options", kind: "message", T: Option, repeated: true },
  {
    no: 10,
    name: "json_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 11,
    name: "default_value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
var Field_Kind;
(function(Field_Kind2) {
  Field_Kind2[Field_Kind2["TYPE_UNKNOWN"] = 0] = "TYPE_UNKNOWN";
  Field_Kind2[Field_Kind2["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
  Field_Kind2[Field_Kind2["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
  Field_Kind2[Field_Kind2["TYPE_INT64"] = 3] = "TYPE_INT64";
  Field_Kind2[Field_Kind2["TYPE_UINT64"] = 4] = "TYPE_UINT64";
  Field_Kind2[Field_Kind2["TYPE_INT32"] = 5] = "TYPE_INT32";
  Field_Kind2[Field_Kind2["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
  Field_Kind2[Field_Kind2["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
  Field_Kind2[Field_Kind2["TYPE_BOOL"] = 8] = "TYPE_BOOL";
  Field_Kind2[Field_Kind2["TYPE_STRING"] = 9] = "TYPE_STRING";
  Field_Kind2[Field_Kind2["TYPE_GROUP"] = 10] = "TYPE_GROUP";
  Field_Kind2[Field_Kind2["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
  Field_Kind2[Field_Kind2["TYPE_BYTES"] = 12] = "TYPE_BYTES";
  Field_Kind2[Field_Kind2["TYPE_UINT32"] = 13] = "TYPE_UINT32";
  Field_Kind2[Field_Kind2["TYPE_ENUM"] = 14] = "TYPE_ENUM";
  Field_Kind2[Field_Kind2["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
  Field_Kind2[Field_Kind2["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
  Field_Kind2[Field_Kind2["TYPE_SINT32"] = 17] = "TYPE_SINT32";
  Field_Kind2[Field_Kind2["TYPE_SINT64"] = 18] = "TYPE_SINT64";
})(Field_Kind || (type_pb.Field_Kind = Field_Kind = {}));
proto3_js_1$1.proto3.util.setEnumType(Field_Kind, "google.protobuf.Field.Kind", [
  { no: 0, name: "TYPE_UNKNOWN" },
  { no: 1, name: "TYPE_DOUBLE" },
  { no: 2, name: "TYPE_FLOAT" },
  { no: 3, name: "TYPE_INT64" },
  { no: 4, name: "TYPE_UINT64" },
  { no: 5, name: "TYPE_INT32" },
  { no: 6, name: "TYPE_FIXED64" },
  { no: 7, name: "TYPE_FIXED32" },
  { no: 8, name: "TYPE_BOOL" },
  { no: 9, name: "TYPE_STRING" },
  { no: 10, name: "TYPE_GROUP" },
  { no: 11, name: "TYPE_MESSAGE" },
  { no: 12, name: "TYPE_BYTES" },
  { no: 13, name: "TYPE_UINT32" },
  { no: 14, name: "TYPE_ENUM" },
  { no: 15, name: "TYPE_SFIXED32" },
  { no: 16, name: "TYPE_SFIXED64" },
  { no: 17, name: "TYPE_SINT32" },
  { no: 18, name: "TYPE_SINT64" }
]);
var Field_Cardinality;
(function(Field_Cardinality2) {
  Field_Cardinality2[Field_Cardinality2["UNKNOWN"] = 0] = "UNKNOWN";
  Field_Cardinality2[Field_Cardinality2["OPTIONAL"] = 1] = "OPTIONAL";
  Field_Cardinality2[Field_Cardinality2["REQUIRED"] = 2] = "REQUIRED";
  Field_Cardinality2[Field_Cardinality2["REPEATED"] = 3] = "REPEATED";
})(Field_Cardinality || (type_pb.Field_Cardinality = Field_Cardinality = {}));
proto3_js_1$1.proto3.util.setEnumType(Field_Cardinality, "google.protobuf.Field.Cardinality", [
  { no: 0, name: "CARDINALITY_UNKNOWN" },
  { no: 1, name: "CARDINALITY_OPTIONAL" },
  { no: 2, name: "CARDINALITY_REQUIRED" },
  { no: 3, name: "CARDINALITY_REPEATED" }
]);
class Enum extends message_js_1$1.Message {
  constructor(data) {
    super();
    this.name = "";
    this.enumvalue = [];
    this.options = [];
    this.syntax = Syntax.PROTO2;
    this.edition = "";
    proto3_js_1$1.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Enum().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Enum().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Enum().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$1.proto3.util.equals(Enum, a, b);
  }
}
type_pb.Enum = Enum;
Enum.runtime = proto3_js_1$1.proto3;
Enum.typeName = "google.protobuf.Enum";
Enum.fields = proto3_js_1$1.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "enumvalue", kind: "message", T: EnumValue, repeated: true },
  { no: 3, name: "options", kind: "message", T: Option, repeated: true },
  { no: 4, name: "source_context", kind: "message", T: source_context_pb_js_1$1.SourceContext },
  { no: 5, name: "syntax", kind: "enum", T: proto3_js_1$1.proto3.getEnumType(Syntax) },
  {
    no: 6,
    name: "edition",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
class EnumValue extends message_js_1$1.Message {
  constructor(data) {
    super();
    this.name = "";
    this.number = 0;
    this.options = [];
    proto3_js_1$1.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new EnumValue().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new EnumValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new EnumValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$1.proto3.util.equals(EnumValue, a, b);
  }
}
type_pb.EnumValue = EnumValue;
EnumValue.runtime = proto3_js_1$1.proto3;
EnumValue.typeName = "google.protobuf.EnumValue";
EnumValue.fields = proto3_js_1$1.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "number",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  { no: 3, name: "options", kind: "message", T: Option, repeated: true }
]);
class Option extends message_js_1$1.Message {
  constructor(data) {
    super();
    this.name = "";
    proto3_js_1$1.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Option().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Option().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Option().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1$1.proto3.util.equals(Option, a, b);
  }
}
type_pb.Option = Option;
Option.runtime = proto3_js_1$1.proto3;
Option.typeName = "google.protobuf.Option";
Option.fields = proto3_js_1$1.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "value", kind: "message", T: any_pb_js_1.Any }
]);
Object.defineProperty(api_pb, "__esModule", { value: true });
api_pb.Mixin = api_pb.Method = api_pb.Api = void 0;
const message_js_1 = message;
const type_pb_js_1 = type_pb;
const source_context_pb_js_1 = source_context_pb;
const proto3_js_1 = proto3;
class Api extends message_js_1.Message {
  constructor(data) {
    super();
    this.name = "";
    this.methods = [];
    this.options = [];
    this.version = "";
    this.mixins = [];
    this.syntax = type_pb_js_1.Syntax.PROTO2;
    proto3_js_1.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Api().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Api().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Api().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1.proto3.util.equals(Api, a, b);
  }
}
api_pb.Api = Api;
Api.runtime = proto3_js_1.proto3;
Api.typeName = "google.protobuf.Api";
Api.fields = proto3_js_1.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "methods", kind: "message", T: Method, repeated: true },
  { no: 3, name: "options", kind: "message", T: type_pb_js_1.Option, repeated: true },
  {
    no: 4,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 5, name: "source_context", kind: "message", T: source_context_pb_js_1.SourceContext },
  { no: 6, name: "mixins", kind: "message", T: Mixin, repeated: true },
  { no: 7, name: "syntax", kind: "enum", T: proto3_js_1.proto3.getEnumType(type_pb_js_1.Syntax) }
]);
class Method extends message_js_1.Message {
  constructor(data) {
    super();
    this.name = "";
    this.requestTypeUrl = "";
    this.requestStreaming = false;
    this.responseTypeUrl = "";
    this.responseStreaming = false;
    this.options = [];
    this.syntax = type_pb_js_1.Syntax.PROTO2;
    proto3_js_1.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Method().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Method().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Method().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1.proto3.util.equals(Method, a, b);
  }
}
api_pb.Method = Method;
Method.runtime = proto3_js_1.proto3;
Method.typeName = "google.protobuf.Method";
Method.fields = proto3_js_1.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "request_type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "request_streaming",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 4,
    name: "response_type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "response_streaming",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  { no: 6, name: "options", kind: "message", T: type_pb_js_1.Option, repeated: true },
  { no: 7, name: "syntax", kind: "enum", T: proto3_js_1.proto3.getEnumType(type_pb_js_1.Syntax) }
]);
class Mixin extends message_js_1.Message {
  constructor(data) {
    super();
    this.name = "";
    this.root = "";
    proto3_js_1.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Mixin().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Mixin().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Mixin().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3_js_1.proto3.util.equals(Mixin, a, b);
  }
}
api_pb.Mixin = Mixin;
Mixin.runtime = proto3_js_1.proto3;
Mixin.typeName = "google.protobuf.Mixin";
Mixin.fields = proto3_js_1.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "root",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toPlainMessage = exports.createRegistryFromDescriptors = exports.createRegistry = exports.createDescriptorSet = exports.BinaryReader = exports.BinaryWriter = exports.WireType = exports.MethodIdempotency = exports.MethodKind = exports.clearExtension = exports.hasExtension = exports.setExtension = exports.getExtension = exports.ScalarType = exports.LongType = exports.isMessage = exports.Message = exports.codegenInfo = exports.protoDelimited = exports.protoBase64 = exports.protoInt64 = exports.protoDouble = exports.proto2 = exports.proto3 = void 0;
  var proto3_js_12 = proto3;
  Object.defineProperty(exports, "proto3", { enumerable: true, get: function() {
    return proto3_js_12.proto3;
  } });
  var proto2_js_12 = proto2;
  Object.defineProperty(exports, "proto2", { enumerable: true, get: function() {
    return proto2_js_12.proto2;
  } });
  var proto_double_js_1 = protoDouble;
  Object.defineProperty(exports, "protoDouble", { enumerable: true, get: function() {
    return proto_double_js_1.protoDouble;
  } });
  var proto_int64_js_12 = protoInt64;
  Object.defineProperty(exports, "protoInt64", { enumerable: true, get: function() {
    return proto_int64_js_12.protoInt64;
  } });
  var proto_base64_js_12 = protoBase64;
  Object.defineProperty(exports, "protoBase64", { enumerable: true, get: function() {
    return proto_base64_js_12.protoBase64;
  } });
  var proto_delimited_js_1 = protoDelimited;
  Object.defineProperty(exports, "protoDelimited", { enumerable: true, get: function() {
    return proto_delimited_js_1.protoDelimited;
  } });
  var codegen_info_js_1 = codegenInfo;
  Object.defineProperty(exports, "codegenInfo", { enumerable: true, get: function() {
    return codegen_info_js_1.codegenInfo;
  } });
  var message_js_12 = message;
  Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
    return message_js_12.Message;
  } });
  var is_message_js_12 = isMessage$1;
  Object.defineProperty(exports, "isMessage", { enumerable: true, get: function() {
    return is_message_js_12.isMessage;
  } });
  var scalar_js_12 = scalar;
  Object.defineProperty(exports, "LongType", { enumerable: true, get: function() {
    return scalar_js_12.LongType;
  } });
  Object.defineProperty(exports, "ScalarType", { enumerable: true, get: function() {
    return scalar_js_12.ScalarType;
  } });
  var extension_accessor_js_12 = extensionAccessor;
  Object.defineProperty(exports, "getExtension", { enumerable: true, get: function() {
    return extension_accessor_js_12.getExtension;
  } });
  Object.defineProperty(exports, "setExtension", { enumerable: true, get: function() {
    return extension_accessor_js_12.setExtension;
  } });
  Object.defineProperty(exports, "hasExtension", { enumerable: true, get: function() {
    return extension_accessor_js_12.hasExtension;
  } });
  Object.defineProperty(exports, "clearExtension", { enumerable: true, get: function() {
    return extension_accessor_js_12.clearExtension;
  } });
  var service_type_js_12 = serviceType;
  Object.defineProperty(exports, "MethodKind", { enumerable: true, get: function() {
    return service_type_js_12.MethodKind;
  } });
  Object.defineProperty(exports, "MethodIdempotency", { enumerable: true, get: function() {
    return service_type_js_12.MethodIdempotency;
  } });
  var binary_encoding_js_12 = binaryEncoding;
  Object.defineProperty(exports, "WireType", { enumerable: true, get: function() {
    return binary_encoding_js_12.WireType;
  } });
  Object.defineProperty(exports, "BinaryWriter", { enumerable: true, get: function() {
    return binary_encoding_js_12.BinaryWriter;
  } });
  Object.defineProperty(exports, "BinaryReader", { enumerable: true, get: function() {
    return binary_encoding_js_12.BinaryReader;
  } });
  var create_descriptor_set_js_12 = createDescriptorSet$1;
  Object.defineProperty(exports, "createDescriptorSet", { enumerable: true, get: function() {
    return create_descriptor_set_js_12.createDescriptorSet;
  } });
  var create_registry_js_1 = createRegistry$1;
  Object.defineProperty(exports, "createRegistry", { enumerable: true, get: function() {
    return create_registry_js_1.createRegistry;
  } });
  var create_registry_from_desc_js_1 = createRegistryFromDesc;
  Object.defineProperty(exports, "createRegistryFromDescriptors", { enumerable: true, get: function() {
    return create_registry_from_desc_js_1.createRegistryFromDescriptors;
  } });
  var to_plain_message_js_1 = toPlainMessage$1;
  Object.defineProperty(exports, "toPlainMessage", { enumerable: true, get: function() {
    return to_plain_message_js_1.toPlainMessage;
  } });
  __exportStar2(plugin_pb, exports);
  __exportStar2(api_pb, exports);
  __exportStar2(any_pb, exports);
  __exportStar2(descriptor_pb, exports);
  __exportStar2(duration_pb, exports);
  __exportStar2(empty_pb, exports);
  __exportStar2(field_mask_pb, exports);
  __exportStar2(source_context_pb, exports);
  __exportStar2(struct_pb, exports);
  __exportStar2(timestamp_pb, exports);
  __exportStar2(type_pb, exports);
  __exportStar2(wrappers_pb, exports);
})(cjs);
Object.defineProperty(contract_pb, "__esModule", { value: true });
contract_pb.TriggerSmartContract = contract_pb.TransferAssetContract = contract_pb.TransferContract = void 0;
const protobuf_1$8 = cjs;
class TransferContract extends protobuf_1$8.Message {
  constructor(data) {
    super();
    this.ownerAddress = new Uint8Array(0);
    this.toAddress = new Uint8Array(0);
    this.amount = protobuf_1$8.protoInt64.zero;
    protobuf_1$8.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new TransferContract().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new TransferContract().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new TransferContract().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$8.proto3.util.equals(TransferContract, a, b);
  }
}
TransferContract.runtime = protobuf_1$8.proto3;
TransferContract.typeName = "protocol.TransferContract";
TransferContract.fields = protobuf_1$8.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "owner_address",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "to_address",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 3,
    name: "amount",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }
]);
contract_pb.TransferContract = TransferContract;
class TransferAssetContract extends protobuf_1$8.Message {
  constructor(data) {
    super();
    this.assetName = new Uint8Array(0);
    this.ownerAddress = new Uint8Array(0);
    this.toAddress = new Uint8Array(0);
    this.amount = protobuf_1$8.protoInt64.zero;
    protobuf_1$8.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new TransferAssetContract().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new TransferAssetContract().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new TransferAssetContract().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$8.proto3.util.equals(TransferAssetContract, a, b);
  }
}
TransferAssetContract.runtime = protobuf_1$8.proto3;
TransferAssetContract.typeName = "protocol.TransferAssetContract";
TransferAssetContract.fields = protobuf_1$8.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "asset_name",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "owner_address",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 3,
    name: "to_address",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 4,
    name: "amount",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }
]);
contract_pb.TransferAssetContract = TransferAssetContract;
class TriggerSmartContract extends protobuf_1$8.Message {
  constructor(data) {
    super();
    this.ownerAddress = new Uint8Array(0);
    this.contractAddress = new Uint8Array(0);
    this.callValue = protobuf_1$8.protoInt64.zero;
    this.data = new Uint8Array(0);
    this.callTokenValue = protobuf_1$8.protoInt64.zero;
    this.tokenId = protobuf_1$8.protoInt64.zero;
    protobuf_1$8.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new TriggerSmartContract().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new TriggerSmartContract().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new TriggerSmartContract().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$8.proto3.util.equals(TriggerSmartContract, a, b);
  }
}
TriggerSmartContract.runtime = protobuf_1$8.proto3;
TriggerSmartContract.typeName = "protocol.TriggerSmartContract";
TriggerSmartContract.fields = protobuf_1$8.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "owner_address",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "contract_address",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 3,
    name: "call_value",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 4,
    name: "data",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 5,
    name: "call_token_value",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 6,
    name: "token_id",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }
]);
contract_pb.TriggerSmartContract = TriggerSmartContract;
var tron_pb = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Transaction_raw = exports.Transaction_Contract_ContractType = exports.Transaction_Contract = exports.Transaction = exports.authority = exports.AccountId = void 0;
  const protobuf_12 = cjs;
  class AccountId extends protobuf_12.Message {
    constructor(data) {
      super();
      this.name = new Uint8Array(0);
      this.address = new Uint8Array(0);
      protobuf_12.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes2, options) {
      return new AccountId().fromBinary(bytes2, options);
    }
    static fromJson(jsonValue, options) {
      return new AccountId().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AccountId().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return protobuf_12.proto3.util.equals(AccountId, a, b);
    }
  }
  AccountId.runtime = protobuf_12.proto3;
  AccountId.typeName = "protocol.AccountId";
  AccountId.fields = protobuf_12.proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "address",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  exports.AccountId = AccountId;
  class authority extends protobuf_12.Message {
    constructor(data) {
      super();
      this.permissionName = new Uint8Array(0);
      protobuf_12.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes2, options) {
      return new authority().fromBinary(bytes2, options);
    }
    static fromJson(jsonValue, options) {
      return new authority().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new authority().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return protobuf_12.proto3.util.equals(authority, a, b);
    }
  }
  authority.runtime = protobuf_12.proto3;
  authority.typeName = "protocol.authority";
  authority.fields = protobuf_12.proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: AccountId },
    {
      no: 2,
      name: "permission_name",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  exports.authority = authority;
  class Transaction2 extends protobuf_12.Message {
    constructor(data) {
      super();
      this.signature = [];
      protobuf_12.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes2, options) {
      return new Transaction2().fromBinary(bytes2, options);
    }
    static fromJson(jsonValue, options) {
      return new Transaction2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Transaction2().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return protobuf_12.proto3.util.equals(Transaction2, a, b);
    }
  }
  Transaction2.runtime = protobuf_12.proto3;
  Transaction2.typeName = "protocol.Transaction";
  Transaction2.fields = protobuf_12.proto3.util.newFieldList(() => [
    { no: 1, name: "raw_data", kind: "message", T: Transaction_raw },
    { no: 2, name: "signature", kind: "scalar", T: 12, repeated: true }
  ]);
  exports.Transaction = Transaction2;
  class Transaction_Contract extends protobuf_12.Message {
    constructor(data) {
      super();
      this.type = Transaction_Contract_ContractType.AccountCreateContract;
      this.provider = new Uint8Array(0);
      this.ContractName = new Uint8Array(0);
      this.PermissionId = 0;
      protobuf_12.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes2, options) {
      return new Transaction_Contract().fromBinary(bytes2, options);
    }
    static fromJson(jsonValue, options) {
      return new Transaction_Contract().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Transaction_Contract().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return protobuf_12.proto3.util.equals(Transaction_Contract, a, b);
    }
  }
  Transaction_Contract.runtime = protobuf_12.proto3;
  Transaction_Contract.typeName = "protocol.Transaction.Contract";
  Transaction_Contract.fields = protobuf_12.proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: protobuf_12.proto3.getEnumType(Transaction_Contract_ContractType) },
    { no: 2, name: "parameter", kind: "message", T: protobuf_12.Any },
    {
      no: 3,
      name: "provider",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "ContractName",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "Permission_id",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  exports.Transaction_Contract = Transaction_Contract;
  var Transaction_Contract_ContractType;
  (function(Transaction_Contract_ContractType2) {
    Transaction_Contract_ContractType2[Transaction_Contract_ContractType2["AccountCreateContract"] = 0] = "AccountCreateContract";
    Transaction_Contract_ContractType2[Transaction_Contract_ContractType2["TransferContract"] = 1] = "TransferContract";
    Transaction_Contract_ContractType2[Transaction_Contract_ContractType2["TransferAssetContract"] = 2] = "TransferAssetContract";
    Transaction_Contract_ContractType2[Transaction_Contract_ContractType2["TriggerSmartContract"] = 31] = "TriggerSmartContract";
  })(Transaction_Contract_ContractType = exports.Transaction_Contract_ContractType || (exports.Transaction_Contract_ContractType = {}));
  protobuf_12.proto3.util.setEnumType(Transaction_Contract_ContractType, "protocol.Transaction.Contract.ContractType", [
    { no: 0, name: "AccountCreateContract" },
    { no: 1, name: "TransferContract" },
    { no: 2, name: "TransferAssetContract" },
    { no: 31, name: "TriggerSmartContract" }
  ]);
  class Transaction_raw extends protobuf_12.Message {
    constructor(data) {
      super();
      this.refBlockBytes = new Uint8Array(0);
      this.refBlockNum = protobuf_12.protoInt64.zero;
      this.refBlockHash = new Uint8Array(0);
      this.expiration = protobuf_12.protoInt64.zero;
      this.auths = [];
      this.data = new Uint8Array(0);
      this.contract = [];
      this.scripts = new Uint8Array(0);
      this.timestamp = protobuf_12.protoInt64.zero;
      this.feeLimit = protobuf_12.protoInt64.zero;
      protobuf_12.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes2, options) {
      return new Transaction_raw().fromBinary(bytes2, options);
    }
    static fromJson(jsonValue, options) {
      return new Transaction_raw().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Transaction_raw().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return protobuf_12.proto3.util.equals(Transaction_raw, a, b);
    }
  }
  Transaction_raw.runtime = protobuf_12.proto3;
  Transaction_raw.typeName = "protocol.Transaction.raw";
  Transaction_raw.fields = protobuf_12.proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "ref_block_bytes",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "ref_block_num",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: "ref_block_hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "expiration",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    { no: 9, name: "auths", kind: "message", T: authority, repeated: true },
    {
      no: 10,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 11, name: "contract", kind: "message", T: Transaction_Contract, repeated: true },
    {
      no: 12,
      name: "scripts",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 14,
      name: "timestamp",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 18,
      name: "fee_limit",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]);
  exports.Transaction_raw = Transaction_raw;
})(tron_pb);
var tron_transaction_pb = {};
Object.defineProperty(tron_transaction_pb, "__esModule", { value: true });
tron_transaction_pb.TronTx = tron_transaction_pb.Override = tron_transaction_pb.LatestBlock = void 0;
const protobuf_1$7 = cjs;
class LatestBlock extends protobuf_1$7.Message {
  constructor(data) {
    super();
    this.hash = "";
    this.number = 0;
    this.timestamp = protobuf_1$7.protoInt64.zero;
    protobuf_1$7.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new LatestBlock().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new LatestBlock().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new LatestBlock().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$7.proto3.util.equals(LatestBlock, a, b);
  }
}
LatestBlock.runtime = protobuf_1$7.proto3;
LatestBlock.typeName = "protoc.LatestBlock";
LatestBlock.fields = protobuf_1$7.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "hash",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "number",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }
]);
tron_transaction_pb.LatestBlock = LatestBlock;
class Override extends protobuf_1$7.Message {
  constructor(data) {
    super();
    this.tokenShortName = "";
    this.tokenFullName = "";
    this.decimals = 0;
    protobuf_1$7.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Override().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Override().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Override().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$7.proto3.util.equals(Override, a, b);
  }
}
Override.runtime = protobuf_1$7.proto3;
Override.typeName = "protoc.Override";
Override.fields = protobuf_1$7.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "tokenShortName",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "tokenFullName",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "decimals",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);
tron_transaction_pb.Override = Override;
class TronTx extends protobuf_1$7.Message {
  constructor(data) {
    super();
    this.token = "";
    this.contractAddress = "";
    this.from = "";
    this.to = "";
    this.memo = "";
    this.value = "";
    this.fee = 0;
    protobuf_1$7.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new TronTx().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new TronTx().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new TronTx().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$7.proto3.util.equals(TronTx, a, b);
  }
}
TronTx.runtime = protobuf_1$7.proto3;
TronTx.typeName = "protoc.TronTx";
TronTx.fields = protobuf_1$7.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "contractAddress",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "from",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "to",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "memo",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 6,
    name: "value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 7, name: "latestBlock", kind: "message", T: LatestBlock },
  { no: 8, name: "override", kind: "message", T: Override },
  {
    no: 9,
    name: "fee",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);
tron_transaction_pb.TronTx = TronTx;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(transfer, "__esModule", { value: true });
transfer.raw2tx = void 0;
const bs58check_1 = __importDefault$1(bs58check);
const contract_pb_1 = contract_pb;
const tron_pb_1 = tron_pb;
const utils_1$c = utils$k;
const tron_transaction_pb_1$1 = tron_transaction_pb;
function formatAddress(address2) {
  return bs58check_1.default.encode(address2);
}
function raw2tx(signData2, tokenInfo) {
  let rawData;
  try {
    rawData = tron_pb_1.Transaction_raw.fromBinary(signData2);
  } catch (e) {
    throw new Error("Sign data is invalid");
  }
  const override = tokenInfo !== void 0 ? {
    decimals: tokenInfo.decimals,
    tokenFullName: tokenInfo.name,
    tokenShortName: tokenInfo.symbol
  } : null;
  const refBlockHash = Buffer$1$1.from([...new Uint8Array(8).fill(0), ...rawData.refBlockHash, ...new Uint8Array(16).fill(0)]);
  const latestBlock = new tron_transaction_pb_1$1.LatestBlock({
    hash: (0, utils_1$c.toHex)(refBlockHash),
    number: Number(`0x${(0, utils_1$c.toHex)(rawData.refBlockBytes.slice(0, 2))}`),
    timestamp: BigInt(Number(rawData.expiration) - 600 * 5 * 1e3)
  });
  const contractData = rawData.contract[0];
  if (contractData.parameter === void 0) {
    throw new Error("contract is invalid");
  }
  let contract;
  switch (contractData.type) {
    case tron_pb_1.Transaction_Contract_ContractType.TransferContract:
      try {
        contract = contract_pb_1.TransferContract.fromBinary(contractData.parameter.value);
      } catch (e) {
        throw new Error("sign data is invalid");
      }
      return new tron_transaction_pb_1$1.TronTx({
        fee: Number(rawData.feeLimit),
        from: formatAddress(contract.ownerAddress),
        latestBlock,
        to: formatAddress(contract.toAddress),
        token: "TRX",
        value: contract.amount.toString()
      });
    case tron_pb_1.Transaction_Contract_ContractType.TransferAssetContract:
      try {
        contract = contract_pb_1.TransferAssetContract.fromBinary(contractData.parameter.value);
      } catch (e) {
        throw new Error("sign data is invalid");
      }
      if (override == null) {
        throw new Error("token info is invalid");
      }
      return new tron_transaction_pb_1$1.TronTx({
        fee: Number(rawData.feeLimit),
        from: formatAddress(contract.ownerAddress),
        latestBlock,
        override,
        to: formatAddress(contract.toAddress),
        token: Buffer$1$1.from(contract.assetName).toString(),
        value: contract.amount.toString()
      });
    case tron_pb_1.Transaction_Contract_ContractType.TriggerSmartContract:
      try {
        contract = contract_pb_1.TriggerSmartContract.fromBinary(contractData.parameter.value);
      } catch (e) {
        throw new Error("sign data is invalid");
      }
      if (override == null) {
        throw new Error("token info is invalid");
      }
      return new tron_transaction_pb_1$1.TronTx({
        contractAddress: formatAddress(contract.contractAddress),
        fee: Number(rawData.feeLimit),
        from: formatAddress(contract.ownerAddress),
        latestBlock,
        override,
        to: formatAddress(Buffer$1$1.from([65, ...contract.data.slice(16, 36)])),
        value: BigInt(`0x${Buffer$1$1.from(contract.data.slice(36, 68)).toString("hex")}`).toString()
      });
    default:
      throw new Error("contract is not supported");
  }
}
transfer.raw2tx = raw2tx;
var pako = {};
var deflate$4 = {};
var deflate$3 = {};
var trees = {};
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist2) => {
  return dist2 < 256 ? _dist_code[dist2] : _dist_code[256 + (dist2 >>> 7)];
};
const put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
const send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
const send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
const bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
const gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base2 = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f2;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base2) {
      xbits = extra[n - base2];
    }
    f2 = tree[n * 2];
    s.opt_len += f2 * (bits + xbits);
    if (has_stree) {
      s.static_len += f2 * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist2;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist2 = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist2;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist2++] = code;
    }
  }
  dist2 >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist2 << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist2++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
const bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
const smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
const pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
const compress_block = (s, ltree, dtree) => {
  let dist2;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist2 = s.pending_buf[s.sym_buf + sx++] & 255;
      dist2 += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist2 === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist2--;
        code = d_code(dist2);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist2 -= base_dist[code];
          send_bits(s, dist2, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
const build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
const _tr_tally$1 = (s, dist2, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist2;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist2 >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist2 === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist2--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist2) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
trees._tr_init = _tr_init$1;
trees._tr_stored_block = _tr_stored_block$1;
trees._tr_flush_block = _tr_flush_block$1;
trees._tr_tally = _tr_tally$1;
trees._tr_align = _tr_align$1;
const adler32$2 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32$2;
const makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32$2 = (crc2, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc2 ^= -1;
  for (let i = pos; i < end; i++) {
    crc2 = crc2 >>> 8 ^ t[(crc2 ^ buf[i]) & 255];
  }
  return crc2 ^ -1;
};
var crc32_1 = crc32$2;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const adler32$1 = adler32_1;
const crc32$1 = crc32_1;
const msg$2 = messages;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = msg$2[errorCode];
  return errorCode;
};
const rank = (f2) => {
  return f2 * 2 - (f2 > 4 ? 9 : 0);
};
const zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
const read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
const fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
const deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next2 = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next2;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
deflate$3.deflateInit = deflateInit;
deflate$3.deflateInit2 = deflateInit2;
deflate$3.deflateReset = deflateReset;
deflate$3.deflateResetKeep = deflateResetKeep;
deflate$3.deflateSetHeader = deflateSetHeader;
deflate$3.deflate = deflate$2;
deflate$3.deflateEnd = deflateEnd;
deflate$3.deflateSetDictionary = deflateSetDictionary;
deflate$3.deflateInfo = "pako deflate (from Nodeca project)";
var common = {};
const _has = (obj, key2) => {
  return Object.prototype.hasOwnProperty.call(obj, key2);
};
common.assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
common.flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var strings$2 = {};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
strings$2.string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
strings$2.buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
strings$2.utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
function ZStream$2() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream$2;
const zlib_deflate = deflate$3;
const utils$2 = common;
const strings$1 = strings$2;
const msg$1 = messages;
const ZStream$1 = zstream;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = utils$2.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream$1();
  this.strm.avail_out = 0;
  let status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(msg$1[status]);
  }
  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings$1.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = zlib_deflate.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(msg$1[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings$1.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = zlib_deflate.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = utils$2.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || msg$1[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
deflate$4.Deflate = Deflate$1;
deflate$4.deflate = deflate$1;
deflate$4.deflateRaw = deflateRaw$1;
deflate$4.gzip = gzip$1;
deflate$4.constants = constants$2;
var inflate$4 = {};
var inflate$3 = {};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist2;
  let from;
  let from_source;
  let input, output2;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist2 = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist2 += hold & (1 << op) - 1;
                  if (dist2 > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist2 > op) {
                    op = dist2 - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist2;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output2[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output2;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist2;
                        from_source = output2;
                      }
                    }
                    while (len > 2) {
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output2[_out++] = from_source[from++];
                      if (len > 1) {
                        output2[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist2;
                    do {
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output2[_out++] = output2[from++];
                      if (len > 1) {
                        output2[_out++] = output2[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table$1 = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask2;
  let next2;
  let base2 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base2 = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base2 = lbase;
    extra = lext;
    match = 257;
  } else {
    base2 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next2 = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask2 = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base2[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask2) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next2 += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask2;
      table[low] = root << 24 | curr << 16 | next2 - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table$1;
const adler32 = adler32_1;
const crc32 = crc32_1;
const inflate_fast2 = inffast;
const inflate_table = inftrees;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src2, end, copy) => {
  let dist2;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src2.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist2 = state.wsize - state.wnext;
    if (dist2 > copy) {
      dist2 = copy;
    }
    state.window.set(src2.subarray(end - copy, end - copy + dist2), state.wnext);
    copy -= dist2;
    if (copy) {
      state.window.set(src2.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist2;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist2;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output2;
  let next2;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next2 = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next2,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next2 + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32(state.check, input, copy, next2);
              }
              have -= copy;
              next2 += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next2 + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32(state.check, input, copy, next2);
            }
            have -= copy;
            next2 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next2 + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32(state.check, input, copy, next2);
            }
            have -= copy;
            next2 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output2.set(input.subarray(next2, next2 + copy), put);
            have -= copy;
            next2 += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inflate_fast2(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next2 = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output2;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output2[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next2++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32(state.check, output2, _out, put - _out) : adler32(state.check, output2, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next2;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output2, _out, strm.next_out - _out) : adler32(state.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
inflate$3.inflateReset = inflateReset;
inflate$3.inflateReset2 = inflateReset2;
inflate$3.inflateResetKeep = inflateResetKeep;
inflate$3.inflateInit = inflateInit;
inflate$3.inflateInit2 = inflateInit2;
inflate$3.inflate = inflate$2;
inflate$3.inflateEnd = inflateEnd;
inflate$3.inflateGetHeader = inflateGetHeader;
inflate$3.inflateSetDictionary = inflateSetDictionary;
inflate$3.inflateInfo = "pako inflate (from Nodeca project)";
function GZheader$1() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader$1;
const zlib_inflate = inflate$3;
const utils$1 = common;
const strings = strings$2;
const msg = messages;
const ZStream = zstream;
const GZheader = gzheader;
const toString = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = utils$1.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  let status = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }
  this.header = new GZheader();
  zlib_inflate.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_inflate.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = zlib_inflate.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      zlib_inflate.inflateReset(strm);
      status = zlib_inflate.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$1.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || msg[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
inflate$4.Inflate = Inflate$1;
inflate$4.inflate = inflate$1;
inflate$4.inflateRaw = inflateRaw$1;
inflate$4.ungzip = inflate$1;
inflate$4.constants = constants$2;
const { Deflate, deflate, deflateRaw, gzip } = deflate$4;
const { Inflate, inflate, inflateRaw, ungzip } = inflate$4;
const constants$1 = constants$2;
pako.Deflate = Deflate;
pako.deflate = deflate;
pako.deflateRaw = deflateRaw;
pako.gzip = gzip;
pako.Inflate = Inflate;
pako.inflate = inflate;
pako.inflateRaw = inflateRaw;
pako.ungzip = ungzip;
pako.constants = constants$1;
var base_pb = {};
var payload_pb = {};
var transaction_pb = {};
var bch_transaction_pb = {};
var btc_transaction_pb = {};
Object.defineProperty(btc_transaction_pb, "__esModule", { value: true });
btc_transaction_pb.Output = btc_transaction_pb.utxo = btc_transaction_pb.Input = btc_transaction_pb.Omni = btc_transaction_pb.BtcTx = void 0;
const protobuf_1$6 = cjs;
class BtcTx extends protobuf_1$6.Message {
  constructor(data) {
    super();
    this.fee = protobuf_1$6.protoInt64.zero;
    this.dustThreshold = 0;
    this.memo = "";
    this.inputs = [];
    this.outputs = [];
    protobuf_1$6.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new BtcTx().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new BtcTx().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new BtcTx().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$6.proto3.util.equals(BtcTx, a, b);
  }
}
BtcTx.runtime = protobuf_1$6.proto3;
BtcTx.typeName = "protoc.BtcTx";
BtcTx.fields = protobuf_1$6.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "fee",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "dustThreshold",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "memo",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 4, name: "inputs", kind: "message", T: Input, repeated: true },
  { no: 5, name: "outputs", kind: "message", T: Output, repeated: true },
  { no: 6, name: "omni", kind: "message", T: Omni }
]);
btc_transaction_pb.BtcTx = BtcTx;
class Omni extends protobuf_1$6.Message {
  constructor(data) {
    super();
    this.to = "";
    this.changeAddress = "";
    this.omniAmount = protobuf_1$6.protoInt64.zero;
    this.propertyId = 0;
    protobuf_1$6.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Omni().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Omni().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Omni().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$6.proto3.util.equals(Omni, a, b);
  }
}
Omni.runtime = protobuf_1$6.proto3;
Omni.typeName = "protoc.Omni";
Omni.fields = protobuf_1$6.proto3.util.newFieldList(() => [
  {
    no: 5,
    name: "to",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 6,
    name: "changeAddress",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 7,
    name: "omniAmount",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 8,
    name: "propertyId",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);
btc_transaction_pb.Omni = Omni;
class Input extends protobuf_1$6.Message {
  constructor(data) {
    super();
    this.hash = "";
    this.index = 0;
    this.ownerKeyPath = "";
    protobuf_1$6.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Input().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Input().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Input().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$6.proto3.util.equals(Input, a, b);
  }
}
Input.runtime = protobuf_1$6.proto3;
Input.typeName = "protoc.Input";
Input.fields = protobuf_1$6.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "hash",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "index",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  { no: 3, name: "utxo", kind: "message", T: utxo },
  {
    no: 4,
    name: "ownerKeyPath",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
btc_transaction_pb.Input = Input;
class utxo extends protobuf_1$6.Message {
  constructor(data) {
    super();
    this.publicKey = "";
    this.script = "";
    this.value = protobuf_1$6.protoInt64.zero;
    protobuf_1$6.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new utxo().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new utxo().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new utxo().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$6.proto3.util.equals(utxo, a, b);
  }
}
utxo.runtime = protobuf_1$6.proto3;
utxo.typeName = "protoc.utxo";
utxo.fields = protobuf_1$6.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "publicKey",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "script",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "value",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }
]);
btc_transaction_pb.utxo = utxo;
class Output extends protobuf_1$6.Message {
  constructor(data) {
    super();
    this.address = "";
    this.value = protobuf_1$6.protoInt64.zero;
    this.isChange = false;
    this.changeAddressPath = "";
    protobuf_1$6.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Output().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Output().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Output().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$6.proto3.util.equals(Output, a, b);
  }
}
Output.runtime = protobuf_1$6.proto3;
Output.typeName = "protoc.Output";
Output.fields = protobuf_1$6.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "address",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "value",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 3,
    name: "isChange",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 4,
    name: "changeAddressPath",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
btc_transaction_pb.Output = Output;
Object.defineProperty(bch_transaction_pb, "__esModule", { value: true });
bch_transaction_pb.BchTx_Input = bch_transaction_pb.BchTx = void 0;
const protobuf_1$5 = cjs;
const btc_transaction_pb_1$2 = btc_transaction_pb;
class BchTx extends protobuf_1$5.Message {
  constructor(data) {
    super();
    this.fee = protobuf_1$5.protoInt64.zero;
    this.dustThreshold = 0;
    this.memo = "";
    this.inputs = [];
    this.outputs = [];
    protobuf_1$5.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new BchTx().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new BchTx().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new BchTx().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$5.proto3.util.equals(BchTx, a, b);
  }
}
BchTx.runtime = protobuf_1$5.proto3;
BchTx.typeName = "protoc.BchTx";
BchTx.fields = protobuf_1$5.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "fee",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "dustThreshold",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "memo",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 4, name: "inputs", kind: "message", T: BchTx_Input, repeated: true },
  { no: 5, name: "outputs", kind: "message", T: btc_transaction_pb_1$2.Output, repeated: true }
]);
bch_transaction_pb.BchTx = BchTx;
class BchTx_Input extends protobuf_1$5.Message {
  constructor(data) {
    super();
    this.hash = "";
    this.index = 0;
    this.value = protobuf_1$5.protoInt64.zero;
    this.pubkey = "";
    this.ownerKeyPath = "";
    protobuf_1$5.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new BchTx_Input().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new BchTx_Input().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new BchTx_Input().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$5.proto3.util.equals(BchTx_Input, a, b);
  }
}
BchTx_Input.runtime = protobuf_1$5.proto3;
BchTx_Input.typeName = "protoc.BchTx.Input";
BchTx_Input.fields = protobuf_1$5.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "hash",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "index",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "value",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 4,
    name: "pubkey",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "ownerKeyPath",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
bch_transaction_pb.BchTx_Input = BchTx_Input;
var dash_transaction_pb = {};
Object.defineProperty(dash_transaction_pb, "__esModule", { value: true });
dash_transaction_pb.DashTx_Input = dash_transaction_pb.DashTx = void 0;
const protobuf_1$4 = cjs;
const btc_transaction_pb_1$1 = btc_transaction_pb;
class DashTx extends protobuf_1$4.Message {
  constructor(data) {
    super();
    this.fee = protobuf_1$4.protoInt64.zero;
    this.dustThreshold = 0;
    this.memo = "";
    this.inputs = [];
    this.outputs = [];
    protobuf_1$4.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new DashTx().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new DashTx().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new DashTx().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$4.proto3.util.equals(DashTx, a, b);
  }
}
DashTx.runtime = protobuf_1$4.proto3;
DashTx.typeName = "protoc.DashTx";
DashTx.fields = protobuf_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "fee",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "dustThreshold",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "memo",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 4, name: "inputs", kind: "message", T: DashTx_Input, repeated: true },
  { no: 5, name: "outputs", kind: "message", T: btc_transaction_pb_1$1.Output, repeated: true }
]);
dash_transaction_pb.DashTx = DashTx;
class DashTx_Input extends protobuf_1$4.Message {
  constructor(data) {
    super();
    this.hash = "";
    this.index = 0;
    this.value = protobuf_1$4.protoInt64.zero;
    this.pubkey = "";
    this.ownerKeyPath = "";
    protobuf_1$4.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new DashTx_Input().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new DashTx_Input().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new DashTx_Input().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$4.proto3.util.equals(DashTx_Input, a, b);
  }
}
DashTx_Input.runtime = protobuf_1$4.proto3;
DashTx_Input.typeName = "protoc.DashTx.Input";
DashTx_Input.fields = protobuf_1$4.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "hash",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "index",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "value",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 4,
    name: "pubkey",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "ownerKeyPath",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
dash_transaction_pb.DashTx_Input = DashTx_Input;
var ltc_transaction_pb = {};
Object.defineProperty(ltc_transaction_pb, "__esModule", { value: true });
ltc_transaction_pb.LtcTx = void 0;
const protobuf_1$3 = cjs;
const btc_transaction_pb_1 = btc_transaction_pb;
class LtcTx extends protobuf_1$3.Message {
  constructor(data) {
    super();
    this.fee = protobuf_1$3.protoInt64.zero;
    this.dustThreshold = 0;
    this.memo = "";
    this.inputs = [];
    this.outputs = [];
    protobuf_1$3.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new LtcTx().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new LtcTx().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new LtcTx().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$3.proto3.util.equals(LtcTx, a, b);
  }
}
LtcTx.runtime = protobuf_1$3.proto3;
LtcTx.typeName = "protoc.LtcTx";
LtcTx.fields = protobuf_1$3.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "fee",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "dustThreshold",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "memo",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 4, name: "inputs", kind: "message", T: btc_transaction_pb_1.Input, repeated: true },
  { no: 5, name: "outputs", kind: "message", T: btc_transaction_pb_1.Output, repeated: true }
]);
ltc_transaction_pb.LtcTx = LtcTx;
Object.defineProperty(transaction_pb, "__esModule", { value: true });
transaction_pb.SignTransaction = void 0;
const protobuf_1$2 = cjs;
const tron_transaction_pb_1 = tron_transaction_pb;
const bch_transaction_pb_1 = bch_transaction_pb;
const dash_transaction_pb_1 = dash_transaction_pb;
const ltc_transaction_pb_1 = ltc_transaction_pb;
class SignTransaction extends protobuf_1$2.Message {
  constructor(data) {
    super();
    this.coinCode = "";
    this.signId = "";
    this.hdPath = "";
    this.timestamp = protobuf_1$2.protoInt64.zero;
    this.decimal = 0;
    this.Transaction = { case: void 0 };
    protobuf_1$2.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new SignTransaction().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new SignTransaction().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new SignTransaction().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$2.proto3.util.equals(SignTransaction, a, b);
  }
}
SignTransaction.runtime = protobuf_1$2.proto3;
SignTransaction.typeName = "protoc.SignTransaction";
SignTransaction.fields = protobuf_1$2.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "coinCode",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "signId",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "hdPath",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 5,
    name: "decimal",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  { no: 8, name: "tronTx", kind: "message", T: tron_transaction_pb_1.TronTx, oneof: "Transaction" },
  { no: 10, name: "bchTx", kind: "message", T: bch_transaction_pb_1.BchTx, oneof: "Transaction" },
  { no: 11, name: "dashTx", kind: "message", T: dash_transaction_pb_1.DashTx, oneof: "Transaction" },
  { no: 12, name: "ltcTx", kind: "message", T: ltc_transaction_pb_1.LtcTx, oneof: "Transaction" }
]);
transaction_pb.SignTransaction = SignTransaction;
var sign_transaction_result_pb = {};
Object.defineProperty(sign_transaction_result_pb, "__esModule", { value: true });
sign_transaction_result_pb.SignTransactionResult = void 0;
const protobuf_1$1 = cjs;
class SignTransactionResult extends protobuf_1$1.Message {
  constructor(data) {
    super();
    this.signId = "";
    this.txId = "";
    this.rawTx = "";
    protobuf_1$1.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new SignTransactionResult().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new SignTransactionResult().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new SignTransactionResult().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1$1.proto3.util.equals(SignTransactionResult, a, b);
  }
}
SignTransactionResult.runtime = protobuf_1$1.proto3;
SignTransactionResult.typeName = "protoc.SignTransactionResult";
SignTransactionResult.fields = protobuf_1$1.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "signId",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "txId",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "rawTx",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
sign_transaction_result_pb.SignTransactionResult = SignTransactionResult;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Payload_Type = exports.Payload = void 0;
  const protobuf_12 = cjs;
  const transaction_pb_12 = transaction_pb;
  const sign_transaction_result_pb_1 = sign_transaction_result_pb;
  class Payload extends protobuf_12.Message {
    constructor(data) {
      super();
      this.type = Payload_Type.RESERVE;
      this.xfp = "";
      this.Content = { case: void 0 };
      protobuf_12.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes2, options) {
      return new Payload().fromBinary(bytes2, options);
    }
    static fromJson(jsonValue, options) {
      return new Payload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Payload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return protobuf_12.proto3.util.equals(Payload, a, b);
    }
  }
  Payload.runtime = protobuf_12.proto3;
  Payload.typeName = "protoc.Payload";
  Payload.fields = protobuf_12.proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: protobuf_12.proto3.getEnumType(Payload_Type) },
    {
      no: 2,
      name: "xfp",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "signTx", kind: "message", T: transaction_pb_12.SignTransaction, oneof: "Content" },
    { no: 7, name: "signTxResult", kind: "message", T: sign_transaction_result_pb_1.SignTransactionResult, oneof: "Content" }
  ]);
  exports.Payload = Payload;
  var Payload_Type;
  (function(Payload_Type2) {
    Payload_Type2[Payload_Type2["RESERVE"] = 0] = "RESERVE";
    Payload_Type2[Payload_Type2["SYNC"] = 1] = "SYNC";
    Payload_Type2[Payload_Type2["SIGN_TX"] = 2] = "SIGN_TX";
    Payload_Type2[Payload_Type2["SIGN_MSG"] = 3] = "SIGN_MSG";
    Payload_Type2[Payload_Type2["SIGN_MULTI_SIG"] = 4] = "SIGN_MULTI_SIG";
    Payload_Type2[Payload_Type2["SYNC_MULTI_SIG_MSG"] = 5] = "SYNC_MULTI_SIG_MSG";
    Payload_Type2[Payload_Type2["SIGN_ETH_MULTI_SIG_MSG"] = 6] = "SIGN_ETH_MULTI_SIG_MSG";
    Payload_Type2[Payload_Type2["VERIFY_ADDRESS"] = 7] = "VERIFY_ADDRESS";
    Payload_Type2[Payload_Type2["STAKING"] = 8] = "STAKING";
    Payload_Type2[Payload_Type2["SIGN_TX_RESULT"] = 9] = "SIGN_TX_RESULT";
  })(Payload_Type = exports.Payload_Type || (exports.Payload_Type = {}));
  protobuf_12.proto3.util.setEnumType(Payload_Type, "protoc.Payload.Type", [
    { no: 0, name: "TYPE_RESERVE" },
    { no: 1, name: "TYPE_SYNC" },
    { no: 2, name: "TYPE_SIGN_TX" },
    { no: 3, name: "TYPE_SIGN_MSG" },
    { no: 4, name: "TYPE_SIGN_MULTI_SIG" },
    { no: 5, name: "TYPE_SYNC_MULTI_SIG_MSG" },
    { no: 6, name: "TYPE_SIGN_ETH_MULTI_SIG_MSG" },
    { no: 7, name: "TYPE_VERIFY_ADDRESS" },
    { no: 8, name: "TYPE_STAKING" },
    { no: 9, name: "TYPE_SIGN_TX_RESULT" }
  ]);
})(payload_pb);
Object.defineProperty(base_pb, "__esModule", { value: true });
base_pb.Base = void 0;
const protobuf_1 = cjs;
const payload_pb_1$1 = payload_pb;
class Base extends protobuf_1.Message {
  constructor(data) {
    super();
    this.version = 0;
    this.description = "";
    this.Content = { case: void 0 };
    this.deviceType = "";
    protobuf_1.proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes2, options) {
    return new Base().fromBinary(bytes2, options);
  }
  static fromJson(jsonValue, options) {
    return new Base().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Base().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return protobuf_1.proto3.util.equals(Base, a, b);
  }
}
Base.runtime = protobuf_1.proto3;
Base.typeName = "protoc.Base";
Base.fields = protobuf_1.proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "version",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 2,
    name: "description",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 3, name: "data", kind: "message", T: payload_pb_1$1.Payload },
  { no: 4, name: "hotVersion", kind: "scalar", T: 5, oneof: "Content" },
  { no: 5, name: "coldVersion", kind: "scalar", T: 5, oneof: "Content" },
  {
    no: 6,
    name: "deviceType",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
base_pb.Base = Base;
var dist$9 = { exports: {} };
var bcUrRegistryKeystone_cjs_production_min = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist();
  const e = { KEYSTONE_SIGN_REQUEST: new t.RegistryType("keystone-sign-request", 6101), KEYSTONE_SIGN_RESULT: new t.RegistryType("keystone-sign-result", 6102) }, { decodeToDataItem: s } = t.extend;
  var n;
  !function(t2) {
    t2[t2.signData = 1] = "signData", t2[t2.origin = 2] = "origin";
  }(n || (n = {}));
  class i extends t.RegistryItem {
    constructor(s2) {
      super(), this.getRegistryType = () => e.KEYSTONE_SIGN_REQUEST, this.getSignData = () => this.signData, this.getOrigin = () => this.origin, this.toDataItem = () => {
        const e2 = {};
        return e2[n.signData] = this.signData, this.origin && (e2[n.origin] = this.origin), new t.DataItem(e2);
      }, this.signData = s2.signData, this.origin = s2.origin;
    }
    static constructKeystoneRequest(t2, e2) {
      return new i({ signData: t2, origin: e2 });
    }
  }
  i.fromDataItem = (t2) => {
    const e2 = t2.getData();
    return new i({ signData: e2[n.signData], origin: e2[n.origin] });
  }, i.fromCBOR = (t2) => {
    const e2 = s(t2);
    return i.fromDataItem(e2);
  };
  const { decodeToDataItem: r } = t.extend;
  var a;
  !function(t2) {
    t2[t2.signResult = 1] = "signResult";
  }(a || (a = {}));
  class g extends t.RegistryItem {
    constructor(s2) {
      super(), this.getRegistryType = () => e.KEYSTONE_SIGN_RESULT, this.getSignResult = () => this.signResult, this.toDataItem = () => {
        const e2 = {};
        return e2[a.signResult] = this.signResult, new t.DataItem(e2);
      }, this.signResult = s2;
    }
  }
  g.fromDataItem = (t2) => {
    const e2 = t2.getData();
    return new g(e2[a.signResult]);
  }, g.fromCBOR = (t2) => {
    const e2 = r(t2);
    return g.fromDataItem(e2);
  }, t.patchTags(Object.values(e).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.KeystoneSignRequest = i, exports.KeystoneSignResult = g;
})(bcUrRegistryKeystone_cjs_production_min);
{
  dist$9.exports = bcUrRegistryKeystone_cjs_production_min;
}
var distExports$7 = dist$9.exports;
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(tron, "__esModule", { value: true });
tron.KeystoneTronSDK = void 0;
const utils_1$b = utils$k;
const ur_1$7 = ur;
const transfer_1 = transfer;
const pako_1 = __importDefault(pako);
const base_pb_1 = base_pb;
const payload_pb_1 = payload_pb;
const transaction_pb_1 = transaction_pb;
const bc_ur_registry_keystone_1 = distExports$7;
class KeystoneTronSDK {
  parseSignature(ur2) {
    var _a, _b, _c, _d;
    if (ur2.type !== ur_1$7.URType.KeystoneSignResult) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_keystone_1.KeystoneSignResult.fromCBOR(ur2.cbor);
    const base2 = base_pb_1.Base.fromBinary(pako_1.default.ungzip(sig.getSignResult()));
    if (((_a = base2.data) === null || _a === void 0 ? void 0 : _a.Content.case) !== "signTxResult") {
      throw new Error("invalid sign result");
    }
    const { signId, rawTx } = (_d = (_c = (_b = base2.data) === null || _b === void 0 ? void 0 : _b.Content) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : {};
    return {
      requestId: signId,
      raw: rawTx
    };
  }
  generateSignRequest({ requestId, signData: signData2, path, xfp, tokenInfo, origin: origin2 }) {
    const tronTx = (0, transfer_1.raw2tx)((0, utils_1$b.toBuffer)(signData2), tokenInfo);
    const signDataBytes = pako_1.default.gzip(new base_pb_1.Base({
      version: 2,
      description: "QrCode Protocol",
      deviceType: "",
      data: new payload_pb_1.Payload({
        xfp,
        type: payload_pb_1.Payload_Type.SIGN_TX,
        Content: {
          case: "signTx",
          value: new transaction_pb_1.SignTransaction({
            coinCode: "TRON",
            hdPath: path,
            signId: requestId,
            timestamp: BigInt(Date.now()),
            decimal: 6,
            Transaction: {
              case: "tronTx",
              value: tronTx
            }
          })
        }
      })
    }).toBinary());
    return new bc_ur_registry_keystone_1.KeystoneSignRequest({
      signData: Buffer$1$1.from(signDataBytes),
      origin: origin2
    }).toUR();
  }
}
tron.KeystoneTronSDK = KeystoneTronSDK;
var aptos = {};
var dist$8 = { exports: {} };
var bcUrRegistryAptos_cjs_production_min = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist(), e = require$$1;
  const i = { APTOS_SIGN_REQUEST: new t.RegistryType("aptos-sign-request", 3101), APTOS_SIGNATURE: new t.RegistryType("aptos-signature", 3102) }, { decodeToDataItem: s, RegistryTypes: n } = t.extend;
  var a, r;
  (a = exports.SignType || (exports.SignType = {}))[a.SingleSign = 1] = "SingleSign", a[a.MultiSign = 2] = "MultiSign", a[a.SignMessage = 3] = "SignMessage", function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.authenticationKeyDerivationPaths = 3] = "authenticationKeyDerivationPaths", t2[t2.accounts = 4] = "accounts", t2[t2.origin = 5] = "origin", t2[t2.signType = 6] = "signType";
  }(r || (r = {}));
  class o extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => i.APTOS_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getAuthenticationKeyDerivationPaths = () => this.authenticationKeyDerivationPaths.map((t2) => t2.getPath()), this.getSignRequestAccounts = () => this.accounts, this.getOrigin = () => this.origin, this.getSignType = () => this.signType, this.toDataItem = () => {
        const e3 = {};
        return e3[r.requestId] = new t.DataItem(this.requestId, n.UUID.getTag()), this.accounts && (e3[r.accounts] = this.accounts), this.origin && (e3[r.origin] = this.origin), e3[r.signData] = this.signData, e3[r.signType] = this.signType, e3[r.authenticationKeyDerivationPaths] = this.authenticationKeyDerivationPaths.map((t2) => {
          const e4 = t2.toDataItem();
          return e4.setTag(t2.getRegistryType().getTag()), e4;
        }), new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.authenticationKeyDerivationPaths = e2.authenticationKeyDerivationPaths, this.accounts = e2.accounts, this.origin = e2.origin, this.signType = e2.signType;
    }
    static constructAptosRequest(i2, s2, n2, a2, r2, u2, g2) {
      const c2 = s2.map((e2, i3) => {
        const s3 = e2.replace(/[m|M]\//, "").split("/").map((e3) => {
          const i4 = parseInt(e3.replace("'", ""));
          let s4 = false;
          return e3.endsWith("'") && (s4 = true), new t.PathComponent({ index: i4, hardened: s4 });
        });
        return new t.CryptoKeypath(s3, Buffer$1$1.from(n2[i3], "hex"));
      });
      return new o({ requestId: Buffer$1$1.from(e.parse(r2)), signData: i2, authenticationKeyDerivationPaths: c2, accounts: u2 || void 0, origin: g2 || void 0, signType: a2 || exports.SignType.SingleSign });
    }
  }
  o.fromDataItem = (e2) => {
    const i2 = e2.getData(), s2 = i2[r.signData], n2 = i2[r.signType], a2 = i2[r.authenticationKeyDerivationPaths].map((e3) => t.CryptoKeypath.fromDataItem(e3)), u2 = i2[r.accounts] ? i2[r.accounts] : void 0, g2 = i2[r.requestId] ? i2[r.requestId].getData() : void 0;
    return new o({ requestId: g2, signData: s2, authenticationKeyDerivationPaths: a2, accounts: u2, origin: i2[r.origin] ? i2[r.origin] : void 0, signType: n2 });
  }, o.fromCBOR = (t2) => {
    const e2 = s(t2);
    return o.fromDataItem(e2);
  };
  const { RegistryTypes: u, decodeToDataItem: g } = t.extend;
  var c;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature", t2[t2.authenticationPublicKey = 3] = "authenticationPublicKey";
  }(c || (c = {}));
  class h extends t.RegistryItem {
    constructor(e2, s2, n2) {
      super(), this.getRegistryType = () => i.APTOS_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.getAuthenticationPublicKey = () => this.authenticationPublicKey, this.toDataItem = () => {
        const e3 = {};
        return e3[c.requestId] = new t.DataItem(this.requestId, u.UUID.getTag()), e3[c.signature] = this.signature, e3[c.authenticationPublicKey] = this.authenticationPublicKey, new t.DataItem(e3);
      }, this.signature = e2, this.requestId = s2, this.authenticationPublicKey = n2;
    }
  }
  h.fromDataItem = (t2) => {
    const e2 = t2.getData(), i2 = e2[c.signature], s2 = e2[c.requestId].getData();
    return new h(i2, s2, e2[c.authenticationPublicKey]);
  }, h.fromCBOR = (t2) => {
    const e2 = g(t2);
    return h.fromDataItem(e2);
  }, t.patchTags(Object.values(i).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.AptosSignRequest = o, exports.AptosSignature = h;
})(bcUrRegistryAptos_cjs_production_min);
{
  dist$8.exports = bcUrRegistryAptos_cjs_production_min;
}
var distExports$6 = dist$8.exports;
Object.defineProperty(aptos, "__esModule", { value: true });
aptos.KeystoneAptosSDK = void 0;
const bc_ur_registry_aptos_1 = distExports$6;
const utils_1$a = utils$k;
const ur_1$6 = ur;
class KeystoneAptosSDK {
  parseSignature(ur2) {
    if (ur2.type !== ur_1$6.URType.AptosSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_aptos_1.AptosSignature.fromCBOR(ur2.cbor);
    return {
      requestId: (0, utils_1$a.uuidStringify)(sig.getRequestId()),
      signature: (0, utils_1$a.toHex)(sig.getSignature()),
      authenticationPublicKey: (0, utils_1$a.toHex)(sig.getAuthenticationPublicKey())
    };
  }
  generateSignRequest({ requestId, signData: signData2, signType, accounts, origin: origin2 }) {
    const authenticationKeyDerivationPaths = [];
    const keys2 = [];
    accounts.forEach((account2) => {
      authenticationKeyDerivationPaths.push(new bc_ur_registry_aptos_1.CryptoKeypath((0, utils_1$a.parsePath)(account2.path).map((e) => new bc_ur_registry_aptos_1.PathComponent(e)), (0, utils_1$a.toBuffer)(account2.xfp)));
      account2.key !== void 0 && keys2.push((0, utils_1$a.toBuffer)(account2.key));
    });
    if (keys2.length > 0 && keys2.length !== authenticationKeyDerivationPaths.length) {
      throw new Error("account and path count must match");
    }
    return new bc_ur_registry_aptos_1.AptosSignRequest({
      requestId: (0, utils_1$a.uuidParse)(requestId),
      signData: (0, utils_1$a.toBuffer)(signData2),
      signType,
      authenticationKeyDerivationPaths,
      accounts: keys2,
      origin: origin2
    }).toUR();
  }
}
KeystoneAptosSDK.SignType = bc_ur_registry_aptos_1.SignType;
aptos.KeystoneAptosSDK = KeystoneAptosSDK;
var bitcoin_cash = {};
var keystone = {};
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Keystone = exports.TXCase = exports.Chain = void 0;
  const pako_12 = __importDefault2(pako);
  const ur_12 = ur;
  const bc_ur_registry_keystone_12 = distExports$7;
  const base_pb_12 = base_pb;
  const payload_pb_12 = payload_pb;
  const transaction_pb_12 = transaction_pb;
  const ltc_transaction_pb_12 = ltc_transaction_pb;
  const bch_transaction_pb_12 = bch_transaction_pb;
  const dash_transaction_pb_12 = dash_transaction_pb;
  var Chain;
  (function(Chain2) {
    Chain2["LTC"] = "LTC";
    Chain2["BCH"] = "BCH";
    Chain2["DASH"] = "DASH";
  })(Chain = exports.Chain || (exports.Chain = {}));
  var TXCase;
  (function(TXCase2) {
    TXCase2["LTC"] = "ltcTx";
    TXCase2["BCH"] = "bchTx";
    TXCase2["DASH"] = "dashTx";
  })(TXCase = exports.TXCase || (exports.TXCase = {}));
  class Keystone {
    generateSignData({ chain, requestId, signData: signData2, xfp }) {
      let tx;
      let txCase;
      let coinCode;
      switch (chain) {
        case Chain.LTC:
          tx = new ltc_transaction_pb_12.LtcTx(Object.assign(Object.assign({}, signData2), { fee: BigInt(signData2.fee), dustThreshold: 5460 }));
          coinCode = Chain.LTC;
          txCase = TXCase.LTC;
          break;
        case Chain.BCH:
          tx = new bch_transaction_pb_12.BchTx(Object.assign(Object.assign({}, signData2), { fee: BigInt(signData2.fee), dustThreshold: 546 }));
          coinCode = Chain.BCH;
          txCase = TXCase.BCH;
          break;
        case Chain.DASH:
          tx = new dash_transaction_pb_12.DashTx(Object.assign(Object.assign({}, signData2), { fee: BigInt(signData2.fee), dustThreshold: 546 }));
          coinCode = Chain.DASH;
          txCase = TXCase.DASH;
          break;
        default:
          throw new Error("chain not support");
      }
      return pako_12.default.gzip(new base_pb_12.Base({
        version: 2,
        description: "QrCode Protocol",
        deviceType: "",
        data: new payload_pb_12.Payload({
          xfp,
          type: payload_pb_12.Payload_Type.SIGN_TX,
          Content: {
            case: "signTx",
            value: new transaction_pb_12.SignTransaction({
              coinCode,
              hdPath: "",
              signId: requestId,
              timestamp: BigInt(Date.now()),
              decimal: 8,
              Transaction: {
                case: txCase,
                value: tx
              }
            })
          }
        })
      }).toBinary());
    }
    generateSignRequest(props2) {
      const signDataBytes = Buffer$1$1.from(this.generateSignData(props2));
      return new bc_ur_registry_keystone_12.KeystoneSignRequest({
        signData: signDataBytes,
        origin: props2.origin
      }).toUR();
    }
    parseSignResult(ur2) {
      var _a, _b;
      if (ur2.type !== ur_12.URType.KeystoneSignResult) {
        throw new Error("type not match");
      }
      const sig = bc_ur_registry_keystone_12.KeystoneSignResult.fromCBOR(ur2.cbor);
      const base2 = base_pb_12.Base.fromBinary(pako_12.default.ungzip(sig.getSignResult()));
      if (((_a = base2.data) === null || _a === void 0 ? void 0 : _a.Content.case) !== "signTxResult") {
        throw new Error("invalid sign result");
      }
      const value = (_b = base2.data) === null || _b === void 0 ? void 0 : _b.Content.value;
      const requestId = value.signId;
      return {
        requestId,
        rawData: value.rawTx
      };
    }
  }
  exports.Keystone = Keystone;
})(keystone);
Object.defineProperty(bitcoin_cash, "__esModule", { value: true });
bitcoin_cash.KeystoneBitcoinCashSDK = void 0;
const keystone_1$2 = keystone;
class KeystoneBitcoinCashSDK extends keystone_1$2.Keystone {
  generateSignRequest(props2) {
    return super.generateSignRequest(Object.assign({ chain: keystone_1$2.Chain.BCH }, props2));
  }
}
bitcoin_cash.KeystoneBitcoinCashSDK = KeystoneBitcoinCashSDK;
var dash = {};
Object.defineProperty(dash, "__esModule", { value: true });
dash.KeystoneDashSDK = void 0;
const keystone_1$1 = keystone;
class KeystoneDashSDK extends keystone_1$1.Keystone {
  generateSignRequest(props2) {
    return super.generateSignRequest(Object.assign({ chain: keystone_1$1.Chain.DASH }, props2));
  }
}
dash.KeystoneDashSDK = KeystoneDashSDK;
var litecoin = {};
Object.defineProperty(litecoin, "__esModule", { value: true });
litecoin.KeystoneLitecoinSDK = void 0;
const keystone_1 = keystone;
class KeystoneLitecoinSDK extends keystone_1.Keystone {
  generateSignRequest(props2) {
    return super.generateSignRequest(Object.assign({ chain: keystone_1.Chain.LTC }, props2));
  }
}
litecoin.KeystoneLitecoinSDK = KeystoneLitecoinSDK;
var near = {};
var dist$7 = { exports: {} };
var bcUrRegistryNear_cjs_production_min = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist(), e = require$$1;
  const i = { NEAR_SIGN_REQUEST: new t.RegistryType("near-sign-request", 2101), NEAR_SIGNATURE: new t.RegistryType("near-signature", 2102), CRYPTO_MULTI_ACCOUNTS: new t.RegistryType("crypto-multi-accounts", 2103) }, { decodeToDataItem: a, RegistryTypes: r } = t.extend;
  var s;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.derivationPath = 3] = "derivationPath", t2[t2.account = 4] = "account", t2[t2.origin = 5] = "origin";
  }(s || (s = {}));
  class n extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => i.NEAR_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDerivationPath = () => this.derivationPath.getPath(), this.getSignRequestAccount = () => this.account, this.getOrigin = () => this.origin, this.toDataItem = () => {
        const e3 = {};
        this.requestId && (e3[s.requestId] = new t.DataItem(this.requestId, r.UUID.getTag())), this.account && (e3[s.account] = this.account), this.origin && (e3[s.origin] = this.origin), e3[s.signData] = this.signData;
        const i2 = this.derivationPath.toDataItem();
        return i2.setTag(this.derivationPath.getRegistryType().getTag()), e3[s.derivationPath] = i2, new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.derivationPath = e2.derivationPath, this.account = e2.account, this.origin = e2.origin;
    }
    static constructNearRequest(i2, a2, r2, s2, o2, u2) {
      const g2 = a2.replace(/[m|M]\//, "").split("/"), c2 = new t.CryptoKeypath(g2.map((e2) => {
        const i3 = parseInt(e2.replace("'", ""));
        let a3 = false;
        return e2.endsWith("'") && (a3 = true), new t.PathComponent({ index: i3, hardened: a3 });
      }), Buffer$1$1.from(r2, "hex"));
      return new n({ requestId: s2 ? Buffer$1$1.from(e.parse(s2)) : void 0, signData: i2, derivationPath: c2, account: o2 || void 0, origin: u2 || void 0 });
    }
  }
  n.fromDataItem = (e2) => {
    const i2 = e2.getData(), a2 = i2[s.signData], r2 = t.CryptoKeypath.fromDataItem(i2[s.derivationPath]), o2 = i2[s.account] ? i2[s.account] : void 0, u2 = i2[s.requestId] ? i2[s.requestId].getData() : void 0;
    return new n({ requestId: u2, signData: a2, derivationPath: r2, account: o2, origin: i2[s.origin] ? i2[s.origin] : void 0 });
  }, n.fromCBOR = (t2) => {
    const e2 = a(t2);
    return n.fromDataItem(e2);
  };
  const { RegistryTypes: o, decodeToDataItem: u } = t.extend;
  var g;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature";
  }(g || (g = {}));
  class c extends t.RegistryItem {
    constructor(e2, a2) {
      super(), this.getRegistryType = () => i.NEAR_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[g.requestId] = new t.DataItem(this.requestId, o.UUID.getTag())), e3[g.signature] = this.signature, new t.DataItem(e3);
      }, this.signature = e2, this.requestId = a2;
    }
  }
  c.fromDataItem = (t2) => {
    const e2 = t2.getData(), i2 = e2[g.signature], a2 = e2[g.requestId] ? e2[g.requestId].getData() : void 0;
    return new c(i2, a2);
  }, c.fromCBOR = (t2) => {
    const e2 = u(t2);
    return c.fromDataItem(e2);
  }, t.patchTags(Object.values(i).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.NearSignRequest = n, exports.NearSignature = c;
})(bcUrRegistryNear_cjs_production_min);
{
  dist$7.exports = bcUrRegistryNear_cjs_production_min;
}
var distExports$5 = dist$7.exports;
Object.defineProperty(near, "__esModule", { value: true });
near.KeystoneNearSDK = void 0;
const utils_1$9 = utils$k;
const ur_1$5 = ur;
const bc_ur_registry_near_1 = distExports$5;
class KeystoneNearSDK {
  parseSignature(ur2) {
    if (ur2.type !== ur_1$5.URType.NearSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_near_1.NearSignature.fromCBOR(ur2.cbor);
    const requestId = sig.getRequestId();
    return {
      requestId: requestId === void 0 ? void 0 : (0, utils_1$9.uuidStringify)(requestId),
      signature: sig.getSignature().map((e) => (0, utils_1$9.toHex)(e))
    };
  }
  generateSignRequest({ requestId, signData: signData2, path, xfp, account: account2, origin: origin2 }) {
    return new bc_ur_registry_near_1.NearSignRequest({
      requestId: (0, utils_1$9.uuidParse)(requestId),
      signData: signData2.map((e) => (0, utils_1$9.toBuffer)(e)),
      derivationPath: new bc_ur_registry_near_1.CryptoKeypath((0, utils_1$9.parsePath)(path).map((e) => new bc_ur_registry_near_1.PathComponent(e)), (0, utils_1$9.toBuffer)(xfp)),
      account: account2,
      origin: origin2
    }).toUR();
  }
}
near.KeystoneNearSDK = KeystoneNearSDK;
var cardano = {};
var dist$6 = { exports: {} };
var bcUrRegistryCardano_cjs_production_min = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist(), e = require$$1;
  const s = { CARDANO_UTXO: new t.RegistryType("cardano-utxo", 2201), CARDANO_SIGN_REQUEST: new t.RegistryType("cardano-sign-request", 2202), CARDANO_SIGNATURE: new t.RegistryType("cardano-signature", 2203), CARDANO_CERT_KEY: new t.RegistryType("cardano-cert-key", 2204), CARDANO_SIGN_DATA_REQUEST: new t.RegistryType("cardano-sign-data-request", 2205), CARDANO_SIGN_DATA_SIGNATURE: new t.RegistryType("cardano-sign-data-signature", 2206), CARDANO_CATALYST_VOTING_REGISTRATION: new t.RegistryType("cardano-catalyst-voting-registration", 2207), CARDANO_CATALYST_VOTING_REGISTRATION_SIGNATURE: new t.RegistryType("cardano-catalyst-voting-registration-signature", 2208), CARDANO_DELEGATION: new t.RegistryType("cardano-delegation", 2209), CARDANO_SIGN_CIP8_DATA_REQUEST: new t.RegistryType("cardano-sign-cip8-data-request", 2210), CARDANO_SIGN_CIP8_DATA_SIGNATURE: new t.RegistryType("cardano-sign-cip8-data-signature", 2211) }, { decodeToDataItem: a } = t.extend;
  var i;
  !function(t2) {
    t2[t2.transactionHash = 1] = "transactionHash", t2[t2.index = 2] = "index", t2[t2.amount = 3] = "amount", t2[t2.keyPath = 4] = "keyPath", t2[t2.address = 5] = "address";
  }(i || (i = {}));
  class r extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.CARDANO_UTXO, this.getTransactionHash = () => this.transactionHash, this.getIndex = () => this.index, this.getKeyPath = () => this.keyPath.getPath(), this.getAmount = () => this.amount, this.getAddress = () => this.address, this.toDataItem = () => {
        const e3 = {};
        this.transactionHash && (e3[i.transactionHash] = this.transactionHash), e3[i.index] = this.index, e3[i.amount] = this.amount;
        const s2 = this.keyPath.toDataItem();
        return s2.setTag(this.keyPath.getRegistryType().getTag()), e3[i.keyPath] = s2, e3[i.address] = this.address, new t.DataItem(e3);
      }, this.transactionHash = e2.transactionHash, this.index = e2.index, this.amount = e2.amount, this.keyPath = e2.keyPath, this.address = e2.address;
    }
    static constructCardanoUtxo({ transactionHash: e2, index: s2, amount: a2, xfp: i2, hdPath: n2, address: o2 }) {
      const d2 = n2.replace(/[m|M]\//, "").split("/"), h2 = new t.CryptoKeypath(d2.map((e3) => {
        const s3 = parseInt(e3.replace("'", "")), a3 = e3.endsWith("'");
        return new t.PathComponent({ index: s3, hardened: a3 });
      }), Buffer$1$1.from(i2, "hex"));
      return new r({ transactionHash: Buffer$1$1.from(e2, "hex"), index: s2, amount: a2, keyPath: h2, address: o2 });
    }
  }
  r.fromDataItem = (e2) => {
    const s2 = e2.getData(), a2 = s2[i.transactionHash], n2 = s2[i.index], o2 = t.CryptoKeypath.fromDataItem(s2[i.keyPath]);
    return new r({ transactionHash: a2, index: n2, amount: s2[i.amount], keyPath: o2, address: s2[i.address] });
  }, r.fromCBOR = (t2) => {
    const e2 = a(t2);
    return r.fromDataItem(e2);
  };
  const { decodeToDataItem: n } = t.extend;
  var o;
  !function(t2) {
    t2[t2.keyHash = 1] = "keyHash", t2[t2.keyPath = 2] = "keyPath";
  }(o || (o = {}));
  class d extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.CARDANO_CERT_KEY, this.getKeyHash = () => this.keyHash, this.getKeyPath = () => this.keyPath.getPath(), this.toDataItem = () => {
        const e3 = {};
        e3[o.keyHash] = this.keyHash;
        const s2 = this.keyPath.toDataItem();
        return s2.setTag(this.keyPath.getRegistryType().getTag()), e3[o.keyPath] = s2, new t.DataItem(e3);
      }, this.keyHash = e2.keyHash, this.keyPath = e2.keyPath;
    }
    static constructCardanoCertKey({ keyHash: e2, xfp: s2, keyPath: a2 }) {
      const i2 = a2.replace(/[m|M]\//, "").split("/"), r2 = new t.CryptoKeypath(i2.map((e3) => {
        const s3 = parseInt(e3.replace("'", "")), a3 = e3.endsWith("'");
        return new t.PathComponent({ index: s3, hardened: a3 });
      }), Buffer$1$1.from(s2, "hex"));
      return new d({ keyHash: Buffer$1$1.from(e2, "hex"), keyPath: r2 });
    }
  }
  d.fromDataItem = (e2) => {
    const s2 = e2.getData(), a2 = s2[o.keyHash], i2 = t.CryptoKeypath.fromDataItem(s2[o.keyPath]);
    return new d({ keyHash: a2, keyPath: i2 });
  }, d.fromCBOR = (t2) => {
    const e2 = n(t2);
    return d.fromDataItem(e2);
  };
  const { decodeToDataItem: h, RegistryTypes: g } = t.extend;
  var u;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.utxos = 3] = "utxos", t2[t2.extraSigners = 4] = "extraSigners", t2[t2.origin = 5] = "origin";
  }(u || (u = {}));
  class c extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.CARDANO_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getUtxos = () => this.utxos, this.getAdditionalSigners = () => this.extraSigners, this.getOrigin = () => this.origin, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[u.requestId] = new t.DataItem(this.requestId, g.UUID.getTag())), e3[u.signData] = this.signData, e3[u.utxos] = this.utxos.map((t2) => {
          const e4 = t2.toDataItem();
          return e4.setTag(t2.getRegistryType().getTag()), e4;
        }), e3[u.extraSigners] = this.extraSigners.map((t2) => {
          const e4 = t2.toDataItem();
          return e4.setTag(t2.getRegistryType().getTag()), e4;
        }), this.origin && (e3[u.origin] = this.origin), new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.utxos = e2.utxos, this.extraSigners = e2.extraSigners, this.origin = e2.origin;
    }
    static constructCardanoSignRequest(t2, s2, a2, i2, n2) {
      const o2 = s2.map((t3) => r.constructCardanoUtxo(t3)), h2 = a2.map((t3) => d.constructCardanoCertKey(t3));
      return new c({ requestId: i2 ? Buffer$1$1.from(e.parse(i2)) : void 0, signData: t2, utxos: o2, extraSigners: h2, origin: n2 || void 0 });
    }
  }
  c.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[u.signData], a2 = e2[u.utxos].map((t3) => r.fromDataItem(t3)), i2 = e2[u.extraSigners].map((t3) => d.fromDataItem(t3)), n2 = e2[u.requestId] ? e2[u.requestId].getData() : void 0;
    return new c({ requestId: n2, signData: s2, utxos: a2, extraSigners: i2, origin: e2[u.origin] ? e2[u.origin] : void 0 });
  }, c.fromCBOR = (t2) => {
    const e2 = h(t2);
    return c.fromDataItem(e2);
  };
  const { RegistryTypes: p, decodeToDataItem: y } = t.extend;
  var I;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature";
  }(I || (I = {}));
  class m extends t.RegistryItem {
    constructor(e2, a2) {
      super(), this.getRegistryType = () => s.CARDANO_SIGNATURE, this.getRequestId = () => this.requestId, this.getWitnessSet = () => this.witnessSet, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[I.requestId] = new t.DataItem(this.requestId, p.UUID.getTag())), e3[I.signature] = this.witnessSet, new t.DataItem(e3);
      }, this.witnessSet = e2, this.requestId = a2;
    }
  }
  m.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[I.signature], a2 = e2[I.requestId] ? e2[I.requestId].getData() : void 0;
    return new m(s2, a2);
  }, m.fromCBOR = (t2) => {
    const e2 = y(t2);
    return m.fromDataItem(e2);
  };
  const { decodeToDataItem: D, RegistryTypes: T } = t.extend;
  var R2;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.derivationPath = 3] = "derivationPath", t2[t2.origin = 4] = "origin", t2[t2.signType = 5] = "signType", t2[t2.xpub = 6] = "xpub";
  }(R2 || (R2 = {}));
  class f2 extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.CARDANO_SIGN_DATA_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDerivationPath = () => this.derivationPath.getPath(), this.getOrigin = () => this.origin, this.getXpub = () => this.xpub, this.toDataItem = () => {
        const e3 = {};
        this.requestId && (e3[R2.requestId] = new t.DataItem(this.requestId, T.UUID.getTag())), this.origin && (e3[R2.origin] = this.origin), e3[R2.signData] = this.signData;
        const s2 = this.derivationPath.toDataItem();
        return s2.setTag(this.derivationPath.getRegistryType().getTag()), e3[R2.derivationPath] = s2, e3[R2.xpub] = this.xpub, new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.derivationPath = e2.derivationPath, this.origin = e2.origin, this.xpub = e2.xpub;
    }
    static constructCardanoSignDataRequest(s2, a2, i2, r2, n2, o2) {
      const d2 = a2.replace(/[m|M]\//, "").split("/"), h2 = new t.CryptoKeypath(d2.map((e2) => {
        const s3 = parseInt(e2.replace("'", ""));
        let a3 = false;
        return e2.endsWith("'") && (a3 = true), new t.PathComponent({ index: s3, hardened: a3 });
      }), Buffer$1$1.from(i2, "hex"));
      return new f2({ requestId: n2 ? Buffer$1$1.from(e.parse(n2)) : void 0, signData: Buffer$1$1.from(s2, "hex"), derivationPath: h2, origin: o2 || void 0, xpub: Buffer$1$1.from(r2, "hex") });
    }
  }
  f2.fromDataItem = (e2) => {
    const s2 = e2.getData(), a2 = s2[R2.signData], i2 = t.CryptoKeypath.fromDataItem(s2[R2.derivationPath]), r2 = s2[R2.requestId] ? s2[R2.requestId].getData() : void 0;
    return new f2({ requestId: r2, signData: a2, derivationPath: i2, origin: s2[R2.origin] ? s2[R2.origin] : void 0, xpub: s2[R2.xpub] });
  }, f2.fromCBOR = (t2) => {
    const e2 = D(t2);
    return f2.fromDataItem(e2);
  };
  const { RegistryTypes: x, decodeToDataItem: P } = t.extend;
  var q;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature", t2[t2.publicKey = 3] = "publicKey";
  }(q || (q = {}));
  class l extends t.RegistryItem {
    constructor(e2, a2, i2) {
      super(), this.getRegistryType = () => s.CARDANO_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.getPublicKey = () => this.publicKey, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[q.requestId] = new t.DataItem(this.requestId, x.UUID.getTag())), e3[q.signature] = this.getSignature(), e3[q.publicKey] = this.getPublicKey(), new t.DataItem(e3);
      }, this.signature = e2, this.publicKey = a2, this.requestId = i2;
    }
  }
  l.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[q.signature], a2 = e2[q.publicKey], i2 = e2[q.requestId] ? e2[q.requestId].getData() : void 0;
    return new l(s2, a2, i2);
  }, l.fromCBOR = (t2) => {
    const e2 = P(t2);
    return l.fromDataItem(e2);
  };
  const { decodeToDataItem: A } = t.extend;
  var C;
  !function(t2) {
    t2[t2.pubKey = 1] = "pubKey", t2[t2.weight = 2] = "weight";
  }(C || (C = {}));
  class v extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.CARDANO_DELEGATION, this.getPubKey = () => this.pubKey, this.getWeight = () => this.weight, this.toDataItem = () => {
        const e3 = {};
        return e3[C.pubKey] = this.getPubKey(), e3[C.weight] = this.getWeight(), new t.DataItem(e3);
      }, this.pubKey = e2.pubKey, this.weight = e2.weight;
    }
    static constructCardanoDelegation({ pubKey: t2, weight: e2 }) {
      return new v({ pubKey: t2, weight: e2 });
    }
  }
  v.fromDataItem = (t2) => {
    const e2 = t2.getData();
    return new v({ pubKey: e2[C.pubKey], weight: e2[C.weight] });
  }, v.fromCBOR = (t2) => {
    const e2 = A(t2);
    return v.fromDataItem(e2);
  };
  const { decodeToDataItem: w, RegistryTypes: S2 } = t.extend;
  var b;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.delegations = 2] = "delegations", t2[t2.stakePub = 3] = "stakePub", t2[t2.paymentAddress = 4] = "paymentAddress", t2[t2.nonce = 5] = "nonce", t2[t2.voting_purpose = 6] = "voting_purpose", t2[t2.derivationPath = 7] = "derivationPath", t2[t2.origin = 8] = "origin", t2[t2.signType = 9] = "signType";
  }(b || (b = {}));
  const _ = (e2, s2) => {
    const a2 = e2.replace(/[m|M]\//, "").split("/");
    return new t.CryptoKeypath(a2.map((e3) => {
      const s3 = parseInt(e3.replace("'", ""));
      let a3 = false;
      return e3.endsWith("'") && (a3 = true), new t.PathComponent({ index: s3, hardened: a3 });
    }), Buffer$1$1.from(s2, "hex"));
  };
  class O extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.CARDANO_CATALYST_VOTING_REGISTRATION, this.getRequestId = () => this.requestId, this.getDelegations = () => this.delegations, this.getStakePub = () => this.stakePub, this.getPaymentAddress = () => this.paymentAddress, this.getNonce = () => this.nonce, this.getVotingPurpose = () => this.voting_purpose, this.getDerivationPath = () => this.derivationPath.getPath(), this.getOrigin = () => this.origin, this.toDataItem = () => {
        const e3 = {};
        this.requestId && (e3[b.requestId] = new t.DataItem(this.requestId, S2.UUID.getTag())), e3[b.stakePub] = this.stakePub, e3[b.paymentAddress] = this.paymentAddress, e3[b.nonce] = this.nonce, e3[b.voting_purpose] = this.voting_purpose, e3[b.delegations] = this.delegations.map((t2) => {
          const e4 = t2.toDataItem();
          return e4.setTag(t2.getRegistryType().getTag()), e4;
        }), this.origin && (e3[b.origin] = this.origin);
        const s2 = this.derivationPath.toDataItem();
        return s2.setTag(this.derivationPath.getRegistryType().getTag()), e3[b.derivationPath] = s2, new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.derivationPath = e2.derivationPath, this.delegations = e2.delegations, this.stakePub = e2.stakePub, this.paymentAddress = e2.paymentAddress, this.nonce = e2.nonce, this.voting_purpose = e2.voting_purpose, this.origin = e2.origin;
    }
    static constructCardanoCatalystRequest(t2, s2, a2, i2, r2, n2, o2, d2, h2) {
      const g2 = d2 ? Buffer$1$1.from(e.parse(d2)) : void 0, u2 = t2.map((t3) => v.constructCardanoDelegation({ pubKey: Buffer$1$1.from(t3.pubKey, "hex"), weight: t3.weight }));
      return new O({ requestId: g2, delegations: u2, stakePub: Buffer$1$1.from(s2, "hex"), paymentAddress: Buffer$1$1.from(a2, "hex"), nonce: i2, voting_purpose: r2, derivationPath: _(n2, o2), origin: h2 });
    }
  }
  O.fromDataItem = (e2) => {
    const s2 = e2.getData(), a2 = s2[b.delegations].map((t2) => v.fromDataItem(t2)), i2 = s2[b.stakePub], r2 = s2[b.paymentAddress], n2 = s2[b.nonce], o2 = s2[b.voting_purpose], d2 = t.CryptoKeypath.fromDataItem(s2[b.derivationPath]), h2 = s2[b.requestId] ? s2[b.requestId].getData() : void 0;
    return new O({ requestId: h2, delegations: a2, stakePub: i2, paymentAddress: r2, nonce: n2, voting_purpose: o2, derivationPath: d2, origin: s2[b.origin] ? s2[b.origin] : void 0 });
  }, O.fromCBOR = (t2) => {
    const e2 = w(t2);
    return O.fromDataItem(e2);
  };
  const { RegistryTypes: K, decodeToDataItem: N } = t.extend;
  var k;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature";
  }(k || (k = {}));
  class B extends t.RegistryItem {
    constructor(e2, a2) {
      super(), this.getRegistryType = () => s.CARDANO_CATALYST_VOTING_REGISTRATION_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[k.requestId] = new t.DataItem(this.requestId, K.UUID.getTag())), e3[k.signature] = this.getSignature(), new t.DataItem(e3);
      }, this.signature = e2, this.requestId = a2;
    }
  }
  B.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[k.signature], a2 = e2[k.requestId] ? e2[k.requestId].getData() : void 0;
    return new B(s2, a2);
  }, B.fromCBOR = (t2) => {
    const e2 = N(t2);
    return B.fromDataItem(e2);
  };
  const { decodeToDataItem: E, RegistryTypes: U } = t.extend;
  var H, G;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.derivationPath = 3] = "derivationPath", t2[t2.origin = 4] = "origin", t2[t2.signType = 5] = "signType", t2[t2.xpub = 6] = "xpub", t2[t2.hashPayload = 7] = "hashPayload", t2[t2.addressBench32 = 8] = "addressBench32", t2[t2.addressFieldType = 9] = "addressFieldType";
  }(H || (H = {})), (G = exports.MessageAddressFieldType || (exports.MessageAddressFieldType = {})).ADDRESS = "ADDRESS", G.KEY_HASH = "KEY_HASH";
  class F extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.CARDANO_SIGN_CIP8_DATA_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDerivationPath = () => this.derivationPath.getPath(), this.getOrigin = () => this.origin, this.getXpub = () => this.xpub, this.getHashPayload = () => this.hashPayload, this.getAddressBench32 = () => this.addressBench32, this.getAddressFieldType = () => this.addressFieldType, this.toDataItem = () => {
        const e3 = {};
        this.requestId && (e3[H.requestId] = new t.DataItem(this.requestId, U.UUID.getTag())), this.origin && (e3[H.origin] = this.origin), e3[H.signData] = this.signData;
        const s2 = this.derivationPath.toDataItem();
        return s2.setTag(this.derivationPath.getRegistryType().getTag()), e3[H.derivationPath] = s2, e3[H.xpub] = this.xpub, e3[H.hashPayload] = this.hashPayload, this.addressBench32 && (e3[H.addressBench32] = this.addressBench32), e3[H.addressFieldType] = this.addressFieldType, new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.derivationPath = e2.derivationPath, this.origin = e2.origin, this.xpub = e2.xpub, this.hashPayload = e2.hashPayload, this.addressBench32 = e2.addressBench32, this.addressFieldType = e2.addressFieldType;
    }
    static constructCardanoSignCip8DataRequest(s2, a2, i2, r2, n2, o2, d2, h2, g2) {
      const u2 = a2.replace(/[m|M]\//, "").split("/"), c2 = new t.CryptoKeypath(u2.map((e2) => {
        const s3 = parseInt(e2.replace("'", ""));
        let a3 = false;
        return e2.endsWith("'") && (a3 = true), new t.PathComponent({ index: s3, hardened: a3 });
      }), Buffer$1$1.from(i2, "hex"));
      return new F({ requestId: h2 ? Buffer$1$1.from(e.parse(h2)) : void 0, signData: Buffer$1$1.from(s2, "hex"), derivationPath: c2, origin: g2 || void 0, xpub: Buffer$1$1.from(r2, "hex"), hashPayload: n2, addressBench32: d2 || void 0, addressFieldType: o2 });
    }
  }
  F.fromDataItem = (e2) => {
    const s2 = e2.getData(), a2 = s2[H.signData], i2 = t.CryptoKeypath.fromDataItem(s2[H.derivationPath]), r2 = s2[H.requestId] ? s2[H.requestId].getData() : void 0;
    return new F({ requestId: r2, signData: a2, derivationPath: i2, origin: s2[H.origin] ? s2[H.origin] : void 0, xpub: s2[H.xpub], hashPayload: s2[H.hashPayload], addressBench32: s2[H.addressBench32] ? s2[H.addressBench32] : void 0, addressFieldType: s2[H.addressFieldType] });
  }, F.fromCBOR = (t2) => {
    const e2 = E(t2);
    return F.fromDataItem(e2);
  };
  const { RegistryTypes: M, decodeToDataItem: W } = t.extend;
  var Y;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature", t2[t2.publicKey = 3] = "publicKey", t2[t2.addressField = 4] = "addressField";
  }(Y || (Y = {}));
  class L extends t.RegistryItem {
    constructor(e2, a2, i2, r2) {
      super(), this.getRegistryType = () => s.CARDANO_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.getPublicKey = () => this.publicKey, this.getAddressField = () => this.addressField, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[Y.requestId] = new t.DataItem(this.requestId, M.UUID.getTag())), e3[Y.signature] = this.getSignature(), e3[Y.publicKey] = this.getPublicKey(), e3[Y.addressField] = this.getAddressField(), new t.DataItem(e3);
      }, this.signature = e2, this.publicKey = a2, this.requestId = r2, this.addressField = i2;
    }
  }
  L.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[Y.signature], a2 = e2[Y.publicKey], i2 = e2[Y.requestId] ? e2[Y.requestId].getData() : void 0;
    return new L(s2, a2, e2[Y.addressField], i2);
  }, L.fromCBOR = (t2) => {
    const e2 = W(t2);
    return L.fromDataItem(e2);
  }, t.patchTags(Object.values(s).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.CardanoCatalystRequest = O, exports.CardanoCatalystSignature = B, exports.CardanoCertKey = d, exports.CardanoSignCip8DataRequest = F, exports.CardanoSignCip8DataSignature = L, exports.CardanoSignDataRequest = f2, exports.CardanoSignDataSignature = l, exports.CardanoSignRequest = c, exports.CardanoSignature = m;
})(bcUrRegistryCardano_cjs_production_min);
{
  dist$6.exports = bcUrRegistryCardano_cjs_production_min;
}
var distExports$4 = dist$6.exports;
Object.defineProperty(cardano, "__esModule", { value: true });
cardano.KeystoneCardanoSDK = void 0;
const bc_ur_registry_cardano_1 = distExports$4;
const utils_1$8 = utils$k;
const ur_1$4 = ur;
class KeystoneCardanoSDK {
  parseSignature(ur2) {
    if (ur2.type !== ur_1$4.URType.CardanoSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_cardano_1.CardanoSignature.fromCBOR(ur2.cbor);
    const requestId = sig.getRequestId();
    return {
      requestId: Buffer$1$1.isBuffer(requestId) ? (0, utils_1$8.uuidStringify)(requestId) : "",
      witnessSet: (0, utils_1$8.toHex)(sig.getWitnessSet())
    };
  }
  parseSignDataSignature(ur2) {
    if (ur2.type !== ur_1$4.URType.CardanoSignDataSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_cardano_1.CardanoSignDataSignature.fromCBOR(ur2.cbor);
    const requestId = sig.getRequestId();
    return {
      requestId: Buffer$1$1.isBuffer(requestId) ? (0, utils_1$8.uuidStringify)(requestId) : "",
      signature: (0, utils_1$8.toHex)(sig.getSignature()),
      publicKey: (0, utils_1$8.toHex)(sig.getPublicKey())
    };
  }
  parseSignCip8DataSignature(ur2) {
    if (ur2.type !== ur_1$4.URType.CardanoSignCip8DataSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_cardano_1.CardanoSignCip8DataSignature.fromCBOR(ur2.cbor);
    const signature2 = sig.getSignature();
    const publicKey = sig.getPublicKey();
    const addressField = sig.getAddressField();
    return {
      requestId: "",
      signature: (0, utils_1$8.toHex)(signature2),
      publicKey: (0, utils_1$8.toHex)(publicKey),
      addressField: (0, utils_1$8.toHex)(addressField)
    };
  }
  parseCatalystSignature(ur2) {
    if (ur2.type !== ur_1$4.URType.CardanoCatalystSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_cardano_1.CardanoCatalystSignature.fromCBOR(ur2.cbor);
    const requestId = sig.getRequestId();
    return {
      requestId: Buffer$1$1.isBuffer(requestId) ? (0, utils_1$8.uuidStringify)(requestId) : "",
      signature: (0, utils_1$8.toHex)(sig.getSignature())
    };
  }
  generateSignDataRequest({ requestId, payload, sigStructure, path, xpub, pubKey, xfp, origin: origin2 }) {
    return bc_ur_registry_cardano_1.CardanoSignDataRequest.constructCardanoSignDataRequest(sigStructure !== null && sigStructure !== void 0 ? sigStructure : payload, path, xfp, pubKey !== null && pubKey !== void 0 ? pubKey : xpub, requestId, origin2).toUR();
  }
  generateSignCip8DataRequest(props2) {
    return bc_ur_registry_cardano_1.CardanoSignCip8DataRequest.constructCardanoSignCip8DataRequest(props2.messageHex, props2.path, props2.xfp, props2.xpub, props2.hashPayload, props2.addressFieldType, "address" in props2 ? props2.address : void 0, props2.requestId, props2.origin).toUR();
  }
  generateCatalystRequest(props2) {
    return bc_ur_registry_cardano_1.CardanoCatalystRequest.constructCardanoCatalystRequest(props2.delegations, props2.stakePub, props2.paymentAddress, props2.nonce, props2.voting_purpose, props2.path, props2.xfp, props2.requestId, props2.origin).toUR();
  }
  generateSignRequest({ signData: signData2, utxos, extraSigners, requestId, origin: origin2 }) {
    return bc_ur_registry_cardano_1.CardanoSignRequest.constructCardanoSignRequest(signData2, utxos, extraSigners, requestId, origin2).toUR();
  }
}
cardano.KeystoneCardanoSDK = KeystoneCardanoSDK;
var arweave = {};
var dist$5 = { exports: {} };
var bcUrRegistryArweave_cjs_production_min = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist(), e = require$$1;
  const s = { ARWEAVE_CRYPTO_ACCOUNT: new t.RegistryType("arweave-crypto-account", 5101), ARWEAVE_SIGN_REQUEST: new t.RegistryType("arweave-sign-request", 5102), ARWEAVE_SIGNATURE: new t.RegistryType("arweave-signature", 5103) }, { decodeToDataItem: i, RegistryTypes: r } = t.extend;
  var a, n, g;
  (a = exports.SignType || (exports.SignType = {}))[a.Transaction = 1] = "Transaction", a[a.DataItem = 2] = "DataItem", a[a.Message = 3] = "Message", (n = exports.SaltLen || (exports.SaltLen = {}))[n.Zero = 0] = "Zero", n[n.Digest = 32] = "Digest", function(t2) {
    t2[t2.masterFingerprint = 1] = "masterFingerprint", t2[t2.requestId = 2] = "requestId", t2[t2.signData = 3] = "signData", t2[t2.signType = 4] = "signType", t2[t2.saltLen = 5] = "saltLen", t2[t2.origin = 6] = "origin", t2[t2.account = 7] = "account";
  }(g || (g = {}));
  class o extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.ARWEAVE_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getSignType = () => this.signType, this.getSaltLen = () => this.saltLen, this.getOrigin = () => this.origin, this.getAccount = () => this.account, this.getMasterFingerprint = () => this.masterFingerprint, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[g.requestId] = new t.DataItem(this.requestId, r.UUID.getTag())), this.account && (e3[g.account] = this.account), this.origin && (e3[g.origin] = this.origin), e3[g.masterFingerprint] = this.masterFingerprint.readUInt32BE(0), e3[g.signData] = this.signData, e3[g.signType] = this.signType, e3[g.saltLen] = this.saltLen, new t.DataItem(e3);
      }, this.masterFingerprint = e2.masterFingerprint, this.requestId = e2.requestId, this.signData = e2.signData, this.signType = e2.signType, this.saltLen = e2.saltLen, this.origin = e2.origin, this.account = e2.account;
    }
    static constructArweaveRequest(t2, s2, i2, r2, a2, n2, g2) {
      return new o({ masterFingerprint: Buffer$1$1.from(s2, "hex"), requestId: a2 ? Buffer$1$1.from(e.parse(a2)) : void 0, signData: t2, signType: i2, saltLen: r2, account: n2, origin: g2 });
    }
  }
  o.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[g.signData], i2 = e2[g.account] ? e2[g.account] : void 0, r2 = e2[g.requestId] ? e2[g.requestId].getData() : void 0, a2 = e2[g.origin] ? e2[g.origin] : void 0, n2 = e2[g.signType], u2 = e2[g.saltLen], c2 = Buffer$1$1.alloc(4);
    return c2.writeUInt32BE(e2[g.masterFingerprint], 0), new o({ masterFingerprint: c2, requestId: r2, signData: s2, signType: n2, saltLen: u2, origin: a2, account: i2 });
  }, o.fromCBOR = (t2) => {
    const e2 = i(t2);
    return o.fromDataItem(e2);
  };
  const { RegistryTypes: u, decodeToDataItem: c } = t.extend;
  var h;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature";
  }(h || (h = {}));
  class p extends t.RegistryItem {
    constructor(e2, i2) {
      super(), this.getRegistryType = () => s.ARWEAVE_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[h.requestId] = new t.DataItem(this.requestId, u.UUID.getTag())), e3[h.signature] = this.signature, new t.DataItem(e3);
      }, this.signature = e2, this.requestId = i2;
    }
  }
  p.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[h.signature], i2 = e2[h.requestId] ? e2[h.requestId].getData() : void 0;
    return new p(s2, i2);
  }, p.fromCBOR = (t2) => {
    const e2 = c(t2);
    return p.fromDataItem(e2);
  };
  const { decodeToDataItem: d } = t.extend;
  var I;
  !function(t2) {
    t2[t2.masterFingerprint = 1] = "masterFingerprint", t2[t2.keyData = 2] = "keyData", t2[t2.device = 3] = "device";
  }(I || (I = {}));
  class m extends t.RegistryItem {
    constructor(e2, i2, r2) {
      super(), this.masterFingerprint = e2, this.keyData = i2, this.device = r2, this.getRegistryType = () => s.ARWEAVE_CRYPTO_ACCOUNT, this.getMasterFingerprint = () => this.masterFingerprint, this.getKeyData = () => this.keyData, this.getDevice = () => this.device, this.toDataItem = () => {
        const e3 = {};
        return e3[I.masterFingerprint] = this.masterFingerprint.readUInt32BE(0), e3[I.keyData] = this.keyData, this.device && (e3[I.device] = this.device), new t.DataItem(e3);
      };
    }
  }
  m.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[I.keyData], i2 = Buffer$1$1.alloc(4);
    return i2.writeUInt32BE(e2[I.masterFingerprint], 0), new m(i2, s2, e2[I.device] ? e2[I.device] : void 0);
  }, m.fromCBOR = (t2) => {
    const e2 = d(t2);
    return m.fromDataItem(e2);
  }, t.patchTags(Object.values(s).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.ArweaveCryptoAccount = m, exports.ArweaveSignRequest = o, exports.ArweaveSignature = p;
})(bcUrRegistryArweave_cjs_production_min);
{
  dist$5.exports = bcUrRegistryArweave_cjs_production_min;
}
var distExports$3 = dist$5.exports;
Object.defineProperty(arweave, "__esModule", { value: true });
arweave.KeystoneArweaveSDK = void 0;
const utils_1$7 = utils$k;
const ur_1$3 = ur;
const bc_ur_registry_arweave_1 = distExports$3;
class KeystoneArweaveSDK {
  parseAccount(ur2) {
    if (ur2.type !== ur_1$3.URType.ArweaveCryptoAccount) {
      throw new Error("type not match");
    }
    const account2 = bc_ur_registry_arweave_1.ArweaveCryptoAccount.fromCBOR(ur2.cbor);
    return {
      masterFingerprint: (0, utils_1$7.toHex)(account2.getMasterFingerprint()),
      keyData: (0, utils_1$7.toHex)(account2.getKeyData()),
      device: account2.getDevice()
    };
  }
  parseSignature(ur2) {
    if (ur2.type !== ur_1$3.URType.ArweaveSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_arweave_1.ArweaveSignature.fromCBOR(ur2.cbor);
    const requestId = sig.getRequestId();
    return {
      requestId: (0, utils_1$7.uuidStringify)(requestId),
      signature: (0, utils_1$7.toHex)(sig.getSignature())
    };
  }
  generateSignRequest({ requestId, signData: signData2, signType, saltLen, masterFingerprint, account: account2, origin: origin2 }) {
    return new bc_ur_registry_arweave_1.ArweaveSignRequest({
      requestId: (0, utils_1$7.uuidParse)(requestId),
      signData: (0, utils_1$7.toBuffer)(signData2),
      signType,
      saltLen,
      masterFingerprint: (0, utils_1$7.toBuffer)(masterFingerprint),
      account: account2 !== void 0 ? (0, utils_1$7.toBuffer)(account2) : void 0,
      origin: origin2
    }).toUR();
  }
}
KeystoneArweaveSDK.SignType = bc_ur_registry_arweave_1.SignType;
KeystoneArweaveSDK.SaltLen = bc_ur_registry_arweave_1.SaltLen;
arweave.KeystoneArweaveSDK = KeystoneArweaveSDK;
var sui = {};
var dist$4 = { exports: {} };
var bcUrRegistrySui_cjs_production_min = {};
var commonjsBrowser$1 = {};
var v1$3 = {};
var rng$3 = {};
Object.defineProperty(rng$3, "__esModule", {
  value: true
});
rng$3.default = rng$2;
let getRandomValues$1;
const rnds8$1 = new Uint8Array(16);
function rng$2() {
  if (!getRandomValues$1) {
    getRandomValues$1 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues$1) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues$1(rnds8$1);
}
var stringify$3 = {};
var validate$3 = {};
var regex$1 = {};
Object.defineProperty(regex$1, "__esModule", {
  value: true
});
regex$1.default = void 0;
var _default$p = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
regex$1.default = _default$p;
Object.defineProperty(validate$3, "__esModule", {
  value: true
});
validate$3.default = void 0;
var _regex$1 = _interopRequireDefault$h(regex$1);
function _interopRequireDefault$h(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function validate$2(uuid) {
  return typeof uuid === "string" && _regex$1.default.test(uuid);
}
var _default$o = validate$2;
validate$3.default = _default$o;
Object.defineProperty(stringify$3, "__esModule", {
  value: true
});
stringify$3.default = void 0;
stringify$3.unsafeStringify = unsafeStringify$1;
var _validate$5 = _interopRequireDefault$g(validate$3);
function _interopRequireDefault$g(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const byteToHex$1 = [];
for (let i = 0; i < 256; ++i) {
  byteToHex$1.push((i + 256).toString(16).slice(1));
}
function unsafeStringify$1(arr, offset = 0) {
  return byteToHex$1[arr[offset + 0]] + byteToHex$1[arr[offset + 1]] + byteToHex$1[arr[offset + 2]] + byteToHex$1[arr[offset + 3]] + "-" + byteToHex$1[arr[offset + 4]] + byteToHex$1[arr[offset + 5]] + "-" + byteToHex$1[arr[offset + 6]] + byteToHex$1[arr[offset + 7]] + "-" + byteToHex$1[arr[offset + 8]] + byteToHex$1[arr[offset + 9]] + "-" + byteToHex$1[arr[offset + 10]] + byteToHex$1[arr[offset + 11]] + byteToHex$1[arr[offset + 12]] + byteToHex$1[arr[offset + 13]] + byteToHex$1[arr[offset + 14]] + byteToHex$1[arr[offset + 15]];
}
function stringify$2(arr, offset = 0) {
  const uuid = unsafeStringify$1(arr, offset);
  if (!(0, _validate$5.default)(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _default$n = stringify$2;
stringify$3.default = _default$n;
Object.defineProperty(v1$3, "__esModule", {
  value: true
});
v1$3.default = void 0;
var _rng$3 = _interopRequireDefault$f(rng$3);
var _stringify$5 = stringify$3;
function _interopRequireDefault$f(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
let _nodeId$1;
let _clockseq$1;
let _lastMSecs$1 = 0;
let _lastNSecs$1 = 0;
function v1$2(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId$1;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq$1;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng$3.default)();
    if (node == null) {
      node = _nodeId$1 = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq$1 = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs$1 + 1;
  const dt = msecs - _lastMSecs$1 + (nsecs - _lastNSecs$1) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs$1) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs$1 = msecs;
  _lastNSecs$1 = nsecs;
  _clockseq$1 = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || (0, _stringify$5.unsafeStringify)(b);
}
var _default$m = v1$2;
v1$3.default = _default$m;
var v3$3 = {};
var v35$3 = {};
var parse$3 = {};
Object.defineProperty(parse$3, "__esModule", {
  value: true
});
parse$3.default = void 0;
var _validate$4 = _interopRequireDefault$e(validate$3);
function _interopRequireDefault$e(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function parse$2(uuid) {
  if (!(0, _validate$4.default)(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var _default$l = parse$2;
parse$3.default = _default$l;
Object.defineProperty(v35$3, "__esModule", {
  value: true
});
v35$3.URL = v35$3.DNS = void 0;
v35$3.default = v35$2;
var _stringify$4 = stringify$3;
var _parse$1 = _interopRequireDefault$d(parse$3);
function _interopRequireDefault$d(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function stringToBytes$1(str) {
  str = unescape(encodeURIComponent(str));
  const bytes2 = [];
  for (let i = 0; i < str.length; ++i) {
    bytes2.push(str.charCodeAt(i));
  }
  return bytes2;
}
const DNS$1 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
v35$3.DNS = DNS$1;
const URL$2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
v35$3.URL = URL$2;
function v35$2(name2, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes$1(value);
    }
    if (typeof namespace === "string") {
      namespace = (0, _parse$1.default)(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes2[i];
      }
      return buf;
    }
    return (0, _stringify$4.unsafeStringify)(bytes2);
  }
  try {
    generateUUID.name = name2;
  } catch (err2) {
  }
  generateUUID.DNS = DNS$1;
  generateUUID.URL = URL$2;
  return generateUUID;
}
var md5$3 = {};
Object.defineProperty(md5$3, "__esModule", {
  value: true
});
md5$3.default = void 0;
function md5$2(bytes2) {
  if (typeof bytes2 === "string") {
    const msg2 = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg2.length);
    for (let i = 0; i < msg2.length; ++i) {
      bytes2[i] = msg2.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray$1(wordsToMd5$1(bytesToWords$1(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray$1(input) {
  const output2 = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output2.push(hex);
  }
  return output2;
}
function getOutputLength$1(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5$1(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength$1(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff$1(a, b, c, d, x[i], 7, -680876936);
    d = md5ff$1(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff$1(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff$1(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff$1(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff$1(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff$1(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff$1(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff$1(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff$1(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff$1(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff$1(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff$1(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff$1(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff$1(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff$1(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg$1(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg$1(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg$1(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg$1(b, c, d, a, x[i], 20, -373897302);
    a = md5gg$1(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg$1(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg$1(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg$1(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg$1(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg$1(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg$1(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg$1(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg$1(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg$1(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg$1(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg$1(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh$1(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh$1(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh$1(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh$1(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh$1(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh$1(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh$1(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh$1(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh$1(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh$1(d, a, b, c, x[i], 11, -358537222);
    c = md5hh$1(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh$1(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh$1(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh$1(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh$1(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh$1(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii$1(a, b, c, d, x[i], 6, -198630844);
    d = md5ii$1(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii$1(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii$1(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii$1(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii$1(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii$1(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii$1(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii$1(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii$1(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii$1(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii$1(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii$1(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii$1(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii$1(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii$1(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd$1(a, olda);
    b = safeAdd$1(b, oldb);
    c = safeAdd$1(c, oldc);
    d = safeAdd$1(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords$1(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output2 = new Uint32Array(getOutputLength$1(length8));
  for (let i = 0; i < length8; i += 8) {
    output2[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output2;
}
function safeAdd$1(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft$1(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn$1(q, a, b, x, s, t) {
  return safeAdd$1(bitRotateLeft$1(safeAdd$1(safeAdd$1(a, q), safeAdd$1(x, t)), s), b);
}
function md5ff$1(a, b, c, d, x, s, t) {
  return md5cmn$1(b & c | ~b & d, a, b, x, s, t);
}
function md5gg$1(a, b, c, d, x, s, t) {
  return md5cmn$1(b & d | c & ~d, a, b, x, s, t);
}
function md5hh$1(a, b, c, d, x, s, t) {
  return md5cmn$1(b ^ c ^ d, a, b, x, s, t);
}
function md5ii$1(a, b, c, d, x, s, t) {
  return md5cmn$1(c ^ (b | ~d), a, b, x, s, t);
}
var _default$k = md5$2;
md5$3.default = _default$k;
Object.defineProperty(v3$3, "__esModule", {
  value: true
});
v3$3.default = void 0;
var _v$3 = _interopRequireDefault$c(v35$3);
var _md$1 = _interopRequireDefault$c(md5$3);
function _interopRequireDefault$c(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const v3$2 = (0, _v$3.default)("v3", 48, _md$1.default);
var _default$j = v3$2;
v3$3.default = _default$j;
var v4$3 = {};
var native$1 = {};
Object.defineProperty(native$1, "__esModule", {
  value: true
});
native$1.default = void 0;
const randomUUID$1 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var _default$i = {
  randomUUID: randomUUID$1
};
native$1.default = _default$i;
Object.defineProperty(v4$3, "__esModule", {
  value: true
});
v4$3.default = void 0;
var _native$1 = _interopRequireDefault$b(native$1);
var _rng$2 = _interopRequireDefault$b(rng$3);
var _stringify$3 = stringify$3;
function _interopRequireDefault$b(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function v4$2(options, buf, offset) {
  if (_native$1.default.randomUUID && !buf && !options) {
    return _native$1.default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || _rng$2.default)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0, _stringify$3.unsafeStringify)(rnds);
}
var _default$h = v4$2;
v4$3.default = _default$h;
var v5$3 = {};
var sha1$3 = {};
Object.defineProperty(sha1$3, "__esModule", {
  value: true
});
sha1$3.default = void 0;
function f$1(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL$1(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1$2(bytes2) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    const msg2 = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (let i = 0; i < msg2.length; ++i) {
      bytes2.push(msg2.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  const l = bytes2.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes2[i * 64 + j * 4] << 24 | bytes2[i * 64 + j * 4 + 1] << 16 | bytes2[i * 64 + j * 4 + 2] << 8 | bytes2[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL$1(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL$1(a, 5) + f$1(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL$1(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var _default$g = sha1$2;
sha1$3.default = _default$g;
Object.defineProperty(v5$3, "__esModule", {
  value: true
});
v5$3.default = void 0;
var _v$2 = _interopRequireDefault$a(v35$3);
var _sha$1 = _interopRequireDefault$a(sha1$3);
function _interopRequireDefault$a(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const v5$2 = (0, _v$2.default)("v5", 80, _sha$1.default);
var _default$f = v5$2;
v5$3.default = _default$f;
var nil$1 = {};
Object.defineProperty(nil$1, "__esModule", {
  value: true
});
nil$1.default = void 0;
var _default$e = "00000000-0000-0000-0000-000000000000";
nil$1.default = _default$e;
var version$3 = {};
Object.defineProperty(version$3, "__esModule", {
  value: true
});
version$3.default = void 0;
var _validate$3 = _interopRequireDefault$9(validate$3);
function _interopRequireDefault$9(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function version$2(uuid) {
  if (!(0, _validate$3.default)(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var _default$d = version$2;
version$3.default = _default$d;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function get() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function get() {
      return _parse2.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function get() {
      return _stringify2.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function get() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function get() {
      return _v22.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function get() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function get() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function get() {
      return _validate2.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function get() {
      return _version.default;
    }
  });
  var _v2 = _interopRequireDefault2(v1$3);
  var _v22 = _interopRequireDefault2(v3$3);
  var _v3 = _interopRequireDefault2(v4$3);
  var _v4 = _interopRequireDefault2(v5$3);
  var _nil = _interopRequireDefault2(nil$1);
  var _version = _interopRequireDefault2(version$3);
  var _validate2 = _interopRequireDefault2(validate$3);
  var _stringify2 = _interopRequireDefault2(stringify$3);
  var _parse2 = _interopRequireDefault2(parse$3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(commonjsBrowser$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var e = requireDist(), t = commonjsBrowser$1;
  const s = { SUI_SIGN_REQUEST: new e.RegistryType("sui-sign-request", 7101), SUI_SIGNATURE: new e.RegistryType("sui-signature", 7102) }, { decodeToDataItem: i, RegistryTypes: r } = e.extend;
  var a;
  !function(e2) {
    e2[e2.requestId = 1] = "requestId", e2[e2.intentMessage = 2] = "intentMessage", e2[e2.derivationPaths = 3] = "derivationPaths", e2[e2.addresses = 4] = "addresses", e2[e2.origin = 5] = "origin";
  }(a || (a = {}));
  class n extends e.RegistryItem {
    constructor(t2) {
      super(), this.getRegistryType = () => s.SUI_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getIntentMessage = () => this.intentMessage, this.getDerivationPaths = () => this.derivationPaths.map((e2) => e2.getPath()), this.getAddresses = () => this.addresses, this.getOrigin = () => this.origin, this.toDataItem = () => {
        const t3 = {};
        return this.requestId && (t3[a.requestId] = new e.DataItem(this.requestId, r.UUID.getTag())), this.addresses && (t3[a.addresses] = this.addresses), this.origin && (t3[a.origin] = this.origin), t3[a.intentMessage] = this.intentMessage, t3[a.derivationPaths] = this.derivationPaths.map((e2) => {
          const t4 = e2.toDataItem();
          return t4.setTag(e2.getRegistryType().getTag()), t4;
        }), new e.DataItem(t3);
      }, this.requestId = t2.requestId, this.intentMessage = t2.intentMessage, this.derivationPaths = t2.derivationPaths, this.addresses = t2.addresses, this.origin = t2.origin;
    }
    static constructSuiRequest(s2, i2, r2, a2, u2, d2) {
      const o2 = i2.map((t2, s3) => {
        const i3 = t2.replace(/[m|M]\//, "").split("/").map((t3) => {
          const s4 = parseInt(t3.replace("'", ""));
          let i4 = false;
          return t3.endsWith("'") && (i4 = true), new e.PathComponent({ index: s4, hardened: i4 });
        });
        return new e.CryptoKeypath(i3, Buffer$1$1.from(r2[s3], "hex"));
      });
      return new n({ requestId: Buffer$1$1.from(t.parse(a2)), intentMessage: s2, derivationPaths: o2, addresses: u2 || void 0, origin: d2 || void 0 });
    }
  }
  n.fromDataItem = (t2) => {
    const s2 = t2.getData(), i2 = s2[a.intentMessage], r2 = s2[a.derivationPaths].map((t3) => e.CryptoKeypath.fromDataItem(t3)), u2 = s2[a.addresses] ? s2[a.addresses] : void 0, d2 = s2[a.requestId] ? s2[a.requestId].getData() : void 0;
    return new n({ requestId: d2, intentMessage: i2, derivationPaths: r2, addresses: u2, origin: s2[a.origin] ? s2[a.origin] : void 0 });
  }, n.fromCBOR = (e2) => {
    const t2 = i(e2);
    return n.fromDataItem(t2);
  };
  const { RegistryTypes: u, decodeToDataItem: d } = e.extend;
  var o;
  !function(e2) {
    e2[e2.requestId = 1] = "requestId", e2[e2.signature = 2] = "signature", e2[e2.publicKey = 3] = "publicKey";
  }(o || (o = {}));
  class g extends e.RegistryItem {
    constructor(t2, i2, r2) {
      super(), this.getRegistryType = () => s.SUI_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.getPublicKey = () => this.publicKey, this.toDataItem = () => {
        const t3 = {};
        return this.requestId && (t3[o.requestId] = new e.DataItem(this.requestId, u.UUID.getTag())), t3[o.signature] = this.signature, this.publicKey && (t3[o.publicKey] = this.publicKey), new e.DataItem(t3);
      }, this.signature = t2, this.requestId = i2, this.publicKey = r2;
    }
  }
  g.fromDataItem = (e2) => {
    const t2 = e2.getData(), s2 = t2[o.signature], i2 = t2[o.requestId].getData();
    return new g(s2, i2, t2[o.publicKey]);
  }, g.fromCBOR = (e2) => {
    const t2 = d(e2);
    return g.fromDataItem(t2);
  }, e.patchTags(Object.values(s).filter((e2) => !!e2.getTag()).map((e2) => e2.getTag())), Object.keys(e).forEach(function(t2) {
    "default" !== t2 && Object.defineProperty(exports, t2, { enumerable: true, get: function() {
      return e[t2];
    } });
  }), exports.SuiSignRequest = n, exports.SuiSignature = g;
})(bcUrRegistrySui_cjs_production_min);
{
  dist$4.exports = bcUrRegistrySui_cjs_production_min;
}
var distExports$2 = dist$4.exports;
Object.defineProperty(sui, "__esModule", { value: true });
sui.KeystoneSuiSDK = void 0;
const bc_ur_registry_sui_1 = distExports$2;
const utils_1$6 = utils$k;
const ur_1$2 = ur;
class KeystoneSuiSDK {
  parseSignature(ur2) {
    if (ur2.type !== ur_1$2.URType.SuiSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_sui_1.SuiSignature.fromCBOR(ur2.cbor);
    const requestId = sig.getRequestId();
    return {
      requestId: Buffer$1$1.isBuffer(requestId) ? (0, utils_1$6.uuidStringify)(requestId) : "",
      signature: (0, utils_1$6.toHex)(sig.getSignature()),
      publicKey: (0, utils_1$6.toHex)(sig.getPublicKey())
    };
  }
  generateSignRequest({ requestId, intentMessage, accounts, origin: origin2 }) {
    const derivationPaths = [];
    const addresses = [];
    accounts.forEach((account2) => {
      derivationPaths.push(new bc_ur_registry_sui_1.CryptoKeypath((0, utils_1$6.parsePath)(account2.path).map((e) => new bc_ur_registry_sui_1.PathComponent(e)), (0, utils_1$6.toBuffer)(account2.xfp)));
      account2.address !== void 0 && addresses.push((0, utils_1$6.toBuffer)(account2.address.startsWith("0x") ? account2.address.substring(2) : account2.address));
    });
    if (addresses.length > 0 && addresses.length !== derivationPaths.length) {
      throw new Error("address and path count must match");
    }
    return new bc_ur_registry_sui_1.SuiSignRequest({
      requestId: (0, utils_1$6.uuidParse)(requestId),
      intentMessage: (0, utils_1$6.toBuffer)(intentMessage),
      derivationPaths,
      addresses,
      origin: origin2
    }).toUR();
  }
}
sui.KeystoneSuiSDK = KeystoneSuiSDK;
var ton = {};
var dist$3 = { exports: {} };
var bcUrRegistryTon_cjs_production_min = {};
var commonjsBrowser = {};
var v1$1 = {};
var rng$1 = {};
Object.defineProperty(rng$1, "__esModule", {
  value: true
});
rng$1.default = rng;
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var stringify$1 = {};
var validate$1 = {};
var regex = {};
Object.defineProperty(regex, "__esModule", {
  value: true
});
regex.default = void 0;
var _default$c = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
regex.default = _default$c;
Object.defineProperty(validate$1, "__esModule", {
  value: true
});
validate$1.default = void 0;
var _regex = _interopRequireDefault$8(regex);
function _interopRequireDefault$8(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function validate7(uuid) {
  return typeof uuid === "string" && _regex.default.test(uuid);
}
var _default$b = validate7;
validate$1.default = _default$b;
Object.defineProperty(stringify$1, "__esModule", {
  value: true
});
stringify$1.default = void 0;
stringify$1.unsafeStringify = unsafeStringify;
var _validate$2 = _interopRequireDefault$7(validate$1);
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset);
  if (!(0, _validate$2.default)(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _default$a = stringify;
stringify$1.default = _default$a;
Object.defineProperty(v1$1, "__esModule", {
  value: true
});
v1$1.default = void 0;
var _rng$1 = _interopRequireDefault$6(rng$1);
var _stringify$2 = stringify$1;
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
let _nodeId;
let _clockseq;
let _lastMSecs = 0;
let _lastNSecs = 0;
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng$1.default)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || (0, _stringify$2.unsafeStringify)(b);
}
var _default$9 = v1;
v1$1.default = _default$9;
var v3$1 = {};
var v35$1 = {};
var parse$1 = {};
Object.defineProperty(parse$1, "__esModule", {
  value: true
});
parse$1.default = void 0;
var _validate$1 = _interopRequireDefault$5(validate$1);
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function parse(uuid) {
  if (!(0, _validate$1.default)(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var _default$8 = parse;
parse$1.default = _default$8;
Object.defineProperty(v35$1, "__esModule", {
  value: true
});
v35$1.URL = v35$1.DNS = void 0;
v35$1.default = v35;
var _stringify$1 = stringify$1;
var _parse = _interopRequireDefault$4(parse$1);
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes2 = [];
  for (let i = 0; i < str.length; ++i) {
    bytes2.push(str.charCodeAt(i));
  }
  return bytes2;
}
const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
v35$1.DNS = DNS;
const URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
v35$1.URL = URL$1;
function v35(name2, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = (0, _parse.default)(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes2[i];
      }
      return buf;
    }
    return (0, _stringify$1.unsafeStringify)(bytes2);
  }
  try {
    generateUUID.name = name2;
  } catch (err2) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
var md5$1 = {};
Object.defineProperty(md5$1, "__esModule", {
  value: true
});
md5$1.default = void 0;
function md5(bytes2) {
  if (typeof bytes2 === "string") {
    const msg2 = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg2.length);
    for (let i = 0; i < msg2.length; ++i) {
      bytes2[i] = msg2.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output2 = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output2.push(hex);
  }
  return output2;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output2 = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output2[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output2;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var _default$7 = md5;
md5$1.default = _default$7;
Object.defineProperty(v3$1, "__esModule", {
  value: true
});
v3$1.default = void 0;
var _v$1 = _interopRequireDefault$3(v35$1);
var _md = _interopRequireDefault$3(md5$1);
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const v3 = (0, _v$1.default)("v3", 48, _md.default);
var _default$6 = v3;
v3$1.default = _default$6;
var v4$1 = {};
var native = {};
Object.defineProperty(native, "__esModule", {
  value: true
});
native.default = void 0;
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var _default$5 = {
  randomUUID
};
native.default = _default$5;
Object.defineProperty(v4$1, "__esModule", {
  value: true
});
v4$1.default = void 0;
var _native = _interopRequireDefault$2(native);
var _rng = _interopRequireDefault$2(rng$1);
var _stringify = stringify$1;
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function v4(options, buf, offset) {
  if (_native.default.randomUUID && !buf && !options) {
    return _native.default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || _rng.default)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0, _stringify.unsafeStringify)(rnds);
}
var _default$4 = v4;
v4$1.default = _default$4;
var v5$1 = {};
var sha1$1 = {};
Object.defineProperty(sha1$1, "__esModule", {
  value: true
});
sha1$1.default = void 0;
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes2) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    const msg2 = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (let i = 0; i < msg2.length; ++i) {
      bytes2.push(msg2.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  const l = bytes2.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes2[i * 64 + j * 4] << 24 | bytes2[i * 64 + j * 4 + 1] << 16 | bytes2[i * 64 + j * 4 + 2] << 8 | bytes2[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var _default$3 = sha1;
sha1$1.default = _default$3;
Object.defineProperty(v5$1, "__esModule", {
  value: true
});
v5$1.default = void 0;
var _v = _interopRequireDefault$1(v35$1);
var _sha = _interopRequireDefault$1(sha1$1);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const v5 = (0, _v.default)("v5", 80, _sha.default);
var _default$2 = v5;
v5$1.default = _default$2;
var nil = {};
Object.defineProperty(nil, "__esModule", {
  value: true
});
nil.default = void 0;
var _default$1 = "00000000-0000-0000-0000-000000000000";
nil.default = _default$1;
var version$1 = {};
Object.defineProperty(version$1, "__esModule", {
  value: true
});
version$1.default = void 0;
var _validate = _interopRequireDefault(validate$1);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var _default = version;
version$1.default = _default;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function get() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function get() {
      return _parse2.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function get() {
      return _stringify2.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function get() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function get() {
      return _v22.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function get() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function get() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function get() {
      return _validate2.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function get() {
      return _version.default;
    }
  });
  var _v2 = _interopRequireDefault2(v1$1);
  var _v22 = _interopRequireDefault2(v3$1);
  var _v3 = _interopRequireDefault2(v4$1);
  var _v4 = _interopRequireDefault2(v5$1);
  var _nil = _interopRequireDefault2(nil);
  var _version = _interopRequireDefault2(version$1);
  var _validate2 = _interopRequireDefault2(validate$1);
  var _stringify2 = _interopRequireDefault2(stringify$1);
  var _parse2 = _interopRequireDefault2(parse$1);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(commonjsBrowser);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist(), e = commonjsBrowser;
  const i = { TRON_SIGN_REQUEST: new t.RegistryType("ton-sign-request", 7201), TRON_SIGNATURE: new t.RegistryType("ton-signature", 7202) }, { decodeToDataItem: s, RegistryTypes: a } = t.extend;
  var r, n;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.dataType = 3] = "dataType", t2[t2.derivationPath = 4] = "derivationPath", t2[t2.address = 5] = "address", t2[t2.origin = 6] = "origin";
  }(r || (r = {})), (n = exports.DataType || (exports.DataType = {}))[n.TRANSACTION = 1] = "TRANSACTION", n[n.SIGN_PROOF = 2] = "SIGN_PROOF";
  class o extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => i.TRON_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDerivationPath = () => this.derivationPath ? this.derivationPath.getPath() : void 0, this.getAddress = () => this.address, this.getOrigin = () => this.origin, this.getDataType = () => this.dataType, this.toDataItem = () => {
        const e3 = {};
        if (e3[r.signData] = this.signData, e3[r.dataType] = this.dataType, this.derivationPath) {
          const t2 = this.derivationPath.toDataItem();
          t2.setTag(this.derivationPath.getRegistryType().getTag()), e3[r.derivationPath] = t2;
        }
        return this.requestId && (e3[r.requestId] = new t.DataItem(this.requestId, a.UUID.getTag())), this.address && (e3[r.address] = this.address), this.origin && (e3[r.origin] = this.origin), new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.derivationPath = e2.derivationPath, this.address = e2.address, this.origin = e2.origin, this.dataType = e2.dataType;
    }
    static parsePath(e2, i2) {
      const s2 = e2.replace(/[m|M]\//, "").split("/").map((e3) => {
        const i3 = parseInt(e3.replace("'", ""));
        let s3 = false;
        return e3.endsWith("'") && (s3 = true), new t.PathComponent({ index: i3, hardened: s3 });
      });
      return new t.CryptoKeypath(s2, Buffer$1$1.from(i2, "hex"));
    }
    static constructTonRequest(t2, i2, s2, a2, r2, n2, d2) {
      return new o({ requestId: a2 ? Buffer$1$1.from(e.parse(a2)) : void 0, signData: t2, dataType: i2, derivationPath: d2 && n2 ? o.parsePath(d2, n2) : void 0, address: s2, origin: r2 });
    }
  }
  o.fromDataItem = (e2) => {
    const i2 = e2.getData(), s2 = i2[r.requestId] ? i2[r.requestId].getData() : void 0, a2 = i2[r.derivationPath] ? t.CryptoKeypath.fromDataItem(i2[r.derivationPath]) : void 0;
    return new o({ requestId: s2, signData: i2[r.signData], dataType: i2[r.dataType], derivationPath: a2, address: i2[r.address], origin: i2[r.origin] });
  }, o.fromCBOR = (t2) => {
    const e2 = s(t2);
    return o.fromDataItem(e2);
  };
  const { RegistryTypes: d, decodeToDataItem: g } = t.extend;
  var h;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature", t2[t2.origin = 3] = "origin";
  }(h || (h = {}));
  class u extends t.RegistryItem {
    constructor(e2, s2, a2) {
      super(), this.getRegistryType = () => i.TRON_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.getOrigin = () => this.origin, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[h.requestId] = new t.DataItem(this.requestId, d.UUID.getTag())), this.origin && (e3[h.origin] = this.origin), e3[h.signature] = this.signature, new t.DataItem(e3);
      }, this.signature = e2, this.requestId = s2, this.origin = a2;
    }
  }
  u.fromDataItem = (t2) => {
    const e2 = t2.getData(), i2 = e2[h.signature];
    let s2 = void 0, a2 = void 0;
    return e2[h.requestId] && (s2 = e2[h.requestId].getData()), e2[h.origin] && (a2 = e2[h.origin]), new u(i2, s2, a2);
  }, u.fromCBOR = (t2) => {
    const e2 = g(t2);
    return u.fromDataItem(e2);
  }, t.patchTags(Object.values(i).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.TonSignRequest = o, exports.TonSignature = u;
})(bcUrRegistryTon_cjs_production_min);
{
  dist$3.exports = bcUrRegistryTon_cjs_production_min;
}
var distExports$1 = dist$3.exports;
Object.defineProperty(ton, "__esModule", { value: true });
ton.KeystoneTonSDK = void 0;
const bc_ur_registry_ton_1 = distExports$1;
const utils_1$5 = utils$k;
const ur_1$1 = ur;
class KeystoneTonSDK {
  constructor(config2) {
    this.config = config2;
  }
  parseSignature(ur2) {
    if (ur2.type !== ur_1$1.URType.TonSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_ton_1.TonSignature.fromCBOR(ur2.cbor);
    const requestId = sig.getRequestId();
    return {
      requestId: Buffer$1$1.isBuffer(requestId) ? (0, utils_1$5.uuidStringify)(requestId) : "",
      signature: (0, utils_1$5.toHex)(sig.getSignature()),
      origin: sig.getOrigin()
    };
  }
  generateSignRequest({ requestId, signData: signData2, dataType, xfp, derivationPath, address: address2 }) {
    var _a;
    return bc_ur_registry_ton_1.TonSignRequest.constructTonRequest((0, utils_1$5.toBuffer)(signData2), dataType, address2, requestId, (_a = this.config) === null || _a === void 0 ? void 0 : _a.origin, xfp, derivationPath).toUR();
  }
}
KeystoneTonSDK.DataType = bc_ur_registry_ton_1.DataType;
ton.KeystoneTonSDK = KeystoneTonSDK;
var stellar = {};
var dist$2 = { exports: {} };
var bcUrRegistryStellar_cjs_production_min = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = requireDist(), e = require$$1;
  const s = { STELLAR_SIGN_REQUEST: new t.RegistryType("stellar-sign-request", 8201), STELLAR_SIGNATURE: new t.RegistryType("stellar-signature", 8202) }, { decodeToDataItem: i, RegistryTypes: r } = t.extend;
  var a, n;
  (a = exports.SignType || (exports.SignType = {}))[a.Transaction = 1] = "Transaction", a[a.TransactionHash = 2] = "TransactionHash", a[a.Message = 3] = "Message", function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signData = 2] = "signData", t2[t2.derivationPath = 3] = "derivationPath", t2[t2.address = 4] = "address", t2[t2.origin = 5] = "origin", t2[t2.signType = 6] = "signType";
  }(n || (n = {}));
  class g extends t.RegistryItem {
    constructor(e2) {
      super(), this.getRegistryType = () => s.STELLAR_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDerivationPath = () => this.derivationPath.getPath(), this.getSignRequestAddress = () => this.address, this.getOrigin = () => this.origin, this.getSignType = () => this.signType, this.toDataItem = () => {
        const e3 = {};
        this.requestId && (e3[n.requestId] = new t.DataItem(this.requestId, r.UUID.getTag())), this.address && (e3[n.address] = this.address), this.origin && (e3[n.origin] = this.origin), e3[n.signData] = this.signData, e3[n.signType] = this.signType;
        const s2 = this.derivationPath.toDataItem();
        return s2.setTag(this.derivationPath.getRegistryType().getTag()), e3[n.derivationPath] = s2, new t.DataItem(e3);
      }, this.requestId = e2.requestId, this.signData = e2.signData, this.derivationPath = e2.derivationPath, this.address = e2.address, this.origin = e2.origin, this.signType = e2.signType;
    }
    static constructStellarRequest(s2, i2, r2, a2, n2, o2, d2) {
      const u2 = i2.replace(/[m|M]\//, "").split("/"), h2 = new t.CryptoKeypath(u2.map((e2) => {
        const s3 = parseInt(e2.replace("'", ""));
        let i3 = false;
        return e2.endsWith("'") && (i3 = true), new t.PathComponent({ index: s3, hardened: i3 });
      }), Buffer$1$1.from(r2, "hex"));
      return new g({ requestId: n2 ? Buffer$1$1.from(e.parse(n2)) : void 0, signData: s2, derivationPath: h2, address: o2 ? Buffer$1$1.from(o2.replace("0x", ""), "hex") : void 0, origin: d2 || void 0, signType: a2 });
    }
  }
  g.fromDataItem = (e2) => {
    const s2 = e2.getData(), i2 = s2[n.signData], r2 = t.CryptoKeypath.fromDataItem(s2[n.derivationPath]), a2 = s2[n.address] ? s2[n.address] : void 0, o2 = s2[n.requestId] ? s2[n.requestId].getData() : void 0;
    return new g({ requestId: o2, signData: i2, derivationPath: r2, address: a2, origin: s2[n.origin] ? s2[n.origin] : void 0, signType: s2[n.signType] });
  }, g.fromCBOR = (t2) => {
    const e2 = i(t2);
    return g.fromDataItem(e2);
  };
  const { RegistryTypes: o, decodeToDataItem: d } = t.extend;
  var u;
  !function(t2) {
    t2[t2.requestId = 1] = "requestId", t2[t2.signature = 2] = "signature";
  }(u || (u = {}));
  class h extends t.RegistryItem {
    constructor(e2, i2) {
      super(), this.getRegistryType = () => s.STELLAR_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.toDataItem = () => {
        const e3 = {};
        return this.requestId && (e3[u.requestId] = new t.DataItem(this.requestId, o.UUID.getTag())), e3[u.signature] = this.signature, new t.DataItem(e3);
      }, this.signature = e2, this.requestId = i2;
    }
  }
  h.fromDataItem = (t2) => {
    const e2 = t2.getData(), s2 = e2[u.signature], i2 = e2[u.requestId] ? e2[u.requestId].getData() : void 0;
    return new h(s2, i2);
  }, h.fromCBOR = (t2) => {
    const e2 = d(t2);
    return h.fromDataItem(e2);
  }, t.patchTags(Object.values(s).filter((t2) => !!t2.getTag()).map((t2) => t2.getTag())), Object.keys(t).forEach(function(e2) {
    "default" !== e2 && Object.defineProperty(exports, e2, { enumerable: true, get: function() {
      return t[e2];
    } });
  }), exports.StellarSignRequest = g, exports.StellarSignature = h;
})(bcUrRegistryStellar_cjs_production_min);
{
  dist$2.exports = bcUrRegistryStellar_cjs_production_min;
}
var distExports = dist$2.exports;
Object.defineProperty(stellar, "__esModule", { value: true });
stellar.KeystoneStellarSDK = void 0;
const utils_1$4 = utils$k;
const ur_1 = ur;
const bc_ur_registry_stellar_1 = distExports;
class KeystoneStellarSDK {
  parseSignature(ur2) {
    if (ur2.type !== ur_1.URType.StellarSignature) {
      throw new Error("type not match");
    }
    const sig = bc_ur_registry_stellar_1.StellarSignature.fromCBOR(ur2.cbor);
    const requestId = sig.getRequestId();
    return {
      requestId: requestId === void 0 ? void 0 : (0, utils_1$4.uuidStringify)(requestId),
      signature: (0, utils_1$4.toHex)(sig.getSignature())
    };
  }
  generateSignRequest({ requestId, signData: signData2, dataType, path, xfp, address: address2, origin: origin2 }) {
    return new bc_ur_registry_stellar_1.StellarSignRequest({
      requestId: (0, utils_1$4.uuidParse)(requestId),
      signData: (0, utils_1$4.toBuffer)(signData2),
      signType: dataType,
      derivationPath: new bc_ur_registry_stellar_1.CryptoKeypath((0, utils_1$4.parsePath)(path).map((e) => new bc_ur_registry_stellar_1.PathComponent(e)), (0, utils_1$4.toBuffer)(xfp)),
      address: address2 !== void 0 ? (0, utils_1$4.toBuffer)(address2) : void 0,
      origin: origin2
    }).toUR();
  }
}
KeystoneStellarSDK.DataType = bc_ur_registry_stellar_1.SignType;
stellar.KeystoneStellarSDK = KeystoneStellarSDK;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(bitcoin, exports);
  __exportStar2(cosmos, exports);
  __exportStar2(evm, exports);
  __exportStar2(ethereum, exports);
  __exportStar2(solana, exports);
  __exportStar2(tron, exports);
  __exportStar2(aptos, exports);
  __exportStar2(bitcoin_cash, exports);
  __exportStar2(dash, exports);
  __exportStar2(litecoin, exports);
  __exportStar2(near, exports);
  __exportStar2(cardano, exports);
  __exportStar2(arweave, exports);
  __exportStar2(sui, exports);
  __exportStar2(ton, exports);
  __exportStar2(stellar, exports);
})(chains);
var wallet = {};
var hardwareCall = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateKeyDerivationCall = exports.QRHardwareCallVersion = exports.DerivationAlgorithm = exports.Curve = void 0;
  const bc_ur_registry_12 = requireDist$1();
  Object.defineProperty(exports, "Curve", { enumerable: true, get: function() {
    return bc_ur_registry_12.Curve;
  } });
  Object.defineProperty(exports, "DerivationAlgorithm", { enumerable: true, get: function() {
    return bc_ur_registry_12.DerivationAlgorithm;
  } });
  Object.defineProperty(exports, "QRHardwareCallVersion", { enumerable: true, get: function() {
    return bc_ur_registry_12.QRHardwareCallVersion;
  } });
  const utils_12 = utils$k;
  const generateKeyDerivationCall = ({ schemas, origin: origin2, version: version2 }) => {
    const keyDerivationSchemas = schemas.map(({ path, curve: curve2 = bc_ur_registry_12.Curve.secp256k1, algo: algo2 = bc_ur_registry_12.DerivationAlgorithm.slip10, chainType }) => {
      if (curve2 === bc_ur_registry_12.Curve.secp256k1 && algo2 === bc_ur_registry_12.DerivationAlgorithm.bip32ed25519) {
        throw new Error("the combination of the given curve and algo not supported");
      }
      return new bc_ur_registry_12.KeyDerivationSchema((0, utils_12.pathToKeypath)(path), curve2, algo2, chainType);
    });
    const keyDerivation = new bc_ur_registry_12.KeyDerivation(keyDerivationSchemas);
    const hardwareCall2 = new bc_ur_registry_12.QRHardwareCall(bc_ur_registry_12.QRHardwareCallType.KeyDerivation, keyDerivation, origin2, version2 ? bc_ur_registry_12.QRHardwareCallVersion.V1 : bc_ur_registry_12.QRHardwareCallVersion.V0);
    return hardwareCall2.toUR();
  };
  exports.generateKeyDerivationCall = generateKeyDerivationCall;
})(hardwareCall);
var multiAccounts = {};
var types$1 = {};
var account$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AccountNote = void 0;
  (function(AccountNote) {
    AccountNote["Standard"] = "account.standard";
    AccountNote["LedgerLegacy"] = "account.ledger_legacy";
    AccountNote["LedgerLive"] = "account.ledger_live";
  })(exports.AccountNote || (exports.AccountNote = {}));
})(account$1);
var props = {};
Object.defineProperty(props, "__esModule", { value: true });
var signature = {};
Object.defineProperty(signature, "__esModule", { value: true });
var token = {};
Object.defineProperty(token, "__esModule", { value: true });
var config = {};
Object.defineProperty(config, "__esModule", { value: true });
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(account$1, exports);
  __exportStar2(props, exports);
  __exportStar2(signature, exports);
  __exportStar2(token, exports);
  __exportStar2(ur, exports);
  __exportStar2(config, exports);
})(types$1);
var accountHelper = {};
Object.defineProperty(accountHelper, "__esModule", { value: true });
accountHelper.generateExtraData = void 0;
const OKX_CHAIN_ID = {
  60: 1
  // ETH
};
const generateExtraData = (coinType) => {
  var _a;
  return {
    okx: {
      chainId: (_a = OKX_CHAIN_ID[coinType]) !== null && _a !== void 0 ? _a : coinType
    }
  };
};
accountHelper.generateExtraData = generateExtraData;
Object.defineProperty(multiAccounts, "__esModule", { value: true });
multiAccounts.parseMultiAccounts = void 0;
const types_1$5 = types$1;
const bc_ur_registry_1$2 = requireDist$1();
const utils_1$3 = utils$k;
const accountHelper_1$2 = accountHelper;
const parseMultiAccounts = (ur2) => {
  if (ur2.type !== types_1$5.URType.CryptoMultiAccounts) {
    throw new Error("type not match");
  }
  const accounts = bc_ur_registry_1$2.CryptoMultiAccounts.fromCBOR(ur2.cbor);
  const masterFingerprint = (0, utils_1$3.toHex)(accounts.getMasterFingerprint());
  return {
    device: accounts.getDevice(),
    masterFingerprint,
    keys: accounts.getKeys().map((key2) => {
      const chainCode = (0, utils_1$3.toHex)(key2.getChainCode());
      const parentFingerprint = (0, utils_1$3.toHex)(key2.getParentFingerprint());
      const origin2 = key2.getOrigin();
      if (origin2 === void 0) {
        throw new Error("multi accounts is invalid");
      }
      let extendedPublicKey;
      if (chainCode.length !== 0 && parentFingerprint.length !== 0) {
        extendedPublicKey = key2.getBip32Key();
      }
      const coinType = origin2.getComponents()[1].getIndex();
      return {
        chain: (0, utils_1$3.getCoinSymbol)(coinType),
        path: `m/${origin2.getPath()}`,
        publicKey: (0, utils_1$3.toHex)(key2.getKey()),
        name: key2.getName(),
        chainCode,
        extendedPublicKey,
        note: key2.getNote(),
        extra: (0, accountHelper_1$2.generateExtraData)(coinType)
      };
    }),
    deviceId: accounts.getDeviceId(),
    deviceVersion: accounts.getVersion()
  };
};
multiAccounts.parseMultiAccounts = parseMultiAccounts;
var hdKey = {};
Object.defineProperty(hdKey, "__esModule", { value: true });
hdKey.parseTonAccount = hdKey.parseHDKey = void 0;
const types_1$4 = types$1;
const bc_ur_registry_1$1 = requireDist$1();
const utils_1$2 = utils$k;
const accountHelper_1$1 = accountHelper;
const parseHDKey = (ur2) => {
  var _a;
  if (ur2.type !== types_1$4.URType.CryptoHDKey) {
    throw new Error("type not match");
  }
  const hdKey2 = bc_ur_registry_1$1.CryptoHDKey.fromCBOR(ur2.cbor);
  const chainCode = (0, utils_1$2.toHex)(hdKey2.getChainCode());
  const parentFingerprint = (0, utils_1$2.toHex)(hdKey2.getParentFingerprint());
  const origin2 = hdKey2.getOrigin();
  const xfp = (_a = hdKey2.getOrigin().getSourceFingerprint()) === null || _a === void 0 ? void 0 : _a.toString("hex");
  if (xfp === void 0) {
    throw new Error("HDKey is invalid");
  }
  let extendedPublicKey;
  if (chainCode.length !== 0 && parentFingerprint.length !== 0) {
    extendedPublicKey = hdKey2.getBip32Key();
  }
  const coinType = origin2.getComponents()[1].getIndex();
  return {
    chain: (0, utils_1$2.getCoinSymbol)(coinType),
    path: `m/${origin2.getPath()}`,
    publicKey: (0, utils_1$2.toHex)(hdKey2.getKey()),
    name: hdKey2.getName(),
    xfp: origin2.getSourceFingerprint().toString("hex"),
    chainCode,
    extendedPublicKey,
    note: hdKey2.getNote(),
    extra: (0, accountHelper_1$1.generateExtraData)(coinType)
  };
};
hdKey.parseHDKey = parseHDKey;
const parseTonAccount = (ur2) => {
  var _a;
  if (ur2.type !== types_1$4.URType.CryptoHDKey) {
    throw new Error("type not match");
  }
  const hdKey2 = bc_ur_registry_1$1.CryptoHDKey.fromCBOR(ur2.cbor);
  const origin2 = hdKey2.getOrigin();
  if (origin2) {
    const xfp = (_a = hdKey2.getOrigin().getSourceFingerprint()) === null || _a === void 0 ? void 0 : _a.toString("hex");
    if (xfp === void 0) {
      throw new Error("HDKey is invalid");
    }
    return {
      path: `m/${origin2.getPath()}`,
      publicKey: (0, utils_1$2.toHex)(hdKey2.getKey()),
      name: hdKey2.getName(),
      xfp: origin2.getSourceFingerprint().toString("hex")
    };
  } else {
    return {
      publicKey: (0, utils_1$2.toHex)(hdKey2.getKey()),
      name: hdKey2.getName()
    };
  }
};
hdKey.parseTonAccount = parseTonAccount;
var account = {};
Object.defineProperty(account, "__esModule", { value: true });
account.parseAccount = void 0;
const types_1$3 = types$1;
const bc_ur_registry_1 = requireDist$1();
const utils_1$1 = utils$k;
const accountHelper_1 = accountHelper;
const parseAccount = (ur2) => {
  if (ur2.type !== types_1$3.URType.CryptoAccount) {
    throw new Error("type not match");
  }
  const account2 = bc_ur_registry_1.CryptoAccount.fromCBOR(ur2.cbor);
  const masterFingerprint = (0, utils_1$1.toHex)(account2.getMasterFingerprint());
  const keys2 = [];
  account2.getOutputDescriptors().forEach((desc) => {
    if (desc.getRegistryType() !== bc_ur_registry_1.RegistryTypes.CRYPTO_HDKEY) {
      const key2 = desc.getCryptoKey();
      const chainCode = (0, utils_1$1.toHex)(key2.getChainCode());
      const parentFingerprint = (0, utils_1$1.toHex)(key2.getParentFingerprint());
      const origin2 = key2.getOrigin();
      if (origin2 === void 0) {
        throw new Error("account is invalid");
      }
      let extendedPublicKey;
      if (chainCode.length !== 0 && parentFingerprint.length !== 0) {
        extendedPublicKey = key2.getBip32Key();
      }
      const coinType = origin2.getComponents()[1].getIndex();
      keys2.push({
        chain: (0, utils_1$1.getCoinSymbol)(coinType),
        path: `m/${origin2.getPath()}`,
        publicKey: (0, utils_1$1.toHex)(key2.getKey()),
        name: key2.getName(),
        chainCode,
        extendedPublicKey,
        note: key2.getNote(),
        extra: (0, accountHelper_1.generateExtraData)(coinType)
      });
    }
  });
  return {
    masterFingerprint,
    keys: keys2
  };
};
account.parseAccount = parseAccount;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(hardwareCall, exports);
  __exportStar2(multiAccounts, exports);
  __exportStar2(hdKey, exports);
  __exportStar2(account, exports);
})(wallet);
var xrp$1 = {};
var xrp = {};
var dist$1 = {};
var coretypes = {};
var enums = {};
const TYPES = {
  Done: -1,
  Unknown: -2,
  NotPresent: 0,
  UInt16: 1,
  UInt32: 2,
  UInt64: 3,
  Hash128: 4,
  Hash256: 5,
  Amount: 6,
  Blob: 7,
  AccountID: 8,
  STObject: 14,
  STArray: 15,
  UInt8: 16,
  Hash160: 17,
  PathSet: 18,
  Vector256: 19,
  UInt96: 20,
  UInt192: 21,
  UInt384: 22,
  UInt512: 23,
  Issue: 24,
  XChainBridge: 25,
  Transaction: 10001,
  LedgerEntry: 10002,
  Validation: 10003,
  Metadata: 10004
};
const LEDGER_ENTRY_TYPES = {
  Invalid: -1,
  AccountRoot: 97,
  DirectoryNode: 100,
  RippleState: 114,
  Ticket: 84,
  SignerList: 83,
  Offer: 111,
  Bridge: 105,
  LedgerHashes: 104,
  Amendments: 102,
  XChainOwnedClaimID: 113,
  XChainOwnedCreateAccountClaimID: 116,
  FeeSettings: 115,
  Escrow: 117,
  PayChannel: 120,
  Check: 67,
  DepositPreauth: 112,
  NegativeUNL: 78,
  NFTokenPage: 80,
  NFTokenOffer: 55,
  AMM: 121,
  DID: 73,
  Any: -3,
  Child: -2,
  Nickname: 110,
  Contract: 99,
  GeneratorMap: 103
};
const FIELDS = [
  [
    "Generic",
    {
      nth: 0,
      isVLEncoded: false,
      isSerialized: false,
      isSigningField: false,
      type: "Unknown"
    }
  ],
  [
    "Invalid",
    {
      nth: -1,
      isVLEncoded: false,
      isSerialized: false,
      isSigningField: false,
      type: "Unknown"
    }
  ],
  [
    "ObjectEndMarker",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "ArrayEndMarker",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "hash",
    {
      nth: 257,
      isVLEncoded: false,
      isSerialized: false,
      isSigningField: false,
      type: "Hash256"
    }
  ],
  [
    "index",
    {
      nth: 258,
      isVLEncoded: false,
      isSerialized: false,
      isSigningField: false,
      type: "Hash256"
    }
  ],
  [
    "taker_gets_funded",
    {
      nth: 258,
      isVLEncoded: false,
      isSerialized: false,
      isSigningField: false,
      type: "Amount"
    }
  ],
  [
    "taker_pays_funded",
    {
      nth: 259,
      isVLEncoded: false,
      isSerialized: false,
      isSigningField: false,
      type: "Amount"
    }
  ],
  [
    "LedgerEntry",
    {
      nth: 257,
      isVLEncoded: false,
      isSerialized: false,
      isSigningField: false,
      type: "LedgerEntry"
    }
  ],
  [
    "Transaction",
    {
      nth: 257,
      isVLEncoded: false,
      isSerialized: false,
      isSigningField: false,
      type: "Transaction"
    }
  ],
  [
    "Validation",
    {
      nth: 257,
      isVLEncoded: false,
      isSerialized: false,
      isSigningField: false,
      type: "Validation"
    }
  ],
  [
    "Metadata",
    {
      nth: 257,
      isVLEncoded: false,
      isSerialized: false,
      isSigningField: false,
      type: "Metadata"
    }
  ],
  [
    "CloseResolution",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt8"
    }
  ],
  [
    "Method",
    {
      nth: 2,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt8"
    }
  ],
  [
    "TransactionResult",
    {
      nth: 3,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt8"
    }
  ],
  [
    "TickSize",
    {
      nth: 16,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt8"
    }
  ],
  [
    "UNLModifyDisabling",
    {
      nth: 17,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt8"
    }
  ],
  [
    "HookResult",
    {
      nth: 18,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt8"
    }
  ],
  [
    "WasLockingChainSend",
    {
      nth: 19,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt8"
    }
  ],
  [
    "LedgerEntryType",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "TransactionType",
    {
      nth: 2,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "SignerWeight",
    {
      nth: 3,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "TransferFee",
    {
      nth: 4,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "TradingFee",
    {
      nth: 5,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "DiscountedFee",
    {
      nth: 6,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "Version",
    {
      nth: 16,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "HookStateChangeCount",
    {
      nth: 17,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "HookEmitCount",
    {
      nth: 18,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "HookExecutionIndex",
    {
      nth: 19,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "HookApiVersion",
    {
      nth: 20,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt16"
    }
  ],
  [
    "NetworkID",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "Flags",
    {
      nth: 2,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "SourceTag",
    {
      nth: 3,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "Sequence",
    {
      nth: 4,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "PreviousTxnLgrSeq",
    {
      nth: 5,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "LedgerSequence",
    {
      nth: 6,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "CloseTime",
    {
      nth: 7,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "ParentCloseTime",
    {
      nth: 8,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "SigningTime",
    {
      nth: 9,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "Expiration",
    {
      nth: 10,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "TransferRate",
    {
      nth: 11,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "WalletSize",
    {
      nth: 12,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "OwnerCount",
    {
      nth: 13,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "DestinationTag",
    {
      nth: 14,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "HighQualityIn",
    {
      nth: 16,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "HighQualityOut",
    {
      nth: 17,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "LowQualityIn",
    {
      nth: 18,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "LowQualityOut",
    {
      nth: 19,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "QualityIn",
    {
      nth: 20,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "QualityOut",
    {
      nth: 21,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "StampEscrow",
    {
      nth: 22,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "BondAmount",
    {
      nth: 23,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "LoadFee",
    {
      nth: 24,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "OfferSequence",
    {
      nth: 25,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "FirstLedgerSequence",
    {
      nth: 26,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "LastLedgerSequence",
    {
      nth: 27,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "TransactionIndex",
    {
      nth: 28,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "OperationLimit",
    {
      nth: 29,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "ReferenceFeeUnits",
    {
      nth: 30,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "ReserveBase",
    {
      nth: 31,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "ReserveIncrement",
    {
      nth: 32,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "SetFlag",
    {
      nth: 33,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "ClearFlag",
    {
      nth: 34,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "SignerQuorum",
    {
      nth: 35,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "CancelAfter",
    {
      nth: 36,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "FinishAfter",
    {
      nth: 37,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "SignerListID",
    {
      nth: 38,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "SettleDelay",
    {
      nth: 39,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "TicketCount",
    {
      nth: 40,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "TicketSequence",
    {
      nth: 41,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "NFTokenTaxon",
    {
      nth: 42,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "MintedNFTokens",
    {
      nth: 43,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "BurnedNFTokens",
    {
      nth: 44,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "HookStateCount",
    {
      nth: 45,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "EmitGeneration",
    {
      nth: 46,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "VoteWeight",
    {
      nth: 48,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "FirstNFTokenSequence",
    {
      nth: 50,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt32"
    }
  ],
  [
    "IndexNext",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "IndexPrevious",
    {
      nth: 2,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "BookNode",
    {
      nth: 3,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "OwnerNode",
    {
      nth: 4,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "BaseFee",
    {
      nth: 5,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "ExchangeRate",
    {
      nth: 6,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "LowNode",
    {
      nth: 7,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "HighNode",
    {
      nth: 8,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "DestinationNode",
    {
      nth: 9,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "Cookie",
    {
      nth: 10,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "ServerVersion",
    {
      nth: 11,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "NFTokenOfferNode",
    {
      nth: 12,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "EmitBurden",
    {
      nth: 13,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "HookOn",
    {
      nth: 16,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "HookInstructionCount",
    {
      nth: 17,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "HookReturnCode",
    {
      nth: 18,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "ReferenceCount",
    {
      nth: 19,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "XChainClaimID",
    {
      nth: 20,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "XChainAccountCreateCount",
    {
      nth: 21,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "XChainAccountClaimCount",
    {
      nth: 22,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "UInt64"
    }
  ],
  [
    "EmailHash",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash128"
    }
  ],
  [
    "TakerPaysCurrency",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash160"
    }
  ],
  [
    "TakerPaysIssuer",
    {
      nth: 2,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash160"
    }
  ],
  [
    "TakerGetsCurrency",
    {
      nth: 3,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash160"
    }
  ],
  [
    "TakerGetsIssuer",
    {
      nth: 4,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash160"
    }
  ],
  [
    "LedgerHash",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "ParentHash",
    {
      nth: 2,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "TransactionHash",
    {
      nth: 3,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "AccountHash",
    {
      nth: 4,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "PreviousTxnID",
    {
      nth: 5,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "LedgerIndex",
    {
      nth: 6,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "WalletLocator",
    {
      nth: 7,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "RootIndex",
    {
      nth: 8,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "AccountTxnID",
    {
      nth: 9,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "NFTokenID",
    {
      nth: 10,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "EmitParentTxnID",
    {
      nth: 11,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "EmitNonce",
    {
      nth: 12,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "EmitHookHash",
    {
      nth: 13,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "AMMID",
    {
      nth: 14,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "BookDirectory",
    {
      nth: 16,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "InvoiceID",
    {
      nth: 17,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "Nickname",
    {
      nth: 18,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "Amendment",
    {
      nth: 19,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "Digest",
    {
      nth: 21,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "Channel",
    {
      nth: 22,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "ConsensusHash",
    {
      nth: 23,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "CheckID",
    {
      nth: 24,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "ValidatedHash",
    {
      nth: 25,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "PreviousPageMin",
    {
      nth: 26,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "NextPageMin",
    {
      nth: 27,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "NFTokenBuyOffer",
    {
      nth: 28,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "NFTokenSellOffer",
    {
      nth: 29,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "HookStateKey",
    {
      nth: 30,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "HookHash",
    {
      nth: 31,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "HookNamespace",
    {
      nth: 32,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "HookSetTxnID",
    {
      nth: 33,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Hash256"
    }
  ],
  [
    "Amount",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "Balance",
    {
      nth: 2,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "LimitAmount",
    {
      nth: 3,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "TakerPays",
    {
      nth: 4,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "TakerGets",
    {
      nth: 5,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "LowLimit",
    {
      nth: 6,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "HighLimit",
    {
      nth: 7,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "Fee",
    {
      nth: 8,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "SendMax",
    {
      nth: 9,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "DeliverMin",
    {
      nth: 10,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "Amount2",
    {
      nth: 11,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "BidMin",
    {
      nth: 12,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "BidMax",
    {
      nth: 13,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "MinimumOffer",
    {
      nth: 16,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "RippleEscrow",
    {
      nth: 17,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "DeliveredAmount",
    {
      nth: 18,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "NFTokenBrokerFee",
    {
      nth: 19,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "BaseFeeDrops",
    {
      nth: 22,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "ReserveBaseDrops",
    {
      nth: 23,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "ReserveIncrementDrops",
    {
      nth: 24,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "LPTokenOut",
    {
      nth: 25,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "LPTokenIn",
    {
      nth: 26,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "EPrice",
    {
      nth: 27,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "Price",
    {
      nth: 28,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "SignatureReward",
    {
      nth: 29,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "MinAccountCreateAmount",
    {
      nth: 30,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "LPTokenBalance",
    {
      nth: 31,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Amount"
    }
  ],
  [
    "PublicKey",
    {
      nth: 1,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "MessageKey",
    {
      nth: 2,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "SigningPubKey",
    {
      nth: 3,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "TxnSignature",
    {
      nth: 4,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: false,
      type: "Blob"
    }
  ],
  [
    "URI",
    {
      nth: 5,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "Signature",
    {
      nth: 6,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: false,
      type: "Blob"
    }
  ],
  [
    "Domain",
    {
      nth: 7,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "FundCode",
    {
      nth: 8,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "RemoveCode",
    {
      nth: 9,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "ExpireCode",
    {
      nth: 10,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "CreateCode",
    {
      nth: 11,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "MemoType",
    {
      nth: 12,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "MemoData",
    {
      nth: 13,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "MemoFormat",
    {
      nth: 14,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "Fulfillment",
    {
      nth: 16,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "Condition",
    {
      nth: 17,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "MasterSignature",
    {
      nth: 18,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: false,
      type: "Blob"
    }
  ],
  [
    "UNLModifyValidator",
    {
      nth: 19,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "ValidatorToDisable",
    {
      nth: 20,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "ValidatorToReEnable",
    {
      nth: 21,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "HookStateData",
    {
      nth: 22,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "HookReturnString",
    {
      nth: 23,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "HookParameterName",
    {
      nth: 24,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "HookParameterValue",
    {
      nth: 25,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "DIDDocument",
    {
      nth: 26,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "Data",
    {
      nth: 27,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Blob"
    }
  ],
  [
    "Account",
    {
      nth: 1,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "Owner",
    {
      nth: 2,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "Destination",
    {
      nth: 3,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "Issuer",
    {
      nth: 4,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "Authorize",
    {
      nth: 5,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "Unauthorize",
    {
      nth: 6,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "RegularKey",
    {
      nth: 8,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "NFTokenMinter",
    {
      nth: 9,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "EmitCallback",
    {
      nth: 10,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "HookAccount",
    {
      nth: 16,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "OtherChainSource",
    {
      nth: 18,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "OtherChainDestination",
    {
      nth: 19,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "AttestationSignerAccount",
    {
      nth: 20,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "AttestationRewardAccount",
    {
      nth: 21,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "LockingChainDoor",
    {
      nth: 22,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "IssuingChainDoor",
    {
      nth: 23,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "AccountID"
    }
  ],
  [
    "Indexes",
    {
      nth: 1,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Vector256"
    }
  ],
  [
    "Hashes",
    {
      nth: 2,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Vector256"
    }
  ],
  [
    "Amendments",
    {
      nth: 3,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Vector256"
    }
  ],
  [
    "NFTokenOffers",
    {
      nth: 4,
      isVLEncoded: true,
      isSerialized: true,
      isSigningField: true,
      type: "Vector256"
    }
  ],
  [
    "Paths",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "PathSet"
    }
  ],
  [
    "LockingChainIssue",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Issue"
    }
  ],
  [
    "IssuingChainIssue",
    {
      nth: 2,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Issue"
    }
  ],
  [
    "Asset",
    {
      nth: 3,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Issue"
    }
  ],
  [
    "Asset2",
    {
      nth: 4,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "Issue"
    }
  ],
  [
    "XChainBridge",
    {
      nth: 1,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "XChainBridge"
    }
  ],
  [
    "TransactionMetaData",
    {
      nth: 2,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "CreatedNode",
    {
      nth: 3,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "DeletedNode",
    {
      nth: 4,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "ModifiedNode",
    {
      nth: 5,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "PreviousFields",
    {
      nth: 6,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "FinalFields",
    {
      nth: 7,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "NewFields",
    {
      nth: 8,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "TemplateEntry",
    {
      nth: 9,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "Memo",
    {
      nth: 10,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "SignerEntry",
    {
      nth: 11,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "NFToken",
    {
      nth: 12,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "EmitDetails",
    {
      nth: 13,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "Hook",
    {
      nth: 14,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "Signer",
    {
      nth: 16,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "Majority",
    {
      nth: 18,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "DisabledValidator",
    {
      nth: 19,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "EmittedTxn",
    {
      nth: 20,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "HookExecution",
    {
      nth: 21,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "HookDefinition",
    {
      nth: 22,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "HookParameter",
    {
      nth: 23,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "HookGrant",
    {
      nth: 24,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "VoteEntry",
    {
      nth: 25,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "AuctionSlot",
    {
      nth: 26,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "AuthAccount",
    {
      nth: 27,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "XChainClaimProofSig",
    {
      nth: 28,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "XChainCreateAccountProofSig",
    {
      nth: 29,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "XChainClaimAttestationCollectionElement",
    {
      nth: 30,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "XChainCreateAccountAttestationCollectionElement",
    {
      nth: 31,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STObject"
    }
  ],
  [
    "Signers",
    {
      nth: 3,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: false,
      type: "STArray"
    }
  ],
  [
    "SignerEntries",
    {
      nth: 4,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "Template",
    {
      nth: 5,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "Necessary",
    {
      nth: 6,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "Sufficient",
    {
      nth: 7,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "AffectedNodes",
    {
      nth: 8,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "Memos",
    {
      nth: 9,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "NFTokens",
    {
      nth: 10,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "Hooks",
    {
      nth: 11,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "VoteSlots",
    {
      nth: 12,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "Majorities",
    {
      nth: 16,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "DisabledValidators",
    {
      nth: 17,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "HookExecutions",
    {
      nth: 18,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "HookParameters",
    {
      nth: 19,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "HookGrants",
    {
      nth: 20,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "XChainClaimAttestations",
    {
      nth: 21,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "XChainCreateAccountAttestations",
    {
      nth: 22,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ],
  [
    "AuthAccounts",
    {
      nth: 25,
      isVLEncoded: false,
      isSerialized: true,
      isSigningField: true,
      type: "STArray"
    }
  ]
];
const TRANSACTION_RESULTS = {
  telLOCAL_ERROR: -399,
  telBAD_DOMAIN: -398,
  telBAD_PATH_COUNT: -397,
  telBAD_PUBLIC_KEY: -396,
  telFAILED_PROCESSING: -395,
  telINSUF_FEE_P: -394,
  telNO_DST_PARTIAL: -393,
  telCAN_NOT_QUEUE: -392,
  telCAN_NOT_QUEUE_BALANCE: -391,
  telCAN_NOT_QUEUE_BLOCKS: -390,
  telCAN_NOT_QUEUE_BLOCKED: -389,
  telCAN_NOT_QUEUE_FEE: -388,
  telCAN_NOT_QUEUE_FULL: -387,
  telWRONG_NETWORK: -386,
  telREQUIRES_NETWORK_ID: -385,
  telNETWORK_ID_MAKES_TX_NON_CANONICAL: -384,
  temMALFORMED: -299,
  temBAD_AMOUNT: -298,
  temBAD_CURRENCY: -297,
  temBAD_EXPIRATION: -296,
  temBAD_FEE: -295,
  temBAD_ISSUER: -294,
  temBAD_LIMIT: -293,
  temBAD_OFFER: -292,
  temBAD_PATH: -291,
  temBAD_PATH_LOOP: -290,
  temBAD_REGKEY: -289,
  temBAD_SEND_XRP_LIMIT: -288,
  temBAD_SEND_XRP_MAX: -287,
  temBAD_SEND_XRP_NO_DIRECT: -286,
  temBAD_SEND_XRP_PARTIAL: -285,
  temBAD_SEND_XRP_PATHS: -284,
  temBAD_SEQUENCE: -283,
  temBAD_SIGNATURE: -282,
  temBAD_SRC_ACCOUNT: -281,
  temBAD_TRANSFER_RATE: -280,
  temDST_IS_SRC: -279,
  temDST_NEEDED: -278,
  temINVALID: -277,
  temINVALID_FLAG: -276,
  temREDUNDANT: -275,
  temRIPPLE_EMPTY: -274,
  temDISABLED: -273,
  temBAD_SIGNER: -272,
  temBAD_QUORUM: -271,
  temBAD_WEIGHT: -270,
  temBAD_TICK_SIZE: -269,
  temINVALID_ACCOUNT_ID: -268,
  temCANNOT_PREAUTH_SELF: -267,
  temINVALID_COUNT: -266,
  temUNCERTAIN: -265,
  temUNKNOWN: -264,
  temSEQ_AND_TICKET: -263,
  temBAD_NFTOKEN_TRANSFER_FEE: -262,
  temBAD_AMM_TOKENS: -261,
  temXCHAIN_EQUAL_DOOR_ACCOUNTS: -260,
  temXCHAIN_BAD_PROOF: -259,
  temXCHAIN_BRIDGE_BAD_ISSUES: -258,
  temXCHAIN_BRIDGE_NONDOOR_OWNER: -257,
  temXCHAIN_BRIDGE_BAD_MIN_ACCOUNT_CREATE_AMOUNT: -256,
  temXCHAIN_BRIDGE_BAD_REWARD_AMOUNT: -255,
  temEMPTY_DID: -254,
  tefFAILURE: -199,
  tefALREADY: -198,
  tefBAD_ADD_AUTH: -197,
  tefBAD_AUTH: -196,
  tefBAD_LEDGER: -195,
  tefCREATED: -194,
  tefEXCEPTION: -193,
  tefINTERNAL: -192,
  tefNO_AUTH_REQUIRED: -191,
  tefPAST_SEQ: -190,
  tefWRONG_PRIOR: -189,
  tefMASTER_DISABLED: -188,
  tefMAX_LEDGER: -187,
  tefBAD_SIGNATURE: -186,
  tefBAD_QUORUM: -185,
  tefNOT_MULTI_SIGNING: -184,
  tefBAD_AUTH_MASTER: -183,
  tefINVARIANT_FAILED: -182,
  tefTOO_BIG: -181,
  tefNO_TICKET: -180,
  tefNFTOKEN_IS_NOT_TRANSFERABLE: -179,
  terRETRY: -99,
  terFUNDS_SPENT: -98,
  terINSUF_FEE_B: -97,
  terNO_ACCOUNT: -96,
  terNO_AUTH: -95,
  terNO_LINE: -94,
  terOWNERS: -93,
  terPRE_SEQ: -92,
  terLAST: -91,
  terNO_RIPPLE: -90,
  terQUEUED: -89,
  terPRE_TICKET: -88,
  terNO_AMM: -87,
  terSUBMITTED: -86,
  tesSUCCESS: 0,
  tecCLAIM: 100,
  tecPATH_PARTIAL: 101,
  tecUNFUNDED_ADD: 102,
  tecUNFUNDED_OFFER: 103,
  tecUNFUNDED_PAYMENT: 104,
  tecFAILED_PROCESSING: 105,
  tecDIR_FULL: 121,
  tecINSUF_RESERVE_LINE: 122,
  tecINSUF_RESERVE_OFFER: 123,
  tecNO_DST: 124,
  tecNO_DST_INSUF_XRP: 125,
  tecNO_LINE_INSUF_RESERVE: 126,
  tecNO_LINE_REDUNDANT: 127,
  tecPATH_DRY: 128,
  tecUNFUNDED: 129,
  tecNO_ALTERNATIVE_KEY: 130,
  tecNO_REGULAR_KEY: 131,
  tecOWNERS: 132,
  tecNO_ISSUER: 133,
  tecNO_AUTH: 134,
  tecNO_LINE: 135,
  tecINSUFF_FEE: 136,
  tecFROZEN: 137,
  tecNO_TARGET: 138,
  tecNO_PERMISSION: 139,
  tecNO_ENTRY: 140,
  tecINSUFFICIENT_RESERVE: 141,
  tecNEED_MASTER_KEY: 142,
  tecDST_TAG_NEEDED: 143,
  tecINTERNAL: 144,
  tecOVERSIZE: 145,
  tecCRYPTOCONDITION_ERROR: 146,
  tecINVARIANT_FAILED: 147,
  tecEXPIRED: 148,
  tecDUPLICATE: 149,
  tecKILLED: 150,
  tecHAS_OBLIGATIONS: 151,
  tecTOO_SOON: 152,
  tecHOOK_REJECTED: 153,
  tecMAX_SEQUENCE_REACHED: 154,
  tecNO_SUITABLE_NFTOKEN_PAGE: 155,
  tecNFTOKEN_BUY_SELL_MISMATCH: 156,
  tecNFTOKEN_OFFER_TYPE_MISMATCH: 157,
  tecCANT_ACCEPT_OWN_NFTOKEN_OFFER: 158,
  tecINSUFFICIENT_FUNDS: 159,
  tecOBJECT_NOT_FOUND: 160,
  tecINSUFFICIENT_PAYMENT: 161,
  tecUNFUNDED_AMM: 162,
  tecAMM_BALANCE: 163,
  tecAMM_FAILED: 164,
  tecAMM_INVALID_TOKENS: 165,
  tecAMM_EMPTY: 166,
  tecAMM_NOT_EMPTY: 167,
  tecAMM_ACCOUNT: 168,
  tecINCOMPLETE: 169,
  tecXCHAIN_BAD_TRANSFER_ISSUE: 170,
  tecXCHAIN_NO_CLAIM_ID: 171,
  tecXCHAIN_BAD_CLAIM_ID: 172,
  tecXCHAIN_CLAIM_NO_QUORUM: 173,
  tecXCHAIN_PROOF_UNKNOWN_KEY: 174,
  tecXCHAIN_CREATE_ACCOUNT_NONXRP_ISSUE: 175,
  tecXCHAIN_WRONG_CHAIN: 176,
  tecXCHAIN_REWARD_MISMATCH: 177,
  tecXCHAIN_NO_SIGNERS_LIST: 178,
  tecXCHAIN_SENDING_ACCOUNT_MISMATCH: 179,
  tecXCHAIN_INSUFF_CREATE_AMOUNT: 180,
  tecXCHAIN_ACCOUNT_CREATE_PAST: 181,
  tecXCHAIN_ACCOUNT_CREATE_TOO_MANY: 182,
  tecXCHAIN_PAYMENT_FAILED: 183,
  tecXCHAIN_SELF_COMMIT: 184,
  tecXCHAIN_BAD_PUBLIC_KEY_ACCOUNT_PAIR: 185,
  tecXCHAIN_CREATE_ACCOUNT_DISABLED: 186,
  tecEMPTY_DID: 187
};
const TRANSACTION_TYPES = {
  Invalid: -1,
  Payment: 0,
  EscrowCreate: 1,
  EscrowFinish: 2,
  AccountSet: 3,
  EscrowCancel: 4,
  SetRegularKey: 5,
  NickNameSet: 6,
  OfferCreate: 7,
  OfferCancel: 8,
  Contract: 9,
  TicketCreate: 10,
  TicketCancel: 11,
  SignerListSet: 12,
  PaymentChannelCreate: 13,
  PaymentChannelFund: 14,
  PaymentChannelClaim: 15,
  CheckCreate: 16,
  CheckCash: 17,
  CheckCancel: 18,
  DepositPreauth: 19,
  TrustSet: 20,
  AccountDelete: 21,
  SetHook: 22,
  NFTokenMint: 25,
  NFTokenBurn: 26,
  NFTokenCreateOffer: 27,
  NFTokenCancelOffer: 28,
  NFTokenAcceptOffer: 29,
  Clawback: 30,
  AMMCreate: 35,
  AMMDeposit: 36,
  AMMWithdraw: 37,
  AMMVote: 38,
  AMMBid: 39,
  AMMDelete: 40,
  XChainCreateClaimID: 41,
  XChainCommit: 42,
  XChainClaim: 43,
  XChainAccountCreateCommit: 44,
  XChainAddClaimAttestation: 45,
  XChainAddAccountCreateAttestation: 46,
  XChainModifyBridge: 47,
  XChainCreateBridge: 48,
  DIDSet: 49,
  DIDDelete: 50,
  EnableAmendment: 100,
  SetFee: 101,
  UNLModify: 102
};
const require$$0 = {
  TYPES,
  LEDGER_ENTRY_TYPES,
  FIELDS,
  TRANSACTION_RESULTS,
  TRANSACTION_TYPES
};
var xrplDefinitionsBase = {};
var bytes$1 = {};
Object.defineProperty(bytes$1, "__esModule", { value: true });
bytes$1.BytesLookup = bytes$1.Bytes = void 0;
const buffer_1$n = dist$h;
class Bytes3 {
  constructor(name2, ordinal, ordinalWidth) {
    this.name = name2;
    this.ordinal = ordinal;
    this.ordinalWidth = ordinalWidth;
    this.bytes = buffer_1$n.Buffer.alloc(ordinalWidth);
    for (let i = 0; i < ordinalWidth; i++) {
      this.bytes[ordinalWidth - i - 1] = ordinal >>> i * 8 & 255;
    }
  }
  toJSON() {
    return this.name;
  }
  toBytesSink(sink) {
    sink.put(this.bytes);
  }
  toBytes() {
    return this.bytes;
  }
}
bytes$1.Bytes = Bytes3;
class BytesLookup {
  constructor(types2, ordinalWidth) {
    this.ordinalWidth = ordinalWidth;
    Object.entries(types2).forEach(([k, v]) => {
      this.add(k, v);
    });
  }
  /**
   * Add a new name value pair to the BytesLookup.
   *
   * @param name - A human readable name for the field.
   * @param value - The numeric value for the field.
   * @throws if the name or value already exist in the lookup because it's unclear how to decode.
   */
  add(name2, value) {
    if (this[name2]) {
      throw new SyntaxError(`Attempted to add a value with a duplicate name "${name2}". This is not allowed because it is unclear how to decode.`);
    }
    if (this[value.toString()]) {
      throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: "${name2}" and previous name: "${this[value.toString()]}. This is not allowed because it is unclear how to decode.
Given value: ${value.toString()}`);
    }
    this[name2] = new Bytes3(name2, value, this.ordinalWidth);
    this[value.toString()] = this[name2];
  }
  from(value) {
    return value instanceof Bytes3 ? value : this[value];
  }
  fromParser(parser) {
    return this.from(parser.readUIntN(this.ordinalWidth).toString());
  }
}
bytes$1.BytesLookup = BytesLookup;
var field = {};
var serializedType = {};
var binarySerializer = {};
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule) return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding$2(result, mod2, k);
  }
  __setModuleDefault$2(result, mod2);
  return result;
};
Object.defineProperty(binarySerializer, "__esModule", { value: true });
binarySerializer.BinarySerializer = binarySerializer.BytesList = void 0;
const assert$2 = __importStar$2(requireAssert());
const buffer_1$m = dist$h;
class BytesList {
  constructor() {
    this.bytesArray = [];
  }
  /**
   * Get the total number of bytes in the BytesList
   *
   * @return the number of bytes
   */
  getLength() {
    return buffer_1$m.Buffer.concat(this.bytesArray).byteLength;
  }
  /**
   * Put bytes in the BytesList
   *
   * @param bytesArg A Buffer
   * @return this BytesList
   */
  put(bytesArg) {
    const bytes2 = buffer_1$m.Buffer.from(bytesArg);
    this.bytesArray.push(bytes2);
    return this;
  }
  /**
   * Write this BytesList to the back of another bytes list
   *
   *  @param list The BytesList to write to
   */
  toBytesSink(list) {
    list.put(this.toBytes());
  }
  toBytes() {
    return buffer_1$m.Buffer.concat(this.bytesArray);
  }
  toHex() {
    return this.toBytes().toString("hex").toUpperCase();
  }
}
binarySerializer.BytesList = BytesList;
class BinarySerializer {
  constructor(sink) {
    this.sink = new BytesList();
    this.sink = sink;
  }
  /**
   * Write a value to this BinarySerializer
   *
   * @param value a SerializedType value
   */
  write(value) {
    value.toBytesSink(this.sink);
  }
  /**
   * Write bytes to this BinarySerializer
   *
   * @param bytes the bytes to write
   */
  put(bytes2) {
    this.sink.put(bytes2);
  }
  /**
   * Write a value of a given type to this BinarySerializer
   *
   * @param type the type to write
   * @param value a value of that type
   */
  writeType(type, value) {
    this.write(type.from(value));
  }
  /**
   * Write BytesList to this BinarySerializer
   *
   * @param bl BytesList to write to BinarySerializer
   */
  writeBytesList(bl) {
    bl.toBytesSink(this.sink);
  }
  /**
   * Calculate the header of Variable Length encoded bytes
   *
   * @param length the length of the bytes
   */
  encodeVariableLength(length) {
    const lenBytes = buffer_1$m.Buffer.alloc(3);
    if (length <= 192) {
      lenBytes[0] = length;
      return lenBytes.slice(0, 1);
    } else if (length <= 12480) {
      length -= 193;
      lenBytes[0] = 193 + (length >>> 8);
      lenBytes[1] = length & 255;
      return lenBytes.slice(0, 2);
    } else if (length <= 918744) {
      length -= 12481;
      lenBytes[0] = 241 + (length >>> 16);
      lenBytes[1] = length >> 8 & 255;
      lenBytes[2] = length & 255;
      return lenBytes.slice(0, 3);
    }
    throw new Error("Overflow error");
  }
  /**
   * Write field and value to BinarySerializer
   *
   * @param field field to write to BinarySerializer
   * @param value value to write to BinarySerializer
   */
  writeFieldAndValue(field2, value, isUnlModifyWorkaround = false) {
    const associatedValue = field2.associatedType.from(value);
    assert$2.ok(associatedValue.toBytesSink !== void 0);
    assert$2.ok(field2.name !== void 0);
    this.sink.put(field2.header);
    if (field2.isVariableLengthEncoded) {
      this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
    } else {
      associatedValue.toBytesSink(this.sink);
    }
  }
  /**
   * Write a variable length encoded value to the BinarySerializer
   *
   * @param value length encoded value to write to BytesList
   */
  writeLengthEncoded(value, isUnlModifyWorkaround = false) {
    const bytes2 = new BytesList();
    if (!isUnlModifyWorkaround) {
      value.toBytesSink(bytes2);
    }
    this.put(this.encodeVariableLength(bytes2.getLength()));
    this.writeBytesList(bytes2);
  }
}
binarySerializer.BinarySerializer = BinarySerializer;
Object.defineProperty(serializedType, "__esModule", { value: true });
serializedType.Comparable = serializedType.SerializedType = void 0;
const binary_serializer_1$2 = binarySerializer;
const buffer_1$l = dist$h;
class SerializedType {
  constructor(bytes2) {
    this.bytes = buffer_1$l.Buffer.alloc(0);
    this.bytes = bytes2 !== null && bytes2 !== void 0 ? bytes2 : buffer_1$l.Buffer.alloc(0);
  }
  static fromParser(parser, hint) {
    throw new Error("fromParser not implemented");
  }
  static from(value) {
    throw new Error("from not implemented");
  }
  /**
   * Write the bytes representation of a SerializedType to a BytesList
   *
   * @param list The BytesList to write SerializedType bytes to
   */
  toBytesSink(list) {
    list.put(this.bytes);
  }
  /**
   * Get the hex representation of a SerializedType's bytes
   *
   * @returns hex String of this.bytes
   */
  toHex() {
    return this.toBytes().toString("hex").toUpperCase();
  }
  /**
   * Get the bytes representation of a SerializedType
   *
   * @returns A buffer of the bytes
   */
  toBytes() {
    if (this.bytes) {
      return this.bytes;
    }
    const bytes2 = new binary_serializer_1$2.BytesList();
    this.toBytesSink(bytes2);
    return bytes2.toBytes();
  }
  /**
   * Return the JSON representation of a SerializedType
   *
   * @param _definitions rippled definitions used to parse the values of transaction types and such.
   *                          Unused in default, but used in STObject, STArray
   *                          Can be customized for sidechains and amendments.
   * @returns any type, if not overloaded returns hexString representation of bytes
   */
  toJSON(_definitions) {
    return this.toHex();
  }
  /**
   * @returns hexString representation of this.bytes
   */
  toString() {
    return this.toHex();
  }
}
serializedType.SerializedType = SerializedType;
class Comparable extends SerializedType {
  lt(other) {
    return this.compareTo(other) < 0;
  }
  eq(other) {
    return this.compareTo(other) === 0;
  }
  gt(other) {
    return this.compareTo(other) > 0;
  }
  gte(other) {
    return this.compareTo(other) > -1;
  }
  lte(other) {
    return this.compareTo(other) < 1;
  }
  /**
   * Overload this method to define how two Comparable SerializedTypes are compared
   *
   * @param other The comparable object to compare this to
   * @returns A number denoting the relationship of this and other
   */
  compareTo(other) {
    throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`);
  }
}
serializedType.Comparable = Comparable;
var constants = {};
Object.defineProperty(constants, "__esModule", { value: true });
constants.TRANSACTION_RESULT_WIDTH = constants.TRANSACTION_TYPE_WIDTH = constants.LEDGER_ENTRY_WIDTH = constants.TYPE_WIDTH = void 0;
constants.TYPE_WIDTH = 2;
constants.LEDGER_ENTRY_WIDTH = 2;
constants.TRANSACTION_TYPE_WIDTH = 2;
constants.TRANSACTION_RESULT_WIDTH = 1;
Object.defineProperty(field, "__esModule", { value: true });
field.FieldLookup = void 0;
const bytes_1 = bytes$1;
const serialized_type_1$8 = serializedType;
const constants_1 = constants;
const buffer_1$k = dist$h;
function fieldHeader(type, nth) {
  const header = [];
  if (type < 16) {
    if (nth < 16) {
      header.push(type << 4 | nth);
    } else {
      header.push(type << 4, nth);
    }
  } else if (nth < 16) {
    header.push(nth, type);
  } else {
    header.push(0, type, nth);
  }
  return buffer_1$k.Buffer.from(header);
}
function buildField([name2, info], typeOrdinal) {
  const field2 = fieldHeader(typeOrdinal, info.nth);
  return {
    name: name2,
    nth: info.nth,
    isVariableLengthEncoded: info.isVLEncoded,
    isSerialized: info.isSerialized,
    isSigningField: info.isSigningField,
    ordinal: typeOrdinal << 16 | info.nth,
    type: new bytes_1.Bytes(info.type, typeOrdinal, constants_1.TYPE_WIDTH),
    header: field2,
    associatedType: serialized_type_1$8.SerializedType
    // For later assignment in ./types/index.js or Definitions.updateAll(...)
  };
}
class FieldLookup {
  constructor(fields, types2) {
    fields.forEach(([name2, field_info]) => {
      const typeOrdinal = types2[field_info.type];
      this[name2] = buildField([name2, field_info], typeOrdinal);
      this[this[name2].ordinal.toString()] = this[name2];
    });
  }
  fromString(value) {
    return this[value];
  }
}
field.FieldLookup = FieldLookup;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BytesLookup = exports.Bytes = exports.FieldLookup = exports.XrplDefinitionsBase = void 0;
  const bytes_12 = bytes$1;
  Object.defineProperty(exports, "Bytes", { enumerable: true, get: function() {
    return bytes_12.Bytes;
  } });
  Object.defineProperty(exports, "BytesLookup", { enumerable: true, get: function() {
    return bytes_12.BytesLookup;
  } });
  const field_1 = field;
  Object.defineProperty(exports, "FieldLookup", { enumerable: true, get: function() {
    return field_1.FieldLookup;
  } });
  const constants_12 = constants;
  class XrplDefinitionsBase {
    /**
     * Present rippled types in a typed and updatable format.
     * For an example of the input format see `definitions.json`
     * To generate a new definitions file from rippled source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen
     *
     * See the definitions.test.js file for examples of how to create your own updated definitions.json.
     *
     * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
     * @param types - A list of type objects with the same name as the fields defined.
     *              You can use the coreTypes object if you are not adding new types.
     */
    constructor(enums2, types2) {
      this.type = new bytes_12.BytesLookup(enums2.TYPES, constants_12.TYPE_WIDTH);
      this.ledgerEntryType = new bytes_12.BytesLookup(enums2.LEDGER_ENTRY_TYPES, constants_12.LEDGER_ENTRY_WIDTH);
      this.transactionType = new bytes_12.BytesLookup(enums2.TRANSACTION_TYPES, constants_12.TRANSACTION_TYPE_WIDTH);
      this.transactionResult = new bytes_12.BytesLookup(enums2.TRANSACTION_RESULTS, constants_12.TRANSACTION_RESULT_WIDTH);
      this.field = new field_1.FieldLookup(enums2.FIELDS, enums2.TYPES);
      this.transactionNames = Object.entries(enums2.TRANSACTION_TYPES).filter(([_key, value]) => value >= 0).map(([key2, _value]) => key2);
      this.dataTypes = {};
      this.associateTypes(types2);
    }
    /**
     * Associates each Field to a corresponding class that TypeScript can recognize.
     *
     * @param types a list of type objects with the same name as the fields defined.
     *              Defaults to xrpl.js's core type definitions.
     */
    associateTypes(types2) {
      this.dataTypes = Object.assign({}, this.dataTypes, types2);
      Object.values(this.field).forEach((field2) => {
        field2.associatedType = this.dataTypes[field2.type.name];
      });
      this.field["TransactionType"].associatedType = this.transactionType;
      this.field["TransactionResult"].associatedType = this.transactionResult;
      this.field["LedgerEntryType"].associatedType = this.ledgerEntryType;
    }
    getAssociatedTypes() {
      return this.dataTypes;
    }
  }
  exports.XrplDefinitionsBase = XrplDefinitionsBase;
})(xrplDefinitionsBase);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TRANSACTION_TYPES = exports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.Bytes = void 0;
  const enums2 = __importStar2(require$$0);
  const xrpl_definitions_base_12 = xrplDefinitionsBase;
  Object.defineProperty(exports, "XrplDefinitionsBase", { enumerable: true, get: function() {
    return xrpl_definitions_base_12.XrplDefinitionsBase;
  } });
  Object.defineProperty(exports, "Bytes", { enumerable: true, get: function() {
    return xrpl_definitions_base_12.Bytes;
  } });
  const DEFAULT_DEFINITIONS = new xrpl_definitions_base_12.XrplDefinitionsBase(enums2, {});
  exports.DEFAULT_DEFINITIONS = DEFAULT_DEFINITIONS;
  const Type2 = DEFAULT_DEFINITIONS.type;
  exports.Type = Type2;
  const LedgerEntryType = DEFAULT_DEFINITIONS.ledgerEntryType;
  exports.LedgerEntryType = LedgerEntryType;
  const TransactionType = DEFAULT_DEFINITIONS.transactionType;
  exports.TransactionType = TransactionType;
  const TransactionResult = DEFAULT_DEFINITIONS.transactionResult;
  exports.TransactionResult = TransactionResult;
  const Field2 = DEFAULT_DEFINITIONS.field;
  exports.Field = Field2;
  const TRANSACTION_TYPES2 = DEFAULT_DEFINITIONS.transactionNames;
  exports.TRANSACTION_TYPES = TRANSACTION_TYPES2;
})(enums);
var types = {};
var accountId = {};
var dist = {};
var xrpCodec = {};
var utils = {};
Object.defineProperty(utils, "__esModule", { value: true });
utils.concatArgs = utils.seqEqual = void 0;
function seqEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
utils.seqEqual = seqEqual;
function isSequence(val) {
  return typeof val !== "number";
}
function concatArgs(...args) {
  const ret = [];
  args.forEach((arg) => {
    if (isSequence(arg)) {
      for (const j of arg) {
        ret.push(j);
      }
    } else {
      ret.push(arg);
    }
  });
  return ret;
}
utils.concatArgs = concatArgs;
Object.defineProperty(xrpCodec, "__esModule", { value: true });
xrpCodec.isValidClassicAddress = xrpCodec.decodeAccountPublic = xrpCodec.encodeAccountPublic = xrpCodec.encodeNodePublic = xrpCodec.decodeNodePublic = xrpCodec.decodeAddress = xrpCodec.decodeAccountID = xrpCodec.encodeAddress = xrpCodec.encodeAccountID = xrpCodec.decodeSeed = xrpCodec.encodeSeed = xrpCodec.codec = void 0;
const baseCodec = src$1;
const createHash$1 = browser;
const utils_1 = utils;
class Codec {
  constructor(options) {
    this._sha256 = options.sha256;
    this._alphabet = options.alphabet;
    this._codec = baseCodec(this._alphabet);
  }
  /**
   * Encoder.
   *
   * @param bytes - Buffer of data to encode.
   * @param opts - Options object including the version bytes and the expected length of the data to encode.
   */
  encode(bytes2, opts) {
    const versions = opts.versions;
    return this._encodeVersioned(bytes2, versions, opts.expectedLength);
  }
  /**
   * Decoder.
   *
   * @param base58string - Base58Check-encoded string to decode.
   * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.
   */
  /* eslint-disable max-lines-per-function --
   * TODO refactor */
  decode(base58string, opts) {
    var _a;
    const versions = opts.versions;
    const types2 = opts.versionTypes;
    const withoutSum = this.decodeChecked(base58string);
    if (versions.length > 1 && !opts.expectedLength) {
      throw new Error("expectedLength is required because there are >= 2 possible versions");
    }
    const versionLengthGuess = typeof versions[0] === "number" ? 1 : versions[0].length;
    const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;
    const versionBytes = withoutSum.slice(0, -payloadLength);
    const payload = withoutSum.slice(-payloadLength);
    for (let i = 0; i < versions.length; i++) {
      const version2 = Array.isArray(versions[i]) ? versions[i] : [versions[i]];
      if ((0, utils_1.seqEqual)(versionBytes, version2)) {
        return {
          version: version2,
          bytes: payload,
          type: types2 ? types2[i] : null
        };
      }
    }
    throw new Error("version_invalid: version bytes do not match any of the provided version(s)");
  }
  encodeChecked(buffer) {
    const check = this._sha256(this._sha256(buffer)).slice(0, 4);
    return this._encodeRaw(Buffer$1$1.from((0, utils_1.concatArgs)(buffer, check)));
  }
  decodeChecked(base58string) {
    const buffer = this._decodeRaw(base58string);
    if (buffer.length < 5) {
      throw new Error("invalid_input_size: decoded data must have length >= 5");
    }
    if (!this._verifyCheckSum(buffer)) {
      throw new Error("checksum_invalid");
    }
    return buffer.slice(0, -4);
  }
  _encodeVersioned(bytes2, versions, expectedLength) {
    if (expectedLength && bytes2.length !== expectedLength) {
      throw new Error("unexpected_payload_length: bytes.length does not match expectedLength. Ensure that the bytes are a Buffer.");
    }
    return this.encodeChecked(Buffer$1$1.from((0, utils_1.concatArgs)(versions, bytes2)));
  }
  _encodeRaw(bytes2) {
    return this._codec.encode(bytes2);
  }
  /* eslint-enable max-lines-per-function */
  _decodeRaw(base58string) {
    return this._codec.decode(base58string);
  }
  _verifyCheckSum(bytes2) {
    const computed = this._sha256(this._sha256(bytes2.slice(0, -4))).slice(0, 4);
    const checksum = bytes2.slice(-4);
    return (0, utils_1.seqEqual)(computed, checksum);
  }
}
const ACCOUNT_ID = 0;
const ACCOUNT_PUBLIC_KEY = 35;
const FAMILY_SEED = 33;
const NODE_PUBLIC = 28;
const ED25519_SEED = [1, 225, 75];
const codecOptions = {
  sha256(bytes2) {
    return createHash$1("sha256").update(Buffer$1$1.from(bytes2)).digest();
  },
  alphabet: "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"
};
const codecWithXrpAlphabet = new Codec(codecOptions);
xrpCodec.codec = codecWithXrpAlphabet;
function encodeSeed(entropy, type) {
  if (entropy.length !== 16) {
    throw new Error("entropy must have length 16");
  }
  const opts = {
    expectedLength: 16,
    // for secp256k1, use `FAMILY_SEED`
    versions: type === "ed25519" ? ED25519_SEED : [FAMILY_SEED]
  };
  return codecWithXrpAlphabet.encode(entropy, opts);
}
xrpCodec.encodeSeed = encodeSeed;
function decodeSeed(seed, opts = {
  versionTypes: ["ed25519", "secp256k1"],
  versions: [ED25519_SEED, FAMILY_SEED],
  expectedLength: 16
}) {
  return codecWithXrpAlphabet.decode(seed, opts);
}
xrpCodec.decodeSeed = decodeSeed;
function encodeAccountID(bytes2) {
  const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
  return codecWithXrpAlphabet.encode(bytes2, opts);
}
xrpCodec.encodeAccountID = encodeAccountID;
xrpCodec.encodeAddress = encodeAccountID;
function decodeAccountID(accountId2) {
  const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
  return codecWithXrpAlphabet.decode(accountId2, opts).bytes;
}
xrpCodec.decodeAccountID = decodeAccountID;
xrpCodec.decodeAddress = decodeAccountID;
function decodeNodePublic(base58string) {
  const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
  return codecWithXrpAlphabet.decode(base58string, opts).bytes;
}
xrpCodec.decodeNodePublic = decodeNodePublic;
function encodeNodePublic(bytes2) {
  const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
  return codecWithXrpAlphabet.encode(bytes2, opts);
}
xrpCodec.encodeNodePublic = encodeNodePublic;
function encodeAccountPublic(bytes2) {
  const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
  return codecWithXrpAlphabet.encode(bytes2, opts);
}
xrpCodec.encodeAccountPublic = encodeAccountPublic;
function decodeAccountPublic(base58string) {
  const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
  return codecWithXrpAlphabet.decode(base58string, opts).bytes;
}
xrpCodec.decodeAccountPublic = decodeAccountPublic;
function isValidClassicAddress(address2) {
  try {
    decodeAccountID(address2);
  } catch (_error) {
    return false;
  }
  return true;
}
xrpCodec.isValidClassicAddress = isValidClassicAddress;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
  const assert2 = __importStar2(requireAssert());
  const xrp_codec_1 = xrpCodec;
  Object.defineProperty(exports, "codec", { enumerable: true, get: function() {
    return xrp_codec_1.codec;
  } });
  Object.defineProperty(exports, "encodeSeed", { enumerable: true, get: function() {
    return xrp_codec_1.encodeSeed;
  } });
  Object.defineProperty(exports, "decodeSeed", { enumerable: true, get: function() {
    return xrp_codec_1.decodeSeed;
  } });
  Object.defineProperty(exports, "encodeAccountID", { enumerable: true, get: function() {
    return xrp_codec_1.encodeAccountID;
  } });
  Object.defineProperty(exports, "decodeAccountID", { enumerable: true, get: function() {
    return xrp_codec_1.decodeAccountID;
  } });
  Object.defineProperty(exports, "encodeNodePublic", { enumerable: true, get: function() {
    return xrp_codec_1.encodeNodePublic;
  } });
  Object.defineProperty(exports, "decodeNodePublic", { enumerable: true, get: function() {
    return xrp_codec_1.decodeNodePublic;
  } });
  Object.defineProperty(exports, "encodeAccountPublic", { enumerable: true, get: function() {
    return xrp_codec_1.encodeAccountPublic;
  } });
  Object.defineProperty(exports, "decodeAccountPublic", { enumerable: true, get: function() {
    return xrp_codec_1.decodeAccountPublic;
  } });
  Object.defineProperty(exports, "isValidClassicAddress", { enumerable: true, get: function() {
    return xrp_codec_1.isValidClassicAddress;
  } });
  const PREFIX_BYTES = {
    // 5, 68
    main: Buffer$1$1.from([5, 68]),
    // 4, 147
    test: Buffer$1$1.from([4, 147])
  };
  const MAX_32_BIT_UNSIGNED_INT = 4294967295;
  function classicAddressToXAddress(classicAddress, tag, test) {
    const accountId2 = (0, xrp_codec_1.decodeAccountID)(classicAddress);
    return encodeXAddress(accountId2, tag, test);
  }
  exports.classicAddressToXAddress = classicAddressToXAddress;
  function encodeXAddress(accountId2, tag, test) {
    if (accountId2.length !== 20) {
      throw new Error("Account ID must be 20 bytes");
    }
    if (tag > MAX_32_BIT_UNSIGNED_INT) {
      throw new Error("Invalid tag");
    }
    const theTag = tag || 0;
    const flag = tag === false || tag == null ? 0 : 1;
    const bytes2 = Buffer$1$1.concat([
      test ? PREFIX_BYTES.test : PREFIX_BYTES.main,
      accountId2,
      Buffer$1$1.from([
        // 0x00 if no tag, 0x01 if 32-bit tag
        flag,
        // first byte
        theTag & 255,
        // second byte
        theTag >> 8 & 255,
        // third byte
        theTag >> 16 & 255,
        // fourth byte
        theTag >> 24 & 255,
        0,
        0,
        0,
        // four zero bytes (reserved for 64-bit tags)
        0
      ])
    ]);
    return xrp_codec_1.codec.encodeChecked(bytes2);
  }
  exports.encodeXAddress = encodeXAddress;
  function xAddressToClassicAddress(xAddress) {
    const { accountId: accountId2, tag, test } = decodeXAddress(xAddress);
    const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId2);
    return {
      classicAddress,
      tag,
      test
    };
  }
  exports.xAddressToClassicAddress = xAddressToClassicAddress;
  function decodeXAddress(xAddress) {
    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);
    const test = isBufferForTestAddress(decoded);
    const accountId2 = decoded.slice(2, 22);
    const tag = tagFromBuffer(decoded);
    return {
      accountId: accountId2,
      tag,
      test
    };
  }
  exports.decodeXAddress = decodeXAddress;
  function isBufferForTestAddress(buf) {
    const decodedPrefix = buf.slice(0, 2);
    if (PREFIX_BYTES.main.equals(decodedPrefix)) {
      return false;
    }
    if (PREFIX_BYTES.test.equals(decodedPrefix)) {
      return true;
    }
    throw new Error("Invalid X-address: bad prefix");
  }
  function tagFromBuffer(buf) {
    const flag = buf[22];
    if (flag >= 2) {
      throw new Error("Unsupported X-address");
    }
    if (flag === 1) {
      return buf[23] + buf[24] * 256 + buf[25] * 65536 + buf[26] * 16777216;
    }
    assert2.strictEqual(flag, 0, "flag must be zero to indicate no tag");
    assert2.ok(Buffer$1$1.from("0000000000000000", "hex").equals(buf.slice(23, 23 + 8)), "remaining bytes must be zero");
    return false;
  }
  function isValidXAddress(xAddress) {
    try {
      decodeXAddress(xAddress);
    } catch (_error) {
      return false;
    }
    return true;
  }
  exports.isValidXAddress = isValidXAddress;
})(dist);
var hash160 = {};
var hash2 = {};
Object.defineProperty(hash2, "__esModule", { value: true });
hash2.Hash = void 0;
const serialized_type_1$7 = serializedType;
const buffer_1$j = dist$h;
class Hash extends serialized_type_1$7.Comparable {
  constructor(bytes2) {
    super(bytes2);
    if (this.bytes.byteLength !== this.constructor.width) {
      throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);
    }
  }
  /**
   * Construct a Hash object from an existing Hash object or a hex-string
   *
   * @param value A hash object or hex-string of a hash
   */
  static from(value) {
    if (value instanceof this) {
      return value;
    }
    if (typeof value === "string") {
      return new this(buffer_1$j.Buffer.from(value, "hex"));
    }
    throw new Error("Cannot construct Hash from given value");
  }
  /**
   * Read a Hash object from a BinaryParser
   *
   * @param parser BinaryParser to read the hash from
   * @param hint length of the bytes to read, optional
   */
  static fromParser(parser, hint) {
    return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));
  }
  /**
   * Overloaded operator for comparing two hash objects
   *
   * @param other The Hash to compare this to
   */
  compareTo(other) {
    return this.bytes.compare(this.constructor.from(other).bytes);
  }
  /**
   * @returns the hex-string representation of this Hash
   */
  toString() {
    return this.toHex();
  }
  /**
   * Returns four bits at the specified depth within a hash
   *
   * @param depth The depth of the four bits
   * @returns The number represented by the four bits
   */
  nibblet(depth) {
    const byteIx = depth > 0 ? depth / 2 | 0 : 0;
    let b = this.bytes[byteIx];
    if (depth % 2 === 0) {
      b = (b & 240) >>> 4;
    } else {
      b = b & 15;
    }
    return b;
  }
}
hash2.Hash = Hash;
Object.defineProperty(hash160, "__esModule", { value: true });
hash160.Hash160 = void 0;
const hash_1$2 = hash2;
const buffer_1$i = dist$h;
class Hash160 extends hash_1$2.Hash {
  constructor(bytes2) {
    if (bytes2 && bytes2.byteLength === 0) {
      bytes2 = Hash160.ZERO_160.bytes;
    }
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : Hash160.ZERO_160.bytes);
  }
}
hash160.Hash160 = Hash160;
Hash160.width = 20;
Hash160.ZERO_160 = new Hash160(buffer_1$i.Buffer.alloc(Hash160.width));
Object.defineProperty(accountId, "__esModule", { value: true });
accountId.AccountID = void 0;
const ripple_address_codec_1 = dist;
const hash_160_1$1 = hash160;
const buffer_1$h = dist$h;
const HEX_REGEX$2 = /^[A-F0-9]{40}$/;
class AccountID extends hash_160_1$1.Hash160 {
  constructor(bytes2) {
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : AccountID.defaultAccountID.bytes);
  }
  /**
   * Defines how to construct an AccountID
   *
   * @param value either an existing AccountID, a hex-string, or a base58 r-Address
   * @returns an AccountID object
   */
  static from(value) {
    if (value instanceof AccountID) {
      return value;
    }
    if (typeof value === "string") {
      if (value === "") {
        return new AccountID();
      }
      return HEX_REGEX$2.test(value) ? new AccountID(buffer_1$h.Buffer.from(value, "hex")) : this.fromBase58(value);
    }
    throw new Error("Cannot construct AccountID from value given");
  }
  /**
   * Defines how to build an AccountID from a base58 r-Address
   *
   * @param value a base58 r-Address
   * @returns an AccountID object
   */
  static fromBase58(value) {
    if ((0, ripple_address_codec_1.isValidXAddress)(value)) {
      const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(value);
      if (classic.tag !== false)
        throw new Error("Only allowed to have tag on Account or Destination");
      value = classic.classicAddress;
    }
    return new AccountID(buffer_1$h.Buffer.from((0, ripple_address_codec_1.decodeAccountID)(value)));
  }
  /**
   * Overload of toJSON
   *
   * @returns the base58 string for this AccountID
   */
  toJSON() {
    return this.toBase58();
  }
  /**
   * Defines how to encode AccountID into a base58 address
   *
   * @returns the base58 string defined by this.bytes
   */
  toBase58() {
    return (0, ripple_address_codec_1.encodeAccountID)(this.bytes);
  }
}
accountId.AccountID = AccountID;
AccountID.defaultAccountID = new AccountID(buffer_1$h.Buffer.alloc(20));
var amount = {};
var decimal = { exports: {} };
(function(module) {
  (function(globalScope) {
    /*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     */
    var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed at run-time using the `Decimal.config` method.
      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,
      // 1 to MAX_DIGITS
      // The rounding mode used when rounding to `precision`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,
      // 0 to 8
      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP         0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
      // FLOOR      3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN  6 The IEEE 754 remainder function.
      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
      //
      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
      // division (9) are commonly used for the modulus operation. The other rounding modes can also
      // be used, but they may not give useful results.
      modulo: 1,
      // 0 to 9
      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,
      // 0 to -EXP_LIMIT
      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos: 21,
      // 0 to EXP_LIMIT
      // The minimum exponent value, beneath which underflow to zero occurs.
      // JavaScript numbers: -324  (5e-324)
      minE: -EXP_LIMIT,
      // -1 to -EXP_LIMIT
      // The maximum exponent value, above which overflow to Infinity occurs.
      // JavaScript numbers: 308  (1.7976931348623157e+308)
      maxE: EXP_LIMIT,
      // 1 to EXP_LIMIT
      // Whether to use cryptographically-secure random number generation, if available.
      crypto: false
      // true/false
    }, Decimal, inexact, noConflict, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex2 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = { toStringTag: tag };
    P.absoluteValue = P.abs = function() {
      var x = new this.constructor(this);
      if (x.s < 0) x.s = 1;
      return finalise(x);
    };
    P.ceil = function() {
      return finalise(new this.constructor(this), this.e + 1, 2);
    };
    P.clampedTo = P.clamp = function(min2, max2) {
      var k, x = this, Ctor = x.constructor;
      min2 = new Ctor(min2);
      max2 = new Ctor(max2);
      if (!min2.s || !max2.s) return new Ctor(NaN);
      if (min2.gt(max2)) throw Error(invalidArgument + max2);
      k = x.cmp(min2);
      return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
    };
    P.comparedTo = P.cmp = function(y) {
      var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
      if (!xd || !yd) {
        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
      }
      if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
      if (xs !== ys) return xs;
      if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
      xdL = xd.length;
      ydL = yd.length;
      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
      }
      return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
    };
    P.cosine = P.cos = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.d) return new Ctor(NaN);
      if (!x.d[0]) return new Ctor(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;
      x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
    };
    P.cubeRoot = P.cbrt = function() {
      var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero()) return new Ctor(x);
      external = false;
      s = x.s * mathpow(x.s * x, 1 / 3);
      if (!s || Math.abs(s) == 1 / 0) {
        n = digitsToString(x.d);
        e = x.e;
        if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
        s = mathpow(n, 1 / 3);
        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new Ctor(n);
        r.s = x.s;
      } else {
        r = new Ctor(s.toString());
      }
      sd = (e = Ctor.precision) + 3;
      for (; ; ) {
        t = r;
        t3 = t.times(t).times(t);
        t3plusx = t3.plus(x);
        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              finalise(t, e + 1, 0);
              if (t.times(t).times(t).eq(x)) {
                r = t;
                break;
              }
            }
            sd += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              finalise(r, e + 1, 1);
              m = !r.times(r).times(r).eq(x);
            }
            break;
          }
        }
      }
      external = true;
      return finalise(r, e, Ctor.rounding, m);
    };
    P.decimalPlaces = P.dp = function() {
      var w, d = this.d, n = NaN;
      if (d) {
        w = d.length - 1;
        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
        w = d[w];
        if (w) for (; w % 10 == 0; w /= 10) n--;
        if (n < 0) n = 0;
      }
      return n;
    };
    P.dividedBy = P.div = function(y) {
      return divide(this, new this.constructor(y));
    };
    P.dividedToIntegerBy = P.divToInt = function(y) {
      var x = this, Ctor = x.constructor;
      return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
    };
    P.equals = P.eq = function(y) {
      return this.cmp(y) === 0;
    };
    P.floor = function() {
      return finalise(new this.constructor(this), this.e + 1, 3);
    };
    P.greaterThan = P.gt = function(y) {
      return this.cmp(y) > 0;
    };
    P.greaterThanOrEqualTo = P.gte = function(y) {
      var k = this.cmp(y);
      return k == 1 || k === 0;
    };
    P.hyperbolicCosine = P.cosh = function() {
      var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
      if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
      if (x.isZero()) return one;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;
      if (len < 32) {
        k = Math.ceil(len / 3);
        n = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        n = "2.3283064365386962890625e-10";
      }
      x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
      var cosh2_x, i = k, d8 = new Ctor(8);
      for (; i--; ) {
        cosh2_x = x.times(x);
        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
      }
      return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
    };
    P.hyperbolicSine = P.sinh = function() {
      var k, pr, rm, len, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;
      if (len < 3) {
        x = taylorSeries(Ctor, 2, x, x, true);
      } else {
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x, true);
        var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sinh2_x = x.times(x);
          x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
        }
      }
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(x, pr, rm, true);
    };
    P.hyperbolicTangent = P.tanh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite()) return new Ctor(x.s);
      if (x.isZero()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 7;
      Ctor.rounding = 1;
      return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
    };
    P.inverseCosine = P.acos = function() {
      var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
      if (k !== -1) {
        return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
      }
      if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);
      Ctor.precision = pr + 6;
      Ctor.rounding = 1;
      x = x.asin();
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return halfPi.minus(x);
    };
    P.inverseHyperbolicCosine = P.acosh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
      if (!x.isFinite()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
      Ctor.rounding = 1;
      external = false;
      x = x.times(x).minus(1).sqrt().plus(x);
      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.ln();
    };
    P.inverseHyperbolicSine = P.asinh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
      Ctor.rounding = 1;
      external = false;
      x = x.times(x).plus(1).sqrt().plus(x);
      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.ln();
    };
    P.inverseHyperbolicTangent = P.atanh = function() {
      var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
      if (!x.isFinite()) return new Ctor(NaN);
      if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      xsd = x.sd();
      if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
      Ctor.precision = wpr = xsd - x.e;
      x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
      Ctor.precision = pr + 4;
      Ctor.rounding = 1;
      x = x.ln();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(0.5);
    };
    P.inverseSine = P.asin = function() {
      var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
      if (x.isZero()) return new Ctor(x);
      k = x.abs().cmp(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (k !== -1) {
        if (k === 0) {
          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
          halfPi.s = x.s;
          return halfPi;
        }
        return new Ctor(NaN);
      }
      Ctor.precision = pr + 6;
      Ctor.rounding = 1;
      x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(2);
    };
    P.inverseTangent = P.atan = function() {
      var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
      if (!x.isFinite()) {
        if (!x.s) return new Ctor(NaN);
        if (pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.5);
          r.s = x.s;
          return r;
        }
      } else if (x.isZero()) {
        return new Ctor(x);
      } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.25);
        r.s = x.s;
        return r;
      }
      Ctor.precision = wpr = pr + 10;
      Ctor.rounding = 1;
      k = Math.min(28, wpr / LOG_BASE + 2 | 0);
      for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
      external = false;
      j = Math.ceil(wpr / LOG_BASE);
      n = 1;
      x2 = x.times(x);
      r = new Ctor(x);
      px = x;
      for (; i !== -1; ) {
        px = px.times(x2);
        t = r.minus(px.div(n += 2));
        px = px.times(x2);
        r = t.plus(px.div(n += 2));
        if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;
      }
      if (k) r = r.times(2 << k - 1);
      external = true;
      return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
    };
    P.isFinite = function() {
      return !!this.d;
    };
    P.isInteger = P.isInt = function() {
      return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
    };
    P.isNaN = function() {
      return !this.s;
    };
    P.isNegative = P.isNeg = function() {
      return this.s < 0;
    };
    P.isPositive = P.isPos = function() {
      return this.s > 0;
    };
    P.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    P.lessThan = P.lt = function(y) {
      return this.cmp(y) < 0;
    };
    P.lessThanOrEqualTo = P.lte = function(y) {
      return this.cmp(y) < 1;
    };
    P.logarithm = P.log = function(base2) {
      var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
      if (base2 == null) {
        base2 = new Ctor(10);
        isBase10 = true;
      } else {
        base2 = new Ctor(base2);
        d = base2.d;
        if (base2.s < 0 || !d || !d[0] || base2.eq(1)) return new Ctor(NaN);
        isBase10 = base2.eq(10);
      }
      d = arg.d;
      if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
      }
      if (isBase10) {
        if (d.length > 1) {
          inf = true;
        } else {
          for (k = d[0]; k % 10 === 0; ) k /= 10;
          inf = k !== 1;
        }
      }
      external = false;
      sd = pr + guard;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd);
      r = divide(num, denominator, sd, 1);
      if (checkRoundingDigits(r.d, k = pr, rm)) {
        do {
          sd += 10;
          num = naturalLogarithm(arg, sd);
          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd);
          r = divide(num, denominator, sd, 1);
          if (!inf) {
            if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
            break;
          }
        } while (checkRoundingDigits(r.d, k += 10, rm));
      }
      external = true;
      return finalise(r, pr, rm);
    };
    P.minus = P.sub = function(y) {
      var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.d) {
        if (!x.s || !y.s) y = new Ctor(NaN);
        else if (x.d) y.s = -y.s;
        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
        return y;
      }
      if (x.s != y.s) {
        y.s = -y.s;
        return x.plus(y);
      }
      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (!xd[0] || !yd[0]) {
        if (yd[0]) y.s = -y.s;
        else if (xd[0]) y = new Ctor(x);
        else return new Ctor(rm === 3 ? -0 : 0);
        return external ? finalise(y, pr, rm) : y;
      }
      e = mathfloor(y.e / LOG_BASE);
      xe = mathfloor(x.e / LOG_BASE);
      xd = xd.slice();
      k = xe - e;
      if (k) {
        xLTy = k < 0;
        if (xLTy) {
          d = xd;
          k = -k;
          len = yd.length;
        } else {
          d = yd;
          e = xe;
          len = xd.length;
        }
        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
        if (k > i) {
          k = i;
          d.length = 1;
        }
        d.reverse();
        for (i = k; i--; ) d.push(0);
        d.reverse();
      } else {
        i = xd.length;
        len = yd.length;
        xLTy = i < len;
        if (xLTy) len = i;
        for (i = 0; i < len; i++) {
          if (xd[i] != yd[i]) {
            xLTy = xd[i] < yd[i];
            break;
          }
        }
        k = 0;
      }
      if (xLTy) {
        d = xd;
        xd = yd;
        yd = d;
        y.s = -y.s;
      }
      len = xd.length;
      for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
      for (i = yd.length; i > k; ) {
        if (xd[--i] < yd[i]) {
          for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
          --xd[j];
          xd[i] += BASE;
        }
        xd[i] -= yd[i];
      }
      for (; xd[--len] === 0; ) xd.pop();
      for (; xd[0] === 0; xd.shift()) --e;
      if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
      y.d = xd;
      y.e = getBase10Exponent(xd, e);
      return external ? finalise(y, pr, rm) : y;
    };
    P.modulo = P.mod = function(y) {
      var q, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
      if (!y.d || x.d && !x.d[0]) {
        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
      }
      external = false;
      if (Ctor.modulo == 9) {
        q = divide(x, y.abs(), 0, 3, 1);
        q.s *= y.s;
      } else {
        q = divide(x, y, 0, Ctor.modulo, 1);
      }
      q = q.times(y);
      external = true;
      return x.minus(q);
    };
    P.naturalExponential = P.exp = function() {
      return naturalExponential(this);
    };
    P.naturalLogarithm = P.ln = function() {
      return naturalLogarithm(this);
    };
    P.negated = P.neg = function() {
      var x = new this.constructor(this);
      x.s = -x.s;
      return finalise(x);
    };
    P.plus = P.add = function(y) {
      var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.d) {
        if (!x.s || !y.s) y = new Ctor(NaN);
        else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
        return y;
      }
      if (x.s != y.s) {
        y.s = -y.s;
        return x.minus(y);
      }
      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (!xd[0] || !yd[0]) {
        if (!yd[0]) y = new Ctor(x);
        return external ? finalise(y, pr, rm) : y;
      }
      k = mathfloor(x.e / LOG_BASE);
      e = mathfloor(y.e / LOG_BASE);
      xd = xd.slice();
      i = k - e;
      if (i) {
        if (i < 0) {
          d = xd;
          i = -i;
          len = yd.length;
        } else {
          d = yd;
          e = k;
          len = xd.length;
        }
        k = Math.ceil(pr / LOG_BASE);
        len = k > len ? k + 1 : len + 1;
        if (i > len) {
          i = len;
          d.length = 1;
        }
        d.reverse();
        for (; i--; ) d.push(0);
        d.reverse();
      }
      len = xd.length;
      i = yd.length;
      if (len - i < 0) {
        i = len;
        d = yd;
        yd = xd;
        xd = d;
      }
      for (carry = 0; i; ) {
        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
        xd[i] %= BASE;
      }
      if (carry) {
        xd.unshift(carry);
        ++e;
      }
      for (len = xd.length; xd[--len] == 0; ) xd.pop();
      y.d = xd;
      y.e = getBase10Exponent(xd, e);
      return external ? finalise(y, pr, rm) : y;
    };
    P.precision = P.sd = function(z) {
      var k, x = this;
      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
      if (x.d) {
        k = getPrecision(x.d);
        if (z && x.e + 1 > k) k = x.e + 1;
      } else {
        k = NaN;
      }
      return k;
    };
    P.round = function() {
      var x = this, Ctor = x.constructor;
      return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
    };
    P.sine = P.sin = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite()) return new Ctor(NaN);
      if (x.isZero()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;
      x = sine(Ctor, toLessThanHalfPi(Ctor, x));
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
    };
    P.squareRoot = P.sqrt = function() {
      var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
      if (s !== 1 || !d || !d[0]) {
        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
      }
      external = false;
      s = Math.sqrt(+x);
      if (s == 0 || s == 1 / 0) {
        n = digitsToString(d);
        if ((n.length + e) % 2 == 0) n += "0";
        s = Math.sqrt(n);
        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new Ctor(n);
      } else {
        r = new Ctor(s.toString());
      }
      sd = (e = Ctor.precision) + 3;
      for (; ; ) {
        t = r;
        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              finalise(t, e + 1, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            sd += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              finalise(r, e + 1, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
      external = true;
      return finalise(r, e, Ctor.rounding, m);
    };
    P.tangent = P.tan = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite()) return new Ctor(NaN);
      if (x.isZero()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 10;
      Ctor.rounding = 1;
      x = x.sin();
      x.s = 1;
      x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
    };
    P.times = P.mul = function(y) {
      var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
      y.s *= x.s;
      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
      }
      e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
      xdL = xd.length;
      ydL = yd.length;
      if (xdL < ydL) {
        r = xd;
        xd = yd;
        yd = r;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
      }
      r = [];
      rL = xdL + ydL;
      for (i = rL; i--; ) r.push(0);
      for (i = ydL; --i >= 0; ) {
        carry = 0;
        for (k = xdL + i; k > i; ) {
          t = r[k] + yd[i] * xd[k - i - 1] + carry;
          r[k--] = t % BASE | 0;
          carry = t / BASE | 0;
        }
        r[k] = (r[k] + carry) % BASE | 0;
      }
      for (; !r[--rL]; ) r.pop();
      if (carry) ++e;
      else r.shift();
      y.d = r;
      y.e = getBase10Exponent(r, e);
      return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
    };
    P.toBinary = function(sd, rm) {
      return toStringBinary(this, 2, sd, rm);
    };
    P.toDecimalPlaces = P.toDP = function(dp, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (dp === void 0) return x;
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
      return finalise(x, dp + x.e + 1, rm);
    };
    P.toExponential = function(dp, rm) {
      var str, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = finiteToString(x, true);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        x = finalise(new Ctor(x), dp + 1, rm);
        str = finiteToString(x, true, dp + 1);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toFixed = function(dp, rm) {
      var str, y, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = finiteToString(x);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        y = finalise(new Ctor(x), dp + x.e + 1, rm);
        str = finiteToString(y, false, dp + y.e + 1);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toFraction = function(maxD) {
      var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
      if (!xd) return new Ctor(x);
      n1 = d0 = new Ctor(1);
      d1 = n0 = new Ctor(0);
      d = new Ctor(d1);
      e = d.e = getPrecision(xd) - x.e - 1;
      k = e % LOG_BASE;
      d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
      if (maxD == null) {
        maxD = e > 0 ? d : n1;
      } else {
        n = new Ctor(maxD);
        if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
        maxD = n.gt(d) ? e > 0 ? d : n1 : n;
      }
      external = false;
      n = new Ctor(digitsToString(xd));
      pr = Ctor.precision;
      Ctor.precision = e = xd.length * LOG_BASE * 2;
      for (; ; ) {
        q = divide(n, d, 0, 1, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.cmp(maxD) == 1) break;
        d0 = d1;
        d1 = d2;
        d2 = n1;
        n1 = n0.plus(q.times(d2));
        n0 = d2;
        d2 = d;
        d = n.minus(q.times(d2));
        n = d2;
      }
      d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
      Ctor.precision = pr;
      external = true;
      return r;
    };
    P.toHexadecimal = P.toHex = function(sd, rm) {
      return toStringBinary(this, 16, sd, rm);
    };
    P.toNearest = function(y, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (y == null) {
        if (!x.d) return x;
        y = new Ctor(1);
        rm = Ctor.rounding;
      } else {
        y = new Ctor(y);
        if (rm === void 0) {
          rm = Ctor.rounding;
        } else {
          checkInt32(rm, 0, 8);
        }
        if (!x.d) return y.s ? x : y;
        if (!y.d) {
          if (y.s) y.s = x.s;
          return y;
        }
      }
      if (y.d[0]) {
        external = false;
        x = divide(x, y, 0, rm, 1).times(y);
        external = true;
        finalise(x);
      } else {
        y.s = x.s;
        x = y;
      }
      return x;
    };
    P.toNumber = function() {
      return +this;
    };
    P.toOctal = function(sd, rm) {
      return toStringBinary(this, 8, sd, rm);
    };
    P.toPower = P.pow = function(y) {
      var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
      if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
      x = new Ctor(x);
      if (x.eq(1)) return x;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (y.eq(1)) return finalise(x, pr, rm);
      e = mathfloor(y.e / LOG_BASE);
      if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r = intPow(Ctor, x, k, pr);
        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
      }
      s = x.s;
      if (s < 0) {
        if (e < y.d.length - 1) return new Ctor(NaN);
        if ((y.d[e] & 1) == 0) s = 1;
        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
          x.s = s;
          return x;
        }
      }
      k = mathpow(+x, yn);
      e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
      if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
      external = false;
      Ctor.rounding = x.s = 1;
      k = Math.min(12, (e + "").length);
      r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
      if (r.d) {
        r = finalise(r, pr + 5, 1);
        if (checkRoundingDigits(r.d, pr, rm)) {
          e = pr + 10;
          r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
          if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
        }
      }
      r.s = s;
      external = true;
      Ctor.rounding = rm;
      return finalise(r, pr, rm);
    };
    P.toPrecision = function(sd, rm) {
      var str, x = this, Ctor = x.constructor;
      if (sd === void 0) {
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        x = finalise(new Ctor(x), sd, rm);
        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toSignificantDigits = P.toSD = function(sd, rm) {
      var x = this, Ctor = x.constructor;
      if (sd === void 0) {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
      }
      return finalise(new Ctor(x), sd, rm);
    };
    P.toString = function() {
      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.truncated = P.trunc = function() {
      return finalise(new this.constructor(this), this.e + 1, 1);
    };
    P.valueOf = P.toJSON = function() {
      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      return x.isNeg() ? "-" + str : str;
    };
    function digitsToString(d) {
      var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
      if (indexOfLastWord > 0) {
        str += w;
        for (i = 1; i < indexOfLastWord; i++) {
          ws = d[i] + "";
          k = LOG_BASE - ws.length;
          if (k) str += getZeroString(k);
          str += ws;
        }
        w = d[i];
        ws = w + "";
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
      } else if (w === 0) {
        return "0";
      }
      for (; w % 10 === 0; ) w /= 10;
      return str + w;
    }
    function checkInt32(i, min2, max2) {
      if (i !== ~~i || i < min2 || i > max2) {
        throw Error(invalidArgument + i);
      }
    }
    function checkRoundingDigits(d, i, rm, repeating) {
      var di, k, r, rd;
      for (k = d[0]; k >= 10; k /= 10) --i;
      if (--i < 0) {
        i += LOG_BASE;
        di = 0;
      } else {
        di = Math.ceil((i + 1) / LOG_BASE);
        i %= LOG_BASE;
      }
      k = mathpow(10, LOG_BASE - i);
      rd = d[di] % k | 0;
      if (repeating == null) {
        if (i < 3) {
          if (i == 0) rd = rd / 100 | 0;
          else if (i == 1) rd = rd / 10 | 0;
          r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
        } else {
          r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
        }
      } else {
        if (i < 4) {
          if (i == 0) rd = rd / 1e3 | 0;
          else if (i == 1) rd = rd / 100 | 0;
          else if (i == 2) rd = rd / 10 | 0;
          r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
        } else {
          r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
        }
      }
      return r;
    }
    function convertBase(str, baseIn, baseOut) {
      var j, arr = [0], arrL, i = 0, strL = str.length;
      for (; i < strL; ) {
        for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
        arr[0] += NUMERALS.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] === void 0) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    function cosine(Ctor, x) {
      var k, len, y;
      if (x.isZero()) return x;
      len = x.d.length;
      if (len < 32) {
        k = Math.ceil(len / 3);
        y = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        y = "2.3283064365386962890625e-10";
      }
      Ctor.precision += k;
      x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
      for (var i = k; i--; ) {
        var cos2x = x.times(x);
        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
      }
      Ctor.precision -= k;
      return x;
    }
    var divide = /* @__PURE__ */ function() {
      function multiplyInteger(x, k, base2) {
        var temp, carry = 0, i = x.length;
        for (x = x.slice(); i--; ) {
          temp = x[i] * k + carry;
          x[i] = temp % base2 | 0;
          carry = temp / base2 | 0;
        }
        if (carry) x.unshift(carry);
        return x;
      }
      function compare2(a, b, aL, bL) {
        var i, r;
        if (aL != bL) {
          r = aL > bL ? 1 : -1;
        } else {
          for (i = r = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              r = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return r;
      }
      function subtract(a, b, aL, base2) {
        var i = 0;
        for (; aL--; ) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base2 + a[aL] - b[aL];
        }
        for (; !a[0] && a.length > 1; ) a.shift();
      }
      return function(x, y, pr, rm, dp, base2) {
        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign6 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(
            // Return NaN if either NaN, or both Infinity or 0.
            !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
              // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
              xd && xd[0] == 0 || !yd ? sign6 * 0 : sign6 / 0
            )
          );
        }
        if (base2) {
          logBase = 1;
          e = x.e - y.e;
        } else {
          base2 = BASE;
          logBase = LOG_BASE;
          e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
        }
        yL = yd.length;
        xL = xd.length;
        q = new Ctor(sign6);
        qd = q.d = [];
        for (i = 0; yd[i] == (xd[i] || 0); i++) ;
        if (yd[i] > (xd[i] || 0)) e--;
        if (pr == null) {
          sd = pr = Ctor.precision;
          rm = Ctor.rounding;
        } else if (dp) {
          sd = pr + (x.e - y.e) + 1;
        } else {
          sd = pr;
        }
        if (sd < 0) {
          qd.push(1);
          more = true;
        } else {
          sd = sd / logBase + 2 | 0;
          i = 0;
          if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;
            for (; (i < xL || k) && sd--; i++) {
              t = k * base2 + (xd[i] || 0);
              qd[i] = t / yd | 0;
              k = t % yd | 0;
            }
            more = k || i < xL;
          } else {
            k = base2 / (yd[0] + 1) | 0;
            if (k > 1) {
              yd = multiplyInteger(yd, k, base2);
              xd = multiplyInteger(xd, k, base2);
              yL = yd.length;
              xL = xd.length;
            }
            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; ) rem[remL++] = 0;
            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];
            if (yd[1] >= base2 / 2) ++yd0;
            do {
              k = 0;
              cmp = compare2(yd, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL) rem0 = rem0 * base2 + (rem[1] || 0);
                k = rem0 / yd0 | 0;
                if (k > 1) {
                  if (k >= base2) k = base2 - 1;
                  prod = multiplyInteger(yd, k, base2);
                  prodL = prod.length;
                  remL = rem.length;
                  cmp = compare2(prod, rem, prodL, remL);
                  if (cmp == 1) {
                    k--;
                    subtract(prod, yL < prodL ? yz : yd, prodL, base2);
                  }
                } else {
                  if (k == 0) cmp = k = 1;
                  prod = yd.slice();
                }
                prodL = prod.length;
                if (prodL < remL) prod.unshift(0);
                subtract(rem, prod, remL, base2);
                if (cmp == -1) {
                  remL = rem.length;
                  cmp = compare2(yd, rem, yL, remL);
                  if (cmp < 1) {
                    k++;
                    subtract(rem, yL < remL ? yz : yd, remL, base2);
                  }
                }
                remL = rem.length;
              } else if (cmp === 0) {
                k++;
                rem = [0];
              }
              qd[i++] = k;
              if (cmp && rem[0]) {
                rem[remL++] = xd[xi] || 0;
              } else {
                rem = [xd[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] !== void 0) && sd--);
            more = rem[0] !== void 0;
          }
          if (!qd[0]) qd.shift();
        }
        if (logBase == 1) {
          q.e = e;
          inexact = more;
        } else {
          for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
          q.e = i + e * logBase - 1;
          finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
        }
        return q;
      };
    }();
    function finalise(x, sd, rm, isTruncated) {
      var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
      out: if (sd != null) {
        xd = x.d;
        if (!xd) return x;
        for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
        i = sd - digits;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          w = xd[xdi = 0];
          rd = w / mathpow(10, digits - j - 1) % 10 | 0;
        } else {
          xdi = Math.ceil((i + 1) / LOG_BASE);
          k = xd.length;
          if (xdi >= k) {
            if (isTruncated) {
              for (; k++ <= xdi; ) xd.push(0);
              w = rd = 0;
              digits = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            w = k = xd[xdi];
            for (digits = 1; k >= 10; k /= 10) digits++;
            i %= LOG_BASE;
            j = i - LOG_BASE + digits;
            rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
          }
        }
        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xd[0]) {
          xd.length = 0;
          if (roundUp) {
            sd -= x.e + 1;
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x.e = -sd || 0;
          } else {
            xd[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xd.length = xdi;
          k = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k = mathpow(10, LOG_BASE - i);
          xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
        }
        if (roundUp) {
          for (; ; ) {
            if (xdi == 0) {
              for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
              j = xd[0] += k;
              for (k = 1; j >= 10; j /= 10) k++;
              if (i != k) {
                x.e++;
                if (xd[0] == BASE) xd[0] = 1;
              }
              break;
            } else {
              xd[xdi] += k;
              if (xd[xdi] != BASE) break;
              xd[xdi--] = 0;
              k = 1;
            }
          }
        }
        for (i = xd.length; xd[--i] === 0; ) xd.pop();
      }
      if (external) {
        if (x.e > Ctor.maxE) {
          x.d = null;
          x.e = NaN;
        } else if (x.e < Ctor.minE) {
          x.e = 0;
          x.d = [0];
        }
      }
      return x;
    }
    function finiteToString(x, isExp, sd) {
      if (!x.isFinite()) return nonFiniteToString(x);
      var k, e = x.e, str = digitsToString(x.d), len = str.length;
      if (isExp) {
        if (sd && (k = sd - len) > 0) {
          str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
        } else if (len > 1) {
          str = str.charAt(0) + "." + str.slice(1);
        }
        str = str + (x.e < 0 ? "e" : "e+") + x.e;
      } else if (e < 0) {
        str = "0." + getZeroString(-e - 1) + str;
        if (sd && (k = sd - len) > 0) str += getZeroString(k);
      } else if (e >= len) {
        str += getZeroString(e + 1 - len);
        if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
      } else {
        if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
        if (sd && (k = sd - len) > 0) {
          if (e + 1 === len) str += ".";
          str += getZeroString(k);
        }
      }
      return str;
    }
    function getBase10Exponent(digits, e) {
      var w = digits[0];
      for (e *= LOG_BASE; w >= 10; w /= 10) e++;
      return e;
    }
    function getLn10(Ctor, sd, pr) {
      if (sd > LN10_PRECISION) {
        external = true;
        if (pr) Ctor.precision = pr;
        throw Error(precisionLimitExceeded);
      }
      return finalise(new Ctor(LN10), sd, 1, true);
    }
    function getPi(Ctor, sd, rm) {
      if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
      return finalise(new Ctor(PI), sd, rm, true);
    }
    function getPrecision(digits) {
      var w = digits.length - 1, len = w * LOG_BASE + 1;
      w = digits[w];
      if (w) {
        for (; w % 10 == 0; w /= 10) len--;
        for (w = digits[0]; w >= 10; w /= 10) len++;
      }
      return len;
    }
    function getZeroString(k) {
      var zs = "";
      for (; k--; ) zs += "0";
      return zs;
    }
    function intPow(Ctor, x, n, pr) {
      var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
      external = false;
      for (; ; ) {
        if (n % 2) {
          r = r.times(x);
          if (truncate(r.d, k)) isTruncated = true;
        }
        n = mathfloor(n / 2);
        if (n === 0) {
          n = r.d.length - 1;
          if (isTruncated && r.d[n] === 0) ++r.d[n];
          break;
        }
        x = x.times(x);
        truncate(x.d, k);
      }
      external = true;
      return r;
    }
    function isOdd(n) {
      return n.d[n.d.length - 1] & 1;
    }
    function maxOrMin(Ctor, args, ltgt) {
      var y, x = new Ctor(args[0]), i = 0;
      for (; ++i < args.length; ) {
        y = new Ctor(args[i]);
        if (!y.s) {
          x = y;
          break;
        } else if (x[ltgt](y)) {
          x = y;
        }
      }
      return x;
    }
    function naturalExponential(x, sd) {
      var denominator, guard, j, pow4, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
      if (!x.d || !x.d[0] || x.e > 17) {
        return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
      }
      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }
      t = new Ctor(0.03125);
      while (x.e > -2) {
        x = x.times(t);
        k += 5;
      }
      guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
      wpr += guard;
      denominator = pow4 = sum2 = new Ctor(1);
      Ctor.precision = wpr;
      for (; ; ) {
        pow4 = finalise(pow4.times(x), wpr, 1);
        denominator = denominator.times(++i);
        t = sum2.plus(divide(pow4, denominator, wpr, 1));
        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
          j = k;
          while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);
          if (sd == null) {
            if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += 10;
              denominator = pow4 = t = new Ctor(1);
              i = 0;
              rep++;
            } else {
              return finalise(sum2, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum2;
          }
        }
        sum2 = t;
      }
    }
    function naturalLogarithm(y, sd) {
      var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
      if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
      }
      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }
      Ctor.precision = wpr += guard;
      c = digitsToString(xd);
      c0 = c.charAt(0);
      if (Math.abs(e = x.e) < 15e14) {
        while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
          x = x.times(y);
          c = digitsToString(x.d);
          c0 = c.charAt(0);
          n++;
        }
        e = x.e;
        if (c0 > 1) {
          x = new Ctor("0." + c);
          e++;
        } else {
          x = new Ctor(c0 + "." + c.slice(1));
        }
      } else {
        t = getLn10(Ctor, wpr + 2, pr).times(e + "");
        x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
        Ctor.precision = pr;
        return sd == null ? finalise(x, pr, rm, external = true) : x;
      }
      x1 = x;
      sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
      x2 = finalise(x.times(x), wpr, 1);
      denominator = 3;
      for (; ; ) {
        numerator = finalise(numerator.times(x2), wpr, 1);
        t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
          sum2 = sum2.times(2);
          if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
          sum2 = divide(sum2, new Ctor(n), wpr, 1);
          if (sd == null) {
            if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += guard;
              t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
              x2 = finalise(x.times(x), wpr, 1);
              denominator = rep = 1;
            } else {
              return finalise(sum2, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum2;
          }
        }
        sum2 = t;
        denominator += 2;
      }
    }
    function nonFiniteToString(x) {
      return String(x.s * x.s / 0);
    }
    function parseDecimal(x, str) {
      var e, i, len;
      if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
      for (i = 0; str.charCodeAt(i) === 48; i++) ;
      for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
      str = str.slice(i, len);
      if (str) {
        len -= i;
        x.e = e = e - i - 1;
        x.d = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;
        if (i < len) {
          if (i) x.d.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
          str = str.slice(i);
          i = LOG_BASE - str.length;
        } else {
          i -= len;
        }
        for (; i--; ) str += "0";
        x.d.push(+str);
        if (external) {
          if (x.e > x.constructor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < x.constructor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
      } else {
        x.e = 0;
        x.d = [0];
      }
      return x;
    }
    function parseOther(x, str) {
      var base2, Ctor, divisor, i, isFloat, len, p, xd, xe;
      if (str.indexOf("_") > -1) {
        str = str.replace(/(\d)_(?=\d)/g, "$1");
        if (isDecimal.test(str)) return parseDecimal(x, str);
      } else if (str === "Infinity" || str === "NaN") {
        if (!+str) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return x;
      }
      if (isHex2.test(str)) {
        base2 = 16;
        str = str.toLowerCase();
      } else if (isBinary.test(str)) {
        base2 = 2;
      } else if (isOctal.test(str)) {
        base2 = 8;
      } else {
        throw Error(invalidArgument + str);
      }
      i = str.search(/p/i);
      if (i > 0) {
        p = +str.slice(i + 1);
        str = str.substring(2, i);
      } else {
        str = str.slice(2);
      }
      i = str.indexOf(".");
      isFloat = i >= 0;
      Ctor = x.constructor;
      if (isFloat) {
        str = str.replace(".", "");
        len = str.length;
        i = len - i;
        divisor = intPow(Ctor, new Ctor(base2), i, i * 2);
      }
      xd = convertBase(str, base2, BASE);
      xe = xd.length - 1;
      for (i = xe; xd[i] === 0; --i) xd.pop();
      if (i < 0) return new Ctor(x.s * 0);
      x.e = getBase10Exponent(xd, xe);
      x.d = xd;
      external = false;
      if (isFloat) x = divide(x, divisor, len * 4);
      if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
      external = true;
      return x;
    }
    function sine(Ctor, x) {
      var k, len = x.d.length;
      if (len < 3) {
        return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
      }
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;
      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x);
      var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
      for (; k--; ) {
        sin2_x = x.times(x);
        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
      }
      return x;
    }
    function taylorSeries(Ctor, n, x, y, isHyperbolic) {
      var j, t, u, x2, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
      external = false;
      x2 = x.times(x);
      u = new Ctor(y);
      for (; ; ) {
        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
        u = isHyperbolic ? y.plus(t) : y.minus(t);
        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
        t = u.plus(y);
        if (t.d[k] !== void 0) {
          for (j = k; t.d[j] === u.d[j] && j--; ) ;
          if (j == -1) break;
        }
        j = u;
        u = y;
        y = t;
        t = j;
      }
      external = true;
      t.d.length = k + 1;
      return t;
    }
    function tinyPow(b, e) {
      var n = b;
      while (--e) n *= b;
      return n;
    }
    function toLessThanHalfPi(Ctor, x) {
      var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
      x = x.abs();
      if (x.lte(halfPi)) {
        quadrant = isNeg ? 4 : 1;
        return x;
      }
      t = x.divToInt(pi);
      if (t.isZero()) {
        quadrant = isNeg ? 3 : 2;
      } else {
        x = x.minus(t.times(pi));
        if (x.lte(halfPi)) {
          quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
          return x;
        }
        quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
      }
      return x.minus(pi).abs();
    }
    function toStringBinary(x, baseOut, sd, rm) {
      var base2, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
      if (isExp) {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
      } else {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      }
      if (!x.isFinite()) {
        str = nonFiniteToString(x);
      } else {
        str = finiteToString(x);
        i = str.indexOf(".");
        if (isExp) {
          base2 = 2;
          if (baseOut == 16) {
            sd = sd * 4 - 3;
          } else if (baseOut == 8) {
            sd = sd * 3 - 2;
          }
        } else {
          base2 = baseOut;
        }
        if (i >= 0) {
          str = str.replace(".", "");
          y = new Ctor(1);
          y.e = str.length - i;
          y.d = convertBase(finiteToString(y), 10, base2);
          y.e = y.d.length;
        }
        xd = convertBase(str, 10, base2);
        e = len = xd.length;
        for (; xd[--len] == 0; ) xd.pop();
        if (!xd[0]) {
          str = isExp ? "0p+0" : "0";
        } else {
          if (i < 0) {
            e--;
          } else {
            x = new Ctor(x);
            x.d = xd;
            x.e = e;
            x = divide(x, y, sd, rm, 0, base2);
            xd = x.d;
            e = x.e;
            roundUp = inexact;
          }
          i = xd[sd];
          k = base2 / 2;
          roundUp = roundUp || xd[sd + 1] !== void 0;
          roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
          xd.length = sd;
          if (roundUp) {
            for (; ++xd[--sd] > base2 - 1; ) {
              xd[sd] = 0;
              if (!sd) {
                ++e;
                xd.unshift(1);
              }
            }
          }
          for (len = xd.length; !xd[len - 1]; --len) ;
          for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
          if (isExp) {
            if (len > 1) {
              if (baseOut == 16 || baseOut == 8) {
                i = baseOut == 16 ? 4 : 3;
                for (--len; len % i; len++) str += "0";
                xd = convertBase(str, base2, baseOut);
                for (len = xd.length; !xd[len - 1]; --len) ;
                for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
              } else {
                str = str.charAt(0) + "." + str.slice(1);
              }
            }
            str = str + (e < 0 ? "p" : "p+") + e;
          } else if (e < 0) {
            for (; ++e; ) str = "0" + str;
            str = "0." + str;
          } else {
            if (++e > len) for (e -= len; e--; ) str += "0";
            else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
      }
      return x.s < 0 ? "-" + str : str;
    }
    function truncate(arr, len) {
      if (arr.length > len) {
        arr.length = len;
        return true;
      }
    }
    function abs(x) {
      return new this(x).abs();
    }
    function acos(x) {
      return new this(x).acos();
    }
    function acosh(x) {
      return new this(x).acosh();
    }
    function add6(x, y) {
      return new this(x).plus(y);
    }
    function asin(x) {
      return new this(x).asin();
    }
    function asinh(x) {
      return new this(x).asinh();
    }
    function atan(x) {
      return new this(x).atan();
    }
    function atanh(x) {
      return new this(x).atanh();
    }
    function atan2(y, x) {
      y = new this(y);
      x = new this(x);
      var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
      if (!y.s || !x.s) {
        r = new this(NaN);
      } else if (!y.d && !x.d) {
        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
        r.s = y.s;
      } else if (!x.d || y.isZero()) {
        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
        r.s = y.s;
      } else if (!y.d || x.isZero()) {
        r = getPi(this, wpr, 1).times(0.5);
        r.s = y.s;
      } else if (x.s < 0) {
        this.precision = wpr;
        this.rounding = 1;
        r = this.atan(divide(y, x, wpr, 1));
        x = getPi(this, wpr, 1);
        this.precision = pr;
        this.rounding = rm;
        r = y.s < 0 ? r.minus(x) : r.plus(x);
      } else {
        r = this.atan(divide(y, x, wpr, 1));
      }
      return r;
    }
    function cbrt(x) {
      return new this(x).cbrt();
    }
    function ceil(x) {
      return finalise(x = new this(x), x.e + 1, 2);
    }
    function clamp(x, min2, max2) {
      return new this(x).clamp(min2, max2);
    }
    function config2(obj) {
      if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
      var i, p, v, useDefaults = obj.defaults === true, ps = [
        "precision",
        1,
        MAX_DIGITS,
        "rounding",
        0,
        8,
        "toExpNeg",
        -EXP_LIMIT,
        0,
        "toExpPos",
        0,
        EXP_LIMIT,
        "maxE",
        0,
        EXP_LIMIT,
        "minE",
        -EXP_LIMIT,
        0,
        "modulo",
        0,
        9
      ];
      for (i = 0; i < ps.length; i += 3) {
        if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
          else throw Error(invalidArgument + p + ": " + v);
        }
      }
      if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (v === true || v === false || v === 0 || v === 1) {
          if (v) {
            if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
              this[p] = true;
            } else {
              throw Error(cryptoUnavailable);
            }
          } else {
            this[p] = false;
          }
        } else {
          throw Error(invalidArgument + p + ": " + v);
        }
      }
      return this;
    }
    function cos(x) {
      return new this(x).cos();
    }
    function cosh(x) {
      return new this(x).cosh();
    }
    function clone(obj) {
      var i, p, ps;
      function Decimal2(v) {
        var e, i2, t, x = this;
        if (!(x instanceof Decimal2)) return new Decimal2(v);
        x.constructor = Decimal2;
        if (isDecimalInstance(v)) {
          x.s = v.s;
          if (external) {
            if (!v.d || v.e > Decimal2.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (v.e < Decimal2.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = v.e;
              x.d = v.d.slice();
            }
          } else {
            x.e = v.e;
            x.d = v.d ? v.d.slice() : v.d;
          }
          return;
        }
        t = typeof v;
        if (t === "number") {
          if (v === 0) {
            x.s = 1 / v < 0 ? -1 : 1;
            x.e = 0;
            x.d = [0];
            return;
          }
          if (v < 0) {
            v = -v;
            x.s = -1;
          } else {
            x.s = 1;
          }
          if (v === ~~v && v < 1e7) {
            for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
            if (external) {
              if (e > Decimal2.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (e < Decimal2.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = e;
                x.d = [v];
              }
            } else {
              x.e = e;
              x.d = [v];
            }
            return;
          } else if (v * 0 !== 0) {
            if (!v) x.s = NaN;
            x.e = NaN;
            x.d = null;
            return;
          }
          return parseDecimal(x, v.toString());
        } else if (t !== "string") {
          throw Error(invalidArgument + v);
        }
        if ((i2 = v.charCodeAt(0)) === 45) {
          v = v.slice(1);
          x.s = -1;
        } else {
          if (i2 === 43) v = v.slice(1);
          x.s = 1;
        }
        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
      }
      Decimal2.prototype = P;
      Decimal2.ROUND_UP = 0;
      Decimal2.ROUND_DOWN = 1;
      Decimal2.ROUND_CEIL = 2;
      Decimal2.ROUND_FLOOR = 3;
      Decimal2.ROUND_HALF_UP = 4;
      Decimal2.ROUND_HALF_DOWN = 5;
      Decimal2.ROUND_HALF_EVEN = 6;
      Decimal2.ROUND_HALF_CEIL = 7;
      Decimal2.ROUND_HALF_FLOOR = 8;
      Decimal2.EUCLID = 9;
      Decimal2.config = Decimal2.set = config2;
      Decimal2.clone = clone;
      Decimal2.isDecimal = isDecimalInstance;
      Decimal2.abs = abs;
      Decimal2.acos = acos;
      Decimal2.acosh = acosh;
      Decimal2.add = add6;
      Decimal2.asin = asin;
      Decimal2.asinh = asinh;
      Decimal2.atan = atan;
      Decimal2.atanh = atanh;
      Decimal2.atan2 = atan2;
      Decimal2.cbrt = cbrt;
      Decimal2.ceil = ceil;
      Decimal2.clamp = clamp;
      Decimal2.cos = cos;
      Decimal2.cosh = cosh;
      Decimal2.div = div;
      Decimal2.exp = exp;
      Decimal2.floor = floor;
      Decimal2.hypot = hypot;
      Decimal2.ln = ln;
      Decimal2.log = log;
      Decimal2.log10 = log10;
      Decimal2.log2 = log2;
      Decimal2.max = max;
      Decimal2.min = min;
      Decimal2.mod = mod2;
      Decimal2.mul = mul5;
      Decimal2.pow = pow3;
      Decimal2.random = random2;
      Decimal2.round = round;
      Decimal2.sign = sign5;
      Decimal2.sin = sin;
      Decimal2.sinh = sinh;
      Decimal2.sqrt = sqrt;
      Decimal2.sub = sub;
      Decimal2.sum = sum;
      Decimal2.tan = tan;
      Decimal2.tanh = tanh;
      Decimal2.trunc = trunc;
      if (obj === void 0) obj = {};
      if (obj) {
        if (obj.defaults !== true) {
          ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
          for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
        }
      }
      Decimal2.config(obj);
      return Decimal2;
    }
    function div(x, y) {
      return new this(x).div(y);
    }
    function exp(x) {
      return new this(x).exp();
    }
    function floor(x) {
      return finalise(x = new this(x), x.e + 1, 3);
    }
    function hypot() {
      var i, n, t = new this(0);
      external = false;
      for (i = 0; i < arguments.length; ) {
        n = new this(arguments[i++]);
        if (!n.d) {
          if (n.s) {
            external = true;
            return new this(1 / 0);
          }
          t = n;
        } else if (t.d) {
          t = t.plus(n.times(n));
        }
      }
      external = true;
      return t.sqrt();
    }
    function isDecimalInstance(obj) {
      return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
    }
    function ln(x) {
      return new this(x).ln();
    }
    function log(x, y) {
      return new this(x).log(y);
    }
    function log2(x) {
      return new this(x).log(2);
    }
    function log10(x) {
      return new this(x).log(10);
    }
    function max() {
      return maxOrMin(this, arguments, "lt");
    }
    function min() {
      return maxOrMin(this, arguments, "gt");
    }
    function mod2(x, y) {
      return new this(x).mod(y);
    }
    function mul5(x, y) {
      return new this(x).mul(y);
    }
    function pow3(x, y) {
      return new this(x).pow(y);
    }
    function random2(sd) {
      var d, e, k, n, i = 0, r = new this(1), rd = [];
      if (sd === void 0) sd = this.precision;
      else checkInt32(sd, 1, MAX_DIGITS);
      k = Math.ceil(sd / LOG_BASE);
      if (!this.crypto) {
        for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
      } else if (crypto.getRandomValues) {
        d = crypto.getRandomValues(new Uint32Array(k));
        for (; i < k; ) {
          n = d[i];
          if (n >= 429e7) {
            d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
          } else {
            rd[i++] = n % 1e7;
          }
        }
      } else if (crypto.randomBytes) {
        d = crypto.randomBytes(k *= 4);
        for (; i < k; ) {
          n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
          if (n >= 214e7) {
            crypto.randomBytes(4).copy(d, i);
          } else {
            rd.push(n % 1e7);
            i += 4;
          }
        }
        i = k / 4;
      } else {
        throw Error(cryptoUnavailable);
      }
      k = rd[--i];
      sd %= LOG_BASE;
      if (k && sd) {
        n = mathpow(10, LOG_BASE - sd);
        rd[i] = (k / n | 0) * n;
      }
      for (; rd[i] === 0; i--) rd.pop();
      if (i < 0) {
        e = 0;
        rd = [0];
      } else {
        e = -1;
        for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
        for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
        if (k < LOG_BASE) e -= LOG_BASE - k;
      }
      r.e = e;
      r.d = rd;
      return r;
    }
    function round(x) {
      return finalise(x = new this(x), x.e + 1, this.rounding);
    }
    function sign5(x) {
      x = new this(x);
      return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
    }
    function sin(x) {
      return new this(x).sin();
    }
    function sinh(x) {
      return new this(x).sinh();
    }
    function sqrt(x) {
      return new this(x).sqrt();
    }
    function sub(x, y) {
      return new this(x).sub(y);
    }
    function sum() {
      var i = 0, args = arguments, x = new this(args[i]);
      external = false;
      for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
      external = true;
      return finalise(x, this.precision, this.rounding);
    }
    function tan(x) {
      return new this(x).tan();
    }
    function tanh(x) {
      return new this(x).tanh();
    }
    function trunc(x) {
      return finalise(x = new this(x), x.e + 1, 1);
    }
    Decimal = clone(DEFAULTS);
    Decimal.prototype.constructor = Decimal;
    Decimal["default"] = Decimal.Decimal = Decimal;
    LN10 = new Decimal(LN10);
    PI = new Decimal(PI);
    if (module.exports) {
      if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
        P[Symbol["for"]("nodejs.util.inspect.custom")] = P.toString;
        P[Symbol.toStringTag] = "Decimal";
      }
      module.exports = Decimal;
    } else {
      if (!globalScope) {
        globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
      }
      noConflict = globalScope.Decimal;
      Decimal.noConflict = function() {
        globalScope.Decimal = noConflict;
        return Decimal;
      };
      globalScope.Decimal = Decimal;
    }
  })(commonjsGlobal);
})(decimal);
var decimalExports = decimal.exports;
var binaryParser = {};
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule) return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding$1(result, mod2, k);
  }
  __setModuleDefault$1(result, mod2);
  return result;
};
Object.defineProperty(binaryParser, "__esModule", { value: true });
binaryParser.BinaryParser = void 0;
const assert$1 = __importStar$1(requireAssert());
const enums_1 = enums;
const buffer_1$g = dist$h;
class BinaryParser {
  /**
   * Initialize bytes to a hex string
   *
   * @param hexBytes a hex string
   * @param definitions Rippled definitions used to parse the values of transaction types and such.
   *                          Can be customized for sidechains and amendments.
   */
  constructor(hexBytes, definitions = enums_1.DEFAULT_DEFINITIONS) {
    this.bytes = buffer_1$g.Buffer.from(hexBytes, "hex");
    this.definitions = definitions;
  }
  /**
   * Peek the first byte of the BinaryParser
   *
   * @returns The first byte of the BinaryParser
   */
  peek() {
    assert$1.ok(this.bytes.byteLength !== 0);
    return this.bytes[0];
  }
  /**
   * Consume the first n bytes of the BinaryParser
   *
   * @param n the number of bytes to skip
   */
  skip(n) {
    assert$1.ok(n <= this.bytes.byteLength);
    this.bytes = this.bytes.slice(n);
  }
  /**
   * read the first n bytes from the BinaryParser
   *
   * @param n The number of bytes to read
   * @return The bytes
   */
  read(n) {
    assert$1.ok(n <= this.bytes.byteLength);
    const slice2 = this.bytes.slice(0, n);
    this.skip(n);
    return slice2;
  }
  /**
   * Read an integer of given size
   *
   * @param n The number of bytes to read
   * @return The number represented by those bytes
   */
  readUIntN(n) {
    assert$1.ok(0 < n && n <= 4, "invalid n");
    return this.read(n).reduce((a, b) => a << 8 | b) >>> 0;
  }
  readUInt8() {
    return this.readUIntN(1);
  }
  readUInt16() {
    return this.readUIntN(2);
  }
  readUInt32() {
    return this.readUIntN(4);
  }
  size() {
    return this.bytes.byteLength;
  }
  end(customEnd) {
    const length = this.bytes.byteLength;
    return length === 0 || customEnd !== void 0 && length <= customEnd;
  }
  /**
   * Reads variable length encoded bytes
   *
   * @return The variable length bytes
   */
  readVariableLength() {
    return this.read(this.readVariableLengthLength());
  }
  /**
   * Reads the length of the variable length encoded bytes
   *
   * @return The length of the variable length encoded bytes
   */
  readVariableLengthLength() {
    const b1 = this.readUInt8();
    if (b1 <= 192) {
      return b1;
    } else if (b1 <= 240) {
      const b2 = this.readUInt8();
      return 193 + (b1 - 193) * 256 + b2;
    } else if (b1 <= 254) {
      const b2 = this.readUInt8();
      const b3 = this.readUInt8();
      return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;
    }
    throw new Error("Invalid variable length indicator");
  }
  /**
   * Reads the field ordinal from the BinaryParser
   *
   * @return Field ordinal
   */
  readFieldOrdinal() {
    let type = this.readUInt8();
    let nth = type & 15;
    type >>= 4;
    if (type === 0) {
      type = this.readUInt8();
      if (type === 0 || type < 16) {
        throw new Error("Cannot read FieldOrdinal, type_code out of range");
      }
    }
    if (nth === 0) {
      nth = this.readUInt8();
      if (nth === 0 || nth < 16) {
        throw new Error("Cannot read FieldOrdinal, field_code out of range");
      }
    }
    return type << 16 | nth;
  }
  /**
   * Read the field from the BinaryParser
   *
   * @return The field represented by the bytes at the head of the BinaryParser
   */
  readField() {
    return this.definitions.field.fromString(this.readFieldOrdinal().toString());
  }
  /**
   * Read a given type from the BinaryParser
   *
   * @param type The type that you want to read from the BinaryParser
   * @return The instance of that type read from the BinaryParser
   */
  readType(type) {
    return type.fromParser(this);
  }
  /**
   * Get the type associated with a given field
   *
   * @param field The field that you wan to get the type of
   * @return The type associated with the given field
   */
  typeForField(field2) {
    return field2.associatedType;
  }
  /**
   * Read value of the type specified by field from the BinaryParser
   *
   * @param field The field that you want to get the associated value for
   * @return The value associated with the given field
   */
  readFieldValue(field2) {
    const type = this.typeForField(field2);
    if (!type) {
      throw new Error(`unsupported: (${field2.name}, ${field2.type.name})`);
    }
    const sizeHint = field2.isVariableLengthEncoded ? this.readVariableLengthLength() : void 0;
    const value = type.fromParser(this, sizeHint);
    if (value === void 0) {
      throw new Error(`fromParser for (${field2.name}, ${field2.type.name}) -> undefined `);
    }
    return value;
  }
  /**
   * Get the next field and value from the BinaryParser
   *
   * @return The field and value
   */
  readFieldAndValue() {
    const field2 = this.readField();
    return [field2, this.readFieldValue(field2)];
  }
}
binaryParser.BinaryParser = BinaryParser;
var currency = {};
Object.defineProperty(currency, "__esModule", { value: true });
currency.Currency = void 0;
const hash_160_1 = hash160;
const buffer_1$f = dist$h;
const XRP_HEX_REGEX = /^0{40}$/;
const ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\]|]{3}$/;
const HEX_REGEX$1 = /^[A-F0-9]{40}$/;
const STANDARD_FORMAT_HEX_REGEX = /^0{24}[\x00-\x7F]{6}0{10}$/;
function isoToBytes(iso) {
  const bytes2 = buffer_1$f.Buffer.alloc(20);
  if (iso !== "XRP") {
    const isoBytes = iso.split("").map((c) => c.charCodeAt(0));
    bytes2.set(isoBytes, 12);
  }
  return bytes2;
}
function isIsoCode(iso) {
  return ISO_REGEX.test(iso);
}
function isoCodeFromHex(code) {
  const iso = code.toString();
  if (iso === "XRP") {
    return null;
  }
  if (isIsoCode(iso)) {
    return iso;
  }
  return null;
}
function isHex(hex) {
  return HEX_REGEX$1.test(hex);
}
function isStringRepresentation(input) {
  return input.length === 3 || isHex(input);
}
function isBytesArray(bytes2) {
  return bytes2.byteLength === 20;
}
function isValidRepresentation(input) {
  return input instanceof buffer_1$f.Buffer ? isBytesArray(input) : isStringRepresentation(input);
}
function bytesFromRepresentation(input) {
  if (!isValidRepresentation(input)) {
    throw new Error(`Unsupported Currency representation: ${input}`);
  }
  return input.length === 3 ? isoToBytes(input) : buffer_1$f.Buffer.from(input, "hex");
}
class Currency extends hash_160_1.Hash160 {
  constructor(byteBuf) {
    super(byteBuf !== null && byteBuf !== void 0 ? byteBuf : Currency.XRP.bytes);
    const hex = this.bytes.toString("hex");
    if (XRP_HEX_REGEX.test(hex)) {
      this._iso = "XRP";
    } else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {
      this._iso = isoCodeFromHex(this.bytes.slice(12, 15));
    } else {
      this._iso = null;
    }
  }
  /**
   * Return the ISO code of this currency
   *
   * @returns ISO code if it exists, else null
   */
  iso() {
    return this._iso;
  }
  /**
   * Constructs a Currency object
   *
   * @param val Currency object or a string representation of a currency
   */
  static from(value) {
    if (value instanceof Currency) {
      return value;
    }
    if (typeof value === "string") {
      return new Currency(bytesFromRepresentation(value));
    }
    throw new Error("Cannot construct Currency from value given");
  }
  /**
   * Gets the JSON representation of a currency
   *
   * @returns JSON representation
   */
  toJSON() {
    const iso = this.iso();
    if (iso !== null) {
      return iso;
    }
    return this.bytes.toString("hex").toUpperCase();
  }
}
currency.Currency = Currency;
Currency.XRP = new Currency(buffer_1$f.Buffer.alloc(20));
var BigInteger = { exports: {} };
(function(module) {
  var bigInt2 = function(undefined$1) {
    var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
    var supportsNativeBigInt = typeof BigInt === "function";
    function Integer(v, radix, alphabet, caseSensitive) {
      if (typeof v === "undefined") return Integer[0];
      if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
      return parseValue(v);
    }
    function BigInteger2(value, sign5) {
      this.value = value;
      this.sign = sign5;
      this.isSmall = false;
    }
    BigInteger2.prototype = Object.create(Integer.prototype);
    function SmallInteger(value) {
      this.value = value;
      this.sign = value < 0;
      this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);
    function NativeBigInt(value) {
      this.value = value;
    }
    NativeBigInt.prototype = Object.create(Integer.prototype);
    function isPrecise(n) {
      return -MAX_INT < n && n < MAX_INT;
    }
    function smallToArray(n) {
      if (n < 1e7)
        return [n];
      if (n < 1e14)
        return [n % 1e7, Math.floor(n / 1e7)];
      return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }
    function arrayToSmall(arr) {
      trim(arr);
      var length = arr.length;
      if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
        switch (length) {
          case 0:
            return 0;
          case 1:
            return arr[0];
          case 2:
            return arr[0] + arr[1] * BASE;
          default:
            return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
        }
      }
      return arr;
    }
    function trim(v) {
      var i2 = v.length;
      while (v[--i2] === 0) ;
      v.length = i2 + 1;
    }
    function createArray(length) {
      var x = new Array(length);
      var i2 = -1;
      while (++i2 < length) {
        x[i2] = 0;
      }
      return x;
    }
    function truncate(n) {
      if (n > 0) return Math.floor(n);
      return Math.ceil(n);
    }
    function add6(a, b) {
      var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base2 = BASE, sum, i2;
      for (i2 = 0; i2 < l_b; i2++) {
        sum = a[i2] + b[i2] + carry;
        carry = sum >= base2 ? 1 : 0;
        r[i2] = sum - carry * base2;
      }
      while (i2 < l_a) {
        sum = a[i2] + carry;
        carry = sum === base2 ? 1 : 0;
        r[i2++] = sum - carry * base2;
      }
      if (carry > 0) r.push(carry);
      return r;
    }
    function addAny(a, b) {
      if (a.length >= b.length) return add6(a, b);
      return add6(b, a);
    }
    function addSmall(a, carry) {
      var l = a.length, r = new Array(l), base2 = BASE, sum, i2;
      for (i2 = 0; i2 < l; i2++) {
        sum = a[i2] - base2 + carry;
        carry = Math.floor(sum / base2);
        r[i2] = sum - carry * base2;
        carry += 1;
      }
      while (carry > 0) {
        r[i2++] = carry % base2;
        carry = Math.floor(carry / base2);
      }
      return r;
    }
    BigInteger2.prototype.add = function(v) {
      var n = parseValue(v);
      if (this.sign !== n.sign) {
        return this.subtract(n.negate());
      }
      var a = this.value, b = n.value;
      if (n.isSmall) {
        return new BigInteger2(addSmall(a, Math.abs(b)), this.sign);
      }
      return new BigInteger2(addAny(a, b), this.sign);
    };
    BigInteger2.prototype.plus = BigInteger2.prototype.add;
    SmallInteger.prototype.add = function(v) {
      var n = parseValue(v);
      var a = this.value;
      if (a < 0 !== n.sign) {
        return this.subtract(n.negate());
      }
      var b = n.value;
      if (n.isSmall) {
        if (isPrecise(a + b)) return new SmallInteger(a + b);
        b = smallToArray(Math.abs(b));
      }
      return new BigInteger2(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;
    NativeBigInt.prototype.add = function(v) {
      return new NativeBigInt(this.value + parseValue(v).value);
    };
    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
    function subtract(a, b) {
      var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base2 = BASE, i2, difference;
      for (i2 = 0; i2 < b_l; i2++) {
        difference = a[i2] - borrow - b[i2];
        if (difference < 0) {
          difference += base2;
          borrow = 1;
        } else borrow = 0;
        r[i2] = difference;
      }
      for (i2 = b_l; i2 < a_l; i2++) {
        difference = a[i2] - borrow;
        if (difference < 0) difference += base2;
        else {
          r[i2++] = difference;
          break;
        }
        r[i2] = difference;
      }
      for (; i2 < a_l; i2++) {
        r[i2] = a[i2];
      }
      trim(r);
      return r;
    }
    function subtractAny(a, b, sign5) {
      var value;
      if (compareAbs(a, b) >= 0) {
        value = subtract(a, b);
      } else {
        value = subtract(b, a);
        sign5 = !sign5;
      }
      value = arrayToSmall(value);
      if (typeof value === "number") {
        if (sign5) value = -value;
        return new SmallInteger(value);
      }
      return new BigInteger2(value, sign5);
    }
    function subtractSmall(a, b, sign5) {
      var l = a.length, r = new Array(l), carry = -b, base2 = BASE, i2, difference;
      for (i2 = 0; i2 < l; i2++) {
        difference = a[i2] + carry;
        carry = Math.floor(difference / base2);
        difference %= base2;
        r[i2] = difference < 0 ? difference + base2 : difference;
      }
      r = arrayToSmall(r);
      if (typeof r === "number") {
        if (sign5) r = -r;
        return new SmallInteger(r);
      }
      return new BigInteger2(r, sign5);
    }
    BigInteger2.prototype.subtract = function(v) {
      var n = parseValue(v);
      if (this.sign !== n.sign) {
        return this.add(n.negate());
      }
      var a = this.value, b = n.value;
      if (n.isSmall)
        return subtractSmall(a, Math.abs(b), this.sign);
      return subtractAny(a, b, this.sign);
    };
    BigInteger2.prototype.minus = BigInteger2.prototype.subtract;
    SmallInteger.prototype.subtract = function(v) {
      var n = parseValue(v);
      var a = this.value;
      if (a < 0 !== n.sign) {
        return this.add(n.negate());
      }
      var b = n.value;
      if (n.isSmall) {
        return new SmallInteger(a - b);
      }
      return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
    NativeBigInt.prototype.subtract = function(v) {
      return new NativeBigInt(this.value - parseValue(v).value);
    };
    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
    BigInteger2.prototype.negate = function() {
      return new BigInteger2(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function() {
      var sign5 = this.sign;
      var small = new SmallInteger(-this.value);
      small.sign = !sign5;
      return small;
    };
    NativeBigInt.prototype.negate = function() {
      return new NativeBigInt(-this.value);
    };
    BigInteger2.prototype.abs = function() {
      return new BigInteger2(this.value, false);
    };
    SmallInteger.prototype.abs = function() {
      return new SmallInteger(Math.abs(this.value));
    };
    NativeBigInt.prototype.abs = function() {
      return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    };
    function multiplyLong(a, b) {
      var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base2 = BASE, product, carry, i2, a_i, b_j;
      for (i2 = 0; i2 < a_l; ++i2) {
        a_i = a[i2];
        for (var j = 0; j < b_l; ++j) {
          b_j = b[j];
          product = a_i * b_j + r[i2 + j];
          carry = Math.floor(product / base2);
          r[i2 + j] = product - carry * base2;
          r[i2 + j + 1] += carry;
        }
      }
      trim(r);
      return r;
    }
    function multiplySmall(a, b) {
      var l = a.length, r = new Array(l), base2 = BASE, carry = 0, product, i2;
      for (i2 = 0; i2 < l; i2++) {
        product = a[i2] * b + carry;
        carry = Math.floor(product / base2);
        r[i2] = product - carry * base2;
      }
      while (carry > 0) {
        r[i2++] = carry % base2;
        carry = Math.floor(carry / base2);
      }
      return r;
    }
    function shiftLeft(x, n) {
      var r = [];
      while (n-- > 0) r.push(0);
      return r.concat(x);
    }
    function multiplyKaratsuba(x, y) {
      var n = Math.max(x.length, y.length);
      if (n <= 30) return multiplyLong(x, y);
      n = Math.ceil(n / 2);
      var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
      var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
      var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
      trim(product);
      return product;
    }
    function useKaratsuba(l1, l2) {
      return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;
    }
    BigInteger2.prototype.multiply = function(v) {
      var n = parseValue(v), a = this.value, b = n.value, sign5 = this.sign !== n.sign, abs;
      if (n.isSmall) {
        if (b === 0) return Integer[0];
        if (b === 1) return this;
        if (b === -1) return this.negate();
        abs = Math.abs(b);
        if (abs < BASE) {
          return new BigInteger2(multiplySmall(a, abs), sign5);
        }
        b = smallToArray(abs);
      }
      if (useKaratsuba(a.length, b.length))
        return new BigInteger2(multiplyKaratsuba(a, b), sign5);
      return new BigInteger2(multiplyLong(a, b), sign5);
    };
    BigInteger2.prototype.times = BigInteger2.prototype.multiply;
    function multiplySmallAndArray(a, b, sign5) {
      if (a < BASE) {
        return new BigInteger2(multiplySmall(b, a), sign5);
      }
      return new BigInteger2(multiplyLong(b, smallToArray(a)), sign5);
    }
    SmallInteger.prototype._multiplyBySmall = function(a) {
      if (isPrecise(a.value * this.value)) {
        return new SmallInteger(a.value * this.value);
      }
      return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger2.prototype._multiplyBySmall = function(a) {
      if (a.value === 0) return Integer[0];
      if (a.value === 1) return this;
      if (a.value === -1) return this.negate();
      return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function(v) {
      return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;
    NativeBigInt.prototype.multiply = function(v) {
      return new NativeBigInt(this.value * parseValue(v).value);
    };
    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
    function square(a) {
      var l = a.length, r = createArray(l + l), base2 = BASE, product, carry, i2, a_i, a_j;
      for (i2 = 0; i2 < l; i2++) {
        a_i = a[i2];
        carry = 0 - a_i * a_i;
        for (var j = i2; j < l; j++) {
          a_j = a[j];
          product = 2 * (a_i * a_j) + r[i2 + j] + carry;
          carry = Math.floor(product / base2);
          r[i2 + j] = product - carry * base2;
        }
        r[i2 + l] = carry;
      }
      trim(r);
      return r;
    }
    BigInteger2.prototype.square = function() {
      return new BigInteger2(square(this.value), false);
    };
    SmallInteger.prototype.square = function() {
      var value = this.value * this.value;
      if (isPrecise(value)) return new SmallInteger(value);
      return new BigInteger2(square(smallToArray(Math.abs(this.value))), false);
    };
    NativeBigInt.prototype.square = function(v) {
      return new NativeBigInt(this.value * this.value);
    };
    function divMod1(a, b) {
      var a_l = a.length, b_l = b.length, base2 = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base2 / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l, q;
      if (remainder.length <= a_l) remainder.push(0);
      divisor.push(0);
      divisorMostSignificantDigit = divisor[b_l - 1];
      for (shift = a_l - b_l; shift >= 0; shift--) {
        quotientDigit = base2 - 1;
        if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
          quotientDigit = Math.floor((remainder[shift + b_l] * base2 + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
        }
        carry = 0;
        borrow = 0;
        l = divisor.length;
        for (i2 = 0; i2 < l; i2++) {
          carry += quotientDigit * divisor[i2];
          q = Math.floor(carry / base2);
          borrow += remainder[shift + i2] - (carry - q * base2);
          carry = q;
          if (borrow < 0) {
            remainder[shift + i2] = borrow + base2;
            borrow = -1;
          } else {
            remainder[shift + i2] = borrow;
            borrow = 0;
          }
        }
        while (borrow !== 0) {
          quotientDigit -= 1;
          carry = 0;
          for (i2 = 0; i2 < l; i2++) {
            carry += remainder[shift + i2] - base2 + divisor[i2];
            if (carry < 0) {
              remainder[shift + i2] = carry + base2;
              carry = 0;
            } else {
              remainder[shift + i2] = carry;
              carry = 1;
            }
          }
          borrow += carry;
        }
        result[shift] = quotientDigit;
      }
      remainder = divModSmall(remainder, lambda)[0];
      return [arrayToSmall(result), arrayToSmall(remainder)];
    }
    function divMod2(a, b) {
      var a_l = a.length, b_l = b.length, result = [], part = [], base2 = BASE, guess, xlen, highx, highy, check;
      while (a_l) {
        part.unshift(a[--a_l]);
        trim(part);
        if (compareAbs(part, b) < 0) {
          result.push(0);
          continue;
        }
        xlen = part.length;
        highx = part[xlen - 1] * base2 + part[xlen - 2];
        highy = b[b_l - 1] * base2 + b[b_l - 2];
        if (xlen > b_l) {
          highx = (highx + 1) * base2;
        }
        guess = Math.ceil(highx / highy);
        do {
          check = multiplySmall(b, guess);
          if (compareAbs(check, part) <= 0) break;
          guess--;
        } while (guess);
        result.push(guess);
        part = subtract(part, check);
      }
      result.reverse();
      return [arrayToSmall(result), arrayToSmall(part)];
    }
    function divModSmall(value, lambda) {
      var length = value.length, quotient = createArray(length), base2 = BASE, i2, q, remainder, divisor;
      remainder = 0;
      for (i2 = length - 1; i2 >= 0; --i2) {
        divisor = remainder * base2 + value[i2];
        q = truncate(divisor / lambda);
        remainder = divisor - q * lambda;
        quotient[i2] = q | 0;
      }
      return [quotient, remainder | 0];
    }
    function divModAny(self2, v) {
      var value, n = parseValue(v);
      if (supportsNativeBigInt) {
        return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];
      }
      var a = self2.value, b = n.value;
      var quotient;
      if (b === 0) throw new Error("Cannot divide by zero");
      if (self2.isSmall) {
        if (n.isSmall) {
          return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
        }
        return [Integer[0], self2];
      }
      if (n.isSmall) {
        if (b === 1) return [self2, Integer[0]];
        if (b == -1) return [self2.negate(), Integer[0]];
        var abs = Math.abs(b);
        if (abs < BASE) {
          value = divModSmall(a, abs);
          quotient = arrayToSmall(value[0]);
          var remainder = value[1];
          if (self2.sign) remainder = -remainder;
          if (typeof quotient === "number") {
            if (self2.sign !== n.sign) quotient = -quotient;
            return [new SmallInteger(quotient), new SmallInteger(remainder)];
          }
          return [new BigInteger2(quotient, self2.sign !== n.sign), new SmallInteger(remainder)];
        }
        b = smallToArray(abs);
      }
      var comparison = compareAbs(a, b);
      if (comparison === -1) return [Integer[0], self2];
      if (comparison === 0) return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];
      if (a.length + b.length <= 200)
        value = divMod1(a, b);
      else value = divMod2(a, b);
      quotient = value[0];
      var qSign = self2.sign !== n.sign, mod2 = value[1], mSign = self2.sign;
      if (typeof quotient === "number") {
        if (qSign) quotient = -quotient;
        quotient = new SmallInteger(quotient);
      } else quotient = new BigInteger2(quotient, qSign);
      if (typeof mod2 === "number") {
        if (mSign) mod2 = -mod2;
        mod2 = new SmallInteger(mod2);
      } else mod2 = new BigInteger2(mod2, mSign);
      return [quotient, mod2];
    }
    BigInteger2.prototype.divmod = function(v) {
      var result = divModAny(this, v);
      return {
        quotient: result[0],
        remainder: result[1]
      };
    };
    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger2.prototype.divmod;
    BigInteger2.prototype.divide = function(v) {
      return divModAny(this, v)[0];
    };
    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
      return new NativeBigInt(this.value / parseValue(v).value);
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger2.prototype.over = BigInteger2.prototype.divide;
    BigInteger2.prototype.mod = function(v) {
      return divModAny(this, v)[1];
    };
    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
      return new NativeBigInt(this.value % parseValue(v).value);
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger2.prototype.remainder = BigInteger2.prototype.mod;
    BigInteger2.prototype.pow = function(v) {
      var n = parseValue(v), a = this.value, b = n.value, value, x, y;
      if (b === 0) return Integer[1];
      if (a === 0) return Integer[0];
      if (a === 1) return Integer[1];
      if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
      if (n.sign) {
        return Integer[0];
      }
      if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
      if (this.isSmall) {
        if (isPrecise(value = Math.pow(a, b)))
          return new SmallInteger(truncate(value));
      }
      x = this;
      y = Integer[1];
      while (true) {
        if (b & true) {
          y = y.times(x);
          --b;
        }
        if (b === 0) break;
        b /= 2;
        x = x.square();
      }
      return y;
    };
    SmallInteger.prototype.pow = BigInteger2.prototype.pow;
    NativeBigInt.prototype.pow = function(v) {
      var n = parseValue(v);
      var a = this.value, b = n.value;
      var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
      if (b === _0) return Integer[1];
      if (a === _0) return Integer[0];
      if (a === _1) return Integer[1];
      if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
      if (n.isNegative()) return new NativeBigInt(_0);
      var x = this;
      var y = Integer[1];
      while (true) {
        if ((b & _1) === _1) {
          y = y.times(x);
          --b;
        }
        if (b === _0) break;
        b /= _2;
        x = x.square();
      }
      return y;
    };
    BigInteger2.prototype.modPow = function(exp, mod2) {
      exp = parseValue(exp);
      mod2 = parseValue(mod2);
      if (mod2.isZero()) throw new Error("Cannot take modPow with modulus 0");
      var r = Integer[1], base2 = this.mod(mod2);
      if (exp.isNegative()) {
        exp = exp.multiply(Integer[-1]);
        base2 = base2.modInv(mod2);
      }
      while (exp.isPositive()) {
        if (base2.isZero()) return Integer[0];
        if (exp.isOdd()) r = r.multiply(base2).mod(mod2);
        exp = exp.divide(2);
        base2 = base2.square().mod(mod2);
      }
      return r;
    };
    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger2.prototype.modPow;
    function compareAbs(a, b) {
      if (a.length !== b.length) {
        return a.length > b.length ? 1 : -1;
      }
      for (var i2 = a.length - 1; i2 >= 0; i2--) {
        if (a[i2] !== b[i2]) return a[i2] > b[i2] ? 1 : -1;
      }
      return 0;
    }
    BigInteger2.prototype.compareAbs = function(v) {
      var n = parseValue(v), a = this.value, b = n.value;
      if (n.isSmall) return 1;
      return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function(v) {
      var n = parseValue(v), a = Math.abs(this.value), b = n.value;
      if (n.isSmall) {
        b = Math.abs(b);
        return a === b ? 0 : a > b ? 1 : -1;
      }
      return -1;
    };
    NativeBigInt.prototype.compareAbs = function(v) {
      var a = this.value;
      var b = parseValue(v).value;
      a = a >= 0 ? a : -a;
      b = b >= 0 ? b : -b;
      return a === b ? 0 : a > b ? 1 : -1;
    };
    BigInteger2.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var n = parseValue(v), a = this.value, b = n.value;
      if (this.sign !== n.sign) {
        return n.sign ? 1 : -1;
      }
      if (n.isSmall) {
        return this.sign ? -1 : 1;
      }
      return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger2.prototype.compareTo = BigInteger2.prototype.compare;
    SmallInteger.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var n = parseValue(v), a = this.value, b = n.value;
      if (n.isSmall) {
        return a == b ? 0 : a > b ? 1 : -1;
      }
      if (a < 0 !== n.sign) {
        return a < 0 ? -1 : 1;
      }
      return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
    NativeBigInt.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var a = this.value;
      var b = parseValue(v).value;
      return a === b ? 0 : a > b ? 1 : -1;
    };
    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
    BigInteger2.prototype.equals = function(v) {
      return this.compare(v) === 0;
    };
    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger2.prototype.eq = BigInteger2.prototype.equals;
    BigInteger2.prototype.notEquals = function(v) {
      return this.compare(v) !== 0;
    };
    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger2.prototype.neq = BigInteger2.prototype.notEquals;
    BigInteger2.prototype.greater = function(v) {
      return this.compare(v) > 0;
    };
    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger2.prototype.gt = BigInteger2.prototype.greater;
    BigInteger2.prototype.lesser = function(v) {
      return this.compare(v) < 0;
    };
    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger2.prototype.lt = BigInteger2.prototype.lesser;
    BigInteger2.prototype.greaterOrEquals = function(v) {
      return this.compare(v) >= 0;
    };
    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger2.prototype.geq = BigInteger2.prototype.greaterOrEquals;
    BigInteger2.prototype.lesserOrEquals = function(v) {
      return this.compare(v) <= 0;
    };
    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger2.prototype.leq = BigInteger2.prototype.lesserOrEquals;
    BigInteger2.prototype.isEven = function() {
      return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function() {
      return (this.value & 1) === 0;
    };
    NativeBigInt.prototype.isEven = function() {
      return (this.value & BigInt(1)) === BigInt(0);
    };
    BigInteger2.prototype.isOdd = function() {
      return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function() {
      return (this.value & 1) === 1;
    };
    NativeBigInt.prototype.isOdd = function() {
      return (this.value & BigInt(1)) === BigInt(1);
    };
    BigInteger2.prototype.isPositive = function() {
      return !this.sign;
    };
    SmallInteger.prototype.isPositive = function() {
      return this.value > 0;
    };
    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
    BigInteger2.prototype.isNegative = function() {
      return this.sign;
    };
    SmallInteger.prototype.isNegative = function() {
      return this.value < 0;
    };
    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
    BigInteger2.prototype.isUnit = function() {
      return false;
    };
    SmallInteger.prototype.isUnit = function() {
      return Math.abs(this.value) === 1;
    };
    NativeBigInt.prototype.isUnit = function() {
      return this.abs().value === BigInt(1);
    };
    BigInteger2.prototype.isZero = function() {
      return false;
    };
    SmallInteger.prototype.isZero = function() {
      return this.value === 0;
    };
    NativeBigInt.prototype.isZero = function() {
      return this.value === BigInt(0);
    };
    BigInteger2.prototype.isDivisibleBy = function(v) {
      var n = parseValue(v);
      if (n.isZero()) return false;
      if (n.isUnit()) return true;
      if (n.compareAbs(2) === 0) return this.isEven();
      return this.mod(n).isZero();
    };
    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger2.prototype.isDivisibleBy;
    function isBasicPrime(v) {
      var n = v.abs();
      if (n.isUnit()) return false;
      if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
      if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
      if (n.lesser(49)) return true;
    }
    function millerRabinTest(n, a) {
      var nPrev = n.prev(), b = nPrev, r = 0, d, i2, x;
      while (b.isEven()) b = b.divide(2), r++;
      next: for (i2 = 0; i2 < a.length; i2++) {
        if (n.lesser(a[i2])) continue;
        x = bigInt2(a[i2]).modPow(b, n);
        if (x.isUnit() || x.equals(nPrev)) continue;
        for (d = r - 1; d != 0; d--) {
          x = x.square().mod(n);
          if (x.isUnit()) return false;
          if (x.equals(nPrev)) continue next;
        }
        return false;
      }
      return true;
    }
    BigInteger2.prototype.isPrime = function(strict) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined$1) return isPrime;
      var n = this.abs();
      var bits = n.bitLength();
      if (bits <= 64)
        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
      var logN = Math.log(2) * bits.toJSNumber();
      var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
      for (var a = [], i2 = 0; i2 < t; i2++) {
        a.push(bigInt2(i2 + 2));
      }
      return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger2.prototype.isPrime;
    BigInteger2.prototype.isProbablePrime = function(iterations, rng2) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined$1) return isPrime;
      var n = this.abs();
      var t = iterations === undefined$1 ? 5 : iterations;
      for (var a = [], i2 = 0; i2 < t; i2++) {
        a.push(bigInt2.randBetween(2, n.minus(2), rng2));
      }
      return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger2.prototype.isProbablePrime;
    BigInteger2.prototype.modInv = function(n) {
      var t = bigInt2.zero, newT = bigInt2.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
      while (!newR.isZero()) {
        q = r.divide(newR);
        lastT = t;
        lastR = r;
        t = newT;
        r = newR;
        newT = lastT.subtract(q.multiply(newT));
        newR = lastR.subtract(q.multiply(newR));
      }
      if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
      if (t.compare(0) === -1) {
        t = t.add(n);
      }
      if (this.isNegative()) {
        return t.negate();
      }
      return t;
    };
    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger2.prototype.modInv;
    BigInteger2.prototype.next = function() {
      var value = this.value;
      if (this.sign) {
        return subtractSmall(value, 1, this.sign);
      }
      return new BigInteger2(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function() {
      var value = this.value;
      if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
      return new BigInteger2(MAX_INT_ARR, false);
    };
    NativeBigInt.prototype.next = function() {
      return new NativeBigInt(this.value + BigInt(1));
    };
    BigInteger2.prototype.prev = function() {
      var value = this.value;
      if (this.sign) {
        return new BigInteger2(addSmall(value, 1), true);
      }
      return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function() {
      var value = this.value;
      if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
      return new BigInteger2(MAX_INT_ARR, true);
    };
    NativeBigInt.prototype.prev = function() {
      return new NativeBigInt(this.value - BigInt(1));
    };
    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
    function shift_isSmall(n) {
      return Math.abs(n) <= BASE;
    }
    BigInteger2.prototype.shiftLeft = function(v) {
      var n = parseValue(v).toJSNumber();
      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }
      if (n < 0) return this.shiftRight(-n);
      var result = this;
      if (result.isZero()) return result;
      while (n >= powers2Length) {
        result = result.multiply(highestPower2);
        n -= powers2Length - 1;
      }
      return result.multiply(powersOfTwo[n]);
    };
    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger2.prototype.shiftLeft;
    BigInteger2.prototype.shiftRight = function(v) {
      var remQuo;
      var n = parseValue(v).toJSNumber();
      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }
      if (n < 0) return this.shiftLeft(-n);
      var result = this;
      while (n >= powers2Length) {
        if (result.isZero() || result.isNegative() && result.isUnit()) return result;
        remQuo = divModAny(result, highestPower2);
        result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        n -= powers2Length - 1;
      }
      remQuo = divModAny(result, powersOfTwo[n]);
      return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger2.prototype.shiftRight;
    function bitwise(x, y, fn) {
      y = parseValue(y);
      var xSign = x.isNegative(), ySign = y.isNegative();
      var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
      var xDigit = 0, yDigit = 0;
      var xDivMod = null, yDivMod = null;
      var result = [];
      while (!xRem.isZero() || !yRem.isZero()) {
        xDivMod = divModAny(xRem, highestPower2);
        xDigit = xDivMod[1].toJSNumber();
        if (xSign) {
          xDigit = highestPower2 - 1 - xDigit;
        }
        yDivMod = divModAny(yRem, highestPower2);
        yDigit = yDivMod[1].toJSNumber();
        if (ySign) {
          yDigit = highestPower2 - 1 - yDigit;
        }
        xRem = xDivMod[0];
        yRem = yDivMod[0];
        result.push(fn(xDigit, yDigit));
      }
      var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt2(-1) : bigInt2(0);
      for (var i2 = result.length - 1; i2 >= 0; i2 -= 1) {
        sum = sum.multiply(highestPower2).add(bigInt2(result[i2]));
      }
      return sum;
    }
    BigInteger2.prototype.not = function() {
      return this.negate().prev();
    };
    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger2.prototype.not;
    BigInteger2.prototype.and = function(n) {
      return bitwise(this, n, function(a, b) {
        return a & b;
      });
    };
    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger2.prototype.and;
    BigInteger2.prototype.or = function(n) {
      return bitwise(this, n, function(a, b) {
        return a | b;
      });
    };
    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger2.prototype.or;
    BigInteger2.prototype.xor = function(n) {
      return bitwise(this, n, function(a, b) {
        return a ^ b;
      });
    };
    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger2.prototype.xor;
    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) {
      var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
      return x & -x;
    }
    function integerLogarithm(value, base2) {
      if (base2.compareTo(value) <= 0) {
        var tmp = integerLogarithm(value, base2.square(base2));
        var p = tmp.p;
        var e = tmp.e;
        var t = p.multiply(base2);
        return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };
      }
      return { p: bigInt2(1), e: 0 };
    }
    BigInteger2.prototype.bitLength = function() {
      var n = this;
      if (n.compareTo(bigInt2(0)) < 0) {
        n = n.negate().subtract(bigInt2(1));
      }
      if (n.compareTo(bigInt2(0)) === 0) {
        return bigInt2(0);
      }
      return bigInt2(integerLogarithm(n, bigInt2(2)).e).add(bigInt2(1));
    };
    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger2.prototype.bitLength;
    function max(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.greater(b) ? a : b;
    }
    function min(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      if (a.equals(b)) return a;
      if (a.isZero()) return b;
      if (b.isZero()) return a;
      var c = Integer[1], d, t;
      while (a.isEven() && b.isEven()) {
        d = min(roughLOB(a), roughLOB(b));
        a = a.divide(d);
        b = b.divide(d);
        c = c.multiply(d);
      }
      while (a.isEven()) {
        a = a.divide(roughLOB(a));
      }
      do {
        while (b.isEven()) {
          b = b.divide(roughLOB(b));
        }
        if (a.greater(b)) {
          t = b;
          b = a;
          a = t;
        }
        b = b.subtract(a);
      } while (!b.isZero());
      return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b, rng2) {
      a = parseValue(a);
      b = parseValue(b);
      var usedRNG = rng2 || Math.random;
      var low = min(a, b), high = max(a, b);
      var range = high.subtract(low).add(1);
      if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
      var digits = toBase(range, BASE).value;
      var result = [], restricted = true;
      for (var i2 = 0; i2 < digits.length; i2++) {
        var top = restricted ? digits[i2] + (i2 + 1 < digits.length ? digits[i2 + 1] / BASE : 0) : BASE;
        var digit = truncate(usedRNG() * top);
        result.push(digit);
        if (digit < digits[i2]) restricted = false;
      }
      return low.add(Integer.fromArray(result, BASE, false));
    }
    var parseBase = function(text, base2, alphabet, caseSensitive) {
      alphabet = alphabet || DEFAULT_ALPHABET;
      text = String(text);
      if (!caseSensitive) {
        text = text.toLowerCase();
        alphabet = alphabet.toLowerCase();
      }
      var length = text.length;
      var i2;
      var absBase = Math.abs(base2);
      var alphabetValues = {};
      for (i2 = 0; i2 < alphabet.length; i2++) {
        alphabetValues[alphabet[i2]] = i2;
      }
      for (i2 = 0; i2 < length; i2++) {
        var c = text[i2];
        if (c === "-") continue;
        if (c in alphabetValues) {
          if (alphabetValues[c] >= absBase) {
            if (c === "1" && absBase === 1) continue;
            throw new Error(c + " is not a valid digit in base " + base2 + ".");
          }
        }
      }
      base2 = parseValue(base2);
      var digits = [];
      var isNegative = text[0] === "-";
      for (i2 = isNegative ? 1 : 0; i2 < text.length; i2++) {
        var c = text[i2];
        if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
        else if (c === "<") {
          var start = i2;
          do {
            i2++;
          } while (text[i2] !== ">" && i2 < text.length);
          digits.push(parseValue(text.slice(start + 1, i2)));
        } else throw new Error(c + " is not a valid character");
      }
      return parseBaseFromArray(digits, base2, isNegative);
    };
    function parseBaseFromArray(digits, base2, isNegative) {
      var val = Integer[0], pow3 = Integer[1], i2;
      for (i2 = digits.length - 1; i2 >= 0; i2--) {
        val = val.add(digits[i2].times(pow3));
        pow3 = pow3.times(base2);
      }
      return isNegative ? val.negate() : val;
    }
    function stringify2(digit, alphabet) {
      alphabet = alphabet || DEFAULT_ALPHABET;
      if (digit < alphabet.length) {
        return alphabet[digit];
      }
      return "<" + digit + ">";
    }
    function toBase(n, base2) {
      base2 = bigInt2(base2);
      if (base2.isZero()) {
        if (n.isZero()) return { value: [0], isNegative: false };
        throw new Error("Cannot convert nonzero numbers to base 0.");
      }
      if (base2.equals(-1)) {
        if (n.isZero()) return { value: [0], isNegative: false };
        if (n.isNegative())
          return {
            value: [].concat.apply(
              [],
              Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
            ),
            isNegative: false
          };
        var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
        arr.unshift([1]);
        return {
          value: [].concat.apply([], arr),
          isNegative: false
        };
      }
      var neg4 = false;
      if (n.isNegative() && base2.isPositive()) {
        neg4 = true;
        n = n.abs();
      }
      if (base2.isUnit()) {
        if (n.isZero()) return { value: [0], isNegative: false };
        return {
          value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
          isNegative: neg4
        };
      }
      var out = [];
      var left = n, divmod;
      while (left.isNegative() || left.compareAbs(base2) >= 0) {
        divmod = left.divmod(base2);
        left = divmod.quotient;
        var digit = divmod.remainder;
        if (digit.isNegative()) {
          digit = base2.minus(digit).abs();
          left = left.next();
        }
        out.push(digit.toJSNumber());
      }
      out.push(left.toJSNumber());
      return { value: out.reverse(), isNegative: neg4 };
    }
    function toBaseString(n, base2, alphabet) {
      var arr = toBase(n, base2);
      return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
        return stringify2(x, alphabet);
      }).join("");
    }
    BigInteger2.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    SmallInteger.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    NativeBigInt.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    BigInteger2.prototype.toString = function(radix, alphabet) {
      if (radix === undefined$1) radix = 10;
      if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);
      var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
      while (--l >= 0) {
        digit = String(v[l]);
        str += zeros.slice(digit.length) + digit;
      }
      var sign5 = this.sign ? "-" : "";
      return sign5 + str;
    };
    SmallInteger.prototype.toString = function(radix, alphabet) {
      if (radix === undefined$1) radix = 10;
      if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);
      return String(this.value);
    };
    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
    NativeBigInt.prototype.toJSON = BigInteger2.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
      return this.toString();
    };
    BigInteger2.prototype.valueOf = function() {
      return parseInt(this.toString(), 10);
    };
    BigInteger2.prototype.toJSNumber = BigInteger2.prototype.valueOf;
    SmallInteger.prototype.valueOf = function() {
      return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
      return parseInt(this.toString(), 10);
    };
    function parseStringValue(v) {
      if (isPrecise(+v)) {
        var x = +v;
        if (x === truncate(x))
          return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
        throw new Error("Invalid integer: " + v);
      }
      var sign5 = v[0] === "-";
      if (sign5) v = v.slice(1);
      var split2 = v.split(/e/i);
      if (split2.length > 2) throw new Error("Invalid integer: " + split2.join("e"));
      if (split2.length === 2) {
        var exp = split2[1];
        if (exp[0] === "+") exp = exp.slice(1);
        exp = +exp;
        if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
        var text = split2[0];
        var decimalPlace = text.indexOf(".");
        if (decimalPlace >= 0) {
          exp -= text.length - decimalPlace - 1;
          text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
        }
        if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
        text += new Array(exp + 1).join("0");
        v = text;
      }
      var isValid = /^([0-9][0-9]*)$/.test(v);
      if (!isValid) throw new Error("Invalid integer: " + v);
      if (supportsNativeBigInt) {
        return new NativeBigInt(BigInt(sign5 ? "-" + v : v));
      }
      var r = [], max2 = v.length, l = LOG_BASE, min2 = max2 - l;
      while (max2 > 0) {
        r.push(+v.slice(min2, max2));
        min2 -= l;
        if (min2 < 0) min2 = 0;
        max2 -= l;
      }
      trim(r);
      return new BigInteger2(r, sign5);
    }
    function parseNumberValue(v) {
      if (supportsNativeBigInt) {
        return new NativeBigInt(BigInt(v));
      }
      if (isPrecise(v)) {
        if (v !== truncate(v)) throw new Error(v + " is not an integer.");
        return new SmallInteger(v);
      }
      return parseStringValue(v.toString());
    }
    function parseValue(v) {
      if (typeof v === "number") {
        return parseNumberValue(v);
      }
      if (typeof v === "string") {
        return parseStringValue(v);
      }
      if (typeof v === "bigint") {
        return new NativeBigInt(v);
      }
      return v;
    }
    for (var i = 0; i < 1e3; i++) {
      Integer[i] = parseValue(i);
      if (i > 0) Integer[-i] = parseValue(-i);
    }
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function(x) {
      return x instanceof BigInteger2 || x instanceof SmallInteger || x instanceof NativeBigInt;
    };
    Integer.randBetween = randBetween;
    Integer.fromArray = function(digits, base2, isNegative) {
      return parseBaseFromArray(digits.map(parseValue), parseValue(base2 || 10), isNegative);
    };
    return Integer;
  }();
  if (module.hasOwnProperty("exports")) {
    module.exports = bigInt2;
  }
})(BigInteger);
var BigIntegerExports = BigInteger.exports;
Object.defineProperty(amount, "__esModule", { value: true });
amount.Amount = void 0;
const decimal_js_1$1 = decimalExports;
const binary_parser_1$4 = binaryParser;
const account_id_1$3 = accountId;
const currency_1$2 = currency;
const serialized_type_1$6 = serializedType;
const bigInt$3 = BigIntegerExports;
const buffer_1$e = dist$h;
const MIN_IOU_EXPONENT = -96;
const MAX_IOU_EXPONENT = 80;
const MAX_IOU_PRECISION = 16;
const MAX_DROPS = new decimal_js_1$1.Decimal("1e17");
const MIN_XRP = new decimal_js_1$1.Decimal("1e-6");
const mask$1 = bigInt$3(4294967295);
decimal_js_1$1.Decimal.config({
  toExpPos: MAX_IOU_EXPONENT + MAX_IOU_PRECISION,
  toExpNeg: MIN_IOU_EXPONENT - MAX_IOU_PRECISION
});
function isAmountObject(arg) {
  const keys2 = Object.keys(arg).sort();
  return keys2.length === 3 && keys2[0] === "currency" && keys2[1] === "issuer" && keys2[2] === "value";
}
class Amount extends serialized_type_1$6.SerializedType {
  constructor(bytes2) {
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : Amount.defaultAmount.bytes);
  }
  /**
   * Construct an amount from an IOU or string amount
   *
   * @param value An Amount, object representing an IOU, or a string
   *     representing an integer amount
   * @returns An Amount object
   */
  static from(value) {
    if (value instanceof Amount) {
      return value;
    }
    let amount2 = buffer_1$e.Buffer.alloc(8);
    if (typeof value === "string") {
      Amount.assertXrpIsValid(value);
      const number2 = bigInt$3(value);
      const intBuf = [buffer_1$e.Buffer.alloc(4), buffer_1$e.Buffer.alloc(4)];
      intBuf[0].writeUInt32BE(Number(number2.shiftRight(32)), 0);
      intBuf[1].writeUInt32BE(Number(number2.and(mask$1)), 0);
      amount2 = buffer_1$e.Buffer.concat(intBuf);
      amount2[0] |= 64;
      return new Amount(amount2);
    }
    if (isAmountObject(value)) {
      const number2 = new decimal_js_1$1.Decimal(value.value);
      Amount.assertIouIsValid(number2);
      if (number2.isZero()) {
        amount2[0] |= 128;
      } else {
        const integerNumberString = number2.times(`1e${-(number2.e - 15)}`).abs().toString();
        const num = bigInt$3(integerNumberString);
        const intBuf = [buffer_1$e.Buffer.alloc(4), buffer_1$e.Buffer.alloc(4)];
        intBuf[0].writeUInt32BE(Number(num.shiftRight(32)), 0);
        intBuf[1].writeUInt32BE(Number(num.and(mask$1)), 0);
        amount2 = buffer_1$e.Buffer.concat(intBuf);
        amount2[0] |= 128;
        if (number2.gt(new decimal_js_1$1.Decimal(0))) {
          amount2[0] |= 64;
        }
        const exponent = number2.e - 15;
        const exponentByte = 97 + exponent;
        amount2[0] |= exponentByte >>> 2;
        amount2[1] |= (exponentByte & 3) << 6;
      }
      const currency2 = currency_1$2.Currency.from(value.currency).toBytes();
      const issuer = account_id_1$3.AccountID.from(value.issuer).toBytes();
      return new Amount(buffer_1$e.Buffer.concat([amount2, currency2, issuer]));
    }
    throw new Error("Invalid type to construct an Amount");
  }
  /**
   * Read an amount from a BinaryParser
   *
   * @param parser BinaryParser to read the Amount from
   * @returns An Amount object
   */
  static fromParser(parser) {
    const isXRP = parser.peek() & 128;
    const numBytes = isXRP ? 48 : 8;
    return new Amount(parser.read(numBytes));
  }
  /**
   * Get the JSON representation of this Amount
   *
   * @returns the JSON interpretation of this.bytes
   */
  toJSON() {
    if (this.isNative()) {
      const bytes2 = this.bytes;
      const isPositive = bytes2[0] & 64;
      const sign5 = isPositive ? "" : "-";
      bytes2[0] &= 63;
      const msb = bigInt$3(bytes2.slice(0, 4).readUInt32BE(0));
      const lsb = bigInt$3(bytes2.slice(4).readUInt32BE(0));
      const num = msb.shiftLeft(32).or(lsb);
      return `${sign5}${num.toString()}`;
    } else {
      const parser = new binary_parser_1$4.BinaryParser(this.toString());
      const mantissa = parser.read(8);
      const currency2 = currency_1$2.Currency.fromParser(parser);
      const issuer = account_id_1$3.AccountID.fromParser(parser);
      const b1 = mantissa[0];
      const b2 = mantissa[1];
      const isPositive = b1 & 64;
      const sign5 = isPositive ? "" : "-";
      const exponent = ((b1 & 63) << 2) + ((b2 & 255) >> 6) - 97;
      mantissa[0] = 0;
      mantissa[1] &= 63;
      const value = new decimal_js_1$1.Decimal(`${sign5}0x${mantissa.toString("hex")}`).times(`1e${exponent}`);
      Amount.assertIouIsValid(value);
      return {
        value: value.toString(),
        currency: currency2.toJSON(),
        issuer: issuer.toJSON()
      };
    }
  }
  /**
   * Validate XRP amount
   *
   * @param amount String representing XRP amount
   * @returns void, but will throw if invalid amount
   */
  static assertXrpIsValid(amount2) {
    if (amount2.indexOf(".") !== -1) {
      throw new Error(`${amount2.toString()} is an illegal amount`);
    }
    const decimal2 = new decimal_js_1$1.Decimal(amount2);
    if (!decimal2.isZero()) {
      if (decimal2.lt(MIN_XRP) || decimal2.gt(MAX_DROPS)) {
        throw new Error(`${amount2.toString()} is an illegal amount`);
      }
    }
  }
  /**
   * Validate IOU.value amount
   *
   * @param decimal Decimal.js object representing IOU.value
   * @returns void, but will throw if invalid amount
   */
  static assertIouIsValid(decimal2) {
    if (!decimal2.isZero()) {
      const p = decimal2.precision();
      const e = decimal2.e - 15;
      if (p > MAX_IOU_PRECISION || e > MAX_IOU_EXPONENT || e < MIN_IOU_EXPONENT) {
        throw new Error("Decimal precision out of range");
      }
      this.verifyNoDecimal(decimal2);
    }
  }
  /**
   * Ensure that the value after being multiplied by the exponent does not
   * contain a decimal.
   *
   * @param decimal a Decimal object
   * @returns a string of the object without a decimal
   */
  static verifyNoDecimal(decimal2) {
    const integerNumberString = decimal2.times(`1e${-(decimal2.e - 15)}`).abs().toString();
    if (integerNumberString.indexOf(".") !== -1) {
      throw new Error("Decimal place found in integerNumberString");
    }
  }
  /**
   * Test if this amount is in units of Native Currency(XRP)
   *
   * @returns true if Native (XRP)
   */
  isNative() {
    return (this.bytes[0] & 128) === 0;
  }
}
amount.Amount = Amount;
Amount.defaultAmount = new Amount(buffer_1$e.Buffer.from("4000000000000000", "hex"));
var blob = {};
Object.defineProperty(blob, "__esModule", { value: true });
blob.Blob = void 0;
const serialized_type_1$5 = serializedType;
const buffer_1$d = dist$h;
class Blob extends serialized_type_1$5.SerializedType {
  constructor(bytes2) {
    super(bytes2);
  }
  /**
   * Defines how to read a Blob from a BinaryParser
   *
   * @param parser The binary parser to read the Blob from
   * @param hint The length of the blob, computed by readVariableLengthLength() and passed in
   * @returns A Blob object
   */
  static fromParser(parser, hint) {
    return new Blob(parser.read(hint));
  }
  /**
   * Create a Blob object from a hex-string
   *
   * @param value existing Blob object or a hex-string
   * @returns A Blob object
   */
  static from(value) {
    if (value instanceof Blob) {
      return value;
    }
    if (typeof value === "string") {
      return new Blob(buffer_1$d.Buffer.from(value, "hex"));
    }
    throw new Error("Cannot construct Blob from value given");
  }
}
blob.Blob = Blob;
var hash128 = {};
Object.defineProperty(hash128, "__esModule", { value: true });
hash128.Hash128 = void 0;
const hash_1$1 = hash2;
const buffer_1$c = dist$h;
class Hash128 extends hash_1$1.Hash {
  constructor(bytes2) {
    if (bytes2 && bytes2.byteLength === 0) {
      bytes2 = Hash128.ZERO_128.bytes;
    }
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : Hash128.ZERO_128.bytes);
  }
  /**
   * Get the hex representation of a hash-128 bytes, allowing unset
   *
   * @returns hex String of this.bytes
   */
  toHex() {
    const hex = this.toBytes().toString("hex").toUpperCase();
    if (/^0+$/.exec(hex)) {
      return "";
    }
    return hex;
  }
}
hash128.Hash128 = Hash128;
Hash128.width = 16;
Hash128.ZERO_128 = new Hash128(buffer_1$c.Buffer.alloc(Hash128.width));
var hash256 = {};
Object.defineProperty(hash256, "__esModule", { value: true });
hash256.Hash256 = void 0;
const hash_1 = hash2;
const buffer_1$b = dist$h;
class Hash256 extends hash_1.Hash {
  constructor(bytes2) {
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : Hash256.ZERO_256.bytes);
  }
}
hash256.Hash256 = Hash256;
Hash256.width = 32;
Hash256.ZERO_256 = new Hash256(buffer_1$b.Buffer.alloc(Hash256.width));
var issue = {};
Object.defineProperty(issue, "__esModule", { value: true });
issue.Issue = void 0;
const binary_parser_1$3 = binaryParser;
const account_id_1$2 = accountId;
const currency_1$1 = currency;
const serialized_type_1$4 = serializedType;
const buffer_1$a = dist$h;
function isIssueObject(arg) {
  const keys2 = Object.keys(arg).sort();
  if (keys2.length === 1) {
    return keys2[0] === "currency";
  }
  return keys2.length === 2 && keys2[0] === "currency" && keys2[1] === "issuer";
}
class Issue extends serialized_type_1$4.SerializedType {
  constructor(bytes2) {
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : Issue.ZERO_ISSUED_CURRENCY.bytes);
  }
  /**
   * Construct an amount from an IOU or string amount
   *
   * @param value An Amount, object representing an IOU, or a string
   *     representing an integer amount
   * @returns An Amount object
   */
  static from(value) {
    if (value instanceof Issue) {
      return value;
    }
    if (isIssueObject(value)) {
      const currency2 = currency_1$1.Currency.from(value.currency).toBytes();
      if (value.issuer == null) {
        return new Issue(currency2);
      }
      const issuer = account_id_1$2.AccountID.from(value.issuer).toBytes();
      return new Issue(buffer_1$a.Buffer.concat([currency2, issuer]));
    }
    throw new Error("Invalid type to construct an Amount");
  }
  /**
   * Read an amount from a BinaryParser
   *
   * @param parser BinaryParser to read the Amount from
   * @returns An Amount object
   */
  static fromParser(parser) {
    const currency2 = parser.read(20);
    if (new currency_1$1.Currency(currency2).toJSON() === "XRP") {
      return new Issue(currency2);
    }
    const currencyAndIssuer = [currency2, parser.read(20)];
    return new Issue(buffer_1$a.Buffer.concat(currencyAndIssuer));
  }
  /**
   * Get the JSON representation of this Amount
   *
   * @returns the JSON interpretation of this.bytes
   */
  toJSON() {
    const parser = new binary_parser_1$3.BinaryParser(this.toString());
    const currency2 = currency_1$1.Currency.fromParser(parser);
    if (currency2.toJSON() === "XRP") {
      return { currency: currency2.toJSON() };
    }
    const issuer = account_id_1$2.AccountID.fromParser(parser);
    return {
      currency: currency2.toJSON(),
      issuer: issuer.toJSON()
    };
  }
}
issue.Issue = Issue;
Issue.ZERO_ISSUED_CURRENCY = new Issue(buffer_1$a.Buffer.alloc(20));
var pathSet = {};
Object.defineProperty(pathSet, "__esModule", { value: true });
pathSet.PathSet = void 0;
const account_id_1$1 = accountId;
const currency_1 = currency;
const binary_parser_1$2 = binaryParser;
const serialized_type_1$3 = serializedType;
const buffer_1$9 = dist$h;
const PATHSET_END_BYTE = 0;
const PATH_SEPARATOR_BYTE = 255;
const TYPE_ACCOUNT = 1;
const TYPE_CURRENCY = 16;
const TYPE_ISSUER = 32;
function isHopObject(arg) {
  return arg.issuer !== void 0 || arg.account !== void 0 || arg.currency !== void 0;
}
function isPathSet(arg) {
  return Array.isArray(arg) && arg.length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0]);
}
class Hop extends serialized_type_1$3.SerializedType {
  /**
   * Create a Hop from a HopObject
   *
   * @param value Either a hop or HopObject to create a hop with
   * @returns a Hop
   */
  static from(value) {
    if (value instanceof Hop) {
      return value;
    }
    const bytes2 = [buffer_1$9.Buffer.from([0])];
    if (value.account) {
      bytes2.push(account_id_1$1.AccountID.from(value.account).toBytes());
      bytes2[0][0] |= TYPE_ACCOUNT;
    }
    if (value.currency) {
      bytes2.push(currency_1.Currency.from(value.currency).toBytes());
      bytes2[0][0] |= TYPE_CURRENCY;
    }
    if (value.issuer) {
      bytes2.push(account_id_1$1.AccountID.from(value.issuer).toBytes());
      bytes2[0][0] |= TYPE_ISSUER;
    }
    return new Hop(buffer_1$9.Buffer.concat(bytes2));
  }
  /**
   * Construct a Hop from a BinaryParser
   *
   * @param parser BinaryParser to read the Hop from
   * @returns a Hop
   */
  static fromParser(parser) {
    const type = parser.readUInt8();
    const bytes2 = [buffer_1$9.Buffer.from([type])];
    if (type & TYPE_ACCOUNT) {
      bytes2.push(parser.read(account_id_1$1.AccountID.width));
    }
    if (type & TYPE_CURRENCY) {
      bytes2.push(parser.read(currency_1.Currency.width));
    }
    if (type & TYPE_ISSUER) {
      bytes2.push(parser.read(account_id_1$1.AccountID.width));
    }
    return new Hop(buffer_1$9.Buffer.concat(bytes2));
  }
  /**
   * Get the JSON interpretation of this hop
   *
   * @returns a HopObject, an JS object with optional account, issuer, and currency
   */
  toJSON() {
    const hopParser = new binary_parser_1$2.BinaryParser(this.bytes.toString("hex"));
    const type = hopParser.readUInt8();
    let account2, currency2, issuer;
    if (type & TYPE_ACCOUNT) {
      account2 = account_id_1$1.AccountID.fromParser(hopParser).toJSON();
    }
    if (type & TYPE_CURRENCY) {
      currency2 = currency_1.Currency.fromParser(hopParser).toJSON();
    }
    if (type & TYPE_ISSUER) {
      issuer = account_id_1$1.AccountID.fromParser(hopParser).toJSON();
    }
    const result = {};
    if (account2) {
      result.account = account2;
    }
    if (issuer) {
      result.issuer = issuer;
    }
    if (currency2) {
      result.currency = currency2;
    }
    return result;
  }
  /**
   * get a number representing the type of this hop
   *
   * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop
   */
  type() {
    return this.bytes[0];
  }
}
class Path extends serialized_type_1$3.SerializedType {
  /**
   * construct a Path from an array of Hops
   *
   * @param value Path or array of HopObjects to construct a Path
   * @returns the Path
   */
  static from(value) {
    if (value instanceof Path) {
      return value;
    }
    const bytes2 = [];
    value.forEach((hop) => {
      bytes2.push(Hop.from(hop).toBytes());
    });
    return new Path(buffer_1$9.Buffer.concat(bytes2));
  }
  /**
   * Read a Path from a BinaryParser
   *
   * @param parser BinaryParser to read Path from
   * @returns the Path represented by the bytes read from the BinaryParser
   */
  static fromParser(parser) {
    const bytes2 = [];
    while (!parser.end()) {
      bytes2.push(Hop.fromParser(parser).toBytes());
      if (parser.peek() === PATHSET_END_BYTE || parser.peek() === PATH_SEPARATOR_BYTE) {
        break;
      }
    }
    return new Path(buffer_1$9.Buffer.concat(bytes2));
  }
  /**
   * Get the JSON representation of this Path
   *
   * @returns an Array of HopObject constructed from this.bytes
   */
  toJSON() {
    const json = [];
    const pathParser = new binary_parser_1$2.BinaryParser(this.toString());
    while (!pathParser.end()) {
      json.push(Hop.fromParser(pathParser).toJSON());
    }
    return json;
  }
}
class PathSet extends serialized_type_1$3.SerializedType {
  /**
   * Construct a PathSet from an Array of Arrays representing paths
   *
   * @param value A PathSet or Array of Array of HopObjects
   * @returns the PathSet constructed from value
   */
  static from(value) {
    if (value instanceof PathSet) {
      return value;
    }
    if (isPathSet(value)) {
      const bytes2 = [];
      value.forEach((path) => {
        bytes2.push(Path.from(path).toBytes());
        bytes2.push(buffer_1$9.Buffer.from([PATH_SEPARATOR_BYTE]));
      });
      bytes2[bytes2.length - 1] = buffer_1$9.Buffer.from([PATHSET_END_BYTE]);
      return new PathSet(buffer_1$9.Buffer.concat(bytes2));
    }
    throw new Error("Cannot construct PathSet from given value");
  }
  /**
   * Construct a PathSet from a BinaryParser
   *
   * @param parser A BinaryParser to read PathSet from
   * @returns the PathSet read from parser
   */
  static fromParser(parser) {
    const bytes2 = [];
    while (!parser.end()) {
      bytes2.push(Path.fromParser(parser).toBytes());
      bytes2.push(parser.read(1));
      if (bytes2[bytes2.length - 1][0] == PATHSET_END_BYTE) {
        break;
      }
    }
    return new PathSet(buffer_1$9.Buffer.concat(bytes2));
  }
  /**
   * Get the JSON representation of this PathSet
   *
   * @returns an Array of Array of HopObjects, representing this PathSet
   */
  toJSON() {
    const json = [];
    const pathParser = new binary_parser_1$2.BinaryParser(this.toString());
    while (!pathParser.end()) {
      json.push(Path.fromParser(pathParser).toJSON());
      pathParser.skip(1);
    }
    return json;
  }
}
pathSet.PathSet = PathSet;
var stArray = {};
var stObject = {};
var hasRequiredStObject;
function requireStObject() {
  if (hasRequiredStObject) return stObject;
  hasRequiredStObject = 1;
  Object.defineProperty(stObject, "__esModule", { value: true });
  stObject.STObject = void 0;
  const enums_12 = enums;
  const serialized_type_12 = serializedType;
  const ripple_address_codec_12 = dist;
  const binary_parser_12 = binaryParser;
  const binary_serializer_12 = binarySerializer;
  const buffer_12 = dist$h;
  const st_array_1 = requireStArray();
  const OBJECT_END_MARKER_BYTE = buffer_12.Buffer.from([225]);
  const OBJECT_END_MARKER = "ObjectEndMarker";
  const ST_OBJECT = "STObject";
  const DESTINATION = "Destination";
  const ACCOUNT = "Account";
  const SOURCE_TAG = "SourceTag";
  const DEST_TAG = "DestinationTag";
  function handleXAddress(field2, xAddress) {
    const decoded = (0, ripple_address_codec_12.xAddressToClassicAddress)(xAddress);
    let tagName;
    if (field2 === DESTINATION)
      tagName = DEST_TAG;
    else if (field2 === ACCOUNT)
      tagName = SOURCE_TAG;
    else if (decoded.tag !== false)
      throw new Error(`${field2} cannot have an associated tag`);
    return decoded.tag !== false ? { [field2]: decoded.classicAddress, [tagName]: decoded.tag } : { [field2]: decoded.classicAddress };
  }
  function checkForDuplicateTags(obj1, obj2) {
    if (!(obj1[SOURCE_TAG] === void 0 || obj2[SOURCE_TAG] === void 0))
      throw new Error("Cannot have Account X-Address and SourceTag");
    if (!(obj1[DEST_TAG] === void 0 || obj2[DEST_TAG] === void 0))
      throw new Error("Cannot have Destination X-Address and DestinationTag");
  }
  class STObject extends serialized_type_12.SerializedType {
    /**
     * Construct a STObject from a BinaryParser
     *
     * @param parser BinaryParser to read STObject from
     * @returns A STObject object
     */
    static fromParser(parser) {
      const list = new binary_serializer_12.BytesList();
      const bytes2 = new binary_serializer_12.BinarySerializer(list);
      while (!parser.end()) {
        const field2 = parser.readField();
        if (field2.name === OBJECT_END_MARKER) {
          break;
        }
        const associatedValue = parser.readFieldValue(field2);
        bytes2.writeFieldAndValue(field2, associatedValue);
        if (field2.type.name === ST_OBJECT) {
          bytes2.put(OBJECT_END_MARKER_BYTE);
        }
      }
      return new STObject(list.toBytes());
    }
    /**
     * Construct a STObject from a JSON object
     *
     * @param value An object to include
     * @param filter optional, denote which field to include in serialized object
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns a STObject object
     */
    static from(value, filter, definitions = enums_12.DEFAULT_DEFINITIONS) {
      if (value instanceof STObject) {
        return value;
      }
      const list = new binary_serializer_12.BytesList();
      const bytes2 = new binary_serializer_12.BinarySerializer(list);
      let isUnlModify = false;
      const xAddressDecoded = Object.entries(value).reduce((acc, [key2, val]) => {
        let handled = void 0;
        if (val && (0, ripple_address_codec_12.isValidXAddress)(val.toString())) {
          handled = handleXAddress(key2, val.toString());
          checkForDuplicateTags(handled, value);
        }
        return Object.assign(acc, handled !== null && handled !== void 0 ? handled : { [key2]: val });
      }, {});
      let sorted = Object.keys(xAddressDecoded).map((f2) => definitions.field[f2]).filter((f2) => f2 !== void 0 && xAddressDecoded[f2.name] !== void 0 && f2.isSerialized).sort((a, b) => {
        return a.ordinal - b.ordinal;
      });
      if (filter !== void 0) {
        sorted = sorted.filter(filter);
      }
      sorted.forEach((field2) => {
        const associatedValue = field2.type.name === ST_OBJECT ? this.from(xAddressDecoded[field2.name], void 0, definitions) : field2.type.name === "STArray" ? st_array_1.STArray.from(xAddressDecoded[field2.name], definitions) : field2.associatedType.from(xAddressDecoded[field2.name]);
        if (associatedValue == void 0) {
          throw new TypeError(`Unable to interpret "${field2.name}: ${xAddressDecoded[field2.name]}".`);
        }
        if (associatedValue.name === "UNLModify") {
          isUnlModify = true;
        }
        const isUnlModifyWorkaround = field2.name == "Account" && isUnlModify;
        bytes2.writeFieldAndValue(field2, associatedValue, isUnlModifyWorkaround);
        if (field2.type.name === ST_OBJECT) {
          bytes2.put(OBJECT_END_MARKER_BYTE);
        }
      });
      return new STObject(list.toBytes());
    }
    /**
     * Get the JSON interpretation of this.bytes
     * @param definitions rippled definitions used to parse the values of transaction types and such.
     *                          Can be customized for sidechains and amendments.
     * @returns a JSON object
     */
    toJSON(definitions) {
      const objectParser = new binary_parser_12.BinaryParser(this.toString(), definitions);
      const accumulator = {};
      while (!objectParser.end()) {
        const field2 = objectParser.readField();
        if (field2.name === OBJECT_END_MARKER) {
          break;
        }
        accumulator[field2.name] = objectParser.readFieldValue(field2).toJSON(definitions);
      }
      return accumulator;
    }
  }
  stObject.STObject = STObject;
  return stObject;
}
var hasRequiredStArray;
function requireStArray() {
  if (hasRequiredStArray) return stArray;
  hasRequiredStArray = 1;
  Object.defineProperty(stArray, "__esModule", { value: true });
  stArray.STArray = void 0;
  const enums_12 = enums;
  const serialized_type_12 = serializedType;
  const st_object_12 = requireStObject();
  const binary_parser_12 = binaryParser;
  const buffer_12 = dist$h;
  const ARRAY_END_MARKER = buffer_12.Buffer.from([241]);
  const ARRAY_END_MARKER_NAME = "ArrayEndMarker";
  const OBJECT_END_MARKER = buffer_12.Buffer.from([225]);
  function isObjects(args) {
    return Array.isArray(args) && (args.length === 0 || typeof args[0] === "object");
  }
  class STArray extends serialized_type_12.SerializedType {
    /**
     * Construct an STArray from a BinaryParser
     *
     * @param parser BinaryParser to parse an STArray from
     * @returns An STArray Object
     */
    static fromParser(parser) {
      const bytes2 = [];
      while (!parser.end()) {
        const field2 = parser.readField();
        if (field2.name === ARRAY_END_MARKER_NAME) {
          break;
        }
        bytes2.push(field2.header, parser.readFieldValue(field2).toBytes(), OBJECT_END_MARKER);
      }
      bytes2.push(ARRAY_END_MARKER);
      return new STArray(buffer_12.Buffer.concat(bytes2));
    }
    /**
     * Construct an STArray from an Array of JSON Objects
     *
     * @param value STArray or Array of Objects to parse into an STArray
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns An STArray object
     */
    static from(value, definitions = enums_12.DEFAULT_DEFINITIONS) {
      if (value instanceof STArray) {
        return value;
      }
      if (isObjects(value)) {
        const bytes2 = [];
        value.forEach((obj) => {
          bytes2.push(st_object_12.STObject.from(obj, void 0, definitions).toBytes());
        });
        bytes2.push(ARRAY_END_MARKER);
        return new STArray(buffer_12.Buffer.concat(bytes2));
      }
      throw new Error("Cannot construct STArray from value given");
    }
    /**
     * Return the JSON representation of this.bytes
     *
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns An Array of JSON objects
     */
    toJSON(definitions = enums_12.DEFAULT_DEFINITIONS) {
      const result = [];
      const arrayParser = new binary_parser_12.BinaryParser(this.toString(), definitions);
      while (!arrayParser.end()) {
        const field2 = arrayParser.readField();
        if (field2.name === ARRAY_END_MARKER_NAME) {
          break;
        }
        const outer = {};
        outer[field2.name] = st_object_12.STObject.fromParser(arrayParser).toJSON(definitions);
        result.push(outer);
      }
      return result;
    }
  }
  stArray.STArray = STArray;
  return stArray;
}
var uint16 = {};
var uint = {};
Object.defineProperty(uint, "__esModule", { value: true });
uint.UInt = void 0;
const serialized_type_1$2 = serializedType;
function compare(n1, n2) {
  return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;
}
class UInt extends serialized_type_1$2.Comparable {
  constructor(bytes2) {
    super(bytes2);
  }
  /**
   * Overload of compareTo for Comparable
   *
   * @param other other UInt to compare this to
   * @returns -1, 0, or 1 depending on how the objects relate to each other
   */
  compareTo(other) {
    return compare(this.valueOf(), other.valueOf());
  }
  /**
   * Convert a UInt object to JSON
   *
   * @returns number or string represented by this.bytes
   */
  toJSON() {
    const val = this.valueOf();
    return typeof val === "number" ? val : val.toString();
  }
}
uint.UInt = UInt;
Object.defineProperty(uint16, "__esModule", { value: true });
uint16.UInt16 = void 0;
const uint_1$3 = uint;
const buffer_1$8 = dist$h;
class UInt16 extends uint_1$3.UInt {
  constructor(bytes2) {
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : UInt16.defaultUInt16.bytes);
  }
  static fromParser(parser) {
    return new UInt16(parser.read(UInt16.width));
  }
  /**
   * Construct a UInt16 object from a number
   *
   * @param val UInt16 object or number
   */
  static from(val) {
    if (val instanceof UInt16) {
      return val;
    }
    if (typeof val === "number") {
      const buf = buffer_1$8.Buffer.alloc(UInt16.width);
      buf.writeUInt16BE(val, 0);
      return new UInt16(buf);
    }
    throw new Error("Can not construct UInt16 with given value");
  }
  /**
   * get the value of a UInt16 object
   *
   * @returns the number represented by this.bytes
   */
  valueOf() {
    return this.bytes.readUInt16BE(0);
  }
}
uint16.UInt16 = UInt16;
UInt16.width = 16 / 8;
UInt16.defaultUInt16 = new UInt16(buffer_1$8.Buffer.alloc(UInt16.width));
var uint32 = {};
Object.defineProperty(uint32, "__esModule", { value: true });
uint32.UInt32 = void 0;
const uint_1$2 = uint;
const buffer_1$7 = dist$h;
class UInt32 extends uint_1$2.UInt {
  constructor(bytes2) {
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : UInt32.defaultUInt32.bytes);
  }
  static fromParser(parser) {
    return new UInt32(parser.read(UInt32.width));
  }
  /**
   * Construct a UInt32 object from a number
   *
   * @param val UInt32 object or number
   */
  static from(val) {
    if (val instanceof UInt32) {
      return val;
    }
    const buf = buffer_1$7.Buffer.alloc(UInt32.width);
    if (typeof val === "string") {
      const num = Number.parseInt(val);
      buf.writeUInt32BE(num, 0);
      return new UInt32(buf);
    }
    if (typeof val === "number") {
      buf.writeUInt32BE(val, 0);
      return new UInt32(buf);
    }
    throw new Error("Cannot construct UInt32 from given value");
  }
  /**
   * get the value of a UInt32 object
   *
   * @returns the number represented by this.bytes
   */
  valueOf() {
    return this.bytes.readUInt32BE(0);
  }
}
uint32.UInt32 = UInt32;
UInt32.width = 32 / 8;
UInt32.defaultUInt32 = new UInt32(buffer_1$7.Buffer.alloc(UInt32.width));
var uint64 = {};
Object.defineProperty(uint64, "__esModule", { value: true });
uint64.UInt64 = void 0;
const uint_1$1 = uint;
const bigInt$2 = BigIntegerExports;
const big_integer_1 = BigIntegerExports;
const buffer_1$6 = dist$h;
const HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;
const mask = bigInt$2(4294967295);
class UInt64 extends uint_1$1.UInt {
  constructor(bytes2) {
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : UInt64.defaultUInt64.bytes);
  }
  static fromParser(parser) {
    return new UInt64(parser.read(UInt64.width));
  }
  /**
   * Construct a UInt64 object
   *
   * @param val A UInt64, hex-string, bigInt, or number
   * @returns A UInt64 object
   */
  static from(val) {
    if (val instanceof UInt64) {
      return val;
    }
    let buf = buffer_1$6.Buffer.alloc(UInt64.width);
    if (typeof val === "number") {
      if (val < 0) {
        throw new Error("value must be an unsigned integer");
      }
      const number2 = bigInt$2(val);
      const intBuf = [buffer_1$6.Buffer.alloc(4), buffer_1$6.Buffer.alloc(4)];
      intBuf[0].writeUInt32BE(Number(number2.shiftRight(32)), 0);
      intBuf[1].writeUInt32BE(Number(number2.and(mask)), 0);
      return new UInt64(buffer_1$6.Buffer.concat(intBuf));
    }
    if (typeof val === "string") {
      if (!HEX_REGEX.test(val)) {
        throw new Error(`${val} is not a valid hex-string`);
      }
      const strBuf = val.padStart(16, "0");
      buf = buffer_1$6.Buffer.from(strBuf, "hex");
      return new UInt64(buf);
    }
    if ((0, big_integer_1.isInstance)(val)) {
      const intBuf = [buffer_1$6.Buffer.alloc(4), buffer_1$6.Buffer.alloc(4)];
      intBuf[0].writeUInt32BE(Number(val.shiftRight(bigInt$2(32))), 0);
      intBuf[1].writeUInt32BE(Number(val.and(mask)), 0);
      return new UInt64(buffer_1$6.Buffer.concat(intBuf));
    }
    throw new Error("Cannot construct UInt64 from given value");
  }
  /**
   * The JSON representation of a UInt64 object
   *
   * @returns a hex-string
   */
  toJSON() {
    return this.bytes.toString("hex").toUpperCase();
  }
  /**
   * Get the value of the UInt64
   *
   * @returns the number represented buy this.bytes
   */
  valueOf() {
    const msb = bigInt$2(this.bytes.slice(0, 4).readUInt32BE(0));
    const lsb = bigInt$2(this.bytes.slice(4).readUInt32BE(0));
    return msb.shiftLeft(bigInt$2(32)).or(lsb);
  }
  /**
   * Get the bytes representation of the UInt64 object
   *
   * @returns 8 bytes representing the UInt64
   */
  toBytes() {
    return this.bytes;
  }
}
uint64.UInt64 = UInt64;
UInt64.width = 64 / 8;
UInt64.defaultUInt64 = new UInt64(buffer_1$6.Buffer.alloc(UInt64.width));
var uint8 = {};
Object.defineProperty(uint8, "__esModule", { value: true });
uint8.UInt8 = void 0;
const uint_1 = uint;
const buffer_1$5 = dist$h;
class UInt8 extends uint_1.UInt {
  constructor(bytes2) {
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : UInt8.defaultUInt8.bytes);
  }
  static fromParser(parser) {
    return new UInt8(parser.read(UInt8.width));
  }
  /**
   * Construct a UInt8 object from a number
   *
   * @param val UInt8 object or number
   */
  static from(val) {
    if (val instanceof UInt8) {
      return val;
    }
    if (typeof val === "number") {
      const buf = buffer_1$5.Buffer.alloc(UInt8.width);
      buf.writeUInt8(val, 0);
      return new UInt8(buf);
    }
    throw new Error("Cannot construct UInt8 from given value");
  }
  /**
   * get the value of a UInt8 object
   *
   * @returns the number represented by this.bytes
   */
  valueOf() {
    return this.bytes.readUInt8(0);
  }
}
uint8.UInt8 = UInt8;
UInt8.width = 8 / 8;
UInt8.defaultUInt8 = new UInt8(buffer_1$5.Buffer.alloc(UInt8.width));
var vector256 = {};
Object.defineProperty(vector256, "__esModule", { value: true });
vector256.Vector256 = void 0;
const serialized_type_1$1 = serializedType;
const hash_256_1$2 = hash256;
const binary_serializer_1$1 = binarySerializer;
function isStrings(arg) {
  return Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === "string");
}
class Vector256 extends serialized_type_1$1.SerializedType {
  constructor(bytes2) {
    super(bytes2);
  }
  /**
   * Construct a Vector256 from a BinaryParser
   *
   * @param parser BinaryParser to
   * @param hint length of the vector, in bytes, optional
   * @returns a Vector256 object
   */
  static fromParser(parser, hint) {
    const bytesList = new binary_serializer_1$1.BytesList();
    const bytes2 = hint !== null && hint !== void 0 ? hint : parser.size();
    const hashes2 = bytes2 / 32;
    for (let i = 0; i < hashes2; i++) {
      hash_256_1$2.Hash256.fromParser(parser).toBytesSink(bytesList);
    }
    return new Vector256(bytesList.toBytes());
  }
  /**
   * Construct a Vector256 object from an array of hashes
   *
   * @param value A Vector256 object or array of hex-strings representing Hash256's
   * @returns a Vector256 object
   */
  static from(value) {
    if (value instanceof Vector256) {
      return value;
    }
    if (isStrings(value)) {
      const bytesList = new binary_serializer_1$1.BytesList();
      value.forEach((hash3) => {
        hash_256_1$2.Hash256.from(hash3).toBytesSink(bytesList);
      });
      return new Vector256(bytesList.toBytes());
    }
    throw new Error("Cannot construct Vector256 from given value");
  }
  /**
   * Return an Array of hex-strings represented by this.bytes
   *
   * @returns An Array of strings representing the Hash256 objects
   */
  toJSON() {
    if (this.bytes.byteLength % 32 !== 0) {
      throw new Error("Invalid bytes for Vector256");
    }
    const result = [];
    for (let i = 0; i < this.bytes.byteLength; i += 32) {
      result.push(this.bytes.slice(i, i + 32).toString("hex").toUpperCase());
    }
    return result;
  }
}
vector256.Vector256 = Vector256;
var xchainBridge = {};
Object.defineProperty(xchainBridge, "__esModule", { value: true });
xchainBridge.XChainBridge = void 0;
const binary_parser_1$1 = binaryParser;
const account_id_1 = accountId;
const serialized_type_1 = serializedType;
const buffer_1$4 = dist$h;
const issue_1 = issue;
function isXChainBridgeObject(arg) {
  const keys2 = Object.keys(arg).sort();
  return keys2.length === 4 && keys2[0] === "IssuingChainDoor" && keys2[1] === "IssuingChainIssue" && keys2[2] === "LockingChainDoor" && keys2[3] === "LockingChainIssue";
}
class XChainBridge extends serialized_type_1.SerializedType {
  constructor(bytes2) {
    super(bytes2 !== null && bytes2 !== void 0 ? bytes2 : XChainBridge.ZERO_XCHAIN_BRIDGE.bytes);
  }
  /**
   * Construct a cross-chain bridge from a JSON
   *
   * @param value XChainBridge or JSON to parse into an XChainBridge
   * @returns An XChainBridge object
   */
  static from(value) {
    if (value instanceof XChainBridge) {
      return value;
    }
    if (!isXChainBridgeObject(value)) {
      throw new Error("Invalid type to construct an XChainBridge");
    }
    const bytes2 = [];
    this.TYPE_ORDER.forEach((item) => {
      const { name: name2, type } = item;
      if (type === account_id_1.AccountID) {
        bytes2.push(buffer_1$4.Buffer.from([20]));
      }
      const object = type.from(value[name2]);
      bytes2.push(object.toBytes());
    });
    return new XChainBridge(buffer_1$4.Buffer.concat(bytes2));
  }
  /**
   * Read an XChainBridge from a BinaryParser
   *
   * @param parser BinaryParser to read the XChainBridge from
   * @returns An XChainBridge object
   */
  static fromParser(parser) {
    const bytes2 = [];
    this.TYPE_ORDER.forEach((item) => {
      const { type } = item;
      if (type === account_id_1.AccountID) {
        parser.skip(1);
        bytes2.push(buffer_1$4.Buffer.from([20]));
      }
      const object = type.fromParser(parser);
      bytes2.push(object.toBytes());
    });
    return new XChainBridge(buffer_1$4.Buffer.concat(bytes2));
  }
  /**
   * Get the JSON representation of this XChainBridge
   *
   * @returns the JSON interpretation of this.bytes
   */
  toJSON() {
    const parser = new binary_parser_1$1.BinaryParser(this.toString());
    const json = {};
    XChainBridge.TYPE_ORDER.forEach((item) => {
      const { name: name2, type } = item;
      if (type === account_id_1.AccountID) {
        parser.skip(1);
      }
      const object = type.fromParser(parser).toJSON();
      json[name2] = object;
    });
    return json;
  }
}
xchainBridge.XChainBridge = XChainBridge;
XChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge(buffer_1$4.Buffer.concat([
  buffer_1$4.Buffer.from([20]),
  buffer_1$4.Buffer.alloc(40),
  buffer_1$4.Buffer.from([20]),
  buffer_1$4.Buffer.alloc(40)
]));
XChainBridge.TYPE_ORDER = [
  { name: "LockingChainDoor", type: account_id_1.AccountID },
  { name: "LockingChainIssue", type: issue_1.Issue },
  { name: "IssuingChainDoor", type: account_id_1.AccountID },
  { name: "IssuingChainIssue", type: issue_1.Issue }
];
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Vector256 = exports.UInt64 = exports.UInt32 = exports.UInt16 = exports.UInt8 = exports.STObject = exports.STArray = exports.PathSet = exports.Hash256 = exports.Hash160 = exports.Hash128 = exports.Currency = exports.Blob = exports.Amount = exports.AccountID = exports.coreTypes = void 0;
  const account_id_12 = accountId;
  Object.defineProperty(exports, "AccountID", { enumerable: true, get: function() {
    return account_id_12.AccountID;
  } });
  const amount_1 = amount;
  Object.defineProperty(exports, "Amount", { enumerable: true, get: function() {
    return amount_1.Amount;
  } });
  const blob_1 = blob;
  Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
    return blob_1.Blob;
  } });
  const currency_12 = currency;
  Object.defineProperty(exports, "Currency", { enumerable: true, get: function() {
    return currency_12.Currency;
  } });
  const hash_128_1 = hash128;
  Object.defineProperty(exports, "Hash128", { enumerable: true, get: function() {
    return hash_128_1.Hash128;
  } });
  const hash_160_12 = hash160;
  Object.defineProperty(exports, "Hash160", { enumerable: true, get: function() {
    return hash_160_12.Hash160;
  } });
  const hash_256_12 = hash256;
  Object.defineProperty(exports, "Hash256", { enumerable: true, get: function() {
    return hash_256_12.Hash256;
  } });
  const issue_12 = issue;
  const path_set_1 = pathSet;
  Object.defineProperty(exports, "PathSet", { enumerable: true, get: function() {
    return path_set_1.PathSet;
  } });
  const st_array_1 = requireStArray();
  Object.defineProperty(exports, "STArray", { enumerable: true, get: function() {
    return st_array_1.STArray;
  } });
  const st_object_12 = requireStObject();
  Object.defineProperty(exports, "STObject", { enumerable: true, get: function() {
    return st_object_12.STObject;
  } });
  const uint_16_1 = uint16;
  Object.defineProperty(exports, "UInt16", { enumerable: true, get: function() {
    return uint_16_1.UInt16;
  } });
  const uint_32_12 = uint32;
  Object.defineProperty(exports, "UInt32", { enumerable: true, get: function() {
    return uint_32_12.UInt32;
  } });
  const uint_64_12 = uint64;
  Object.defineProperty(exports, "UInt64", { enumerable: true, get: function() {
    return uint_64_12.UInt64;
  } });
  const uint_8_12 = uint8;
  Object.defineProperty(exports, "UInt8", { enumerable: true, get: function() {
    return uint_8_12.UInt8;
  } });
  const vector_256_1 = vector256;
  Object.defineProperty(exports, "Vector256", { enumerable: true, get: function() {
    return vector_256_1.Vector256;
  } });
  const xchain_bridge_1 = xchainBridge;
  const enums_12 = enums;
  const coreTypes = {
    AccountID: account_id_12.AccountID,
    Amount: amount_1.Amount,
    Blob: blob_1.Blob,
    Currency: currency_12.Currency,
    Hash128: hash_128_1.Hash128,
    Hash160: hash_160_12.Hash160,
    Hash256: hash_256_12.Hash256,
    Issue: issue_12.Issue,
    PathSet: path_set_1.PathSet,
    STArray: st_array_1.STArray,
    STObject: st_object_12.STObject,
    UInt8: uint_8_12.UInt8,
    UInt16: uint_16_1.UInt16,
    UInt32: uint_32_12.UInt32,
    UInt64: uint_64_12.UInt64,
    Vector256: vector_256_1.Vector256,
    XChainBridge: xchain_bridge_1.XChainBridge
  };
  exports.coreTypes = coreTypes;
  enums_12.DEFAULT_DEFINITIONS.associateTypes(coreTypes);
})(types);
var binary = {};
var hashPrefixes = {};
Object.defineProperty(hashPrefixes, "__esModule", { value: true });
hashPrefixes.HashPrefix = void 0;
const buffer_1$3 = dist$h;
function bytes(uint322) {
  const result = buffer_1$3.Buffer.alloc(4);
  result.writeUInt32BE(uint322, 0);
  return result;
}
const HashPrefix = {
  transactionID: bytes(1415073280),
  // transaction plus metadata
  transaction: bytes(1397638144),
  // account state
  accountStateEntry: bytes(1296846336),
  // inner node in tree
  innerNode: bytes(1296649728),
  // ledger master data for signing
  ledgerHeader: bytes(1280791040),
  // inner transaction to sign
  transactionSig: bytes(1398036480),
  // inner transaction to sign
  transactionMultiSig: bytes(1397576704),
  // validation for signing
  validation: bytes(1447119872),
  // proposal for signing
  proposal: bytes(1347571712),
  // payment channel claim
  paymentChannelClaim: bytes(1129073920)
};
hashPrefixes.HashPrefix = HashPrefix;
var hashes = {};
Object.defineProperty(hashes, "__esModule", { value: true });
hashes.transactionID = hashes.sha512Half = hashes.Sha512Half = void 0;
const hash_prefixes_1$2 = hashPrefixes;
const createHash = browser;
const hash_256_1$1 = hash256;
const binary_serializer_1 = binarySerializer;
const buffer_1$2 = dist$h;
class Sha512Half extends binary_serializer_1.BytesList {
  constructor() {
    super(...arguments);
    this.hash = createHash("sha512");
  }
  /**
   * Construct a new Sha512Hash and write bytes this.hash
   *
   * @param bytes bytes to write to this.hash
   * @returns the new Sha512Hash object
   */
  static put(bytes2) {
    return new Sha512Half().put(bytes2);
  }
  /**
   * Write bytes to an existing Sha512Hash
   *
   * @param bytes bytes to write to object
   * @returns the Sha512 object
   */
  put(bytes2) {
    this.hash.update(bytes2);
    return this;
  }
  /**
   * Compute SHA512 hash and slice in half
   *
   * @returns half of a SHA512 hash
   */
  finish256() {
    return buffer_1$2.Buffer.from(this.hash.digest().slice(0, 32));
  }
  /**
   * Constructs a Hash256 from the Sha512Half object
   *
   * @returns a Hash256 object
   */
  finish() {
    return new hash_256_1$1.Hash256(this.finish256());
  }
}
hashes.Sha512Half = Sha512Half;
function sha512Half(...args) {
  const hash3 = new Sha512Half();
  args.forEach((a) => hash3.put(a));
  return hash3.finish256();
}
hashes.sha512Half = sha512Half;
function transactionID(serialized) {
  return new hash_256_1$1.Hash256(sha512Half(hash_prefixes_1$2.HashPrefix.transactionID, serialized));
}
hashes.transactionID = transactionID;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;
  const types_12 = types;
  const binary_parser_12 = binaryParser;
  Object.defineProperty(exports, "BinaryParser", { enumerable: true, get: function() {
    return binary_parser_12.BinaryParser;
  } });
  const hash_prefixes_12 = hashPrefixes;
  const binary_serializer_12 = binarySerializer;
  Object.defineProperty(exports, "BinarySerializer", { enumerable: true, get: function() {
    return binary_serializer_12.BinarySerializer;
  } });
  Object.defineProperty(exports, "BytesList", { enumerable: true, get: function() {
    return binary_serializer_12.BytesList;
  } });
  const hashes_12 = hashes;
  Object.defineProperty(exports, "sha512Half", { enumerable: true, get: function() {
    return hashes_12.sha512Half;
  } });
  Object.defineProperty(exports, "transactionID", { enumerable: true, get: function() {
    return hashes_12.transactionID;
  } });
  const enums_12 = enums;
  const bigInt2 = BigIntegerExports;
  const makeParser = (bytes2, definitions) => new binary_parser_12.BinaryParser(bytes2, definitions);
  exports.makeParser = makeParser;
  const readJSON = (parser, definitions = enums_12.DEFAULT_DEFINITIONS) => parser.readType(types_12.coreTypes.STObject).toJSON(definitions);
  exports.readJSON = readJSON;
  const binaryToJSON = (bytes2, definitions) => readJSON(makeParser(bytes2, definitions), definitions);
  exports.binaryToJSON = binaryToJSON;
  function serializeObject(object, opts = {}) {
    const { prefix, suffix, signingFieldsOnly = false, definitions } = opts;
    const bytesList = new binary_serializer_12.BytesList();
    if (prefix) {
      bytesList.put(prefix);
    }
    const filter = signingFieldsOnly ? (f2) => f2.isSigningField : void 0;
    types_12.coreTypes.STObject.from(object, filter, definitions).toBytesSink(bytesList);
    if (suffix) {
      bytesList.put(suffix);
    }
    return bytesList.toBytes();
  }
  exports.serializeObject = serializeObject;
  function signingData(transaction, prefix = hash_prefixes_12.HashPrefix.transactionSig, opts = {}) {
    return serializeObject(transaction, {
      prefix,
      signingFieldsOnly: true,
      definitions: opts.definitions
    });
  }
  exports.signingData = signingData;
  function signingClaimData(claim) {
    const num = bigInt2(String(claim.amount));
    const prefix = hash_prefixes_12.HashPrefix.paymentChannelClaim;
    const channel = types_12.coreTypes.Hash256.from(claim.channel).toBytes();
    const amount2 = types_12.coreTypes.UInt64.from(num).toBytes();
    const bytesList = new binary_serializer_12.BytesList();
    bytesList.put(prefix);
    bytesList.put(channel);
    bytesList.put(amount2);
    return bytesList.toBytes();
  }
  exports.signingClaimData = signingClaimData;
  function multiSigningData(transaction, signingAccount, opts = {
    definitions: enums_12.DEFAULT_DEFINITIONS
  }) {
    const prefix = hash_prefixes_12.HashPrefix.transactionMultiSig;
    const suffix = types_12.coreTypes.AccountID.from(signingAccount).toBytes();
    return serializeObject(transaction, {
      prefix,
      suffix,
      signingFieldsOnly: true,
      definitions: opts.definitions
    });
  }
  exports.multiSigningData = multiSigningData;
})(binary);
var shamap = {};
Object.defineProperty(shamap, "__esModule", { value: true });
shamap.ShaMapLeaf = shamap.ShaMapNode = shamap.ShaMap = void 0;
const assert_1 = requireAssert();
const types_1$2 = types;
const hash_prefixes_1$1 = hashPrefixes;
const hashes_1$1 = hashes;
const buffer_1$1 = dist$h;
class ShaMapNode {
}
shamap.ShaMapNode = ShaMapNode;
class ShaMapLeaf extends ShaMapNode {
  constructor(index2, item) {
    super();
    this.index = index2;
    this.item = item;
  }
  /**
   * @returns true as ShaMapLeaf is a leaf node
   */
  isLeaf() {
    return true;
  }
  /**
   * @returns false as ShaMapLeaf is not an inner node
   */
  isInner() {
    return false;
  }
  /**
   * Get the prefix of the this.item
   *
   * @returns The hash prefix, unless this.item is undefined, then it returns an empty Buffer
   */
  hashPrefix() {
    return this.item === void 0 ? buffer_1$1.Buffer.alloc(0) : this.item.hashPrefix();
  }
  /**
   * Hash the bytes representation of this
   *
   * @returns hash of this.item concatenated with this.index
   */
  hash() {
    const hash3 = hashes_1$1.Sha512Half.put(this.hashPrefix());
    this.toBytesSink(hash3);
    return hash3.finish();
  }
  /**
   * Write the bytes representation of this to a BytesList
   * @param list BytesList to write bytes to
   */
  toBytesSink(list) {
    if (this.item !== void 0) {
      this.item.toBytesSink(list);
    }
    this.index.toBytesSink(list);
  }
}
shamap.ShaMapLeaf = ShaMapLeaf;
class ShaMapInner extends ShaMapNode {
  constructor(depth = 0) {
    super();
    this.depth = depth;
    this.slotBits = 0;
    this.branches = Array(16);
  }
  /**
   * @returns true as ShaMapInner is an inner node
   */
  isInner() {
    return true;
  }
  /**
   * @returns false as ShaMapInner is not a leaf node
   */
  isLeaf() {
    return false;
  }
  /**
   * Get the hash prefix for this node
   *
   * @returns hash prefix describing an inner node
   */
  hashPrefix() {
    return hash_prefixes_1$1.HashPrefix.innerNode;
  }
  /**
   * Set a branch of this node to be another node
   *
   * @param slot Slot to add branch to this.branches
   * @param branch Branch to add
   */
  setBranch(slot, branch) {
    this.slotBits = this.slotBits | 1 << slot;
    this.branches[slot] = branch;
  }
  /**
   * @returns true if node is empty
   */
  empty() {
    return this.slotBits === 0;
  }
  /**
   * Compute the hash of this node
   *
   * @returns The hash of this node
   */
  hash() {
    if (this.empty()) {
      return types_1$2.coreTypes.Hash256.ZERO_256;
    }
    const hash3 = hashes_1$1.Sha512Half.put(this.hashPrefix());
    this.toBytesSink(hash3);
    return hash3.finish();
  }
  /**
   * Writes the bytes representation of this node to a BytesList
   *
   * @param list BytesList to write bytes to
   */
  toBytesSink(list) {
    for (let i = 0; i < this.branches.length; i++) {
      const branch = this.branches[i];
      const hash3 = branch ? branch.hash() : types_1$2.coreTypes.Hash256.ZERO_256;
      hash3.toBytesSink(list);
    }
  }
  /**
   * Add item to the SHAMap
   *
   * @param index Hash of the index of the item being inserted
   * @param item Item to insert in the map
   * @param leaf Leaf node to insert when branch doesn't exist
   */
  addItem(index2, item, leaf) {
    assert_1.strict.ok(index2 !== void 0);
    if (index2 !== void 0) {
      const nibble = index2.nibblet(this.depth);
      const existing = this.branches[nibble];
      if (existing === void 0) {
        this.setBranch(nibble, leaf || new ShaMapLeaf(index2, item));
      } else if (existing instanceof ShaMapLeaf) {
        const newInner = new ShaMapInner(this.depth + 1);
        newInner.addItem(existing.index, void 0, existing);
        newInner.addItem(index2, item, leaf);
        this.setBranch(nibble, newInner);
      } else if (existing instanceof ShaMapInner) {
        existing.addItem(index2, item, leaf);
      } else {
        throw new Error("invalid ShaMap.addItem call");
      }
    }
  }
}
class ShaMap extends ShaMapInner {
}
shamap.ShaMap = ShaMap;
var ledgerHashes = {};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule) return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
  }
  __setModuleDefault(result, mod2);
  return result;
};
Object.defineProperty(ledgerHashes, "__esModule", { value: true });
ledgerHashes.decodeLedgerData = ledgerHashes.ledgerHash = ledgerHashes.transactionTreeHash = ledgerHashes.accountStateHash = void 0;
const assert = __importStar(requireAssert());
const shamap_1 = shamap;
const hash_prefixes_1 = hashPrefixes;
const hashes_1 = hashes;
const binary_1 = binary;
const hash_256_1 = hash256;
const st_object_1 = requireStObject();
const uint_64_1 = uint64;
const uint_32_1 = uint32;
const uint_8_1 = uint8;
const binary_parser_1 = binaryParser;
const bigInt$1 = BigIntegerExports;
function computeHash(itemizer, itemsJson) {
  const map = new shamap_1.ShaMap();
  itemsJson.forEach((item) => map.addItem(...itemizer(item)));
  return map.hash();
}
function transactionItemizer(json) {
  assert.ok(json.hash);
  const index2 = hash_256_1.Hash256.from(json.hash);
  const item = {
    hashPrefix() {
      return hash_prefixes_1.HashPrefix.transaction;
    },
    toBytesSink(sink) {
      const serializer = new binary_1.BinarySerializer(sink);
      serializer.writeLengthEncoded(st_object_1.STObject.from(json));
      serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));
    }
  };
  return [index2, item, void 0];
}
function entryItemizer(json) {
  const index2 = hash_256_1.Hash256.from(json.index);
  const bytes2 = (0, binary_1.serializeObject)(json);
  const item = {
    hashPrefix() {
      return hash_prefixes_1.HashPrefix.accountStateEntry;
    },
    toBytesSink(sink) {
      sink.put(bytes2);
    }
  };
  return [index2, item, void 0];
}
function transactionTreeHash(param) {
  const itemizer = transactionItemizer;
  return computeHash(itemizer, param);
}
ledgerHashes.transactionTreeHash = transactionTreeHash;
function accountStateHash(param) {
  const itemizer = entryItemizer;
  return computeHash(itemizer, param);
}
ledgerHashes.accountStateHash = accountStateHash;
function ledgerHash(header) {
  const hash3 = new hashes_1.Sha512Half();
  hash3.put(hash_prefixes_1.HashPrefix.ledgerHeader);
  assert.ok(header.parent_close_time !== void 0);
  assert.ok(header.close_flags !== void 0);
  uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash3);
  uint_64_1.UInt64.from(bigInt$1(String(header.total_coins))).toBytesSink(hash3);
  hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash3);
  hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash3);
  hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash3);
  uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash3);
  uint_32_1.UInt32.from(header.close_time).toBytesSink(hash3);
  uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash3);
  uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash3);
  return hash3.finish();
}
ledgerHashes.ledgerHash = ledgerHash;
function decodeLedgerData(binary2, definitions) {
  assert.ok(typeof binary2 === "string", "binary must be a hex string");
  const parser = new binary_parser_1.BinaryParser(binary2, definitions);
  return {
    ledger_index: parser.readUInt32(),
    total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),
    parent_hash: parser.readType(hash_256_1.Hash256).toHex(),
    transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),
    account_hash: parser.readType(hash_256_1.Hash256).toHex(),
    parent_close_time: parser.readUInt32(),
    close_time: parser.readUInt32(),
    close_time_resolution: parser.readUInt8(),
    close_flags: parser.readUInt8()
  };
}
ledgerHashes.decodeLedgerData = decodeLedgerData;
var quality$1 = {};
Object.defineProperty(quality$1, "__esModule", { value: true });
quality$1.quality = void 0;
const types_1$1 = types;
const decimal_js_1 = decimalExports;
const bigInt = BigIntegerExports;
const buffer_1 = dist$h;
class quality {
  /**
   * Encode quality amount
   *
   * @param arg string representation of an amount
   * @returns Serialized quality
   */
  static encode(quality2) {
    const decimal2 = new decimal_js_1.Decimal(quality2);
    const exponent = decimal2.e - 15;
    const qualityString = decimal2.times(`1e${-exponent}`).abs().toString();
    const bytes2 = types_1$1.coreTypes.UInt64.from(bigInt(qualityString)).toBytes();
    bytes2[0] = exponent + 100;
    return bytes2;
  }
  /**
   * Decode quality amount
   *
   * @param arg hex-string denoting serialized quality
   * @returns deserialized quality
   */
  static decode(quality2) {
    const bytes2 = buffer_1.Buffer.from(quality2, "hex").slice(-8);
    const exponent = bytes2[0] - 100;
    const mantissa = new decimal_js_1.Decimal(`0x${bytes2.slice(1).toString("hex")}`);
    return mantissa.times(`1e${exponent}`);
  }
}
quality$1.quality = quality;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.types = exports.ShaMap = exports.HashPrefix = exports.quality = exports.TransactionResult = exports.Type = exports.LedgerEntryType = exports.TransactionType = exports.Field = exports.DEFAULT_DEFINITIONS = exports.ledgerHashes = exports.binary = exports.hashes = void 0;
  const enums_12 = enums;
  Object.defineProperty(exports, "DEFAULT_DEFINITIONS", { enumerable: true, get: function() {
    return enums_12.DEFAULT_DEFINITIONS;
  } });
  Object.defineProperty(exports, "Field", { enumerable: true, get: function() {
    return enums_12.Field;
  } });
  Object.defineProperty(exports, "TransactionType", { enumerable: true, get: function() {
    return enums_12.TransactionType;
  } });
  Object.defineProperty(exports, "LedgerEntryType", { enumerable: true, get: function() {
    return enums_12.LedgerEntryType;
  } });
  Object.defineProperty(exports, "Type", { enumerable: true, get: function() {
    return enums_12.Type;
  } });
  Object.defineProperty(exports, "TransactionResult", { enumerable: true, get: function() {
    return enums_12.TransactionResult;
  } });
  const types$12 = __importStar2(types);
  exports.types = types$12;
  const binary$1 = __importStar2(binary);
  exports.binary = binary$1;
  const shamap_12 = shamap;
  Object.defineProperty(exports, "ShaMap", { enumerable: true, get: function() {
    return shamap_12.ShaMap;
  } });
  const ledgerHashes$1 = __importStar2(ledgerHashes);
  exports.ledgerHashes = ledgerHashes$1;
  const hashes$1 = __importStar2(hashes);
  exports.hashes = hashes$1;
  const quality_1 = quality$1;
  Object.defineProperty(exports, "quality", { enumerable: true, get: function() {
    return quality_1.quality;
  } });
  const hash_prefixes_12 = hashPrefixes;
  Object.defineProperty(exports, "HashPrefix", { enumerable: true, get: function() {
    return hash_prefixes_12.HashPrefix;
  } });
})(coretypes);
var xrplDefinitions = {};
Object.defineProperty(xrplDefinitions, "__esModule", { value: true });
xrplDefinitions.XrplDefinitions = void 0;
const xrpl_definitions_base_1 = xrplDefinitionsBase;
const types_1 = types;
class XrplDefinitions extends xrpl_definitions_base_1.XrplDefinitionsBase {
  /**
   * Present rippled types in a typed and updatable format.
   * For an example of the input format see `definitions.json`
   * To generate a new definitions file from rippled source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen
   *
   * See the definitions.test.js file for examples of how to create your own updated definitions.json.
   *
   * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
   * @param additionalTypes - A list of SerializedType objects with the same name as the fields defined.
   *              These types will be included in addition to the coreTypes used on mainnet.
   */
  constructor(enums2, additionalTypes) {
    const types2 = Object.assign({}, types_1.coreTypes, additionalTypes);
    super(enums2, types2);
  }
}
xrplDefinitions.XrplDefinitions = XrplDefinitions;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;
  const assert2 = __importStar2(requireAssert());
  const coretypes_1 = coretypes;
  const ledger_hashes_1 = ledgerHashes;
  Object.defineProperty(exports, "decodeLedgerData", { enumerable: true, get: function() {
    return ledger_hashes_1.decodeLedgerData;
  } });
  const enums_12 = enums;
  Object.defineProperty(exports, "XrplDefinitionsBase", { enumerable: true, get: function() {
    return enums_12.XrplDefinitionsBase;
  } });
  Object.defineProperty(exports, "TRANSACTION_TYPES", { enumerable: true, get: function() {
    return enums_12.TRANSACTION_TYPES;
  } });
  Object.defineProperty(exports, "DEFAULT_DEFINITIONS", { enumerable: true, get: function() {
    return enums_12.DEFAULT_DEFINITIONS;
  } });
  const xrpl_definitions_1 = xrplDefinitions;
  Object.defineProperty(exports, "XrplDefinitions", { enumerable: true, get: function() {
    return xrpl_definitions_1.XrplDefinitions;
  } });
  const types_12 = types;
  Object.defineProperty(exports, "coreTypes", { enumerable: true, get: function() {
    return types_12.coreTypes;
  } });
  const { signingData, signingClaimData, multiSigningData, binaryToJSON, serializeObject } = coretypes_1.binary;
  function decode2(binary2, definitions) {
    assert2.ok(typeof binary2 === "string", "binary must be a hex string");
    return binaryToJSON(binary2, definitions);
  }
  exports.decode = decode2;
  function encode3(json, definitions) {
    assert2.ok(typeof json === "object");
    return serializeObject(json, { definitions }).toString("hex").toUpperCase();
  }
  exports.encode = encode3;
  function encodeForSigning(json, definitions) {
    assert2.ok(typeof json === "object");
    return signingData(json, coretypes_1.HashPrefix.transactionSig, {
      definitions
    }).toString("hex").toUpperCase();
  }
  exports.encodeForSigning = encodeForSigning;
  function encodeForSigningClaim(json) {
    assert2.ok(typeof json === "object");
    return signingClaimData(json).toString("hex").toUpperCase();
  }
  exports.encodeForSigningClaim = encodeForSigningClaim;
  function encodeForMultisigning(json, signer, definitions) {
    assert2.ok(typeof json === "object");
    assert2.equal(json["SigningPubKey"], "");
    const definitionsOpt = definitions ? { definitions } : void 0;
    return multiSigningData(json, signer, definitionsOpt).toString("hex").toUpperCase();
  }
  exports.encodeForMultisigning = encodeForMultisigning;
  function encodeQuality(value) {
    assert2.ok(typeof value === "string");
    return coretypes_1.quality.encode(value).toString("hex").toUpperCase();
  }
  exports.encodeQuality = encodeQuality;
  function decodeQuality(value) {
    assert2.ok(typeof value === "string");
    return coretypes_1.quality.decode(value).toString();
  }
  exports.decodeQuality = decodeQuality;
})(dist$1);
Object.defineProperty(xrp, "__esModule", { value: true });
xrp.KeystoneXrpSDK = void 0;
const bc_ur_1 = dist$g;
const ripple_binary_codec_1 = dist$1;
class KeystoneXrpSDK {
  parseAccount(ur2) {
    const accountInfo = ur2.decodeCBOR().toString();
    return JSON.parse(accountInfo);
  }
  parseSignature(ur2) {
    if (ur2.type !== "bytes") {
      throw new Error("type not match");
    }
    try {
      const signedTxHex = ur2.decodeCBOR().toString("hex");
      const signedTx = (0, ripple_binary_codec_1.decode)(signedTxHex);
      return signedTx.TxnSignature;
    } catch (e) {
      throw new Error("signature is invalid");
    }
  }
  generateSignRequest(tx) {
    const txStr = JSON.stringify(tx);
    return bc_ur_1.UR.fromBuffer(Buffer$1$1.from(txStr));
  }
}
xrp.KeystoneXrpSDK = KeystoneXrpSDK;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(xrp, exports);
})(xrp$1);
Object.defineProperty(sdk$1, "__esModule", { value: true });
sdk$1.KeystoneSDK = void 0;
const chains_1 = chains;
const wallet_1 = wallet;
const xrp_1 = xrp$1;
let KeystoneSDK$1 = class KeystoneSDK {
  constructor(config2) {
    this.parseMultiAccounts = wallet_1.parseMultiAccounts;
    this.parseTonAccount = wallet_1.parseTonAccount;
    this.parseHDKey = wallet_1.parseHDKey;
    this.parseAccount = wallet_1.parseAccount;
    this.generateKeyDerivationCall = wallet_1.generateKeyDerivationCall;
    this.config = config2;
  }
  get btc() {
    if (this._btc === void 0) {
      this._btc = new chains_1.KeystoneBitcoinSDK();
    }
    return this._btc;
  }
  get eth() {
    if (this._eth === void 0) {
      this._eth = new chains_1.KeystoneEthereumSDK(this.config);
    }
    return this._eth;
  }
  get sol() {
    if (this._sol === void 0) {
      this._sol = new chains_1.KeystoneSolanaSDK();
    }
    return this._sol;
  }
  get stellar() {
    if (this._stellar === void 0) {
      this._stellar = new chains_1.KeystoneStellarSDK();
    }
    return this._stellar;
  }
  get cosmos() {
    if (this._cosmos === void 0) {
      this._cosmos = new chains_1.KeystoneCosmosSDK(this.config);
    }
    return this._cosmos;
  }
  get evm() {
    if (this._evm === void 0) {
      this._evm = new chains_1.KeystoneEvmSDK(this.config);
    }
    return this._evm;
  }
  get tron() {
    if (this._tron === void 0) {
      this._tron = new chains_1.KeystoneTronSDK();
    }
    return this._tron;
  }
  get ltc() {
    if (this._ltc === void 0) {
      this._ltc = new chains_1.KeystoneLitecoinSDK();
    }
    return this._ltc;
  }
  get bch() {
    if (this._bch === void 0) {
      this._bch = new chains_1.KeystoneBitcoinCashSDK();
    }
    return this._bch;
  }
  get dash() {
    if (this._dash === void 0) {
      this._dash = new chains_1.KeystoneDashSDK();
    }
    return this._dash;
  }
  get aptos() {
    if (this._aptos === void 0) {
      this._aptos = new chains_1.KeystoneAptosSDK();
    }
    return this._aptos;
  }
  get near() {
    if (this._near === void 0) {
      this._near = new chains_1.KeystoneNearSDK();
    }
    return this._near;
  }
  get arweave() {
    if (this._arweave === void 0) {
      this._arweave = new chains_1.KeystoneArweaveSDK();
    }
    return this._arweave;
  }
  get sui() {
    if (this._sui === void 0) {
      this._sui = new chains_1.KeystoneSuiSDK();
    }
    return this._sui;
  }
  get cardano() {
    if (this._cardano === void 0) {
      this._cardano = new chains_1.KeystoneCardanoSDK();
    }
    return this._cardano;
  }
  get xrp() {
    if (this._xrp === void 0) {
      this._xrp = new xrp_1.KeystoneXrpSDK();
    }
    return this._xrp;
  }
  get ton() {
    if (this._ton === void 0) {
      this._ton = new chains_1.KeystoneTonSDK(this.config);
    }
    return this._ton;
  }
};
KeystoneSDK$1.parseMultiAccounts = wallet_1.parseMultiAccounts;
KeystoneSDK$1.parseHDKey = wallet_1.parseHDKey;
KeystoneSDK$1.generateKeyDerivationCall = wallet_1.generateKeyDerivationCall;
sdk$1.KeystoneSDK = KeystoneSDK$1;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.utils = exports.KeystoneSDK = exports.QRHardwareCallVersion = exports.DerivationAlgorithm = exports.Curve = void 0;
  const utils2 = __importStar2(utils$k);
  exports.utils = utils2;
  const sdk_1 = sdk$1;
  Object.defineProperty(exports, "KeystoneSDK", { enumerable: true, get: function() {
    return sdk_1.KeystoneSDK;
  } });
  __exportStar2(dist$g, exports);
  __exportStar2(types$1, exports);
  __exportStar2(chains, exports);
  var hardwareCall_1 = hardwareCall;
  Object.defineProperty(exports, "Curve", { enumerable: true, get: function() {
    return hardwareCall_1.Curve;
  } });
  Object.defineProperty(exports, "DerivationAlgorithm", { enumerable: true, get: function() {
    return hardwareCall_1.DerivationAlgorithm;
  } });
  var bc_ur_registry_12 = requireDist$1();
  Object.defineProperty(exports, "QRHardwareCallVersion", { enumerable: true, get: function() {
    return bc_ur_registry_12.QRHardwareCallVersion;
  } });
  exports.default = sdk_1.KeystoneSDK;
})(dist$j);
const KeystoneSDK2 = /* @__PURE__ */ getDefaultExportFromCjs(dist$j);
const sdk = new KeystoneSDK2();
const origin = "eternl";
const curve = dist$j.Curve.ed25519;
const algo = dist$j.DerivationAlgorithm.bip32ed25519;
let builder = null;
let nonce = 0;
const getKeystonePublicKeyUR = (accPurpose = purpose.hdwallet, accIndex = 0, amountAccounts = 1, accList = []) => {
  let ur2;
  if (accIndex === -1 && accList.length === 0) {
    const schemas = [];
    for (let i = 0; i < amountAccounts; i++) {
      schemas.push({ path: getStringDerivationPath([accPurpose, coin$1.ada, i]), curve, algo });
    }
    ur2 = sdk.generateKeyDerivationCall({ schemas, origin });
  } else if (accList.length === 0) {
    if (accIndex >= 0 || accPurpose !== purpose.hdwallet) {
      ur2 = sdk.generateKeyDerivationCall(
        {
          schemas: [{ path: getStringDerivationPath([accPurpose, coin$1.ada, accIndex]), curve, algo }],
          origin
        }
      );
    } else {
      ur2 = sdk.generateKeyDerivationCall(
        {
          schemas: [{ path: getStringDerivationPath([purpose.hdwallet, coin$1.ada, 0]), curve, algo }],
          origin
        }
      );
    }
  } else {
    const schemas = [];
    for (let i = 0; i < accList.length; i++) {
      schemas.push({ path: getStringDerivationPath([accPurpose, coin$1.ada, accList[i]]), curve, algo });
    }
    ur2 = sdk.generateKeyDerivationCall({ schemas, origin });
  }
  return ur2;
};
const handleMultiAccountScan = (type, cbor2) => {
  const pubKeyList = [];
  const multiAccounts2 = sdk.parseMultiAccounts(new dist$j.UR(toHexBuffer(cbor2), type));
  for (const key2 of multiAccounts2.keys) {
    const pubKey = Bip32PublicKey.from_hex(key2.publicKey + key2.chainCode);
    pubKeyList.push(pubKey.to_bech32());
    safeFreeCSLObject(pubKey);
  }
  return { id: multiAccounts2.masterFingerprint, pubKeyList };
};
const handleKeystoneSignature = (accountData, txBuildRes, type, cbor2) => {
  let cslSignedTx;
  let cslWitnessSetOwned;
  let cslVkeys;
  let res = { error: "notExecuted" };
  try {
    const networkId = accountData.state.networkId;
    const epochParams = checkEpochParams(networkId);
    const keystoneSign = sdk.cardano.parseSignature(new dist$j.UR(toHexBuffer(cbor2), type));
    cslWitnessSetOwned = TransactionWitnessSet.from_hex(keystoneSign.witnessSet);
    const cslVkeysOwned = cslWitnessSetOwned.vkeys();
    cslVkeys = txBuildRes.cslWitnessSet.vkeys() ?? Vkeywitnesses.new();
    for (let i = 0; i < ((cslVkeysOwned == null ? void 0 : cslVkeysOwned.len()) ?? 0); i++) {
      const vkeyWitness = cslVkeysOwned.get(i);
      if (!hasWitness(cslVkeys, vkeyWitness)) {
        cslVkeys.add(vkeyWitness);
      }
      safeFreeCSLObject(vkeyWitness);
    }
    txBuildRes.cslWitnessSet.set_vkeys(cslVkeys);
    safeFreeCSLObject(cslVkeys);
    safeFreeCSLObject(cslVkeysOwned);
    cslSignedTx = Transaction.new(txBuildRes.cslTxBody, txBuildRes.cslWitnessSet, txBuildRes.cslAuxData);
    safeFreeCSLObject(txBuildRes.cslAuxData);
    txBuildRes.cslAuxData = cslSignedTx.auxiliary_data();
    const signedTxBytes = cslSignedTx.to_bytes();
    const signedTxHash = txBuildRes.txHash;
    const signedTx = getTransactionJSONFromCSL(networkId, cslSignedTx);
    const signedTxSize = signedTxBytes.byteLength;
    signedTx.hash = signedTxHash;
    signedTx.size = signedTxSize;
    signedTx.inputUtxoList = txBuildRes.builtTx.inputUtxoList;
    const signedTxHex = reinjectWitnessSet(txBuildRes.txCbor, toHexString(signedTxBytes), txBuildRes.cslWitnessSet);
    const signedTxWitnessSet = toHexString(txBuildRes.cslWitnessSet.to_bytes());
    const maxTxSize = epochParams.maxTxSize;
    signedTx.cbor = signedTxHex;
    res = {
      tx: signedTx,
      hash: signedTxHash,
      cbor: signedTxHex,
      witnessSet: signedTxWitnessSet,
      witnessSetOwned: keystoneSign.witnessSet
    };
    if (signedTxSize > epochParams.maxTxSize) {
      res.error = ErrorSignTx.txSize + "." + signedTxSize + "." + maxTxSize;
    }
  } catch (err2) {
    res = { error: (err2 == null ? void 0 : err2.message) ?? err2 };
  } finally {
    safeFreeCSLObject(cslSignedTx);
    safeFreeCSLObject(cslWitnessSetOwned);
  }
  return res;
};
const createKeystoneSignRequest = async (appAccount, walletData, txBuildRes, credList) => {
  if (!(txBuildRes == null ? void 0 : txBuildRes.builtTx)) {
    throw ErrorSignTx.missingTx;
  }
  if (!(txBuildRes == null ? void 0 : txBuildRes.txCbor)) {
    throw ErrorSignTx.missingTx;
  }
  if (!credList) {
    throw ErrorSignTx.missingKeysList;
  }
  const xfp = walletData.wallet.masterFingerprint ?? "";
  const tx = txBuildRes.builtTx;
  let inputUtxoList = tx.inputUtxoList;
  if (!inputUtxoList) {
    const { utxoList } = getFilteredUtxoList(appAccount, false);
    inputUtxoList = utxoList;
  }
  const req = {
    origin,
    requestId: getRandomUUID(),
    signData: toHexBuffer(txBuildRes.txCbor),
    utxos: getOwnedUtxos(appAccount.data, xfp, tx.body.inputs, inputUtxoList),
    extraSigners: getExtraSigners(appAccount.data, xfp, credList, tx.body.inputs, inputUtxoList)
  };
  const req_json = JSON.parse(JSON.stringify(req));
  console.log("req_json", JSON.stringify(req_json));
  console.log("req_json", req_json);
  txBuildRes.hwRequest = req_json;
  return sdk.cardano.generateSignRequest(req);
};
const createKeystoneSignDataRequest = async (appAccount, walletData, address2, payload) => {
  const accountData = appAccount.data;
  const keyDetails = getAccountKeyDetails(address2, appAccount.data);
  try {
    const xfp = walletData.wallet.masterFingerprint ?? "";
    const path = keyDetails.accountCredAndType.cred.path;
    const pubKeyBech32 = createPubKey(accountData.account.pub, path.slice(3));
    const bip32PubKey = getCSLBip32PublicKey(pubKeyBech32);
    const pubKey = bip32PubKey.to_raw_key();
    const pubHex = toHexString(pubKey.as_bytes());
    safeFreeCSLObject(pubKey);
    safeFreeCSLObject(bip32PubKey);
    builder = createSignDataBuilder(keyDetails.credBytes, payload);
    const sigStruc = builder.make_data_to_sign();
    const req = {
      xfp,
      origin,
      requestId: getRandomUUID(),
      payload: toHexString(sigStruc.to_bytes()),
      path: getStringDerivationPath(path),
      xpub: pubHex
    };
    safeFreeCSLObject(sigStruc);
    const req_json = JSON.parse(JSON.stringify(req));
    console.log("req_json", JSON.stringify(req_json));
    console.log("req_json", req_json);
    return sdk.cardano.generateSignDataRequest(req);
  } catch (err2) {
    throw (err2 == null ? void 0 : err2.message) ?? err2;
  }
};
const createKeystoneCatalystRequest = async (accountData, walletData, catalystPrvKey) => {
  const xfp = walletData.wallet.masterFingerprint ?? "";
  const networkId = accountData.state.networkId;
  const free = [];
  try {
    const changeAddr = getChangeAddress(accountData);
    changeAddr && free.push(changeAddr.csl);
    if (!changeAddr) {
      throw new Error("Unable to get reward payment address of account");
    }
    const stakeCred = accountData.keys.stake[0];
    const stakePubKeyBech32 = createPubKey(accountData.account.pub, stakeCred.path.slice(3));
    const stakePubKey = getCSLBip32PublicKey(stakePubKeyBech32, free).to_raw_key();
    free.push(stakePubKey);
    const stakePubHex = toHexString(stakePubKey.as_bytes());
    const rewardAddressHex = toHexString(changeAddr.csl.to_bytes());
    const voteBip32PrvKey = getCSLBip32PrivateKey(catalystPrvKey, free);
    free.push(voteBip32PrvKey);
    const votePrvKey = voteBip32PrvKey.to_raw_key();
    free.push(votePrvKey);
    const votePubKey = votePrvKey.to_public();
    free.push(votePubKey);
    const votePubHex = toHexString(votePubKey.as_bytes());
    nonce = getCalculatedChainTip(networkId);
    const req = {
      xfp,
      origin,
      requestId: getRandomUUID(),
      delegations: [{ pubKey: votePubHex, weight: 1 }],
      path: getStringDerivationPath(stakeCred.path),
      stakePub: stakePubHex,
      paymentAddress: rewardAddressHex,
      nonce,
      voting_purpose: 0
    };
    const req_json = JSON.parse(JSON.stringify(req));
    console.log("req_json", JSON.stringify(req_json));
    console.log("req_json", req_json);
    return sdk.cardano.generateCatalystRequest(req);
  } catch (err2) {
    throw (err2 == null ? void 0 : err2.message) ?? err2;
  } finally {
    freeCSLObjects(free);
  }
};
const getOwnedUtxos = (accountData, xfp, inputs, utxoList) => {
  const keystoneInputs = [];
  for (const input of inputs) {
    const utxo2 = utxoList.find((u) => u.input.transaction_id === input.transaction_id && u.input.index === input.index);
    const cred = utxo2 ? getAddressCredentials(utxo2.output.address) : null;
    const key2 = cred ? getOwnedCred([accountData.keys], cred.paymentCred) : null;
    if (key2) {
      keystoneInputs.push({
        transactionHash: utxo2.input.transaction_id,
        index: utxo2.input.index,
        amount: utxo2.output.amount.coin,
        xfp,
        hdPath: getStringDerivationPath(key2.path),
        address: utxo2.output.address
      });
    }
  }
  return keystoneInputs;
};
const getExtraSigners = (accountData, xfp, credList, inputs, utxoList) => {
  const extraSigners = [];
  const utxoCredSet = /* @__PURE__ */ new Set();
  for (const utxo2 of utxoList) {
    if (inputs.some((i) => i.transaction_id === utxo2.input.transaction_id && i.index === utxo2.input.index)) {
      const cred = utxo2 ? getAddressCredentials(utxo2.output.address).paymentCred : null;
      if (cred) {
        utxoCredSet.add(cred);
      }
    }
  }
  for (const cred of credList) {
    const key2 = getOwnedCred([accountData.keys], cred.cred);
    if (key2 && !utxoCredSet.has(key2.cred)) {
      extraSigners.push({
        keyHash: cred.cred,
        xfp,
        keyPath: getStringDerivationPath(cred.path)
      });
    }
  }
  return extraSigners;
};
const handleKeystoneSignData = (type, cbor2) => {
  const keystoneSign = sdk.cardano.parseSignDataSignature(new dist$j.UR(toHexBuffer(cbor2), type));
  const pubKey = PublicKey.from_bytes(toHexBuffer(keystoneSign.publicKey));
  const coseSign1 = builder.build(toHexArray(keystoneSign.signature));
  const signatureHex = toHexString(coseSign1.to_bytes());
  const keyHex = createCOSEKeyHex(pubKey.as_bytes());
  safeFreeCSLObject(pubKey);
  safeFreeCSLObject(coseSign1);
  safeFreeCSLObject(builder);
  builder = null;
  return {
    signature: signatureHex,
    key: keyHex
  };
};
const handleKeystoneCatalyst = (type, cbor2) => {
  const keystoneSign = sdk.cardano.parseCatalystSignature(new dist$j.UR(toHexBuffer(cbor2), type));
  return {
    signature: keystoneSign.signature,
    nonce
  };
};
function useKeystoneDevice() {
  return {
    getKeystonePublicKeyUR,
    handleMultiAccountScan,
    createKeystoneSignRequest,
    createKeystoneSignDataRequest,
    createKeystoneCatalystRequest,
    handleKeystoneSignature,
    handleKeystoneSignData,
    handleKeystoneCatalyst
  };
}
const MAX_FRAGMENT_LENGTH = 256;
const DEFAULT_INTERVAL = 100;
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "AnimatedQRCode",
  props: {
    ur: { type: Object, required: true },
    capacity: { type: Number, required: false, default: MAX_FRAGMENT_LENGTH },
    interval: { type: Number, required: false, default: DEFAULT_INTERVAL }
  },
  setup(__props) {
    let _iid = -1;
    const canvasRef = ref(null);
    const canvasError = ref("");
    const props2 = __props;
    const updateQRCode = async (fragment) => {
      await browser$1.toCanvas(canvasRef.value, fragment);
    };
    const generateQRAnimation = async () => {
      try {
        const urEncoder2 = new dist$j.UREncoder(props2.ur, props2.capacity);
        _iid = setInterval(async () => {
          await updateQRCode(urEncoder2.nextPart().toUpperCase());
        }, props2.interval);
      } catch (err2) {
        canvasError.value = (err2 == null ? void 0 : err2.message) ?? JSON.stringify(err2);
        console.error(canvasError.value);
      }
    };
    onMounted(() => generateQRAnimation());
    onUnmounted(() => clearInterval(_iid));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("canvas", {
        ref_key: "canvasRef",
        ref: canvasRef,
        width: 212,
        height: 212,
        class: "shadow cc-rounded mt-4 mb-4"
      }, null, 512);
    };
  }
});
var Html5QrcodeSupportedFormats;
(function(Html5QrcodeSupportedFormats2) {
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["QR_CODE"] = 0] = "QR_CODE";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["AZTEC"] = 1] = "AZTEC";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODABAR"] = 2] = "CODABAR";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_39"] = 3] = "CODE_39";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_93"] = 4] = "CODE_93";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_128"] = 5] = "CODE_128";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["DATA_MATRIX"] = 6] = "DATA_MATRIX";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["MAXICODE"] = 7] = "MAXICODE";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["ITF"] = 8] = "ITF";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["EAN_13"] = 9] = "EAN_13";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["EAN_8"] = 10] = "EAN_8";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["PDF_417"] = 11] = "PDF_417";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["RSS_14"] = 12] = "RSS_14";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_A"] = 14] = "UPC_A";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_E"] = 15] = "UPC_E";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
})(Html5QrcodeSupportedFormats || (Html5QrcodeSupportedFormats = {}));
var html5QrcodeSupportedFormatsTextMap = /* @__PURE__ */ new Map([
  [Html5QrcodeSupportedFormats.QR_CODE, "QR_CODE"],
  [Html5QrcodeSupportedFormats.AZTEC, "AZTEC"],
  [Html5QrcodeSupportedFormats.CODABAR, "CODABAR"],
  [Html5QrcodeSupportedFormats.CODE_39, "CODE_39"],
  [Html5QrcodeSupportedFormats.CODE_93, "CODE_93"],
  [Html5QrcodeSupportedFormats.CODE_128, "CODE_128"],
  [Html5QrcodeSupportedFormats.DATA_MATRIX, "DATA_MATRIX"],
  [Html5QrcodeSupportedFormats.MAXICODE, "MAXICODE"],
  [Html5QrcodeSupportedFormats.ITF, "ITF"],
  [Html5QrcodeSupportedFormats.EAN_13, "EAN_13"],
  [Html5QrcodeSupportedFormats.EAN_8, "EAN_8"],
  [Html5QrcodeSupportedFormats.PDF_417, "PDF_417"],
  [Html5QrcodeSupportedFormats.RSS_14, "RSS_14"],
  [Html5QrcodeSupportedFormats.RSS_EXPANDED, "RSS_EXPANDED"],
  [Html5QrcodeSupportedFormats.UPC_A, "UPC_A"],
  [Html5QrcodeSupportedFormats.UPC_E, "UPC_E"],
  [Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION, "UPC_EAN_EXTENSION"]
]);
var DecodedTextType;
(function(DecodedTextType2) {
  DecodedTextType2[DecodedTextType2["UNKNOWN"] = 0] = "UNKNOWN";
  DecodedTextType2[DecodedTextType2["URL"] = 1] = "URL";
})(DecodedTextType || (DecodedTextType = {}));
function isValidHtml5QrcodeSupportedFormats(format) {
  return Object.values(Html5QrcodeSupportedFormats).includes(format);
}
var Html5QrcodeScanType;
(function(Html5QrcodeScanType2) {
  Html5QrcodeScanType2[Html5QrcodeScanType2["SCAN_TYPE_CAMERA"] = 0] = "SCAN_TYPE_CAMERA";
  Html5QrcodeScanType2[Html5QrcodeScanType2["SCAN_TYPE_FILE"] = 1] = "SCAN_TYPE_FILE";
})(Html5QrcodeScanType || (Html5QrcodeScanType = {}));
var Html5QrcodeConstants = function() {
  function Html5QrcodeConstants2() {
  }
  Html5QrcodeConstants2.GITHUB_PROJECT_URL = "https://github.com/mebjas/html5-qrcode";
  Html5QrcodeConstants2.SCAN_DEFAULT_FPS = 2;
  Html5QrcodeConstants2.DEFAULT_DISABLE_FLIP = false;
  Html5QrcodeConstants2.DEFAULT_REMEMBER_LAST_CAMERA_USED = true;
  Html5QrcodeConstants2.DEFAULT_SUPPORTED_SCAN_TYPE = [
    Html5QrcodeScanType.SCAN_TYPE_CAMERA,
    Html5QrcodeScanType.SCAN_TYPE_FILE
  ];
  return Html5QrcodeConstants2;
}();
var QrcodeResultFormat = function() {
  function QrcodeResultFormat2(format, formatName) {
    this.format = format;
    this.formatName = formatName;
  }
  QrcodeResultFormat2.prototype.toString = function() {
    return this.formatName;
  };
  QrcodeResultFormat2.create = function(format) {
    if (!html5QrcodeSupportedFormatsTextMap.has(format)) {
      throw "".concat(format, " not in html5QrcodeSupportedFormatsTextMap");
    }
    return new QrcodeResultFormat2(format, html5QrcodeSupportedFormatsTextMap.get(format));
  };
  return QrcodeResultFormat2;
}();
var Html5QrcodeResultFactory = function() {
  function Html5QrcodeResultFactory2() {
  }
  Html5QrcodeResultFactory2.createFromText = function(decodedText) {
    var qrcodeResult = {
      text: decodedText
    };
    return {
      decodedText,
      result: qrcodeResult
    };
  };
  Html5QrcodeResultFactory2.createFromQrcodeResult = function(qrcodeResult) {
    return {
      decodedText: qrcodeResult.text,
      result: qrcodeResult
    };
  };
  return Html5QrcodeResultFactory2;
}();
var Html5QrcodeErrorTypes;
(function(Html5QrcodeErrorTypes2) {
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["UNKWOWN_ERROR"] = 0] = "UNKWOWN_ERROR";
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["IMPLEMENTATION_ERROR"] = 1] = "IMPLEMENTATION_ERROR";
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["NO_CODE_FOUND_ERROR"] = 2] = "NO_CODE_FOUND_ERROR";
})(Html5QrcodeErrorTypes || (Html5QrcodeErrorTypes = {}));
var Html5QrcodeErrorFactory = function() {
  function Html5QrcodeErrorFactory2() {
  }
  Html5QrcodeErrorFactory2.createFrom = function(error) {
    return {
      errorMessage: error,
      type: Html5QrcodeErrorTypes.UNKWOWN_ERROR
    };
  };
  return Html5QrcodeErrorFactory2;
}();
var BaseLoggger = function() {
  function BaseLoggger2(verbose) {
    this.verbose = verbose;
  }
  BaseLoggger2.prototype.log = function(message2) {
    if (this.verbose) {
      console.log(message2);
    }
  };
  BaseLoggger2.prototype.warn = function(message2) {
    if (this.verbose) {
      console.warn(message2);
    }
  };
  BaseLoggger2.prototype.logError = function(message2, isExperimental) {
    if (this.verbose || isExperimental === true) {
      console.error(message2);
    }
  };
  BaseLoggger2.prototype.logErrors = function(errors2) {
    if (errors2.length === 0) {
      throw "Logger#logError called without arguments";
    }
    if (this.verbose) {
      console.error(errors2);
    }
  };
  return BaseLoggger2;
}();
function isNullOrUndefined(obj) {
  return typeof obj === "undefined" || obj === null;
}
var Html5QrcodeStrings = function() {
  function Html5QrcodeStrings2() {
  }
  Html5QrcodeStrings2.codeParseError = function(exception) {
    return "QR code parse error, error = ".concat(exception);
  };
  Html5QrcodeStrings2.errorGettingUserMedia = function(error) {
    return "Error getting userMedia, error = ".concat(error);
  };
  Html5QrcodeStrings2.onlyDeviceSupportedError = function() {
    return "The device doesn't support navigator.mediaDevices , only supported cameraIdOrConfig in this case is deviceId parameter (string).";
  };
  Html5QrcodeStrings2.cameraStreamingNotSupported = function() {
    return "Camera streaming not supported by the browser.";
  };
  Html5QrcodeStrings2.unableToQuerySupportedDevices = function() {
    return "Unable to query supported devices, unknown error.";
  };
  Html5QrcodeStrings2.insecureContextCameraQueryError = function() {
    return "Camera access is only supported in secure context like https or localhost.";
  };
  Html5QrcodeStrings2.scannerPaused = function() {
    return "Scanner paused";
  };
  return Html5QrcodeStrings2;
}();
var VideoConstraintsUtil = function() {
  function VideoConstraintsUtil2() {
  }
  VideoConstraintsUtil2.isMediaStreamConstraintsValid = function(videoConstraints, logger) {
    if (typeof videoConstraints !== "object") {
      var typeofVideoConstraints = typeof videoConstraints;
      logger.logError("videoConstraints should be of type object, the " + "object passed is of type ".concat(typeofVideoConstraints, "."), true);
      return false;
    }
    var bannedKeys = [
      "autoGainControl",
      "channelCount",
      "echoCancellation",
      "latency",
      "noiseSuppression",
      "sampleRate",
      "sampleSize",
      "volume"
    ];
    var bannedkeysSet = new Set(bannedKeys);
    var keysInVideoConstraints = Object.keys(videoConstraints);
    for (var _i = 0, keysInVideoConstraints_1 = keysInVideoConstraints; _i < keysInVideoConstraints_1.length; _i++) {
      var key2 = keysInVideoConstraints_1[_i];
      if (bannedkeysSet.has(key2)) {
        logger.logError("".concat(key2, " is not supported videoConstaints."), true);
        return false;
      }
    }
    return true;
  };
  return VideoConstraintsUtil2;
}();
var zxingJs_umd$1 = { exports: {} };
(function(module, exports) {
  (function(global, factory) {
    factory(exports);
  })(commonjsGlobal, function(exports2) {
    function isNullOrUndefined2(obj) {
      return obj === null || obj === void 0;
    }
    var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };
    function __extends2(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function fixProto(target, prototype) {
      var setPrototypeOf = Object.setPrototypeOf;
      setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
    }
    function fixStack(target, fn) {
      if (fn === void 0) {
        fn = target.constructor;
      }
      var captureStackTrace = Error.captureStackTrace;
      captureStackTrace && captureStackTrace(target, fn);
    }
    var CustomError = function(_super) {
      __extends2(CustomError2, _super);
      function CustomError2(message2) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message2) || this;
        Object.defineProperty(_this, "name", {
          value: _newTarget.name,
          enumerable: false
        });
        fixProto(_this, _newTarget.prototype);
        fixStack(_this);
        return _this;
      }
      return CustomError2;
    }(Error);
    class Exception extends CustomError {
      /**
       * Allows Exception to be constructed directly
       * with some message and prototype definition.
       */
      constructor(message2 = void 0) {
        super(message2);
        this.message = message2;
      }
      getKind() {
        const ex = this.constructor;
        return ex.kind;
      }
    }
    Exception.kind = "Exception";
    class ArgumentException extends Exception {
    }
    ArgumentException.kind = "ArgumentException";
    class IllegalArgumentException extends Exception {
    }
    IllegalArgumentException.kind = "IllegalArgumentException";
    class BinaryBitmap {
      constructor(binarizer) {
        this.binarizer = binarizer;
        if (binarizer === null) {
          throw new IllegalArgumentException("Binarizer must be non-null.");
        }
      }
      /**
       * @return The width of the bitmap.
       */
      getWidth() {
        return this.binarizer.getWidth();
      }
      /**
       * @return The height of the bitmap.
       */
      getHeight() {
        return this.binarizer.getHeight();
      }
      /**
       * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return
       * cached data. Callers should assume this method is expensive and call it as seldom as possible.
       * This method is intended for decoding 1D barcodes and may choose to apply sharpening.
       *
       * @param y The row to fetch, which must be in [0, bitmap height)
       * @param row An optional preallocated array. If null or too small, it will be ignored.
       *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.
       * @return The array of bits for this row (true means black).
       * @throws NotFoundException if row can't be binarized
       */
      getBlackRow(y, row) {
        return this.binarizer.getBlackRow(y, row);
      }
      /**
       * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive
       * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
       * may not apply sharpening. Therefore, a row from this matrix may not be identical to one
       * fetched using getBlackRow(), so don't mix and match between them.
       *
       * @return The 2D array of bits for the image (true means black).
       * @throws NotFoundException if image can't be binarized to make a matrix
       */
      getBlackMatrix() {
        if (this.matrix === null || this.matrix === void 0) {
          this.matrix = this.binarizer.getBlackMatrix();
        }
        return this.matrix;
      }
      /**
       * @return Whether this bitmap can be cropped.
       */
      isCropSupported() {
        return this.binarizer.getLuminanceSource().isCropSupported();
      }
      /**
       * Returns a new object with cropped image data. Implementations may keep a reference to the
       * original data rather than a copy. Only callable if isCropSupported() is true.
       *
       * @param left The left coordinate, which must be in [0,getWidth())
       * @param top The top coordinate, which must be in [0,getHeight())
       * @param width The width of the rectangle to crop.
       * @param height The height of the rectangle to crop.
       * @return A cropped version of this object.
       */
      crop(left, top, width, height) {
        const newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
      }
      /**
       * @return Whether this bitmap supports counter-clockwise rotation.
       */
      isRotateSupported() {
        return this.binarizer.getLuminanceSource().isRotateSupported();
      }
      /**
       * Returns a new object with rotated image data by 90 degrees counterclockwise.
       * Only callable if {@link #isRotateSupported()} is true.
       *
       * @return A rotated version of this object.
       */
      rotateCounterClockwise() {
        const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
      }
      /**
       * Returns a new object with rotated image data by 45 degrees counterclockwise.
       * Only callable if {@link #isRotateSupported()} is true.
       *
       * @return A rotated version of this object.
       */
      rotateCounterClockwise45() {
        const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
      }
      /*@Override*/
      toString() {
        try {
          return this.getBlackMatrix().toString();
        } catch (e) {
          return "";
        }
      }
    }
    class ChecksumException extends Exception {
      static getChecksumInstance() {
        return new ChecksumException();
      }
    }
    ChecksumException.kind = "ChecksumException";
    class Binarizer {
      constructor(source) {
        this.source = source;
      }
      getLuminanceSource() {
        return this.source;
      }
      getWidth() {
        return this.source.getWidth();
      }
      getHeight() {
        return this.source.getHeight();
      }
    }
    class System {
      // public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
      /**
       * Makes a copy of a array.
       */
      static arraycopy(src2, srcPos, dest, destPos, length) {
        while (length--) {
          dest[destPos++] = src2[srcPos++];
        }
      }
      /**
       * Returns the current time in milliseconds.
       */
      static currentTimeMillis() {
        return Date.now();
      }
    }
    class IndexOutOfBoundsException extends Exception {
    }
    IndexOutOfBoundsException.kind = "IndexOutOfBoundsException";
    class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException {
      constructor(index2 = void 0, message2 = void 0) {
        super(message2);
        this.index = index2;
        this.message = message2;
      }
    }
    ArrayIndexOutOfBoundsException.kind = "ArrayIndexOutOfBoundsException";
    class Arrays {
      /**
       * Assigns the specified int value to each element of the specified array
       * of ints.
       *
       * @param a the array to be filled
       * @param val the value to be stored in all elements of the array
       */
      static fill(a, val) {
        for (let i = 0, len = a.length; i < len; i++)
          a[i] = val;
      }
      /**
       * Assigns the specified int value to each element of the specified
       * range of the specified array of ints.  The range to be filled
       * extends from index {@code fromIndex}, inclusive, to index
       * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
       * range to be filled is empty.)
       *
       * @param a the array to be filled
       * @param fromIndex the index of the first element (inclusive) to be
       *        filled with the specified value
       * @param toIndex the index of the last element (exclusive) to be
       *        filled with the specified value
       * @param val the value to be stored in all elements of the array
       * @throws IllegalArgumentException if {@code fromIndex > toIndex}
       * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or
       *         {@code toIndex > a.length}
       */
      static fillWithin(a, fromIndex, toIndex, val) {
        Arrays.rangeCheck(a.length, fromIndex, toIndex);
        for (let i = fromIndex; i < toIndex; i++)
          a[i] = val;
      }
      /**
       * Checks that {@code fromIndex} and {@code toIndex} are in
       * the range and throws an exception if they aren't.
       */
      static rangeCheck(arrayLength, fromIndex, toIndex) {
        if (fromIndex > toIndex) {
          throw new IllegalArgumentException("fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
        }
        if (fromIndex < 0) {
          throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        if (toIndex > arrayLength) {
          throw new ArrayIndexOutOfBoundsException(toIndex);
        }
      }
      static asList(...args) {
        return args;
      }
      static create(rows, cols, value) {
        let arr = Array.from({ length: rows });
        return arr.map((x) => Array.from({ length: cols }).fill(value));
      }
      static createInt32Array(rows, cols, value) {
        let arr = Array.from({ length: rows });
        return arr.map((x) => Int32Array.from({ length: cols }).fill(value));
      }
      static equals(first, second) {
        if (!first) {
          return false;
        }
        if (!second) {
          return false;
        }
        if (!first.length) {
          return false;
        }
        if (!second.length) {
          return false;
        }
        if (first.length !== second.length) {
          return false;
        }
        for (let i = 0, length = first.length; i < length; i++) {
          if (first[i] !== second[i]) {
            return false;
          }
        }
        return true;
      }
      static hashCode(a) {
        if (a === null) {
          return 0;
        }
        let result = 1;
        for (const element of a) {
          result = 31 * result + element;
        }
        return result;
      }
      static fillUint8Array(a, value) {
        for (let i = 0; i !== a.length; i++) {
          a[i] = value;
        }
      }
      static copyOf(original, newLength) {
        return original.slice(0, newLength);
      }
      static copyOfUint8Array(original, newLength) {
        if (original.length <= newLength) {
          const newArray = new Uint8Array(newLength);
          newArray.set(original);
          return newArray;
        }
        return original.slice(0, newLength);
      }
      static copyOfRange(original, from, to) {
        const newLength = to - from;
        const copy = new Int32Array(newLength);
        System.arraycopy(original, from, copy, 0, newLength);
        return copy;
      }
      /*
      * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point
      * for the new element.
      * Parameters:
      *     ar - A sorted array
      *     el - An element to search for
      *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:
      *        a negative number  if a is less than b;
      *        0 if a is equal to b;
      *        a positive number of a is greater than b.
      * The array may contain duplicate elements. If there are more than one equal elements in the array,
      * the returned value can be the index of any one of the equal elements.
      *
      * http://jsfiddle.net/aryzhov/pkfst550/
      */
      static binarySearch(ar, el, comparator) {
        if (void 0 === comparator) {
          comparator = Arrays.numberComparator;
        }
        let m = 0;
        let n = ar.length - 1;
        while (m <= n) {
          const k = n + m >> 1;
          const cmp = comparator(el, ar[k]);
          if (cmp > 0) {
            m = k + 1;
          } else if (cmp < 0) {
            n = k - 1;
          } else {
            return k;
          }
        }
        return -m - 1;
      }
      static numberComparator(a, b) {
        return a - b;
      }
    }
    class Integer {
      static numberOfTrailingZeros(i) {
        let y;
        if (i === 0)
          return 32;
        let n = 31;
        y = i << 16;
        if (y !== 0) {
          n -= 16;
          i = y;
        }
        y = i << 8;
        if (y !== 0) {
          n -= 8;
          i = y;
        }
        y = i << 4;
        if (y !== 0) {
          n -= 4;
          i = y;
        }
        y = i << 2;
        if (y !== 0) {
          n -= 2;
          i = y;
        }
        return n - (i << 1 >>> 31);
      }
      static numberOfLeadingZeros(i) {
        if (i === 0) {
          return 32;
        }
        let n = 1;
        if (i >>> 16 === 0) {
          n += 16;
          i <<= 16;
        }
        if (i >>> 24 === 0) {
          n += 8;
          i <<= 8;
        }
        if (i >>> 28 === 0) {
          n += 4;
          i <<= 4;
        }
        if (i >>> 30 === 0) {
          n += 2;
          i <<= 2;
        }
        n -= i >>> 31;
        return n;
      }
      static toHexString(i) {
        return i.toString(16);
      }
      static toBinaryString(intNumber) {
        return String(parseInt(String(intNumber), 2));
      }
      // Returns the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count.
      // Returns:
      // the number of one-bits in the two's complement binary representation of the specified int value.
      static bitCount(i) {
        i = i - (i >>> 1 & 1431655765);
        i = (i & 858993459) + (i >>> 2 & 858993459);
        i = i + (i >>> 4) & 252645135;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 63;
      }
      static truncDivision(dividend, divisor) {
        return Math.trunc(dividend / divisor);
      }
      /**
       * Converts A string to an integer.
       * @param s A string to convert into a number.
       * @param radix A value between 2 and 36 that specifies the base of the number in numString. If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal. All other strings are considered decimal.
       */
      static parseInt(num, radix = void 0) {
        return parseInt(num, radix);
      }
    }
    Integer.MIN_VALUE_32_BITS = -2147483648;
    Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;
    class BitArray {
      // For testing only
      constructor(size, bits) {
        if (void 0 === size) {
          this.size = 0;
          this.bits = new Int32Array(1);
        } else {
          this.size = size;
          if (void 0 === bits || null === bits) {
            this.bits = BitArray.makeArray(size);
          } else {
            this.bits = bits;
          }
        }
      }
      getSize() {
        return this.size;
      }
      getSizeInBytes() {
        return Math.floor((this.size + 7) / 8);
      }
      ensureCapacity(size) {
        if (size > this.bits.length * 32) {
          const newBits2 = BitArray.makeArray(size);
          System.arraycopy(this.bits, 0, newBits2, 0, this.bits.length);
          this.bits = newBits2;
        }
      }
      /**
       * @param i bit to get
       * @return true iff bit i is set
       */
      get(i) {
        return (this.bits[Math.floor(i / 32)] & 1 << (i & 31)) !== 0;
      }
      /**
       * Sets bit i.
       *
       * @param i bit to set
       */
      set(i) {
        this.bits[Math.floor(i / 32)] |= 1 << (i & 31);
      }
      /**
       * Flips bit i.
       *
       * @param i bit to set
       */
      flip(i) {
        this.bits[Math.floor(i / 32)] ^= 1 << (i & 31);
      }
      /**
       * @param from first bit to check
       * @return index of first bit that is set, starting from the given index, or size if none are set
       *  at or beyond this given index
       * @see #getNextUnset(int)
       */
      getNextSet(from) {
        const size = this.size;
        if (from >= size) {
          return size;
        }
        const bits = this.bits;
        let bitsOffset = Math.floor(from / 32);
        let currentBits = bits[bitsOffset];
        currentBits &= ~((1 << (from & 31)) - 1);
        const length = bits.length;
        while (currentBits === 0) {
          if (++bitsOffset === length) {
            return size;
          }
          currentBits = bits[bitsOffset];
        }
        const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);
        return result > size ? size : result;
      }
      /**
       * @param from index to start looking for unset bit
       * @return index of next unset bit, or {@code size} if none are unset until the end
       * @see #getNextSet(int)
       */
      getNextUnset(from) {
        const size = this.size;
        if (from >= size) {
          return size;
        }
        const bits = this.bits;
        let bitsOffset = Math.floor(from / 32);
        let currentBits = ~bits[bitsOffset];
        currentBits &= ~((1 << (from & 31)) - 1);
        const length = bits.length;
        while (currentBits === 0) {
          if (++bitsOffset === length) {
            return size;
          }
          currentBits = ~bits[bitsOffset];
        }
        const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);
        return result > size ? size : result;
      }
      /**
       * Sets a block of 32 bits, starting at bit i.
       *
       * @param i first bit to set
       * @param newBits the new value of the next 32 bits. Note again that the least-significant bit
       * corresponds to bit i, the next-least-significant to i+1, and so on.
       */
      setBulk(i, newBits2) {
        this.bits[Math.floor(i / 32)] = newBits2;
      }
      /**
       * Sets a range of bits.
       *
       * @param start start of range, inclusive.
       * @param end end of range, exclusive
       */
      setRange(start, end) {
        if (end < start || start < 0 || end > this.size) {
          throw new IllegalArgumentException();
        }
        if (end === start) {
          return;
        }
        end--;
        const firstInt = Math.floor(start / 32);
        const lastInt = Math.floor(end / 32);
        const bits = this.bits;
        for (let i = firstInt; i <= lastInt; i++) {
          const firstBit = i > firstInt ? 0 : start & 31;
          const lastBit = i < lastInt ? 31 : end & 31;
          const mask2 = (2 << lastBit) - (1 << firstBit);
          bits[i] |= mask2;
        }
      }
      /**
       * Clears all bits (sets to false).
       */
      clear() {
        const max = this.bits.length;
        const bits = this.bits;
        for (let i = 0; i < max; i++) {
          bits[i] = 0;
        }
      }
      /**
       * Efficient method to check if a range of bits is set, or not set.
       *
       * @param start start of range, inclusive.
       * @param end end of range, exclusive
       * @param value if true, checks that bits in range are set, otherwise checks that they are not set
       * 
       * @return true iff all bits are set or not set in range, according to value argument
       * @throws IllegalArgumentException if end is less than start or the range is not contained in the array
       */
      isRange(start, end, value) {
        if (end < start || start < 0 || end > this.size) {
          throw new IllegalArgumentException();
        }
        if (end === start) {
          return true;
        }
        end--;
        const firstInt = Math.floor(start / 32);
        const lastInt = Math.floor(end / 32);
        const bits = this.bits;
        for (let i = firstInt; i <= lastInt; i++) {
          const firstBit = i > firstInt ? 0 : start & 31;
          const lastBit = i < lastInt ? 31 : end & 31;
          const mask2 = (2 << lastBit) - (1 << firstBit) & 4294967295;
          if ((bits[i] & mask2) !== (value ? mask2 : 0)) {
            return false;
          }
        }
        return true;
      }
      appendBit(bit) {
        this.ensureCapacity(this.size + 1);
        if (bit) {
          this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 31);
        }
        this.size++;
      }
      /**
       * Appends the least-significant bits, from value, in order from most-significant to
       * least-significant. For example, appending 6 bits from 0x000001E will append the bits
       * 0, 1, 1, 1, 1, 0 in that order.
       *
       * @param value {@code int} containing bits to append
       * @param numBits bits from value to append
       */
      appendBits(value, numBits) {
        if (numBits < 0 || numBits > 32) {
          throw new IllegalArgumentException("Num bits must be between 0 and 32");
        }
        this.ensureCapacity(this.size + numBits);
        for (let numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
          this.appendBit((value >> numBitsLeft - 1 & 1) === 1);
        }
      }
      appendBitArray(other) {
        const otherSize = other.size;
        this.ensureCapacity(this.size + otherSize);
        for (let i = 0; i < otherSize; i++) {
          this.appendBit(other.get(i));
        }
      }
      xor(other) {
        if (this.size !== other.size) {
          throw new IllegalArgumentException("Sizes don't match");
        }
        const bits = this.bits;
        for (let i = 0, length = bits.length; i < length; i++) {
          bits[i] ^= other.bits[i];
        }
      }
      /**
       *
       * @param bitOffset first bit to start writing
       * @param array array to write into. Bytes are written most-significant byte first. This is the opposite
       *  of the internal representation, which is exposed by {@link #getBitArray()}
       * @param offset position in array to start writing
       * @param numBytes how many bytes to write
       */
      toBytes(bitOffset, array, offset, numBytes) {
        for (let i = 0; i < numBytes; i++) {
          let theByte = 0;
          for (let j = 0; j < 8; j++) {
            if (this.get(bitOffset)) {
              theByte |= 1 << 7 - j;
            }
            bitOffset++;
          }
          array[offset + i] = /*(byte)*/
          theByte;
        }
      }
      /**
       * @return underlying array of ints. The first element holds the first 32 bits, and the least
       *         significant bit is bit 0.
       */
      getBitArray() {
        return this.bits;
      }
      /**
       * Reverses all bits in the array.
       */
      reverse() {
        const newBits2 = new Int32Array(this.bits.length);
        const len = Math.floor((this.size - 1) / 32);
        const oldBitsLen = len + 1;
        const bits = this.bits;
        for (let i = 0; i < oldBitsLen; i++) {
          let x = bits[i];
          x = x >> 1 & 1431655765 | (x & 1431655765) << 1;
          x = x >> 2 & 858993459 | (x & 858993459) << 2;
          x = x >> 4 & 252645135 | (x & 252645135) << 4;
          x = x >> 8 & 16711935 | (x & 16711935) << 8;
          x = x >> 16 & 65535 | (x & 65535) << 16;
          newBits2[len - i] = /*(int)*/
          x;
        }
        if (this.size !== oldBitsLen * 32) {
          const leftOffset = oldBitsLen * 32 - this.size;
          let currentInt = newBits2[0] >>> leftOffset;
          for (let i = 1; i < oldBitsLen; i++) {
            const nextInt = newBits2[i];
            currentInt |= nextInt << 32 - leftOffset;
            newBits2[i - 1] = currentInt;
            currentInt = nextInt >>> leftOffset;
          }
          newBits2[oldBitsLen - 1] = currentInt;
        }
        this.bits = newBits2;
      }
      static makeArray(size) {
        return new Int32Array(Math.floor((size + 31) / 32));
      }
      /*@Override*/
      equals(o) {
        if (!(o instanceof BitArray)) {
          return false;
        }
        const other = o;
        return this.size === other.size && Arrays.equals(this.bits, other.bits);
      }
      /*@Override*/
      hashCode() {
        return 31 * this.size + Arrays.hashCode(this.bits);
      }
      /*@Override*/
      toString() {
        let result = "";
        for (let i = 0, size = this.size; i < size; i++) {
          if ((i & 7) === 0) {
            result += " ";
          }
          result += this.get(i) ? "X" : ".";
        }
        return result;
      }
      /*@Override*/
      clone() {
        return new BitArray(this.size, this.bits.slice());
      }
    }
    var DecodeHintType;
    (function(DecodeHintType2) {
      DecodeHintType2[DecodeHintType2["OTHER"] = 0] = "OTHER";
      DecodeHintType2[DecodeHintType2["PURE_BARCODE"] = 1] = "PURE_BARCODE";
      DecodeHintType2[DecodeHintType2["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS";
      DecodeHintType2[DecodeHintType2["TRY_HARDER"] = 3] = "TRY_HARDER";
      DecodeHintType2[DecodeHintType2["CHARACTER_SET"] = 4] = "CHARACTER_SET";
      DecodeHintType2[DecodeHintType2["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS";
      DecodeHintType2[DecodeHintType2["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT";
      DecodeHintType2[DecodeHintType2["ASSUME_GS1"] = 7] = "ASSUME_GS1";
      DecodeHintType2[DecodeHintType2["RETURN_CODABAR_START_END"] = 8] = "RETURN_CODABAR_START_END";
      DecodeHintType2[DecodeHintType2["NEED_RESULT_POINT_CALLBACK"] = 9] = "NEED_RESULT_POINT_CALLBACK";
      DecodeHintType2[DecodeHintType2["ALLOWED_EAN_EXTENSIONS"] = 10] = "ALLOWED_EAN_EXTENSIONS";
    })(DecodeHintType || (DecodeHintType = {}));
    var DecodeHintType$1 = DecodeHintType;
    class FormatException extends Exception {
      static getFormatInstance() {
        return new FormatException();
      }
    }
    FormatException.kind = "FormatException";
    var CharacterSetValueIdentifiers;
    (function(CharacterSetValueIdentifiers2) {
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp437"] = 0] = "Cp437";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_1"] = 1] = "ISO8859_1";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_2"] = 2] = "ISO8859_2";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_3"] = 3] = "ISO8859_3";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_4"] = 4] = "ISO8859_4";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_5"] = 5] = "ISO8859_5";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_6"] = 6] = "ISO8859_6";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_7"] = 7] = "ISO8859_7";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_8"] = 8] = "ISO8859_8";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_9"] = 9] = "ISO8859_9";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_10"] = 10] = "ISO8859_10";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_11"] = 11] = "ISO8859_11";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_13"] = 12] = "ISO8859_13";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_14"] = 13] = "ISO8859_14";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_15"] = 14] = "ISO8859_15";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_16"] = 15] = "ISO8859_16";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["SJIS"] = 16] = "SJIS";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1250"] = 17] = "Cp1250";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1251"] = 18] = "Cp1251";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1252"] = 19] = "Cp1252";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1256"] = 20] = "Cp1256";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UTF8"] = 22] = "UTF8";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ASCII"] = 23] = "ASCII";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Big5"] = 24] = "Big5";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["GB18030"] = 25] = "GB18030";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["EUC_KR"] = 26] = "EUC_KR";
    })(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));
    class CharacterSetECI {
      constructor(valueIdentifier, valuesParam, name2, ...otherEncodingNames) {
        this.valueIdentifier = valueIdentifier;
        this.name = name2;
        if (typeof valuesParam === "number") {
          this.values = Int32Array.from([valuesParam]);
        } else {
          this.values = valuesParam;
        }
        this.otherEncodingNames = otherEncodingNames;
        CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
        CharacterSetECI.NAME_TO_ECI.set(name2, this);
        const values = this.values;
        for (let i = 0, length = values.length; i !== length; i++) {
          const v = values[i];
          CharacterSetECI.VALUES_TO_ECI.set(v, this);
        }
        for (const otherName of otherEncodingNames) {
          CharacterSetECI.NAME_TO_ECI.set(otherName, this);
        }
      }
      // CharacterSetECI(value: number /*int*/) {
      //   this(new Int32Array {value})
      // }
      // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {
      //   this.values = new Int32Array {value}
      //   this.otherEncodingNames = otherEncodingNames
      // }
      // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {
      //   this.values = values
      //   this.otherEncodingNames = otherEncodingNames
      // }
      getValueIdentifier() {
        return this.valueIdentifier;
      }
      getName() {
        return this.name;
      }
      getValue() {
        return this.values[0];
      }
      /**
       * @param value character set ECI value
       * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but
       *   unsupported
       * @throws FormatException if ECI value is invalid
       */
      static getCharacterSetECIByValue(value) {
        if (value < 0 || value >= 900) {
          throw new FormatException("incorect value");
        }
        const characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);
        if (void 0 === characterSet) {
          throw new FormatException("incorect value");
        }
        return characterSet;
      }
      /**
       * @param name character set ECI encoding name
       * @return CharacterSetECI representing ECI for character encoding, or null if it is legal
       *   but unsupported
       */
      static getCharacterSetECIByName(name2) {
        const characterSet = CharacterSetECI.NAME_TO_ECI.get(name2);
        if (void 0 === characterSet) {
          throw new FormatException("incorect value");
        }
        return characterSet;
      }
      equals(o) {
        if (!(o instanceof CharacterSetECI)) {
          return false;
        }
        const other = o;
        return this.getName() === other.getName();
      }
    }
    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = /* @__PURE__ */ new Map();
    CharacterSetECI.VALUES_TO_ECI = /* @__PURE__ */ new Map();
    CharacterSetECI.NAME_TO_ECI = /* @__PURE__ */ new Map();
    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), "Cp437");
    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), "ISO-8859-1", "ISO88591", "ISO8859_1");
    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, "ISO-8859-2", "ISO88592", "ISO8859_2");
    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, "ISO-8859-3", "ISO88593", "ISO8859_3");
    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, "ISO-8859-4", "ISO88594", "ISO8859_4");
    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, "ISO-8859-5", "ISO88595", "ISO8859_5");
    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, "ISO-8859-6", "ISO88596", "ISO8859_6");
    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, "ISO-8859-7", "ISO88597", "ISO8859_7");
    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, "ISO-8859-8", "ISO88598", "ISO8859_8");
    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, "ISO-8859-9", "ISO88599", "ISO8859_9");
    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, "ISO-8859-10", "ISO885910", "ISO8859_10");
    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, "ISO-8859-11", "ISO885911", "ISO8859_11");
    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, "ISO-8859-13", "ISO885913", "ISO8859_13");
    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, "ISO-8859-14", "ISO885914", "ISO8859_14");
    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, "ISO-8859-15", "ISO885915", "ISO8859_15");
    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, "ISO-8859-16", "ISO885916", "ISO8859_16");
    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, "SJIS", "Shift_JIS");
    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, "Cp1250", "windows-1250");
    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, "Cp1251", "windows-1251");
    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, "Cp1252", "windows-1252");
    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, "Cp1256", "windows-1256");
    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, "UnicodeBigUnmarked", "UTF-16BE", "UnicodeBig");
    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, "UTF8", "UTF-8");
    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), "ASCII", "US-ASCII");
    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, "Big5");
    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, "GB18030", "GB2312", "EUC_CN", "GBK");
    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, "EUC_KR", "EUC-KR");
    class UnsupportedOperationException extends Exception {
    }
    UnsupportedOperationException.kind = "UnsupportedOperationException";
    class StringEncoding {
      /**
       * Decodes some Uint8Array to a string format.
       */
      static decode(bytes2, encoding) {
        const encodingName = this.encodingName(encoding);
        if (this.customDecoder) {
          return this.customDecoder(bytes2, encodingName);
        }
        if (typeof TextDecoder === "undefined" || this.shouldDecodeOnFallback(encodingName)) {
          return this.decodeFallback(bytes2, encodingName);
        }
        return new TextDecoder(encodingName).decode(bytes2);
      }
      /**
       * Checks if the decoding method should use the fallback for decoding
       * once Node TextDecoder doesn't support all encoding formats.
       *
       * @param encodingName
       */
      static shouldDecodeOnFallback(encodingName) {
        return !StringEncoding.isBrowser() && encodingName === "ISO-8859-1";
      }
      /**
       * Encodes some string into a Uint8Array.
       */
      static encode(s, encoding) {
        const encodingName = this.encodingName(encoding);
        if (this.customEncoder) {
          return this.customEncoder(s, encodingName);
        }
        if (typeof TextEncoder === "undefined") {
          return this.encodeFallback(s);
        }
        return new TextEncoder().encode(s);
      }
      static isBrowser() {
        return typeof window !== "undefined" && {}.toString.call(window) === "[object Window]";
      }
      /**
       * Returns the string value from some encoding character set.
       */
      static encodingName(encoding) {
        return typeof encoding === "string" ? encoding : encoding.getName();
      }
      /**
       * Returns character set from some encoding character set.
       */
      static encodingCharacterSet(encoding) {
        if (encoding instanceof CharacterSetECI) {
          return encoding;
        }
        return CharacterSetECI.getCharacterSetECIByName(encoding);
      }
      /**
       * Runs a fallback for the native decoding funcion.
       */
      static decodeFallback(bytes2, encoding) {
        const characterSet = this.encodingCharacterSet(encoding);
        if (StringEncoding.isDecodeFallbackSupported(characterSet)) {
          let s = "";
          for (let i = 0, length = bytes2.length; i < length; i++) {
            let h = bytes2[i].toString(16);
            if (h.length < 2) {
              h = "0" + h;
            }
            s += "%" + h;
          }
          return decodeURIComponent(s);
        }
        if (characterSet.equals(CharacterSetECI.UnicodeBigUnmarked)) {
          return String.fromCharCode.apply(null, new Uint16Array(bytes2.buffer));
        }
        throw new UnsupportedOperationException(`Encoding ${this.encodingName(encoding)} not supported by fallback.`);
      }
      static isDecodeFallbackSupported(characterSet) {
        return characterSet.equals(CharacterSetECI.UTF8) || characterSet.equals(CharacterSetECI.ISO8859_1) || characterSet.equals(CharacterSetECI.ASCII);
      }
      /**
       * Runs a fallback for the native encoding funcion.
       *
       * @see https://stackoverflow.com/a/17192845/4367683
       */
      static encodeFallback(s) {
        const encodedURIstring = btoa(unescape(encodeURIComponent(s)));
        const charList = encodedURIstring.split("");
        const uintArray = [];
        for (let i = 0; i < charList.length; i++) {
          uintArray.push(charList[i].charCodeAt(0));
        }
        return new Uint8Array(uintArray);
      }
    }
    class StringUtils {
      // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||
      // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);
      static castAsNonUtf8Char(code, encoding = null) {
        const e = encoding ? encoding.getName() : this.ISO88591;
        return StringEncoding.decode(new Uint8Array([code]), e);
      }
      /**
       * @param bytes bytes encoding a string, whose encoding should be guessed
       * @param hints decode hints if applicable
       * @return name of guessed encoding; at the moment will only guess one of:
       *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform
       *  default encoding if none of these can possibly be correct
       */
      static guessEncoding(bytes2, hints) {
        if (hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.CHARACTER_SET)) {
          return hints.get(DecodeHintType$1.CHARACTER_SET).toString();
        }
        const length = bytes2.length;
        let canBeISO88591 = true;
        let canBeShiftJIS = true;
        let canBeUTF8 = true;
        let utf8BytesLeft = 0;
        let utf2BytesChars = 0;
        let utf3BytesChars = 0;
        let utf4BytesChars = 0;
        let sjisBytesLeft = 0;
        let sjisKatakanaChars = 0;
        let sjisCurKatakanaWordLength = 0;
        let sjisCurDoubleBytesWordLength = 0;
        let sjisMaxKatakanaWordLength = 0;
        let sjisMaxDoubleBytesWordLength = 0;
        let isoHighOther = 0;
        const utf8bom = bytes2.length > 3 && bytes2[0] === /*(byte) */
        239 && bytes2[1] === /*(byte) */
        187 && bytes2[2] === /*(byte) */
        191;
        for (let i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {
          const value = bytes2[i] & 255;
          if (canBeUTF8) {
            if (utf8BytesLeft > 0) {
              if ((value & 128) === 0) {
                canBeUTF8 = false;
              } else {
                utf8BytesLeft--;
              }
            } else if ((value & 128) !== 0) {
              if ((value & 64) === 0) {
                canBeUTF8 = false;
              } else {
                utf8BytesLeft++;
                if ((value & 32) === 0) {
                  utf2BytesChars++;
                } else {
                  utf8BytesLeft++;
                  if ((value & 16) === 0) {
                    utf3BytesChars++;
                  } else {
                    utf8BytesLeft++;
                    if ((value & 8) === 0) {
                      utf4BytesChars++;
                    } else {
                      canBeUTF8 = false;
                    }
                  }
                }
              }
            }
          }
          if (canBeISO88591) {
            if (value > 127 && value < 160) {
              canBeISO88591 = false;
            } else if (value > 159) {
              if (value < 192 || value === 215 || value === 247) {
                isoHighOther++;
              }
            }
          }
          if (canBeShiftJIS) {
            if (sjisBytesLeft > 0) {
              if (value < 64 || value === 127 || value > 252) {
                canBeShiftJIS = false;
              } else {
                sjisBytesLeft--;
              }
            } else if (value === 128 || value === 160 || value > 239) {
              canBeShiftJIS = false;
            } else if (value > 160 && value < 224) {
              sjisKatakanaChars++;
              sjisCurDoubleBytesWordLength = 0;
              sjisCurKatakanaWordLength++;
              if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
                sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
              }
            } else if (value > 127) {
              sjisBytesLeft++;
              sjisCurKatakanaWordLength = 0;
              sjisCurDoubleBytesWordLength++;
              if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
                sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
              }
            } else {
              sjisCurKatakanaWordLength = 0;
              sjisCurDoubleBytesWordLength = 0;
            }
          }
        }
        if (canBeUTF8 && utf8BytesLeft > 0) {
          canBeUTF8 = false;
        }
        if (canBeShiftJIS && sjisBytesLeft > 0) {
          canBeShiftJIS = false;
        }
        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
          return StringUtils.UTF8;
        }
        if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
          return StringUtils.SHIFT_JIS;
        }
        if (canBeISO88591 && canBeShiftJIS) {
          return sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2 || isoHighOther * 10 >= length ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;
        }
        if (canBeISO88591) {
          return StringUtils.ISO88591;
        }
        if (canBeShiftJIS) {
          return StringUtils.SHIFT_JIS;
        }
        if (canBeUTF8) {
          return StringUtils.UTF8;
        }
        return StringUtils.PLATFORM_DEFAULT_ENCODING;
      }
      /**
       *
       * @see https://stackoverflow.com/a/13439711/4367683
       *
       * @param append The new string to append.
       * @param args Argumets values to be formated.
       */
      static format(append, ...args) {
        let i = -1;
        function callback(exp, p0, p1, p2, p3, p4) {
          if (exp === "%%")
            return "%";
          if (args[++i] === void 0)
            return void 0;
          exp = p2 ? parseInt(p2.substr(1)) : void 0;
          let base2 = p3 ? parseInt(p3.substr(1)) : void 0;
          let val;
          switch (p4) {
            case "s":
              val = args[i];
              break;
            case "c":
              val = args[i][0];
              break;
            case "f":
              val = parseFloat(args[i]).toFixed(exp);
              break;
            case "p":
              val = parseFloat(args[i]).toPrecision(exp);
              break;
            case "e":
              val = parseFloat(args[i]).toExponential(exp);
              break;
            case "x":
              val = parseInt(args[i]).toString(base2 ? base2 : 16);
              break;
            case "d":
              val = parseFloat(parseInt(args[i], base2 ? base2 : 10).toPrecision(exp)).toFixed(0);
              break;
          }
          val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base2);
          let size = parseInt(p1);
          let ch = p1 && p1[0] + "" === "0" ? "0" : " ";
          while (val.length < size)
            val = p0 !== void 0 ? val + ch : ch + val;
          return val;
        }
        let regex2 = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
        return append.replace(regex2, callback);
      }
      /**
       *
       */
      static getBytes(str, encoding) {
        return StringEncoding.encode(str, encoding);
      }
      /**
       * Returns the charcode at the specified index or at index zero.
       */
      static getCharCode(str, index2 = 0) {
        return str.charCodeAt(index2);
      }
      /**
       * Returns char for given charcode
       */
      static getCharAt(charCode) {
        return String.fromCharCode(charCode);
      }
    }
    StringUtils.SHIFT_JIS = CharacterSetECI.SJIS.getName();
    StringUtils.GB2312 = "GB2312";
    StringUtils.ISO88591 = CharacterSetECI.ISO8859_1.getName();
    StringUtils.EUC_JP = "EUC_JP";
    StringUtils.UTF8 = CharacterSetECI.UTF8.getName();
    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8;
    StringUtils.ASSUME_SHIFT_JIS = false;
    class StringBuilder {
      constructor(value = "") {
        this.value = value;
      }
      enableDecoding(encoding) {
        this.encoding = encoding;
        return this;
      }
      append(s) {
        if (typeof s === "string") {
          this.value += s.toString();
        } else if (this.encoding) {
          this.value += StringUtils.castAsNonUtf8Char(s, this.encoding);
        } else {
          this.value += String.fromCharCode(s);
        }
        return this;
      }
      appendChars(str, offset, len) {
        for (let i = offset; offset < offset + len; i++) {
          this.append(str[i]);
        }
        return this;
      }
      length() {
        return this.value.length;
      }
      charAt(n) {
        return this.value.charAt(n);
      }
      deleteCharAt(n) {
        this.value = this.value.substr(0, n) + this.value.substring(n + 1);
      }
      setCharAt(n, c) {
        this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);
      }
      substring(start, end) {
        return this.value.substring(start, end);
      }
      /**
       * @note helper method for RSS Expanded
       */
      setLengthToZero() {
        this.value = "";
      }
      toString() {
        return this.value;
      }
      insert(n, c) {
        this.value = this.value.substr(0, n) + c + this.value.substr(n + c.length);
      }
    }
    class BitMatrix {
      /**
       * Creates an empty square {@link BitMatrix}.
       *
       * @param dimension height and width
       */
      // public constructor(dimension: number /*int*/) {
      //   this(dimension, dimension)
      // }
      /**
       * Creates an empty {@link BitMatrix}.
       *
       * @param width bit matrix width
       * @param height bit matrix height
       */
      // public constructor(width: number /*int*/, height: number /*int*/) {
      //   if (width < 1 || height < 1) {
      //     throw new IllegalArgumentException("Both dimensions must be greater than 0")
      //   }
      //   this.width = width
      //   this.height = height
      //   this.rowSize = (width + 31) / 32
      //   bits = new int[rowSize * height];
      // }
      constructor(width, height, rowSize, bits) {
        this.width = width;
        this.height = height;
        this.rowSize = rowSize;
        this.bits = bits;
        if (void 0 === height || null === height) {
          height = width;
        }
        this.height = height;
        if (width < 1 || height < 1) {
          throw new IllegalArgumentException("Both dimensions must be greater than 0");
        }
        if (void 0 === rowSize || null === rowSize) {
          rowSize = Math.floor((width + 31) / 32);
        }
        this.rowSize = rowSize;
        if (void 0 === bits || null === bits) {
          this.bits = new Int32Array(this.rowSize * this.height);
        }
      }
      /**
       * Interprets a 2D array of booleans as a {@link BitMatrix}, where "true" means an "on" bit.
       *
       * @function parse
       * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows
       * @return {@link BitMatrix} representation of image
       */
      static parseFromBooleanArray(image) {
        const height = image.length;
        const width = image[0].length;
        const bits = new BitMatrix(width, height);
        for (let i = 0; i < height; i++) {
          const imageI = image[i];
          for (let j = 0; j < width; j++) {
            if (imageI[j]) {
              bits.set(j, i);
            }
          }
        }
        return bits;
      }
      /**
       *
       * @function parse
       * @param stringRepresentation
       * @param setString
       * @param unsetString
       */
      static parseFromString(stringRepresentation, setString, unsetString) {
        if (stringRepresentation === null) {
          throw new IllegalArgumentException("stringRepresentation cannot be null");
        }
        const bits = new Array(stringRepresentation.length);
        let bitsPos = 0;
        let rowStartPos = 0;
        let rowLength = -1;
        let nRows = 0;
        let pos = 0;
        while (pos < stringRepresentation.length) {
          if (stringRepresentation.charAt(pos) === "\n" || stringRepresentation.charAt(pos) === "\r") {
            if (bitsPos > rowStartPos) {
              if (rowLength === -1) {
                rowLength = bitsPos - rowStartPos;
              } else if (bitsPos - rowStartPos !== rowLength) {
                throw new IllegalArgumentException("row lengths do not match");
              }
              rowStartPos = bitsPos;
              nRows++;
            }
            pos++;
          } else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
            pos += setString.length;
            bits[bitsPos] = true;
            bitsPos++;
          } else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
            pos += unsetString.length;
            bits[bitsPos] = false;
            bitsPos++;
          } else {
            throw new IllegalArgumentException("illegal character encountered: " + stringRepresentation.substring(pos));
          }
        }
        if (bitsPos > rowStartPos) {
          if (rowLength === -1) {
            rowLength = bitsPos - rowStartPos;
          } else if (bitsPos - rowStartPos !== rowLength) {
            throw new IllegalArgumentException("row lengths do not match");
          }
          nRows++;
        }
        const matrix = new BitMatrix(rowLength, nRows);
        for (let i = 0; i < bitsPos; i++) {
          if (bits[i]) {
            matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));
          }
        }
        return matrix;
      }
      /**
       * <p>Gets the requested bit, where true means black.</p>
       *
       * @param x The horizontal component (i.e. which column)
       * @param y The vertical component (i.e. which row)
       * @return value of given bit in matrix
       */
      get(x, y) {
        const offset = y * this.rowSize + Math.floor(x / 32);
        return (this.bits[offset] >>> (x & 31) & 1) !== 0;
      }
      /**
       * <p>Sets the given bit to true.</p>
       *
       * @param x The horizontal component (i.e. which column)
       * @param y The vertical component (i.e. which row)
       */
      set(x, y) {
        const offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] |= 1 << (x & 31) & 4294967295;
      }
      unset(x, y) {
        const offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] &= ~(1 << (x & 31) & 4294967295);
      }
      /**
       * <p>Flips the given bit.</p>
       *
       * @param x The horizontal component (i.e. which column)
       * @param y The vertical component (i.e. which row)
       */
      flip(x, y) {
        const offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] ^= 1 << (x & 31) & 4294967295;
      }
      /**
       * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding
       * mask bit is set.
       *
       * @param mask XOR mask
       */
      xor(mask2) {
        if (this.width !== mask2.getWidth() || this.height !== mask2.getHeight() || this.rowSize !== mask2.getRowSize()) {
          throw new IllegalArgumentException("input matrix dimensions do not match");
        }
        const rowArray = new BitArray(Math.floor(this.width / 32) + 1);
        const rowSize = this.rowSize;
        const bits = this.bits;
        for (let y = 0, height = this.height; y < height; y++) {
          const offset = y * rowSize;
          const row = mask2.getRow(y, rowArray).getBitArray();
          for (let x = 0; x < rowSize; x++) {
            bits[offset + x] ^= row[x];
          }
        }
      }
      /**
       * Clears all bits (sets to false).
       */
      clear() {
        const bits = this.bits;
        const max = bits.length;
        for (let i = 0; i < max; i++) {
          bits[i] = 0;
        }
      }
      /**
       * <p>Sets a square region of the bit matrix to true.</p>
       *
       * @param left The horizontal position to begin at (inclusive)
       * @param top The vertical position to begin at (inclusive)
       * @param width The width of the region
       * @param height The height of the region
       */
      setRegion(left, top, width, height) {
        if (top < 0 || left < 0) {
          throw new IllegalArgumentException("Left and top must be nonnegative");
        }
        if (height < 1 || width < 1) {
          throw new IllegalArgumentException("Height and width must be at least 1");
        }
        const right = left + width;
        const bottom = top + height;
        if (bottom > this.height || right > this.width) {
          throw new IllegalArgumentException("The region must fit inside the matrix");
        }
        const rowSize = this.rowSize;
        const bits = this.bits;
        for (let y = top; y < bottom; y++) {
          const offset = y * rowSize;
          for (let x = left; x < right; x++) {
            bits[offset + Math.floor(x / 32)] |= 1 << (x & 31) & 4294967295;
          }
        }
      }
      /**
       * A fast method to retrieve one row of data from the matrix as a BitArray.
       *
       * @param y The row to retrieve
       * @param row An optional caller-allocated BitArray, will be allocated if null or too small
       * @return The resulting BitArray - this reference should always be used even when passing
       *         your own row
       */
      getRow(y, row) {
        if (row === null || row === void 0 || row.getSize() < this.width) {
          row = new BitArray(this.width);
        } else {
          row.clear();
        }
        const rowSize = this.rowSize;
        const bits = this.bits;
        const offset = y * rowSize;
        for (let x = 0; x < rowSize; x++) {
          row.setBulk(x * 32, bits[offset + x]);
        }
        return row;
      }
      /**
       * @param y row to set
       * @param row {@link BitArray} to copy from
       */
      setRow(y, row) {
        System.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);
      }
      /**
       * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees
       */
      rotate180() {
        const width = this.getWidth();
        const height = this.getHeight();
        let topRow = new BitArray(width);
        let bottomRow = new BitArray(width);
        for (let i = 0, length = Math.floor((height + 1) / 2); i < length; i++) {
          topRow = this.getRow(i, topRow);
          bottomRow = this.getRow(height - 1 - i, bottomRow);
          topRow.reverse();
          bottomRow.reverse();
          this.setRow(i, bottomRow);
          this.setRow(height - 1 - i, topRow);
        }
      }
      /**
       * This is useful in detecting the enclosing rectangle of a 'pure' barcode.
       *
       * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white
       */
      getEnclosingRectangle() {
        const width = this.width;
        const height = this.height;
        const rowSize = this.rowSize;
        const bits = this.bits;
        let left = width;
        let top = height;
        let right = -1;
        let bottom = -1;
        for (let y = 0; y < height; y++) {
          for (let x32 = 0; x32 < rowSize; x32++) {
            const theBits = bits[y * rowSize + x32];
            if (theBits !== 0) {
              if (y < top) {
                top = y;
              }
              if (y > bottom) {
                bottom = y;
              }
              if (x32 * 32 < left) {
                let bit = 0;
                while ((theBits << 31 - bit & 4294967295) === 0) {
                  bit++;
                }
                if (x32 * 32 + bit < left) {
                  left = x32 * 32 + bit;
                }
              }
              if (x32 * 32 + 31 > right) {
                let bit = 31;
                while (theBits >>> bit === 0) {
                  bit--;
                }
                if (x32 * 32 + bit > right) {
                  right = x32 * 32 + bit;
                }
              }
            }
          }
        }
        if (right < left || bottom < top) {
          return null;
        }
        return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);
      }
      /**
       * This is useful in detecting a corner of a 'pure' barcode.
       *
       * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white
       */
      getTopLeftOnBit() {
        const rowSize = this.rowSize;
        const bits = this.bits;
        let bitsOffset = 0;
        while (bitsOffset < bits.length && bits[bitsOffset] === 0) {
          bitsOffset++;
        }
        if (bitsOffset === bits.length) {
          return null;
        }
        const y = bitsOffset / rowSize;
        let x = bitsOffset % rowSize * 32;
        const theBits = bits[bitsOffset];
        let bit = 0;
        while ((theBits << 31 - bit & 4294967295) === 0) {
          bit++;
        }
        x += bit;
        return Int32Array.from([x, y]);
      }
      getBottomRightOnBit() {
        const rowSize = this.rowSize;
        const bits = this.bits;
        let bitsOffset = bits.length - 1;
        while (bitsOffset >= 0 && bits[bitsOffset] === 0) {
          bitsOffset--;
        }
        if (bitsOffset < 0) {
          return null;
        }
        const y = Math.floor(bitsOffset / rowSize);
        let x = Math.floor(bitsOffset % rowSize) * 32;
        const theBits = bits[bitsOffset];
        let bit = 31;
        while (theBits >>> bit === 0) {
          bit--;
        }
        x += bit;
        return Int32Array.from([x, y]);
      }
      /**
       * @return The width of the matrix
       */
      getWidth() {
        return this.width;
      }
      /**
       * @return The height of the matrix
       */
      getHeight() {
        return this.height;
      }
      /**
       * @return The row size of the matrix
       */
      getRowSize() {
        return this.rowSize;
      }
      /*@Override*/
      equals(o) {
        if (!(o instanceof BitMatrix)) {
          return false;
        }
        const other = o;
        return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize && Arrays.equals(this.bits, other.bits);
      }
      /*@Override*/
      hashCode() {
        let hash3 = this.width;
        hash3 = 31 * hash3 + this.width;
        hash3 = 31 * hash3 + this.height;
        hash3 = 31 * hash3 + this.rowSize;
        hash3 = 31 * hash3 + Arrays.hashCode(this.bits);
        return hash3;
      }
      /**
       * @return string representation using "X" for set and " " for unset bits
       */
      /*@Override*/
      // public toString(): string {
      //   return toString(": "X, "  ")
      // }
      /**
       * @param setString representation of a set bit
       * @param unsetString representation of an unset bit
       * @return string representation of entire matrix utilizing given strings
       */
      // public toString(setString: string = "X ", unsetString: string = "  "): string {
      //   return this.buildToString(setString, unsetString, "\n")
      // }
      /**
       * @param setString representation of a set bit
       * @param unsetString representation of an unset bit
       * @param lineSeparator newline character in string representation
       * @return string representation of entire matrix utilizing given strings and line separator
       * @deprecated call {@link #toString(String,String)} only, which uses \n line separator always
       */
      // @Deprecated
      toString(setString = "X ", unsetString = "  ", lineSeparator = "\n") {
        return this.buildToString(setString, unsetString, lineSeparator);
      }
      buildToString(setString, unsetString, lineSeparator) {
        let result = new StringBuilder();
        for (let y = 0, height = this.height; y < height; y++) {
          for (let x = 0, width = this.width; x < width; x++) {
            result.append(this.get(x, y) ? setString : unsetString);
          }
          result.append(lineSeparator);
        }
        return result.toString();
      }
      /*@Override*/
      clone() {
        return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());
      }
    }
    class NotFoundException extends Exception {
      static getNotFoundInstance() {
        return new NotFoundException();
      }
    }
    NotFoundException.kind = "NotFoundException";
    class GlobalHistogramBinarizer extends Binarizer {
      constructor(source) {
        super(source);
        this.luminances = GlobalHistogramBinarizer.EMPTY;
        this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);
      }
      // Applies simple sharpening to the row data to improve performance of the 1D Readers.
      /*@Override*/
      getBlackRow(y, row) {
        const source = this.getLuminanceSource();
        const width = source.getWidth();
        if (row === void 0 || row === null || row.getSize() < width) {
          row = new BitArray(width);
        } else {
          row.clear();
        }
        this.initArrays(width);
        const localLuminances = source.getRow(y, this.luminances);
        const localBuckets = this.buckets;
        for (let x = 0; x < width; x++) {
          localBuckets[(localLuminances[x] & 255) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
        }
        const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
        if (width < 3) {
          for (let x = 0; x < width; x++) {
            if ((localLuminances[x] & 255) < blackPoint) {
              row.set(x);
            }
          }
        } else {
          let left = localLuminances[0] & 255;
          let center = localLuminances[1] & 255;
          for (let x = 1; x < width - 1; x++) {
            const right = localLuminances[x + 1] & 255;
            if ((center * 4 - left - right) / 2 < blackPoint) {
              row.set(x);
            }
            left = center;
            center = right;
          }
        }
        return row;
      }
      // Does not sharpen the data, as this call is intended to only be used by 2D Readers.
      /*@Override*/
      getBlackMatrix() {
        const source = this.getLuminanceSource();
        const width = source.getWidth();
        const height = source.getHeight();
        const matrix = new BitMatrix(width, height);
        this.initArrays(width);
        const localBuckets = this.buckets;
        for (let y = 1; y < 5; y++) {
          const row = Math.floor(height * y / 5);
          const localLuminances2 = source.getRow(row, this.luminances);
          const right = Math.floor(width * 4 / 5);
          for (let x = Math.floor(width / 5); x < right; x++) {
            const pixel = localLuminances2[x] & 255;
            localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
          }
        }
        const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
        const localLuminances = source.getMatrix();
        for (let y = 0; y < height; y++) {
          const offset = y * width;
          for (let x = 0; x < width; x++) {
            const pixel = localLuminances[offset + x] & 255;
            if (pixel < blackPoint) {
              matrix.set(x, y);
            }
          }
        }
        return matrix;
      }
      /*@Override*/
      createBinarizer(source) {
        return new GlobalHistogramBinarizer(source);
      }
      initArrays(luminanceSize) {
        if (this.luminances.length < luminanceSize) {
          this.luminances = new Uint8ClampedArray(luminanceSize);
        }
        const buckets = this.buckets;
        for (let x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {
          buckets[x] = 0;
        }
      }
      static estimateBlackPoint(buckets) {
        const numBuckets = buckets.length;
        let maxBucketCount = 0;
        let firstPeak = 0;
        let firstPeakSize = 0;
        for (let x = 0; x < numBuckets; x++) {
          if (buckets[x] > firstPeakSize) {
            firstPeak = x;
            firstPeakSize = buckets[x];
          }
          if (buckets[x] > maxBucketCount) {
            maxBucketCount = buckets[x];
          }
        }
        let secondPeak = 0;
        let secondPeakScore = 0;
        for (let x = 0; x < numBuckets; x++) {
          const distanceToBiggest = x - firstPeak;
          const score = buckets[x] * distanceToBiggest * distanceToBiggest;
          if (score > secondPeakScore) {
            secondPeak = x;
            secondPeakScore = score;
          }
        }
        if (firstPeak > secondPeak) {
          const temp = firstPeak;
          firstPeak = secondPeak;
          secondPeak = temp;
        }
        if (secondPeak - firstPeak <= numBuckets / 16) {
          throw new NotFoundException();
        }
        let bestValley = secondPeak - 1;
        let bestValleyScore = -1;
        for (let x = secondPeak - 1; x > firstPeak; x--) {
          const fromFirst = x - firstPeak;
          const score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);
          if (score > bestValleyScore) {
            bestValley = x;
            bestValleyScore = score;
          }
        }
        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;
      }
    }
    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;
    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);
    class HybridBinarizer extends GlobalHistogramBinarizer {
      constructor(source) {
        super(source);
        this.matrix = null;
      }
      /**
       * Calculates the final BitMatrix once for all requests. This could be called once from the
       * constructor instead, but there are some advantages to doing it lazily, such as making
       * profiling easier, and not doing heavy lifting when callers don't expect it.
       */
      /*@Override*/
      getBlackMatrix() {
        if (this.matrix !== null) {
          return this.matrix;
        }
        const source = this.getLuminanceSource();
        const width = source.getWidth();
        const height = source.getHeight();
        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {
          const luminances = source.getMatrix();
          let subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;
          if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
            subWidth++;
          }
          let subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;
          if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
            subHeight++;
          }
          const blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
          const newMatrix = new BitMatrix(width, height);
          HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
          this.matrix = newMatrix;
        } else {
          this.matrix = super.getBlackMatrix();
        }
        return this.matrix;
      }
      /*@Override*/
      createBinarizer(source) {
        return new HybridBinarizer(source);
      }
      /**
       * For each block in the image, calculate the average black point using a 5x5 grid
       * of the blocks around it. Also handles the corner cases (fractional blocks are computed based
       * on the last pixels in the row/column which are also used in the previous block).
       */
      static calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix) {
        const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
        const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
        for (let y = 0; y < subHeight; y++) {
          let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
          if (yoffset > maxYOffset) {
            yoffset = maxYOffset;
          }
          const top = HybridBinarizer.cap(y, 2, subHeight - 3);
          for (let x = 0; x < subWidth; x++) {
            let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
            if (xoffset > maxXOffset) {
              xoffset = maxXOffset;
            }
            const left = HybridBinarizer.cap(x, 2, subWidth - 3);
            let sum = 0;
            for (let z = -2; z <= 2; z++) {
              const blackRow = blackPoints[top + z];
              sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];
            }
            const average = sum / 25;
            HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
          }
        }
      }
      static cap(value, min, max) {
        return value < min ? min : value > max ? max : value;
      }
      /**
       * Applies a single threshold to a block of pixels.
       */
      static thresholdBlock(luminances, xoffset, yoffset, threshold, stride, matrix) {
        for (let y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {
          for (let x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {
            if ((luminances[offset + x] & 255) <= threshold) {
              matrix.set(xoffset + x, yoffset + y);
            }
          }
        }
      }
      /**
       * Calculates a single black point for each block of pixels and saves it away.
       * See the following thread for a discussion of this algorithm:
       *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
       */
      static calculateBlackPoints(luminances, subWidth, subHeight, width, height) {
        const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
        const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
        const blackPoints = new Array(subHeight);
        for (let y = 0; y < subHeight; y++) {
          blackPoints[y] = new Int32Array(subWidth);
          let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
          if (yoffset > maxYOffset) {
            yoffset = maxYOffset;
          }
          for (let x = 0; x < subWidth; x++) {
            let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
            if (xoffset > maxXOffset) {
              xoffset = maxXOffset;
            }
            let sum = 0;
            let min = 255;
            let max = 0;
            for (let yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
              for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                const pixel = luminances[offset + xx] & 255;
                sum += pixel;
                if (pixel < min) {
                  min = pixel;
                }
                if (pixel > max) {
                  max = pixel;
                }
              }
              if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {
                for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
                  for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                    sum += luminances[offset + xx] & 255;
                  }
                }
              }
            }
            let average = sum >> HybridBinarizer.BLOCK_SIZE_POWER * 2;
            if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {
              average = min / 2;
              if (y > 0 && x > 0) {
                const averageNeighborBlackPoint = (blackPoints[y - 1][x] + 2 * blackPoints[y][x - 1] + blackPoints[y - 1][x - 1]) / 4;
                if (min < averageNeighborBlackPoint) {
                  average = averageNeighborBlackPoint;
                }
              }
            }
            blackPoints[y][x] = average;
          }
        }
        return blackPoints;
      }
    }
    HybridBinarizer.BLOCK_SIZE_POWER = 3;
    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER;
    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1;
    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;
    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;
    class LuminanceSource {
      constructor(width, height) {
        this.width = width;
        this.height = height;
      }
      /**
       * @return The width of the bitmap.
       */
      getWidth() {
        return this.width;
      }
      /**
       * @return The height of the bitmap.
       */
      getHeight() {
        return this.height;
      }
      /**
       * @return Whether this subclass supports cropping.
       */
      isCropSupported() {
        return false;
      }
      /**
       * Returns a new object with cropped image data. Implementations may keep a reference to the
       * original data rather than a copy. Only callable if isCropSupported() is true.
       *
       * @param left The left coordinate, which must be in [0,getWidth())
       * @param top The top coordinate, which must be in [0,getHeight())
       * @param width The width of the rectangle to crop.
       * @param height The height of the rectangle to crop.
       * @return A cropped version of this object.
       */
      crop(left, top, width, height) {
        throw new UnsupportedOperationException("This luminance source does not support cropping.");
      }
      /**
       * @return Whether this subclass supports counter-clockwise rotation.
       */
      isRotateSupported() {
        return false;
      }
      /**
       * Returns a new object with rotated image data by 90 degrees counterclockwise.
       * Only callable if {@link #isRotateSupported()} is true.
       *
       * @return A rotated version of this object.
       */
      rotateCounterClockwise() {
        throw new UnsupportedOperationException("This luminance source does not support rotation by 90 degrees.");
      }
      /**
       * Returns a new object with rotated image data by 45 degrees counterclockwise.
       * Only callable if {@link #isRotateSupported()} is true.
       *
       * @return A rotated version of this object.
       */
      rotateCounterClockwise45() {
        throw new UnsupportedOperationException("This luminance source does not support rotation by 45 degrees.");
      }
      /*@Override*/
      toString() {
        const row = new Uint8ClampedArray(this.width);
        let result = new StringBuilder();
        for (let y = 0; y < this.height; y++) {
          const sourceRow = this.getRow(y, row);
          for (let x = 0; x < this.width; x++) {
            const luminance = sourceRow[x] & 255;
            let c;
            if (luminance < 64) {
              c = "#";
            } else if (luminance < 128) {
              c = "+";
            } else if (luminance < 192) {
              c = ".";
            } else {
              c = " ";
            }
            result.append(c);
          }
          result.append("\n");
        }
        return result.toString();
      }
    }
    class InvertedLuminanceSource extends LuminanceSource {
      constructor(delegate) {
        super(delegate.getWidth(), delegate.getHeight());
        this.delegate = delegate;
      }
      /*@Override*/
      getRow(y, row) {
        const sourceRow = this.delegate.getRow(y, row);
        const width = this.getWidth();
        for (let i = 0; i < width; i++) {
          sourceRow[i] = /*(byte)*/
          255 - (sourceRow[i] & 255);
        }
        return sourceRow;
      }
      /*@Override*/
      getMatrix() {
        const matrix = this.delegate.getMatrix();
        const length = this.getWidth() * this.getHeight();
        const invertedMatrix = new Uint8ClampedArray(length);
        for (let i = 0; i < length; i++) {
          invertedMatrix[i] = /*(byte)*/
          255 - (matrix[i] & 255);
        }
        return invertedMatrix;
      }
      /*@Override*/
      isCropSupported() {
        return this.delegate.isCropSupported();
      }
      /*@Override*/
      crop(left, top, width, height) {
        return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));
      }
      /*@Override*/
      isRotateSupported() {
        return this.delegate.isRotateSupported();
      }
      /**
       * @return original delegate {@link LuminanceSource} since invert undoes itself
       */
      /*@Override*/
      invert() {
        return this.delegate;
      }
      /*@Override*/
      rotateCounterClockwise() {
        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());
      }
      /*@Override*/
      rotateCounterClockwise45() {
        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());
      }
    }
    class HTMLCanvasElementLuminanceSource extends LuminanceSource {
      constructor(canvas) {
        super(canvas.width, canvas.height);
        this.canvas = canvas;
        this.tempCanvasElement = null;
        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);
      }
      static makeBufferFromCanvasImageData(canvas) {
        const imageData = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
        return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
      }
      static toGrayscaleBuffer(imageBuffer, width, height) {
        const grayscaleBuffer = new Uint8ClampedArray(width * height);
        for (let i = 0, j = 0, length = imageBuffer.length; i < length; i += 4, j++) {
          let gray;
          const alpha = imageBuffer[i + 3];
          if (alpha === 0) {
            gray = 255;
          } else {
            const pixelR = imageBuffer[i];
            const pixelG = imageBuffer[i + 1];
            const pixelB = imageBuffer[i + 2];
            gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 512 >> 10;
          }
          grayscaleBuffer[j] = gray;
        }
        return grayscaleBuffer;
      }
      getRow(y, row) {
        if (y < 0 || y >= this.getHeight()) {
          throw new IllegalArgumentException("Requested row is outside the image: " + y);
        }
        const width = this.getWidth();
        const start = y * width;
        if (row === null) {
          row = this.buffer.slice(start, start + width);
        } else {
          if (row.length < width) {
            row = new Uint8ClampedArray(width);
          }
          row.set(this.buffer.slice(start, start + width));
        }
        return row;
      }
      getMatrix() {
        return this.buffer;
      }
      isCropSupported() {
        return true;
      }
      crop(left, top, width, height) {
        super.crop(left, top, width, height);
        return this;
      }
      /**
       * This is always true, since the image is a gray-scale image.
       *
       * @return true
       */
      isRotateSupported() {
        return true;
      }
      rotateCounterClockwise() {
        this.rotate(-90);
        return this;
      }
      rotateCounterClockwise45() {
        this.rotate(-45);
        return this;
      }
      getTempCanvasElement() {
        if (null === this.tempCanvasElement) {
          const tempCanvasElement = this.canvas.ownerDocument.createElement("canvas");
          tempCanvasElement.width = this.canvas.width;
          tempCanvasElement.height = this.canvas.height;
          this.tempCanvasElement = tempCanvasElement;
        }
        return this.tempCanvasElement;
      }
      rotate(angle) {
        const tempCanvasElement = this.getTempCanvasElement();
        const tempContext = tempCanvasElement.getContext("2d");
        const angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;
        const width = this.canvas.width;
        const height = this.canvas.height;
        const newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
        const newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
        tempCanvasElement.width = newWidth;
        tempCanvasElement.height = newHeight;
        tempContext.translate(newWidth / 2, newHeight / 2);
        tempContext.rotate(angleRadians);
        tempContext.drawImage(this.canvas, width / -2, height / -2);
        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);
        return this;
      }
      invert() {
        return new InvertedLuminanceSource(this);
      }
    }
    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;
    class VideoInputDevice {
      /**
       * Creates an instance of VideoInputDevice.
       *
       * @param {string} deviceId the video input device id
       * @param {string} label the label of the device if available
       */
      constructor(deviceId, label, groupId) {
        this.deviceId = deviceId;
        this.label = label;
        this.kind = "videoinput";
        this.groupId = groupId || void 0;
      }
      /** @inheritdoc */
      toJSON() {
        return {
          kind: this.kind,
          groupId: this.groupId,
          deviceId: this.deviceId,
          label: this.label
        };
      }
    }
    var __awaiter2 = (globalThis || commonjsGlobal || self || window || void 0) && (globalThis || commonjsGlobal || self || window || void 0).__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    class BrowserCodeReader {
      /**
       * Creates an instance of BrowserCodeReader.
       * @param {Reader} reader The reader instance to decode the barcode
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries
       *
       * @memberOf BrowserCodeReader
       */
      constructor(reader, timeBetweenScansMillis = 500, _hints) {
        this.reader = reader;
        this.timeBetweenScansMillis = timeBetweenScansMillis;
        this._hints = _hints;
        this._stopContinuousDecode = false;
        this._stopAsyncDecode = false;
        this._timeBetweenDecodingAttempts = 0;
      }
      /**
       * If navigator is present.
       */
      get hasNavigator() {
        return typeof navigator !== "undefined";
      }
      /**
       * If mediaDevices under navigator is supported.
       */
      get isMediaDevicesSuported() {
        return this.hasNavigator && !!navigator.mediaDevices;
      }
      /**
       * If enumerateDevices under navigator is supported.
       */
      get canEnumerateDevices() {
        return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);
      }
      /** Time between two decoding tries in milli seconds. */
      get timeBetweenDecodingAttempts() {
        return this._timeBetweenDecodingAttempts;
      }
      /**
       * Change the time span the decoder waits between two decoding tries.
       *
       * @param {number} millis Time between two decoding tries in milli seconds.
       */
      set timeBetweenDecodingAttempts(millis) {
        this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;
      }
      /**
       * Sets the hints.
       */
      set hints(hints) {
        this._hints = hints || null;
      }
      /**
       * Sets the hints.
       */
      get hints() {
        return this._hints;
      }
      /**
       * Lists all the available video input devices.
       */
      listVideoInputDevices() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.hasNavigator) {
            throw new Error("Can't enumerate devices, navigator is not present.");
          }
          if (!this.canEnumerateDevices) {
            throw new Error("Can't enumerate devices, method not supported.");
          }
          const devices = yield navigator.mediaDevices.enumerateDevices();
          const videoDevices = [];
          for (const device of devices) {
            const kind = device.kind === "video" ? "videoinput" : device.kind;
            if (kind !== "videoinput") {
              continue;
            }
            const deviceId = device.deviceId || device.id;
            const label = device.label || `Video device ${videoDevices.length + 1}`;
            const groupId = device.groupId;
            const videoDevice = { deviceId, label, kind, groupId };
            videoDevices.push(videoDevice);
          }
          return videoDevices;
        });
      }
      /**
       * Obtain the list of available devices with type 'videoinput'.
       *
       * @returns {Promise<VideoInputDevice[]>} an array of available video input devices
       *
       * @memberOf BrowserCodeReader
       *
       * @deprecated Use `listVideoInputDevices` instead.
       */
      getVideoInputDevices() {
        return __awaiter2(this, void 0, void 0, function* () {
          const devices = yield this.listVideoInputDevices();
          return devices.map((d) => new VideoInputDevice(d.deviceId, d.label));
        });
      }
      /**
       * Let's you find a device using it's Id.
       */
      findDeviceById(deviceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          const devices = yield this.listVideoInputDevices();
          if (!devices) {
            return null;
          }
          return devices.find((x) => x.deviceId === deviceId);
        });
      }
      /**
       * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.
       *
       * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
       * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns The decoding result.
       *
       * @memberOf BrowserCodeReader
       *
       * @deprecated Use `decodeOnceFromVideoDevice` instead.
       */
      decodeFromInputVideoDevice(deviceId, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          return yield this.decodeOnceFromVideoDevice(deviceId, videoSource);
        });
      }
      /**
       * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.
       *
       * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
       * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeOnceFromVideoDevice(deviceId, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.reset();
          let videoConstraints;
          if (!deviceId) {
            videoConstraints = { facingMode: "environment" };
          } else {
            videoConstraints = { deviceId: { exact: deviceId } };
          }
          const constraints = { video: videoConstraints };
          return yield this.decodeOnceFromConstraints(constraints, videoSource);
        });
      }
      /**
       * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
       *
       * @param constraints the media stream constraints to get s valid media stream to decode from
       * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeOnceFromConstraints(constraints, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          const stream = yield navigator.mediaDevices.getUserMedia(constraints);
          return yield this.decodeOnceFromStream(stream, videoSource);
        });
      }
      /**
       * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
       *
       * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
       * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeOnceFromStream(stream, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.reset();
          const video = yield this.attachStreamToVideo(stream, videoSource);
          const result = yield this.decodeOnce(video);
          return result;
        });
      }
      /**
       * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.
       *
       * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
       * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns {Promise<void>}
       *
       * @memberOf BrowserCodeReader
       *
       * @deprecated Use `decodeFromVideoDevice` instead.
       */
      decodeFromInputVideoDeviceContinuously(deviceId, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          return yield this.decodeFromVideoDevice(deviceId, videoSource, callbackFn);
        });
      }
      /**
       * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.
       *
       * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
       * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns {Promise<void>}
       *
       * @memberOf BrowserCodeReader
       */
      decodeFromVideoDevice(deviceId, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          let videoConstraints;
          if (!deviceId) {
            videoConstraints = { facingMode: "environment" };
          } else {
            videoConstraints = { deviceId: { exact: deviceId } };
          }
          const constraints = { video: videoConstraints };
          return yield this.decodeFromConstraints(constraints, videoSource, callbackFn);
        });
      }
      /**
       * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
       *
       * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
       * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeFromConstraints(constraints, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          const stream = yield navigator.mediaDevices.getUserMedia(constraints);
          return yield this.decodeFromStream(stream, videoSource, callbackFn);
        });
      }
      /**
       * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
       *
       * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
       * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeFromStream(stream, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.reset();
          const video = yield this.attachStreamToVideo(stream, videoSource);
          return yield this.decodeContinuously(video, callbackFn);
        });
      }
      /**
       * Breaks the decoding loop.
       */
      stopAsyncDecode() {
        this._stopAsyncDecode = true;
      }
      /**
       * Breaks the decoding loop.
       */
      stopContinuousDecode() {
        this._stopContinuousDecode = true;
      }
      /**
       * Sets the new stream and request a new decoding-with-delay.
       *
       * @param stream The stream to be shown in the video element.
       * @param decodeFn A callback for the decode method.
       */
      attachStreamToVideo(stream, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          const videoElement = this.prepareVideoElement(videoSource);
          this.addVideoSource(videoElement, stream);
          this.videoElement = videoElement;
          this.stream = stream;
          yield this.playVideoOnLoadAsync(videoElement);
          return videoElement;
        });
      }
      /**
       *
       * @param videoElement
       */
      playVideoOnLoadAsync(videoElement) {
        return new Promise((resolve2, reject) => this.playVideoOnLoad(videoElement, () => resolve2()));
      }
      /**
       * Binds listeners and callbacks to the videoElement.
       *
       * @param element
       * @param callbackFn
       */
      playVideoOnLoad(element, callbackFn) {
        this.videoEndedListener = () => this.stopStreams();
        this.videoCanPlayListener = () => this.tryPlayVideo(element);
        element.addEventListener("ended", this.videoEndedListener);
        element.addEventListener("canplay", this.videoCanPlayListener);
        element.addEventListener("playing", callbackFn);
        this.tryPlayVideo(element);
      }
      /**
       * Checks if the given video element is currently playing.
       */
      isVideoPlaying(video) {
        return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
      }
      /**
       * Just tries to play the video and logs any errors.
       * The play call is only made is the video is not already playing.
       */
      tryPlayVideo(videoElement) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this.isVideoPlaying(videoElement)) {
            console.warn("Trying to play video that is already playing.");
            return;
          }
          try {
            yield videoElement.play();
          } catch (_a) {
            console.warn("It was not possible to play the video.");
          }
        });
      }
      /**
       * Searches and validates a media element.
       */
      getMediaElement(mediaElementId, type) {
        const mediaElement = document.getElementById(mediaElementId);
        if (!mediaElement) {
          throw new ArgumentException(`element with id '${mediaElementId}' not found`);
        }
        if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
          throw new ArgumentException(`element with id '${mediaElementId}' must be an ${type} element`);
        }
        return mediaElement;
      }
      /**
       * Decodes the barcode from an image.
       *
       * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
       * @param {string} [url]
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeFromImage(source, url) {
        if (!source && !url) {
          throw new ArgumentException("either imageElement with a src set or an url must be provided");
        }
        if (url && !source) {
          return this.decodeFromImageUrl(url);
        }
        return this.decodeFromImageElement(source);
      }
      /**
       * Decodes the barcode from a video.
       *
       * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
       * @param {string} [url]
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeFromVideo(source, url) {
        if (!source && !url) {
          throw new ArgumentException("Either an element with a src set or an URL must be provided");
        }
        if (url && !source) {
          return this.decodeFromVideoUrl(url);
        }
        return this.decodeFromVideoElement(source);
      }
      /**
       * Decodes continuously the barcode from a video.
       *
       * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
       * @param {string} [url]
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       *
       * @experimental
       */
      decodeFromVideoContinuously(source, url, callbackFn) {
        if (void 0 === source && void 0 === url) {
          throw new ArgumentException("Either an element with a src set or an URL must be provided");
        }
        if (url && !source) {
          return this.decodeFromVideoUrlContinuously(url, callbackFn);
        }
        return this.decodeFromVideoElementContinuously(source, callbackFn);
      }
      /**
       * Decodes something from an image HTML element.
       */
      decodeFromImageElement(source) {
        if (!source) {
          throw new ArgumentException("An image element must be provided.");
        }
        this.reset();
        const element = this.prepareImageElement(source);
        this.imageElement = element;
        let task;
        if (this.isImageLoaded(element)) {
          task = this.decodeOnce(element, false, true);
        } else {
          task = this._decodeOnLoadImage(element);
        }
        return task;
      }
      /**
       * Decodes something from an image HTML element.
       */
      decodeFromVideoElement(source) {
        const element = this._decodeFromVideoElementSetup(source);
        return this._decodeOnLoadVideo(element);
      }
      /**
       * Decodes something from an image HTML element.
       */
      decodeFromVideoElementContinuously(source, callbackFn) {
        const element = this._decodeFromVideoElementSetup(source);
        return this._decodeOnLoadVideoContinuously(element, callbackFn);
      }
      /**
       * Sets up the video source so it can be decoded when loaded.
       *
       * @param source The video source element.
       */
      _decodeFromVideoElementSetup(source) {
        if (!source) {
          throw new ArgumentException("A video element must be provided.");
        }
        this.reset();
        const element = this.prepareVideoElement(source);
        this.videoElement = element;
        return element;
      }
      /**
       * Decodes an image from a URL.
       */
      decodeFromImageUrl(url) {
        if (!url) {
          throw new ArgumentException("An URL must be provided.");
        }
        this.reset();
        const element = this.prepareImageElement();
        this.imageElement = element;
        const decodeTask = this._decodeOnLoadImage(element);
        element.src = url;
        return decodeTask;
      }
      /**
       * Decodes an image from a URL.
       */
      decodeFromVideoUrl(url) {
        if (!url) {
          throw new ArgumentException("An URL must be provided.");
        }
        this.reset();
        const element = this.prepareVideoElement();
        const decodeTask = this.decodeFromVideoElement(element);
        element.src = url;
        return decodeTask;
      }
      /**
       * Decodes an image from a URL.
       *
       * @experimental
       */
      decodeFromVideoUrlContinuously(url, callbackFn) {
        if (!url) {
          throw new ArgumentException("An URL must be provided.");
        }
        this.reset();
        const element = this.prepareVideoElement();
        const decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);
        element.src = url;
        return decodeTask;
      }
      _decodeOnLoadImage(element) {
        return new Promise((resolve2, reject) => {
          this.imageLoadedListener = () => this.decodeOnce(element, false, true).then(resolve2, reject);
          element.addEventListener("load", this.imageLoadedListener);
        });
      }
      _decodeOnLoadVideo(videoElement) {
        return __awaiter2(this, void 0, void 0, function* () {
          yield this.playVideoOnLoadAsync(videoElement);
          return yield this.decodeOnce(videoElement);
        });
      }
      _decodeOnLoadVideoContinuously(videoElement, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          yield this.playVideoOnLoadAsync(videoElement);
          this.decodeContinuously(videoElement, callbackFn);
        });
      }
      isImageLoaded(img) {
        if (!img.complete) {
          return false;
        }
        if (img.naturalWidth === 0) {
          return false;
        }
        return true;
      }
      prepareImageElement(imageSource) {
        let imageElement;
        if (typeof imageSource === "undefined") {
          imageElement = document.createElement("img");
          imageElement.width = 200;
          imageElement.height = 200;
        }
        if (typeof imageSource === "string") {
          imageElement = this.getMediaElement(imageSource, "img");
        }
        if (imageSource instanceof HTMLImageElement) {
          imageElement = imageSource;
        }
        return imageElement;
      }
      /**
       * Sets a HTMLVideoElement for scanning or creates a new one.
       *
       * @param videoSource The HTMLVideoElement to be set.
       */
      prepareVideoElement(videoSource) {
        let videoElement;
        if (!videoSource && typeof document !== "undefined") {
          videoElement = document.createElement("video");
          videoElement.width = 200;
          videoElement.height = 200;
        }
        if (typeof videoSource === "string") {
          videoElement = this.getMediaElement(videoSource, "video");
        }
        if (videoSource instanceof HTMLVideoElement) {
          videoElement = videoSource;
        }
        videoElement.setAttribute("autoplay", "true");
        videoElement.setAttribute("muted", "true");
        videoElement.setAttribute("playsinline", "true");
        return videoElement;
      }
      /**
       * Tries to decode from the video input until it finds some value.
       */
      decodeOnce(element, retryIfNotFound = true, retryIfChecksumOrFormatError = true) {
        this._stopAsyncDecode = false;
        const loop = (resolve2, reject) => {
          if (this._stopAsyncDecode) {
            reject(new NotFoundException("Video stream has ended before any code could be detected."));
            this._stopAsyncDecode = void 0;
            return;
          }
          try {
            const result = this.decode(element);
            resolve2(result);
          } catch (e) {
            const ifNotFound = retryIfNotFound && e instanceof NotFoundException;
            const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;
            const ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;
            if (ifNotFound || ifChecksumOrFormat) {
              return setTimeout(loop, this._timeBetweenDecodingAttempts, resolve2, reject);
            }
            reject(e);
          }
        };
        return new Promise((resolve2, reject) => loop(resolve2, reject));
      }
      /**
       * Continuously decodes from video input.
       */
      decodeContinuously(element, callbackFn) {
        this._stopContinuousDecode = false;
        const loop = () => {
          if (this._stopContinuousDecode) {
            this._stopContinuousDecode = void 0;
            return;
          }
          try {
            const result = this.decode(element);
            callbackFn(result, null);
            setTimeout(loop, this.timeBetweenScansMillis);
          } catch (e) {
            callbackFn(null, e);
            const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;
            const isNotFound = e instanceof NotFoundException;
            if (isChecksumOrFormatError || isNotFound) {
              setTimeout(loop, this._timeBetweenDecodingAttempts);
            }
          }
        };
        loop();
      }
      /**
       * Gets the BinaryBitmap for ya! (and decodes it)
       */
      decode(element) {
        const binaryBitmap = this.createBinaryBitmap(element);
        return this.decodeBitmap(binaryBitmap);
      }
      /**
       * Returns true if media element is indeed a {@link HtmlVideoElement}.
       */
      _isHTMLVideoElement(mediaElement) {
        const potentialVideo = mediaElement;
        return potentialVideo.videoWidth !== 0;
      }
      /**
       * Overwriting this allows you to manipulate the next frame in anyway
       * you want before decode.
       */
      drawFrameOnCanvas(srcElement, dimensions, canvasElementContext) {
        if (!dimensions) {
          dimensions = {
            sx: 0,
            sy: 0,
            sWidth: srcElement.videoWidth,
            sHeight: srcElement.videoHeight,
            dx: 0,
            dy: 0,
            dWidth: srcElement.videoWidth,
            dHeight: srcElement.videoHeight
          };
        }
        if (!canvasElementContext) {
          canvasElementContext = this.captureCanvasContext;
        }
        canvasElementContext.drawImage(
          srcElement,
          dimensions.sx,
          dimensions.sy,
          dimensions.sWidth,
          dimensions.sHeight,
          dimensions.dx,
          dimensions.dy,
          dimensions.dWidth,
          dimensions.dHeight
        );
      }
      /**
       * Ovewriting this allows you to manipulate the snapshot image in anyway
       *  you want before decode.
       */
      drawImageOnCanvas(srcElement, dimensions, canvasElementContext = this.captureCanvasContext) {
        if (!dimensions) {
          dimensions = {
            sx: 0,
            sy: 0,
            sWidth: srcElement.naturalWidth,
            sHeight: srcElement.naturalHeight,
            dx: 0,
            dy: 0,
            dWidth: srcElement.naturalWidth,
            dHeight: srcElement.naturalHeight
          };
        }
        if (!canvasElementContext) {
          canvasElementContext = this.captureCanvasContext;
        }
        canvasElementContext.drawImage(
          srcElement,
          dimensions.sx,
          dimensions.sy,
          dimensions.sWidth,
          dimensions.sHeight,
          dimensions.dx,
          dimensions.dy,
          dimensions.dWidth,
          dimensions.dHeight
        );
      }
      /**
       * Creates a binaryBitmap based in some image source.
       *
       * @param mediaElement HTML element containing drawable image source.
       */
      createBinaryBitmap(mediaElement) {
        this.getCaptureCanvasContext(mediaElement);
        if (this._isHTMLVideoElement(mediaElement)) {
          this.drawFrameOnCanvas(mediaElement);
        } else {
          this.drawImageOnCanvas(mediaElement);
        }
        const canvas = this.getCaptureCanvas(mediaElement);
        const luminanceSource = new HTMLCanvasElementLuminanceSource(canvas);
        const hybridBinarizer = new HybridBinarizer(luminanceSource);
        return new BinaryBitmap(hybridBinarizer);
      }
      getCaptureCanvasContext(mediaElement) {
        if (!this.captureCanvasContext) {
          const elem = this.getCaptureCanvas(mediaElement);
          const ctx = elem.getContext("2d");
          this.captureCanvasContext = ctx;
        }
        return this.captureCanvasContext;
      }
      getCaptureCanvas(mediaElement) {
        if (!this.captureCanvas) {
          const elem = this.createCaptureCanvas(mediaElement);
          this.captureCanvas = elem;
        }
        return this.captureCanvas;
      }
      /**
       * Call the encapsulated readers decode
       */
      decodeBitmap(binaryBitmap) {
        return this.reader.decode(binaryBitmap, this._hints);
      }
      /**
       * 🖌 Prepares the canvas for capture and scan frames.
       */
      createCaptureCanvas(mediaElement) {
        if (typeof document === "undefined") {
          this._destroyCaptureCanvas();
          return null;
        }
        const canvasElement = document.createElement("canvas");
        let width;
        let height;
        if (typeof mediaElement !== "undefined") {
          if (mediaElement instanceof HTMLVideoElement) {
            width = mediaElement.videoWidth;
            height = mediaElement.videoHeight;
          } else if (mediaElement instanceof HTMLImageElement) {
            width = mediaElement.naturalWidth || mediaElement.width;
            height = mediaElement.naturalHeight || mediaElement.height;
          }
        }
        canvasElement.style.width = width + "px";
        canvasElement.style.height = height + "px";
        canvasElement.width = width;
        canvasElement.height = height;
        return canvasElement;
      }
      /**
       * Stops the continuous scan and cleans the stream.
       */
      stopStreams() {
        if (this.stream) {
          this.stream.getVideoTracks().forEach((t) => t.stop());
          this.stream = void 0;
        }
        if (this._stopAsyncDecode === false) {
          this.stopAsyncDecode();
        }
        if (this._stopContinuousDecode === false) {
          this.stopContinuousDecode();
        }
      }
      /**
       * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.
       *
       * @memberOf BrowserCodeReader
       */
      reset() {
        this.stopStreams();
        this._destroyVideoElement();
        this._destroyImageElement();
        this._destroyCaptureCanvas();
      }
      _destroyVideoElement() {
        if (!this.videoElement) {
          return;
        }
        if (typeof this.videoEndedListener !== "undefined") {
          this.videoElement.removeEventListener("ended", this.videoEndedListener);
        }
        if (typeof this.videoPlayingEventListener !== "undefined") {
          this.videoElement.removeEventListener("playing", this.videoPlayingEventListener);
        }
        if (typeof this.videoCanPlayListener !== "undefined") {
          this.videoElement.removeEventListener("loadedmetadata", this.videoCanPlayListener);
        }
        this.cleanVideoSource(this.videoElement);
        this.videoElement = void 0;
      }
      _destroyImageElement() {
        if (!this.imageElement) {
          return;
        }
        if (void 0 !== this.imageLoadedListener) {
          this.imageElement.removeEventListener("load", this.imageLoadedListener);
        }
        this.imageElement.src = void 0;
        this.imageElement.removeAttribute("src");
        this.imageElement = void 0;
      }
      /**
       * Cleans canvas references 🖌
       */
      _destroyCaptureCanvas() {
        this.captureCanvasContext = void 0;
        this.captureCanvas = void 0;
      }
      /**
       * Defines what the videoElement src will be.
       *
       * @param videoElement
       * @param stream
       */
      addVideoSource(videoElement, stream) {
        try {
          videoElement.srcObject = stream;
        } catch (err2) {
          videoElement.src = URL.createObjectURL(stream);
        }
      }
      /**
       * Unbinds a HTML video src property.
       *
       * @param videoElement
       */
      cleanVideoSource(videoElement) {
        try {
          videoElement.srcObject = null;
        } catch (err2) {
          videoElement.src = "";
        }
        this.videoElement.removeAttribute("src");
      }
    }
    class Result {
      // public constructor(private text: string,
      //               Uint8Array rawBytes,
      //               ResultPoconst resultPoints: Int32Array,
      //               BarcodeFormat format) {
      //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())
      // }
      // public constructor(text: string,
      //               Uint8Array rawBytes,
      //               ResultPoconst resultPoints: Int32Array,
      //               BarcodeFormat format,
      //               long timestamp) {
      //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,
      //        resultPoints, format, timestamp)
      // }
      constructor(text, rawBytes, numBits = rawBytes == null ? 0 : 8 * rawBytes.length, resultPoints, format, timestamp = System.currentTimeMillis()) {
        this.text = text;
        this.rawBytes = rawBytes;
        this.numBits = numBits;
        this.resultPoints = resultPoints;
        this.format = format;
        this.timestamp = timestamp;
        this.text = text;
        this.rawBytes = rawBytes;
        if (void 0 === numBits || null === numBits) {
          this.numBits = rawBytes === null || rawBytes === void 0 ? 0 : 8 * rawBytes.length;
        } else {
          this.numBits = numBits;
        }
        this.resultPoints = resultPoints;
        this.format = format;
        this.resultMetadata = null;
        if (void 0 === timestamp || null === timestamp) {
          this.timestamp = System.currentTimeMillis();
        } else {
          this.timestamp = timestamp;
        }
      }
      /**
       * @return raw text encoded by the barcode
       */
      getText() {
        return this.text;
      }
      /**
       * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}
       */
      getRawBytes() {
        return this.rawBytes;
      }
      /**
       * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
       * @since 3.3.0
       */
      getNumBits() {
        return this.numBits;
      }
      /**
       * @return points related to the barcode in the image. These are typically points
       *         identifying finder patterns or the corners of the barcode. The exact meaning is
       *         specific to the type of barcode that was decoded.
       */
      getResultPoints() {
        return this.resultPoints;
      }
      /**
       * @return {@link BarcodeFormat} representing the format of the barcode that was decoded
       */
      getBarcodeFormat() {
        return this.format;
      }
      /**
       * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be
       *   {@code null}. This contains optional metadata about what was detected about the barcode,
       *   like orientation.
       */
      getResultMetadata() {
        return this.resultMetadata;
      }
      putMetadata(type, value) {
        if (this.resultMetadata === null) {
          this.resultMetadata = /* @__PURE__ */ new Map();
        }
        this.resultMetadata.set(type, value);
      }
      putAllMetadata(metadata) {
        if (metadata !== null) {
          if (this.resultMetadata === null) {
            this.resultMetadata = metadata;
          } else {
            this.resultMetadata = new Map(metadata);
          }
        }
      }
      addResultPoints(newPoints) {
        const oldPoints = this.resultPoints;
        if (oldPoints === null) {
          this.resultPoints = newPoints;
        } else if (newPoints !== null && newPoints.length > 0) {
          const allPoints = new Array(oldPoints.length + newPoints.length);
          System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
          System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
          this.resultPoints = allPoints;
        }
      }
      getTimestamp() {
        return this.timestamp;
      }
      /*@Override*/
      toString() {
        return this.text;
      }
    }
    var BarcodeFormat;
    (function(BarcodeFormat2) {
      BarcodeFormat2[BarcodeFormat2["AZTEC"] = 0] = "AZTEC";
      BarcodeFormat2[BarcodeFormat2["CODABAR"] = 1] = "CODABAR";
      BarcodeFormat2[BarcodeFormat2["CODE_39"] = 2] = "CODE_39";
      BarcodeFormat2[BarcodeFormat2["CODE_93"] = 3] = "CODE_93";
      BarcodeFormat2[BarcodeFormat2["CODE_128"] = 4] = "CODE_128";
      BarcodeFormat2[BarcodeFormat2["DATA_MATRIX"] = 5] = "DATA_MATRIX";
      BarcodeFormat2[BarcodeFormat2["EAN_8"] = 6] = "EAN_8";
      BarcodeFormat2[BarcodeFormat2["EAN_13"] = 7] = "EAN_13";
      BarcodeFormat2[BarcodeFormat2["ITF"] = 8] = "ITF";
      BarcodeFormat2[BarcodeFormat2["MAXICODE"] = 9] = "MAXICODE";
      BarcodeFormat2[BarcodeFormat2["PDF_417"] = 10] = "PDF_417";
      BarcodeFormat2[BarcodeFormat2["QR_CODE"] = 11] = "QR_CODE";
      BarcodeFormat2[BarcodeFormat2["RSS_14"] = 12] = "RSS_14";
      BarcodeFormat2[BarcodeFormat2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
      BarcodeFormat2[BarcodeFormat2["UPC_A"] = 14] = "UPC_A";
      BarcodeFormat2[BarcodeFormat2["UPC_E"] = 15] = "UPC_E";
      BarcodeFormat2[BarcodeFormat2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
    })(BarcodeFormat || (BarcodeFormat = {}));
    var BarcodeFormat$1 = BarcodeFormat;
    var ResultMetadataType;
    (function(ResultMetadataType2) {
      ResultMetadataType2[ResultMetadataType2["OTHER"] = 0] = "OTHER";
      ResultMetadataType2[ResultMetadataType2["ORIENTATION"] = 1] = "ORIENTATION";
      ResultMetadataType2[ResultMetadataType2["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";
      ResultMetadataType2[ResultMetadataType2["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";
      ResultMetadataType2[ResultMetadataType2["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";
      ResultMetadataType2[ResultMetadataType2["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";
      ResultMetadataType2[ResultMetadataType2["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";
      ResultMetadataType2[ResultMetadataType2["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";
      ResultMetadataType2[ResultMetadataType2["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";
      ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";
      ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";
    })(ResultMetadataType || (ResultMetadataType = {}));
    var ResultMetadataType$1 = ResultMetadataType;
    class DecoderResult {
      // public constructor(rawBytes: Uint8Array,
      //                      text: string,
      //                      List<Uint8Array> byteSegments,
      //                      String ecLevel) {
      //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)
      // }
      constructor(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber = -1, structuredAppendParity = -1) {
        this.rawBytes = rawBytes;
        this.text = text;
        this.byteSegments = byteSegments;
        this.ecLevel = ecLevel;
        this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;
        this.structuredAppendParity = structuredAppendParity;
        this.numBits = rawBytes === void 0 || rawBytes === null ? 0 : 8 * rawBytes.length;
      }
      /**
       * @return raw bytes representing the result, or {@code null} if not applicable
       */
      getRawBytes() {
        return this.rawBytes;
      }
      /**
       * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
       * @since 3.3.0
       */
      getNumBits() {
        return this.numBits;
      }
      /**
       * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}
       * @since 3.3.0
       */
      setNumBits(numBits) {
        this.numBits = numBits;
      }
      /**
       * @return text representation of the result
       */
      getText() {
        return this.text;
      }
      /**
       * @return list of byte segments in the result, or {@code null} if not applicable
       */
      getByteSegments() {
        return this.byteSegments;
      }
      /**
       * @return name of error correction level used, or {@code null} if not applicable
       */
      getECLevel() {
        return this.ecLevel;
      }
      /**
       * @return number of errors corrected, or {@code null} if not applicable
       */
      getErrorsCorrected() {
        return this.errorsCorrected;
      }
      setErrorsCorrected(errorsCorrected) {
        this.errorsCorrected = errorsCorrected;
      }
      /**
       * @return number of erasures corrected, or {@code null} if not applicable
       */
      getErasures() {
        return this.erasures;
      }
      setErasures(erasures) {
        this.erasures = erasures;
      }
      /**
       * @return arbitrary additional metadata
       */
      getOther() {
        return this.other;
      }
      setOther(other) {
        this.other = other;
      }
      hasStructuredAppend() {
        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
      }
      getStructuredAppendParity() {
        return this.structuredAppendParity;
      }
      getStructuredAppendSequenceNumber() {
        return this.structuredAppendSequenceNumber;
      }
    }
    class AbstractGenericGF {
      /**
       * @return 2 to the power of a in GF(size)
       */
      exp(a) {
        return this.expTable[a];
      }
      /**
       * @return base 2 log of a in GF(size)
       */
      log(a) {
        if (a === 0) {
          throw new IllegalArgumentException();
        }
        return this.logTable[a];
      }
      /**
       * Implements both addition and subtraction -- they are the same in GF(size).
       *
       * @return sum/difference of a and b
       */
      static addOrSubtract(a, b) {
        return a ^ b;
      }
    }
    class GenericGFPoly {
      /**
       * @param field the {@link GenericGF} instance representing the field to use
       * to perform computations
       * @param coefficients coefficients as ints representing elements of GF(size), arranged
       * from most significant (highest-power term) coefficient to least significant
       * @throws IllegalArgumentException if argument is null or empty,
       * or if leading coefficient is 0 and this is not a
       * constant polynomial (that is, it is not the monomial "0")
       */
      constructor(field2, coefficients) {
        if (coefficients.length === 0) {
          throw new IllegalArgumentException();
        }
        this.field = field2;
        const coefficientsLength = coefficients.length;
        if (coefficientsLength > 1 && coefficients[0] === 0) {
          let firstNonZero = 1;
          while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
            firstNonZero++;
          }
          if (firstNonZero === coefficientsLength) {
            this.coefficients = Int32Array.from([0]);
          } else {
            this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
            System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
          }
        } else {
          this.coefficients = coefficients;
        }
      }
      getCoefficients() {
        return this.coefficients;
      }
      /**
       * @return degree of this polynomial
       */
      getDegree() {
        return this.coefficients.length - 1;
      }
      /**
       * @return true iff this polynomial is the monomial "0"
       */
      isZero() {
        return this.coefficients[0] === 0;
      }
      /**
       * @return coefficient of x^degree term in this polynomial
       */
      getCoefficient(degree) {
        return this.coefficients[this.coefficients.length - 1 - degree];
      }
      /**
       * @return evaluation of this polynomial at a given point
       */
      evaluateAt(a) {
        if (a === 0) {
          return this.getCoefficient(0);
        }
        const coefficients = this.coefficients;
        let result;
        if (a === 1) {
          result = 0;
          for (let i = 0, length = coefficients.length; i !== length; i++) {
            const coefficient = coefficients[i];
            result = AbstractGenericGF.addOrSubtract(result, coefficient);
          }
          return result;
        }
        result = coefficients[0];
        const size = coefficients.length;
        const field2 = this.field;
        for (let i = 1; i < size; i++) {
          result = AbstractGenericGF.addOrSubtract(field2.multiply(a, result), coefficients[i]);
        }
        return result;
      }
      addOrSubtract(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
        }
        if (this.isZero()) {
          return other;
        }
        if (other.isZero()) {
          return this;
        }
        let smallerCoefficients = this.coefficients;
        let largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
          const temp = smallerCoefficients;
          smallerCoefficients = largerCoefficients;
          largerCoefficients = temp;
        }
        let sumDiff = new Int32Array(largerCoefficients.length);
        const lengthDiff = largerCoefficients.length - smallerCoefficients.length;
        System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (let i = lengthDiff; i < largerCoefficients.length; i++) {
          sumDiff[i] = AbstractGenericGF.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
        }
        return new GenericGFPoly(this.field, sumDiff);
      }
      multiply(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
        }
        if (this.isZero() || other.isZero()) {
          return this.field.getZero();
        }
        const aCoefficients = this.coefficients;
        const aLength = aCoefficients.length;
        const bCoefficients = other.coefficients;
        const bLength = bCoefficients.length;
        const product = new Int32Array(aLength + bLength - 1);
        const field2 = this.field;
        for (let i = 0; i < aLength; i++) {
          const aCoeff = aCoefficients[i];
          for (let j = 0; j < bLength; j++) {
            product[i + j] = AbstractGenericGF.addOrSubtract(product[i + j], field2.multiply(aCoeff, bCoefficients[j]));
          }
        }
        return new GenericGFPoly(field2, product);
      }
      multiplyScalar(scalar2) {
        if (scalar2 === 0) {
          return this.field.getZero();
        }
        if (scalar2 === 1) {
          return this;
        }
        const size = this.coefficients.length;
        const field2 = this.field;
        const product = new Int32Array(size);
        const coefficients = this.coefficients;
        for (let i = 0; i < size; i++) {
          product[i] = field2.multiply(coefficients[i], scalar2);
        }
        return new GenericGFPoly(field2, product);
      }
      multiplyByMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return this.field.getZero();
        }
        const coefficients = this.coefficients;
        const size = coefficients.length;
        const product = new Int32Array(size + degree);
        const field2 = this.field;
        for (let i = 0; i < size; i++) {
          product[i] = field2.multiply(coefficients[i], coefficient);
        }
        return new GenericGFPoly(field2, product);
      }
      divide(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
        }
        if (other.isZero()) {
          throw new IllegalArgumentException("Divide by 0");
        }
        const field2 = this.field;
        let quotient = field2.getZero();
        let remainder = this;
        const denominatorLeadingTerm = other.getCoefficient(other.getDegree());
        const inverseDenominatorLeadingTerm = field2.inverse(denominatorLeadingTerm);
        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
          const degreeDifference = remainder.getDegree() - other.getDegree();
          const scale = field2.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
          const term = other.multiplyByMonomial(degreeDifference, scale);
          const iterationQuotient = field2.buildMonomial(degreeDifference, scale);
          quotient = quotient.addOrSubtract(iterationQuotient);
          remainder = remainder.addOrSubtract(term);
        }
        return [quotient, remainder];
      }
      /*@Override*/
      toString() {
        let result = "";
        for (let degree = this.getDegree(); degree >= 0; degree--) {
          let coefficient = this.getCoefficient(degree);
          if (coefficient !== 0) {
            if (coefficient < 0) {
              result += " - ";
              coefficient = -coefficient;
            } else {
              if (result.length > 0) {
                result += " + ";
              }
            }
            if (degree === 0 || coefficient !== 1) {
              const alphaPower = this.field.log(coefficient);
              if (alphaPower === 0) {
                result += "1";
              } else if (alphaPower === 1) {
                result += "a";
              } else {
                result += "a^";
                result += alphaPower;
              }
            }
            if (degree !== 0) {
              if (degree === 1) {
                result += "x";
              } else {
                result += "x^";
                result += degree;
              }
            }
          }
        }
        return result;
      }
    }
    class ArithmeticException extends Exception {
    }
    ArithmeticException.kind = "ArithmeticException";
    class GenericGF extends AbstractGenericGF {
      /**
       * Create a representation of GF(size) using the given primitive polynomial.
       *
       * @param primitive irreducible polynomial whose coefficients are represented by
       *  the bits of an int, where the least-significant bit represents the constant
       *  coefficient
       * @param size the size of the field
       * @param b the factor b in the generator polynomial can be 0- or 1-based
       *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).
       *  In most cases it should be 1, but for QR code it is 0.
       */
      constructor(primitive, size, generatorBase) {
        super();
        this.primitive = primitive;
        this.size = size;
        this.generatorBase = generatorBase;
        const expTable = new Int32Array(size);
        let x = 1;
        for (let i = 0; i < size; i++) {
          expTable[i] = x;
          x *= 2;
          if (x >= size) {
            x ^= primitive;
            x &= size - 1;
          }
        }
        this.expTable = expTable;
        const logTable = new Int32Array(size);
        for (let i = 0; i < size - 1; i++) {
          logTable[expTable[i]] = i;
        }
        this.logTable = logTable;
        this.zero = new GenericGFPoly(this, Int32Array.from([0]));
        this.one = new GenericGFPoly(this, Int32Array.from([1]));
      }
      getZero() {
        return this.zero;
      }
      getOne() {
        return this.one;
      }
      /**
       * @return the monomial representing coefficient * x^degree
       */
      buildMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return this.zero;
        }
        const coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new GenericGFPoly(this, coefficients);
      }
      /**
       * @return multiplicative inverse of a
       */
      inverse(a) {
        if (a === 0) {
          throw new ArithmeticException();
        }
        return this.expTable[this.size - this.logTable[a] - 1];
      }
      /**
       * @return product of a and b in GF(size)
       */
      multiply(a, b) {
        if (a === 0 || b === 0) {
          return 0;
        }
        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];
      }
      getSize() {
        return this.size;
      }
      getGeneratorBase() {
        return this.generatorBase;
      }
      /*@Override*/
      toString() {
        return "GF(0x" + Integer.toHexString(this.primitive) + "," + this.size + ")";
      }
      equals(o) {
        return o === this;
      }
    }
    GenericGF.AZTEC_DATA_12 = new GenericGF(4201, 4096, 1);
    GenericGF.AZTEC_DATA_10 = new GenericGF(1033, 1024, 1);
    GenericGF.AZTEC_DATA_6 = new GenericGF(67, 64, 1);
    GenericGF.AZTEC_PARAM = new GenericGF(19, 16, 1);
    GenericGF.QR_CODE_FIELD_256 = new GenericGF(285, 256, 0);
    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(301, 256, 1);
    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;
    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;
    class ReedSolomonException extends Exception {
    }
    ReedSolomonException.kind = "ReedSolomonException";
    class IllegalStateException extends Exception {
    }
    IllegalStateException.kind = "IllegalStateException";
    class ReedSolomonDecoder {
      constructor(field2) {
        this.field = field2;
      }
      /**
       * <p>Decodes given set of received codewords, which include both data and error-correction
       * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,
       * in the input.</p>
       *
       * @param received data and error-correction codewords
       * @param twoS number of error-correction codewords available
       * @throws ReedSolomonException if decoding fails for any reason
       */
      decode(received, twoS) {
        const field2 = this.field;
        const poly = new GenericGFPoly(field2, received);
        const syndromeCoefficients = new Int32Array(twoS);
        let noError = true;
        for (let i = 0; i < twoS; i++) {
          const evalResult = poly.evaluateAt(field2.exp(i + field2.getGeneratorBase()));
          syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;
          if (evalResult !== 0) {
            noError = false;
          }
        }
        if (noError) {
          return;
        }
        const syndrome = new GenericGFPoly(field2, syndromeCoefficients);
        const sigmaOmega = this.runEuclideanAlgorithm(field2.buildMonomial(twoS, 1), syndrome, twoS);
        const sigma = sigmaOmega[0];
        const omega = sigmaOmega[1];
        const errorLocations = this.findErrorLocations(sigma);
        const errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
        for (let i = 0; i < errorLocations.length; i++) {
          const position = received.length - 1 - field2.log(errorLocations[i]);
          if (position < 0) {
            throw new ReedSolomonException("Bad error location");
          }
          received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);
        }
      }
      runEuclideanAlgorithm(a, b, R2) {
        if (a.getDegree() < b.getDegree()) {
          const temp = a;
          a = b;
          b = temp;
        }
        const field2 = this.field;
        let rLast = a;
        let r = b;
        let tLast = field2.getZero();
        let t = field2.getOne();
        while (r.getDegree() >= (R2 / 2 | 0)) {
          let rLastLast = rLast;
          let tLastLast = tLast;
          rLast = r;
          tLast = t;
          if (rLast.isZero()) {
            throw new ReedSolomonException("r_{i-1} was zero");
          }
          r = rLastLast;
          let q = field2.getZero();
          const denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
          const dltInverse = field2.inverse(denominatorLeadingTerm);
          while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
            const degreeDiff = r.getDegree() - rLast.getDegree();
            const scale = field2.multiply(r.getCoefficient(r.getDegree()), dltInverse);
            q = q.addOrSubtract(field2.buildMonomial(degreeDiff, scale));
            r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
          }
          t = q.multiply(tLast).addOrSubtract(tLastLast);
          if (r.getDegree() >= rLast.getDegree()) {
            throw new IllegalStateException("Division algorithm failed to reduce polynomial?");
          }
        }
        const sigmaTildeAtZero = t.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
          throw new ReedSolomonException("sigmaTilde(0) was zero");
        }
        const inverse = field2.inverse(sigmaTildeAtZero);
        const sigma = t.multiplyScalar(inverse);
        const omega = r.multiplyScalar(inverse);
        return [sigma, omega];
      }
      findErrorLocations(errorLocator) {
        const numErrors = errorLocator.getDegree();
        if (numErrors === 1) {
          return Int32Array.from([errorLocator.getCoefficient(1)]);
        }
        const result = new Int32Array(numErrors);
        let e = 0;
        const field2 = this.field;
        for (let i = 1; i < field2.getSize() && e < numErrors; i++) {
          if (errorLocator.evaluateAt(i) === 0) {
            result[e] = field2.inverse(i);
            e++;
          }
        }
        if (e !== numErrors) {
          throw new ReedSolomonException("Error locator degree does not match number of roots");
        }
        return result;
      }
      findErrorMagnitudes(errorEvaluator, errorLocations) {
        const s = errorLocations.length;
        const result = new Int32Array(s);
        const field2 = this.field;
        for (let i = 0; i < s; i++) {
          const xiInverse = field2.inverse(errorLocations[i]);
          let denominator = 1;
          for (let j = 0; j < s; j++) {
            if (i !== j) {
              const term = field2.multiply(errorLocations[j], xiInverse);
              const termPlus1 = (term & 1) === 0 ? term | 1 : term & ~1;
              denominator = field2.multiply(denominator, termPlus1);
            }
          }
          result[i] = field2.multiply(errorEvaluator.evaluateAt(xiInverse), field2.inverse(denominator));
          if (field2.getGeneratorBase() !== 0) {
            result[i] = field2.multiply(result[i], xiInverse);
          }
        }
        return result;
      }
    }
    var Table;
    (function(Table2) {
      Table2[Table2["UPPER"] = 0] = "UPPER";
      Table2[Table2["LOWER"] = 1] = "LOWER";
      Table2[Table2["MIXED"] = 2] = "MIXED";
      Table2[Table2["DIGIT"] = 3] = "DIGIT";
      Table2[Table2["PUNCT"] = 4] = "PUNCT";
      Table2[Table2["BINARY"] = 5] = "BINARY";
    })(Table || (Table = {}));
    class Decoder2 {
      decode(detectorResult) {
        this.ddata = detectorResult;
        let matrix = detectorResult.getBits();
        let rawbits = this.extractBits(matrix);
        let correctedBits = this.correctBits(rawbits);
        let rawBytes = Decoder2.convertBoolArrayToByteArray(correctedBits);
        let result = Decoder2.getEncodedData(correctedBits);
        let decoderResult = new DecoderResult(rawBytes, result, null, null);
        decoderResult.setNumBits(correctedBits.length);
        return decoderResult;
      }
      // This method is used for testing the high-level encoder
      static highLevelDecode(correctedBits) {
        return this.getEncodedData(correctedBits);
      }
      /**
       * Gets the string encoded in the aztec code bits
       *
       * @return the decoded string
       */
      static getEncodedData(correctedBits) {
        let endIndex = correctedBits.length;
        let latchTable = Table.UPPER;
        let shiftTable = Table.UPPER;
        let result = "";
        let index2 = 0;
        while (index2 < endIndex) {
          if (shiftTable === Table.BINARY) {
            if (endIndex - index2 < 5) {
              break;
            }
            let length = Decoder2.readCode(correctedBits, index2, 5);
            index2 += 5;
            if (length === 0) {
              if (endIndex - index2 < 11) {
                break;
              }
              length = Decoder2.readCode(correctedBits, index2, 11) + 31;
              index2 += 11;
            }
            for (let charCount = 0; charCount < length; charCount++) {
              if (endIndex - index2 < 8) {
                index2 = endIndex;
                break;
              }
              const code = Decoder2.readCode(correctedBits, index2, 8);
              result += /*(char)*/
              StringUtils.castAsNonUtf8Char(code);
              index2 += 8;
            }
            shiftTable = latchTable;
          } else {
            let size = shiftTable === Table.DIGIT ? 4 : 5;
            if (endIndex - index2 < size) {
              break;
            }
            let code = Decoder2.readCode(correctedBits, index2, size);
            index2 += size;
            let str = Decoder2.getCharacter(shiftTable, code);
            if (str.startsWith("CTRL_")) {
              latchTable = shiftTable;
              shiftTable = Decoder2.getTable(str.charAt(5));
              if (str.charAt(6) === "L") {
                latchTable = shiftTable;
              }
            } else {
              result += str;
              shiftTable = latchTable;
            }
          }
        }
        return result;
      }
      /**
       * gets the table corresponding to the char passed
       */
      static getTable(t) {
        switch (t) {
          case "L":
            return Table.LOWER;
          case "P":
            return Table.PUNCT;
          case "M":
            return Table.MIXED;
          case "D":
            return Table.DIGIT;
          case "B":
            return Table.BINARY;
          case "U":
          default:
            return Table.UPPER;
        }
      }
      /**
       * Gets the character (or string) corresponding to the passed code in the given table
       *
       * @param table the table used
       * @param code the code of the character
       */
      static getCharacter(table, code) {
        switch (table) {
          case Table.UPPER:
            return Decoder2.UPPER_TABLE[code];
          case Table.LOWER:
            return Decoder2.LOWER_TABLE[code];
          case Table.MIXED:
            return Decoder2.MIXED_TABLE[code];
          case Table.PUNCT:
            return Decoder2.PUNCT_TABLE[code];
          case Table.DIGIT:
            return Decoder2.DIGIT_TABLE[code];
          default:
            throw new IllegalStateException("Bad table");
        }
      }
      /**
       * <p>Performs RS error correction on an array of bits.</p>
       *
       * @return the corrected array
       * @throws FormatException if the input contains too many errors
       */
      correctBits(rawbits) {
        let gf;
        let codewordSize;
        if (this.ddata.getNbLayers() <= 2) {
          codewordSize = 6;
          gf = GenericGF.AZTEC_DATA_6;
        } else if (this.ddata.getNbLayers() <= 8) {
          codewordSize = 8;
          gf = GenericGF.AZTEC_DATA_8;
        } else if (this.ddata.getNbLayers() <= 22) {
          codewordSize = 10;
          gf = GenericGF.AZTEC_DATA_10;
        } else {
          codewordSize = 12;
          gf = GenericGF.AZTEC_DATA_12;
        }
        let numDataCodewords = this.ddata.getNbDatablocks();
        let numCodewords = rawbits.length / codewordSize;
        if (numCodewords < numDataCodewords) {
          throw new FormatException();
        }
        let offset = rawbits.length % codewordSize;
        let dataWords = new Int32Array(numCodewords);
        for (let i = 0; i < numCodewords; i++, offset += codewordSize) {
          dataWords[i] = Decoder2.readCode(rawbits, offset, codewordSize);
        }
        try {
          let rsDecoder = new ReedSolomonDecoder(gf);
          rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
        } catch (ex) {
          throw new FormatException(ex);
        }
        let mask2 = (1 << codewordSize) - 1;
        let stuffedBits = 0;
        for (let i = 0; i < numDataCodewords; i++) {
          let dataWord = dataWords[i];
          if (dataWord === 0 || dataWord === mask2) {
            throw new FormatException();
          } else if (dataWord === 1 || dataWord === mask2 - 1) {
            stuffedBits++;
          }
        }
        let correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);
        let index2 = 0;
        for (let i = 0; i < numDataCodewords; i++) {
          let dataWord = dataWords[i];
          if (dataWord === 1 || dataWord === mask2 - 1) {
            correctedBits.fill(dataWord > 1, index2, index2 + codewordSize - 1);
            index2 += codewordSize - 1;
          } else {
            for (let bit = codewordSize - 1; bit >= 0; --bit) {
              correctedBits[index2++] = (dataWord & 1 << bit) !== 0;
            }
          }
        }
        return correctedBits;
      }
      /**
       * Gets the array of bits from an Aztec Code matrix
       *
       * @return the array of bits
       */
      extractBits(matrix) {
        let compact = this.ddata.isCompact();
        let layers = this.ddata.getNbLayers();
        let baseMatrixSize = (compact ? 11 : 14) + layers * 4;
        let alignmentMap = new Int32Array(baseMatrixSize);
        let rawbits = new Array(this.totalBitsInLayer(layers, compact));
        if (compact) {
          for (let i = 0; i < alignmentMap.length; i++) {
            alignmentMap[i] = i;
          }
        } else {
          let matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);
          let origCenter = baseMatrixSize / 2;
          let center = Integer.truncDivision(matrixSize, 2);
          for (let i = 0; i < origCenter; i++) {
            let newOffset = i + Integer.truncDivision(i, 15);
            alignmentMap[origCenter - i - 1] = center - newOffset - 1;
            alignmentMap[origCenter + i] = center + newOffset + 1;
          }
        }
        for (let i = 0, rowOffset = 0; i < layers; i++) {
          let rowSize = (layers - i) * 4 + (compact ? 9 : 12);
          let low = i * 2;
          let high = baseMatrixSize - 1 - low;
          for (let j = 0; j < rowSize; j++) {
            let columnOffset = j * 2;
            for (let k = 0; k < 2; k++) {
              rawbits[rowOffset + columnOffset + k] = matrix.get(alignmentMap[low + k], alignmentMap[low + j]);
              rawbits[rowOffset + 2 * rowSize + columnOffset + k] = matrix.get(alignmentMap[low + j], alignmentMap[high - k]);
              rawbits[rowOffset + 4 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - k], alignmentMap[high - j]);
              rawbits[rowOffset + 6 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - j], alignmentMap[low + k]);
            }
          }
          rowOffset += rowSize * 8;
        }
        return rawbits;
      }
      /**
       * Reads a code of given length and at given index in an array of bits
       */
      static readCode(rawbits, startIndex, length) {
        let res = 0;
        for (let i = startIndex; i < startIndex + length; i++) {
          res <<= 1;
          if (rawbits[i]) {
            res |= 1;
          }
        }
        return res;
      }
      /**
       * Reads a code of length 8 in an array of bits, padding with zeros
       */
      static readByte(rawbits, startIndex) {
        let n = rawbits.length - startIndex;
        if (n >= 8) {
          return Decoder2.readCode(rawbits, startIndex, 8);
        }
        return Decoder2.readCode(rawbits, startIndex, n) << 8 - n;
      }
      /**
       * Packs a bit array into bytes, most significant bit first
       */
      static convertBoolArrayToByteArray(boolArr) {
        let byteArr = new Uint8Array((boolArr.length + 7) / 8);
        for (let i = 0; i < byteArr.length; i++) {
          byteArr[i] = Decoder2.readByte(boolArr, 8 * i);
        }
        return byteArr;
      }
      totalBitsInLayer(layers, compact) {
        return ((compact ? 88 : 112) + 16 * layers) * layers;
      }
    }
    Decoder2.UPPER_TABLE = [
      "CTRL_PS",
      " ",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "CTRL_LL",
      "CTRL_ML",
      "CTRL_DL",
      "CTRL_BS"
    ];
    Decoder2.LOWER_TABLE = [
      "CTRL_PS",
      " ",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "CTRL_US",
      "CTRL_ML",
      "CTRL_DL",
      "CTRL_BS"
    ];
    Decoder2.MIXED_TABLE = [
      // Module parse failed: Octal literal in strict mode (50:29)
      // so number string were scaped
      "CTRL_PS",
      " ",
      "\\1",
      "\\2",
      "\\3",
      "\\4",
      "\\5",
      "\\6",
      "\\7",
      "\b",
      "	",
      "\n",
      "\\13",
      "\f",
      "\r",
      "\\33",
      "\\34",
      "\\35",
      "\\36",
      "\\37",
      "@",
      "\\",
      "^",
      "_",
      "`",
      "|",
      "~",
      "\\177",
      "CTRL_LL",
      "CTRL_UL",
      "CTRL_PL",
      "CTRL_BS"
    ];
    Decoder2.PUNCT_TABLE = [
      "",
      "\r",
      "\r\n",
      ". ",
      ", ",
      ": ",
      "!",
      '"',
      "#",
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "?",
      "[",
      "]",
      "{",
      "}",
      "CTRL_UL"
    ];
    Decoder2.DIGIT_TABLE = [
      "CTRL_PS",
      " ",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      ",",
      ".",
      "CTRL_UL",
      "CTRL_US"
    ];
    class MathUtils {
      constructor() {
      }
      /**
       * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its
       * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut
       * differ slightly from {@link Math#round(float)} in that half rounds down for negative
       * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.
       *
       * @param d real value to round
       * @return nearest {@code int}
       */
      static round(d) {
        if (NaN === d)
          return 0;
        if (d <= Number.MIN_SAFE_INTEGER)
          return Number.MIN_SAFE_INTEGER;
        if (d >= Number.MAX_SAFE_INTEGER)
          return Number.MAX_SAFE_INTEGER;
        return (
          /*(int) */
          d + (d < 0 ? -0.5 : 0.5) | 0
        );
      }
      // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js
      /**
       * @param aX point A x coordinate
       * @param aY point A y coordinate
       * @param bX point B x coordinate
       * @param bY point B y coordinate
       * @return Euclidean distance between points A and B
       */
      static distance(aX, aY, bX, bY) {
        const xDiff = aX - bX;
        const yDiff = aY - bY;
        return (
          /*(float) */
          Math.sqrt(xDiff * xDiff + yDiff * yDiff)
        );
      }
      /**
       * @param aX point A x coordinate
       * @param aY point A y coordinate
       * @param bX point B x coordinate
       * @param bY point B y coordinate
       * @return Euclidean distance between points A and B
       */
      // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {
      //   const xDiff = aX - bX
      //   const yDiff = aY - bY
      //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);
      // }
      /**
       * @param array values to sum
       * @return sum of values in array
       */
      static sum(array) {
        let count = 0;
        for (let i = 0, length = array.length; i !== length; i++) {
          const a = array[i];
          count += a;
        }
        return count;
      }
    }
    class Float {
      /**
       * SincTS has no difference between int and float, there's all numbers,
       * this is used only to polyfill Java code.
       */
      static floatToIntBits(f2) {
        return f2;
      }
    }
    Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;
    class ResultPoint {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      getX() {
        return this.x;
      }
      getY() {
        return this.y;
      }
      /*@Override*/
      equals(other) {
        if (other instanceof ResultPoint) {
          const otherPoint = other;
          return this.x === otherPoint.x && this.y === otherPoint.y;
        }
        return false;
      }
      /*@Override*/
      hashCode() {
        return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);
      }
      /*@Override*/
      toString() {
        return "(" + this.x + "," + this.y + ")";
      }
      /**
       * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC
       * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.
       *
       * @param patterns array of three {@code ResultPoint} to order
       */
      static orderBestPatterns(patterns) {
        const zeroOneDistance = this.distance(patterns[0], patterns[1]);
        const oneTwoDistance = this.distance(patterns[1], patterns[2]);
        const zeroTwoDistance = this.distance(patterns[0], patterns[2]);
        let pointA;
        let pointB;
        let pointC;
        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
          pointB = patterns[0];
          pointA = patterns[1];
          pointC = patterns[2];
        } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
          pointB = patterns[1];
          pointA = patterns[0];
          pointC = patterns[2];
        } else {
          pointB = patterns[2];
          pointA = patterns[0];
          pointC = patterns[1];
        }
        if (this.crossProductZ(pointA, pointB, pointC) < 0) {
          const temp = pointA;
          pointA = pointC;
          pointC = temp;
        }
        patterns[0] = pointA;
        patterns[1] = pointB;
        patterns[2] = pointC;
      }
      /**
       * @param pattern1 first pattern
       * @param pattern2 second pattern
       * @return distance between two points
       */
      static distance(pattern1, pattern2) {
        return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
      }
      /**
       * Returns the z component of the cross product between vectors BC and BA.
       */
      static crossProductZ(pointA, pointB, pointC) {
        const bX = pointB.x;
        const bY = pointB.y;
        return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);
      }
    }
    class DetectorResult {
      constructor(bits, points) {
        this.bits = bits;
        this.points = points;
      }
      getBits() {
        return this.bits;
      }
      getPoints() {
        return this.points;
      }
    }
    class AztecDetectorResult extends DetectorResult {
      constructor(bits, points, compact, nbDatablocks, nbLayers) {
        super(bits, points);
        this.compact = compact;
        this.nbDatablocks = nbDatablocks;
        this.nbLayers = nbLayers;
      }
      getNbLayers() {
        return this.nbLayers;
      }
      getNbDatablocks() {
        return this.nbDatablocks;
      }
      isCompact() {
        return this.compact;
      }
    }
    class WhiteRectangleDetector {
      // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {
      //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)
      // }
      /**
       * @param image barcode image to find a rectangle in
       * @param initSize initial size of search area around center
       * @param x x position of search center
       * @param y y position of search center
       * @throws NotFoundException if image is too small to accommodate {@code initSize}
       */
      constructor(image, initSize, x, y) {
        this.image = image;
        this.height = image.getHeight();
        this.width = image.getWidth();
        if (void 0 === initSize || null === initSize) {
          initSize = WhiteRectangleDetector.INIT_SIZE;
        }
        if (void 0 === x || null === x) {
          x = image.getWidth() / 2 | 0;
        }
        if (void 0 === y || null === y) {
          y = image.getHeight() / 2 | 0;
        }
        const halfsize = initSize / 2 | 0;
        this.leftInit = x - halfsize;
        this.rightInit = x + halfsize;
        this.upInit = y - halfsize;
        this.downInit = y + halfsize;
        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {
          throw new NotFoundException();
        }
      }
      /**
       * <p>
       * Detects a candidate barcode-like rectangular region within an image. It
       * starts around the center of the image, increases the size of the candidate
       * region until it finds a white rectangular region.
       * </p>
       *
       * @return {@link ResultPoint}[] describing the corners of the rectangular
       *         region. The first and last points are opposed on the diagonal, as
       *         are the second and third. The first point will be the topmost
       *         point and the last, the bottommost. The second point will be
       *         leftmost and the third, the rightmost
       * @throws NotFoundException if no Data Matrix Code can be found
       */
      detect() {
        let left = this.leftInit;
        let right = this.rightInit;
        let up = this.upInit;
        let down = this.downInit;
        let sizeExceeded = false;
        let aBlackPointFoundOnBorder = true;
        let atLeastOneBlackPointFoundOnBorder = false;
        let atLeastOneBlackPointFoundOnRight = false;
        let atLeastOneBlackPointFoundOnBottom = false;
        let atLeastOneBlackPointFoundOnLeft = false;
        let atLeastOneBlackPointFoundOnTop = false;
        const width = this.width;
        const height = this.height;
        while (aBlackPointFoundOnBorder) {
          aBlackPointFoundOnBorder = false;
          let rightBorderNotWhite = true;
          while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {
            rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);
            if (rightBorderNotWhite) {
              right++;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnRight = true;
            } else if (!atLeastOneBlackPointFoundOnRight) {
              right++;
            }
          }
          if (right >= width) {
            sizeExceeded = true;
            break;
          }
          let bottomBorderNotWhite = true;
          while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {
            bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);
            if (bottomBorderNotWhite) {
              down++;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnBottom = true;
            } else if (!atLeastOneBlackPointFoundOnBottom) {
              down++;
            }
          }
          if (down >= height) {
            sizeExceeded = true;
            break;
          }
          let leftBorderNotWhite = true;
          while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {
            leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);
            if (leftBorderNotWhite) {
              left--;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnLeft = true;
            } else if (!atLeastOneBlackPointFoundOnLeft) {
              left--;
            }
          }
          if (left < 0) {
            sizeExceeded = true;
            break;
          }
          let topBorderNotWhite = true;
          while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {
            topBorderNotWhite = this.containsBlackPoint(left, right, up, true);
            if (topBorderNotWhite) {
              up--;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnTop = true;
            } else if (!atLeastOneBlackPointFoundOnTop) {
              up--;
            }
          }
          if (up < 0) {
            sizeExceeded = true;
            break;
          }
          if (aBlackPointFoundOnBorder) {
            atLeastOneBlackPointFoundOnBorder = true;
          }
        }
        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {
          const maxSize = right - left;
          let z = null;
          for (let i = 1; z === null && i < maxSize; i++) {
            z = this.getBlackPointOnSegment(left, down - i, left + i, down);
          }
          if (z == null) {
            throw new NotFoundException();
          }
          let t = null;
          for (let i = 1; t === null && i < maxSize; i++) {
            t = this.getBlackPointOnSegment(left, up + i, left + i, up);
          }
          if (t == null) {
            throw new NotFoundException();
          }
          let x = null;
          for (let i = 1; x === null && i < maxSize; i++) {
            x = this.getBlackPointOnSegment(right, up + i, right - i, up);
          }
          if (x == null) {
            throw new NotFoundException();
          }
          let y = null;
          for (let i = 1; y === null && i < maxSize; i++) {
            y = this.getBlackPointOnSegment(right, down - i, right - i, down);
          }
          if (y == null) {
            throw new NotFoundException();
          }
          return this.centerEdges(y, z, x, t);
        } else {
          throw new NotFoundException();
        }
      }
      getBlackPointOnSegment(aX, aY, bX, bY) {
        const dist2 = MathUtils.round(MathUtils.distance(aX, aY, bX, bY));
        const xStep = (bX - aX) / dist2;
        const yStep = (bY - aY) / dist2;
        const image = this.image;
        for (let i = 0; i < dist2; i++) {
          const x = MathUtils.round(aX + i * xStep);
          const y = MathUtils.round(aY + i * yStep);
          if (image.get(x, y)) {
            return new ResultPoint(x, y);
          }
        }
        return null;
      }
      /**
       * recenters the points of a constant distance towards the center
       *
       * @param y bottom most point
       * @param z left most point
       * @param x right most point
       * @param t top most point
       * @return {@link ResultPoint}[] describing the corners of the rectangular
       *         region. The first and last points are opposed on the diagonal, as
       *         are the second and third. The first point will be the topmost
       *         point and the last, the bottommost. The second point will be
       *         leftmost and the third, the rightmost
       */
      centerEdges(y, z, x, t) {
        const yi = y.getX();
        const yj = y.getY();
        const zi = z.getX();
        const zj = z.getY();
        const xi = x.getX();
        const xj = x.getY();
        const ti = t.getX();
        const tj = t.getY();
        const CORR = WhiteRectangleDetector.CORR;
        if (yi < this.width / 2) {
          return [
            new ResultPoint(ti - CORR, tj + CORR),
            new ResultPoint(zi + CORR, zj + CORR),
            new ResultPoint(xi - CORR, xj - CORR),
            new ResultPoint(yi + CORR, yj - CORR)
          ];
        } else {
          return [
            new ResultPoint(ti + CORR, tj + CORR),
            new ResultPoint(zi + CORR, zj - CORR),
            new ResultPoint(xi - CORR, xj + CORR),
            new ResultPoint(yi - CORR, yj - CORR)
          ];
        }
      }
      /**
       * Determines whether a segment contains a black point
       *
       * @param a          min value of the scanned coordinate
       * @param b          max value of the scanned coordinate
       * @param fixed      value of fixed coordinate
       * @param horizontal set to true if scan must be horizontal, false if vertical
       * @return true if a black point has been found, else false.
       */
      containsBlackPoint(a, b, fixed, horizontal) {
        const image = this.image;
        if (horizontal) {
          for (let x = a; x <= b; x++) {
            if (image.get(x, fixed)) {
              return true;
            }
          }
        } else {
          for (let y = a; y <= b; y++) {
            if (image.get(fixed, y)) {
              return true;
            }
          }
        }
        return false;
      }
    }
    WhiteRectangleDetector.INIT_SIZE = 10;
    WhiteRectangleDetector.CORR = 1;
    class GridSampler {
      /**
       * <p>Checks a set of points that have been transformed to sample points on an image against
       * the image's dimensions to see if the point are even within the image.</p>
       *
       * <p>This method will actually "nudge" the endpoints back onto the image if they are found to be
       * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder
       * patterns in an image where the QR Code runs all the way to the image border.</p>
       *
       * <p>For efficiency, the method will check points from either end of the line until one is found
       * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>
       *
       * @param image image into which the points should map
       * @param points actual points in x1,y1,...,xn,yn form
       * @throws NotFoundException if an endpoint is lies outside the image boundaries
       */
      static checkAndNudgePoints(image, points) {
        const width = image.getWidth();
        const height = image.getHeight();
        let nudged = true;
        for (let offset = 0; offset < points.length && nudged; offset += 2) {
          const x = Math.floor(points[offset]);
          const y = Math.floor(points[offset + 1]);
          if (x < -1 || x > width || y < -1 || y > height) {
            throw new NotFoundException();
          }
          nudged = false;
          if (x === -1) {
            points[offset] = 0;
            nudged = true;
          } else if (x === width) {
            points[offset] = width - 1;
            nudged = true;
          }
          if (y === -1) {
            points[offset + 1] = 0;
            nudged = true;
          } else if (y === height) {
            points[offset + 1] = height - 1;
            nudged = true;
          }
        }
        nudged = true;
        for (let offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
          const x = Math.floor(points[offset]);
          const y = Math.floor(points[offset + 1]);
          if (x < -1 || x > width || y < -1 || y > height) {
            throw new NotFoundException();
          }
          nudged = false;
          if (x === -1) {
            points[offset] = 0;
            nudged = true;
          } else if (x === width) {
            points[offset] = width - 1;
            nudged = true;
          }
          if (y === -1) {
            points[offset + 1] = 0;
            nudged = true;
          } else if (y === height) {
            points[offset + 1] = height - 1;
            nudged = true;
          }
        }
      }
    }
    class PerspectiveTransform {
      constructor(a11, a21, a31, a12, a22, a32, a13, a23, a33) {
        this.a11 = a11;
        this.a21 = a21;
        this.a31 = a31;
        this.a12 = a12;
        this.a22 = a22;
        this.a32 = a32;
        this.a13 = a13;
        this.a23 = a23;
        this.a33 = a33;
      }
      static quadrilateralToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {
        const qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
        const sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
        return sToQ.times(qToS);
      }
      transformPoints(points) {
        const max = points.length;
        const a11 = this.a11;
        const a12 = this.a12;
        const a13 = this.a13;
        const a21 = this.a21;
        const a22 = this.a22;
        const a23 = this.a23;
        const a31 = this.a31;
        const a32 = this.a32;
        const a33 = this.a33;
        for (let i = 0; i < max; i += 2) {
          const x = points[i];
          const y = points[i + 1];
          const denominator = a13 * x + a23 * y + a33;
          points[i] = (a11 * x + a21 * y + a31) / denominator;
          points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
        }
      }
      transformPointsWithValues(xValues, yValues) {
        const a11 = this.a11;
        const a12 = this.a12;
        const a13 = this.a13;
        const a21 = this.a21;
        const a22 = this.a22;
        const a23 = this.a23;
        const a31 = this.a31;
        const a32 = this.a32;
        const a33 = this.a33;
        const n = xValues.length;
        for (let i = 0; i < n; i++) {
          const x = xValues[i];
          const y = yValues[i];
          const denominator = a13 * x + a23 * y + a33;
          xValues[i] = (a11 * x + a21 * y + a31) / denominator;
          yValues[i] = (a12 * x + a22 * y + a32) / denominator;
        }
      }
      static squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3) {
        const dx3 = x0 - x1 + x2 - x3;
        const dy3 = y0 - y1 + y2 - y3;
        if (dx3 === 0 && dy3 === 0) {
          return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0, 0, 1);
        } else {
          const dx1 = x1 - x2;
          const dx2 = x3 - x2;
          const dy1 = y1 - y2;
          const dy2 = y3 - y2;
          const denominator = dx1 * dy2 - dx2 * dy1;
          const a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
          const a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
          return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1);
        }
      }
      static quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3) {
        return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
      }
      buildAdjoint() {
        return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
      }
      times(other) {
        return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
      }
    }
    class DefaultGridSampler extends GridSampler {
      /*@Override*/
      sampleGrid(image, dimensionX, dimensionY, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY) {
        const transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
        return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
      }
      /*@Override*/
      sampleGridWithTransform(image, dimensionX, dimensionY, transform) {
        if (dimensionX <= 0 || dimensionY <= 0) {
          throw new NotFoundException();
        }
        const bits = new BitMatrix(dimensionX, dimensionY);
        const points = new Float32Array(2 * dimensionX);
        for (let y = 0; y < dimensionY; y++) {
          const max = points.length;
          const iValue = y + 0.5;
          for (let x = 0; x < max; x += 2) {
            points[x] = x / 2 + 0.5;
            points[x + 1] = iValue;
          }
          transform.transformPoints(points);
          GridSampler.checkAndNudgePoints(image, points);
          try {
            for (let x = 0; x < max; x += 2) {
              if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {
                bits.set(x / 2, y);
              }
            }
          } catch (aioobe) {
            throw new NotFoundException();
          }
        }
        return bits;
      }
    }
    class GridSamplerInstance {
      /**
       * Sets the implementation of GridSampler used by the library. One global
       * instance is stored, which may sound problematic. But, the implementation provided
       * ought to be appropriate for the entire platform, and all uses of this library
       * in the whole lifetime of the JVM. For instance, an Android activity can swap in
       * an implementation that takes advantage of native platform libraries.
       *
       * @param newGridSampler The platform-specific object to install.
       */
      static setGridSampler(newGridSampler) {
        GridSamplerInstance.gridSampler = newGridSampler;
      }
      /**
       * @return the current implementation of GridSampler
       */
      static getInstance() {
        return GridSamplerInstance.gridSampler;
      }
    }
    GridSamplerInstance.gridSampler = new DefaultGridSampler();
    class Point2 {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      toResultPoint() {
        return new ResultPoint(this.getX(), this.getY());
      }
      getX() {
        return this.x;
      }
      getY() {
        return this.y;
      }
    }
    class Detector {
      constructor(image) {
        this.EXPECTED_CORNER_BITS = new Int32Array([
          3808,
          476,
          2107,
          1799
        ]);
        this.image = image;
      }
      detect() {
        return this.detectMirror(false);
      }
      /**
       * Detects an Aztec Code in an image.
       *
       * @param isMirror if true, image is a mirror-image of original
       * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code
       * @throws NotFoundException if no Aztec Code can be found
       */
      detectMirror(isMirror) {
        let pCenter = this.getMatrixCenter();
        let bullsEyeCorners = this.getBullsEyeCorners(pCenter);
        if (isMirror) {
          let temp = bullsEyeCorners[0];
          bullsEyeCorners[0] = bullsEyeCorners[2];
          bullsEyeCorners[2] = temp;
        }
        this.extractParameters(bullsEyeCorners);
        let bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);
        let corners = this.getMatrixCornerPoints(bullsEyeCorners);
        return new AztecDetectorResult(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);
      }
      /**
       * Extracts the number of data layers and data blocks from the layer around the bull's eye.
       *
       * @param bullsEyeCorners the array of bull's eye corners
       * @throws NotFoundException in case of too many errors or invalid parameters
       */
      extractParameters(bullsEyeCorners) {
        if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {
          throw new NotFoundException();
        }
        let length = 2 * this.nbCenterLayers;
        let sides = new Int32Array([
          this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),
          this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),
          this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),
          this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length)
          // Top
        ]);
        this.shift = this.getRotation(sides, length);
        let parameterData = 0;
        for (let i = 0; i < 4; i++) {
          let side = sides[(this.shift + i) % 4];
          if (this.compact) {
            parameterData <<= 7;
            parameterData += side >> 1 & 127;
          } else {
            parameterData <<= 10;
            parameterData += (side >> 2 & 31 << 5) + (side >> 1 & 31);
          }
        }
        let correctedData = this.getCorrectedParameterData(parameterData, this.compact);
        if (this.compact) {
          this.nbLayers = (correctedData >> 6) + 1;
          this.nbDataBlocks = (correctedData & 63) + 1;
        } else {
          this.nbLayers = (correctedData >> 11) + 1;
          this.nbDataBlocks = (correctedData & 2047) + 1;
        }
      }
      getRotation(sides, length) {
        let cornerBits = 0;
        sides.forEach((side, idx, arr) => {
          let t = (side >> length - 2 << 1) + (side & 1);
          cornerBits = (cornerBits << 3) + t;
        });
        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);
        for (let shift = 0; shift < 4; shift++) {
          if (Integer.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {
            return shift;
          }
        }
        throw new NotFoundException();
      }
      /**
       * Corrects the parameter bits using Reed-Solomon algorithm.
       *
       * @param parameterData parameter bits
       * @param compact true if this is a compact Aztec code
       * @throws NotFoundException if the array contains too many errors
       */
      getCorrectedParameterData(parameterData, compact) {
        let numCodewords;
        let numDataCodewords;
        if (compact) {
          numCodewords = 7;
          numDataCodewords = 2;
        } else {
          numCodewords = 10;
          numDataCodewords = 4;
        }
        let numECCodewords = numCodewords - numDataCodewords;
        let parameterWords = new Int32Array(numCodewords);
        for (let i = numCodewords - 1; i >= 0; --i) {
          parameterWords[i] = parameterData & 15;
          parameterData >>= 4;
        }
        try {
          let rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);
          rsDecoder.decode(parameterWords, numECCodewords);
        } catch (ignored) {
          throw new NotFoundException();
        }
        let result = 0;
        for (let i = 0; i < numDataCodewords; i++) {
          result = (result << 4) + parameterWords[i];
        }
        return result;
      }
      /**
       * Finds the corners of a bull-eye centered on the passed point.
       * This returns the centers of the diagonal points just outside the bull's eye
       * Returns [topRight, bottomRight, bottomLeft, topLeft]
       *
       * @param pCenter Center point
       * @return The corners of the bull-eye
       * @throws NotFoundException If no valid bull-eye can be found
       */
      getBullsEyeCorners(pCenter) {
        let pina = pCenter;
        let pinb = pCenter;
        let pinc = pCenter;
        let pind = pCenter;
        let color = true;
        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
          let pouta = this.getFirstDifferent(pina, color, 1, -1);
          let poutb = this.getFirstDifferent(pinb, color, 1, 1);
          let poutc = this.getFirstDifferent(pinc, color, -1, 1);
          let poutd = this.getFirstDifferent(pind, color, -1, -1);
          if (this.nbCenterLayers > 2) {
            let q = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));
            if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {
              break;
            }
          }
          pina = pouta;
          pinb = poutb;
          pinc = poutc;
          pind = poutd;
          color = !color;
        }
        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {
          throw new NotFoundException();
        }
        this.compact = this.nbCenterLayers === 5;
        let pinax = new ResultPoint(pina.getX() + 0.5, pina.getY() - 0.5);
        let pinbx = new ResultPoint(pinb.getX() + 0.5, pinb.getY() + 0.5);
        let pincx = new ResultPoint(pinc.getX() - 0.5, pinc.getY() + 0.5);
        let pindx = new ResultPoint(pind.getX() - 0.5, pind.getY() - 0.5);
        return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);
      }
      /**
       * Finds a candidate center point of an Aztec code from an image
       *
       * @return the center point
       */
      getMatrixCenter() {
        let pointA;
        let pointB;
        let pointC;
        let pointD;
        try {
          let cornerPoints = new WhiteRectangleDetector(this.image).detect();
          pointA = cornerPoints[0];
          pointB = cornerPoints[1];
          pointC = cornerPoints[2];
          pointD = cornerPoints[3];
        } catch (e) {
          let cx2 = this.image.getWidth() / 2;
          let cy2 = this.image.getHeight() / 2;
          pointA = this.getFirstDifferent(new Point2(cx2 + 7, cy2 - 7), false, 1, -1).toResultPoint();
          pointB = this.getFirstDifferent(new Point2(cx2 + 7, cy2 + 7), false, 1, 1).toResultPoint();
          pointC = this.getFirstDifferent(new Point2(cx2 - 7, cy2 + 7), false, -1, 1).toResultPoint();
          pointD = this.getFirstDifferent(new Point2(cx2 - 7, cy2 - 7), false, -1, -1).toResultPoint();
        }
        let cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
        let cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
        try {
          let cornerPoints = new WhiteRectangleDetector(this.image, 15, cx, cy).detect();
          pointA = cornerPoints[0];
          pointB = cornerPoints[1];
          pointC = cornerPoints[2];
          pointD = cornerPoints[3];
        } catch (e) {
          pointA = this.getFirstDifferent(new Point2(cx + 7, cy - 7), false, 1, -1).toResultPoint();
          pointB = this.getFirstDifferent(new Point2(cx + 7, cy + 7), false, 1, 1).toResultPoint();
          pointC = this.getFirstDifferent(new Point2(cx - 7, cy + 7), false, -1, 1).toResultPoint();
          pointD = this.getFirstDifferent(new Point2(cx - 7, cy - 7), false, -1, -1).toResultPoint();
        }
        cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
        cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
        return new Point2(cx, cy);
      }
      /**
       * Gets the Aztec code corners from the bull's eye corners and the parameters.
       *
       * @param bullsEyeCorners the array of bull's eye corners
       * @return the array of aztec code corners
       */
      getMatrixCornerPoints(bullsEyeCorners) {
        return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());
      }
      /**
       * Creates a BitMatrix by sampling the provided image.
       * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the
       * diagonal just outside the bull's eye.
       */
      sampleGrid(image, topLeft, topRight, bottomRight, bottomLeft) {
        let sampler = GridSamplerInstance.getInstance();
        let dimension = this.getDimension();
        let low = dimension / 2 - this.nbCenterLayers;
        let high = dimension / 2 + this.nbCenterLayers;
        return sampler.sampleGrid(
          image,
          dimension,
          dimension,
          low,
          low,
          // topleft
          high,
          low,
          // topright
          high,
          high,
          // bottomright
          low,
          high,
          // bottomleft
          topLeft.getX(),
          topLeft.getY(),
          topRight.getX(),
          topRight.getY(),
          bottomRight.getX(),
          bottomRight.getY(),
          bottomLeft.getX(),
          bottomLeft.getY()
        );
      }
      /**
       * Samples a line.
       *
       * @param p1   start point (inclusive)
       * @param p2   end point (exclusive)
       * @param size number of bits
       * @return the array of bits as an int (first bit is high-order bit of result)
       */
      sampleLine(p1, p2, size) {
        let result = 0;
        let d = this.distanceResultPoint(p1, p2);
        let moduleSize = d / size;
        let px = p1.getX();
        let py = p1.getY();
        let dx = moduleSize * (p2.getX() - p1.getX()) / d;
        let dy = moduleSize * (p2.getY() - p1.getY()) / d;
        for (let i = 0; i < size; i++) {
          if (this.image.get(MathUtils.round(px + i * dx), MathUtils.round(py + i * dy))) {
            result |= 1 << size - i - 1;
          }
        }
        return result;
      }
      /**
       * @return true if the border of the rectangle passed in parameter is compound of white points only
       *         or black points only
       */
      isWhiteOrBlackRectangle(p1, p2, p3, p4) {
        let corr = 3;
        p1 = new Point2(p1.getX() - corr, p1.getY() + corr);
        p2 = new Point2(p2.getX() - corr, p2.getY() - corr);
        p3 = new Point2(p3.getX() + corr, p3.getY() - corr);
        p4 = new Point2(p4.getX() + corr, p4.getY() + corr);
        let cInit = this.getColor(p4, p1);
        if (cInit === 0) {
          return false;
        }
        let c = this.getColor(p1, p2);
        if (c !== cInit) {
          return false;
        }
        c = this.getColor(p2, p3);
        if (c !== cInit) {
          return false;
        }
        c = this.getColor(p3, p4);
        return c === cInit;
      }
      /**
       * Gets the color of a segment
       *
       * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else
       */
      getColor(p1, p2) {
        let d = this.distancePoint(p1, p2);
        let dx = (p2.getX() - p1.getX()) / d;
        let dy = (p2.getY() - p1.getY()) / d;
        let error = 0;
        let px = p1.getX();
        let py = p1.getY();
        let colorModel = this.image.get(p1.getX(), p1.getY());
        let iMax = Math.ceil(d);
        for (let i = 0; i < iMax; i++) {
          px += dx;
          py += dy;
          if (this.image.get(MathUtils.round(px), MathUtils.round(py)) !== colorModel) {
            error++;
          }
        }
        let errRatio = error / d;
        if (errRatio > 0.1 && errRatio < 0.9) {
          return 0;
        }
        return errRatio <= 0.1 === colorModel ? 1 : -1;
      }
      /**
       * Gets the coordinate of the first point with a different color in the given direction
       */
      getFirstDifferent(init, color, dx, dy) {
        let x = init.getX() + dx;
        let y = init.getY() + dy;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
          x += dx;
          y += dy;
        }
        x -= dx;
        y -= dy;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
          x += dx;
        }
        x -= dx;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
          y += dy;
        }
        y -= dy;
        return new Point2(x, y);
      }
      /**
       * Expand the square represented by the corner points by pushing out equally in all directions
       *
       * @param cornerPoints the corners of the square, which has the bull's eye at its center
       * @param oldSide the original length of the side of the square in the target bit matrix
       * @param newSide the new length of the size of the square in the target bit matrix
       * @return the corners of the expanded square
       */
      expandSquare(cornerPoints, oldSide, newSide) {
        let ratio = newSide / (2 * oldSide);
        let dx = cornerPoints[0].getX() - cornerPoints[2].getX();
        let dy = cornerPoints[0].getY() - cornerPoints[2].getY();
        let centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2;
        let centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2;
        let result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
        let result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
        dx = cornerPoints[1].getX() - cornerPoints[3].getX();
        dy = cornerPoints[1].getY() - cornerPoints[3].getY();
        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2;
        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2;
        let result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
        let result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
        let results = [result0, result1, result2, result3];
        return results;
      }
      isValid(x, y) {
        return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();
      }
      isValidPoint(point5) {
        let x = MathUtils.round(point5.getX());
        let y = MathUtils.round(point5.getY());
        return this.isValid(x, y);
      }
      distancePoint(a, b) {
        return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());
      }
      distanceResultPoint(a, b) {
        return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());
      }
      getDimension() {
        if (this.compact) {
          return 4 * this.nbLayers + 11;
        }
        if (this.nbLayers <= 4) {
          return 4 * this.nbLayers + 15;
        }
        return 4 * this.nbLayers + 2 * (Integer.truncDivision(this.nbLayers - 4, 8) + 1) + 15;
      }
    }
    class AztecReader {
      /**
       * Locates and decodes a Data Matrix code in an image.
       *
       * @return a String representing the content encoded by the Data Matrix code
       * @throws NotFoundException if a Data Matrix code cannot be found
       * @throws FormatException if a Data Matrix code cannot be decoded
       */
      decode(image, hints = null) {
        let exception = null;
        let detector = new Detector(image.getBlackMatrix());
        let points = null;
        let decoderResult = null;
        try {
          let detectorResult = detector.detectMirror(false);
          points = detectorResult.getPoints();
          this.reportFoundResultPoints(hints, points);
          decoderResult = new Decoder2().decode(detectorResult);
        } catch (e) {
          exception = e;
        }
        if (decoderResult == null) {
          try {
            let detectorResult = detector.detectMirror(true);
            points = detectorResult.getPoints();
            this.reportFoundResultPoints(hints, points);
            decoderResult = new Decoder2().decode(detectorResult);
          } catch (e) {
            if (exception != null) {
              throw exception;
            }
            throw e;
          }
        }
        let result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat$1.AZTEC, System.currentTimeMillis());
        let byteSegments = decoderResult.getByteSegments();
        if (byteSegments != null) {
          result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
        }
        let ecLevel = decoderResult.getECLevel();
        if (ecLevel != null) {
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        return result;
      }
      reportFoundResultPoints(hints, points) {
        if (hints != null) {
          let rpcb = hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
          if (rpcb != null) {
            points.forEach((point5, idx, arr) => {
              rpcb.foundPossibleResultPoint(point5);
            });
          }
        }
      }
      // @Override
      reset() {
      }
    }
    class BrowserAztecCodeReader extends BrowserCodeReader {
      /**
       * Creates an instance of BrowserAztecCodeReader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       *
       * @memberOf BrowserAztecCodeReader
       */
      constructor(timeBetweenScansMillis = 500) {
        super(new AztecReader(), timeBetweenScansMillis);
      }
    }
    class OneDReader {
      /*
      @Override
      public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {
        return decode(image, null);
      }
      */
      // Note that we don't try rotation without the try harder flag, even if rotation was supported.
      // @Override
      decode(image, hints) {
        try {
          return this.doDecode(image, hints);
        } catch (nfe) {
          const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;
          if (tryHarder && image.isRotateSupported()) {
            const rotatedImage = image.rotateCounterClockwise();
            const result = this.doDecode(rotatedImage, hints);
            const metadata = result.getResultMetadata();
            let orientation = 270;
            if (metadata !== null && metadata.get(ResultMetadataType$1.ORIENTATION) === true) {
              orientation = orientation + metadata.get(ResultMetadataType$1.ORIENTATION) % 360;
            }
            result.putMetadata(ResultMetadataType$1.ORIENTATION, orientation);
            const points = result.getResultPoints();
            if (points !== null) {
              const height = rotatedImage.getHeight();
              for (let i = 0; i < points.length; i++) {
                points[i] = new ResultPoint(height - points[i].getY() - 1, points[i].getX());
              }
            }
            return result;
          } else {
            throw new NotFoundException();
          }
        }
      }
      // @Override
      reset() {
      }
      /**
       * We're going to examine rows from the middle outward, searching alternately above and below the
       * middle, and farther out each time. rowStep is the number of rows between each successive
       * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then
       * middle + rowStep, then middle - (2 * rowStep), etc.
       * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily
       * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the
       * image if "trying harder".
       *
       * @param image The image to decode
       * @param hints Any hints that were requested
       * @return The contents of the decoded barcode
       * @throws NotFoundException Any spontaneous errors which occur
       */
      doDecode(image, hints) {
        const width = image.getWidth();
        const height = image.getHeight();
        let row = new BitArray(width);
        const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;
        const rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));
        let maxLines;
        if (tryHarder) {
          maxLines = height;
        } else {
          maxLines = 15;
        }
        const middle = Math.trunc(height / 2);
        for (let x = 0; x < maxLines; x++) {
          const rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);
          const isAbove = (x & 1) === 0;
          const rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);
          if (rowNumber < 0 || rowNumber >= height) {
            break;
          }
          try {
            row = image.getBlackRow(rowNumber, row);
          } catch (ignored) {
            continue;
          }
          for (let attempt = 0; attempt < 2; attempt++) {
            if (attempt === 1) {
              row.reverse();
              if (hints && hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK) === true) {
                const newHints = /* @__PURE__ */ new Map();
                hints.forEach((hint, key2) => newHints.set(key2, hint));
                newHints.delete(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                hints = newHints;
              }
            }
            try {
              const result = this.decodeRow(rowNumber, row, hints);
              if (attempt === 1) {
                result.putMetadata(ResultMetadataType$1.ORIENTATION, 180);
                const points = result.getResultPoints();
                if (points !== null) {
                  points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());
                  points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());
                }
              }
              return result;
            } catch (re) {
            }
          }
        }
        throw new NotFoundException();
      }
      /**
       * Records the size of successive runs of white and black pixels in a row, starting at a given point.
       * The values are recorded in the given array, and the number of runs recorded is equal to the size
       * of the array. If the row starts on a white pixel at the given start point, then the first count
       * recorded is the run of white pixels starting from that point; likewise it is the count of a run
       * of black pixels if the row begin on a black pixels at that point.
       *
       * @param row row to count from
       * @param start offset into row to start at
       * @param counters array into which to record counts
       * @throws NotFoundException if counters cannot be filled entirely from row before running out
       *  of pixels
       */
      static recordPattern(row, start, counters) {
        const numCounters = counters.length;
        for (let index2 = 0; index2 < numCounters; index2++)
          counters[index2] = 0;
        const end = row.getSize();
        if (start >= end) {
          throw new NotFoundException();
        }
        let isWhite = !row.get(start);
        let counterPosition = 0;
        let i = start;
        while (i < end) {
          if (row.get(i) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (++counterPosition === numCounters) {
              break;
            } else {
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          i++;
        }
        if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i === end)) {
          throw new NotFoundException();
        }
      }
      static recordPatternInReverse(row, start, counters) {
        let numTransitionsLeft = counters.length;
        let last = row.get(start);
        while (start > 0 && numTransitionsLeft >= 0) {
          if (row.get(--start) !== last) {
            numTransitionsLeft--;
            last = !last;
          }
        }
        if (numTransitionsLeft >= 0) {
          throw new NotFoundException();
        }
        OneDReader.recordPattern(row, start + 1, counters);
      }
      /**
       * Determines how closely a set of observed counts of runs of black/white values matches a given
       * target pattern. This is reported as the ratio of the total variance from the expected pattern
       * proportions across all pattern elements, to the length of the pattern.
       *
       * @param counters observed counters
       * @param pattern expected pattern
       * @param maxIndividualVariance The most any counter can differ before we give up
       * @return ratio of total variance between counters and pattern compared to total pattern size
       */
      static patternMatchVariance(counters, pattern, maxIndividualVariance) {
        const numCounters = counters.length;
        let total = 0;
        let patternLength = 0;
        for (let i = 0; i < numCounters; i++) {
          total += counters[i];
          patternLength += pattern[i];
        }
        if (total < patternLength) {
          return Number.POSITIVE_INFINITY;
        }
        const unitBarWidth = total / patternLength;
        maxIndividualVariance *= unitBarWidth;
        let totalVariance = 0;
        for (let x = 0; x < numCounters; x++) {
          const counter = counters[x];
          const scaledPattern = pattern[x] * unitBarWidth;
          const variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
          if (variance > maxIndividualVariance) {
            return Number.POSITIVE_INFINITY;
          }
          totalVariance += variance;
        }
        return totalVariance / total;
      }
    }
    class Code128Reader extends OneDReader {
      static findStartPattern(row) {
        const width = row.getSize();
        const rowOffset = row.getNextSet(0);
        let counterPosition = 0;
        let counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
        let patternStart = rowOffset;
        let isWhite = false;
        const patternLength = 6;
        for (let i = rowOffset; i < width; i++) {
          if (row.get(i) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
              let bestMatch = -1;
              for (let startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {
                const variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);
                if (variance < bestVariance) {
                  bestVariance = variance;
                  bestMatch = startCode;
                }
              }
              if (bestMatch >= 0 && row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {
                return Int32Array.from([patternStart, i, bestMatch]);
              }
              patternStart += counters[0] + counters[1];
              counters = counters.slice(2, counters.length - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static decodeCode(row, counters, rowOffset) {
        OneDReader.recordPattern(row, rowOffset, counters);
        let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
        let bestMatch = -1;
        for (let d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {
          const pattern = Code128Reader.CODE_PATTERNS[d];
          const variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = d;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch;
        } else {
          throw new NotFoundException();
        }
      }
      decodeRow(rowNumber, row, hints) {
        const convertFNC1 = hints && hints.get(DecodeHintType$1.ASSUME_GS1) === true;
        const startPatternInfo = Code128Reader.findStartPattern(row);
        const startCode = startPatternInfo[2];
        let currentRawCodesIndex = 0;
        const rawCodes = new Uint8Array(20);
        rawCodes[currentRawCodesIndex++] = startCode;
        let codeSet;
        switch (startCode) {
          case Code128Reader.CODE_START_A:
            codeSet = Code128Reader.CODE_CODE_A;
            break;
          case Code128Reader.CODE_START_B:
            codeSet = Code128Reader.CODE_CODE_B;
            break;
          case Code128Reader.CODE_START_C:
            codeSet = Code128Reader.CODE_CODE_C;
            break;
          default:
            throw new FormatException();
        }
        let done = false;
        let isNextShifted = false;
        let result = "";
        let lastStart = startPatternInfo[0];
        let nextStart = startPatternInfo[1];
        const counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
        let lastCode = 0;
        let code = 0;
        let checksumTotal = startCode;
        let multiplier = 0;
        let lastCharacterWasPrintable = true;
        let upperMode = false;
        let shiftUpperMode = false;
        while (!done) {
          const unshift = isNextShifted;
          isNextShifted = false;
          lastCode = code;
          code = Code128Reader.decodeCode(row, counters, nextStart);
          rawCodes[currentRawCodesIndex++] = code;
          if (code !== Code128Reader.CODE_STOP) {
            lastCharacterWasPrintable = true;
          }
          if (code !== Code128Reader.CODE_STOP) {
            multiplier++;
            checksumTotal += multiplier * code;
          }
          lastStart = nextStart;
          nextStart += counters.reduce((previous, current) => previous + current, 0);
          switch (code) {
            case Code128Reader.CODE_START_A:
            case Code128Reader.CODE_START_B:
            case Code128Reader.CODE_START_C:
              throw new FormatException();
          }
          switch (codeSet) {
            case Code128Reader.CODE_CODE_A:
              if (code < 64) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(" ".charCodeAt(0) + code);
                } else {
                  result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                }
                shiftUpperMode = false;
              } else if (code < 96) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(code - 64);
                } else {
                  result += String.fromCharCode(code + 64);
                }
                shiftUpperMode = false;
              } else {
                if (code !== Code128Reader.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader.CODE_FNC_2:
                  case Code128Reader.CODE_FNC_3:
                    break;
                  case Code128Reader.CODE_FNC_4_A:
                    if (!upperMode && shiftUpperMode) {
                      upperMode = true;
                      shiftUpperMode = false;
                    } else if (upperMode && shiftUpperMode) {
                      upperMode = false;
                      shiftUpperMode = false;
                    } else {
                      shiftUpperMode = true;
                    }
                    break;
                  case Code128Reader.CODE_SHIFT:
                    isNextShifted = true;
                    codeSet = Code128Reader.CODE_CODE_B;
                    break;
                  case Code128Reader.CODE_CODE_B:
                    codeSet = Code128Reader.CODE_CODE_B;
                    break;
                  case Code128Reader.CODE_CODE_C:
                    codeSet = Code128Reader.CODE_CODE_C;
                    break;
                  case Code128Reader.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
            case Code128Reader.CODE_CODE_B:
              if (code < 96) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(" ".charCodeAt(0) + code);
                } else {
                  result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                }
                shiftUpperMode = false;
              } else {
                if (code !== Code128Reader.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader.CODE_FNC_2:
                  case Code128Reader.CODE_FNC_3:
                    break;
                  case Code128Reader.CODE_FNC_4_B:
                    if (!upperMode && shiftUpperMode) {
                      upperMode = true;
                      shiftUpperMode = false;
                    } else if (upperMode && shiftUpperMode) {
                      upperMode = false;
                      shiftUpperMode = false;
                    } else {
                      shiftUpperMode = true;
                    }
                    break;
                  case Code128Reader.CODE_SHIFT:
                    isNextShifted = true;
                    codeSet = Code128Reader.CODE_CODE_A;
                    break;
                  case Code128Reader.CODE_CODE_A:
                    codeSet = Code128Reader.CODE_CODE_A;
                    break;
                  case Code128Reader.CODE_CODE_C:
                    codeSet = Code128Reader.CODE_CODE_C;
                    break;
                  case Code128Reader.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
            case Code128Reader.CODE_CODE_C:
              if (code < 100) {
                if (code < 10) {
                  result += "0";
                }
                result += code;
              } else {
                if (code !== Code128Reader.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader.CODE_CODE_A:
                    codeSet = Code128Reader.CODE_CODE_A;
                    break;
                  case Code128Reader.CODE_CODE_B:
                    codeSet = Code128Reader.CODE_CODE_B;
                    break;
                  case Code128Reader.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
          }
          if (unshift) {
            codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;
          }
        }
        const lastPatternSize = nextStart - lastStart;
        nextStart = row.getNextUnset(nextStart);
        if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {
          throw new NotFoundException();
        }
        checksumTotal -= multiplier * lastCode;
        if (checksumTotal % 103 !== lastCode) {
          throw new ChecksumException();
        }
        const resultLength = result.length;
        if (resultLength === 0) {
          throw new NotFoundException();
        }
        if (resultLength > 0 && lastCharacterWasPrintable) {
          if (codeSet === Code128Reader.CODE_CODE_C) {
            result = result.substring(0, resultLength - 2);
          } else {
            result = result.substring(0, resultLength - 1);
          }
        }
        const left = (startPatternInfo[1] + startPatternInfo[0]) / 2;
        const right = lastStart + lastPatternSize / 2;
        const rawCodesSize = rawCodes.length;
        const rawBytes = new Uint8Array(rawCodesSize);
        for (let i = 0; i < rawCodesSize; i++) {
          rawBytes[i] = rawCodes[i];
        }
        const points = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
        return new Result(result, rawBytes, 0, points, BarcodeFormat$1.CODE_128, (/* @__PURE__ */ new Date()).getTime());
      }
    }
    Code128Reader.CODE_PATTERNS = [
      Int32Array.from([2, 1, 2, 2, 2, 2]),
      Int32Array.from([2, 2, 2, 1, 2, 2]),
      Int32Array.from([2, 2, 2, 2, 2, 1]),
      Int32Array.from([1, 2, 1, 2, 2, 3]),
      Int32Array.from([1, 2, 1, 3, 2, 2]),
      Int32Array.from([1, 3, 1, 2, 2, 2]),
      Int32Array.from([1, 2, 2, 2, 1, 3]),
      Int32Array.from([1, 2, 2, 3, 1, 2]),
      Int32Array.from([1, 3, 2, 2, 1, 2]),
      Int32Array.from([2, 2, 1, 2, 1, 3]),
      Int32Array.from([2, 2, 1, 3, 1, 2]),
      Int32Array.from([2, 3, 1, 2, 1, 2]),
      Int32Array.from([1, 1, 2, 2, 3, 2]),
      Int32Array.from([1, 2, 2, 1, 3, 2]),
      Int32Array.from([1, 2, 2, 2, 3, 1]),
      Int32Array.from([1, 1, 3, 2, 2, 2]),
      Int32Array.from([1, 2, 3, 1, 2, 2]),
      Int32Array.from([1, 2, 3, 2, 2, 1]),
      Int32Array.from([2, 2, 3, 2, 1, 1]),
      Int32Array.from([2, 2, 1, 1, 3, 2]),
      Int32Array.from([2, 2, 1, 2, 3, 1]),
      Int32Array.from([2, 1, 3, 2, 1, 2]),
      Int32Array.from([2, 2, 3, 1, 1, 2]),
      Int32Array.from([3, 1, 2, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 2, 2, 2]),
      Int32Array.from([3, 2, 1, 1, 2, 2]),
      Int32Array.from([3, 2, 1, 2, 2, 1]),
      Int32Array.from([3, 1, 2, 2, 1, 2]),
      Int32Array.from([3, 2, 2, 1, 1, 2]),
      Int32Array.from([3, 2, 2, 2, 1, 1]),
      Int32Array.from([2, 1, 2, 1, 2, 3]),
      Int32Array.from([2, 1, 2, 3, 2, 1]),
      Int32Array.from([2, 3, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 1, 3, 2, 3]),
      Int32Array.from([1, 3, 1, 1, 2, 3]),
      Int32Array.from([1, 3, 1, 3, 2, 1]),
      Int32Array.from([1, 1, 2, 3, 1, 3]),
      Int32Array.from([1, 3, 2, 1, 1, 3]),
      Int32Array.from([1, 3, 2, 3, 1, 1]),
      Int32Array.from([2, 1, 1, 3, 1, 3]),
      Int32Array.from([2, 3, 1, 1, 1, 3]),
      Int32Array.from([2, 3, 1, 3, 1, 1]),
      Int32Array.from([1, 1, 2, 1, 3, 3]),
      Int32Array.from([1, 1, 2, 3, 3, 1]),
      Int32Array.from([1, 3, 2, 1, 3, 1]),
      Int32Array.from([1, 1, 3, 1, 2, 3]),
      Int32Array.from([1, 1, 3, 3, 2, 1]),
      Int32Array.from([1, 3, 3, 1, 2, 1]),
      Int32Array.from([3, 1, 3, 1, 2, 1]),
      Int32Array.from([2, 1, 1, 3, 3, 1]),
      Int32Array.from([2, 3, 1, 1, 3, 1]),
      Int32Array.from([2, 1, 3, 1, 1, 3]),
      Int32Array.from([2, 1, 3, 3, 1, 1]),
      Int32Array.from([2, 1, 3, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 2, 3]),
      Int32Array.from([3, 1, 1, 3, 2, 1]),
      Int32Array.from([3, 3, 1, 1, 2, 1]),
      Int32Array.from([3, 1, 2, 1, 1, 3]),
      Int32Array.from([3, 1, 2, 3, 1, 1]),
      Int32Array.from([3, 3, 2, 1, 1, 1]),
      Int32Array.from([3, 1, 4, 1, 1, 1]),
      Int32Array.from([2, 2, 1, 4, 1, 1]),
      Int32Array.from([4, 3, 1, 1, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 2, 4]),
      Int32Array.from([1, 1, 1, 4, 2, 2]),
      Int32Array.from([1, 2, 1, 1, 2, 4]),
      Int32Array.from([1, 2, 1, 4, 2, 1]),
      Int32Array.from([1, 4, 1, 1, 2, 2]),
      Int32Array.from([1, 4, 1, 2, 2, 1]),
      Int32Array.from([1, 1, 2, 2, 1, 4]),
      Int32Array.from([1, 1, 2, 4, 1, 2]),
      Int32Array.from([1, 2, 2, 1, 1, 4]),
      Int32Array.from([1, 2, 2, 4, 1, 1]),
      Int32Array.from([1, 4, 2, 1, 1, 2]),
      Int32Array.from([1, 4, 2, 2, 1, 1]),
      Int32Array.from([2, 4, 1, 2, 1, 1]),
      Int32Array.from([2, 2, 1, 1, 1, 4]),
      Int32Array.from([4, 1, 3, 1, 1, 1]),
      Int32Array.from([2, 4, 1, 1, 1, 2]),
      Int32Array.from([1, 3, 4, 1, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 4, 2]),
      Int32Array.from([1, 2, 1, 1, 4, 2]),
      Int32Array.from([1, 2, 1, 2, 4, 1]),
      Int32Array.from([1, 1, 4, 2, 1, 2]),
      Int32Array.from([1, 2, 4, 1, 1, 2]),
      Int32Array.from([1, 2, 4, 2, 1, 1]),
      Int32Array.from([4, 1, 1, 2, 1, 2]),
      Int32Array.from([4, 2, 1, 1, 1, 2]),
      Int32Array.from([4, 2, 1, 2, 1, 1]),
      Int32Array.from([2, 1, 2, 1, 4, 1]),
      Int32Array.from([2, 1, 4, 1, 2, 1]),
      Int32Array.from([4, 1, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 1, 1, 4, 3]),
      Int32Array.from([1, 1, 1, 3, 4, 1]),
      Int32Array.from([1, 3, 1, 1, 4, 1]),
      Int32Array.from([1, 1, 4, 1, 1, 3]),
      Int32Array.from([1, 1, 4, 3, 1, 1]),
      Int32Array.from([4, 1, 1, 1, 1, 3]),
      Int32Array.from([4, 1, 1, 3, 1, 1]),
      Int32Array.from([1, 1, 3, 1, 4, 1]),
      Int32Array.from([1, 1, 4, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 4, 1]),
      Int32Array.from([4, 1, 1, 1, 3, 1]),
      Int32Array.from([2, 1, 1, 4, 1, 2]),
      Int32Array.from([2, 1, 1, 2, 1, 4]),
      Int32Array.from([2, 1, 1, 2, 3, 2]),
      Int32Array.from([2, 3, 3, 1, 1, 1, 2])
    ];
    Code128Reader.MAX_AVG_VARIANCE = 0.25;
    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;
    Code128Reader.CODE_SHIFT = 98;
    Code128Reader.CODE_CODE_C = 99;
    Code128Reader.CODE_CODE_B = 100;
    Code128Reader.CODE_CODE_A = 101;
    Code128Reader.CODE_FNC_1 = 102;
    Code128Reader.CODE_FNC_2 = 97;
    Code128Reader.CODE_FNC_3 = 96;
    Code128Reader.CODE_FNC_4_A = 101;
    Code128Reader.CODE_FNC_4_B = 100;
    Code128Reader.CODE_START_A = 103;
    Code128Reader.CODE_START_B = 104;
    Code128Reader.CODE_START_C = 105;
    Code128Reader.CODE_STOP = 106;
    class Code39Reader extends OneDReader {
      /**
       * Creates a reader that assumes all encoded data is data, and does not treat the final
       * character as a check digit. It will not decoded "extended Code 39" sequences.
       */
      // public Code39Reader() {
      //   this(false);
      // }
      /**
       * Creates a reader that can be configured to check the last character as a check digit.
       * It will not decoded "extended Code 39" sequences.
       *
       * @param usingCheckDigit if true, treat the last data character as a check digit, not
       * data, and verify that the checksum passes.
       */
      // public Code39Reader(boolean usingCheckDigit) {
      //   this(usingCheckDigit, false);
      // }
      /**
       * Creates a reader that can be configured to check the last character as a check digit,
       * or optionally attempt to decode "extended Code 39" sequences that are used to encode
       * the full ASCII character set.
       *
       * @param usingCheckDigit if true, treat the last data character as a check digit, not
       * data, and verify that the checksum passes.
       * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the
       * text.
       */
      constructor(usingCheckDigit = false, extendedMode = false) {
        super();
        this.usingCheckDigit = usingCheckDigit;
        this.extendedMode = extendedMode;
        this.decodeRowResult = "";
        this.counters = new Int32Array(9);
      }
      decodeRow(rowNumber, row, hints) {
        let theCounters = this.counters;
        theCounters.fill(0);
        this.decodeRowResult = "";
        let start = Code39Reader.findAsteriskPattern(row, theCounters);
        let nextStart = row.getNextSet(start[1]);
        let end = row.getSize();
        let decodedChar;
        let lastStart;
        do {
          Code39Reader.recordPattern(row, nextStart, theCounters);
          let pattern = Code39Reader.toNarrowWidePattern(theCounters);
          if (pattern < 0) {
            throw new NotFoundException();
          }
          decodedChar = Code39Reader.patternToChar(pattern);
          this.decodeRowResult += decodedChar;
          lastStart = nextStart;
          for (let counter of theCounters) {
            nextStart += counter;
          }
          nextStart = row.getNextSet(nextStart);
        } while (decodedChar !== "*");
        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1);
        let lastPatternSize = 0;
        for (let counter of theCounters) {
          lastPatternSize += counter;
        }
        let whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;
        if (nextStart !== end && whiteSpaceAfterEnd * 2 < lastPatternSize) {
          throw new NotFoundException();
        }
        if (this.usingCheckDigit) {
          let max = this.decodeRowResult.length - 1;
          let total = 0;
          for (let i = 0; i < max; i++) {
            total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));
          }
          if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {
            throw new ChecksumException();
          }
          this.decodeRowResult = this.decodeRowResult.substring(0, max);
        }
        if (this.decodeRowResult.length === 0) {
          throw new NotFoundException();
        }
        let resultString;
        if (this.extendedMode) {
          resultString = Code39Reader.decodeExtended(this.decodeRowResult);
        } else {
          resultString = this.decodeRowResult;
        }
        let left = (start[1] + start[0]) / 2;
        let right = lastStart + lastPatternSize / 2;
        return new Result(resultString, null, 0, [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)], BarcodeFormat$1.CODE_39, (/* @__PURE__ */ new Date()).getTime());
      }
      static findAsteriskPattern(row, counters) {
        let width = row.getSize();
        let rowOffset = row.getNextSet(0);
        let counterPosition = 0;
        let patternStart = rowOffset;
        let isWhite = false;
        let patternLength = counters.length;
        for (let i = rowOffset; i < width; i++) {
          if (row.get(i) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING && row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {
                return [patternStart, i];
              }
              patternStart += counters[0] + counters[1];
              counters.copyWithin(0, 2, 2 + counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions
      // per image when using some of our blackbox images.
      static toNarrowWidePattern(counters) {
        let numCounters = counters.length;
        let maxNarrowCounter = 0;
        let wideCounters;
        do {
          let minCounter = 2147483647;
          for (let counter of counters) {
            if (counter < minCounter && counter > maxNarrowCounter) {
              minCounter = counter;
            }
          }
          maxNarrowCounter = minCounter;
          wideCounters = 0;
          let totalWideCountersWidth = 0;
          let pattern = 0;
          for (let i = 0; i < numCounters; i++) {
            let counter = counters[i];
            if (counter > maxNarrowCounter) {
              pattern |= 1 << numCounters - 1 - i;
              wideCounters++;
              totalWideCountersWidth += counter;
            }
          }
          if (wideCounters === 3) {
            for (let i = 0; i < numCounters && wideCounters > 0; i++) {
              let counter = counters[i];
              if (counter > maxNarrowCounter) {
                wideCounters--;
                if (counter * 2 >= totalWideCountersWidth) {
                  return -1;
                }
              }
            }
            return pattern;
          }
        } while (wideCounters > 3);
        return -1;
      }
      static patternToChar(pattern) {
        for (let i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {
          if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {
            return Code39Reader.ALPHABET_STRING.charAt(i);
          }
        }
        if (pattern === Code39Reader.ASTERISK_ENCODING) {
          return "*";
        }
        throw new NotFoundException();
      }
      static decodeExtended(encoded) {
        let length = encoded.length;
        let decoded = "";
        for (let i = 0; i < length; i++) {
          let c = encoded.charAt(i);
          if (c === "+" || c === "$" || c === "%" || c === "/") {
            let next2 = encoded.charAt(i + 1);
            let decodedChar = "\0";
            switch (c) {
              case "+":
                if (next2 >= "A" && next2 <= "Z") {
                  decodedChar = String.fromCharCode(next2.charCodeAt(0) + 32);
                } else {
                  throw new FormatException();
                }
                break;
              case "$":
                if (next2 >= "A" && next2 <= "Z") {
                  decodedChar = String.fromCharCode(next2.charCodeAt(0) - 64);
                } else {
                  throw new FormatException();
                }
                break;
              case "%":
                if (next2 >= "A" && next2 <= "E") {
                  decodedChar = String.fromCharCode(next2.charCodeAt(0) - 38);
                } else if (next2 >= "F" && next2 <= "J") {
                  decodedChar = String.fromCharCode(next2.charCodeAt(0) - 11);
                } else if (next2 >= "K" && next2 <= "O") {
                  decodedChar = String.fromCharCode(next2.charCodeAt(0) + 16);
                } else if (next2 >= "P" && next2 <= "T") {
                  decodedChar = String.fromCharCode(next2.charCodeAt(0) + 43);
                } else if (next2 === "U") {
                  decodedChar = "\0";
                } else if (next2 === "V") {
                  decodedChar = "@";
                } else if (next2 === "W") {
                  decodedChar = "`";
                } else if (next2 === "X" || next2 === "Y" || next2 === "Z") {
                  decodedChar = "";
                } else {
                  throw new FormatException();
                }
                break;
              case "/":
                if (next2 >= "A" && next2 <= "O") {
                  decodedChar = String.fromCharCode(next2.charCodeAt(0) - 32);
                } else if (next2 === "Z") {
                  decodedChar = ":";
                } else {
                  throw new FormatException();
                }
                break;
            }
            decoded += decodedChar;
            i++;
          } else {
            decoded += c;
          }
        }
        return decoded;
      }
    }
    Code39Reader.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
    Code39Reader.CHARACTER_ENCODINGS = [
      52,
      289,
      97,
      352,
      49,
      304,
      112,
      37,
      292,
      100,
      265,
      73,
      328,
      25,
      280,
      88,
      13,
      268,
      76,
      28,
      259,
      67,
      322,
      19,
      274,
      82,
      7,
      262,
      70,
      22,
      385,
      193,
      448,
      145,
      400,
      208,
      133,
      388,
      196,
      168,
      162,
      138,
      42
      // /-%
    ];
    Code39Reader.ASTERISK_ENCODING = 148;
    class ITFReader extends OneDReader {
      constructor() {
        super(...arguments);
        this.narrowLineWidth = -1;
      }
      // See ITFWriter.PATTERNS
      /*
      
        /!**
         * Patterns of Wide / Narrow lines to indicate each digit
         *!/
        */
      decodeRow(rowNumber, row, hints) {
        let startRange = this.decodeStart(row);
        let endRange = this.decodeEnd(row);
        let result = new StringBuilder();
        ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);
        let resultString = result.toString();
        let allowedLengths = null;
        if (hints != null) {
          allowedLengths = hints.get(DecodeHintType$1.ALLOWED_LENGTHS);
        }
        if (allowedLengths == null) {
          allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;
        }
        let length = resultString.length;
        let lengthOK = false;
        let maxAllowedLength = 0;
        for (let value of allowedLengths) {
          if (length === value) {
            lengthOK = true;
            break;
          }
          if (value > maxAllowedLength) {
            maxAllowedLength = value;
          }
        }
        if (!lengthOK && length > maxAllowedLength) {
          lengthOK = true;
        }
        if (!lengthOK) {
          throw new FormatException();
        }
        const points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];
        let resultReturn = new Result(
          resultString,
          null,
          // no natural byte representation for these barcodes
          0,
          points,
          BarcodeFormat$1.ITF,
          (/* @__PURE__ */ new Date()).getTime()
        );
        return resultReturn;
      }
      /*
      /!**
       * @param row          row of black/white values to search
       * @param payloadStart offset of start pattern
       * @param resultString {@link StringBuilder} to append decoded chars to
       * @throws NotFoundException if decoding could not complete successfully
       *!/*/
      static decodeMiddle(row, payloadStart, payloadEnd, resultString) {
        let counterDigitPair = new Int32Array(10);
        let counterBlack = new Int32Array(5);
        let counterWhite = new Int32Array(5);
        counterDigitPair.fill(0);
        counterBlack.fill(0);
        counterWhite.fill(0);
        while (payloadStart < payloadEnd) {
          OneDReader.recordPattern(row, payloadStart, counterDigitPair);
          for (let k = 0; k < 5; k++) {
            let twoK = 2 * k;
            counterBlack[k] = counterDigitPair[twoK];
            counterWhite[k] = counterDigitPair[twoK + 1];
          }
          let bestMatch = ITFReader.decodeDigit(counterBlack);
          resultString.append(bestMatch.toString());
          bestMatch = this.decodeDigit(counterWhite);
          resultString.append(bestMatch.toString());
          counterDigitPair.forEach(function(counterDigit) {
            payloadStart += counterDigit;
          });
        }
      }
      /*/!**
       * Identify where the start of the middle / payload section starts.
       *
       * @param row row of black/white values to search
       * @return Array, containing index of start of 'start block' and end of
       *         'start block'
       *!/*/
      decodeStart(row) {
        let endStart = ITFReader.skipWhiteSpace(row);
        let startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);
        this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;
        this.validateQuietZone(row, startPattern[0]);
        return startPattern;
      }
      /*/!**
       * The start & end patterns must be pre/post fixed by a quiet zone. This
       * zone must be at least 10 times the width of a narrow line.  Scan back until
       * we either get to the start of the barcode or match the necessary number of
       * quiet zone pixels.
       *
       * Note: Its assumed the row is reversed when using this method to find
       * quiet zone after the end pattern.
       *
       * ref: http://www.barcode-1.net/i25code.html
       *
       * @param row bit array representing the scanned barcode.
       * @param startPattern index into row of the start or end pattern.
       * @throws NotFoundException if the quiet zone cannot be found
       *!/*/
      validateQuietZone(row, startPattern) {
        let quietCount = this.narrowLineWidth * 10;
        quietCount = quietCount < startPattern ? quietCount : startPattern;
        for (let i = startPattern - 1; quietCount > 0 && i >= 0; i--) {
          if (row.get(i)) {
            break;
          }
          quietCount--;
        }
        if (quietCount !== 0) {
          throw new NotFoundException();
        }
      }
      /*
      /!**
       * Skip all whitespace until we get to the first black line.
       *
       * @param row row of black/white values to search
       * @return index of the first black line.
       * @throws NotFoundException Throws exception if no black lines are found in the row
       *!/*/
      static skipWhiteSpace(row) {
        const width = row.getSize();
        const endStart = row.getNextSet(0);
        if (endStart === width) {
          throw new NotFoundException();
        }
        return endStart;
      }
      /*/!**
       * Identify where the end of the middle / payload section ends.
       *
       * @param row row of black/white values to search
       * @return Array, containing index of start of 'end block' and end of 'end
       *         block'
       *!/*/
      decodeEnd(row) {
        row.reverse();
        try {
          let endStart = ITFReader.skipWhiteSpace(row);
          let endPattern;
          try {
            endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);
          } catch (error) {
            if (error instanceof NotFoundException) {
              endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);
            }
          }
          this.validateQuietZone(row, endPattern[0]);
          let temp = endPattern[0];
          endPattern[0] = row.getSize() - endPattern[1];
          endPattern[1] = row.getSize() - temp;
          return endPattern;
        } finally {
          row.reverse();
        }
      }
      /*
      /!**
       * @param row       row of black/white values to search
       * @param rowOffset position to start search
       * @param pattern   pattern of counts of number of black and white pixels that are
       *                  being searched for as a pattern
       * @return start/end horizontal offset of guard pattern, as an array of two
       *         ints
       * @throws NotFoundException if pattern is not found
       *!/*/
      static findGuardPattern(row, rowOffset, pattern) {
        let patternLength = pattern.length;
        let counters = new Int32Array(patternLength);
        let width = row.getSize();
        let isWhite = false;
        let counterPosition = 0;
        let patternStart = rowOffset;
        counters.fill(0);
        for (let x = rowOffset; x < width; x++) {
          if (row.get(x) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {
                return [patternStart, x];
              }
              patternStart += counters[0] + counters[1];
              System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      /*/!**
       * Attempts to decode a sequence of ITF black/white lines into single
       * digit.
       *
       * @param counters the counts of runs of observed black/white/black/... values
       * @return The decoded digit
       * @throws NotFoundException if digit cannot be decoded
       *!/*/
      static decodeDigit(counters) {
        let bestVariance = ITFReader.MAX_AVG_VARIANCE;
        let bestMatch = -1;
        let max = ITFReader.PATTERNS.length;
        for (let i = 0; i < max; i++) {
          let pattern = ITFReader.PATTERNS[i];
          let variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = i;
          } else if (variance === bestVariance) {
            bestMatch = -1;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch % 10;
        } else {
          throw new NotFoundException();
        }
      }
    }
    ITFReader.PATTERNS = [
      Int32Array.from([1, 1, 2, 2, 1]),
      Int32Array.from([2, 1, 1, 1, 2]),
      Int32Array.from([1, 2, 1, 1, 2]),
      Int32Array.from([2, 2, 1, 1, 1]),
      Int32Array.from([1, 1, 2, 1, 2]),
      Int32Array.from([2, 1, 2, 1, 1]),
      Int32Array.from([1, 2, 2, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 2]),
      Int32Array.from([2, 1, 1, 2, 1]),
      Int32Array.from([1, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 3, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 3]),
      Int32Array.from([1, 3, 1, 1, 3]),
      Int32Array.from([3, 3, 1, 1, 1]),
      Int32Array.from([1, 1, 3, 1, 3]),
      Int32Array.from([3, 1, 3, 1, 1]),
      Int32Array.from([1, 3, 3, 1, 1]),
      Int32Array.from([1, 1, 1, 3, 3]),
      Int32Array.from([3, 1, 1, 3, 1]),
      Int32Array.from([1, 3, 1, 3, 1])
      // 9
    ];
    ITFReader.MAX_AVG_VARIANCE = 0.38;
    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;
    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];
    ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);
    ITFReader.END_PATTERN_REVERSED = [
      Int32Array.from([1, 1, 2]),
      Int32Array.from([1, 1, 3])
      // 3x
    ];
    class AbstractUPCEANReader extends OneDReader {
      constructor() {
        super(...arguments);
        this.decodeRowStringBuffer = "";
      }
      static findStartGuardPattern(row) {
        let foundStart = false;
        let startRange;
        let nextStart = 0;
        let counters = Int32Array.from([0, 0, 0]);
        while (!foundStart) {
          counters = Int32Array.from([0, 0, 0]);
          startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);
          let start = startRange[0];
          nextStart = startRange[1];
          let quietStart = start - (nextStart - start);
          if (quietStart >= 0) {
            foundStart = row.isRange(quietStart, start, false);
          }
        }
        return startRange;
      }
      static checkChecksum(s) {
        return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);
      }
      static checkStandardUPCEANChecksum(s) {
        let length = s.length;
        if (length === 0)
          return false;
        let check = parseInt(s.charAt(length - 1), 10);
        return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
      }
      static getStandardUPCEANChecksum(s) {
        let length = s.length;
        let sum = 0;
        for (let i = length - 1; i >= 0; i -= 2) {
          let digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        sum *= 3;
        for (let i = length - 2; i >= 0; i -= 2) {
          let digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        return (1e3 - sum) % 10;
      }
      static decodeEnd(row, endStart) {
        return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));
      }
      /**
       * @throws NotFoundException
       */
      static findGuardPatternWithoutCounters(row, rowOffset, whiteFirst, pattern) {
        return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));
      }
      /**
       * @param row row of black/white values to search
       * @param rowOffset position to start search
       * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...
       * pixel counts, otherwise, it is interpreted as black/white/black/...
       * @param pattern pattern of counts of number of black and white pixels that are being
       * searched for as a pattern
       * @param counters array of counters, as long as pattern, to re-use
       * @return start/end horizontal offset of guard pattern, as an array of two ints
       * @throws NotFoundException if pattern is not found
       */
      static findGuardPattern(row, rowOffset, whiteFirst, pattern, counters) {
        let width = row.getSize();
        rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);
        let counterPosition = 0;
        let patternStart = rowOffset;
        let patternLength = pattern.length;
        let isWhite = whiteFirst;
        for (let x = rowOffset; x < width; x++) {
          if (row.get(x) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {
                return Int32Array.from([patternStart, x]);
              }
              patternStart += counters[0] + counters[1];
              let slice2 = counters.slice(2, counters.length - 1);
              for (let i = 0; i < counterPosition - 1; i++) {
                counters[i] = slice2[i];
              }
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static decodeDigit(row, counters, rowOffset, patterns) {
        this.recordPattern(row, rowOffset, counters);
        let bestVariance = this.MAX_AVG_VARIANCE;
        let bestMatch = -1;
        let max = patterns.length;
        for (let i = 0; i < max; i++) {
          let pattern = patterns[i];
          let variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = i;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch;
        } else {
          throw new NotFoundException();
        }
      }
    }
    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;
    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;
    AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);
    AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);
    AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
    AbstractUPCEANReader.L_PATTERNS = [
      Int32Array.from([3, 2, 1, 1]),
      Int32Array.from([2, 2, 2, 1]),
      Int32Array.from([2, 1, 2, 2]),
      Int32Array.from([1, 4, 1, 1]),
      Int32Array.from([1, 1, 3, 2]),
      Int32Array.from([1, 2, 3, 1]),
      Int32Array.from([1, 1, 1, 4]),
      Int32Array.from([1, 3, 1, 2]),
      Int32Array.from([1, 2, 1, 3]),
      Int32Array.from([3, 1, 1, 2])
    ];
    class UPCEANExtension5Support {
      constructor() {
        this.CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        this.decodeRowStringBuffer = "";
      }
      decodeRow(rowNumber, row, extensionStartRange) {
        let result = this.decodeRowStringBuffer;
        let end = this.decodeMiddle(row, extensionStartRange, result);
        let resultString = result.toString();
        let extensionData = UPCEANExtension5Support.parseExtensionString(resultString);
        let resultPoints = [
          new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
          new ResultPoint(end, rowNumber)
        ];
        let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, (/* @__PURE__ */ new Date()).getTime());
        if (extensionData != null) {
          extensionResult.putAllMetadata(extensionData);
        }
        return extensionResult;
      }
      decodeMiddle(row, startRange, resultString) {
        let counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        let lgPatternFound = 0;
        for (let x = 0; x < 5 && rowOffset < end; x++) {
          let bestMatch = AbstractUPCEANReader.decodeDigit(
            row,
            counters,
            rowOffset,
            AbstractUPCEANReader.L_AND_G_PATTERNS
          );
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 4 - x;
          }
          if (x !== 4) {
            rowOffset = row.getNextSet(rowOffset);
            rowOffset = row.getNextUnset(rowOffset);
          }
        }
        if (resultString.length !== 5) {
          throw new NotFoundException();
        }
        let checkDigit = this.determineCheckDigit(lgPatternFound);
        if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {
          throw new NotFoundException();
        }
        return rowOffset;
      }
      static extensionChecksum(s) {
        let length = s.length;
        let sum = 0;
        for (let i = length - 2; i >= 0; i -= 2) {
          sum += s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
        }
        sum *= 3;
        for (let i = length - 1; i >= 0; i -= 2) {
          sum += s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
        }
        sum *= 3;
        return sum % 10;
      }
      determineCheckDigit(lgPatternFound) {
        for (let d = 0; d < 10; d++) {
          if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {
            return d;
          }
        }
        throw new NotFoundException();
      }
      static parseExtensionString(raw) {
        if (raw.length !== 5) {
          return null;
        }
        let value = UPCEANExtension5Support.parseExtension5String(raw);
        if (value == null) {
          return null;
        }
        return /* @__PURE__ */ new Map([[ResultMetadataType$1.SUGGESTED_PRICE, value]]);
      }
      static parseExtension5String(raw) {
        let currency2;
        switch (raw.charAt(0)) {
          case "0":
            currency2 = "£";
            break;
          case "5":
            currency2 = "$";
            break;
          case "9":
            switch (raw) {
              case "90000":
                return null;
              case "99991":
                return "0.00";
              case "99990":
                return "Used";
            }
            currency2 = "";
            break;
          default:
            currency2 = "";
            break;
        }
        let rawAmount = parseInt(raw.substring(1));
        let unitsString = (rawAmount / 100).toString();
        let hundredths = rawAmount % 100;
        let hundredthsString = hundredths < 10 ? "0" + hundredths : hundredths.toString();
        return currency2 + unitsString + "." + hundredthsString;
      }
    }
    class UPCEANExtension2Support {
      constructor() {
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        this.decodeRowStringBuffer = "";
      }
      decodeRow(rowNumber, row, extensionStartRange) {
        let result = this.decodeRowStringBuffer;
        let end = this.decodeMiddle(row, extensionStartRange, result);
        let resultString = result.toString();
        let extensionData = UPCEANExtension2Support.parseExtensionString(resultString);
        let resultPoints = [
          new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
          new ResultPoint(end, rowNumber)
        ];
        let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, (/* @__PURE__ */ new Date()).getTime());
        if (extensionData != null) {
          extensionResult.putAllMetadata(extensionData);
        }
        return extensionResult;
      }
      decodeMiddle(row, startRange, resultString) {
        let counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        let checkParity = 0;
        for (let x = 0; x < 2 && rowOffset < end; x++) {
          let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            checkParity |= 1 << 1 - x;
          }
          if (x !== 1) {
            rowOffset = row.getNextSet(rowOffset);
            rowOffset = row.getNextUnset(rowOffset);
          }
        }
        if (resultString.length !== 2) {
          throw new NotFoundException();
        }
        if (parseInt(resultString.toString()) % 4 !== checkParity) {
          throw new NotFoundException();
        }
        return rowOffset;
      }
      static parseExtensionString(raw) {
        if (raw.length !== 2) {
          return null;
        }
        return /* @__PURE__ */ new Map([[ResultMetadataType$1.ISSUE_NUMBER, parseInt(raw)]]);
      }
    }
    class UPCEANExtensionSupport {
      static decodeRow(rowNumber, row, rowOffset) {
        let extensionStartRange = AbstractUPCEANReader.findGuardPattern(
          row,
          rowOffset,
          false,
          this.EXTENSION_START_PATTERN,
          new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0)
        );
        try {
          let fiveSupport = new UPCEANExtension5Support();
          return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);
        } catch (err2) {
          let twoSupport = new UPCEANExtension2Support();
          return twoSupport.decodeRow(rowNumber, row, extensionStartRange);
        }
      }
    }
    UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);
    class UPCEANReader extends AbstractUPCEANReader {
      constructor() {
        super();
        this.decodeRowStringBuffer = "";
        UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map((arr) => Int32Array.from(arr));
        for (let i = 10; i < 20; i++) {
          let widths = UPCEANReader.L_PATTERNS[i - 10];
          let reversedWidths = new Int32Array(widths.length);
          for (let j = 0; j < widths.length; j++) {
            reversedWidths[j] = widths[widths.length - j - 1];
          }
          UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;
        }
      }
      decodeRow(rowNumber, row, hints) {
        let startGuardRange = UPCEANReader.findStartGuardPattern(row);
        let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
        if (resultPointCallback != null) {
          const resultPoint2 = new ResultPoint((startGuardRange[0] + startGuardRange[1]) / 2, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint2);
        }
        let budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);
        let endStart = budello.rowOffset;
        let result = budello.resultString;
        if (resultPointCallback != null) {
          const resultPoint2 = new ResultPoint(endStart, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint2);
        }
        let endRange = this.decodeEnd(row, endStart);
        if (resultPointCallback != null) {
          const resultPoint2 = new ResultPoint((endRange[0] + endRange[1]) / 2, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint2);
        }
        let end = endRange[1];
        let quietEnd = end + (end - endRange[0]);
        if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {
          throw new NotFoundException();
        }
        let resultString = result.toString();
        if (resultString.length < 8) {
          throw new FormatException();
        }
        if (!UPCEANReader.checkChecksum(resultString)) {
          throw new ChecksumException();
        }
        let left = (startGuardRange[1] + startGuardRange[0]) / 2;
        let right = (endRange[1] + endRange[0]) / 2;
        let format = this.getBarcodeFormat();
        let resultPoint = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
        let decodeResult = new Result(resultString, null, 0, resultPoint, format, (/* @__PURE__ */ new Date()).getTime());
        let extensionLength = 0;
        try {
          let extensionResult = UPCEANExtensionSupport.decodeRow(rowNumber, row, endRange[1]);
          decodeResult.putMetadata(ResultMetadataType$1.UPC_EAN_EXTENSION, extensionResult.getText());
          decodeResult.putAllMetadata(extensionResult.getResultMetadata());
          decodeResult.addResultPoints(extensionResult.getResultPoints());
          extensionLength = extensionResult.getText().length;
        } catch (ignoreError) {
        }
        let allowedExtensions = hints == null ? null : hints.get(DecodeHintType$1.ALLOWED_EAN_EXTENSIONS);
        if (allowedExtensions != null) {
          let valid = false;
          for (let length in allowedExtensions) {
            if (extensionLength.toString() === length) {
              valid = true;
              break;
            }
          }
          if (!valid) {
            throw new NotFoundException();
          }
        }
        return decodeResult;
      }
      decodeEnd(row, endStart) {
        return UPCEANReader.findGuardPattern(
          row,
          endStart,
          false,
          UPCEANReader.START_END_PATTERN,
          new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0)
        );
      }
      static checkChecksum(s) {
        return UPCEANReader.checkStandardUPCEANChecksum(s);
      }
      static checkStandardUPCEANChecksum(s) {
        let length = s.length;
        if (length === 0)
          return false;
        let check = parseInt(s.charAt(length - 1), 10);
        return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
      }
      static getStandardUPCEANChecksum(s) {
        let length = s.length;
        let sum = 0;
        for (let i = length - 1; i >= 0; i -= 2) {
          let digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        sum *= 3;
        for (let i = length - 2; i >= 0; i -= 2) {
          let digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        return (1e3 - sum) % 10;
      }
    }
    class EAN13Reader extends UPCEANReader {
      constructor() {
        super();
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
      }
      decodeMiddle(row, startRange, resultString) {
        let counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        let lgPatternFound = 0;
        for (let x = 0; x < 6 && rowOffset < end; x++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_AND_G_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 5 - x;
          }
        }
        resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);
        let middleRange = UPCEANReader.findGuardPattern(
          row,
          rowOffset,
          true,
          UPCEANReader.MIDDLE_PATTERN,
          new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0)
        );
        rowOffset = middleRange[1];
        for (let x = 0; x < 6 && rowOffset < end; x++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          for (let counter of counters) {
            rowOffset += counter;
          }
        }
        return { rowOffset, resultString };
      }
      getBarcodeFormat() {
        return BarcodeFormat$1.EAN_13;
      }
      static determineFirstDigit(resultString, lgPatternFound) {
        for (let d = 0; d < 10; d++) {
          if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {
            resultString = String.fromCharCode("0".charCodeAt(0) + d) + resultString;
            return resultString;
          }
        }
        throw new NotFoundException();
      }
    }
    EAN13Reader.FIRST_DIGIT_ENCODINGS = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26];
    class EAN8Reader extends UPCEANReader {
      constructor() {
        super();
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
      }
      decodeMiddle(row, startRange, resultString) {
        const counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        for (let x = 0; x < 4 && rowOffset < end; x++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          for (let counter of counters) {
            rowOffset += counter;
          }
        }
        let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
        rowOffset = middleRange[1];
        for (let x = 0; x < 4 && rowOffset < end; x++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          for (let counter of counters) {
            rowOffset += counter;
          }
        }
        return { rowOffset, resultString };
      }
      getBarcodeFormat() {
        return BarcodeFormat$1.EAN_8;
      }
    }
    class UPCAReader extends UPCEANReader {
      constructor() {
        super(...arguments);
        this.ean13Reader = new EAN13Reader();
      }
      // @Override
      getBarcodeFormat() {
        return BarcodeFormat$1.UPC_A;
      }
      // Note that we don't try rotation without the try harder flag, even if rotation was supported.
      // @Override
      decode(image, hints) {
        return this.maybeReturnResult(this.ean13Reader.decode(image));
      }
      // @Override
      decodeRow(rowNumber, row, hints) {
        return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));
      }
      // @Override
      decodeMiddle(row, startRange, resultString) {
        return this.ean13Reader.decodeMiddle(row, startRange, resultString);
      }
      maybeReturnResult(result) {
        let text = result.getText();
        if (text.charAt(0) === "0") {
          let upcaResult = new Result(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat$1.UPC_A);
          if (result.getResultMetadata() != null) {
            upcaResult.putAllMetadata(result.getResultMetadata());
          }
          return upcaResult;
        } else {
          throw new NotFoundException();
        }
      }
      reset() {
        this.ean13Reader.reset();
      }
    }
    class UPCEReader extends UPCEANReader {
      constructor() {
        super();
        this.decodeMiddleCounters = new Int32Array(4);
      }
      /**
       * @throws NotFoundException
       */
      // @Override
      decodeMiddle(row, startRange, result) {
        const counters = this.decodeMiddleCounters.map((x) => x);
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        const end = row.getSize();
        let rowOffset = startRange[1];
        let lgPatternFound = 0;
        for (let x = 0; x < 6 && rowOffset < end; x++) {
          const bestMatch = UPCEReader.decodeDigit(
            row,
            counters,
            rowOffset,
            UPCEReader.L_AND_G_PATTERNS
          );
          result += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 5 - x;
          }
        }
        let resultString = UPCEReader.determineNumSysAndCheckDigit(
          result,
          lgPatternFound
        );
        return { rowOffset, resultString };
      }
      /**
       * @throws NotFoundException
       */
      // @Override
      decodeEnd(row, endStart) {
        return UPCEReader.findGuardPatternWithoutCounters(
          row,
          endStart,
          true,
          UPCEReader.MIDDLE_END_PATTERN
        );
      }
      /**
       * @throws FormatException
       */
      // @Override
      checkChecksum(s) {
        return UPCEANReader.checkChecksum(UPCEReader.convertUPCEtoUPCA(s));
      }
      /**
       * @throws NotFoundException
       */
      static determineNumSysAndCheckDigit(resultString, lgPatternFound) {
        for (let numSys = 0; numSys <= 1; numSys++) {
          for (let d = 0; d < 10; d++) {
            if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {
              let prefix = String.fromCharCode("0".charCodeAt(0) + numSys);
              let suffix = String.fromCharCode("0".charCodeAt(0) + d);
              return prefix + resultString + suffix;
            }
          }
        }
        throw NotFoundException.getNotFoundInstance();
      }
      // @Override
      getBarcodeFormat() {
        return BarcodeFormat$1.UPC_E;
      }
      /**
       * Expands a UPC-E value back into its full, equivalent UPC-A code value.
       *
       * @param upce UPC-E code as string of digits
       * @return equivalent UPC-A code as string of digits
       */
      static convertUPCEtoUPCA(upce) {
        const upceChars = upce.slice(1, 7).split("").map((x) => x.charCodeAt(0));
        const result = new StringBuilder(
          /*12*/
        );
        result.append(upce.charAt(0));
        let lastChar = upceChars[5];
        switch (lastChar) {
          case 0:
          case 1:
          case 2:
            result.appendChars(upceChars, 0, 2);
            result.append(lastChar);
            result.append("0000");
            result.appendChars(upceChars, 2, 3);
            break;
          case 3:
            result.appendChars(upceChars, 0, 3);
            result.append("00000");
            result.appendChars(upceChars, 3, 2);
            break;
          case 4:
            result.appendChars(upceChars, 0, 4);
            result.append("00000");
            result.append(upceChars[4]);
            break;
          default:
            result.appendChars(upceChars, 0, 5);
            result.append("0000");
            result.append(lastChar);
            break;
        }
        if (upce.length >= 8) {
          result.append(upce.charAt(7));
        }
        return result.toString();
      }
    }
    UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
    UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [
      Int32Array.from([56, 52, 50, 49, 44, 38, 35, 42, 41, 37]),
      Int32Array.from([7, 11, 13, 14, 19, 25, 28, 21, 22, 26])
    ];
    class MultiFormatUPCEANReader extends OneDReader {
      constructor(hints) {
        super();
        let possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
        let readers = [];
        if (!isNullOrUndefined2(possibleFormats)) {
          if (possibleFormats.indexOf(BarcodeFormat$1.EAN_13) > -1) {
            readers.push(new EAN13Reader());
          }
          if (possibleFormats.indexOf(BarcodeFormat$1.UPC_A) > -1) {
            readers.push(new UPCAReader());
          }
          if (possibleFormats.indexOf(BarcodeFormat$1.EAN_8) > -1) {
            readers.push(new EAN8Reader());
          }
          if (possibleFormats.indexOf(BarcodeFormat$1.UPC_E) > -1) {
            readers.push(new UPCEReader());
          }
        } else {
          readers.push(new EAN13Reader());
          readers.push(new UPCAReader());
          readers.push(new EAN8Reader());
          readers.push(new UPCEReader());
        }
        this.readers = readers;
      }
      decodeRow(rowNumber, row, hints) {
        for (let reader of this.readers) {
          try {
            const result = reader.decodeRow(rowNumber, row, hints);
            const ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat$1.EAN_13 && result.getText().charAt(0) === "0";
            const possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            const canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat$1.UPC_A);
            if (ean13MayBeUPCA && canReturnUPCA) {
              const rawBytes = result.getRawBytes();
              const resultUPCA = new Result(
                result.getText().substring(1),
                rawBytes,
                rawBytes ? rawBytes.length : null,
                result.getResultPoints(),
                BarcodeFormat$1.UPC_A
              );
              resultUPCA.putAllMetadata(result.getResultMetadata());
              return resultUPCA;
            }
            return result;
          } catch (err2) {
          }
        }
        throw new NotFoundException();
      }
      reset() {
        for (let reader of this.readers) {
          reader.reset();
        }
      }
    }
    class AbstractRSSReader extends OneDReader {
      constructor() {
        super();
        this.decodeFinderCounters = new Int32Array(4);
        this.dataCharacterCounters = new Int32Array(8);
        this.oddRoundingErrors = new Array(4);
        this.evenRoundingErrors = new Array(4);
        this.oddCounts = new Array(this.dataCharacterCounters.length / 2);
        this.evenCounts = new Array(this.dataCharacterCounters.length / 2);
      }
      getDecodeFinderCounters() {
        return this.decodeFinderCounters;
      }
      getDataCharacterCounters() {
        return this.dataCharacterCounters;
      }
      getOddRoundingErrors() {
        return this.oddRoundingErrors;
      }
      getEvenRoundingErrors() {
        return this.evenRoundingErrors;
      }
      getOddCounts() {
        return this.oddCounts;
      }
      getEvenCounts() {
        return this.evenCounts;
      }
      parseFinderValue(counters, finderPatterns) {
        for (let value = 0; value < finderPatterns.length; value++) {
          if (OneDReader.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {
            return value;
          }
        }
        throw new NotFoundException();
      }
      /**
       * @param array values to sum
       * @return sum of values
       * @deprecated call {@link MathUtils#sum(int[])}
       */
      static count(array) {
        return MathUtils.sum(new Int32Array(array));
      }
      static increment(array, errors2) {
        let index2 = 0;
        let biggestError = errors2[0];
        for (let i = 1; i < array.length; i++) {
          if (errors2[i] > biggestError) {
            biggestError = errors2[i];
            index2 = i;
          }
        }
        array[index2]++;
      }
      static decrement(array, errors2) {
        let index2 = 0;
        let biggestError = errors2[0];
        for (let i = 1; i < array.length; i++) {
          if (errors2[i] < biggestError) {
            biggestError = errors2[i];
            index2 = i;
          }
        }
        array[index2]--;
      }
      static isFinderPattern(counters) {
        let firstTwoSum = counters[0] + counters[1];
        let sum = firstTwoSum + counters[2] + counters[3];
        let ratio = firstTwoSum / sum;
        if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {
          let minCounter = Number.MAX_SAFE_INTEGER;
          let maxCounter = Number.MIN_SAFE_INTEGER;
          for (let counter of counters) {
            if (counter > maxCounter) {
              maxCounter = counter;
            }
            if (counter < minCounter) {
              minCounter = counter;
            }
          }
          return maxCounter < 10 * minCounter;
        }
        return false;
      }
    }
    AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;
    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;
    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12;
    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14;
    class DataCharacter {
      constructor(value, checksumPortion) {
        this.value = value;
        this.checksumPortion = checksumPortion;
      }
      getValue() {
        return this.value;
      }
      getChecksumPortion() {
        return this.checksumPortion;
      }
      toString() {
        return this.value + "(" + this.checksumPortion + ")";
      }
      equals(o) {
        if (!(o instanceof DataCharacter)) {
          return false;
        }
        const that = o;
        return this.value === that.value && this.checksumPortion === that.checksumPortion;
      }
      hashCode() {
        return this.value ^ this.checksumPortion;
      }
    }
    class FinderPattern {
      constructor(value, startEnd, start, end, rowNumber) {
        this.value = value;
        this.startEnd = startEnd;
        this.value = value;
        this.startEnd = startEnd;
        this.resultPoints = new Array();
        this.resultPoints.push(new ResultPoint(start, rowNumber));
        this.resultPoints.push(new ResultPoint(end, rowNumber));
      }
      getValue() {
        return this.value;
      }
      getStartEnd() {
        return this.startEnd;
      }
      getResultPoints() {
        return this.resultPoints;
      }
      equals(o) {
        if (!(o instanceof FinderPattern)) {
          return false;
        }
        const that = o;
        return this.value === that.value;
      }
      hashCode() {
        return this.value;
      }
    }
    class RSSUtils {
      constructor() {
      }
      static getRSSvalue(widths, maxWidth, noNarrow) {
        let n = 0;
        for (let width of widths) {
          n += width;
        }
        let val = 0;
        let narrowMask = 0;
        let elements = widths.length;
        for (let bar = 0; bar < elements - 1; bar++) {
          let elmWidth;
          for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {
            let subVal = RSSUtils.combins(n - elmWidth - 1, elements - bar - 2);
            if (noNarrow && narrowMask === 0 && n - elmWidth - (elements - bar - 1) >= elements - bar - 1) {
              subVal -= RSSUtils.combins(n - elmWidth - (elements - bar), elements - bar - 2);
            }
            if (elements - bar - 1 > 1) {
              let lessVal = 0;
              for (let mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {
                lessVal += RSSUtils.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);
              }
              subVal -= lessVal * (elements - 1 - bar);
            } else if (n - elmWidth > maxWidth) {
              subVal--;
            }
            val += subVal;
          }
          n -= elmWidth;
        }
        return val;
      }
      static combins(n, r) {
        let maxDenom;
        let minDenom;
        if (n - r > r) {
          minDenom = r;
          maxDenom = n - r;
        } else {
          minDenom = n - r;
          maxDenom = r;
        }
        let val = 1;
        let j = 1;
        for (let i = n; i > maxDenom; i--) {
          val *= i;
          if (j <= minDenom) {
            val /= j;
            j++;
          }
        }
        while (j <= minDenom) {
          val /= j;
          j++;
        }
        return val;
      }
    }
    class BitArrayBuilder {
      static buildBitArray(pairs) {
        let charNumber = pairs.length * 2 - 1;
        if (pairs[pairs.length - 1].getRightChar() == null) {
          charNumber -= 1;
        }
        let size = 12 * charNumber;
        let binary2 = new BitArray(size);
        let accPos = 0;
        let firstPair = pairs[0];
        let firstValue = firstPair.getRightChar().getValue();
        for (let i = 11; i >= 0; --i) {
          if ((firstValue & 1 << i) != 0) {
            binary2.set(accPos);
          }
          accPos++;
        }
        for (let i = 1; i < pairs.length; ++i) {
          let currentPair = pairs[i];
          let leftValue = currentPair.getLeftChar().getValue();
          for (let j = 11; j >= 0; --j) {
            if ((leftValue & 1 << j) != 0) {
              binary2.set(accPos);
            }
            accPos++;
          }
          if (currentPair.getRightChar() != null) {
            let rightValue = currentPair.getRightChar().getValue();
            for (let j = 11; j >= 0; --j) {
              if ((rightValue & 1 << j) != 0) {
                binary2.set(accPos);
              }
              accPos++;
            }
          }
        }
        return binary2;
      }
    }
    class BlockParsedResult {
      constructor(finished, decodedInformation) {
        if (decodedInformation) {
          this.decodedInformation = null;
        } else {
          this.finished = finished;
          this.decodedInformation = decodedInformation;
        }
      }
      getDecodedInformation() {
        return this.decodedInformation;
      }
      isFinished() {
        return this.finished;
      }
    }
    class DecodedObject {
      constructor(newPosition) {
        this.newPosition = newPosition;
      }
      getNewPosition() {
        return this.newPosition;
      }
    }
    class DecodedChar extends DecodedObject {
      constructor(newPosition, value) {
        super(newPosition);
        this.value = value;
      }
      getValue() {
        return this.value;
      }
      isFNC1() {
        return this.value === DecodedChar.FNC1;
      }
    }
    DecodedChar.FNC1 = "$";
    class DecodedInformation extends DecodedObject {
      constructor(newPosition, newString, remainingValue) {
        super(newPosition);
        if (remainingValue) {
          this.remaining = true;
          this.remainingValue = this.remainingValue;
        } else {
          this.remaining = false;
          this.remainingValue = 0;
        }
        this.newString = newString;
      }
      getNewString() {
        return this.newString;
      }
      isRemaining() {
        return this.remaining;
      }
      getRemainingValue() {
        return this.remainingValue;
      }
    }
    class DecodedNumeric extends DecodedObject {
      constructor(newPosition, firstDigit, secondDigit) {
        super(newPosition);
        if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {
          throw new FormatException();
        }
        this.firstDigit = firstDigit;
        this.secondDigit = secondDigit;
      }
      getFirstDigit() {
        return this.firstDigit;
      }
      getSecondDigit() {
        return this.secondDigit;
      }
      getValue() {
        return this.firstDigit * 10 + this.secondDigit;
      }
      isFirstDigitFNC1() {
        return this.firstDigit === DecodedNumeric.FNC1;
      }
      isSecondDigitFNC1() {
        return this.secondDigit === DecodedNumeric.FNC1;
      }
      isAnyFNC1() {
        return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;
      }
    }
    DecodedNumeric.FNC1 = 10;
    class FieldParser {
      constructor() {
      }
      static parseFieldsInGeneralPurpose(rawInformation) {
        if (!rawInformation) {
          return null;
        }
        if (rawInformation.length < 2) {
          throw new NotFoundException();
        }
        let firstTwoDigits = rawInformation.substring(0, 2);
        for (let dataLength of FieldParser.TWO_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstTwoDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(2, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(2, dataLength[1], rawInformation);
          }
        }
        if (rawInformation.length < 3) {
          throw new NotFoundException();
        }
        let firstThreeDigits = rawInformation.substring(0, 3);
        for (let dataLength of FieldParser.THREE_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstThreeDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(3, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(3, dataLength[1], rawInformation);
          }
        }
        for (let dataLength of FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstThreeDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
          }
        }
        if (rawInformation.length < 4) {
          throw new NotFoundException();
        }
        let firstFourDigits = rawInformation.substring(0, 4);
        for (let dataLength of FieldParser.FOUR_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstFourDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
          }
        }
        throw new NotFoundException();
      }
      static processFixedAI(aiSize, fieldSize, rawInformation) {
        if (rawInformation.length < aiSize) {
          throw new NotFoundException();
        }
        let ai = rawInformation.substring(0, aiSize);
        if (rawInformation.length < aiSize + fieldSize) {
          throw new NotFoundException();
        }
        let field2 = rawInformation.substring(aiSize, aiSize + fieldSize);
        let remaining = rawInformation.substring(aiSize + fieldSize);
        let result = "(" + ai + ")" + field2;
        let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
        return parsedAI == null ? result : result + parsedAI;
      }
      static processVariableAI(aiSize, variableFieldSize, rawInformation) {
        let ai = rawInformation.substring(0, aiSize);
        let maxSize;
        if (rawInformation.length < aiSize + variableFieldSize) {
          maxSize = rawInformation.length;
        } else {
          maxSize = aiSize + variableFieldSize;
        }
        let field2 = rawInformation.substring(aiSize, maxSize);
        let remaining = rawInformation.substring(maxSize);
        let result = "(" + ai + ")" + field2;
        let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
        return parsedAI == null ? result : result + parsedAI;
      }
    }
    FieldParser.VARIABLE_LENGTH = [];
    FieldParser.TWO_DIGIT_DATA_LENGTH = [
      ["00", 18],
      ["01", 14],
      ["02", 14],
      ["10", FieldParser.VARIABLE_LENGTH, 20],
      ["11", 6],
      ["12", 6],
      ["13", 6],
      ["15", 6],
      ["17", 6],
      ["20", 2],
      ["21", FieldParser.VARIABLE_LENGTH, 20],
      ["22", FieldParser.VARIABLE_LENGTH, 29],
      ["30", FieldParser.VARIABLE_LENGTH, 8],
      ["37", FieldParser.VARIABLE_LENGTH, 8],
      // internal company codes
      ["90", FieldParser.VARIABLE_LENGTH, 30],
      ["91", FieldParser.VARIABLE_LENGTH, 30],
      ["92", FieldParser.VARIABLE_LENGTH, 30],
      ["93", FieldParser.VARIABLE_LENGTH, 30],
      ["94", FieldParser.VARIABLE_LENGTH, 30],
      ["95", FieldParser.VARIABLE_LENGTH, 30],
      ["96", FieldParser.VARIABLE_LENGTH, 30],
      ["97", FieldParser.VARIABLE_LENGTH, 3],
      ["98", FieldParser.VARIABLE_LENGTH, 30],
      ["99", FieldParser.VARIABLE_LENGTH, 30]
    ];
    FieldParser.THREE_DIGIT_DATA_LENGTH = [
      // Same format as above
      ["240", FieldParser.VARIABLE_LENGTH, 30],
      ["241", FieldParser.VARIABLE_LENGTH, 30],
      ["242", FieldParser.VARIABLE_LENGTH, 6],
      ["250", FieldParser.VARIABLE_LENGTH, 30],
      ["251", FieldParser.VARIABLE_LENGTH, 30],
      ["253", FieldParser.VARIABLE_LENGTH, 17],
      ["254", FieldParser.VARIABLE_LENGTH, 20],
      ["400", FieldParser.VARIABLE_LENGTH, 30],
      ["401", FieldParser.VARIABLE_LENGTH, 30],
      ["402", 17],
      ["403", FieldParser.VARIABLE_LENGTH, 30],
      ["410", 13],
      ["411", 13],
      ["412", 13],
      ["413", 13],
      ["414", 13],
      ["420", FieldParser.VARIABLE_LENGTH, 20],
      ["421", FieldParser.VARIABLE_LENGTH, 15],
      ["422", 3],
      ["423", FieldParser.VARIABLE_LENGTH, 15],
      ["424", 3],
      ["425", 3],
      ["426", 3]
    ];
    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
      // Same format as above
      ["310", 6],
      ["311", 6],
      ["312", 6],
      ["313", 6],
      ["314", 6],
      ["315", 6],
      ["316", 6],
      ["320", 6],
      ["321", 6],
      ["322", 6],
      ["323", 6],
      ["324", 6],
      ["325", 6],
      ["326", 6],
      ["327", 6],
      ["328", 6],
      ["329", 6],
      ["330", 6],
      ["331", 6],
      ["332", 6],
      ["333", 6],
      ["334", 6],
      ["335", 6],
      ["336", 6],
      ["340", 6],
      ["341", 6],
      ["342", 6],
      ["343", 6],
      ["344", 6],
      ["345", 6],
      ["346", 6],
      ["347", 6],
      ["348", 6],
      ["349", 6],
      ["350", 6],
      ["351", 6],
      ["352", 6],
      ["353", 6],
      ["354", 6],
      ["355", 6],
      ["356", 6],
      ["357", 6],
      ["360", 6],
      ["361", 6],
      ["362", 6],
      ["363", 6],
      ["364", 6],
      ["365", 6],
      ["366", 6],
      ["367", 6],
      ["368", 6],
      ["369", 6],
      ["390", FieldParser.VARIABLE_LENGTH, 15],
      ["391", FieldParser.VARIABLE_LENGTH, 18],
      ["392", FieldParser.VARIABLE_LENGTH, 15],
      ["393", FieldParser.VARIABLE_LENGTH, 18],
      ["703", FieldParser.VARIABLE_LENGTH, 30]
    ];
    FieldParser.FOUR_DIGIT_DATA_LENGTH = [
      // Same format as above
      ["7001", 13],
      ["7002", FieldParser.VARIABLE_LENGTH, 30],
      ["7003", 10],
      ["8001", 14],
      ["8002", FieldParser.VARIABLE_LENGTH, 20],
      ["8003", FieldParser.VARIABLE_LENGTH, 30],
      ["8004", FieldParser.VARIABLE_LENGTH, 30],
      ["8005", 6],
      ["8006", 18],
      ["8007", FieldParser.VARIABLE_LENGTH, 30],
      ["8008", FieldParser.VARIABLE_LENGTH, 12],
      ["8018", 18],
      ["8020", FieldParser.VARIABLE_LENGTH, 25],
      ["8100", 6],
      ["8101", 10],
      ["8102", 2],
      ["8110", FieldParser.VARIABLE_LENGTH, 70],
      ["8200", FieldParser.VARIABLE_LENGTH, 70]
    ];
    class GeneralAppIdDecoder {
      constructor(information) {
        this.buffer = new StringBuilder();
        this.information = information;
      }
      decodeAllCodes(buff, initialPosition) {
        let currentPosition = initialPosition;
        let remaining = null;
        do {
          let info = this.decodeGeneralPurposeField(currentPosition, remaining);
          let parsedFields = FieldParser.parseFieldsInGeneralPurpose(info.getNewString());
          if (parsedFields != null) {
            buff.append(parsedFields);
          }
          if (info.isRemaining()) {
            remaining = "" + info.getRemainingValue();
          } else {
            remaining = null;
          }
          if (currentPosition === info.getNewPosition()) {
            break;
          }
          currentPosition = info.getNewPosition();
        } while (true);
        return buff.toString();
      }
      isStillNumeric(pos) {
        if (pos + 7 > this.information.getSize()) {
          return pos + 4 <= this.information.getSize();
        }
        for (let i = pos; i < pos + 3; ++i) {
          if (this.information.get(i)) {
            return true;
          }
        }
        return this.information.get(pos + 3);
      }
      decodeNumeric(pos) {
        if (pos + 7 > this.information.getSize()) {
          let numeric2 = this.extractNumericValueFromBitArray(pos, 4);
          if (numeric2 === 0) {
            return new DecodedNumeric(this.information.getSize(), DecodedNumeric.FNC1, DecodedNumeric.FNC1);
          }
          return new DecodedNumeric(this.information.getSize(), numeric2 - 1, DecodedNumeric.FNC1);
        }
        let numeric = this.extractNumericValueFromBitArray(pos, 7);
        let digit1 = (numeric - 8) / 11;
        let digit2 = (numeric - 8) % 11;
        return new DecodedNumeric(pos + 7, digit1, digit2);
      }
      extractNumericValueFromBitArray(pos, bits) {
        return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);
      }
      static extractNumericValueFromBitArray(information, pos, bits) {
        let value = 0;
        for (let i = 0; i < bits; ++i) {
          if (information.get(pos + i)) {
            value |= 1 << bits - i - 1;
          }
        }
        return value;
      }
      decodeGeneralPurposeField(pos, remaining) {
        this.buffer.setLengthToZero();
        if (remaining != null) {
          this.buffer.append(remaining);
        }
        this.current.setPosition(pos);
        let lastDecoded = this.parseBlocks();
        if (lastDecoded != null && lastDecoded.isRemaining()) {
          return new DecodedInformation(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());
        }
        return new DecodedInformation(this.current.getPosition(), this.buffer.toString());
      }
      parseBlocks() {
        let isFinished;
        let result;
        do {
          let initialPosition = this.current.getPosition();
          if (this.current.isAlpha()) {
            result = this.parseAlphaBlock();
            isFinished = result.isFinished();
          } else if (this.current.isIsoIec646()) {
            result = this.parseIsoIec646Block();
            isFinished = result.isFinished();
          } else {
            result = this.parseNumericBlock();
            isFinished = result.isFinished();
          }
          let positionChanged = initialPosition !== this.current.getPosition();
          if (!positionChanged && !isFinished) {
            break;
          }
        } while (!isFinished);
        return result.getDecodedInformation();
      }
      parseNumericBlock() {
        while (this.isStillNumeric(this.current.getPosition())) {
          let numeric = this.decodeNumeric(this.current.getPosition());
          this.current.setPosition(numeric.getNewPosition());
          if (numeric.isFirstDigitFNC1()) {
            let information;
            if (numeric.isSecondDigitFNC1()) {
              information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            } else {
              information = new DecodedInformation(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());
            }
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(numeric.getFirstDigit());
          if (numeric.isSecondDigitFNC1()) {
            let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(numeric.getSecondDigit());
        }
        if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {
          this.current.setAlpha();
          this.current.incrementPosition(4);
        }
        return new BlockParsedResult(false);
      }
      parseIsoIec646Block() {
        while (this.isStillIsoIec646(this.current.getPosition())) {
          let iso = this.decodeIsoIec646(this.current.getPosition());
          this.current.setPosition(iso.getNewPosition());
          if (iso.isFNC1()) {
            let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(iso.getValue());
        }
        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
          this.current.incrementPosition(3);
          this.current.setNumeric();
        } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
          if (this.current.getPosition() + 5 < this.information.getSize()) {
            this.current.incrementPosition(5);
          } else {
            this.current.setPosition(this.information.getSize());
          }
          this.current.setAlpha();
        }
        return new BlockParsedResult(false);
      }
      parseAlphaBlock() {
        while (this.isStillAlpha(this.current.getPosition())) {
          let alpha = this.decodeAlphanumeric(this.current.getPosition());
          this.current.setPosition(alpha.getNewPosition());
          if (alpha.isFNC1()) {
            let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(alpha.getValue());
        }
        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
          this.current.incrementPosition(3);
          this.current.setNumeric();
        } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
          if (this.current.getPosition() + 5 < this.information.getSize()) {
            this.current.incrementPosition(5);
          } else {
            this.current.setPosition(this.information.getSize());
          }
          this.current.setIsoIec646();
        }
        return new BlockParsedResult(false);
      }
      isStillIsoIec646(pos) {
        if (pos + 5 > this.information.getSize()) {
          return false;
        }
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue >= 5 && fiveBitValue < 16) {
          return true;
        }
        if (pos + 7 > this.information.getSize()) {
          return false;
        }
        let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
        if (sevenBitValue >= 64 && sevenBitValue < 116) {
          return true;
        }
        if (pos + 8 > this.information.getSize()) {
          return false;
        }
        let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
        return eightBitValue >= 232 && eightBitValue < 253;
      }
      decodeIsoIec646(pos) {
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue === 15) {
          return new DecodedChar(pos + 5, DecodedChar.FNC1);
        }
        if (fiveBitValue >= 5 && fiveBitValue < 15) {
          return new DecodedChar(pos + 5, "0" + (fiveBitValue - 5));
        }
        let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
        if (sevenBitValue >= 64 && sevenBitValue < 90) {
          return new DecodedChar(pos + 7, "" + (sevenBitValue + 1));
        }
        if (sevenBitValue >= 90 && sevenBitValue < 116) {
          return new DecodedChar(pos + 7, "" + (sevenBitValue + 7));
        }
        let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
        let c;
        switch (eightBitValue) {
          case 232:
            c = "!";
            break;
          case 233:
            c = '"';
            break;
          case 234:
            c = "%";
            break;
          case 235:
            c = "&";
            break;
          case 236:
            c = "'";
            break;
          case 237:
            c = "(";
            break;
          case 238:
            c = ")";
            break;
          case 239:
            c = "*";
            break;
          case 240:
            c = "+";
            break;
          case 241:
            c = ",";
            break;
          case 242:
            c = "-";
            break;
          case 243:
            c = ".";
            break;
          case 244:
            c = "/";
            break;
          case 245:
            c = ":";
            break;
          case 246:
            c = ";";
            break;
          case 247:
            c = "<";
            break;
          case 248:
            c = "=";
            break;
          case 249:
            c = ">";
            break;
          case 250:
            c = "?";
            break;
          case 251:
            c = "_";
            break;
          case 252:
            c = " ";
            break;
          default:
            throw new FormatException();
        }
        return new DecodedChar(pos + 8, c);
      }
      isStillAlpha(pos) {
        if (pos + 5 > this.information.getSize()) {
          return false;
        }
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue >= 5 && fiveBitValue < 16) {
          return true;
        }
        if (pos + 6 > this.information.getSize()) {
          return false;
        }
        let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
        return sixBitValue >= 16 && sixBitValue < 63;
      }
      decodeAlphanumeric(pos) {
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue === 15) {
          return new DecodedChar(pos + 5, DecodedChar.FNC1);
        }
        if (fiveBitValue >= 5 && fiveBitValue < 15) {
          return new DecodedChar(pos + 5, "0" + (fiveBitValue - 5));
        }
        let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
        if (sixBitValue >= 32 && sixBitValue < 58) {
          return new DecodedChar(pos + 6, "" + (sixBitValue + 33));
        }
        let c;
        switch (sixBitValue) {
          case 58:
            c = "*";
            break;
          case 59:
            c = ",";
            break;
          case 60:
            c = "-";
            break;
          case 61:
            c = ".";
            break;
          case 62:
            c = "/";
            break;
          default:
            throw new IllegalStateException("Decoding invalid alphanumeric value: " + sixBitValue);
        }
        return new DecodedChar(pos + 6, c);
      }
      isAlphaTo646ToAlphaLatch(pos) {
        if (pos + 1 > this.information.getSize()) {
          return false;
        }
        for (let i = 0; i < 5 && i + pos < this.information.getSize(); ++i) {
          if (i === 2) {
            if (!this.information.get(pos + 2)) {
              return false;
            }
          } else if (this.information.get(pos + i)) {
            return false;
          }
        }
        return true;
      }
      isAlphaOr646ToNumericLatch(pos) {
        if (pos + 3 > this.information.getSize()) {
          return false;
        }
        for (let i = pos; i < pos + 3; ++i) {
          if (this.information.get(i)) {
            return false;
          }
        }
        return true;
      }
      isNumericToAlphaNumericLatch(pos) {
        if (pos + 1 > this.information.getSize()) {
          return false;
        }
        for (let i = 0; i < 4 && i + pos < this.information.getSize(); ++i) {
          if (this.information.get(pos + i)) {
            return false;
          }
        }
        return true;
      }
    }
    class AbstractExpandedDecoder {
      constructor(information) {
        this.information = information;
        this.generalDecoder = new GeneralAppIdDecoder(information);
      }
      getInformation() {
        return this.information;
      }
      getGeneralDecoder() {
        return this.generalDecoder;
      }
    }
    class AI01decoder extends AbstractExpandedDecoder {
      constructor(information) {
        super(information);
      }
      encodeCompressedGtin(buf, currentPos) {
        buf.append("(01)");
        let initialPosition = buf.length();
        buf.append("9");
        this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);
      }
      encodeCompressedGtinWithoutAI(buf, currentPos, initialBufferPosition) {
        for (let i = 0; i < 4; ++i) {
          let currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);
          if (currentBlock / 100 === 0) {
            buf.append("0");
          }
          if (currentBlock / 10 === 0) {
            buf.append("0");
          }
          buf.append(currentBlock);
        }
        AI01decoder.appendCheckDigit(buf, initialBufferPosition);
      }
      static appendCheckDigit(buf, currentPos) {
        let checkDigit = 0;
        for (let i = 0; i < 13; i++) {
          let digit = buf.charAt(i + currentPos).charCodeAt(0) - "0".charCodeAt(0);
          checkDigit += (i & 1) === 0 ? 3 * digit : digit;
        }
        checkDigit = 10 - checkDigit % 10;
        if (checkDigit === 10) {
          checkDigit = 0;
        }
        buf.append(checkDigit);
      }
    }
    AI01decoder.GTIN_SIZE = 40;
    class AI01AndOtherAIs extends AI01decoder {
      // the second one is the encodation method, and the other two are for the variable length
      constructor(information) {
        super(information);
      }
      parseInformation() {
        let buff = new StringBuilder();
        buff.append("(01)");
        let initialGtinPosition = buff.length();
        let firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);
        buff.append(firstGtinDigit);
        this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);
        return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);
      }
    }
    AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2;
    class AnyAIDecoder extends AbstractExpandedDecoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        let buf = new StringBuilder();
        return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);
      }
    }
    AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;
    class AI01weightDecoder extends AI01decoder {
      constructor(information) {
        super(information);
      }
      encodeCompressedWeight(buf, currentPos, weightSize) {
        let originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);
        this.addWeightCode(buf, originalWeightNumeric);
        let weightNumeric = this.checkWeight(originalWeightNumeric);
        let currentDivisor = 1e5;
        for (let i = 0; i < 5; ++i) {
          if (weightNumeric / currentDivisor === 0) {
            buf.append("0");
          }
          currentDivisor /= 10;
        }
        buf.append(weightNumeric);
      }
    }
    class AI013x0xDecoder extends AI01weightDecoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        if (this.getInformation().getSize() != AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE + AI013x0xDecoder.WEIGHT_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);
        this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);
        return buf.toString();
      }
    }
    AI013x0xDecoder.HEADER_SIZE = 4 + 1;
    AI013x0xDecoder.WEIGHT_SIZE = 15;
    class AI013103decoder extends AI013x0xDecoder {
      constructor(information) {
        super(information);
      }
      addWeightCode(buf, weight) {
        buf.append("(3103)");
      }
      checkWeight(weight) {
        return weight;
      }
    }
    class AI01320xDecoder extends AI013x0xDecoder {
      constructor(information) {
        super(information);
      }
      addWeightCode(buf, weight) {
        if (weight < 1e4) {
          buf.append("(3202)");
        } else {
          buf.append("(3203)");
        }
      }
      checkWeight(weight) {
        if (weight < 1e4) {
          return weight;
        }
        return weight - 1e4;
      }
    }
    class AI01392xDecoder extends AI01decoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);
        let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);
        buf.append("(392");
        buf.append(lastAIdigit);
        buf.append(")");
        let decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);
        buf.append(decodedInformation.getNewString());
        return buf.toString();
      }
    }
    AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;
    AI01392xDecoder.LAST_DIGIT_SIZE = 2;
    class AI01393xDecoder extends AI01decoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        if (this.getInformation().getSize() < AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);
        let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);
        buf.append("(393");
        buf.append(lastAIdigit);
        buf.append(")");
        let firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);
        if (firstThreeDigits / 100 == 0) {
          buf.append("0");
        }
        if (firstThreeDigits / 10 == 0) {
          buf.append("0");
        }
        buf.append(firstThreeDigits);
        let generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE + AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);
        buf.append(generalInformation.getNewString());
        return buf.toString();
      }
    }
    AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;
    AI01393xDecoder.LAST_DIGIT_SIZE = 2;
    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;
    class AI013x0x1xDecoder extends AI01weightDecoder {
      constructor(information, firstAIdigits, dateCode) {
        super(information);
        this.dateCode = dateCode;
        this.firstAIdigits = firstAIdigits;
      }
      parseInformation() {
        if (this.getInformation().getSize() != AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE + AI013x0x1xDecoder.DATE_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);
        this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);
        this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE);
        return buf.toString();
      }
      encodeCompressedDate(buf, currentPos) {
        let numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);
        if (numericDate == 38400) {
          return;
        }
        buf.append("(");
        buf.append(this.dateCode);
        buf.append(")");
        let day = numericDate % 32;
        numericDate /= 32;
        let month = numericDate % 12 + 1;
        numericDate /= 12;
        let year = numericDate;
        if (year / 10 == 0) {
          buf.append("0");
        }
        buf.append(year);
        if (month / 10 == 0) {
          buf.append("0");
        }
        buf.append(month);
        if (day / 10 == 0) {
          buf.append("0");
        }
        buf.append(day);
      }
      addWeightCode(buf, weight) {
        buf.append("(");
        buf.append(this.firstAIdigits);
        buf.append(weight / 1e5);
        buf.append(")");
      }
      checkWeight(weight) {
        return weight % 1e5;
      }
    }
    AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;
    AI013x0x1xDecoder.WEIGHT_SIZE = 20;
    AI013x0x1xDecoder.DATE_SIZE = 16;
    function createDecoder(information) {
      try {
        if (information.get(1)) {
          return new AI01AndOtherAIs(information);
        }
        if (!information.get(2)) {
          return new AnyAIDecoder(information);
        }
        let fourBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 4);
        switch (fourBitEncodationMethod) {
          case 4:
            return new AI013103decoder(information);
          case 5:
            return new AI01320xDecoder(information);
        }
        let fiveBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 5);
        switch (fiveBitEncodationMethod) {
          case 12:
            return new AI01392xDecoder(information);
          case 13:
            return new AI01393xDecoder(information);
        }
        let sevenBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 7);
        switch (sevenBitEncodationMethod) {
          case 56:
            return new AI013x0x1xDecoder(information, "310", "11");
          case 57:
            return new AI013x0x1xDecoder(information, "320", "11");
          case 58:
            return new AI013x0x1xDecoder(information, "310", "13");
          case 59:
            return new AI013x0x1xDecoder(information, "320", "13");
          case 60:
            return new AI013x0x1xDecoder(information, "310", "15");
          case 61:
            return new AI013x0x1xDecoder(information, "320", "15");
          case 62:
            return new AI013x0x1xDecoder(information, "310", "17");
          case 63:
            return new AI013x0x1xDecoder(information, "320", "17");
        }
      } catch (e) {
        console.log(e);
        throw new IllegalStateException("unknown decoder: " + information);
      }
    }
    class ExpandedPair {
      constructor(leftChar, rightChar, finderPatter, mayBeLast) {
        this.leftchar = leftChar;
        this.rightchar = rightChar;
        this.finderpattern = finderPatter;
        this.maybeLast = mayBeLast;
      }
      mayBeLast() {
        return this.maybeLast;
      }
      getLeftChar() {
        return this.leftchar;
      }
      getRightChar() {
        return this.rightchar;
      }
      getFinderPattern() {
        return this.finderpattern;
      }
      mustBeLast() {
        return this.rightchar == null;
      }
      toString() {
        return "[ " + this.leftchar + ", " + this.rightchar + " : " + (this.finderpattern == null ? "null" : this.finderpattern.getValue()) + " ]";
      }
      static equals(o1, o2) {
        if (!(o1 instanceof ExpandedPair)) {
          return false;
        }
        return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) && ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) && ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);
      }
      static equalsOrNull(o1, o2) {
        return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);
      }
      hashCode() {
        let value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();
        return value;
      }
    }
    class ExpandedRow {
      constructor(pairs, rowNumber, wasReversed) {
        this.pairs = pairs;
        this.rowNumber = rowNumber;
        this.wasReversed = wasReversed;
      }
      getPairs() {
        return this.pairs;
      }
      getRowNumber() {
        return this.rowNumber;
      }
      isReversed() {
        return this.wasReversed;
      }
      // check implementation
      isEquivalent(otherPairs) {
        return this.checkEqualitity(this, otherPairs);
      }
      // @Override
      toString() {
        return "{ " + this.pairs + " }";
      }
      /**
       * Two rows are equal if they contain the same pairs in the same order.
       */
      // @Override
      // check implementation
      equals(o1, o2) {
        if (!(o1 instanceof ExpandedRow)) {
          return false;
        }
        return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;
      }
      checkEqualitity(pair1, pair2) {
        if (!pair1 || !pair2)
          return;
        let result;
        pair1.forEach((e1, i) => {
          pair2.forEach((e2) => {
            if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {
              result = true;
            }
          });
        });
        return result;
      }
    }
    class RSSExpandedReader extends AbstractRSSReader {
      constructor(verbose) {
        super(...arguments);
        this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);
        this.rows = new Array();
        this.startEnd = [2];
        this.verbose = verbose === true;
      }
      decodeRow(rowNumber, row, hints) {
        this.pairs.length = 0;
        this.startFromEven = false;
        try {
          return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
        } catch (e) {
          if (this.verbose) {
            console.log(e);
          }
        }
        this.pairs.length = 0;
        this.startFromEven = true;
        return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
      }
      reset() {
        this.pairs.length = 0;
        this.rows.length = 0;
      }
      // Not private for testing
      decodeRow2pairs(rowNumber, row) {
        let done = false;
        while (!done) {
          try {
            this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));
          } catch (error) {
            if (error instanceof NotFoundException) {
              if (!this.pairs.length) {
                throw new NotFoundException();
              }
              done = true;
            }
          }
        }
        if (this.checkChecksum()) {
          return this.pairs;
        }
        let tryStackedDecode;
        if (this.rows.length) {
          tryStackedDecode = true;
        } else {
          tryStackedDecode = false;
        }
        this.storeRow(rowNumber, false);
        if (tryStackedDecode) {
          let ps = this.checkRowsBoolean(false);
          if (ps != null) {
            return ps;
          }
          ps = this.checkRowsBoolean(true);
          if (ps != null) {
            return ps;
          }
        }
        throw new NotFoundException();
      }
      // Need to Verify
      checkRowsBoolean(reverse) {
        if (this.rows.length > 25) {
          this.rows.length = 0;
          return null;
        }
        this.pairs.length = 0;
        if (reverse) {
          this.rows = this.rows.reverse();
        }
        let ps = null;
        try {
          ps = this.checkRows(new Array(), 0);
        } catch (e) {
          if (this.verbose) {
            console.log(e);
          }
        }
        if (reverse) {
          this.rows = this.rows.reverse();
        }
        return ps;
      }
      // Try to construct a valid rows sequence
      // Recursion is used to implement backtracking
      checkRows(collectedRows, currentRow) {
        for (let i = currentRow; i < this.rows.length; i++) {
          let row = this.rows[i];
          this.pairs.length = 0;
          for (let collectedRow of collectedRows) {
            this.pairs.push(collectedRow.getPairs());
          }
          this.pairs.push(row.getPairs());
          if (!RSSExpandedReader.isValidSequence(this.pairs)) {
            continue;
          }
          if (this.checkChecksum()) {
            return this.pairs;
          }
          let rs = new Array(collectedRows);
          rs.push(row);
          try {
            return this.checkRows(rs, i + 1);
          } catch (e) {
            if (this.verbose) {
              console.log(e);
            }
          }
        }
        throw new NotFoundException();
      }
      // Whether the pairs form a valid find pattern sequence,
      // either complete or a prefix
      static isValidSequence(pairs) {
        for (let sequence of RSSExpandedReader.FINDER_PATTERN_SEQUENCES) {
          if (pairs.length > sequence.length) {
            continue;
          }
          let stop = true;
          for (let j = 0; j < pairs.length; j++) {
            if (pairs[j].getFinderPattern().getValue() != sequence[j]) {
              stop = false;
              break;
            }
          }
          if (stop) {
            return true;
          }
        }
        return false;
      }
      storeRow(rowNumber, wasReversed) {
        let insertPos = 0;
        let prevIsSame = false;
        let nextIsSame = false;
        while (insertPos < this.rows.length) {
          let erow = this.rows[insertPos];
          if (erow.getRowNumber() > rowNumber) {
            nextIsSame = erow.isEquivalent(this.pairs);
            break;
          }
          prevIsSame = erow.isEquivalent(this.pairs);
          insertPos++;
        }
        if (nextIsSame || prevIsSame) {
          return;
        }
        if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {
          return;
        }
        this.rows.push(insertPos, new ExpandedRow(this.pairs, rowNumber, wasReversed));
        this.removePartialRows(this.pairs, this.rows);
      }
      // Remove all the rows that contains only specified pairs
      removePartialRows(pairs, rows) {
        for (let row of rows) {
          if (row.getPairs().length === pairs.length) {
            continue;
          }
          for (let p of row.getPairs()) {
            for (let pp of pairs) {
              if (ExpandedPair.equals(p, pp)) {
                break;
              }
            }
          }
        }
      }
      // Returns true when one of the rows already contains all the pairs
      static isPartialRow(pairs, rows) {
        for (let r of rows) {
          let allFound = true;
          for (let p of pairs) {
            let found = false;
            for (let pp of r.getPairs()) {
              if (p.equals(pp)) {
                found = true;
                break;
              }
            }
            if (!found) {
              allFound = false;
              break;
            }
          }
          if (allFound) {
            return true;
          }
        }
        return false;
      }
      // Only used for unit testing
      getRows() {
        return this.rows;
      }
      // Not private for unit testing
      static constructResult(pairs) {
        let binary2 = BitArrayBuilder.buildBitArray(pairs);
        let decoder = createDecoder(binary2);
        let resultingString = decoder.parseInformation();
        let firstPoints = pairs[0].getFinderPattern().getResultPoints();
        let lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();
        let points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];
        return new Result(resultingString, null, null, points, BarcodeFormat$1.RSS_EXPANDED, null);
      }
      checkChecksum() {
        let firstPair = this.pairs.get(0);
        let checkCharacter = firstPair.getLeftChar();
        let firstCharacter = firstPair.getRightChar();
        if (firstCharacter == null) {
          return false;
        }
        let checksum = firstCharacter.getChecksumPortion();
        let s = 2;
        for (let i = 1; i < this.pairs.size(); ++i) {
          let currentPair = this.pairs.get(i);
          checksum += currentPair.getLeftChar().getChecksumPortion();
          s++;
          let currentRightChar = currentPair.getRightChar();
          if (currentRightChar != null) {
            checksum += currentRightChar.getChecksumPortion();
            s++;
          }
        }
        checksum %= 211;
        let checkCharacterValue = 211 * (s - 4) + checksum;
        return checkCharacterValue == checkCharacter.getValue();
      }
      static getNextSecondBar(row, initialPos) {
        let currentPos;
        if (row.get(initialPos)) {
          currentPos = row.getNextUnset(initialPos);
          currentPos = row.getNextSet(currentPos);
        } else {
          currentPos = row.getNextSet(initialPos);
          currentPos = row.getNextUnset(currentPos);
        }
        return currentPos;
      }
      // not private for testing
      retrieveNextPair(row, previousPairs, rowNumber) {
        let isOddPattern = previousPairs.length % 2 == 0;
        if (this.startFromEven) {
          isOddPattern = !isOddPattern;
        }
        let pattern;
        let keepFinding = true;
        let forcedOffset = -1;
        do {
          this.findNextPair(row, previousPairs, forcedOffset);
          pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);
          if (pattern == null) {
            forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);
          } else {
            keepFinding = false;
          }
        } while (keepFinding);
        let leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);
        if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {
          throw new NotFoundException();
        }
        let rightChar;
        try {
          rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);
        } catch (e) {
          rightChar = null;
          if (this.verbose) {
            console.log(e);
          }
        }
        return new ExpandedPair(leftChar, rightChar, pattern, true);
      }
      isEmptyPair(pairs) {
        if (pairs.length === 0) {
          return true;
        }
        return false;
      }
      findNextPair(row, previousPairs, forcedOffset) {
        let counters = this.getDecodeFinderCounters();
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let width = row.getSize();
        let rowOffset;
        if (forcedOffset >= 0) {
          rowOffset = forcedOffset;
        } else if (this.isEmptyPair(previousPairs)) {
          rowOffset = 0;
        } else {
          let lastPair = previousPairs[previousPairs.length - 1];
          rowOffset = lastPair.getFinderPattern().getStartEnd()[1];
        }
        let searchingEvenPair = previousPairs.length % 2 != 0;
        if (this.startFromEven) {
          searchingEvenPair = !searchingEvenPair;
        }
        let isWhite = false;
        while (rowOffset < width) {
          isWhite = !row.get(rowOffset);
          if (!isWhite) {
            break;
          }
          rowOffset++;
        }
        let counterPosition = 0;
        let patternStart = rowOffset;
        for (let x = rowOffset; x < width; x++) {
          if (row.get(x) != isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition == 3) {
              if (searchingEvenPair) {
                RSSExpandedReader.reverseCounters(counters);
              }
              if (RSSExpandedReader.isFinderPattern(counters)) {
                this.startEnd[0] = patternStart;
                this.startEnd[1] = x;
                return;
              }
              if (searchingEvenPair) {
                RSSExpandedReader.reverseCounters(counters);
              }
              patternStart += counters[0] + counters[1];
              counters[0] = counters[2];
              counters[1] = counters[3];
              counters[2] = 0;
              counters[3] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static reverseCounters(counters) {
        let length = counters.length;
        for (let i = 0; i < length / 2; ++i) {
          let tmp = counters[i];
          counters[i] = counters[length - i - 1];
          counters[length - i - 1] = tmp;
        }
      }
      parseFoundFinderPattern(row, rowNumber, oddPattern) {
        let firstCounter;
        let start;
        let end;
        if (oddPattern) {
          let firstElementStart = this.startEnd[0] - 1;
          while (firstElementStart >= 0 && !row.get(firstElementStart)) {
            firstElementStart--;
          }
          firstElementStart++;
          firstCounter = this.startEnd[0] - firstElementStart;
          start = firstElementStart;
          end = this.startEnd[1];
        } else {
          start = this.startEnd[0];
          end = row.getNextUnset(this.startEnd[1] + 1);
          firstCounter = end - this.startEnd[1];
        }
        let counters = this.getDecodeFinderCounters();
        System.arraycopy(counters, 0, counters, 1, counters.length - 1);
        counters[0] = firstCounter;
        let value;
        try {
          value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);
        } catch (e) {
          return null;
        }
        return new FinderPattern(value, [start, end], start, end, rowNumber);
      }
      decodeDataCharacter(row, pattern, isOddPattern, leftChar) {
        let counters = this.getDataCharacterCounters();
        for (let x = 0; x < counters.length; x++) {
          counters[x] = 0;
        }
        if (leftChar) {
          RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
        } else {
          RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);
          for (let i = 0, j = counters.length - 1; i < j; i++, j--) {
            let temp = counters[i];
            counters[i] = counters[j];
            counters[j] = temp;
          }
        }
        let numModules = 17;
        let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
        let expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15;
        if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {
          throw new NotFoundException();
        }
        let oddCounts = this.getOddCounts();
        let evenCounts = this.getEvenCounts();
        let oddRoundingErrors = this.getOddRoundingErrors();
        let evenRoundingErrors = this.getEvenRoundingErrors();
        for (let i = 0; i < counters.length; i++) {
          let value2 = 1 * counters[i] / elementWidth;
          let count = value2 + 0.5;
          if (count < 1) {
            if (value2 < 0.3) {
              throw new NotFoundException();
            }
            count = 1;
          } else if (count > 8) {
            if (value2 > 8.7) {
              throw new NotFoundException();
            }
            count = 8;
          }
          let offset = i / 2;
          if ((i & 1) == 0) {
            oddCounts[offset] = count;
            oddRoundingErrors[offset] = value2 - count;
          } else {
            evenCounts[offset] = count;
            evenRoundingErrors[offset] = value2 - count;
          }
        }
        this.adjustOddEvenCounts(numModules);
        let weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;
        let oddSum = 0;
        let oddChecksumPortion = 0;
        for (let i = oddCounts.length - 1; i >= 0; i--) {
          if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
            let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i];
            oddChecksumPortion += oddCounts[i] * weight;
          }
          oddSum += oddCounts[i];
        }
        let evenChecksumPortion = 0;
        for (let i = evenCounts.length - 1; i >= 0; i--) {
          if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
            let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i + 1];
            evenChecksumPortion += evenCounts[i] * weight;
          }
        }
        let checksumPortion = oddChecksumPortion + evenChecksumPortion;
        if ((oddSum & 1) != 0 || oddSum > 13 || oddSum < 4) {
          throw new NotFoundException();
        }
        let group = (13 - oddSum) / 2;
        let oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];
        let evenWidest = 9 - oddWidest;
        let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
        let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
        let tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];
        let gSum = RSSExpandedReader.GSUM[group];
        let value = vOdd * tEven + vEven + gSum;
        return new DataCharacter(value, checksumPortion);
      }
      static isNotA1left(pattern, isOddPattern, leftChar) {
        return !(pattern.getValue() == 0 && isOddPattern && leftChar);
      }
      adjustOddEvenCounts(numModules) {
        let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
        let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
        let incrementOdd = false;
        let decrementOdd = false;
        if (oddSum > 13) {
          decrementOdd = true;
        } else if (oddSum < 4) {
          incrementOdd = true;
        }
        let incrementEven = false;
        let decrementEven = false;
        if (evenSum > 13) {
          decrementEven = true;
        } else if (evenSum < 4) {
          incrementEven = true;
        }
        let mismatch = oddSum + evenSum - numModules;
        let oddParityBad = (oddSum & 1) == 1;
        let evenParityBad = (evenSum & 1) == 0;
        if (mismatch == 1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            decrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            decrementEven = true;
          }
        } else if (mismatch == -1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            incrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            incrementEven = true;
          }
        } else if (mismatch == 0) {
          if (oddParityBad) {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            if (oddSum < evenSum) {
              incrementOdd = true;
              decrementEven = true;
            } else {
              decrementOdd = true;
              incrementEven = true;
            }
          } else {
            if (evenParityBad) {
              throw new NotFoundException();
            }
          }
        } else {
          throw new NotFoundException();
        }
        if (incrementOdd) {
          if (decrementOdd) {
            throw new NotFoundException();
          }
          RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (decrementOdd) {
          RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (incrementEven) {
          if (decrementEven) {
            throw new NotFoundException();
          }
          RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
        }
        if (decrementEven) {
          RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
        }
      }
    }
    RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];
    RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];
    RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];
    RSSExpandedReader.FINDER_PATTERNS = [
      Int32Array.from([1, 8, 4, 1]),
      Int32Array.from([3, 6, 4, 1]),
      Int32Array.from([3, 4, 6, 1]),
      Int32Array.from([3, 2, 8, 1]),
      Int32Array.from([2, 6, 5, 1]),
      Int32Array.from([2, 2, 9, 1])
      // F
    ];
    RSSExpandedReader.WEIGHTS = [
      [1, 3, 9, 27, 81, 32, 96, 77],
      [20, 60, 180, 118, 143, 7, 21, 63],
      [189, 145, 13, 39, 117, 140, 209, 205],
      [193, 157, 49, 147, 19, 57, 171, 91],
      [62, 186, 136, 197, 169, 85, 44, 132],
      [185, 133, 188, 142, 4, 12, 36, 108],
      [113, 128, 173, 97, 80, 29, 87, 50],
      [150, 28, 84, 41, 123, 158, 52, 156],
      [46, 138, 203, 187, 139, 206, 196, 166],
      [76, 17, 51, 153, 37, 111, 122, 155],
      [43, 129, 176, 106, 107, 110, 119, 146],
      [16, 48, 144, 10, 30, 90, 59, 177],
      [109, 116, 137, 200, 178, 112, 125, 164],
      [70, 210, 208, 202, 184, 130, 179, 115],
      [134, 191, 151, 31, 93, 68, 204, 190],
      [148, 22, 66, 198, 172, 94, 71, 2],
      [6, 18, 54, 162, 64, 192, 154, 40],
      [120, 149, 25, 75, 14, 42, 126, 167],
      [79, 26, 78, 23, 69, 207, 199, 175],
      [103, 98, 83, 38, 114, 131, 182, 124],
      [161, 61, 183, 127, 170, 88, 53, 159],
      [55, 165, 73, 8, 24, 72, 5, 15],
      [45, 135, 194, 160, 58, 174, 100, 89]
    ];
    RSSExpandedReader.FINDER_PAT_A = 0;
    RSSExpandedReader.FINDER_PAT_B = 1;
    RSSExpandedReader.FINDER_PAT_C = 2;
    RSSExpandedReader.FINDER_PAT_D = 3;
    RSSExpandedReader.FINDER_PAT_E = 4;
    RSSExpandedReader.FINDER_PAT_F = 5;
    RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_C],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_F],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F]
    ];
    RSSExpandedReader.MAX_PAIRS = 11;
    class Pair extends DataCharacter {
      constructor(value, checksumPortion, finderPattern) {
        super(value, checksumPortion);
        this.count = 0;
        this.finderPattern = finderPattern;
      }
      getFinderPattern() {
        return this.finderPattern;
      }
      getCount() {
        return this.count;
      }
      incrementCount() {
        this.count++;
      }
    }
    class RSS14Reader extends AbstractRSSReader {
      constructor() {
        super(...arguments);
        this.possibleLeftPairs = [];
        this.possibleRightPairs = [];
      }
      decodeRow(rowNumber, row, hints) {
        const leftPair = this.decodePair(row, false, rowNumber, hints);
        RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);
        row.reverse();
        let rightPair = this.decodePair(row, true, rowNumber, hints);
        RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);
        row.reverse();
        for (let left of this.possibleLeftPairs) {
          if (left.getCount() > 1) {
            for (let right of this.possibleRightPairs) {
              if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {
                return RSS14Reader.constructResult(left, right);
              }
            }
          }
        }
        throw new NotFoundException();
      }
      static addOrTally(possiblePairs, pair) {
        if (pair == null) {
          return;
        }
        let found = false;
        for (let other of possiblePairs) {
          if (other.getValue() === pair.getValue()) {
            other.incrementCount();
            found = true;
            break;
          }
        }
        if (!found) {
          possiblePairs.push(pair);
        }
      }
      reset() {
        this.possibleLeftPairs.length = 0;
        this.possibleRightPairs.length = 0;
      }
      static constructResult(leftPair, rightPair) {
        let symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();
        let text = new String(symbolValue).toString();
        let buffer = new StringBuilder();
        for (let i = 13 - text.length; i > 0; i--) {
          buffer.append("0");
        }
        buffer.append(text);
        let checkDigit = 0;
        for (let i = 0; i < 13; i++) {
          let digit = buffer.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
          checkDigit += (i & 1) === 0 ? 3 * digit : digit;
        }
        checkDigit = 10 - checkDigit % 10;
        if (checkDigit === 10) {
          checkDigit = 0;
        }
        buffer.append(checkDigit.toString());
        let leftPoints = leftPair.getFinderPattern().getResultPoints();
        let rightPoints = rightPair.getFinderPattern().getResultPoints();
        return new Result(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat$1.RSS_14, (/* @__PURE__ */ new Date()).getTime());
      }
      static checkChecksum(leftPair, rightPair) {
        let checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;
        let targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();
        if (targetCheckValue > 72) {
          targetCheckValue--;
        }
        if (targetCheckValue > 8) {
          targetCheckValue--;
        }
        return checkValue === targetCheckValue;
      }
      decodePair(row, right, rowNumber, hints) {
        try {
          let startEnd = this.findFinderPattern(row, right);
          let pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);
          let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
          if (resultPointCallback != null) {
            let center = (startEnd[0] + startEnd[1]) / 2;
            if (right) {
              center = row.getSize() - 1 - center;
            }
            resultPointCallback.foundPossibleResultPoint(new ResultPoint(center, rowNumber));
          }
          let outside = this.decodeDataCharacter(row, pattern, true);
          let inside = this.decodeDataCharacter(row, pattern, false);
          return new Pair(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);
        } catch (err2) {
          return null;
        }
      }
      decodeDataCharacter(row, pattern, outsideChar) {
        let counters = this.getDataCharacterCounters();
        for (let x = 0; x < counters.length; x++) {
          counters[x] = 0;
        }
        if (outsideChar) {
          OneDReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
        } else {
          OneDReader.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);
          for (let i = 0, j = counters.length - 1; i < j; i++, j--) {
            let temp = counters[i];
            counters[i] = counters[j];
            counters[j] = temp;
          }
        }
        let numModules = outsideChar ? 16 : 15;
        let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
        let oddCounts = this.getOddCounts();
        let evenCounts = this.getEvenCounts();
        let oddRoundingErrors = this.getOddRoundingErrors();
        let evenRoundingErrors = this.getEvenRoundingErrors();
        for (let i = 0; i < counters.length; i++) {
          let value = counters[i] / elementWidth;
          let count = Math.floor(value + 0.5);
          if (count < 1) {
            count = 1;
          } else if (count > 8) {
            count = 8;
          }
          let offset = Math.floor(i / 2);
          if ((i & 1) === 0) {
            oddCounts[offset] = count;
            oddRoundingErrors[offset] = value - count;
          } else {
            evenCounts[offset] = count;
            evenRoundingErrors[offset] = value - count;
          }
        }
        this.adjustOddEvenCounts(outsideChar, numModules);
        let oddSum = 0;
        let oddChecksumPortion = 0;
        for (let i = oddCounts.length - 1; i >= 0; i--) {
          oddChecksumPortion *= 9;
          oddChecksumPortion += oddCounts[i];
          oddSum += oddCounts[i];
        }
        let evenChecksumPortion = 0;
        let evenSum = 0;
        for (let i = evenCounts.length - 1; i >= 0; i--) {
          evenChecksumPortion *= 9;
          evenChecksumPortion += evenCounts[i];
          evenSum += evenCounts[i];
        }
        let checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;
        if (outsideChar) {
          if ((oddSum & 1) !== 0 || oddSum > 12 || oddSum < 4) {
            throw new NotFoundException();
          }
          let group = (12 - oddSum) / 2;
          let oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];
          let evenWidest = 9 - oddWidest;
          let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, false);
          let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, true);
          let tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];
          let gSum = RSS14Reader.OUTSIDE_GSUM[group];
          return new DataCharacter(vOdd * tEven + vEven + gSum, checksumPortion);
        } else {
          if ((evenSum & 1) !== 0 || evenSum > 10 || evenSum < 4) {
            throw new NotFoundException();
          }
          let group = (10 - evenSum) / 2;
          let oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];
          let evenWidest = 9 - oddWidest;
          let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
          let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
          let tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];
          let gSum = RSS14Reader.INSIDE_GSUM[group];
          return new DataCharacter(vEven * tOdd + vOdd + gSum, checksumPortion);
        }
      }
      findFinderPattern(row, rightFinderPattern) {
        let counters = this.getDecodeFinderCounters();
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let width = row.getSize();
        let isWhite = false;
        let rowOffset = 0;
        while (rowOffset < width) {
          isWhite = !row.get(rowOffset);
          if (rightFinderPattern === isWhite) {
            break;
          }
          rowOffset++;
        }
        let counterPosition = 0;
        let patternStart = rowOffset;
        for (let x = rowOffset; x < width; x++) {
          if (row.get(x) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === 3) {
              if (AbstractRSSReader.isFinderPattern(counters)) {
                return [patternStart, x];
              }
              patternStart += counters[0] + counters[1];
              counters[0] = counters[2];
              counters[1] = counters[3];
              counters[2] = 0;
              counters[3] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      parseFoundFinderPattern(row, rowNumber, right, startEnd) {
        let firstIsBlack = row.get(startEnd[0]);
        let firstElementStart = startEnd[0] - 1;
        while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {
          firstElementStart--;
        }
        firstElementStart++;
        const firstCounter = startEnd[0] - firstElementStart;
        const counters = this.getDecodeFinderCounters();
        const copy = new Int32Array(counters.length);
        System.arraycopy(counters, 0, copy, 1, counters.length - 1);
        copy[0] = firstCounter;
        const value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);
        let start = firstElementStart;
        let end = startEnd[1];
        if (right) {
          start = row.getSize() - 1 - start;
          end = row.getSize() - 1 - end;
        }
        return new FinderPattern(value, [firstElementStart, startEnd[1]], start, end, rowNumber);
      }
      adjustOddEvenCounts(outsideChar, numModules) {
        let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
        let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
        let incrementOdd = false;
        let decrementOdd = false;
        let incrementEven = false;
        let decrementEven = false;
        if (outsideChar) {
          if (oddSum > 12) {
            decrementOdd = true;
          } else if (oddSum < 4) {
            incrementOdd = true;
          }
          if (evenSum > 12) {
            decrementEven = true;
          } else if (evenSum < 4) {
            incrementEven = true;
          }
        } else {
          if (oddSum > 11) {
            decrementOdd = true;
          } else if (oddSum < 5) {
            incrementOdd = true;
          }
          if (evenSum > 10) {
            decrementEven = true;
          } else if (evenSum < 4) {
            incrementEven = true;
          }
        }
        let mismatch = oddSum + evenSum - numModules;
        let oddParityBad = (oddSum & 1) === (outsideChar ? 1 : 0);
        let evenParityBad = (evenSum & 1) === 1;
        if (mismatch === 1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            decrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            decrementEven = true;
          }
        } else if (mismatch === -1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            incrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            incrementEven = true;
          }
        } else if (mismatch === 0) {
          if (oddParityBad) {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            if (oddSum < evenSum) {
              incrementOdd = true;
              decrementEven = true;
            } else {
              decrementOdd = true;
              incrementEven = true;
            }
          } else {
            if (evenParityBad) {
              throw new NotFoundException();
            }
          }
        } else {
          throw new NotFoundException();
        }
        if (incrementOdd) {
          if (decrementOdd) {
            throw new NotFoundException();
          }
          AbstractRSSReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (decrementOdd) {
          AbstractRSSReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (incrementEven) {
          if (decrementEven) {
            throw new NotFoundException();
          }
          AbstractRSSReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
        }
        if (decrementEven) {
          AbstractRSSReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
        }
      }
    }
    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];
    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];
    RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];
    RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];
    RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];
    RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];
    RSS14Reader.FINDER_PATTERNS = [
      Int32Array.from([3, 8, 2, 1]),
      Int32Array.from([3, 5, 5, 1]),
      Int32Array.from([3, 3, 7, 1]),
      Int32Array.from([3, 1, 9, 1]),
      Int32Array.from([2, 7, 4, 1]),
      Int32Array.from([2, 5, 6, 1]),
      Int32Array.from([2, 3, 8, 1]),
      Int32Array.from([1, 5, 7, 1]),
      Int32Array.from([1, 3, 9, 1])
    ];
    class MultiFormatOneDReader extends OneDReader {
      constructor(hints, verbose) {
        super();
        this.readers = [];
        this.verbose = verbose === true;
        const possibleFormats = !hints ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
        const useCode39CheckDigit = hints && hints.get(DecodeHintType$1.ASSUME_CODE_39_CHECK_DIGIT) !== void 0;
        if (possibleFormats) {
          if (possibleFormats.includes(BarcodeFormat$1.EAN_13) || possibleFormats.includes(BarcodeFormat$1.UPC_A) || possibleFormats.includes(BarcodeFormat$1.EAN_8) || possibleFormats.includes(BarcodeFormat$1.UPC_E)) {
            this.readers.push(new MultiFormatUPCEANReader(hints));
          }
          if (possibleFormats.includes(BarcodeFormat$1.CODE_39)) {
            this.readers.push(new Code39Reader(useCode39CheckDigit));
          }
          if (possibleFormats.includes(BarcodeFormat$1.CODE_128)) {
            this.readers.push(new Code128Reader());
          }
          if (possibleFormats.includes(BarcodeFormat$1.ITF)) {
            this.readers.push(new ITFReader());
          }
          if (possibleFormats.includes(BarcodeFormat$1.RSS_14)) {
            this.readers.push(new RSS14Reader());
          }
          if (possibleFormats.includes(BarcodeFormat$1.RSS_EXPANDED)) {
            this.readers.push(new RSSExpandedReader(this.verbose));
          }
        } else {
          this.readers.push(new MultiFormatUPCEANReader(hints));
          this.readers.push(new Code39Reader());
          this.readers.push(new MultiFormatUPCEANReader(hints));
          this.readers.push(new Code128Reader());
          this.readers.push(new ITFReader());
          this.readers.push(new RSS14Reader());
          this.readers.push(new RSSExpandedReader(this.verbose));
        }
      }
      // @Override
      decodeRow(rowNumber, row, hints) {
        for (let i = 0; i < this.readers.length; i++) {
          try {
            return this.readers[i].decodeRow(rowNumber, row, hints);
          } catch (re) {
          }
        }
        throw new NotFoundException();
      }
      // @Override
      reset() {
        this.readers.forEach((reader) => reader.reset());
      }
    }
    class BrowserBarcodeReader extends BrowserCodeReader {
      /**
       * Creates an instance of BrowserBarcodeReader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       * @param {Map<DecodeHintType, any>} hints
       */
      constructor(timeBetweenScansMillis = 500, hints) {
        super(new MultiFormatOneDReader(hints), timeBetweenScansMillis, hints);
      }
    }
    class ECBlocks {
      constructor(ecCodewords, ecBlocks1, ecBlocks2) {
        this.ecCodewords = ecCodewords;
        this.ecBlocks = [ecBlocks1];
        ecBlocks2 && this.ecBlocks.push(ecBlocks2);
      }
      getECCodewords() {
        return this.ecCodewords;
      }
      getECBlocks() {
        return this.ecBlocks;
      }
    }
    class ECB {
      constructor(count, dataCodewords) {
        this.count = count;
        this.dataCodewords = dataCodewords;
      }
      getCount() {
        return this.count;
      }
      getDataCodewords() {
        return this.dataCodewords;
      }
    }
    class Version2 {
      constructor(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {
        this.versionNumber = versionNumber;
        this.symbolSizeRows = symbolSizeRows;
        this.symbolSizeColumns = symbolSizeColumns;
        this.dataRegionSizeRows = dataRegionSizeRows;
        this.dataRegionSizeColumns = dataRegionSizeColumns;
        this.ecBlocks = ecBlocks;
        let total = 0;
        const ecCodewords = ecBlocks.getECCodewords();
        const ecbArray = ecBlocks.getECBlocks();
        for (let ecBlock of ecbArray) {
          total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
        }
        this.totalCodewords = total;
      }
      getVersionNumber() {
        return this.versionNumber;
      }
      getSymbolSizeRows() {
        return this.symbolSizeRows;
      }
      getSymbolSizeColumns() {
        return this.symbolSizeColumns;
      }
      getDataRegionSizeRows() {
        return this.dataRegionSizeRows;
      }
      getDataRegionSizeColumns() {
        return this.dataRegionSizeColumns;
      }
      getTotalCodewords() {
        return this.totalCodewords;
      }
      getECBlocks() {
        return this.ecBlocks;
      }
      /**
       * <p>Deduces version information from Data Matrix dimensions.</p>
       *
       * @param numRows Number of rows in modules
       * @param numColumns Number of columns in modules
       * @return Version for a Data Matrix Code of those dimensions
       * @throws FormatException if dimensions do correspond to a valid Data Matrix size
       */
      static getVersionForDimensions(numRows, numColumns) {
        if ((numRows & 1) !== 0 || (numColumns & 1) !== 0) {
          throw new FormatException();
        }
        for (let version2 of Version2.VERSIONS) {
          if (version2.symbolSizeRows === numRows && version2.symbolSizeColumns === numColumns) {
            return version2;
          }
        }
        throw new FormatException();
      }
      //  @Override
      toString() {
        return "" + this.versionNumber;
      }
      /**
       * See ISO 16022:2006 5.5.1 Table 7
       */
      static buildVersions() {
        return [
          new Version2(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),
          new Version2(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),
          new Version2(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),
          new Version2(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),
          new Version2(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),
          new Version2(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),
          new Version2(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),
          new Version2(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),
          new Version2(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),
          new Version2(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),
          new Version2(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),
          new Version2(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),
          new Version2(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),
          new Version2(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),
          new Version2(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),
          new Version2(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),
          new Version2(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),
          new Version2(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),
          new Version2(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),
          new Version2(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),
          new Version2(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),
          new Version2(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),
          new Version2(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),
          new Version2(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),
          new Version2(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),
          new Version2(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),
          new Version2(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),
          new Version2(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),
          new Version2(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),
          new Version2(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))
        ];
      }
    }
    Version2.VERSIONS = Version2.buildVersions();
    class BitMatrixParser {
      /**
       * @param bitMatrix {@link BitMatrix} to parse
       * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2
       */
      constructor(bitMatrix) {
        const dimension = bitMatrix.getHeight();
        if (dimension < 8 || dimension > 144 || (dimension & 1) !== 0) {
          throw new FormatException();
        }
        this.version = BitMatrixParser.readVersion(bitMatrix);
        this.mappingBitMatrix = this.extractDataRegion(bitMatrix);
        this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());
      }
      getVersion() {
        return this.version;
      }
      /**
       * <p>Creates the version object based on the dimension of the original bit matrix from
       * the datamatrix code.</p>
       *
       * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>
       *
       * @param bitMatrix Original {@link BitMatrix} including alignment patterns
       * @return {@link Version} encapsulating the Data Matrix Code's "version"
       * @throws FormatException if the dimensions of the mapping matrix are not valid
       * Data Matrix dimensions.
       */
      static readVersion(bitMatrix) {
        const numRows = bitMatrix.getHeight();
        const numColumns = bitMatrix.getWidth();
        return Version2.getVersionForDimensions(numRows, numColumns);
      }
      /**
       * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)
       * in the correct order in order to reconstitute the codewords bytes contained within the
       * Data Matrix Code.</p>
       *
       * @return bytes encoded within the Data Matrix Code
       * @throws FormatException if the exact number of bytes expected is not read
       */
      readCodewords() {
        const result = new Int8Array(this.version.getTotalCodewords());
        let resultOffset = 0;
        let row = 4;
        let column = 0;
        const numRows = this.mappingBitMatrix.getHeight();
        const numColumns = this.mappingBitMatrix.getWidth();
        let corner1Read = false;
        let corner2Read = false;
        let corner3Read = false;
        let corner4Read = false;
        do {
          if (row === numRows && column === 0 && !corner1Read) {
            result[resultOffset++] = this.readCorner1(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner1Read = true;
          } else if (row === numRows - 2 && column === 0 && (numColumns & 3) !== 0 && !corner2Read) {
            result[resultOffset++] = this.readCorner2(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner2Read = true;
          } else if (row === numRows + 4 && column === 2 && (numColumns & 7) === 0 && !corner3Read) {
            result[resultOffset++] = this.readCorner3(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner3Read = true;
          } else if (row === numRows - 2 && column === 0 && (numColumns & 7) === 4 && !corner4Read) {
            result[resultOffset++] = this.readCorner4(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner4Read = true;
          } else {
            do {
              if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {
                result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
              }
              row -= 2;
              column += 2;
            } while (row >= 0 && column < numColumns);
            row += 1;
            column += 3;
            do {
              if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {
                result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
              }
              row += 2;
              column -= 2;
            } while (row < numRows && column >= 0);
            row += 3;
            column += 1;
          }
        } while (row < numRows || column < numColumns);
        if (resultOffset !== this.version.getTotalCodewords()) {
          throw new FormatException();
        }
        return result;
      }
      /**
       * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>
       *
       * @param row Row to read in the mapping matrix
       * @param column Column to read in the mapping matrix
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return value of the given bit in the mapping matrix
       */
      readModule(row, column, numRows, numColumns) {
        if (row < 0) {
          row += numRows;
          column += 4 - (numRows + 4 & 7);
        }
        if (column < 0) {
          column += numColumns;
          row += 4 - (numColumns + 4 & 7);
        }
        this.readMappingMatrix.set(column, row);
        return this.mappingBitMatrix.get(column, row);
      }
      /**
       * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>
       *
       * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>
       *
       * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern
       * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return byte from the utah shape
       */
      readUtah(row, column, numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(row - 2, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 2, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      /**
       * <p>Reads the 8 bits of the special corner condition 1.</p>
       *
       * <p>See ISO 16022:2006, Figure F.3</p>
       *
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return byte from the Corner condition 1
       */
      readCorner1(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      /**
       * <p>Reads the 8 bits of the special corner condition 2.</p>
       *
       * <p>See ISO 16022:2006, Figure F.4</p>
       *
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return byte from the Corner condition 2
       */
      readCorner2(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 4, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      /**
       * <p>Reads the 8 bits of the special corner condition 3.</p>
       *
       * <p>See ISO 16022:2006, Figure F.5</p>
       *
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return byte from the Corner condition 3
       */
      readCorner3(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      /**
       * <p>Reads the 8 bits of the special corner condition 4.</p>
       *
       * <p>See ISO 16022:2006, Figure F.6</p>
       *
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return byte from the Corner condition 4
       */
      readCorner4(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      /**
       * <p>Extracts the data region from a {@link BitMatrix} that contains
       * alignment patterns.</p>
       *
       * @param bitMatrix Original {@link BitMatrix} with alignment patterns
       * @return BitMatrix that has the alignment patterns removed
       */
      extractDataRegion(bitMatrix) {
        const symbolSizeRows = this.version.getSymbolSizeRows();
        const symbolSizeColumns = this.version.getSymbolSizeColumns();
        if (bitMatrix.getHeight() !== symbolSizeRows) {
          throw new IllegalArgumentException("Dimension of bitMatrix must match the version size");
        }
        const dataRegionSizeRows = this.version.getDataRegionSizeRows();
        const dataRegionSizeColumns = this.version.getDataRegionSizeColumns();
        const numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;
        const numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;
        const sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;
        const sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;
        const bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);
        for (let dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {
          const dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;
          for (let dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {
            const dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;
            for (let i = 0; i < dataRegionSizeRows; ++i) {
              const readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;
              const writeRowOffset = dataRegionRowOffset + i;
              for (let j = 0; j < dataRegionSizeColumns; ++j) {
                const readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;
                if (bitMatrix.get(readColumnOffset, readRowOffset)) {
                  const writeColumnOffset = dataRegionColumnOffset + j;
                  bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);
                }
              }
            }
          }
        }
        return bitMatrixWithoutAlignment;
      }
    }
    class DataBlock {
      constructor(numDataCodewords, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
      }
      /**
       * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.
       * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
       * method will separate the data into original blocks.</p>
       *
       * @param rawCodewords bytes as read directly from the Data Matrix Code
       * @param version version of the Data Matrix Code
       * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
       *         Data Matrix Code
       */
      static getDataBlocks(rawCodewords, version2) {
        const ecBlocks = version2.getECBlocks();
        let totalBlocks = 0;
        const ecBlockArray = ecBlocks.getECBlocks();
        for (let ecBlock of ecBlockArray) {
          totalBlocks += ecBlock.getCount();
        }
        const result = new Array(totalBlocks);
        let numResultBlocks = 0;
        for (let ecBlock of ecBlockArray) {
          for (let i = 0; i < ecBlock.getCount(); i++) {
            const numDataCodewords = ecBlock.getDataCodewords();
            const numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;
            result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));
          }
        }
        const longerBlocksTotalCodewords = result[0].codewords.length;
        const longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();
        const shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;
        let rawCodewordsOffset = 0;
        for (let i = 0; i < shorterBlocksNumDataCodewords; i++) {
          for (let j = 0; j < numResultBlocks; j++) {
            result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
          }
        }
        const specialVersion = version2.getVersionNumber() === 24;
        const numLongerBlocks = specialVersion ? 8 : numResultBlocks;
        for (let j = 0; j < numLongerBlocks; j++) {
          result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];
        }
        const max = result[0].codewords.length;
        for (let i = longerBlocksNumDataCodewords; i < max; i++) {
          for (let j = 0; j < numResultBlocks; j++) {
            const jOffset = specialVersion ? (j + 8) % numResultBlocks : j;
            const iOffset = specialVersion && jOffset > 7 ? i - 1 : i;
            result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
          }
        }
        if (rawCodewordsOffset !== rawCodewords.length) {
          throw new IllegalArgumentException();
        }
        return result;
      }
      getNumDataCodewords() {
        return this.numDataCodewords;
      }
      getCodewords() {
        return this.codewords;
      }
    }
    class BitSource {
      /**
       * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.
       * Bits are read within a byte from most-significant to least-significant bit.
       */
      constructor(bytes2) {
        this.bytes = bytes2;
        this.byteOffset = 0;
        this.bitOffset = 0;
      }
      /**
       * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.
       */
      getBitOffset() {
        return this.bitOffset;
      }
      /**
       * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.
       */
      getByteOffset() {
        return this.byteOffset;
      }
      /**
       * @param numBits number of bits to read
       * @return int representing the bits read. The bits will appear as the least-significant
       *         bits of the int
       * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available
       */
      readBits(numBits) {
        if (numBits < 1 || numBits > 32 || numBits > this.available()) {
          throw new IllegalArgumentException("" + numBits);
        }
        let result = 0;
        let bitOffset = this.bitOffset;
        let byteOffset = this.byteOffset;
        const bytes2 = this.bytes;
        if (bitOffset > 0) {
          const bitsLeft = 8 - bitOffset;
          const toRead = numBits < bitsLeft ? numBits : bitsLeft;
          const bitsToNotRead = bitsLeft - toRead;
          const mask2 = 255 >> 8 - toRead << bitsToNotRead;
          result = (bytes2[byteOffset] & mask2) >> bitsToNotRead;
          numBits -= toRead;
          bitOffset += toRead;
          if (bitOffset === 8) {
            bitOffset = 0;
            byteOffset++;
          }
        }
        if (numBits > 0) {
          while (numBits >= 8) {
            result = result << 8 | bytes2[byteOffset] & 255;
            byteOffset++;
            numBits -= 8;
          }
          if (numBits > 0) {
            const bitsToNotRead = 8 - numBits;
            const mask2 = 255 >> bitsToNotRead << bitsToNotRead;
            result = result << numBits | (bytes2[byteOffset] & mask2) >> bitsToNotRead;
            bitOffset += numBits;
          }
        }
        this.bitOffset = bitOffset;
        this.byteOffset = byteOffset;
        return result;
      }
      /**
       * @return number of bits that can be read successfully
       */
      available() {
        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
      }
    }
    var Mode;
    (function(Mode2) {
      Mode2[Mode2["PAD_ENCODE"] = 0] = "PAD_ENCODE";
      Mode2[Mode2["ASCII_ENCODE"] = 1] = "ASCII_ENCODE";
      Mode2[Mode2["C40_ENCODE"] = 2] = "C40_ENCODE";
      Mode2[Mode2["TEXT_ENCODE"] = 3] = "TEXT_ENCODE";
      Mode2[Mode2["ANSIX12_ENCODE"] = 4] = "ANSIX12_ENCODE";
      Mode2[Mode2["EDIFACT_ENCODE"] = 5] = "EDIFACT_ENCODE";
      Mode2[Mode2["BASE256_ENCODE"] = 6] = "BASE256_ENCODE";
    })(Mode || (Mode = {}));
    class DecodedBitStreamParser {
      static decode(bytes2) {
        const bits = new BitSource(bytes2);
        const result = new StringBuilder();
        const resultTrailer = new StringBuilder();
        const byteSegments = new Array();
        let mode = Mode.ASCII_ENCODE;
        do {
          if (mode === Mode.ASCII_ENCODE) {
            mode = this.decodeAsciiSegment(bits, result, resultTrailer);
          } else {
            switch (mode) {
              case Mode.C40_ENCODE:
                this.decodeC40Segment(bits, result);
                break;
              case Mode.TEXT_ENCODE:
                this.decodeTextSegment(bits, result);
                break;
              case Mode.ANSIX12_ENCODE:
                this.decodeAnsiX12Segment(bits, result);
                break;
              case Mode.EDIFACT_ENCODE:
                this.decodeEdifactSegment(bits, result);
                break;
              case Mode.BASE256_ENCODE:
                this.decodeBase256Segment(bits, result, byteSegments);
                break;
              default:
                throw new FormatException();
            }
            mode = Mode.ASCII_ENCODE;
          }
        } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);
        if (resultTrailer.length() > 0) {
          result.append(resultTrailer.toString());
        }
        return new DecoderResult(bytes2, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);
      }
      /**
       * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2
       */
      static decodeAsciiSegment(bits, result, resultTrailer) {
        let upperShift = false;
        do {
          let oneByte = bits.readBits(8);
          if (oneByte === 0) {
            throw new FormatException();
          } else if (oneByte <= 128) {
            if (upperShift) {
              oneByte += 128;
            }
            result.append(String.fromCharCode(oneByte - 1));
            return Mode.ASCII_ENCODE;
          } else if (oneByte === 129) {
            return Mode.PAD_ENCODE;
          } else if (oneByte <= 229) {
            const value = oneByte - 130;
            if (value < 10) {
              result.append("0");
            }
            result.append("" + value);
          } else {
            switch (oneByte) {
              case 230:
                return Mode.C40_ENCODE;
              case 231:
                return Mode.BASE256_ENCODE;
              case 232:
                result.append(String.fromCharCode(29));
                break;
              case 233:
              case 234:
                break;
              case 235:
                upperShift = true;
                break;
              case 236:
                result.append("[)>05");
                resultTrailer.insert(0, "");
                break;
              case 237:
                result.append("[)>06");
                resultTrailer.insert(0, "");
                break;
              case 238:
                return Mode.ANSIX12_ENCODE;
              case 239:
                return Mode.TEXT_ENCODE;
              case 240:
                return Mode.EDIFACT_ENCODE;
              case 241:
                break;
              default:
                if (oneByte !== 254 || bits.available() !== 0) {
                  throw new FormatException();
                }
                break;
            }
          }
        } while (bits.available() > 0);
        return Mode.ASCII_ENCODE;
      }
      /**
       * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1
       */
      static decodeC40Segment(bits, result) {
        let upperShift = false;
        const cValues = [];
        let shift = 0;
        do {
          if (bits.available() === 8) {
            return;
          }
          const firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (let i = 0; i < 3; i++) {
            const cValue = cValues[i];
            switch (shift) {
              case 0:
                if (cValue < 3) {
                  shift = cValue + 1;
                } else if (cValue < this.C40_BASIC_SET_CHARS.length) {
                  const c40char = this.C40_BASIC_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(c40char);
                  }
                } else {
                  throw new FormatException();
                }
                break;
              case 1:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 128));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue));
                }
                shift = 0;
                break;
              case 2:
                if (cValue < this.C40_SHIFT2_SET_CHARS.length) {
                  const c40char = this.C40_SHIFT2_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(c40char);
                  }
                } else {
                  switch (cValue) {
                    case 27:
                      result.append(String.fromCharCode(29));
                      break;
                    case 30:
                      upperShift = true;
                      break;
                    default:
                      throw new FormatException();
                  }
                }
                shift = 0;
                break;
              case 3:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 224));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue + 96));
                }
                shift = 0;
                break;
              default:
                throw new FormatException();
            }
          }
        } while (bits.available() > 0);
      }
      /**
       * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2
       */
      static decodeTextSegment(bits, result) {
        let upperShift = false;
        let cValues = [];
        let shift = 0;
        do {
          if (bits.available() === 8) {
            return;
          }
          const firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (let i = 0; i < 3; i++) {
            const cValue = cValues[i];
            switch (shift) {
              case 0:
                if (cValue < 3) {
                  shift = cValue + 1;
                } else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {
                  const textChar = this.TEXT_BASIC_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                } else {
                  throw new FormatException();
                }
                break;
              case 1:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 128));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue));
                }
                shift = 0;
                break;
              case 2:
                if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {
                  const textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                } else {
                  switch (cValue) {
                    case 27:
                      result.append(String.fromCharCode(29));
                      break;
                    case 30:
                      upperShift = true;
                      break;
                    default:
                      throw new FormatException();
                  }
                }
                shift = 0;
                break;
              case 3:
                if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {
                  const textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                  shift = 0;
                } else {
                  throw new FormatException();
                }
                break;
              default:
                throw new FormatException();
            }
          }
        } while (bits.available() > 0);
      }
      /**
       * See ISO 16022:2006, 5.2.7
       */
      static decodeAnsiX12Segment(bits, result) {
        const cValues = [];
        do {
          if (bits.available() === 8) {
            return;
          }
          const firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (let i = 0; i < 3; i++) {
            const cValue = cValues[i];
            switch (cValue) {
              case 0:
                result.append("\r");
                break;
              case 1:
                result.append("*");
                break;
              case 2:
                result.append(">");
                break;
              case 3:
                result.append(" ");
                break;
              default:
                if (cValue < 14) {
                  result.append(String.fromCharCode(cValue + 44));
                } else if (cValue < 40) {
                  result.append(String.fromCharCode(cValue + 51));
                } else {
                  throw new FormatException();
                }
                break;
            }
          }
        } while (bits.available() > 0);
      }
      static parseTwoBytes(firstByte, secondByte, result) {
        let fullBitValue = (firstByte << 8) + secondByte - 1;
        let temp = Math.floor(fullBitValue / 1600);
        result[0] = temp;
        fullBitValue -= temp * 1600;
        temp = Math.floor(fullBitValue / 40);
        result[1] = temp;
        result[2] = fullBitValue - temp * 40;
      }
      /**
       * See ISO 16022:2006, 5.2.8 and Annex C Table C.3
       */
      static decodeEdifactSegment(bits, result) {
        do {
          if (bits.available() <= 16) {
            return;
          }
          for (let i = 0; i < 4; i++) {
            let edifactValue = bits.readBits(6);
            if (edifactValue === 31) {
              const bitsLeft = 8 - bits.getBitOffset();
              if (bitsLeft !== 8) {
                bits.readBits(bitsLeft);
              }
              return;
            }
            if ((edifactValue & 32) === 0) {
              edifactValue |= 64;
            }
            result.append(String.fromCharCode(edifactValue));
          }
        } while (bits.available() > 0);
      }
      /**
       * See ISO 16022:2006, 5.2.9 and Annex B, B.2
       */
      static decodeBase256Segment(bits, result, byteSegments) {
        let codewordPosition = 1 + bits.getByteOffset();
        const d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);
        let count;
        if (d1 === 0) {
          count = bits.available() / 8 | 0;
        } else if (d1 < 250) {
          count = d1;
        } else {
          count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);
        }
        if (count < 0) {
          throw new FormatException();
        }
        const bytes2 = new Uint8Array(count);
        for (let i = 0; i < count; i++) {
          if (bits.available() < 8) {
            throw new FormatException();
          }
          bytes2[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);
        }
        byteSegments.push(bytes2);
        try {
          result.append(StringEncoding.decode(bytes2, StringUtils.ISO88591));
        } catch (uee) {
          throw new IllegalStateException("Platform does not support required encoding: " + uee.message);
        }
      }
      /**
       * See ISO 16022:2006, Annex B, B.2
       */
      static unrandomize255State(randomizedBase256Codeword, base256CodewordPosition) {
        const pseudoRandomNumber = 149 * base256CodewordPosition % 255 + 1;
        const tempVariable = randomizedBase256Codeword - pseudoRandomNumber;
        return tempVariable >= 0 ? tempVariable : tempVariable + 256;
      }
    }
    DecodedBitStreamParser.C40_BASIC_SET_CHARS = [
      "*",
      "*",
      "*",
      " ",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ];
    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [
      "!",
      '"',
      "#",
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "?",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_"
    ];
    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [
      "*",
      "*",
      "*",
      " ",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z"
    ];
    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;
    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [
      "`",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "{",
      "|",
      "}",
      "~",
      String.fromCharCode(127)
    ];
    class Decoder$12 {
      constructor() {
        this.rsDecoder = new ReedSolomonDecoder(GenericGF.DATA_MATRIX_FIELD_256);
      }
      /**
       * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or "true" is taken
       * to mean a black module.</p>
       *
       * @param bits booleans representing white/black Data Matrix Code modules
       * @return text and bytes encoded within the Data Matrix Code
       * @throws FormatException if the Data Matrix Code cannot be decoded
       * @throws ChecksumException if error correction fails
       */
      decode(bits) {
        const parser = new BitMatrixParser(bits);
        const version2 = parser.getVersion();
        const codewords = parser.readCodewords();
        const dataBlocks = DataBlock.getDataBlocks(codewords, version2);
        let totalBytes = 0;
        for (let db2 of dataBlocks) {
          totalBytes += db2.getNumDataCodewords();
        }
        const resultBytes = new Uint8Array(totalBytes);
        const dataBlocksCount = dataBlocks.length;
        for (let j = 0; j < dataBlocksCount; j++) {
          const dataBlock = dataBlocks[j];
          const codewordBytes = dataBlock.getCodewords();
          const numDataCodewords = dataBlock.getNumDataCodewords();
          this.correctErrors(codewordBytes, numDataCodewords);
          for (let i = 0; i < numDataCodewords; i++) {
            resultBytes[i * dataBlocksCount + j] = codewordBytes[i];
          }
        }
        return DecodedBitStreamParser.decode(resultBytes);
      }
      /**
       * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
       * correct the errors in-place using Reed-Solomon error correction.</p>
       *
       * @param codewordBytes data and error correction codewords
       * @param numDataCodewords number of codewords that are data bytes
       * @throws ChecksumException if error correction fails
       */
      correctErrors(codewordBytes, numDataCodewords) {
        const codewordsInts = new Int32Array(codewordBytes);
        try {
          this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        } catch (ignored) {
          throw new ChecksumException();
        }
        for (let i = 0; i < numDataCodewords; i++) {
          codewordBytes[i] = codewordsInts[i];
        }
      }
    }
    class Detector$1 {
      constructor(image) {
        this.image = image;
        this.rectangleDetector = new WhiteRectangleDetector(this.image);
      }
      /**
       * <p>Detects a Data Matrix Code in an image.</p>
       *
       * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code
       * @throws NotFoundException if no Data Matrix Code can be found
       */
      detect() {
        const cornerPoints = this.rectangleDetector.detect();
        let points = this.detectSolid1(cornerPoints);
        points = this.detectSolid2(points);
        points[3] = this.correctTopRight(points);
        if (!points[3]) {
          throw new NotFoundException();
        }
        points = this.shiftToModuleCenter(points);
        const topLeft = points[0];
        const bottomLeft = points[1];
        const bottomRight = points[2];
        const topRight = points[3];
        let dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;
        let dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;
        if ((dimensionTop & 1) === 1) {
          dimensionTop += 1;
        }
        if ((dimensionRight & 1) === 1) {
          dimensionRight += 1;
        }
        if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {
          dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);
        }
        let bits = Detector$1.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);
        return new DetectorResult(bits, [topLeft, bottomLeft, bottomRight, topRight]);
      }
      static shiftPoint(point5, to, div) {
        let x = (to.getX() - point5.getX()) / (div + 1);
        let y = (to.getY() - point5.getY()) / (div + 1);
        return new ResultPoint(point5.getX() + x, point5.getY() + y);
      }
      static moveAway(point5, fromX, fromY) {
        let x = point5.getX();
        let y = point5.getY();
        if (x < fromX) {
          x -= 1;
        } else {
          x += 1;
        }
        if (y < fromY) {
          y -= 1;
        } else {
          y += 1;
        }
        return new ResultPoint(x, y);
      }
      /**
       * Detect a solid side which has minimum transition.
       */
      detectSolid1(cornerPoints) {
        let pointA = cornerPoints[0];
        let pointB = cornerPoints[1];
        let pointC = cornerPoints[3];
        let pointD = cornerPoints[2];
        let trAB = this.transitionsBetween(pointA, pointB);
        let trBC = this.transitionsBetween(pointB, pointC);
        let trCD = this.transitionsBetween(pointC, pointD);
        let trDA = this.transitionsBetween(pointD, pointA);
        let min = trAB;
        let points = [pointD, pointA, pointB, pointC];
        if (min > trBC) {
          min = trBC;
          points[0] = pointA;
          points[1] = pointB;
          points[2] = pointC;
          points[3] = pointD;
        }
        if (min > trCD) {
          min = trCD;
          points[0] = pointB;
          points[1] = pointC;
          points[2] = pointD;
          points[3] = pointA;
        }
        if (min > trDA) {
          points[0] = pointC;
          points[1] = pointD;
          points[2] = pointA;
          points[3] = pointB;
        }
        return points;
      }
      /**
       * Detect a second solid side next to first solid side.
       */
      detectSolid2(points) {
        let pointA = points[0];
        let pointB = points[1];
        let pointC = points[2];
        let pointD = points[3];
        let tr = this.transitionsBetween(pointA, pointD);
        let pointBs = Detector$1.shiftPoint(pointB, pointC, (tr + 1) * 4);
        let pointCs = Detector$1.shiftPoint(pointC, pointB, (tr + 1) * 4);
        let trBA = this.transitionsBetween(pointBs, pointA);
        let trCD = this.transitionsBetween(pointCs, pointD);
        if (trBA < trCD) {
          points[0] = pointA;
          points[1] = pointB;
          points[2] = pointC;
          points[3] = pointD;
        } else {
          points[0] = pointB;
          points[1] = pointC;
          points[2] = pointD;
          points[3] = pointA;
        }
        return points;
      }
      /**
       * Calculates the corner position of the white top right module.
       */
      correctTopRight(points) {
        let pointA = points[0];
        let pointB = points[1];
        let pointC = points[2];
        let pointD = points[3];
        let trTop = this.transitionsBetween(pointA, pointD);
        let trRight = this.transitionsBetween(pointB, pointD);
        let pointAs = Detector$1.shiftPoint(pointA, pointB, (trRight + 1) * 4);
        let pointCs = Detector$1.shiftPoint(pointC, pointB, (trTop + 1) * 4);
        trTop = this.transitionsBetween(pointAs, pointD);
        trRight = this.transitionsBetween(pointCs, pointD);
        let candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));
        let candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));
        if (!this.isValid(candidate1)) {
          if (this.isValid(candidate2)) {
            return candidate2;
          }
          return null;
        }
        if (!this.isValid(candidate2)) {
          return candidate1;
        }
        let sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);
        let sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);
        if (sumc1 > sumc2) {
          return candidate1;
        } else {
          return candidate2;
        }
      }
      /**
       * Shift the edge points to the module center.
       */
      shiftToModuleCenter(points) {
        let pointA = points[0];
        let pointB = points[1];
        let pointC = points[2];
        let pointD = points[3];
        let dimH = this.transitionsBetween(pointA, pointD) + 1;
        let dimV = this.transitionsBetween(pointC, pointD) + 1;
        let pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
        let pointCs = Detector$1.shiftPoint(pointC, pointB, dimH * 4);
        dimH = this.transitionsBetween(pointAs, pointD) + 1;
        dimV = this.transitionsBetween(pointCs, pointD) + 1;
        if ((dimH & 1) === 1) {
          dimH += 1;
        }
        if ((dimV & 1) === 1) {
          dimV += 1;
        }
        let centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;
        let centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;
        pointA = Detector$1.moveAway(pointA, centerX, centerY);
        pointB = Detector$1.moveAway(pointB, centerX, centerY);
        pointC = Detector$1.moveAway(pointC, centerX, centerY);
        pointD = Detector$1.moveAway(pointD, centerX, centerY);
        let pointBs;
        let pointDs;
        pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
        pointAs = Detector$1.shiftPoint(pointAs, pointD, dimH * 4);
        pointBs = Detector$1.shiftPoint(pointB, pointA, dimV * 4);
        pointBs = Detector$1.shiftPoint(pointBs, pointC, dimH * 4);
        pointCs = Detector$1.shiftPoint(pointC, pointD, dimV * 4);
        pointCs = Detector$1.shiftPoint(pointCs, pointB, dimH * 4);
        pointDs = Detector$1.shiftPoint(pointD, pointC, dimV * 4);
        pointDs = Detector$1.shiftPoint(pointDs, pointA, dimH * 4);
        return [pointAs, pointBs, pointCs, pointDs];
      }
      isValid(p) {
        return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();
      }
      static sampleGrid(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {
        const sampler = GridSamplerInstance.getInstance();
        return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
      }
      /**
       * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.
       */
      transitionsBetween(from, to) {
        let fromX = Math.trunc(from.getX());
        let fromY = Math.trunc(from.getY());
        let toX = Math.trunc(to.getX());
        let toY = Math.trunc(to.getY());
        let steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
          let temp = fromX;
          fromX = fromY;
          fromY = temp;
          temp = toX;
          toX = toY;
          toY = temp;
        }
        let dx = Math.abs(toX - fromX);
        let dy = Math.abs(toY - fromY);
        let error = -dx / 2;
        let ystep = fromY < toY ? 1 : -1;
        let xstep = fromX < toX ? 1 : -1;
        let transitions = 0;
        let inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);
        for (let x = fromX, y = fromY; x !== toX; x += xstep) {
          let isBlack = this.image.get(steep ? y : x, steep ? x : y);
          if (isBlack !== inBlack) {
            transitions++;
            inBlack = isBlack;
          }
          error += dy;
          if (error > 0) {
            if (y === toY) {
              break;
            }
            y += ystep;
            error -= dx;
          }
        }
        return transitions;
      }
    }
    class DataMatrixReader {
      constructor() {
        this.decoder = new Decoder$12();
      }
      /**
       * Locates and decodes a Data Matrix code in an image.
       *
       * @return a String representing the content encoded by the Data Matrix code
       * @throws NotFoundException if a Data Matrix code cannot be found
       * @throws FormatException if a Data Matrix code cannot be decoded
       * @throws ChecksumException if error correction fails
       */
      // @Override
      // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {
      //   return decode(image, null);
      // }
      // @Override
      decode(image, hints = null) {
        let decoderResult;
        let points;
        if (hints != null && hints.has(DecodeHintType$1.PURE_BARCODE)) {
          const bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());
          decoderResult = this.decoder.decode(bits);
          points = DataMatrixReader.NO_POINTS;
        } else {
          const detectorResult = new Detector$1(image.getBlackMatrix()).detect();
          decoderResult = this.decoder.decode(detectorResult.getBits());
          points = detectorResult.getPoints();
        }
        const rawBytes = decoderResult.getRawBytes();
        const result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat$1.DATA_MATRIX, System.currentTimeMillis());
        const byteSegments = decoderResult.getByteSegments();
        if (byteSegments != null) {
          result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
        }
        const ecLevel = decoderResult.getECLevel();
        if (ecLevel != null) {
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        return result;
      }
      // @Override
      reset() {
      }
      /**
       * This method detects a code in a "pure" image -- that is, pure monochrome image
       * which contains only an unrotated, unskewed, image of a code, with some white border
       * around it. This is a specialized method that works exceptionally fast in this special
       * case.
       *
       * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)
       */
      static extractPureBits(image) {
        const leftTopBlack = image.getTopLeftOnBit();
        const rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack == null || rightBottomBlack == null) {
          throw new NotFoundException();
        }
        const moduleSize = this.moduleSize(leftTopBlack, image);
        let top = leftTopBlack[1];
        const bottom = rightBottomBlack[1];
        let left = leftTopBlack[0];
        const right = rightBottomBlack[0];
        const matrixWidth = (right - left + 1) / moduleSize;
        const matrixHeight = (bottom - top + 1) / moduleSize;
        if (matrixWidth <= 0 || matrixHeight <= 0) {
          throw new NotFoundException();
        }
        const nudge = moduleSize / 2;
        top += nudge;
        left += nudge;
        const bits = new BitMatrix(matrixWidth, matrixHeight);
        for (let y = 0; y < matrixHeight; y++) {
          const iOffset = top + y * moduleSize;
          for (let x = 0; x < matrixWidth; x++) {
            if (image.get(left + x * moduleSize, iOffset)) {
              bits.set(x, y);
            }
          }
        }
        return bits;
      }
      static moduleSize(leftTopBlack, image) {
        const width = image.getWidth();
        let x = leftTopBlack[0];
        const y = leftTopBlack[1];
        while (x < width && image.get(x, y)) {
          x++;
        }
        if (x === width) {
          throw new NotFoundException();
        }
        const moduleSize = x - leftTopBlack[0];
        if (moduleSize === 0) {
          throw new NotFoundException();
        }
        return moduleSize;
      }
    }
    DataMatrixReader.NO_POINTS = [];
    class BrowserDatamatrixCodeReader extends BrowserCodeReader {
      /**
       * Creates an instance of BrowserQRCodeReader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       */
      constructor(timeBetweenScansMillis = 500) {
        super(new DataMatrixReader(), timeBetweenScansMillis);
      }
    }
    var ErrorCorrectionLevelValues;
    (function(ErrorCorrectionLevelValues2) {
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["L"] = 0] = "L";
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["M"] = 1] = "M";
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["Q"] = 2] = "Q";
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["H"] = 3] = "H";
    })(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));
    class ErrorCorrectionLevel {
      constructor(value, stringValue, bits) {
        this.value = value;
        this.stringValue = stringValue;
        this.bits = bits;
        ErrorCorrectionLevel.FOR_BITS.set(bits, this);
        ErrorCorrectionLevel.FOR_VALUE.set(value, this);
      }
      getValue() {
        return this.value;
      }
      getBits() {
        return this.bits;
      }
      static fromString(s) {
        switch (s) {
          case "L":
            return ErrorCorrectionLevel.L;
          case "M":
            return ErrorCorrectionLevel.M;
          case "Q":
            return ErrorCorrectionLevel.Q;
          case "H":
            return ErrorCorrectionLevel.H;
          default:
            throw new ArgumentException(s + "not available");
        }
      }
      toString() {
        return this.stringValue;
      }
      equals(o) {
        if (!(o instanceof ErrorCorrectionLevel)) {
          return false;
        }
        const other = o;
        return this.value === other.value;
      }
      /**
       * @param bits int containing the two bits encoding a QR Code's error correction level
       * @return ErrorCorrectionLevel representing the encoded error correction level
       */
      static forBits(bits) {
        if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {
          throw new IllegalArgumentException();
        }
        return ErrorCorrectionLevel.FOR_BITS.get(bits);
      }
    }
    ErrorCorrectionLevel.FOR_BITS = /* @__PURE__ */ new Map();
    ErrorCorrectionLevel.FOR_VALUE = /* @__PURE__ */ new Map();
    ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, "L", 1);
    ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, "M", 0);
    ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, "Q", 3);
    ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, "H", 2);
    class FormatInformation {
      constructor(formatInfo) {
        this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(formatInfo >> 3 & 3);
        this.dataMask = /*(byte) */
        formatInfo & 7;
      }
      static numBitsDiffering(a, b) {
        return Integer.bitCount(a ^ b);
      }
      /**
       * @param maskedFormatInfo1 format info indicator, with mask still applied
       * @param maskedFormatInfo2 second copy of same info; both are checked at the same time
       *  to establish best match
       * @return information about the format it specifies, or {@code null}
       *  if doesn't seem to match any known pattern
       */
      static decodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2) {
        const formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
        if (formatInfo !== null) {
          return formatInfo;
        }
        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);
      }
      static doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2) {
        let bestDifference = Number.MAX_SAFE_INTEGER;
        let bestFormatInfo = 0;
        for (const decodeInfo of FormatInformation.FORMAT_INFO_DECODE_LOOKUP) {
          const targetInfo = decodeInfo[0];
          if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
            return new FormatInformation(decodeInfo[1]);
          }
          let bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);
          if (bitsDifference < bestDifference) {
            bestFormatInfo = decodeInfo[1];
            bestDifference = bitsDifference;
          }
          if (maskedFormatInfo1 !== maskedFormatInfo2) {
            bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);
            if (bitsDifference < bestDifference) {
              bestFormatInfo = decodeInfo[1];
              bestDifference = bitsDifference;
            }
          }
        }
        if (bestDifference <= 3) {
          return new FormatInformation(bestFormatInfo);
        }
        return null;
      }
      getErrorCorrectionLevel() {
        return this.errorCorrectionLevel;
      }
      getDataMask() {
        return this.dataMask;
      }
      /*@Override*/
      hashCode() {
        return this.errorCorrectionLevel.getBits() << 3 | this.dataMask;
      }
      /*@Override*/
      equals(o) {
        if (!(o instanceof FormatInformation)) {
          return false;
        }
        const other = o;
        return this.errorCorrectionLevel === other.errorCorrectionLevel && this.dataMask === other.dataMask;
      }
    }
    FormatInformation.FORMAT_INFO_MASK_QR = 21522;
    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [
      Int32Array.from([21522, 0]),
      Int32Array.from([20773, 1]),
      Int32Array.from([24188, 2]),
      Int32Array.from([23371, 3]),
      Int32Array.from([17913, 4]),
      Int32Array.from([16590, 5]),
      Int32Array.from([20375, 6]),
      Int32Array.from([19104, 7]),
      Int32Array.from([30660, 8]),
      Int32Array.from([29427, 9]),
      Int32Array.from([32170, 10]),
      Int32Array.from([30877, 11]),
      Int32Array.from([26159, 12]),
      Int32Array.from([25368, 13]),
      Int32Array.from([27713, 14]),
      Int32Array.from([26998, 15]),
      Int32Array.from([5769, 16]),
      Int32Array.from([5054, 17]),
      Int32Array.from([7399, 18]),
      Int32Array.from([6608, 19]),
      Int32Array.from([1890, 20]),
      Int32Array.from([597, 21]),
      Int32Array.from([3340, 22]),
      Int32Array.from([2107, 23]),
      Int32Array.from([13663, 24]),
      Int32Array.from([12392, 25]),
      Int32Array.from([16177, 26]),
      Int32Array.from([14854, 27]),
      Int32Array.from([9396, 28]),
      Int32Array.from([8579, 29]),
      Int32Array.from([11994, 30]),
      Int32Array.from([11245, 31])
    ];
    class ECBlocks$1 {
      constructor(ecCodewordsPerBlock, ...ecBlocks) {
        this.ecCodewordsPerBlock = ecCodewordsPerBlock;
        this.ecBlocks = ecBlocks;
      }
      getECCodewordsPerBlock() {
        return this.ecCodewordsPerBlock;
      }
      getNumBlocks() {
        let total = 0;
        const ecBlocks = this.ecBlocks;
        for (const ecBlock of ecBlocks) {
          total += ecBlock.getCount();
        }
        return total;
      }
      getTotalECCodewords() {
        return this.ecCodewordsPerBlock * this.getNumBlocks();
      }
      getECBlocks() {
        return this.ecBlocks;
      }
    }
    class ECB$1 {
      constructor(count, dataCodewords) {
        this.count = count;
        this.dataCodewords = dataCodewords;
      }
      getCount() {
        return this.count;
      }
      getDataCodewords() {
        return this.dataCodewords;
      }
    }
    class Version$1 {
      constructor(versionNumber, alignmentPatternCenters, ...ecBlocks) {
        this.versionNumber = versionNumber;
        this.alignmentPatternCenters = alignmentPatternCenters;
        this.ecBlocks = ecBlocks;
        let total = 0;
        const ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
        const ecbArray = ecBlocks[0].getECBlocks();
        for (const ecBlock of ecbArray) {
          total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
        }
        this.totalCodewords = total;
      }
      getVersionNumber() {
        return this.versionNumber;
      }
      getAlignmentPatternCenters() {
        return this.alignmentPatternCenters;
      }
      getTotalCodewords() {
        return this.totalCodewords;
      }
      getDimensionForVersion() {
        return 17 + 4 * this.versionNumber;
      }
      getECBlocksForLevel(ecLevel) {
        return this.ecBlocks[ecLevel.getValue()];
      }
      /**
       * <p>Deduces version information purely from QR Code dimensions.</p>
       *
       * @param dimension dimension in modules
       * @return Version for a QR Code of that dimension
       * @throws FormatException if dimension is not 1 mod 4
       */
      static getProvisionalVersionForDimension(dimension) {
        if (dimension % 4 !== 1) {
          throw new FormatException();
        }
        try {
          return this.getVersionForNumber((dimension - 17) / 4);
        } catch (ignored) {
          throw new FormatException();
        }
      }
      static getVersionForNumber(versionNumber) {
        if (versionNumber < 1 || versionNumber > 40) {
          throw new IllegalArgumentException();
        }
        return Version$1.VERSIONS[versionNumber - 1];
      }
      static decodeVersionInformation(versionBits) {
        let bestDifference = Number.MAX_SAFE_INTEGER;
        let bestVersion = 0;
        for (let i = 0; i < Version$1.VERSION_DECODE_INFO.length; i++) {
          const targetVersion = Version$1.VERSION_DECODE_INFO[i];
          if (targetVersion === versionBits) {
            return Version$1.getVersionForNumber(i + 7);
          }
          const bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
          if (bitsDifference < bestDifference) {
            bestVersion = i + 7;
            bestDifference = bitsDifference;
          }
        }
        if (bestDifference <= 3) {
          return Version$1.getVersionForNumber(bestVersion);
        }
        return null;
      }
      /**
       * See ISO 18004:2006 Annex E
       */
      buildFunctionPattern() {
        const dimension = this.getDimensionForVersion();
        const bitMatrix = new BitMatrix(dimension);
        bitMatrix.setRegion(0, 0, 9, 9);
        bitMatrix.setRegion(dimension - 8, 0, 8, 9);
        bitMatrix.setRegion(0, dimension - 8, 9, 8);
        const max = this.alignmentPatternCenters.length;
        for (let x = 0; x < max; x++) {
          const i = this.alignmentPatternCenters[x] - 2;
          for (let y = 0; y < max; y++) {
            if (x === 0 && (y === 0 || y === max - 1) || x === max - 1 && y === 0) {
              continue;
            }
            bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
          }
        }
        bitMatrix.setRegion(6, 9, 1, dimension - 17);
        bitMatrix.setRegion(9, 6, dimension - 17, 1);
        if (this.versionNumber > 6) {
          bitMatrix.setRegion(dimension - 11, 0, 3, 6);
          bitMatrix.setRegion(0, dimension - 11, 6, 3);
        }
        return bitMatrix;
      }
      /*@Override*/
      toString() {
        return "" + this.versionNumber;
      }
    }
    Version$1.VERSION_DECODE_INFO = Int32Array.from([
      31892,
      34236,
      39577,
      42195,
      48118,
      51042,
      55367,
      58893,
      63784,
      68472,
      70749,
      76311,
      79154,
      84390,
      87683,
      92361,
      96236,
      102084,
      102881,
      110507,
      110734,
      117786,
      119615,
      126325,
      127568,
      133589,
      136944,
      141498,
      145311,
      150283,
      152622,
      158308,
      161089,
      167017
    ]);
    Version$1.VERSIONS = [
      new Version$1(1, new Int32Array(0), new ECBlocks$1(7, new ECB$1(1, 19)), new ECBlocks$1(10, new ECB$1(1, 16)), new ECBlocks$1(13, new ECB$1(1, 13)), new ECBlocks$1(17, new ECB$1(1, 9))),
      new Version$1(2, Int32Array.from([6, 18]), new ECBlocks$1(10, new ECB$1(1, 34)), new ECBlocks$1(16, new ECB$1(1, 28)), new ECBlocks$1(22, new ECB$1(1, 22)), new ECBlocks$1(28, new ECB$1(1, 16))),
      new Version$1(3, Int32Array.from([6, 22]), new ECBlocks$1(15, new ECB$1(1, 55)), new ECBlocks$1(26, new ECB$1(1, 44)), new ECBlocks$1(18, new ECB$1(2, 17)), new ECBlocks$1(22, new ECB$1(2, 13))),
      new Version$1(4, Int32Array.from([6, 26]), new ECBlocks$1(20, new ECB$1(1, 80)), new ECBlocks$1(18, new ECB$1(2, 32)), new ECBlocks$1(26, new ECB$1(2, 24)), new ECBlocks$1(16, new ECB$1(4, 9))),
      new Version$1(5, Int32Array.from([6, 30]), new ECBlocks$1(26, new ECB$1(1, 108)), new ECBlocks$1(24, new ECB$1(2, 43)), new ECBlocks$1(18, new ECB$1(2, 15), new ECB$1(2, 16)), new ECBlocks$1(22, new ECB$1(2, 11), new ECB$1(2, 12))),
      new Version$1(6, Int32Array.from([6, 34]), new ECBlocks$1(18, new ECB$1(2, 68)), new ECBlocks$1(16, new ECB$1(4, 27)), new ECBlocks$1(24, new ECB$1(4, 19)), new ECBlocks$1(28, new ECB$1(4, 15))),
      new Version$1(7, Int32Array.from([6, 22, 38]), new ECBlocks$1(20, new ECB$1(2, 78)), new ECBlocks$1(18, new ECB$1(4, 31)), new ECBlocks$1(18, new ECB$1(2, 14), new ECB$1(4, 15)), new ECBlocks$1(26, new ECB$1(4, 13), new ECB$1(1, 14))),
      new Version$1(8, Int32Array.from([6, 24, 42]), new ECBlocks$1(24, new ECB$1(2, 97)), new ECBlocks$1(22, new ECB$1(2, 38), new ECB$1(2, 39)), new ECBlocks$1(22, new ECB$1(4, 18), new ECB$1(2, 19)), new ECBlocks$1(26, new ECB$1(4, 14), new ECB$1(2, 15))),
      new Version$1(9, Int32Array.from([6, 26, 46]), new ECBlocks$1(30, new ECB$1(2, 116)), new ECBlocks$1(22, new ECB$1(3, 36), new ECB$1(2, 37)), new ECBlocks$1(20, new ECB$1(4, 16), new ECB$1(4, 17)), new ECBlocks$1(24, new ECB$1(4, 12), new ECB$1(4, 13))),
      new Version$1(10, Int32Array.from([6, 28, 50]), new ECBlocks$1(18, new ECB$1(2, 68), new ECB$1(2, 69)), new ECBlocks$1(26, new ECB$1(4, 43), new ECB$1(1, 44)), new ECBlocks$1(24, new ECB$1(6, 19), new ECB$1(2, 20)), new ECBlocks$1(28, new ECB$1(6, 15), new ECB$1(2, 16))),
      new Version$1(11, Int32Array.from([6, 30, 54]), new ECBlocks$1(20, new ECB$1(4, 81)), new ECBlocks$1(30, new ECB$1(1, 50), new ECB$1(4, 51)), new ECBlocks$1(28, new ECB$1(4, 22), new ECB$1(4, 23)), new ECBlocks$1(24, new ECB$1(3, 12), new ECB$1(8, 13))),
      new Version$1(12, Int32Array.from([6, 32, 58]), new ECBlocks$1(24, new ECB$1(2, 92), new ECB$1(2, 93)), new ECBlocks$1(22, new ECB$1(6, 36), new ECB$1(2, 37)), new ECBlocks$1(26, new ECB$1(4, 20), new ECB$1(6, 21)), new ECBlocks$1(28, new ECB$1(7, 14), new ECB$1(4, 15))),
      new Version$1(13, Int32Array.from([6, 34, 62]), new ECBlocks$1(26, new ECB$1(4, 107)), new ECBlocks$1(22, new ECB$1(8, 37), new ECB$1(1, 38)), new ECBlocks$1(24, new ECB$1(8, 20), new ECB$1(4, 21)), new ECBlocks$1(22, new ECB$1(12, 11), new ECB$1(4, 12))),
      new Version$1(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks$1(30, new ECB$1(3, 115), new ECB$1(1, 116)), new ECBlocks$1(24, new ECB$1(4, 40), new ECB$1(5, 41)), new ECBlocks$1(20, new ECB$1(11, 16), new ECB$1(5, 17)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(5, 13))),
      new Version$1(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks$1(22, new ECB$1(5, 87), new ECB$1(1, 88)), new ECBlocks$1(24, new ECB$1(5, 41), new ECB$1(5, 42)), new ECBlocks$1(30, new ECB$1(5, 24), new ECB$1(7, 25)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(7, 13))),
      new Version$1(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks$1(24, new ECB$1(5, 98), new ECB$1(1, 99)), new ECBlocks$1(28, new ECB$1(7, 45), new ECB$1(3, 46)), new ECBlocks$1(24, new ECB$1(15, 19), new ECB$1(2, 20)), new ECBlocks$1(30, new ECB$1(3, 15), new ECB$1(13, 16))),
      new Version$1(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks$1(28, new ECB$1(1, 107), new ECB$1(5, 108)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(1, 47)), new ECBlocks$1(28, new ECB$1(1, 22), new ECB$1(15, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(17, 15))),
      new Version$1(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks$1(30, new ECB$1(5, 120), new ECB$1(1, 121)), new ECBlocks$1(26, new ECB$1(9, 43), new ECB$1(4, 44)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(1, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(19, 15))),
      new Version$1(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks$1(28, new ECB$1(3, 113), new ECB$1(4, 114)), new ECBlocks$1(26, new ECB$1(3, 44), new ECB$1(11, 45)), new ECBlocks$1(26, new ECB$1(17, 21), new ECB$1(4, 22)), new ECBlocks$1(26, new ECB$1(9, 13), new ECB$1(16, 14))),
      new Version$1(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks$1(28, new ECB$1(3, 107), new ECB$1(5, 108)), new ECBlocks$1(26, new ECB$1(3, 41), new ECB$1(13, 42)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(5, 25)), new ECBlocks$1(28, new ECB$1(15, 15), new ECB$1(10, 16))),
      new Version$1(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks$1(28, new ECB$1(4, 116), new ECB$1(4, 117)), new ECBlocks$1(26, new ECB$1(17, 42)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(19, 16), new ECB$1(6, 17))),
      new Version$1(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks$1(28, new ECB$1(2, 111), new ECB$1(7, 112)), new ECBlocks$1(28, new ECB$1(17, 46)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(16, 25)), new ECBlocks$1(24, new ECB$1(34, 13))),
      new Version$1(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks$1(30, new ECB$1(4, 121), new ECB$1(5, 122)), new ECBlocks$1(28, new ECB$1(4, 47), new ECB$1(14, 48)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(16, 15), new ECB$1(14, 16))),
      new Version$1(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks$1(30, new ECB$1(6, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(6, 45), new ECB$1(14, 46)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(16, 25)), new ECBlocks$1(30, new ECB$1(30, 16), new ECB$1(2, 17))),
      new Version$1(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks$1(26, new ECB$1(8, 106), new ECB$1(4, 107)), new ECBlocks$1(28, new ECB$1(8, 47), new ECB$1(13, 48)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(13, 16))),
      new Version$1(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks$1(28, new ECB$1(10, 114), new ECB$1(2, 115)), new ECBlocks$1(28, new ECB$1(19, 46), new ECB$1(4, 47)), new ECBlocks$1(28, new ECB$1(28, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(33, 16), new ECB$1(4, 17))),
      new Version$1(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks$1(30, new ECB$1(8, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(22, 45), new ECB$1(3, 46)), new ECBlocks$1(30, new ECB$1(8, 23), new ECB$1(26, 24)), new ECBlocks$1(30, new ECB$1(12, 15), new ECB$1(28, 16))),
      new Version$1(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks$1(30, new ECB$1(3, 117), new ECB$1(10, 118)), new ECBlocks$1(28, new ECB$1(3, 45), new ECB$1(23, 46)), new ECBlocks$1(30, new ECB$1(4, 24), new ECB$1(31, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(31, 16))),
      new Version$1(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks$1(30, new ECB$1(7, 116), new ECB$1(7, 117)), new ECBlocks$1(28, new ECB$1(21, 45), new ECB$1(7, 46)), new ECBlocks$1(30, new ECB$1(1, 23), new ECB$1(37, 24)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(26, 16))),
      new Version$1(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks$1(30, new ECB$1(5, 115), new ECB$1(10, 116)), new ECBlocks$1(28, new ECB$1(19, 47), new ECB$1(10, 48)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(25, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(25, 16))),
      new Version$1(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(3, 116)), new ECBlocks$1(28, new ECB$1(2, 46), new ECB$1(29, 47)), new ECBlocks$1(30, new ECB$1(42, 24), new ECB$1(1, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(28, 16))),
      new Version$1(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks$1(30, new ECB$1(17, 115)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(10, 24), new ECB$1(35, 25)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(35, 16))),
      new Version$1(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks$1(30, new ECB$1(17, 115), new ECB$1(1, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(21, 47)), new ECBlocks$1(30, new ECB$1(29, 24), new ECB$1(19, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(46, 16))),
      new Version$1(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(6, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(44, 24), new ECB$1(7, 25)), new ECBlocks$1(30, new ECB$1(59, 16), new ECB$1(1, 17))),
      new Version$1(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks$1(30, new ECB$1(12, 121), new ECB$1(7, 122)), new ECBlocks$1(28, new ECB$1(12, 47), new ECB$1(26, 48)), new ECBlocks$1(30, new ECB$1(39, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(41, 16))),
      new Version$1(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks$1(30, new ECB$1(6, 121), new ECB$1(14, 122)), new ECBlocks$1(28, new ECB$1(6, 47), new ECB$1(34, 48)), new ECBlocks$1(30, new ECB$1(46, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(2, 15), new ECB$1(64, 16))),
      new Version$1(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks$1(30, new ECB$1(17, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(29, 46), new ECB$1(14, 47)), new ECBlocks$1(30, new ECB$1(49, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(24, 15), new ECB$1(46, 16))),
      new Version$1(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks$1(30, new ECB$1(4, 122), new ECB$1(18, 123)), new ECBlocks$1(28, new ECB$1(13, 46), new ECB$1(32, 47)), new ECBlocks$1(30, new ECB$1(48, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(42, 15), new ECB$1(32, 16))),
      new Version$1(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks$1(30, new ECB$1(20, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(40, 47), new ECB$1(7, 48)), new ECBlocks$1(30, new ECB$1(43, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(10, 15), new ECB$1(67, 16))),
      new Version$1(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks$1(30, new ECB$1(19, 118), new ECB$1(6, 119)), new ECBlocks$1(28, new ECB$1(18, 47), new ECB$1(31, 48)), new ECBlocks$1(30, new ECB$1(34, 24), new ECB$1(34, 25)), new ECBlocks$1(30, new ECB$1(20, 15), new ECB$1(61, 16)))
    ];
    var DataMaskValues;
    (function(DataMaskValues2) {
      DataMaskValues2[DataMaskValues2["DATA_MASK_000"] = 0] = "DATA_MASK_000";
      DataMaskValues2[DataMaskValues2["DATA_MASK_001"] = 1] = "DATA_MASK_001";
      DataMaskValues2[DataMaskValues2["DATA_MASK_010"] = 2] = "DATA_MASK_010";
      DataMaskValues2[DataMaskValues2["DATA_MASK_011"] = 3] = "DATA_MASK_011";
      DataMaskValues2[DataMaskValues2["DATA_MASK_100"] = 4] = "DATA_MASK_100";
      DataMaskValues2[DataMaskValues2["DATA_MASK_101"] = 5] = "DATA_MASK_101";
      DataMaskValues2[DataMaskValues2["DATA_MASK_110"] = 6] = "DATA_MASK_110";
      DataMaskValues2[DataMaskValues2["DATA_MASK_111"] = 7] = "DATA_MASK_111";
    })(DataMaskValues || (DataMaskValues = {}));
    class DataMask {
      // See ISO 18004:2006 6.8.1
      constructor(value, isMasked) {
        this.value = value;
        this.isMasked = isMasked;
      }
      // End of enum constants.
      /**
       * <p>Implementations of this method reverse the data masking process applied to a QR Code and
       * make its bits ready to read.</p>
       *
       * @param bits representation of QR Code bits
       * @param dimension dimension of QR Code, represented by bits, being unmasked
       */
      unmaskBitMatrix(bits, dimension) {
        for (let i = 0; i < dimension; i++) {
          for (let j = 0; j < dimension; j++) {
            if (this.isMasked(i, j)) {
              bits.flip(j, i);
            }
          }
        }
      }
    }
    DataMask.values = /* @__PURE__ */ new Map([
      /**
       * 000: mask bits for which (x + y) mod 2 == 0
       */
      [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, (i, j) => {
        return (i + j & 1) === 0;
      })],
      /**
       * 001: mask bits for which x mod 2 == 0
       */
      [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, (i, j) => {
        return (i & 1) === 0;
      })],
      /**
       * 010: mask bits for which y mod 3 == 0
       */
      [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, (i, j) => {
        return j % 3 === 0;
      })],
      /**
       * 011: mask bits for which (x + y) mod 3 == 0
       */
      [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, (i, j) => {
        return (i + j) % 3 === 0;
      })],
      /**
       * 100: mask bits for which (x/2 + y/3) mod 2 == 0
       */
      [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, (i, j) => {
        return (Math.floor(i / 2) + Math.floor(j / 3) & 1) === 0;
      })],
      /**
       * 101: mask bits for which xy mod 2 + xy mod 3 == 0
       * equivalently, such that xy mod 6 == 0
       */
      [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, (i, j) => {
        return i * j % 6 === 0;
      })],
      /**
       * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0
       * equivalently, such that xy mod 6 < 3
       */
      [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, (i, j) => {
        return i * j % 6 < 3;
      })],
      /**
       * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0
       * equivalently, such that (x + y + xy mod 3) mod 2 == 0
       */
      [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, (i, j) => {
        return (i + j + i * j % 3 & 1) === 0;
      })]
    ]);
    class BitMatrixParser$1 {
      /**
       * @param bitMatrix {@link BitMatrix} to parse
       * @throws FormatException if dimension is not >= 21 and 1 mod 4
       */
      constructor(bitMatrix) {
        const dimension = bitMatrix.getHeight();
        if (dimension < 21 || (dimension & 3) !== 1) {
          throw new FormatException();
        }
        this.bitMatrix = bitMatrix;
      }
      /**
       * <p>Reads format information from one of its two locations within the QR Code.</p>
       *
       * @return {@link FormatInformation} encapsulating the QR Code's format info
       * @throws FormatException if both format information locations cannot be parsed as
       * the valid encoding of format information
       */
      readFormatInformation() {
        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== void 0) {
          return this.parsedFormatInfo;
        }
        let formatInfoBits1 = 0;
        for (let i = 0; i < 6; i++) {
          formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);
        }
        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
        for (let j = 5; j >= 0; j--) {
          formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);
        }
        const dimension = this.bitMatrix.getHeight();
        let formatInfoBits2 = 0;
        const jMin = dimension - 7;
        for (let j = dimension - 1; j >= jMin; j--) {
          formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);
        }
        for (let i = dimension - 8; i < dimension; i++) {
          formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);
        }
        this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
        if (this.parsedFormatInfo !== null) {
          return this.parsedFormatInfo;
        }
        throw new FormatException();
      }
      /**
       * <p>Reads version information from one of its two locations within the QR Code.</p>
       *
       * @return {@link Version} encapsulating the QR Code's version
       * @throws FormatException if both version information locations cannot be parsed as
       * the valid encoding of version information
       */
      readVersion() {
        if (this.parsedVersion !== null && this.parsedVersion !== void 0) {
          return this.parsedVersion;
        }
        const dimension = this.bitMatrix.getHeight();
        const provisionalVersion = Math.floor((dimension - 17) / 4);
        if (provisionalVersion <= 6) {
          return Version$1.getVersionForNumber(provisionalVersion);
        }
        let versionBits = 0;
        const ijMin = dimension - 11;
        for (let j = 5; j >= 0; j--) {
          for (let i = dimension - 9; i >= ijMin; i--) {
            versionBits = this.copyBit(i, j, versionBits);
          }
        }
        let theParsedVersion = Version$1.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
          this.parsedVersion = theParsedVersion;
          return theParsedVersion;
        }
        versionBits = 0;
        for (let i = 5; i >= 0; i--) {
          for (let j = dimension - 9; j >= ijMin; j--) {
            versionBits = this.copyBit(i, j, versionBits);
          }
        }
        theParsedVersion = Version$1.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
          this.parsedVersion = theParsedVersion;
          return theParsedVersion;
        }
        throw new FormatException();
      }
      copyBit(i, j, versionBits) {
        const bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);
        return bit ? versionBits << 1 | 1 : versionBits << 1;
      }
      /**
       * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the
       * correct order in order to reconstruct the codewords bytes contained within the
       * QR Code.</p>
       *
       * @return bytes encoded within the QR Code
       * @throws FormatException if the exact number of bytes expected is not read
       */
      readCodewords() {
        const formatInfo = this.readFormatInformation();
        const version2 = this.readVersion();
        const dataMask = DataMask.values.get(formatInfo.getDataMask());
        const dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
        const functionPattern = version2.buildFunctionPattern();
        let readingUp = true;
        const result = new Uint8Array(version2.getTotalCodewords());
        let resultOffset = 0;
        let currentByte = 0;
        let bitsRead = 0;
        for (let j = dimension - 1; j > 0; j -= 2) {
          if (j === 6) {
            j--;
          }
          for (let count = 0; count < dimension; count++) {
            const i = readingUp ? dimension - 1 - count : count;
            for (let col = 0; col < 2; col++) {
              if (!functionPattern.get(j - col, i)) {
                bitsRead++;
                currentByte <<= 1;
                if (this.bitMatrix.get(j - col, i)) {
                  currentByte |= 1;
                }
                if (bitsRead === 8) {
                  result[resultOffset++] = /*(byte) */
                  currentByte;
                  bitsRead = 0;
                  currentByte = 0;
                }
              }
            }
          }
          readingUp = !readingUp;
        }
        if (resultOffset !== version2.getTotalCodewords()) {
          throw new FormatException();
        }
        return result;
      }
      /**
       * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.
       */
      remask() {
        if (this.parsedFormatInfo === null) {
          return;
        }
        const dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];
        const dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
      }
      /**
       * Prepare the parser for a mirrored operation.
       * This flag has effect only on the {@link #readFormatInformation()} and the
       * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the
       * {@link #mirror()} method should be called.
       *
       * @param mirror Whether to read version and format information mirrored.
       */
      setMirror(isMirror) {
        this.parsedVersion = null;
        this.parsedFormatInfo = null;
        this.isMirror = isMirror;
      }
      /** Mirror the bit matrix in order to attempt a second reading. */
      mirror() {
        const bitMatrix = this.bitMatrix;
        for (let x = 0, width = bitMatrix.getWidth(); x < width; x++) {
          for (let y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {
            if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {
              bitMatrix.flip(y, x);
              bitMatrix.flip(x, y);
            }
          }
        }
      }
    }
    class DataBlock$1 {
      constructor(numDataCodewords, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
      }
      /**
       * <p>When QR Codes use multiple data blocks, they are actually interleaved.
       * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
       * method will separate the data into original blocks.</p>
       *
       * @param rawCodewords bytes as read directly from the QR Code
       * @param version version of the QR Code
       * @param ecLevel error-correction level of the QR Code
       * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
       *         QR Code
       */
      static getDataBlocks(rawCodewords, version2, ecLevel) {
        if (rawCodewords.length !== version2.getTotalCodewords()) {
          throw new IllegalArgumentException();
        }
        const ecBlocks = version2.getECBlocksForLevel(ecLevel);
        let totalBlocks = 0;
        const ecBlockArray = ecBlocks.getECBlocks();
        for (const ecBlock of ecBlockArray) {
          totalBlocks += ecBlock.getCount();
        }
        const result = new Array(totalBlocks);
        let numResultBlocks = 0;
        for (const ecBlock of ecBlockArray) {
          for (let i = 0; i < ecBlock.getCount(); i++) {
            const numDataCodewords = ecBlock.getDataCodewords();
            const numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
            result[numResultBlocks++] = new DataBlock$1(numDataCodewords, new Uint8Array(numBlockCodewords));
          }
        }
        const shorterBlocksTotalCodewords = result[0].codewords.length;
        let longerBlocksStartAt = result.length - 1;
        while (longerBlocksStartAt >= 0) {
          const numCodewords = result[longerBlocksStartAt].codewords.length;
          if (numCodewords === shorterBlocksTotalCodewords) {
            break;
          }
          longerBlocksStartAt--;
        }
        longerBlocksStartAt++;
        const shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
        let rawCodewordsOffset = 0;
        for (let i = 0; i < shorterBlocksNumDataCodewords; i++) {
          for (let j = 0; j < numResultBlocks; j++) {
            result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
          }
        }
        for (let j = longerBlocksStartAt; j < numResultBlocks; j++) {
          result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
        }
        const max = result[0].codewords.length;
        for (let i = shorterBlocksNumDataCodewords; i < max; i++) {
          for (let j = 0; j < numResultBlocks; j++) {
            const iOffset = j < longerBlocksStartAt ? i : i + 1;
            result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
          }
        }
        return result;
      }
      getNumDataCodewords() {
        return this.numDataCodewords;
      }
      getCodewords() {
        return this.codewords;
      }
    }
    var ModeValues;
    (function(ModeValues2) {
      ModeValues2[ModeValues2["TERMINATOR"] = 0] = "TERMINATOR";
      ModeValues2[ModeValues2["NUMERIC"] = 1] = "NUMERIC";
      ModeValues2[ModeValues2["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";
      ModeValues2[ModeValues2["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";
      ModeValues2[ModeValues2["BYTE"] = 4] = "BYTE";
      ModeValues2[ModeValues2["ECI"] = 5] = "ECI";
      ModeValues2[ModeValues2["KANJI"] = 6] = "KANJI";
      ModeValues2[ModeValues2["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";
      ModeValues2[ModeValues2["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";
      ModeValues2[ModeValues2["HANZI"] = 9] = "HANZI";
    })(ModeValues || (ModeValues = {}));
    class Mode$1 {
      constructor(value, stringValue, characterCountBitsForVersions, bits) {
        this.value = value;
        this.stringValue = stringValue;
        this.characterCountBitsForVersions = characterCountBitsForVersions;
        this.bits = bits;
        Mode$1.FOR_BITS.set(bits, this);
        Mode$1.FOR_VALUE.set(value, this);
      }
      /**
       * @param bits four bits encoding a QR Code data mode
       * @return Mode encoded by these bits
       * @throws IllegalArgumentException if bits do not correspond to a known mode
       */
      static forBits(bits) {
        const mode = Mode$1.FOR_BITS.get(bits);
        if (void 0 === mode) {
          throw new IllegalArgumentException();
        }
        return mode;
      }
      /**
       * @param version version in question
       * @return number of bits used, in this QR Code symbol {@link Version}, to encode the
       *         count of characters that will follow encoded in this Mode
       */
      getCharacterCountBits(version2) {
        const versionNumber = version2.getVersionNumber();
        let offset;
        if (versionNumber <= 9) {
          offset = 0;
        } else if (versionNumber <= 26) {
          offset = 1;
        } else {
          offset = 2;
        }
        return this.characterCountBitsForVersions[offset];
      }
      getValue() {
        return this.value;
      }
      getBits() {
        return this.bits;
      }
      equals(o) {
        if (!(o instanceof Mode$1)) {
          return false;
        }
        const other = o;
        return this.value === other.value;
      }
      toString() {
        return this.stringValue;
      }
    }
    Mode$1.FOR_BITS = /* @__PURE__ */ new Map();
    Mode$1.FOR_VALUE = /* @__PURE__ */ new Map();
    Mode$1.TERMINATOR = new Mode$1(ModeValues.TERMINATOR, "TERMINATOR", Int32Array.from([0, 0, 0]), 0);
    Mode$1.NUMERIC = new Mode$1(ModeValues.NUMERIC, "NUMERIC", Int32Array.from([10, 12, 14]), 1);
    Mode$1.ALPHANUMERIC = new Mode$1(ModeValues.ALPHANUMERIC, "ALPHANUMERIC", Int32Array.from([9, 11, 13]), 2);
    Mode$1.STRUCTURED_APPEND = new Mode$1(ModeValues.STRUCTURED_APPEND, "STRUCTURED_APPEND", Int32Array.from([0, 0, 0]), 3);
    Mode$1.BYTE = new Mode$1(ModeValues.BYTE, "BYTE", Int32Array.from([8, 16, 16]), 4);
    Mode$1.ECI = new Mode$1(ModeValues.ECI, "ECI", Int32Array.from([0, 0, 0]), 7);
    Mode$1.KANJI = new Mode$1(ModeValues.KANJI, "KANJI", Int32Array.from([8, 10, 12]), 8);
    Mode$1.FNC1_FIRST_POSITION = new Mode$1(ModeValues.FNC1_FIRST_POSITION, "FNC1_FIRST_POSITION", Int32Array.from([0, 0, 0]), 5);
    Mode$1.FNC1_SECOND_POSITION = new Mode$1(ModeValues.FNC1_SECOND_POSITION, "FNC1_SECOND_POSITION", Int32Array.from([0, 0, 0]), 9);
    Mode$1.HANZI = new Mode$1(ModeValues.HANZI, "HANZI", Int32Array.from([8, 10, 12]), 13);
    class DecodedBitStreamParser$1 {
      static decode(bytes2, version2, ecLevel, hints) {
        const bits = new BitSource(bytes2);
        let result = new StringBuilder();
        const byteSegments = new Array();
        let symbolSequence = -1;
        let parityData = -1;
        try {
          let currentCharacterSetECI = null;
          let fc1InEffect = false;
          let mode;
          do {
            if (bits.available() < 4) {
              mode = Mode$1.TERMINATOR;
            } else {
              const modeBits = bits.readBits(4);
              mode = Mode$1.forBits(modeBits);
            }
            switch (mode) {
              case Mode$1.TERMINATOR:
                break;
              case Mode$1.FNC1_FIRST_POSITION:
              case Mode$1.FNC1_SECOND_POSITION:
                fc1InEffect = true;
                break;
              case Mode$1.STRUCTURED_APPEND:
                if (bits.available() < 16) {
                  throw new FormatException();
                }
                symbolSequence = bits.readBits(8);
                parityData = bits.readBits(8);
                break;
              case Mode$1.ECI:
                const value = DecodedBitStreamParser$1.parseECIValue(bits);
                currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);
                if (currentCharacterSetECI === null) {
                  throw new FormatException();
                }
                break;
              case Mode$1.HANZI:
                const subset = bits.readBits(4);
                const countHanzi = bits.readBits(mode.getCharacterCountBits(version2));
                if (subset === DecodedBitStreamParser$1.GB2312_SUBSET) {
                  DecodedBitStreamParser$1.decodeHanziSegment(bits, result, countHanzi);
                }
                break;
              default:
                const count = bits.readBits(mode.getCharacterCountBits(version2));
                switch (mode) {
                  case Mode$1.NUMERIC:
                    DecodedBitStreamParser$1.decodeNumericSegment(bits, result, count);
                    break;
                  case Mode$1.ALPHANUMERIC:
                    DecodedBitStreamParser$1.decodeAlphanumericSegment(bits, result, count, fc1InEffect);
                    break;
                  case Mode$1.BYTE:
                    DecodedBitStreamParser$1.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);
                    break;
                  case Mode$1.KANJI:
                    DecodedBitStreamParser$1.decodeKanjiSegment(bits, result, count);
                    break;
                  default:
                    throw new FormatException();
                }
                break;
            }
          } while (mode !== Mode$1.TERMINATOR);
        } catch (iae) {
          throw new FormatException();
        }
        return new DecoderResult(bytes2, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
      }
      /**
       * See specification GBT 18284-2000
       */
      static decodeHanziSegment(bits, result, count) {
        if (count * 13 > bits.available()) {
          throw new FormatException();
        }
        const buffer = new Uint8Array(2 * count);
        let offset = 0;
        while (count > 0) {
          const twoBytes = bits.readBits(13);
          let assembledTwoBytes = twoBytes / 96 << 8 & 4294967295 | twoBytes % 96;
          if (assembledTwoBytes < 959) {
            assembledTwoBytes += 41377;
          } else {
            assembledTwoBytes += 42657;
          }
          buffer[offset] = /*(byte) */
          assembledTwoBytes >> 8 & 255;
          buffer[offset + 1] = /*(byte) */
          assembledTwoBytes & 255;
          offset += 2;
          count--;
        }
        try {
          result.append(StringEncoding.decode(buffer, StringUtils.GB2312));
        } catch (ignored) {
          throw new FormatException(ignored);
        }
      }
      static decodeKanjiSegment(bits, result, count) {
        if (count * 13 > bits.available()) {
          throw new FormatException();
        }
        const buffer = new Uint8Array(2 * count);
        let offset = 0;
        while (count > 0) {
          const twoBytes = bits.readBits(13);
          let assembledTwoBytes = twoBytes / 192 << 8 & 4294967295 | twoBytes % 192;
          if (assembledTwoBytes < 7936) {
            assembledTwoBytes += 33088;
          } else {
            assembledTwoBytes += 49472;
          }
          buffer[offset] = /*(byte) */
          assembledTwoBytes >> 8;
          buffer[offset + 1] = /*(byte) */
          assembledTwoBytes;
          offset += 2;
          count--;
        }
        try {
          result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));
        } catch (ignored) {
          throw new FormatException(ignored);
        }
      }
      static decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints) {
        if (8 * count > bits.available()) {
          throw new FormatException();
        }
        const readBytes = new Uint8Array(count);
        for (let i = 0; i < count; i++) {
          readBytes[i] = /*(byte) */
          bits.readBits(8);
        }
        let encoding;
        if (currentCharacterSetECI === null) {
          encoding = StringUtils.guessEncoding(readBytes, hints);
        } else {
          encoding = currentCharacterSetECI.getName();
        }
        try {
          result.append(StringEncoding.decode(readBytes, encoding));
        } catch (ignored) {
          throw new FormatException(ignored);
        }
        byteSegments.push(readBytes);
      }
      static toAlphaNumericChar(value) {
        if (value >= DecodedBitStreamParser$1.ALPHANUMERIC_CHARS.length) {
          throw new FormatException();
        }
        return DecodedBitStreamParser$1.ALPHANUMERIC_CHARS[value];
      }
      static decodeAlphanumericSegment(bits, result, count, fc1InEffect) {
        const start = result.length();
        while (count > 1) {
          if (bits.available() < 11) {
            throw new FormatException();
          }
          const nextTwoCharsBits = bits.readBits(11);
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(nextTwoCharsBits % 45));
          count -= 2;
        }
        if (count === 1) {
          if (bits.available() < 6) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(bits.readBits(6)));
        }
        if (fc1InEffect) {
          for (let i = start; i < result.length(); i++) {
            if (result.charAt(i) === "%") {
              if (i < result.length() - 1 && result.charAt(i + 1) === "%") {
                result.deleteCharAt(i + 1);
              } else {
                result.setCharAt(i, String.fromCharCode(29));
              }
            }
          }
        }
      }
      static decodeNumericSegment(bits, result, count) {
        while (count >= 3) {
          if (bits.available() < 10) {
            throw new FormatException();
          }
          const threeDigitsBits = bits.readBits(10);
          if (threeDigitsBits >= 1e3) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(threeDigitsBits % 10));
          count -= 3;
        }
        if (count === 2) {
          if (bits.available() < 7) {
            throw new FormatException();
          }
          const twoDigitsBits = bits.readBits(7);
          if (twoDigitsBits >= 100) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(twoDigitsBits % 10));
        } else if (count === 1) {
          if (bits.available() < 4) {
            throw new FormatException();
          }
          const digitBits = bits.readBits(4);
          if (digitBits >= 10) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(digitBits));
        }
      }
      static parseECIValue(bits) {
        const firstByte = bits.readBits(8);
        if ((firstByte & 128) === 0) {
          return firstByte & 127;
        }
        if ((firstByte & 192) === 128) {
          const secondByte = bits.readBits(8);
          return (firstByte & 63) << 8 & 4294967295 | secondByte;
        }
        if ((firstByte & 224) === 192) {
          const secondThirdBytes = bits.readBits(16);
          return (firstByte & 31) << 16 & 4294967295 | secondThirdBytes;
        }
        throw new FormatException();
      }
    }
    DecodedBitStreamParser$1.ALPHANUMERIC_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
    DecodedBitStreamParser$1.GB2312_SUBSET = 1;
    class QRCodeDecoderMetaData {
      constructor(mirrored) {
        this.mirrored = mirrored;
      }
      /**
       * @return true if the QR Code was mirrored.
       */
      isMirrored() {
        return this.mirrored;
      }
      /**
       * Apply the result points' order correction due to mirroring.
       *
       * @param points Array of points to apply mirror correction to.
       */
      applyMirroredCorrection(points) {
        if (!this.mirrored || points === null || points.length < 3) {
          return;
        }
        const bottomLeft = points[0];
        points[0] = points[2];
        points[2] = bottomLeft;
      }
    }
    class Decoder$2 {
      constructor() {
        this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);
      }
      // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {
      //   return decode(image, null)
      // }
      /**
       * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.
       * "true" is taken to mean a black module.</p>
       *
       * @param image booleans representing white/black QR Code modules
       * @param hints decoding hints that should be used to influence decoding
       * @return text and bytes encoded within the QR Code
       * @throws FormatException if the QR Code cannot be decoded
       * @throws ChecksumException if error correction fails
       */
      decodeBooleanArray(image, hints) {
        return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);
      }
      // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {
      //   return decode(bits, null)
      // }
      /**
       * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or "true" is taken to mean a black module.</p>
       *
       * @param bits booleans representing white/black QR Code modules
       * @param hints decoding hints that should be used to influence decoding
       * @return text and bytes encoded within the QR Code
       * @throws FormatException if the QR Code cannot be decoded
       * @throws ChecksumException if error correction fails
       */
      decodeBitMatrix(bits, hints) {
        const parser = new BitMatrixParser$1(bits);
        let ex = null;
        try {
          return this.decodeBitMatrixParser(parser, hints);
        } catch (e) {
          ex = e;
        }
        try {
          parser.remask();
          parser.setMirror(true);
          parser.readVersion();
          parser.readFormatInformation();
          parser.mirror();
          const result = this.decodeBitMatrixParser(parser, hints);
          result.setOther(new QRCodeDecoderMetaData(true));
          return result;
        } catch (e) {
          if (ex !== null) {
            throw ex;
          }
          throw e;
        }
      }
      decodeBitMatrixParser(parser, hints) {
        const version2 = parser.readVersion();
        const ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
        const codewords = parser.readCodewords();
        const dataBlocks = DataBlock$1.getDataBlocks(codewords, version2, ecLevel);
        let totalBytes = 0;
        for (const dataBlock of dataBlocks) {
          totalBytes += dataBlock.getNumDataCodewords();
        }
        const resultBytes = new Uint8Array(totalBytes);
        let resultOffset = 0;
        for (const dataBlock of dataBlocks) {
          const codewordBytes = dataBlock.getCodewords();
          const numDataCodewords = dataBlock.getNumDataCodewords();
          this.correctErrors(codewordBytes, numDataCodewords);
          for (let i = 0; i < numDataCodewords; i++) {
            resultBytes[resultOffset++] = codewordBytes[i];
          }
        }
        return DecodedBitStreamParser$1.decode(resultBytes, version2, ecLevel, hints);
      }
      /**
       * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
       * correct the errors in-place using Reed-Solomon error correction.</p>
       *
       * @param codewordBytes data and error correction codewords
       * @param numDataCodewords number of codewords that are data bytes
       * @throws ChecksumException if error correction fails
       */
      correctErrors(codewordBytes, numDataCodewords) {
        const codewordsInts = new Int32Array(codewordBytes);
        try {
          this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        } catch (ignored) {
          throw new ChecksumException();
        }
        for (let i = 0; i < numDataCodewords; i++) {
          codewordBytes[i] = /*(byte) */
          codewordsInts[i];
        }
      }
    }
    class AlignmentPattern extends ResultPoint {
      constructor(posX, posY, estimatedModuleSize) {
        super(posX, posY);
        this.estimatedModuleSize = estimatedModuleSize;
      }
      /**
       * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated
       * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
       */
      aboutEquals(moduleSize, i, j) {
        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
          const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
          return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
      }
      /**
       * Combines this object's current estimate of a finder pattern position and module size
       * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.
       */
      combineEstimate(i, j, newModuleSize) {
        const combinedX = (this.getX() + j) / 2;
        const combinedY = (this.getY() + i) / 2;
        const combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2;
        return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
      }
    }
    class AlignmentPatternFinder {
      /**
       * <p>Creates a finder that will look in a portion of the whole image.</p>
       *
       * @param image image to search
       * @param startX left column from which to start searching
       * @param startY top row from which to start searching
       * @param width width of region to search
       * @param height height of region to search
       * @param moduleSize estimated module size so far
       */
      constructor(image, startX, startY, width, height, moduleSize, resultPointCallback) {
        this.image = image;
        this.startX = startX;
        this.startY = startY;
        this.width = width;
        this.height = height;
        this.moduleSize = moduleSize;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = [];
        this.crossCheckStateCount = new Int32Array(3);
      }
      /**
       * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since
       * it's pretty performance-critical and so is written to be fast foremost.</p>
       *
       * @return {@link AlignmentPattern} if found
       * @throws NotFoundException if not found
       */
      find() {
        const startX = this.startX;
        const height = this.height;
        const width = this.width;
        const maxJ = startX + width;
        const middleI = this.startY + height / 2;
        const stateCount = new Int32Array(3);
        const image = this.image;
        for (let iGen = 0; iGen < height; iGen++) {
          const i = middleI + ((iGen & 1) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
          stateCount[0] = 0;
          stateCount[1] = 0;
          stateCount[2] = 0;
          let j = startX;
          while (j < maxJ && !image.get(j, i)) {
            j++;
          }
          let currentState = 0;
          while (j < maxJ) {
            if (image.get(j, i)) {
              if (currentState === 1) {
                stateCount[1]++;
              } else {
                if (currentState === 2) {
                  if (this.foundPatternCross(stateCount)) {
                    const confirmed = this.handlePossibleCenter(stateCount, i, j);
                    if (confirmed !== null) {
                      return confirmed;
                    }
                  }
                  stateCount[0] = stateCount[2];
                  stateCount[1] = 1;
                  stateCount[2] = 0;
                  currentState = 1;
                } else {
                  stateCount[++currentState]++;
                }
              }
            } else {
              if (currentState === 1) {
                currentState++;
              }
              stateCount[currentState]++;
            }
            j++;
          }
          if (this.foundPatternCross(stateCount)) {
            const confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
            if (confirmed !== null) {
              return confirmed;
            }
          }
        }
        if (this.possibleCenters.length !== 0) {
          return this.possibleCenters[0];
        }
        throw new NotFoundException();
      }
      /**
       * Given a count of black/white/black pixels just seen and an end position,
       * figures the location of the center of this black/white/black run.
       */
      static centerFromEnd(stateCount, end) {
        return end - stateCount[2] - stateCount[1] / 2;
      }
      /**
       * @param stateCount count of black/white/black pixels just read
       * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios
       *         used by alignment patterns to be considered a match
       */
      foundPatternCross(stateCount) {
        const moduleSize = this.moduleSize;
        const maxVariance = moduleSize / 2;
        for (let i = 0; i < 3; i++) {
          if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
            return false;
          }
        }
        return true;
      }
      /**
       * <p>After a horizontal scan finds a potential alignment pattern, this method
       * "cross-checks" by scanning down vertically through the center of the possible
       * alignment pattern to see if the same proportion is detected.</p>
       *
       * @param startI row where an alignment pattern was detected
       * @param centerJ center of the section that appears to cross an alignment pattern
       * @param maxCount maximum reasonable number of modules that should be
       * observed in any reading state, based on the results of the horizontal scan
       * @return vertical center of alignment pattern, or {@link Float#NaN} if not found
       */
      crossCheckVertical(startI, centerJ, maxCount, originalStateCountTotal) {
        const image = this.image;
        const maxI = image.getHeight();
        const stateCount = this.crossCheckStateCount;
        stateCount[0] = 0;
        stateCount[1] = 0;
        stateCount[2] = 0;
        let i = startI;
        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i--;
        }
        if (i < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        i = startI + 1;
        while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i++;
        }
        if (i === maxI || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {
          stateCount[2]++;
          i++;
        }
        if (stateCount[2] > maxCount) {
          return NaN;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
          return NaN;
        }
        return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;
      }
      /**
       * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
       * cross check with a vertical scan, and if successful, will see if this pattern had been
       * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have
       * found the alignment pattern.</p>
       *
       * @param stateCount reading state module counts from horizontal scan
       * @param i row where alignment pattern may be found
       * @param j end of possible alignment pattern in row
       * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not
       */
      handlePossibleCenter(stateCount, i, j) {
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        const centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);
        const centerI = this.crossCheckVertical(
          i,
          /*(int) */
          centerJ,
          2 * stateCount[1],
          stateCountTotal
        );
        if (!isNaN(centerI)) {
          const estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3;
          for (const center of this.possibleCenters) {
            if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
              return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
            }
          }
          const point5 = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
          this.possibleCenters.push(point5);
          if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
            this.resultPointCallback.foundPossibleResultPoint(point5);
          }
        }
        return null;
      }
    }
    class FinderPattern$1 extends ResultPoint {
      // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {
      //   this(posX, posY, estimatedModuleSize, 1)
      // }
      constructor(posX, posY, estimatedModuleSize, count) {
        super(posX, posY);
        this.estimatedModuleSize = estimatedModuleSize;
        this.count = count;
        if (void 0 === count) {
          this.count = 1;
        }
      }
      getEstimatedModuleSize() {
        return this.estimatedModuleSize;
      }
      getCount() {
        return this.count;
      }
      /*
      void incrementCount() {
        this.count++
      }
       */
      /**
       * <p>Determines if this finder pattern "about equals" a finder pattern at the stated
       * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
       */
      aboutEquals(moduleSize, i, j) {
        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
          const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
          return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
      }
      /**
       * Combines this object's current estimate of a finder pattern position and module size
       * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average
       * based on count.
       */
      combineEstimate(i, j, newModuleSize) {
        const combinedCount = this.count + 1;
        const combinedX = (this.count * this.getX() + j) / combinedCount;
        const combinedY = (this.count * this.getY() + i) / combinedCount;
        const combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
        return new FinderPattern$1(combinedX, combinedY, combinedModuleSize, combinedCount);
      }
    }
    class FinderPatternInfo {
      constructor(patternCenters) {
        this.bottomLeft = patternCenters[0];
        this.topLeft = patternCenters[1];
        this.topRight = patternCenters[2];
      }
      getBottomLeft() {
        return this.bottomLeft;
      }
      getTopLeft() {
        return this.topLeft;
      }
      getTopRight() {
        return this.topRight;
      }
    }
    class FinderPatternFinder {
      /**
       * <p>Creates a finder that will search the image for three finder patterns.</p>
       *
       * @param image image to search
       */
      // public constructor(image: BitMatrix) {
      //   this(image, null)
      // }
      constructor(image, resultPointCallback) {
        this.image = image;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = [];
        this.crossCheckStateCount = new Int32Array(5);
        this.resultPointCallback = resultPointCallback;
      }
      getImage() {
        return this.image;
      }
      getPossibleCenters() {
        return this.possibleCenters;
      }
      find(hints) {
        const tryHarder = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.TRY_HARDER);
        const pureBarcode = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.PURE_BARCODE);
        const image = this.image;
        const maxI = image.getHeight();
        const maxJ = image.getWidth();
        let iSkip = Math.floor(3 * maxI / (4 * FinderPatternFinder.MAX_MODULES));
        if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {
          iSkip = FinderPatternFinder.MIN_SKIP;
        }
        let done = false;
        const stateCount = new Int32Array(5);
        for (let i = iSkip - 1; i < maxI && !done; i += iSkip) {
          stateCount[0] = 0;
          stateCount[1] = 0;
          stateCount[2] = 0;
          stateCount[3] = 0;
          stateCount[4] = 0;
          let currentState = 0;
          for (let j = 0; j < maxJ; j++) {
            if (image.get(j, i)) {
              if ((currentState & 1) === 1) {
                currentState++;
              }
              stateCount[currentState]++;
            } else {
              if ((currentState & 1) === 0) {
                if (currentState === 4) {
                  if (FinderPatternFinder.foundPatternCross(stateCount)) {
                    const confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);
                    if (confirmed === true) {
                      iSkip = 2;
                      if (this.hasSkipped === true) {
                        done = this.haveMultiplyConfirmedCenters();
                      } else {
                        const rowSkip = this.findRowSkip();
                        if (rowSkip > stateCount[2]) {
                          i += rowSkip - stateCount[2] - iSkip;
                          j = maxJ - 1;
                        }
                      }
                    } else {
                      stateCount[0] = stateCount[2];
                      stateCount[1] = stateCount[3];
                      stateCount[2] = stateCount[4];
                      stateCount[3] = 1;
                      stateCount[4] = 0;
                      currentState = 3;
                      continue;
                    }
                    currentState = 0;
                    stateCount[0] = 0;
                    stateCount[1] = 0;
                    stateCount[2] = 0;
                    stateCount[3] = 0;
                    stateCount[4] = 0;
                  } else {
                    stateCount[0] = stateCount[2];
                    stateCount[1] = stateCount[3];
                    stateCount[2] = stateCount[4];
                    stateCount[3] = 1;
                    stateCount[4] = 0;
                    currentState = 3;
                  }
                } else {
                  stateCount[++currentState]++;
                }
              } else {
                stateCount[currentState]++;
              }
            }
          }
          if (FinderPatternFinder.foundPatternCross(stateCount)) {
            const confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);
            if (confirmed === true) {
              iSkip = stateCount[0];
              if (this.hasSkipped) {
                done = this.haveMultiplyConfirmedCenters();
              }
            }
          }
        }
        const patternInfo = this.selectBestPatterns();
        ResultPoint.orderBestPatterns(patternInfo);
        return new FinderPatternInfo(patternInfo);
      }
      /**
       * Given a count of black/white/black/white/black pixels just seen and an end position,
       * figures the location of the center of this run.
       */
      static centerFromEnd(stateCount, end) {
        return end - stateCount[4] - stateCount[3] - stateCount[2] / 2;
      }
      /**
       * @param stateCount count of black/white/black/white/black pixels just read
       * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios
       *         used by finder patterns to be considered a match
       */
      static foundPatternCross(stateCount) {
        let totalModuleSize = 0;
        for (let i = 0; i < 5; i++) {
          const count = stateCount[i];
          if (count === 0) {
            return false;
          }
          totalModuleSize += count;
        }
        if (totalModuleSize < 7) {
          return false;
        }
        const moduleSize = totalModuleSize / 7;
        const maxVariance = moduleSize / 2;
        return Math.abs(moduleSize - stateCount[0]) < maxVariance && Math.abs(moduleSize - stateCount[1]) < maxVariance && Math.abs(3 * moduleSize - stateCount[2]) < 3 * maxVariance && Math.abs(moduleSize - stateCount[3]) < maxVariance && Math.abs(moduleSize - stateCount[4]) < maxVariance;
      }
      getCrossCheckStateCount() {
        const crossCheckStateCount = this.crossCheckStateCount;
        crossCheckStateCount[0] = 0;
        crossCheckStateCount[1] = 0;
        crossCheckStateCount[2] = 0;
        crossCheckStateCount[3] = 0;
        crossCheckStateCount[4] = 0;
        return crossCheckStateCount;
      }
      /**
       * After a vertical and horizontal scan finds a potential finder pattern, this method
       * "cross-cross-cross-checks" by scanning down diagonally through the center of the possible
       * finder pattern to see if the same proportion is detected.
       *
       * @param startI row where a finder pattern was detected
       * @param centerJ center of the section that appears to cross a finder pattern
       * @param maxCount maximum reasonable number of modules that should be
       *  observed in any reading state, based on the results of the horizontal scan
       * @param originalStateCountTotal The original state count total.
       * @return true if proportions are withing expected limits
       */
      crossCheckDiagonal(startI, centerJ, maxCount, originalStateCountTotal) {
        const stateCount = this.getCrossCheckStateCount();
        let i = 0;
        const image = this.image;
        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {
          stateCount[2]++;
          i++;
        }
        if (startI < i || centerJ < i) {
          return false;
        }
        while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i++;
        }
        if (startI < i || centerJ < i || stateCount[1] > maxCount) {
          return false;
        }
        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i++;
        }
        if (stateCount[0] > maxCount) {
          return false;
        }
        const maxI = image.getHeight();
        const maxJ = image.getWidth();
        i = 1;
        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {
          stateCount[2]++;
          i++;
        }
        if (startI + i >= maxI || centerJ + i >= maxJ) {
          return false;
        }
        while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) && stateCount[3] < maxCount) {
          stateCount[3]++;
          i++;
        }
        if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {
          return false;
        }
        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) && stateCount[4] < maxCount) {
          stateCount[4]++;
          i++;
        }
        if (stateCount[4] >= maxCount) {
          return false;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal && FinderPatternFinder.foundPatternCross(stateCount);
      }
      /**
       * <p>After a horizontal scan finds a potential finder pattern, this method
       * "cross-checks" by scanning down vertically through the center of the possible
       * finder pattern to see if the same proportion is detected.</p>
       *
       * @param startI row where a finder pattern was detected
       * @param centerJ center of the section that appears to cross a finder pattern
       * @param maxCount maximum reasonable number of modules that should be
       * observed in any reading state, based on the results of the horizontal scan
       * @return vertical center of finder pattern, or {@link Float#NaN} if not found
       */
      crossCheckVertical(startI, centerJ, maxCount, originalStateCountTotal) {
        const image = this.image;
        const maxI = image.getHeight();
        const stateCount = this.getCrossCheckStateCount();
        let i = startI;
        while (i >= 0 && image.get(centerJ, i)) {
          stateCount[2]++;
          i--;
        }
        if (i < 0) {
          return NaN;
        }
        while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i--;
        }
        if (i < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        i = startI + 1;
        while (i < maxI && image.get(centerJ, i)) {
          stateCount[2]++;
          i++;
        }
        if (i === maxI) {
          return NaN;
        }
        while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {
          stateCount[3]++;
          i++;
        }
        if (i === maxI || stateCount[3] >= maxCount) {
          return NaN;
        }
        while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {
          stateCount[4]++;
          i++;
        }
        if (stateCount[4] >= maxCount) {
          return NaN;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
          return NaN;
        }
        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;
      }
      /**
       * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,
       * except it reads horizontally instead of vertically. This is used to cross-cross
       * check a vertical cross check and locate the real center of the alignment pattern.</p>
       */
      crossCheckHorizontal(startJ, centerI, maxCount, originalStateCountTotal) {
        const image = this.image;
        const maxJ = image.getWidth();
        const stateCount = this.getCrossCheckStateCount();
        let j = startJ;
        while (j >= 0 && image.get(j, centerI)) {
          stateCount[2]++;
          j--;
        }
        if (j < 0) {
          return NaN;
        }
        while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          j--;
        }
        if (j < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          j--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        j = startJ + 1;
        while (j < maxJ && image.get(j, centerI)) {
          stateCount[2]++;
          j++;
        }
        if (j === maxJ) {
          return NaN;
        }
        while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {
          stateCount[3]++;
          j++;
        }
        if (j === maxJ || stateCount[3] >= maxCount) {
          return NaN;
        }
        while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {
          stateCount[4]++;
          j++;
        }
        if (stateCount[4] >= maxCount) {
          return NaN;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
          return NaN;
        }
        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;
      }
      /**
       * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
       * cross check with a vertical scan, and if successful, will, ah, cross-cross-check
       * with another horizontal scan. This is needed primarily to locate the real horizontal
       * center of the pattern in cases of extreme skew.
       * And then we cross-cross-cross check with another diagonal scan.</p>
       *
       * <p>If that succeeds the finder pattern location is added to a list that tracks
       * the number of times each location has been nearly-matched as a finder pattern.
       * Each additional find is more evidence that the location is in fact a finder
       * pattern center
       *
       * @param stateCount reading state module counts from horizontal scan
       * @param i row where finder pattern may be found
       * @param j end of possible finder pattern in row
       * @param pureBarcode true if in "pure barcode" mode
       * @return true if a finder pattern candidate was found this time
       */
      handlePossibleCenter(stateCount, i, j, pureBarcode) {
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        let centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);
        let centerI = this.crossCheckVertical(
          i,
          /*(int) */
          Math.floor(centerJ),
          stateCount[2],
          stateCountTotal
        );
        if (!isNaN(centerI)) {
          centerJ = this.crossCheckHorizontal(
            /*(int) */
            Math.floor(centerJ),
            /*(int) */
            Math.floor(centerI),
            stateCount[2],
            stateCountTotal
          );
          if (!isNaN(centerJ) && (!pureBarcode || this.crossCheckDiagonal(
            /*(int) */
            Math.floor(centerI),
            /*(int) */
            Math.floor(centerJ),
            stateCount[2],
            stateCountTotal
          ))) {
            const estimatedModuleSize = stateCountTotal / 7;
            let found = false;
            const possibleCenters = this.possibleCenters;
            for (let index2 = 0, length = possibleCenters.length; index2 < length; index2++) {
              const center = possibleCenters[index2];
              if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                possibleCenters[index2] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                found = true;
                break;
              }
            }
            if (!found) {
              const point5 = new FinderPattern$1(centerJ, centerI, estimatedModuleSize);
              possibleCenters.push(point5);
              if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
                this.resultPointCallback.foundPossibleResultPoint(point5);
              }
            }
            return true;
          }
        }
        return false;
      }
      /**
       * @return number of rows we could safely skip during scanning, based on the first
       *         two finder patterns that have been located. In some cases their position will
       *         allow us to infer that the third pattern must lie below a certain point farther
       *         down in the image.
       */
      findRowSkip() {
        const max = this.possibleCenters.length;
        if (max <= 1) {
          return 0;
        }
        let firstConfirmedCenter = null;
        for (const center of this.possibleCenters) {
          if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
            if (firstConfirmedCenter == null) {
              firstConfirmedCenter = center;
            } else {
              this.hasSkipped = true;
              return (
                /*(int) */
                Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) - Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2)
              );
            }
          }
        }
        return 0;
      }
      /**
       * @return true iff we have found at least 3 finder patterns that have been detected
       *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the
       *         candidates is "pretty similar"
       */
      haveMultiplyConfirmedCenters() {
        let confirmedCount = 0;
        let totalModuleSize = 0;
        const max = this.possibleCenters.length;
        for (const pattern of this.possibleCenters) {
          if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
            confirmedCount++;
            totalModuleSize += pattern.getEstimatedModuleSize();
          }
        }
        if (confirmedCount < 3) {
          return false;
        }
        const average = totalModuleSize / max;
        let totalDeviation = 0;
        for (const pattern of this.possibleCenters) {
          totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
        }
        return totalDeviation <= 0.05 * totalModuleSize;
      }
      /**
       * @return the 3 best {@link FinderPattern}s from our list of candidates. The "best" are
       *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module
       *         size differs from the average among those patterns the least
       * @throws NotFoundException if 3 such finder patterns do not exist
       */
      selectBestPatterns() {
        const startSize = this.possibleCenters.length;
        if (startSize < 3) {
          throw new NotFoundException();
        }
        const possibleCenters = this.possibleCenters;
        let average;
        if (startSize > 3) {
          let totalModuleSize = 0;
          let square = 0;
          for (const center of this.possibleCenters) {
            const size = center.getEstimatedModuleSize();
            totalModuleSize += size;
            square += size * size;
          }
          average = totalModuleSize / startSize;
          let stdDev = Math.sqrt(square / startSize - average * average);
          possibleCenters.sort(
            /**
             * <p>Orders by furthest from average</p>
             */
            // FurthestFromAverageComparator implements Comparator<FinderPattern>
            (center1, center2) => {
              const dA = Math.abs(center2.getEstimatedModuleSize() - average);
              const dB = Math.abs(center1.getEstimatedModuleSize() - average);
              return dA < dB ? -1 : dA > dB ? 1 : 0;
            }
          );
          const limit = Math.max(0.2 * average, stdDev);
          for (let i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {
            const pattern = possibleCenters[i];
            if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
              possibleCenters.splice(i, 1);
              i--;
            }
          }
        }
        if (possibleCenters.length > 3) {
          let totalModuleSize = 0;
          for (const possibleCenter of possibleCenters) {
            totalModuleSize += possibleCenter.getEstimatedModuleSize();
          }
          average = totalModuleSize / possibleCenters.length;
          possibleCenters.sort(
            /**
             * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>
             */
            // CenterComparator implements Comparator<FinderPattern>
            (center1, center2) => {
              if (center2.getCount() === center1.getCount()) {
                const dA = Math.abs(center2.getEstimatedModuleSize() - average);
                const dB = Math.abs(center1.getEstimatedModuleSize() - average);
                return dA < dB ? 1 : dA > dB ? -1 : 0;
              } else {
                return center2.getCount() - center1.getCount();
              }
            }
          );
          possibleCenters.splice(3);
        }
        return [
          possibleCenters[0],
          possibleCenters[1],
          possibleCenters[2]
        ];
      }
    }
    FinderPatternFinder.CENTER_QUORUM = 2;
    FinderPatternFinder.MIN_SKIP = 3;
    FinderPatternFinder.MAX_MODULES = 57;
    class Detector$2 {
      constructor(image) {
        this.image = image;
      }
      getImage() {
        return this.image;
      }
      getResultPointCallback() {
        return this.resultPointCallback;
      }
      /**
       * <p>Detects a QR Code in an image.</p>
       *
       * @return {@link DetectorResult} encapsulating results of detecting a QR Code
       * @throws NotFoundException if QR Code cannot be found
       * @throws FormatException if a QR Code cannot be decoded
       */
      // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {
      //   return detect(null)
      // }
      /**
       * <p>Detects a QR Code in an image.</p>
       *
       * @param hints optional hints to detector
       * @return {@link DetectorResult} encapsulating results of detecting a QR Code
       * @throws NotFoundException if QR Code cannot be found
       * @throws FormatException if a QR Code cannot be decoded
       */
      detect(hints) {
        this.resultPointCallback = hints === null || hints === void 0 ? null : (
          /*(ResultPointCallback) */
          hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK)
        );
        const finder = new FinderPatternFinder(this.image, this.resultPointCallback);
        const info = finder.find(hints);
        return this.processFinderPatternInfo(info);
      }
      processFinderPatternInfo(info) {
        const topLeft = info.getTopLeft();
        const topRight = info.getTopRight();
        const bottomLeft = info.getBottomLeft();
        const moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
        if (moduleSize < 1) {
          throw new NotFoundException("No pattern found in proccess finder.");
        }
        const dimension = Detector$2.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
        const provisionalVersion = Version$1.getProvisionalVersionForDimension(dimension);
        const modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
        let alignmentPattern = null;
        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
          const bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
          const bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
          const correctionToTopLeft = 1 - 3 / modulesBetweenFPCenters;
          const estAlignmentX = (
            /*(int) */
            Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()))
          );
          const estAlignmentY = (
            /*(int) */
            Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()))
          );
          for (let i = 4; i <= 16; i <<= 1) {
            try {
              alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);
              break;
            } catch (re) {
              if (!(re instanceof NotFoundException)) {
                throw re;
              }
            }
          }
        }
        const transform = Detector$2.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
        const bits = Detector$2.sampleGrid(this.image, transform, dimension);
        let points;
        if (alignmentPattern === null) {
          points = [bottomLeft, topLeft, topRight];
        } else {
          points = [bottomLeft, topLeft, topRight, alignmentPattern];
        }
        return new DetectorResult(bits, points);
      }
      static createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension) {
        const dimMinusThree = dimension - 3.5;
        let bottomRightX;
        let bottomRightY;
        let sourceBottomRightX;
        let sourceBottomRightY;
        if (alignmentPattern !== null) {
          bottomRightX = alignmentPattern.getX();
          bottomRightY = alignmentPattern.getY();
          sourceBottomRightX = dimMinusThree - 3;
          sourceBottomRightY = sourceBottomRightX;
        } else {
          bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
          bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
          sourceBottomRightX = dimMinusThree;
          sourceBottomRightY = dimMinusThree;
        }
        return PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
      }
      static sampleGrid(image, transform, dimension) {
        const sampler = GridSamplerInstance.getInstance();
        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
      }
      /**
       * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position
       * of the finder patterns and estimated module size.</p>
       */
      static computeDimension(topLeft, topRight, bottomLeft, moduleSize) {
        const tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
        const tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
        let dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
        switch (dimension & 3) {
          case 0:
            dimension++;
            break;
          case 2:
            dimension--;
            break;
          case 3:
            throw new NotFoundException("Dimensions could be not found.");
        }
        return dimension;
      }
      /**
       * <p>Computes an average estimated module size based on estimated derived from the positions
       * of the three finder patterns.</p>
       *
       * @param topLeft detected top-left finder pattern center
       * @param topRight detected top-right finder pattern center
       * @param bottomLeft detected bottom-left finder pattern center
       * @return estimated module size
       */
      calculateModuleSize(topLeft, topRight, bottomLeft) {
        return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2;
      }
      /**
       * <p>Estimates module size based on two finder patterns -- it uses
       * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the
       * width of each, measuring along the axis between their centers.</p>
       */
      calculateModuleSizeOneWay(pattern, otherPattern) {
        const moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(
          /*(int) */
          Math.floor(pattern.getX()),
          /*(int) */
          Math.floor(pattern.getY()),
          /*(int) */
          Math.floor(otherPattern.getX()),
          /*(int) */
          Math.floor(otherPattern.getY())
        );
        const moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(
          /*(int) */
          Math.floor(otherPattern.getX()),
          /*(int) */
          Math.floor(otherPattern.getY()),
          /*(int) */
          Math.floor(pattern.getX()),
          /*(int) */
          Math.floor(pattern.getY())
        );
        if (isNaN(moduleSizeEst1)) {
          return moduleSizeEst2 / 7;
        }
        if (isNaN(moduleSizeEst2)) {
          return moduleSizeEst1 / 7;
        }
        return (moduleSizeEst1 + moduleSizeEst2) / 14;
      }
      /**
       * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of
       * a finder pattern by looking for a black-white-black run from the center in the direction
       * of another point (another finder pattern center), and in the opposite direction too.
       */
      sizeOfBlackWhiteBlackRunBothWays(fromX, fromY, toX, toY) {
        let result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
        let scale = 1;
        let otherToX = fromX - (toX - fromX);
        if (otherToX < 0) {
          scale = fromX / /*(float) */
          (fromX - otherToX);
          otherToX = 0;
        } else if (otherToX >= this.image.getWidth()) {
          scale = (this.image.getWidth() - 1 - fromX) / /*(float) */
          (otherToX - fromX);
          otherToX = this.image.getWidth() - 1;
        }
        let otherToY = (
          /*(int) */
          Math.floor(fromY - (toY - fromY) * scale)
        );
        scale = 1;
        if (otherToY < 0) {
          scale = fromY / /*(float) */
          (fromY - otherToY);
          otherToY = 0;
        } else if (otherToY >= this.image.getHeight()) {
          scale = (this.image.getHeight() - 1 - fromY) / /*(float) */
          (otherToY - fromY);
          otherToY = this.image.getHeight() - 1;
        }
        otherToX = /*(int) */
        Math.floor(fromX + (otherToX - fromX) * scale);
        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
        return result - 1;
      }
      /**
       * <p>This method traces a line from a point in the image, in the direction towards another point.
       * It begins in a black region, and keeps going until it finds white, then black, then white again.
       * It reports the distance from the start to this point.</p>
       *
       * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern
       * may be skewed or rotated.</p>
       */
      sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY) {
        const steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
          let temp = fromX;
          fromX = fromY;
          fromY = temp;
          temp = toX;
          toX = toY;
          toY = temp;
        }
        const dx = Math.abs(toX - fromX);
        const dy = Math.abs(toY - fromY);
        let error = -dx / 2;
        const xstep = fromX < toX ? 1 : -1;
        const ystep = fromY < toY ? 1 : -1;
        let state = 0;
        const xLimit = toX + xstep;
        for (let x = fromX, y = fromY; x !== xLimit; x += xstep) {
          const realX = steep ? y : x;
          const realY = steep ? x : y;
          if (state === 1 === this.image.get(realX, realY)) {
            if (state === 2) {
              return MathUtils.distance(x, y, fromX, fromY);
            }
            state++;
          }
          error += dy;
          if (error > 0) {
            if (y === toY) {
              break;
            }
            y += ystep;
            error -= dx;
          }
        }
        if (state === 2) {
          return MathUtils.distance(toX + xstep, toY, fromX, fromY);
        }
        return NaN;
      }
      /**
       * <p>Attempts to locate an alignment pattern in a limited region of the image, which is
       * guessed to contain it. This method uses {@link AlignmentPattern}.</p>
       *
       * @param overallEstModuleSize estimated module size so far
       * @param estAlignmentX x coordinate of center of area probably containing alignment pattern
       * @param estAlignmentY y coordinate of above
       * @param allowanceFactor number of pixels in all directions to search from the center
       * @return {@link AlignmentPattern} if found, or null otherwise
       * @throws NotFoundException if an unexpected error occurs during detection
       */
      findAlignmentInRegion(overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {
        const allowance = (
          /*(int) */
          Math.floor(allowanceFactor * overallEstModuleSize)
        );
        const alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
        const alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
          throw new NotFoundException("Alignment top exceeds estimated module size.");
        }
        const alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
        const alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
          throw new NotFoundException("Alignment bottom exceeds estimated module size.");
        }
        const alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
        return alignmentFinder.find();
      }
    }
    class QRCodeReader {
      constructor() {
        this.decoder = new Decoder$2();
      }
      getDecoder() {
        return this.decoder;
      }
      /**
       * Locates and decodes a QR code in an image.
       *
       * @return a representing: string the content encoded by the QR code
       * @throws NotFoundException if a QR code cannot be found
       * @throws FormatException if a QR code cannot be decoded
       * @throws ChecksumException if error correction fails
       */
      /*@Override*/
      // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {
      //   return this.decode(image, null)
      // }
      /*@Override*/
      decode(image, hints) {
        let decoderResult;
        let points;
        if (hints !== void 0 && hints !== null && void 0 !== hints.get(DecodeHintType$1.PURE_BARCODE)) {
          const bits = QRCodeReader.extractPureBits(image.getBlackMatrix());
          decoderResult = this.decoder.decodeBitMatrix(bits, hints);
          points = QRCodeReader.NO_POINTS;
        } else {
          const detectorResult = new Detector$2(image.getBlackMatrix()).detect(hints);
          decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
          points = detectorResult.getPoints();
        }
        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
          decoderResult.getOther().applyMirroredCorrection(points);
        }
        const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat$1.QR_CODE, void 0);
        const byteSegments = decoderResult.getByteSegments();
        if (byteSegments !== null) {
          result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
        }
        const ecLevel = decoderResult.getECLevel();
        if (ecLevel !== null) {
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        if (decoderResult.hasStructuredAppend()) {
          result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
          result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
        }
        return result;
      }
      /*@Override*/
      reset() {
      }
      /**
       * This method detects a code in a "pure" image -- that is, pure monochrome image
       * which contains only an unrotated, unskewed, image of a code, with some white border
       * around it. This is a specialized method that works exceptionally fast in this special
       * case.
       *
       * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)
       */
      static extractPureBits(image) {
        const leftTopBlack = image.getTopLeftOnBit();
        const rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack === null || rightBottomBlack === null) {
          throw new NotFoundException();
        }
        const moduleSize = this.moduleSize(leftTopBlack, image);
        let top = leftTopBlack[1];
        let bottom = rightBottomBlack[1];
        let left = leftTopBlack[0];
        let right = rightBottomBlack[0];
        if (left >= right || top >= bottom) {
          throw new NotFoundException();
        }
        if (bottom - top !== right - left) {
          right = left + (bottom - top);
          if (right >= image.getWidth()) {
            throw new NotFoundException();
          }
        }
        const matrixWidth = Math.round((right - left + 1) / moduleSize);
        const matrixHeight = Math.round((bottom - top + 1) / moduleSize);
        if (matrixWidth <= 0 || matrixHeight <= 0) {
          throw new NotFoundException();
        }
        if (matrixHeight !== matrixWidth) {
          throw new NotFoundException();
        }
        const nudge = (
          /*(int) */
          Math.floor(moduleSize / 2)
        );
        top += nudge;
        left += nudge;
        const nudgedTooFarRight = left + /*(int) */
        Math.floor((matrixWidth - 1) * moduleSize) - right;
        if (nudgedTooFarRight > 0) {
          if (nudgedTooFarRight > nudge) {
            throw new NotFoundException();
          }
          left -= nudgedTooFarRight;
        }
        const nudgedTooFarDown = top + /*(int) */
        Math.floor((matrixHeight - 1) * moduleSize) - bottom;
        if (nudgedTooFarDown > 0) {
          if (nudgedTooFarDown > nudge) {
            throw new NotFoundException();
          }
          top -= nudgedTooFarDown;
        }
        const bits = new BitMatrix(matrixWidth, matrixHeight);
        for (let y = 0; y < matrixHeight; y++) {
          const iOffset = top + /*(int) */
          Math.floor(y * moduleSize);
          for (let x = 0; x < matrixWidth; x++) {
            if (image.get(left + /*(int) */
            Math.floor(x * moduleSize), iOffset)) {
              bits.set(x, y);
            }
          }
        }
        return bits;
      }
      static moduleSize(leftTopBlack, image) {
        const height = image.getHeight();
        const width = image.getWidth();
        let x = leftTopBlack[0];
        let y = leftTopBlack[1];
        let inBlack = true;
        let transitions = 0;
        while (x < width && y < height) {
          if (inBlack !== image.get(x, y)) {
            if (++transitions === 5) {
              break;
            }
            inBlack = !inBlack;
          }
          x++;
          y++;
        }
        if (x === width || y === height) {
          throw new NotFoundException();
        }
        return (x - leftTopBlack[0]) / 7;
      }
    }
    QRCodeReader.NO_POINTS = new Array();
    class PDF417Common {
      PDF417Common() {
      }
      /**
       * @param moduleBitCount values to sum
       * @return sum of values
       * @deprecated call {@link MathUtils#sum(int[])}
       */
      // @Deprecated
      static getBitCountSum(moduleBitCount) {
        return MathUtils.sum(moduleBitCount);
      }
      static toIntArray(list) {
        if (list == null || !list.length) {
          return PDF417Common.EMPTY_INT_ARRAY;
        }
        const result = new Int32Array(list.length);
        let i = 0;
        for (const integer of list) {
          result[i++] = integer;
        }
        return result;
      }
      /**
       * @param symbol encoded symbol to translate to a codeword
       * @return the codeword corresponding to the symbol.
       */
      static getCodeword(symbol) {
        const i = Arrays.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 262143);
        if (i < 0) {
          return -1;
        }
        return (PDF417Common.CODEWORD_TABLE[i] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;
      }
    }
    PDF417Common.NUMBER_OF_CODEWORDS = 929;
    PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;
    PDF417Common.MIN_ROWS_IN_BARCODE = 3;
    PDF417Common.MAX_ROWS_IN_BARCODE = 90;
    PDF417Common.MODULES_IN_CODEWORD = 17;
    PDF417Common.MODULES_IN_STOP_PATTERN = 18;
    PDF417Common.BARS_IN_MODULE = 8;
    PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);
    PDF417Common.SYMBOL_TABLE = Int32Array.from([
      66142,
      66170,
      66206,
      66236,
      66290,
      66292,
      66350,
      66382,
      66396,
      66454,
      66470,
      66476,
      66594,
      66600,
      66614,
      66626,
      66628,
      66632,
      66640,
      66654,
      66662,
      66668,
      66682,
      66690,
      66718,
      66720,
      66748,
      66758,
      66776,
      66798,
      66802,
      66804,
      66820,
      66824,
      66832,
      66846,
      66848,
      66876,
      66880,
      66936,
      66950,
      66956,
      66968,
      66992,
      67006,
      67022,
      67036,
      67042,
      67044,
      67048,
      67062,
      67118,
      67150,
      67164,
      67214,
      67228,
      67256,
      67294,
      67322,
      67350,
      67366,
      67372,
      67398,
      67404,
      67416,
      67438,
      67474,
      67476,
      67490,
      67492,
      67496,
      67510,
      67618,
      67624,
      67650,
      67656,
      67664,
      67678,
      67686,
      67692,
      67706,
      67714,
      67716,
      67728,
      67742,
      67744,
      67772,
      67782,
      67788,
      67800,
      67822,
      67826,
      67828,
      67842,
      67848,
      67870,
      67872,
      67900,
      67904,
      67960,
      67974,
      67992,
      68016,
      68030,
      68046,
      68060,
      68066,
      68068,
      68072,
      68086,
      68104,
      68112,
      68126,
      68128,
      68156,
      68160,
      68216,
      68336,
      68358,
      68364,
      68376,
      68400,
      68414,
      68448,
      68476,
      68494,
      68508,
      68536,
      68546,
      68548,
      68552,
      68560,
      68574,
      68582,
      68588,
      68654,
      68686,
      68700,
      68706,
      68708,
      68712,
      68726,
      68750,
      68764,
      68792,
      68802,
      68804,
      68808,
      68816,
      68830,
      68838,
      68844,
      68858,
      68878,
      68892,
      68920,
      68976,
      68990,
      68994,
      68996,
      69e3,
      69008,
      69022,
      69024,
      69052,
      69062,
      69068,
      69080,
      69102,
      69106,
      69108,
      69142,
      69158,
      69164,
      69190,
      69208,
      69230,
      69254,
      69260,
      69272,
      69296,
      69310,
      69326,
      69340,
      69386,
      69394,
      69396,
      69410,
      69416,
      69430,
      69442,
      69444,
      69448,
      69456,
      69470,
      69478,
      69484,
      69554,
      69556,
      69666,
      69672,
      69698,
      69704,
      69712,
      69726,
      69754,
      69762,
      69764,
      69776,
      69790,
      69792,
      69820,
      69830,
      69836,
      69848,
      69870,
      69874,
      69876,
      69890,
      69918,
      69920,
      69948,
      69952,
      70008,
      70022,
      70040,
      70064,
      70078,
      70094,
      70108,
      70114,
      70116,
      70120,
      70134,
      70152,
      70174,
      70176,
      70264,
      70384,
      70412,
      70448,
      70462,
      70496,
      70524,
      70542,
      70556,
      70584,
      70594,
      70600,
      70608,
      70622,
      70630,
      70636,
      70664,
      70672,
      70686,
      70688,
      70716,
      70720,
      70776,
      70896,
      71136,
      71180,
      71192,
      71216,
      71230,
      71264,
      71292,
      71360,
      71416,
      71452,
      71480,
      71536,
      71550,
      71554,
      71556,
      71560,
      71568,
      71582,
      71584,
      71612,
      71622,
      71628,
      71640,
      71662,
      71726,
      71732,
      71758,
      71772,
      71778,
      71780,
      71784,
      71798,
      71822,
      71836,
      71864,
      71874,
      71880,
      71888,
      71902,
      71910,
      71916,
      71930,
      71950,
      71964,
      71992,
      72048,
      72062,
      72066,
      72068,
      72080,
      72094,
      72096,
      72124,
      72134,
      72140,
      72152,
      72174,
      72178,
      72180,
      72206,
      72220,
      72248,
      72304,
      72318,
      72416,
      72444,
      72456,
      72464,
      72478,
      72480,
      72508,
      72512,
      72568,
      72588,
      72600,
      72624,
      72638,
      72654,
      72668,
      72674,
      72676,
      72680,
      72694,
      72726,
      72742,
      72748,
      72774,
      72780,
      72792,
      72814,
      72838,
      72856,
      72880,
      72894,
      72910,
      72924,
      72930,
      72932,
      72936,
      72950,
      72966,
      72972,
      72984,
      73008,
      73022,
      73056,
      73084,
      73102,
      73116,
      73144,
      73156,
      73160,
      73168,
      73182,
      73190,
      73196,
      73210,
      73226,
      73234,
      73236,
      73250,
      73252,
      73256,
      73270,
      73282,
      73284,
      73296,
      73310,
      73318,
      73324,
      73346,
      73348,
      73352,
      73360,
      73374,
      73376,
      73404,
      73414,
      73420,
      73432,
      73454,
      73498,
      73518,
      73522,
      73524,
      73550,
      73564,
      73570,
      73572,
      73576,
      73590,
      73800,
      73822,
      73858,
      73860,
      73872,
      73886,
      73888,
      73916,
      73944,
      73970,
      73972,
      73992,
      74014,
      74016,
      74044,
      74048,
      74104,
      74118,
      74136,
      74160,
      74174,
      74210,
      74212,
      74216,
      74230,
      74244,
      74256,
      74270,
      74272,
      74360,
      74480,
      74502,
      74508,
      74544,
      74558,
      74592,
      74620,
      74638,
      74652,
      74680,
      74690,
      74696,
      74704,
      74726,
      74732,
      74782,
      74784,
      74812,
      74992,
      75232,
      75288,
      75326,
      75360,
      75388,
      75456,
      75512,
      75576,
      75632,
      75646,
      75650,
      75652,
      75664,
      75678,
      75680,
      75708,
      75718,
      75724,
      75736,
      75758,
      75808,
      75836,
      75840,
      75896,
      76016,
      76256,
      76736,
      76824,
      76848,
      76862,
      76896,
      76924,
      76992,
      77048,
      77296,
      77340,
      77368,
      77424,
      77438,
      77536,
      77564,
      77572,
      77576,
      77584,
      77600,
      77628,
      77632,
      77688,
      77702,
      77708,
      77720,
      77744,
      77758,
      77774,
      77788,
      77870,
      77902,
      77916,
      77922,
      77928,
      77966,
      77980,
      78008,
      78018,
      78024,
      78032,
      78046,
      78060,
      78074,
      78094,
      78136,
      78192,
      78206,
      78210,
      78212,
      78224,
      78238,
      78240,
      78268,
      78278,
      78284,
      78296,
      78322,
      78324,
      78350,
      78364,
      78448,
      78462,
      78560,
      78588,
      78600,
      78622,
      78624,
      78652,
      78656,
      78712,
      78726,
      78744,
      78768,
      78782,
      78798,
      78812,
      78818,
      78820,
      78824,
      78838,
      78862,
      78876,
      78904,
      78960,
      78974,
      79072,
      79100,
      79296,
      79352,
      79368,
      79376,
      79390,
      79392,
      79420,
      79424,
      79480,
      79600,
      79628,
      79640,
      79664,
      79678,
      79712,
      79740,
      79772,
      79800,
      79810,
      79812,
      79816,
      79824,
      79838,
      79846,
      79852,
      79894,
      79910,
      79916,
      79942,
      79948,
      79960,
      79982,
      79988,
      80006,
      80024,
      80048,
      80062,
      80078,
      80092,
      80098,
      80100,
      80104,
      80134,
      80140,
      80176,
      80190,
      80224,
      80252,
      80270,
      80284,
      80312,
      80328,
      80336,
      80350,
      80358,
      80364,
      80378,
      80390,
      80396,
      80408,
      80432,
      80446,
      80480,
      80508,
      80576,
      80632,
      80654,
      80668,
      80696,
      80752,
      80766,
      80776,
      80784,
      80798,
      80800,
      80828,
      80844,
      80856,
      80878,
      80882,
      80884,
      80914,
      80916,
      80930,
      80932,
      80936,
      80950,
      80962,
      80968,
      80976,
      80990,
      80998,
      81004,
      81026,
      81028,
      81040,
      81054,
      81056,
      81084,
      81094,
      81100,
      81112,
      81134,
      81154,
      81156,
      81160,
      81168,
      81182,
      81184,
      81212,
      81216,
      81272,
      81286,
      81292,
      81304,
      81328,
      81342,
      81358,
      81372,
      81380,
      81384,
      81398,
      81434,
      81454,
      81458,
      81460,
      81486,
      81500,
      81506,
      81508,
      81512,
      81526,
      81550,
      81564,
      81592,
      81602,
      81604,
      81608,
      81616,
      81630,
      81638,
      81644,
      81702,
      81708,
      81722,
      81734,
      81740,
      81752,
      81774,
      81778,
      81780,
      82050,
      82078,
      82080,
      82108,
      82180,
      82184,
      82192,
      82206,
      82208,
      82236,
      82240,
      82296,
      82316,
      82328,
      82352,
      82366,
      82402,
      82404,
      82408,
      82440,
      82448,
      82462,
      82464,
      82492,
      82496,
      82552,
      82672,
      82694,
      82700,
      82712,
      82736,
      82750,
      82784,
      82812,
      82830,
      82882,
      82884,
      82888,
      82896,
      82918,
      82924,
      82952,
      82960,
      82974,
      82976,
      83004,
      83008,
      83064,
      83184,
      83424,
      83468,
      83480,
      83504,
      83518,
      83552,
      83580,
      83648,
      83704,
      83740,
      83768,
      83824,
      83838,
      83842,
      83844,
      83848,
      83856,
      83872,
      83900,
      83910,
      83916,
      83928,
      83950,
      83984,
      84e3,
      84028,
      84032,
      84088,
      84208,
      84448,
      84928,
      85040,
      85054,
      85088,
      85116,
      85184,
      85240,
      85488,
      85560,
      85616,
      85630,
      85728,
      85756,
      85764,
      85768,
      85776,
      85790,
      85792,
      85820,
      85824,
      85880,
      85894,
      85900,
      85912,
      85936,
      85966,
      85980,
      86048,
      86080,
      86136,
      86256,
      86496,
      86976,
      88160,
      88188,
      88256,
      88312,
      88560,
      89056,
      89200,
      89214,
      89312,
      89340,
      89536,
      89592,
      89608,
      89616,
      89632,
      89664,
      89720,
      89840,
      89868,
      89880,
      89904,
      89952,
      89980,
      89998,
      90012,
      90040,
      90190,
      90204,
      90254,
      90268,
      90296,
      90306,
      90308,
      90312,
      90334,
      90382,
      90396,
      90424,
      90480,
      90494,
      90500,
      90504,
      90512,
      90526,
      90528,
      90556,
      90566,
      90572,
      90584,
      90610,
      90612,
      90638,
      90652,
      90680,
      90736,
      90750,
      90848,
      90876,
      90884,
      90888,
      90896,
      90910,
      90912,
      90940,
      90944,
      91e3,
      91014,
      91020,
      91032,
      91056,
      91070,
      91086,
      91100,
      91106,
      91108,
      91112,
      91126,
      91150,
      91164,
      91192,
      91248,
      91262,
      91360,
      91388,
      91584,
      91640,
      91664,
      91678,
      91680,
      91708,
      91712,
      91768,
      91888,
      91928,
      91952,
      91966,
      92e3,
      92028,
      92046,
      92060,
      92088,
      92098,
      92100,
      92104,
      92112,
      92126,
      92134,
      92140,
      92188,
      92216,
      92272,
      92384,
      92412,
      92608,
      92664,
      93168,
      93200,
      93214,
      93216,
      93244,
      93248,
      93304,
      93424,
      93664,
      93720,
      93744,
      93758,
      93792,
      93820,
      93888,
      93944,
      93980,
      94008,
      94064,
      94078,
      94084,
      94088,
      94096,
      94110,
      94112,
      94140,
      94150,
      94156,
      94168,
      94246,
      94252,
      94278,
      94284,
      94296,
      94318,
      94342,
      94348,
      94360,
      94384,
      94398,
      94414,
      94428,
      94440,
      94470,
      94476,
      94488,
      94512,
      94526,
      94560,
      94588,
      94606,
      94620,
      94648,
      94658,
      94660,
      94664,
      94672,
      94686,
      94694,
      94700,
      94714,
      94726,
      94732,
      94744,
      94768,
      94782,
      94816,
      94844,
      94912,
      94968,
      94990,
      95004,
      95032,
      95088,
      95102,
      95112,
      95120,
      95134,
      95136,
      95164,
      95180,
      95192,
      95214,
      95218,
      95220,
      95244,
      95256,
      95280,
      95294,
      95328,
      95356,
      95424,
      95480,
      95728,
      95758,
      95772,
      95800,
      95856,
      95870,
      95968,
      95996,
      96008,
      96016,
      96030,
      96032,
      96060,
      96064,
      96120,
      96152,
      96176,
      96190,
      96220,
      96226,
      96228,
      96232,
      96290,
      96292,
      96296,
      96310,
      96322,
      96324,
      96328,
      96336,
      96350,
      96358,
      96364,
      96386,
      96388,
      96392,
      96400,
      96414,
      96416,
      96444,
      96454,
      96460,
      96472,
      96494,
      96498,
      96500,
      96514,
      96516,
      96520,
      96528,
      96542,
      96544,
      96572,
      96576,
      96632,
      96646,
      96652,
      96664,
      96688,
      96702,
      96718,
      96732,
      96738,
      96740,
      96744,
      96758,
      96772,
      96776,
      96784,
      96798,
      96800,
      96828,
      96832,
      96888,
      97008,
      97030,
      97036,
      97048,
      97072,
      97086,
      97120,
      97148,
      97166,
      97180,
      97208,
      97220,
      97224,
      97232,
      97246,
      97254,
      97260,
      97326,
      97330,
      97332,
      97358,
      97372,
      97378,
      97380,
      97384,
      97398,
      97422,
      97436,
      97464,
      97474,
      97476,
      97480,
      97488,
      97502,
      97510,
      97516,
      97550,
      97564,
      97592,
      97648,
      97666,
      97668,
      97672,
      97680,
      97694,
      97696,
      97724,
      97734,
      97740,
      97752,
      97774,
      97830,
      97836,
      97850,
      97862,
      97868,
      97880,
      97902,
      97906,
      97908,
      97926,
      97932,
      97944,
      97968,
      97998,
      98012,
      98018,
      98020,
      98024,
      98038,
      98618,
      98674,
      98676,
      98838,
      98854,
      98874,
      98892,
      98904,
      98926,
      98930,
      98932,
      98968,
      99006,
      99042,
      99044,
      99048,
      99062,
      99166,
      99194,
      99246,
      99286,
      99350,
      99366,
      99372,
      99386,
      99398,
      99416,
      99438,
      99442,
      99444,
      99462,
      99504,
      99518,
      99534,
      99548,
      99554,
      99556,
      99560,
      99574,
      99590,
      99596,
      99608,
      99632,
      99646,
      99680,
      99708,
      99726,
      99740,
      99768,
      99778,
      99780,
      99784,
      99792,
      99806,
      99814,
      99820,
      99834,
      99858,
      99860,
      99874,
      99880,
      99894,
      99906,
      99920,
      99934,
      99962,
      99970,
      99972,
      99976,
      99984,
      99998,
      1e5,
      100028,
      100038,
      100044,
      100056,
      100078,
      100082,
      100084,
      100142,
      100174,
      100188,
      100246,
      100262,
      100268,
      100306,
      100308,
      100390,
      100396,
      100410,
      100422,
      100428,
      100440,
      100462,
      100466,
      100468,
      100486,
      100504,
      100528,
      100542,
      100558,
      100572,
      100578,
      100580,
      100584,
      100598,
      100620,
      100656,
      100670,
      100704,
      100732,
      100750,
      100792,
      100802,
      100808,
      100816,
      100830,
      100838,
      100844,
      100858,
      100888,
      100912,
      100926,
      100960,
      100988,
      101056,
      101112,
      101148,
      101176,
      101232,
      101246,
      101250,
      101252,
      101256,
      101264,
      101278,
      101280,
      101308,
      101318,
      101324,
      101336,
      101358,
      101362,
      101364,
      101410,
      101412,
      101416,
      101430,
      101442,
      101448,
      101456,
      101470,
      101478,
      101498,
      101506,
      101508,
      101520,
      101534,
      101536,
      101564,
      101580,
      101618,
      101620,
      101636,
      101640,
      101648,
      101662,
      101664,
      101692,
      101696,
      101752,
      101766,
      101784,
      101838,
      101858,
      101860,
      101864,
      101934,
      101938,
      101940,
      101966,
      101980,
      101986,
      101988,
      101992,
      102030,
      102044,
      102072,
      102082,
      102084,
      102088,
      102096,
      102138,
      102166,
      102182,
      102188,
      102214,
      102220,
      102232,
      102254,
      102282,
      102290,
      102292,
      102306,
      102308,
      102312,
      102326,
      102444,
      102458,
      102470,
      102476,
      102488,
      102514,
      102516,
      102534,
      102552,
      102576,
      102590,
      102606,
      102620,
      102626,
      102632,
      102646,
      102662,
      102668,
      102704,
      102718,
      102752,
      102780,
      102798,
      102812,
      102840,
      102850,
      102856,
      102864,
      102878,
      102886,
      102892,
      102906,
      102936,
      102974,
      103008,
      103036,
      103104,
      103160,
      103224,
      103280,
      103294,
      103298,
      103300,
      103312,
      103326,
      103328,
      103356,
      103366,
      103372,
      103384,
      103406,
      103410,
      103412,
      103472,
      103486,
      103520,
      103548,
      103616,
      103672,
      103920,
      103992,
      104048,
      104062,
      104160,
      104188,
      104194,
      104196,
      104200,
      104208,
      104224,
      104252,
      104256,
      104312,
      104326,
      104332,
      104344,
      104368,
      104382,
      104398,
      104412,
      104418,
      104420,
      104424,
      104482,
      104484,
      104514,
      104520,
      104528,
      104542,
      104550,
      104570,
      104578,
      104580,
      104592,
      104606,
      104608,
      104636,
      104652,
      104690,
      104692,
      104706,
      104712,
      104734,
      104736,
      104764,
      104768,
      104824,
      104838,
      104856,
      104910,
      104930,
      104932,
      104936,
      104968,
      104976,
      104990,
      104992,
      105020,
      105024,
      105080,
      105200,
      105240,
      105278,
      105312,
      105372,
      105410,
      105412,
      105416,
      105424,
      105446,
      105518,
      105524,
      105550,
      105564,
      105570,
      105572,
      105576,
      105614,
      105628,
      105656,
      105666,
      105672,
      105680,
      105702,
      105722,
      105742,
      105756,
      105784,
      105840,
      105854,
      105858,
      105860,
      105864,
      105872,
      105888,
      105932,
      105970,
      105972,
      106006,
      106022,
      106028,
      106054,
      106060,
      106072,
      106100,
      106118,
      106124,
      106136,
      106160,
      106174,
      106190,
      106210,
      106212,
      106216,
      106250,
      106258,
      106260,
      106274,
      106276,
      106280,
      106306,
      106308,
      106312,
      106320,
      106334,
      106348,
      106394,
      106414,
      106418,
      106420,
      106566,
      106572,
      106610,
      106612,
      106630,
      106636,
      106648,
      106672,
      106686,
      106722,
      106724,
      106728,
      106742,
      106758,
      106764,
      106776,
      106800,
      106814,
      106848,
      106876,
      106894,
      106908,
      106936,
      106946,
      106948,
      106952,
      106960,
      106974,
      106982,
      106988,
      107032,
      107056,
      107070,
      107104,
      107132,
      107200,
      107256,
      107292,
      107320,
      107376,
      107390,
      107394,
      107396,
      107400,
      107408,
      107422,
      107424,
      107452,
      107462,
      107468,
      107480,
      107502,
      107506,
      107508,
      107544,
      107568,
      107582,
      107616,
      107644,
      107712,
      107768,
      108016,
      108060,
      108088,
      108144,
      108158,
      108256,
      108284,
      108290,
      108292,
      108296,
      108304,
      108318,
      108320,
      108348,
      108352,
      108408,
      108422,
      108428,
      108440,
      108464,
      108478,
      108494,
      108508,
      108514,
      108516,
      108520,
      108592,
      108640,
      108668,
      108736,
      108792,
      109040,
      109536,
      109680,
      109694,
      109792,
      109820,
      110016,
      110072,
      110084,
      110088,
      110096,
      110112,
      110140,
      110144,
      110200,
      110320,
      110342,
      110348,
      110360,
      110384,
      110398,
      110432,
      110460,
      110478,
      110492,
      110520,
      110532,
      110536,
      110544,
      110558,
      110658,
      110686,
      110714,
      110722,
      110724,
      110728,
      110736,
      110750,
      110752,
      110780,
      110796,
      110834,
      110836,
      110850,
      110852,
      110856,
      110864,
      110878,
      110880,
      110908,
      110912,
      110968,
      110982,
      111e3,
      111054,
      111074,
      111076,
      111080,
      111108,
      111112,
      111120,
      111134,
      111136,
      111164,
      111168,
      111224,
      111344,
      111372,
      111422,
      111456,
      111516,
      111554,
      111556,
      111560,
      111568,
      111590,
      111632,
      111646,
      111648,
      111676,
      111680,
      111736,
      111856,
      112096,
      112152,
      112224,
      112252,
      112320,
      112440,
      112514,
      112516,
      112520,
      112528,
      112542,
      112544,
      112588,
      112686,
      112718,
      112732,
      112782,
      112796,
      112824,
      112834,
      112836,
      112840,
      112848,
      112870,
      112890,
      112910,
      112924,
      112952,
      113008,
      113022,
      113026,
      113028,
      113032,
      113040,
      113054,
      113056,
      113100,
      113138,
      113140,
      113166,
      113180,
      113208,
      113264,
      113278,
      113376,
      113404,
      113416,
      113424,
      113440,
      113468,
      113472,
      113560,
      113614,
      113634,
      113636,
      113640,
      113686,
      113702,
      113708,
      113734,
      113740,
      113752,
      113778,
      113780,
      113798,
      113804,
      113816,
      113840,
      113854,
      113870,
      113890,
      113892,
      113896,
      113926,
      113932,
      113944,
      113968,
      113982,
      114016,
      114044,
      114076,
      114114,
      114116,
      114120,
      114128,
      114150,
      114170,
      114194,
      114196,
      114210,
      114212,
      114216,
      114242,
      114244,
      114248,
      114256,
      114270,
      114278,
      114306,
      114308,
      114312,
      114320,
      114334,
      114336,
      114364,
      114380,
      114420,
      114458,
      114478,
      114482,
      114484,
      114510,
      114524,
      114530,
      114532,
      114536,
      114842,
      114866,
      114868,
      114970,
      114994,
      114996,
      115042,
      115044,
      115048,
      115062,
      115130,
      115226,
      115250,
      115252,
      115278,
      115292,
      115298,
      115300,
      115304,
      115318,
      115342,
      115394,
      115396,
      115400,
      115408,
      115422,
      115430,
      115436,
      115450,
      115478,
      115494,
      115514,
      115526,
      115532,
      115570,
      115572,
      115738,
      115758,
      115762,
      115764,
      115790,
      115804,
      115810,
      115812,
      115816,
      115830,
      115854,
      115868,
      115896,
      115906,
      115912,
      115920,
      115934,
      115942,
      115948,
      115962,
      115996,
      116024,
      116080,
      116094,
      116098,
      116100,
      116104,
      116112,
      116126,
      116128,
      116156,
      116166,
      116172,
      116184,
      116206,
      116210,
      116212,
      116246,
      116262,
      116268,
      116282,
      116294,
      116300,
      116312,
      116334,
      116338,
      116340,
      116358,
      116364,
      116376,
      116400,
      116414,
      116430,
      116444,
      116450,
      116452,
      116456,
      116498,
      116500,
      116514,
      116520,
      116534,
      116546,
      116548,
      116552,
      116560,
      116574,
      116582,
      116588,
      116602,
      116654,
      116694,
      116714,
      116762,
      116782,
      116786,
      116788,
      116814,
      116828,
      116834,
      116836,
      116840,
      116854,
      116878,
      116892,
      116920,
      116930,
      116936,
      116944,
      116958,
      116966,
      116972,
      116986,
      117006,
      117048,
      117104,
      117118,
      117122,
      117124,
      117136,
      117150,
      117152,
      117180,
      117190,
      117196,
      117208,
      117230,
      117234,
      117236,
      117304,
      117360,
      117374,
      117472,
      117500,
      117506,
      117508,
      117512,
      117520,
      117536,
      117564,
      117568,
      117624,
      117638,
      117644,
      117656,
      117680,
      117694,
      117710,
      117724,
      117730,
      117732,
      117736,
      117750,
      117782,
      117798,
      117804,
      117818,
      117830,
      117848,
      117874,
      117876,
      117894,
      117936,
      117950,
      117966,
      117986,
      117988,
      117992,
      118022,
      118028,
      118040,
      118064,
      118078,
      118112,
      118140,
      118172,
      118210,
      118212,
      118216,
      118224,
      118238,
      118246,
      118266,
      118306,
      118312,
      118338,
      118352,
      118366,
      118374,
      118394,
      118402,
      118404,
      118408,
      118416,
      118430,
      118432,
      118460,
      118476,
      118514,
      118516,
      118574,
      118578,
      118580,
      118606,
      118620,
      118626,
      118628,
      118632,
      118678,
      118694,
      118700,
      118730,
      118738,
      118740,
      118830,
      118834,
      118836,
      118862,
      118876,
      118882,
      118884,
      118888,
      118902,
      118926,
      118940,
      118968,
      118978,
      118980,
      118984,
      118992,
      119006,
      119014,
      119020,
      119034,
      119068,
      119096,
      119152,
      119166,
      119170,
      119172,
      119176,
      119184,
      119198,
      119200,
      119228,
      119238,
      119244,
      119256,
      119278,
      119282,
      119284,
      119324,
      119352,
      119408,
      119422,
      119520,
      119548,
      119554,
      119556,
      119560,
      119568,
      119582,
      119584,
      119612,
      119616,
      119672,
      119686,
      119692,
      119704,
      119728,
      119742,
      119758,
      119772,
      119778,
      119780,
      119784,
      119798,
      119920,
      119934,
      120032,
      120060,
      120256,
      120312,
      120324,
      120328,
      120336,
      120352,
      120384,
      120440,
      120560,
      120582,
      120588,
      120600,
      120624,
      120638,
      120672,
      120700,
      120718,
      120732,
      120760,
      120770,
      120772,
      120776,
      120784,
      120798,
      120806,
      120812,
      120870,
      120876,
      120890,
      120902,
      120908,
      120920,
      120946,
      120948,
      120966,
      120972,
      120984,
      121008,
      121022,
      121038,
      121058,
      121060,
      121064,
      121078,
      121100,
      121112,
      121136,
      121150,
      121184,
      121212,
      121244,
      121282,
      121284,
      121288,
      121296,
      121318,
      121338,
      121356,
      121368,
      121392,
      121406,
      121440,
      121468,
      121536,
      121592,
      121656,
      121730,
      121732,
      121736,
      121744,
      121758,
      121760,
      121804,
      121842,
      121844,
      121890,
      121922,
      121924,
      121928,
      121936,
      121950,
      121958,
      121978,
      121986,
      121988,
      121992,
      122e3,
      122014,
      122016,
      122044,
      122060,
      122098,
      122100,
      122116,
      122120,
      122128,
      122142,
      122144,
      122172,
      122176,
      122232,
      122246,
      122264,
      122318,
      122338,
      122340,
      122344,
      122414,
      122418,
      122420,
      122446,
      122460,
      122466,
      122468,
      122472,
      122510,
      122524,
      122552,
      122562,
      122564,
      122568,
      122576,
      122598,
      122618,
      122646,
      122662,
      122668,
      122694,
      122700,
      122712,
      122738,
      122740,
      122762,
      122770,
      122772,
      122786,
      122788,
      122792,
      123018,
      123026,
      123028,
      123042,
      123044,
      123048,
      123062,
      123098,
      123146,
      123154,
      123156,
      123170,
      123172,
      123176,
      123190,
      123202,
      123204,
      123208,
      123216,
      123238,
      123244,
      123258,
      123290,
      123314,
      123316,
      123402,
      123410,
      123412,
      123426,
      123428,
      123432,
      123446,
      123458,
      123464,
      123472,
      123486,
      123494,
      123500,
      123514,
      123522,
      123524,
      123528,
      123536,
      123552,
      123580,
      123590,
      123596,
      123608,
      123630,
      123634,
      123636,
      123674,
      123698,
      123700,
      123740,
      123746,
      123748,
      123752,
      123834,
      123914,
      123922,
      123924,
      123938,
      123944,
      123958,
      123970,
      123976,
      123984,
      123998,
      124006,
      124012,
      124026,
      124034,
      124036,
      124048,
      124062,
      124064,
      124092,
      124102,
      124108,
      124120,
      124142,
      124146,
      124148,
      124162,
      124164,
      124168,
      124176,
      124190,
      124192,
      124220,
      124224,
      124280,
      124294,
      124300,
      124312,
      124336,
      124350,
      124366,
      124380,
      124386,
      124388,
      124392,
      124406,
      124442,
      124462,
      124466,
      124468,
      124494,
      124508,
      124514,
      124520,
      124558,
      124572,
      124600,
      124610,
      124612,
      124616,
      124624,
      124646,
      124666,
      124694,
      124710,
      124716,
      124730,
      124742,
      124748,
      124760,
      124786,
      124788,
      124818,
      124820,
      124834,
      124836,
      124840,
      124854,
      124946,
      124948,
      124962,
      124964,
      124968,
      124982,
      124994,
      124996,
      125e3,
      125008,
      125022,
      125030,
      125036,
      125050,
      125058,
      125060,
      125064,
      125072,
      125086,
      125088,
      125116,
      125126,
      125132,
      125144,
      125166,
      125170,
      125172,
      125186,
      125188,
      125192,
      125200,
      125216,
      125244,
      125248,
      125304,
      125318,
      125324,
      125336,
      125360,
      125374,
      125390,
      125404,
      125410,
      125412,
      125416,
      125430,
      125444,
      125448,
      125456,
      125472,
      125504,
      125560,
      125680,
      125702,
      125708,
      125720,
      125744,
      125758,
      125792,
      125820,
      125838,
      125852,
      125880,
      125890,
      125892,
      125896,
      125904,
      125918,
      125926,
      125932,
      125978,
      125998,
      126002,
      126004,
      126030,
      126044,
      126050,
      126052,
      126056,
      126094,
      126108,
      126136,
      126146,
      126148,
      126152,
      126160,
      126182,
      126202,
      126222,
      126236,
      126264,
      126320,
      126334,
      126338,
      126340,
      126344,
      126352,
      126366,
      126368,
      126412,
      126450,
      126452,
      126486,
      126502,
      126508,
      126522,
      126534,
      126540,
      126552,
      126574,
      126578,
      126580,
      126598,
      126604,
      126616,
      126640,
      126654,
      126670,
      126684,
      126690,
      126692,
      126696,
      126738,
      126754,
      126756,
      126760,
      126774,
      126786,
      126788,
      126792,
      126800,
      126814,
      126822,
      126828,
      126842,
      126894,
      126898,
      126900,
      126934,
      127126,
      127142,
      127148,
      127162,
      127178,
      127186,
      127188,
      127254,
      127270,
      127276,
      127290,
      127302,
      127308,
      127320,
      127342,
      127346,
      127348,
      127370,
      127378,
      127380,
      127394,
      127396,
      127400,
      127450,
      127510,
      127526,
      127532,
      127546,
      127558,
      127576,
      127598,
      127602,
      127604,
      127622,
      127628,
      127640,
      127664,
      127678,
      127694,
      127708,
      127714,
      127716,
      127720,
      127734,
      127754,
      127762,
      127764,
      127778,
      127784,
      127810,
      127812,
      127816,
      127824,
      127838,
      127846,
      127866,
      127898,
      127918,
      127922,
      127924,
      128022,
      128038,
      128044,
      128058,
      128070,
      128076,
      128088,
      128110,
      128114,
      128116,
      128134,
      128140,
      128152,
      128176,
      128190,
      128206,
      128220,
      128226,
      128228,
      128232,
      128246,
      128262,
      128268,
      128280,
      128304,
      128318,
      128352,
      128380,
      128398,
      128412,
      128440,
      128450,
      128452,
      128456,
      128464,
      128478,
      128486,
      128492,
      128506,
      128522,
      128530,
      128532,
      128546,
      128548,
      128552,
      128566,
      128578,
      128580,
      128584,
      128592,
      128606,
      128614,
      128634,
      128642,
      128644,
      128648,
      128656,
      128670,
      128672,
      128700,
      128716,
      128754,
      128756,
      128794,
      128814,
      128818,
      128820,
      128846,
      128860,
      128866,
      128868,
      128872,
      128886,
      128918,
      128934,
      128940,
      128954,
      128978,
      128980,
      129178,
      129198,
      129202,
      129204,
      129238,
      129258,
      129306,
      129326,
      129330,
      129332,
      129358,
      129372,
      129378,
      129380,
      129384,
      129398,
      129430,
      129446,
      129452,
      129466,
      129482,
      129490,
      129492,
      129562,
      129582,
      129586,
      129588,
      129614,
      129628,
      129634,
      129636,
      129640,
      129654,
      129678,
      129692,
      129720,
      129730,
      129732,
      129736,
      129744,
      129758,
      129766,
      129772,
      129814,
      129830,
      129836,
      129850,
      129862,
      129868,
      129880,
      129902,
      129906,
      129908,
      129930,
      129938,
      129940,
      129954,
      129956,
      129960,
      129974,
      130010
    ]);
    PDF417Common.CODEWORD_TABLE = Int32Array.from([
      2627,
      1819,
      2622,
      2621,
      1813,
      1812,
      2729,
      2724,
      2723,
      2779,
      2774,
      2773,
      902,
      896,
      908,
      868,
      865,
      861,
      859,
      2511,
      873,
      871,
      1780,
      835,
      2493,
      825,
      2491,
      842,
      837,
      844,
      1764,
      1762,
      811,
      810,
      809,
      2483,
      807,
      2482,
      806,
      2480,
      815,
      814,
      813,
      812,
      2484,
      817,
      816,
      1745,
      1744,
      1742,
      1746,
      2655,
      2637,
      2635,
      2626,
      2625,
      2623,
      2628,
      1820,
      2752,
      2739,
      2737,
      2728,
      2727,
      2725,
      2730,
      2785,
      2783,
      2778,
      2777,
      2775,
      2780,
      787,
      781,
      747,
      739,
      736,
      2413,
      754,
      752,
      1719,
      692,
      689,
      681,
      2371,
      678,
      2369,
      700,
      697,
      694,
      703,
      1688,
      1686,
      642,
      638,
      2343,
      631,
      2341,
      627,
      2338,
      651,
      646,
      643,
      2345,
      654,
      652,
      1652,
      1650,
      1647,
      1654,
      601,
      599,
      2322,
      596,
      2321,
      594,
      2319,
      2317,
      611,
      610,
      608,
      606,
      2324,
      603,
      2323,
      615,
      614,
      612,
      1617,
      1616,
      1614,
      1612,
      616,
      1619,
      1618,
      2575,
      2538,
      2536,
      905,
      901,
      898,
      909,
      2509,
      2507,
      2504,
      870,
      867,
      864,
      860,
      2512,
      875,
      872,
      1781,
      2490,
      2489,
      2487,
      2485,
      1748,
      836,
      834,
      832,
      830,
      2494,
      827,
      2492,
      843,
      841,
      839,
      845,
      1765,
      1763,
      2701,
      2676,
      2674,
      2653,
      2648,
      2656,
      2634,
      2633,
      2631,
      2629,
      1821,
      2638,
      2636,
      2770,
      2763,
      2761,
      2750,
      2745,
      2753,
      2736,
      2735,
      2733,
      2731,
      1848,
      2740,
      2738,
      2786,
      2784,
      591,
      588,
      576,
      569,
      566,
      2296,
      1590,
      537,
      534,
      526,
      2276,
      522,
      2274,
      545,
      542,
      539,
      548,
      1572,
      1570,
      481,
      2245,
      466,
      2242,
      462,
      2239,
      492,
      485,
      482,
      2249,
      496,
      494,
      1534,
      1531,
      1528,
      1538,
      413,
      2196,
      406,
      2191,
      2188,
      425,
      419,
      2202,
      415,
      2199,
      432,
      430,
      427,
      1472,
      1467,
      1464,
      433,
      1476,
      1474,
      368,
      367,
      2160,
      365,
      2159,
      362,
      2157,
      2155,
      2152,
      378,
      377,
      375,
      2166,
      372,
      2165,
      369,
      2162,
      383,
      381,
      379,
      2168,
      1419,
      1418,
      1416,
      1414,
      385,
      1411,
      384,
      1423,
      1422,
      1420,
      1424,
      2461,
      802,
      2441,
      2439,
      790,
      786,
      783,
      794,
      2409,
      2406,
      2403,
      750,
      742,
      738,
      2414,
      756,
      753,
      1720,
      2367,
      2365,
      2362,
      2359,
      1663,
      693,
      691,
      684,
      2373,
      680,
      2370,
      702,
      699,
      696,
      704,
      1690,
      1687,
      2337,
      2336,
      2334,
      2332,
      1624,
      2329,
      1622,
      640,
      637,
      2344,
      634,
      2342,
      630,
      2340,
      650,
      648,
      645,
      2346,
      655,
      653,
      1653,
      1651,
      1649,
      1655,
      2612,
      2597,
      2595,
      2571,
      2568,
      2565,
      2576,
      2534,
      2529,
      2526,
      1787,
      2540,
      2537,
      907,
      904,
      900,
      910,
      2503,
      2502,
      2500,
      2498,
      1768,
      2495,
      1767,
      2510,
      2508,
      2506,
      869,
      866,
      863,
      2513,
      876,
      874,
      1782,
      2720,
      2713,
      2711,
      2697,
      2694,
      2691,
      2702,
      2672,
      2670,
      2664,
      1828,
      2678,
      2675,
      2647,
      2646,
      2644,
      2642,
      1823,
      2639,
      1822,
      2654,
      2652,
      2650,
      2657,
      2771,
      1855,
      2765,
      2762,
      1850,
      1849,
      2751,
      2749,
      2747,
      2754,
      353,
      2148,
      344,
      342,
      336,
      2142,
      332,
      2140,
      345,
      1375,
      1373,
      306,
      2130,
      299,
      2128,
      295,
      2125,
      319,
      314,
      311,
      2132,
      1354,
      1352,
      1349,
      1356,
      262,
      257,
      2101,
      253,
      2096,
      2093,
      274,
      273,
      267,
      2107,
      263,
      2104,
      280,
      278,
      275,
      1316,
      1311,
      1308,
      1320,
      1318,
      2052,
      202,
      2050,
      2044,
      2040,
      219,
      2063,
      212,
      2060,
      208,
      2055,
      224,
      221,
      2066,
      1260,
      1258,
      1252,
      231,
      1248,
      229,
      1266,
      1264,
      1261,
      1268,
      155,
      1998,
      153,
      1996,
      1994,
      1991,
      1988,
      165,
      164,
      2007,
      162,
      2006,
      159,
      2003,
      2e3,
      172,
      171,
      169,
      2012,
      166,
      2010,
      1186,
      1184,
      1182,
      1179,
      175,
      1176,
      173,
      1192,
      1191,
      1189,
      1187,
      176,
      1194,
      1193,
      2313,
      2307,
      2305,
      592,
      589,
      2294,
      2292,
      2289,
      578,
      572,
      568,
      2297,
      580,
      1591,
      2272,
      2267,
      2264,
      1547,
      538,
      536,
      529,
      2278,
      525,
      2275,
      547,
      544,
      541,
      1574,
      1571,
      2237,
      2235,
      2229,
      1493,
      2225,
      1489,
      478,
      2247,
      470,
      2244,
      465,
      2241,
      493,
      488,
      484,
      2250,
      498,
      495,
      1536,
      1533,
      1530,
      1539,
      2187,
      2186,
      2184,
      2182,
      1432,
      2179,
      1430,
      2176,
      1427,
      414,
      412,
      2197,
      409,
      2195,
      405,
      2193,
      2190,
      426,
      424,
      421,
      2203,
      418,
      2201,
      431,
      429,
      1473,
      1471,
      1469,
      1466,
      434,
      1477,
      1475,
      2478,
      2472,
      2470,
      2459,
      2457,
      2454,
      2462,
      803,
      2437,
      2432,
      2429,
      1726,
      2443,
      2440,
      792,
      789,
      785,
      2401,
      2399,
      2393,
      1702,
      2389,
      1699,
      2411,
      2408,
      2405,
      745,
      741,
      2415,
      758,
      755,
      1721,
      2358,
      2357,
      2355,
      2353,
      1661,
      2350,
      1660,
      2347,
      1657,
      2368,
      2366,
      2364,
      2361,
      1666,
      690,
      687,
      2374,
      683,
      2372,
      701,
      698,
      705,
      1691,
      1689,
      2619,
      2617,
      2610,
      2608,
      2605,
      2613,
      2593,
      2588,
      2585,
      1803,
      2599,
      2596,
      2563,
      2561,
      2555,
      1797,
      2551,
      1795,
      2573,
      2570,
      2567,
      2577,
      2525,
      2524,
      2522,
      2520,
      1786,
      2517,
      1785,
      2514,
      1783,
      2535,
      2533,
      2531,
      2528,
      1788,
      2541,
      2539,
      906,
      903,
      911,
      2721,
      1844,
      2715,
      2712,
      1838,
      1836,
      2699,
      2696,
      2693,
      2703,
      1827,
      1826,
      1824,
      2673,
      2671,
      2669,
      2666,
      1829,
      2679,
      2677,
      1858,
      1857,
      2772,
      1854,
      1853,
      1851,
      1856,
      2766,
      2764,
      143,
      1987,
      139,
      1986,
      135,
      133,
      131,
      1984,
      128,
      1983,
      125,
      1981,
      138,
      137,
      136,
      1985,
      1133,
      1132,
      1130,
      112,
      110,
      1974,
      107,
      1973,
      104,
      1971,
      1969,
      122,
      121,
      119,
      117,
      1977,
      114,
      1976,
      124,
      1115,
      1114,
      1112,
      1110,
      1117,
      1116,
      84,
      83,
      1953,
      81,
      1952,
      78,
      1950,
      1948,
      1945,
      94,
      93,
      91,
      1959,
      88,
      1958,
      85,
      1955,
      99,
      97,
      95,
      1961,
      1086,
      1085,
      1083,
      1081,
      1078,
      100,
      1090,
      1089,
      1087,
      1091,
      49,
      47,
      1917,
      44,
      1915,
      1913,
      1910,
      1907,
      59,
      1926,
      56,
      1925,
      53,
      1922,
      1919,
      66,
      64,
      1931,
      61,
      1929,
      1042,
      1040,
      1038,
      71,
      1035,
      70,
      1032,
      68,
      1048,
      1047,
      1045,
      1043,
      1050,
      1049,
      12,
      10,
      1869,
      1867,
      1864,
      1861,
      21,
      1880,
      19,
      1877,
      1874,
      1871,
      28,
      1888,
      25,
      1886,
      22,
      1883,
      982,
      980,
      977,
      974,
      32,
      30,
      991,
      989,
      987,
      984,
      34,
      995,
      994,
      992,
      2151,
      2150,
      2147,
      2146,
      2144,
      356,
      355,
      354,
      2149,
      2139,
      2138,
      2136,
      2134,
      1359,
      343,
      341,
      338,
      2143,
      335,
      2141,
      348,
      347,
      346,
      1376,
      1374,
      2124,
      2123,
      2121,
      2119,
      1326,
      2116,
      1324,
      310,
      308,
      305,
      2131,
      302,
      2129,
      298,
      2127,
      320,
      318,
      316,
      313,
      2133,
      322,
      321,
      1355,
      1353,
      1351,
      1357,
      2092,
      2091,
      2089,
      2087,
      1276,
      2084,
      1274,
      2081,
      1271,
      259,
      2102,
      256,
      2100,
      252,
      2098,
      2095,
      272,
      269,
      2108,
      266,
      2106,
      281,
      279,
      277,
      1317,
      1315,
      1313,
      1310,
      282,
      1321,
      1319,
      2039,
      2037,
      2035,
      2032,
      1203,
      2029,
      1200,
      1197,
      207,
      2053,
      205,
      2051,
      201,
      2049,
      2046,
      2043,
      220,
      218,
      2064,
      215,
      2062,
      211,
      2059,
      228,
      226,
      223,
      2069,
      1259,
      1257,
      1254,
      232,
      1251,
      230,
      1267,
      1265,
      1263,
      2316,
      2315,
      2312,
      2311,
      2309,
      2314,
      2304,
      2303,
      2301,
      2299,
      1593,
      2308,
      2306,
      590,
      2288,
      2287,
      2285,
      2283,
      1578,
      2280,
      1577,
      2295,
      2293,
      2291,
      579,
      577,
      574,
      571,
      2298,
      582,
      581,
      1592,
      2263,
      2262,
      2260,
      2258,
      1545,
      2255,
      1544,
      2252,
      1541,
      2273,
      2271,
      2269,
      2266,
      1550,
      535,
      532,
      2279,
      528,
      2277,
      546,
      543,
      549,
      1575,
      1573,
      2224,
      2222,
      2220,
      1486,
      2217,
      1485,
      2214,
      1482,
      1479,
      2238,
      2236,
      2234,
      2231,
      1496,
      2228,
      1492,
      480,
      477,
      2248,
      473,
      2246,
      469,
      2243,
      490,
      487,
      2251,
      497,
      1537,
      1535,
      1532,
      2477,
      2476,
      2474,
      2479,
      2469,
      2468,
      2466,
      2464,
      1730,
      2473,
      2471,
      2453,
      2452,
      2450,
      2448,
      1729,
      2445,
      1728,
      2460,
      2458,
      2456,
      2463,
      805,
      804,
      2428,
      2427,
      2425,
      2423,
      1725,
      2420,
      1724,
      2417,
      1722,
      2438,
      2436,
      2434,
      2431,
      1727,
      2444,
      2442,
      793,
      791,
      788,
      795,
      2388,
      2386,
      2384,
      1697,
      2381,
      1696,
      2378,
      1694,
      1692,
      2402,
      2400,
      2398,
      2395,
      1703,
      2392,
      1701,
      2412,
      2410,
      2407,
      751,
      748,
      744,
      2416,
      759,
      757,
      1807,
      2620,
      2618,
      1806,
      1805,
      2611,
      2609,
      2607,
      2614,
      1802,
      1801,
      1799,
      2594,
      2592,
      2590,
      2587,
      1804,
      2600,
      2598,
      1794,
      1793,
      1791,
      1789,
      2564,
      2562,
      2560,
      2557,
      1798,
      2554,
      1796,
      2574,
      2572,
      2569,
      2578,
      1847,
      1846,
      2722,
      1843,
      1842,
      1840,
      1845,
      2716,
      2714,
      1835,
      1834,
      1832,
      1830,
      1839,
      1837,
      2700,
      2698,
      2695,
      2704,
      1817,
      1811,
      1810,
      897,
      862,
      1777,
      829,
      826,
      838,
      1760,
      1758,
      808,
      2481,
      1741,
      1740,
      1738,
      1743,
      2624,
      1818,
      2726,
      2776,
      782,
      740,
      737,
      1715,
      686,
      679,
      695,
      1682,
      1680,
      639,
      628,
      2339,
      647,
      644,
      1645,
      1643,
      1640,
      1648,
      602,
      600,
      597,
      595,
      2320,
      593,
      2318,
      609,
      607,
      604,
      1611,
      1610,
      1608,
      1606,
      613,
      1615,
      1613,
      2328,
      926,
      924,
      892,
      886,
      899,
      857,
      850,
      2505,
      1778,
      824,
      823,
      821,
      819,
      2488,
      818,
      2486,
      833,
      831,
      828,
      840,
      1761,
      1759,
      2649,
      2632,
      2630,
      2746,
      2734,
      2732,
      2782,
      2781,
      570,
      567,
      1587,
      531,
      527,
      523,
      540,
      1566,
      1564,
      476,
      467,
      463,
      2240,
      486,
      483,
      1524,
      1521,
      1518,
      1529,
      411,
      403,
      2192,
      399,
      2189,
      423,
      416,
      1462,
      1457,
      1454,
      428,
      1468,
      1465,
      2210,
      366,
      363,
      2158,
      360,
      2156,
      357,
      2153,
      376,
      373,
      370,
      2163,
      1410,
      1409,
      1407,
      1405,
      382,
      1402,
      380,
      1417,
      1415,
      1412,
      1421,
      2175,
      2174,
      777,
      774,
      771,
      784,
      732,
      725,
      722,
      2404,
      743,
      1716,
      676,
      674,
      668,
      2363,
      665,
      2360,
      685,
      1684,
      1681,
      626,
      624,
      622,
      2335,
      620,
      2333,
      617,
      2330,
      641,
      635,
      649,
      1646,
      1644,
      1642,
      2566,
      928,
      925,
      2530,
      2527,
      894,
      891,
      888,
      2501,
      2499,
      2496,
      858,
      856,
      854,
      851,
      1779,
      2692,
      2668,
      2665,
      2645,
      2643,
      2640,
      2651,
      2768,
      2759,
      2757,
      2744,
      2743,
      2741,
      2748,
      352,
      1382,
      340,
      337,
      333,
      1371,
      1369,
      307,
      300,
      296,
      2126,
      315,
      312,
      1347,
      1342,
      1350,
      261,
      258,
      250,
      2097,
      246,
      2094,
      271,
      268,
      264,
      1306,
      1301,
      1298,
      276,
      1312,
      1309,
      2115,
      203,
      2048,
      195,
      2045,
      191,
      2041,
      213,
      209,
      2056,
      1246,
      1244,
      1238,
      225,
      1234,
      222,
      1256,
      1253,
      1249,
      1262,
      2080,
      2079,
      154,
      1997,
      150,
      1995,
      147,
      1992,
      1989,
      163,
      160,
      2004,
      156,
      2001,
      1175,
      1174,
      1172,
      1170,
      1167,
      170,
      1164,
      167,
      1185,
      1183,
      1180,
      1177,
      174,
      1190,
      1188,
      2025,
      2024,
      2022,
      587,
      586,
      564,
      559,
      556,
      2290,
      573,
      1588,
      520,
      518,
      512,
      2268,
      508,
      2265,
      530,
      1568,
      1565,
      461,
      457,
      2233,
      450,
      2230,
      446,
      2226,
      479,
      471,
      489,
      1526,
      1523,
      1520,
      397,
      395,
      2185,
      392,
      2183,
      389,
      2180,
      2177,
      410,
      2194,
      402,
      422,
      1463,
      1461,
      1459,
      1456,
      1470,
      2455,
      799,
      2433,
      2430,
      779,
      776,
      773,
      2397,
      2394,
      2390,
      734,
      728,
      724,
      746,
      1717,
      2356,
      2354,
      2351,
      2348,
      1658,
      677,
      675,
      673,
      670,
      667,
      688,
      1685,
      1683,
      2606,
      2589,
      2586,
      2559,
      2556,
      2552,
      927,
      2523,
      2521,
      2518,
      2515,
      1784,
      2532,
      895,
      893,
      890,
      2718,
      2709,
      2707,
      2689,
      2687,
      2684,
      2663,
      2662,
      2660,
      2658,
      1825,
      2667,
      2769,
      1852,
      2760,
      2758,
      142,
      141,
      1139,
      1138,
      134,
      132,
      129,
      126,
      1982,
      1129,
      1128,
      1126,
      1131,
      113,
      111,
      108,
      105,
      1972,
      101,
      1970,
      120,
      118,
      115,
      1109,
      1108,
      1106,
      1104,
      123,
      1113,
      1111,
      82,
      79,
      1951,
      75,
      1949,
      72,
      1946,
      92,
      89,
      86,
      1956,
      1077,
      1076,
      1074,
      1072,
      98,
      1069,
      96,
      1084,
      1082,
      1079,
      1088,
      1968,
      1967,
      48,
      45,
      1916,
      42,
      1914,
      39,
      1911,
      1908,
      60,
      57,
      54,
      1923,
      50,
      1920,
      1031,
      1030,
      1028,
      1026,
      67,
      1023,
      65,
      1020,
      62,
      1041,
      1039,
      1036,
      1033,
      69,
      1046,
      1044,
      1944,
      1943,
      1941,
      11,
      9,
      1868,
      7,
      1865,
      1862,
      1859,
      20,
      1878,
      16,
      1875,
      13,
      1872,
      970,
      968,
      966,
      963,
      29,
      960,
      26,
      23,
      983,
      981,
      978,
      975,
      33,
      971,
      31,
      990,
      988,
      985,
      1906,
      1904,
      1902,
      993,
      351,
      2145,
      1383,
      331,
      330,
      328,
      326,
      2137,
      323,
      2135,
      339,
      1372,
      1370,
      294,
      293,
      291,
      289,
      2122,
      286,
      2120,
      283,
      2117,
      309,
      303,
      317,
      1348,
      1346,
      1344,
      245,
      244,
      242,
      2090,
      239,
      2088,
      236,
      2085,
      2082,
      260,
      2099,
      249,
      270,
      1307,
      1305,
      1303,
      1300,
      1314,
      189,
      2038,
      186,
      2036,
      183,
      2033,
      2030,
      2026,
      206,
      198,
      2047,
      194,
      216,
      1247,
      1245,
      1243,
      1240,
      227,
      1237,
      1255,
      2310,
      2302,
      2300,
      2286,
      2284,
      2281,
      565,
      563,
      561,
      558,
      575,
      1589,
      2261,
      2259,
      2256,
      2253,
      1542,
      521,
      519,
      517,
      514,
      2270,
      511,
      533,
      1569,
      1567,
      2223,
      2221,
      2218,
      2215,
      1483,
      2211,
      1480,
      459,
      456,
      453,
      2232,
      449,
      474,
      491,
      1527,
      1525,
      1522,
      2475,
      2467,
      2465,
      2451,
      2449,
      2446,
      801,
      800,
      2426,
      2424,
      2421,
      2418,
      1723,
      2435,
      780,
      778,
      775,
      2387,
      2385,
      2382,
      2379,
      1695,
      2375,
      1693,
      2396,
      735,
      733,
      730,
      727,
      749,
      1718,
      2616,
      2615,
      2604,
      2603,
      2601,
      2584,
      2583,
      2581,
      2579,
      1800,
      2591,
      2550,
      2549,
      2547,
      2545,
      1792,
      2542,
      1790,
      2558,
      929,
      2719,
      1841,
      2710,
      2708,
      1833,
      1831,
      2690,
      2688,
      2686,
      1815,
      1809,
      1808,
      1774,
      1756,
      1754,
      1737,
      1736,
      1734,
      1739,
      1816,
      1711,
      1676,
      1674,
      633,
      629,
      1638,
      1636,
      1633,
      1641,
      598,
      1605,
      1604,
      1602,
      1600,
      605,
      1609,
      1607,
      2327,
      887,
      853,
      1775,
      822,
      820,
      1757,
      1755,
      1584,
      524,
      1560,
      1558,
      468,
      464,
      1514,
      1511,
      1508,
      1519,
      408,
      404,
      400,
      1452,
      1447,
      1444,
      417,
      1458,
      1455,
      2208,
      364,
      361,
      358,
      2154,
      1401,
      1400,
      1398,
      1396,
      374,
      1393,
      371,
      1408,
      1406,
      1403,
      1413,
      2173,
      2172,
      772,
      726,
      723,
      1712,
      672,
      669,
      666,
      682,
      1678,
      1675,
      625,
      623,
      621,
      618,
      2331,
      636,
      632,
      1639,
      1637,
      1635,
      920,
      918,
      884,
      880,
      889,
      849,
      848,
      847,
      846,
      2497,
      855,
      852,
      1776,
      2641,
      2742,
      2787,
      1380,
      334,
      1367,
      1365,
      301,
      297,
      1340,
      1338,
      1335,
      1343,
      255,
      251,
      247,
      1296,
      1291,
      1288,
      265,
      1302,
      1299,
      2113,
      204,
      196,
      192,
      2042,
      1232,
      1230,
      1224,
      214,
      1220,
      210,
      1242,
      1239,
      1235,
      1250,
      2077,
      2075,
      151,
      148,
      1993,
      144,
      1990,
      1163,
      1162,
      1160,
      1158,
      1155,
      161,
      1152,
      157,
      1173,
      1171,
      1168,
      1165,
      168,
      1181,
      1178,
      2021,
      2020,
      2018,
      2023,
      585,
      560,
      557,
      1585,
      516,
      509,
      1562,
      1559,
      458,
      447,
      2227,
      472,
      1516,
      1513,
      1510,
      398,
      396,
      393,
      390,
      2181,
      386,
      2178,
      407,
      1453,
      1451,
      1449,
      1446,
      420,
      1460,
      2209,
      769,
      764,
      720,
      712,
      2391,
      729,
      1713,
      664,
      663,
      661,
      659,
      2352,
      656,
      2349,
      671,
      1679,
      1677,
      2553,
      922,
      919,
      2519,
      2516,
      885,
      883,
      881,
      2685,
      2661,
      2659,
      2767,
      2756,
      2755,
      140,
      1137,
      1136,
      130,
      127,
      1125,
      1124,
      1122,
      1127,
      109,
      106,
      102,
      1103,
      1102,
      1100,
      1098,
      116,
      1107,
      1105,
      1980,
      80,
      76,
      73,
      1947,
      1068,
      1067,
      1065,
      1063,
      90,
      1060,
      87,
      1075,
      1073,
      1070,
      1080,
      1966,
      1965,
      46,
      43,
      40,
      1912,
      36,
      1909,
      1019,
      1018,
      1016,
      1014,
      58,
      1011,
      55,
      1008,
      51,
      1029,
      1027,
      1024,
      1021,
      63,
      1037,
      1034,
      1940,
      1939,
      1937,
      1942,
      8,
      1866,
      4,
      1863,
      1,
      1860,
      956,
      954,
      952,
      949,
      946,
      17,
      14,
      969,
      967,
      964,
      961,
      27,
      957,
      24,
      979,
      976,
      972,
      1901,
      1900,
      1898,
      1896,
      986,
      1905,
      1903,
      350,
      349,
      1381,
      329,
      327,
      324,
      1368,
      1366,
      292,
      290,
      287,
      284,
      2118,
      304,
      1341,
      1339,
      1337,
      1345,
      243,
      240,
      237,
      2086,
      233,
      2083,
      254,
      1297,
      1295,
      1293,
      1290,
      1304,
      2114,
      190,
      187,
      184,
      2034,
      180,
      2031,
      177,
      2027,
      199,
      1233,
      1231,
      1229,
      1226,
      217,
      1223,
      1241,
      2078,
      2076,
      584,
      555,
      554,
      552,
      550,
      2282,
      562,
      1586,
      507,
      506,
      504,
      502,
      2257,
      499,
      2254,
      515,
      1563,
      1561,
      445,
      443,
      441,
      2219,
      438,
      2216,
      435,
      2212,
      460,
      454,
      475,
      1517,
      1515,
      1512,
      2447,
      798,
      797,
      2422,
      2419,
      770,
      768,
      766,
      2383,
      2380,
      2376,
      721,
      719,
      717,
      714,
      731,
      1714,
      2602,
      2582,
      2580,
      2548,
      2546,
      2543,
      923,
      921,
      2717,
      2706,
      2705,
      2683,
      2682,
      2680,
      1771,
      1752,
      1750,
      1733,
      1732,
      1731,
      1735,
      1814,
      1707,
      1670,
      1668,
      1631,
      1629,
      1626,
      1634,
      1599,
      1598,
      1596,
      1594,
      1603,
      1601,
      2326,
      1772,
      1753,
      1751,
      1581,
      1554,
      1552,
      1504,
      1501,
      1498,
      1509,
      1442,
      1437,
      1434,
      401,
      1448,
      1445,
      2206,
      1392,
      1391,
      1389,
      1387,
      1384,
      359,
      1399,
      1397,
      1394,
      1404,
      2171,
      2170,
      1708,
      1672,
      1669,
      619,
      1632,
      1630,
      1628,
      1773,
      1378,
      1363,
      1361,
      1333,
      1328,
      1336,
      1286,
      1281,
      1278,
      248,
      1292,
      1289,
      2111,
      1218,
      1216,
      1210,
      197,
      1206,
      193,
      1228,
      1225,
      1221,
      1236,
      2073,
      2071,
      1151,
      1150,
      1148,
      1146,
      152,
      1143,
      149,
      1140,
      145,
      1161,
      1159,
      1156,
      1153,
      158,
      1169,
      1166,
      2017,
      2016,
      2014,
      2019,
      1582,
      510,
      1556,
      1553,
      452,
      448,
      1506,
      1500,
      394,
      391,
      387,
      1443,
      1441,
      1439,
      1436,
      1450,
      2207,
      765,
      716,
      713,
      1709,
      662,
      660,
      657,
      1673,
      1671,
      916,
      914,
      879,
      878,
      877,
      882,
      1135,
      1134,
      1121,
      1120,
      1118,
      1123,
      1097,
      1096,
      1094,
      1092,
      103,
      1101,
      1099,
      1979,
      1059,
      1058,
      1056,
      1054,
      77,
      1051,
      74,
      1066,
      1064,
      1061,
      1071,
      1964,
      1963,
      1007,
      1006,
      1004,
      1002,
      999,
      41,
      996,
      37,
      1017,
      1015,
      1012,
      1009,
      52,
      1025,
      1022,
      1936,
      1935,
      1933,
      1938,
      942,
      940,
      938,
      935,
      932,
      5,
      2,
      955,
      953,
      950,
      947,
      18,
      943,
      15,
      965,
      962,
      958,
      1895,
      1894,
      1892,
      1890,
      973,
      1899,
      1897,
      1379,
      325,
      1364,
      1362,
      288,
      285,
      1334,
      1332,
      1330,
      241,
      238,
      234,
      1287,
      1285,
      1283,
      1280,
      1294,
      2112,
      188,
      185,
      181,
      178,
      2028,
      1219,
      1217,
      1215,
      1212,
      200,
      1209,
      1227,
      2074,
      2072,
      583,
      553,
      551,
      1583,
      505,
      503,
      500,
      513,
      1557,
      1555,
      444,
      442,
      439,
      436,
      2213,
      455,
      451,
      1507,
      1505,
      1502,
      796,
      763,
      762,
      760,
      767,
      711,
      710,
      708,
      706,
      2377,
      718,
      715,
      1710,
      2544,
      917,
      915,
      2681,
      1627,
      1597,
      1595,
      2325,
      1769,
      1749,
      1747,
      1499,
      1438,
      1435,
      2204,
      1390,
      1388,
      1385,
      1395,
      2169,
      2167,
      1704,
      1665,
      1662,
      1625,
      1623,
      1620,
      1770,
      1329,
      1282,
      1279,
      2109,
      1214,
      1207,
      1222,
      2068,
      2065,
      1149,
      1147,
      1144,
      1141,
      146,
      1157,
      1154,
      2013,
      2011,
      2008,
      2015,
      1579,
      1549,
      1546,
      1495,
      1487,
      1433,
      1431,
      1428,
      1425,
      388,
      1440,
      2205,
      1705,
      658,
      1667,
      1664,
      1119,
      1095,
      1093,
      1978,
      1057,
      1055,
      1052,
      1062,
      1962,
      1960,
      1005,
      1003,
      1e3,
      997,
      38,
      1013,
      1010,
      1932,
      1930,
      1927,
      1934,
      941,
      939,
      936,
      933,
      6,
      930,
      3,
      951,
      948,
      944,
      1889,
      1887,
      1884,
      1881,
      959,
      1893,
      1891,
      35,
      1377,
      1360,
      1358,
      1327,
      1325,
      1322,
      1331,
      1277,
      1275,
      1272,
      1269,
      235,
      1284,
      2110,
      1205,
      1204,
      1201,
      1198,
      182,
      1195,
      179,
      1213,
      2070,
      2067,
      1580,
      501,
      1551,
      1548,
      440,
      437,
      1497,
      1494,
      1490,
      1503,
      761,
      709,
      707,
      1706,
      913,
      912,
      2198,
      1386,
      2164,
      2161,
      1621,
      1766,
      2103,
      1208,
      2058,
      2054,
      1145,
      1142,
      2005,
      2002,
      1999,
      2009,
      1488,
      1429,
      1426,
      2200,
      1698,
      1659,
      1656,
      1975,
      1053,
      1957,
      1954,
      1001,
      998,
      1924,
      1921,
      1918,
      1928,
      937,
      934,
      931,
      1879,
      1876,
      1873,
      1870,
      945,
      1885,
      1882,
      1323,
      1273,
      1270,
      2105,
      1202,
      1199,
      1196,
      1211,
      2061,
      2057,
      1576,
      1543,
      1540,
      1484,
      1481,
      1478,
      1491,
      1700
    ]);
    class PDF417DetectorResult {
      constructor(bits, points) {
        this.bits = bits;
        this.points = points;
      }
      getBits() {
        return this.bits;
      }
      getPoints() {
        return this.points;
      }
    }
    class Detector$3 {
      /**
       * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>
       *
       * @param image barcode image to decode
       * @param hints optional hints to detector
       * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will
       * be found and returned
       * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code
       * @throws NotFoundException if no PDF417 Code can be found
       */
      static detectMultiple(image, hints, multiple) {
        let bitMatrix = image.getBlackMatrix();
        let barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
        if (!barcodeCoordinates.length) {
          bitMatrix = bitMatrix.clone();
          bitMatrix.rotate180();
          barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
        }
        return new PDF417DetectorResult(bitMatrix, barcodeCoordinates);
      }
      /**
       * Detects PDF417 codes in an image. Only checks 0 degree rotation
       * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will
       * be found and returned
       * @param bitMatrix bit matrix to detect barcodes in
       * @return List of ResultPoint arrays containing the coordinates of found barcodes
       */
      static detect(multiple, bitMatrix) {
        const barcodeCoordinates = new Array();
        let row = 0;
        let column = 0;
        let foundBarcodeInRow = false;
        while (row < bitMatrix.getHeight()) {
          const vertices = Detector$3.findVertices(bitMatrix, row, column);
          if (vertices[0] == null && vertices[3] == null) {
            if (!foundBarcodeInRow) {
              break;
            }
            foundBarcodeInRow = false;
            column = 0;
            for (const barcodeCoordinate of barcodeCoordinates) {
              if (barcodeCoordinate[1] != null) {
                row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));
              }
              if (barcodeCoordinate[3] != null) {
                row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));
              }
            }
            row += Detector$3.ROW_STEP;
            continue;
          }
          foundBarcodeInRow = true;
          barcodeCoordinates.push(vertices);
          if (!multiple) {
            break;
          }
          if (vertices[2] != null) {
            column = Math.trunc(vertices[2].getX());
            row = Math.trunc(vertices[2].getY());
          } else {
            column = Math.trunc(vertices[4].getX());
            row = Math.trunc(vertices[4].getY());
          }
        }
        return barcodeCoordinates;
      }
      /**
       * Locate the vertices and the codewords area of a black blob using the Start
       * and Stop patterns as locators.
       *
       * @param matrix the scanned barcode image.
       * @return an array containing the vertices:
       *           vertices[0] x, y top left barcode
       *           vertices[1] x, y bottom left barcode
       *           vertices[2] x, y top right barcode
       *           vertices[3] x, y bottom right barcode
       *           vertices[4] x, y top left codeword area
       *           vertices[5] x, y bottom left codeword area
       *           vertices[6] x, y top right codeword area
       *           vertices[7] x, y bottom right codeword area
       */
      static findVertices(matrix, startRow, startColumn) {
        const height = matrix.getHeight();
        const width = matrix.getWidth();
        const result = new Array(8);
        Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.START_PATTERN), Detector$3.INDEXES_START_PATTERN);
        if (result[4] != null) {
          startColumn = Math.trunc(result[4].getX());
          startRow = Math.trunc(result[4].getY());
        }
        Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.STOP_PATTERN), Detector$3.INDEXES_STOP_PATTERN);
        return result;
      }
      static copyToResult(result, tmpResult, destinationIndexes) {
        for (let i = 0; i < destinationIndexes.length; i++) {
          result[destinationIndexes[i]] = tmpResult[i];
        }
      }
      static findRowsWithPattern(matrix, height, width, startRow, startColumn, pattern) {
        const result = new Array(4);
        let found = false;
        const counters = new Int32Array(pattern.length);
        for (; startRow < height; startRow += Detector$3.ROW_STEP) {
          let loc = Detector$3.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);
          if (loc != null) {
            while (startRow > 0) {
              const previousRowLoc = Detector$3.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);
              if (previousRowLoc != null) {
                loc = previousRowLoc;
              } else {
                startRow++;
                break;
              }
            }
            result[0] = new ResultPoint(loc[0], startRow);
            result[1] = new ResultPoint(loc[1], startRow);
            found = true;
            break;
          }
        }
        let stopRow = startRow + 1;
        if (found) {
          let skippedRowCount = 0;
          let previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);
          for (; stopRow < height; stopRow++) {
            const loc = Detector$3.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);
            if (loc != null && Math.abs(previousRowLoc[0] - loc[0]) < Detector$3.MAX_PATTERN_DRIFT && Math.abs(previousRowLoc[1] - loc[1]) < Detector$3.MAX_PATTERN_DRIFT) {
              previousRowLoc = loc;
              skippedRowCount = 0;
            } else {
              if (skippedRowCount > Detector$3.SKIPPED_ROW_COUNT_MAX) {
                break;
              } else {
                skippedRowCount++;
              }
            }
          }
          stopRow -= skippedRowCount + 1;
          result[2] = new ResultPoint(previousRowLoc[0], stopRow);
          result[3] = new ResultPoint(previousRowLoc[1], stopRow);
        }
        if (stopRow - startRow < Detector$3.BARCODE_MIN_HEIGHT) {
          Arrays.fill(result, null);
        }
        return result;
      }
      /**
       * @param matrix row of black/white values to search
       * @param column x position to start search
       * @param row y position to start search
       * @param width the number of pixels to search on this row
       * @param pattern pattern of counts of number of black and white pixels that are
       *                 being searched for as a pattern
       * @param counters array of counters, as long as pattern, to re-use
       * @return start/end horizontal offset of guard pattern, as an array of two ints.
       */
      static findGuardPattern(matrix, column, row, width, whiteFirst, pattern, counters) {
        Arrays.fillWithin(counters, 0, counters.length, 0);
        let patternStart = column;
        let pixelDrift = 0;
        while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector$3.MAX_PIXEL_DRIFT) {
          patternStart--;
        }
        let x = patternStart;
        let counterPosition = 0;
        let patternLength = pattern.length;
        for (let isWhite = whiteFirst; x < width; x++) {
          let pixel = matrix.get(x, row);
          if (pixel !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
                return new Int32Array([patternStart, x]);
              }
              patternStart += counters[0] + counters[1];
              System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        if (counterPosition === patternLength - 1 && Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
          return new Int32Array([patternStart, x - 1]);
        }
        return null;
      }
      /**
       * Determines how closely a set of observed counts of runs of black/white
       * values matches a given target pattern. This is reported as the ratio of
       * the total variance from the expected pattern proportions across all
       * pattern elements, to the length of the pattern.
       *
       * @param counters observed counters
       * @param pattern expected pattern
       * @param maxIndividualVariance The most any counter can differ before we give up
       * @return ratio of total variance between counters and pattern compared to total pattern size
       */
      static patternMatchVariance(counters, pattern, maxIndividualVariance) {
        let numCounters = counters.length;
        let total = 0;
        let patternLength = 0;
        for (let i = 0; i < numCounters; i++) {
          total += counters[i];
          patternLength += pattern[i];
        }
        if (total < patternLength) {
          return (
            /*Float.POSITIVE_INFINITY*/
            Infinity
          );
        }
        let unitBarWidth = total / patternLength;
        maxIndividualVariance *= unitBarWidth;
        let totalVariance = 0;
        for (let x = 0; x < numCounters; x++) {
          let counter = counters[x];
          let scaledPattern = pattern[x] * unitBarWidth;
          let variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
          if (variance > maxIndividualVariance) {
            return (
              /*Float.POSITIVE_INFINITY*/
              Infinity
            );
          }
          totalVariance += variance;
        }
        return totalVariance / total;
      }
    }
    Detector$3.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);
    Detector$3.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);
    Detector$3.MAX_AVG_VARIANCE = 0.42;
    Detector$3.MAX_INDIVIDUAL_VARIANCE = 0.8;
    Detector$3.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);
    Detector$3.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);
    Detector$3.MAX_PIXEL_DRIFT = 3;
    Detector$3.MAX_PATTERN_DRIFT = 5;
    Detector$3.SKIPPED_ROW_COUNT_MAX = 25;
    Detector$3.ROW_STEP = 5;
    Detector$3.BARCODE_MIN_HEIGHT = 10;
    class ModulusPoly {
      constructor(field2, coefficients) {
        if (coefficients.length === 0) {
          throw new IllegalArgumentException();
        }
        this.field = field2;
        let coefficientsLength = (
          /*int*/
          coefficients.length
        );
        if (coefficientsLength > 1 && coefficients[0] === 0) {
          let firstNonZero = (
            /*int*/
            1
          );
          while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
            firstNonZero++;
          }
          if (firstNonZero === coefficientsLength) {
            this.coefficients = new Int32Array([0]);
          } else {
            this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
            System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
          }
        } else {
          this.coefficients = coefficients;
        }
      }
      getCoefficients() {
        return this.coefficients;
      }
      /**
       * @return degree of this polynomial
       */
      getDegree() {
        return this.coefficients.length - 1;
      }
      /**
       * @return true iff this polynomial is the monomial "0"
       */
      isZero() {
        return this.coefficients[0] === 0;
      }
      /**
       * @return coefficient of x^degree term in this polynomial
       */
      getCoefficient(degree) {
        return this.coefficients[this.coefficients.length - 1 - degree];
      }
      /**
       * @return evaluation of this polynomial at a given point
       */
      evaluateAt(a) {
        if (a === 0) {
          return this.getCoefficient(0);
        }
        if (a === 1) {
          let sum = (
            /*int*/
            0
          );
          for (let coefficient of this.coefficients) {
            sum = this.field.add(sum, coefficient);
          }
          return sum;
        }
        let result = (
          /*int*/
          this.coefficients[0]
        );
        let size = (
          /*int*/
          this.coefficients.length
        );
        for (let i = 1; i < size; i++) {
          result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);
        }
        return result;
      }
      add(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
        }
        if (this.isZero()) {
          return other;
        }
        if (other.isZero()) {
          return this;
        }
        let smallerCoefficients = this.coefficients;
        let largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
          let temp = smallerCoefficients;
          smallerCoefficients = largerCoefficients;
          largerCoefficients = temp;
        }
        let sumDiff = new Int32Array(largerCoefficients.length);
        let lengthDiff = (
          /*int*/
          largerCoefficients.length - smallerCoefficients.length
        );
        System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (let i = lengthDiff; i < largerCoefficients.length; i++) {
          sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
        }
        return new ModulusPoly(this.field, sumDiff);
      }
      subtract(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
        }
        if (other.isZero()) {
          return this;
        }
        return this.add(other.negative());
      }
      multiply(other) {
        if (other instanceof ModulusPoly) {
          return this.multiplyOther(other);
        }
        return this.multiplyScalar(other);
      }
      multiplyOther(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
        }
        if (this.isZero() || other.isZero()) {
          return new ModulusPoly(this.field, new Int32Array([0]));
        }
        let aCoefficients = this.coefficients;
        let aLength = (
          /*int*/
          aCoefficients.length
        );
        let bCoefficients = other.coefficients;
        let bLength = (
          /*int*/
          bCoefficients.length
        );
        let product = new Int32Array(aLength + bLength - 1);
        for (let i = 0; i < aLength; i++) {
          let aCoeff = (
            /*int*/
            aCoefficients[i]
          );
          for (let j = 0; j < bLength; j++) {
            product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));
          }
        }
        return new ModulusPoly(this.field, product);
      }
      negative() {
        let size = (
          /*int*/
          this.coefficients.length
        );
        let negativeCoefficients = new Int32Array(size);
        for (let i = 0; i < size; i++) {
          negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);
        }
        return new ModulusPoly(this.field, negativeCoefficients);
      }
      multiplyScalar(scalar2) {
        if (scalar2 === 0) {
          return new ModulusPoly(this.field, new Int32Array([0]));
        }
        if (scalar2 === 1) {
          return this;
        }
        let size = (
          /*int*/
          this.coefficients.length
        );
        let product = new Int32Array(size);
        for (let i = 0; i < size; i++) {
          product[i] = this.field.multiply(this.coefficients[i], scalar2);
        }
        return new ModulusPoly(this.field, product);
      }
      multiplyByMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return new ModulusPoly(this.field, new Int32Array([0]));
        }
        let size = (
          /*int*/
          this.coefficients.length
        );
        let product = new Int32Array(size + degree);
        for (let i = 0; i < size; i++) {
          product[i] = this.field.multiply(this.coefficients[i], coefficient);
        }
        return new ModulusPoly(this.field, product);
      }
      /*
        ModulusPoly[] divide(other: ModulusPoly) {
          if (!field.equals(other.field)) {
            throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
          }
          if (other.isZero()) {
            throw new IllegalArgumentException("Divide by 0");
          }
      
          let quotient: ModulusPoly = field.getZero();
          let remainder: ModulusPoly = this;
      
          let denominatorLeadingTerm: /*int/ number = other.getCoefficient(other.getDegree());
          let inverseDenominatorLeadingTerm: /*int/ number = field.inverse(denominatorLeadingTerm);
      
          while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
            let degreeDifference: /*int/ number = remainder.getDegree() - other.getDegree();
            let scale: /*int/ number = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
            let term: ModulusPoly = other.multiplyByMonomial(degreeDifference, scale);
            let iterationQuotient: ModulusPoly = field.buildMonomial(degreeDifference, scale);
            quotient = quotient.add(iterationQuotient);
            remainder = remainder.subtract(term);
          }
      
          return new ModulusPoly[] { quotient, remainder };
        }
        */
      // @Override
      toString() {
        let result = new StringBuilder(
          /*8 * this.getDegree()*/
        );
        for (let degree = this.getDegree(); degree >= 0; degree--) {
          let coefficient = (
            /*int*/
            this.getCoefficient(degree)
          );
          if (coefficient !== 0) {
            if (coefficient < 0) {
              result.append(" - ");
              coefficient = -coefficient;
            } else {
              if (result.length() > 0) {
                result.append(" + ");
              }
            }
            if (degree === 0 || coefficient !== 1) {
              result.append(coefficient);
            }
            if (degree !== 0) {
              if (degree === 1) {
                result.append("x");
              } else {
                result.append("x^");
                result.append(degree);
              }
            }
          }
        }
        return result.toString();
      }
    }
    class ModulusBase {
      add(a, b) {
        return (a + b) % this.modulus;
      }
      subtract(a, b) {
        return (this.modulus + a - b) % this.modulus;
      }
      exp(a) {
        return this.expTable[a];
      }
      log(a) {
        if (a === 0) {
          throw new IllegalArgumentException();
        }
        return this.logTable[a];
      }
      inverse(a) {
        if (a === 0) {
          throw new ArithmeticException();
        }
        return this.expTable[this.modulus - this.logTable[a] - 1];
      }
      multiply(a, b) {
        if (a === 0 || b === 0) {
          return 0;
        }
        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];
      }
      getSize() {
        return this.modulus;
      }
      equals(o) {
        return o === this;
      }
    }
    class ModulusGF extends ModulusBase {
      // private /*final*/ modulus: /*int*/ number;
      constructor(modulus, generator) {
        super();
        this.modulus = modulus;
        this.expTable = new Int32Array(modulus);
        this.logTable = new Int32Array(modulus);
        let x = (
          /*int*/
          1
        );
        for (let i = 0; i < modulus; i++) {
          this.expTable[i] = x;
          x = x * generator % modulus;
        }
        for (let i = 0; i < modulus - 1; i++) {
          this.logTable[this.expTable[i]] = i;
        }
        this.zero = new ModulusPoly(this, new Int32Array([0]));
        this.one = new ModulusPoly(this, new Int32Array([1]));
      }
      getZero() {
        return this.zero;
      }
      getOne() {
        return this.one;
      }
      buildMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return this.zero;
        }
        let coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new ModulusPoly(this, coefficients);
      }
    }
    ModulusGF.PDF417_GF = new ModulusGF(PDF417Common.NUMBER_OF_CODEWORDS, 3);
    class ErrorCorrection {
      constructor() {
        this.field = ModulusGF.PDF417_GF;
      }
      /**
       * @param received received codewords
       * @param numECCodewords number of those codewords used for EC
       * @param erasures location of erasures
       * @return number of errors
       * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors
       */
      decode(received, numECCodewords, erasures) {
        let poly = new ModulusPoly(this.field, received);
        let S2 = new Int32Array(numECCodewords);
        let error = false;
        for (let i = numECCodewords; i > 0; i--) {
          let evaluation = poly.evaluateAt(this.field.exp(i));
          S2[numECCodewords - i] = evaluation;
          if (evaluation !== 0) {
            error = true;
          }
        }
        if (!error) {
          return 0;
        }
        let knownErrors = this.field.getOne();
        if (erasures != null) {
          for (const erasure of erasures) {
            let b = this.field.exp(received.length - 1 - erasure);
            let term = new ModulusPoly(this.field, new Int32Array([this.field.subtract(0, b), 1]));
            knownErrors = knownErrors.multiply(term);
          }
        }
        let syndrome = new ModulusPoly(this.field, S2);
        let sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);
        let sigma = sigmaOmega[0];
        let omega = sigmaOmega[1];
        let errorLocations = this.findErrorLocations(sigma);
        let errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);
        for (let i = 0; i < errorLocations.length; i++) {
          let position = received.length - 1 - this.field.log(errorLocations[i]);
          if (position < 0) {
            throw ChecksumException.getChecksumInstance();
          }
          received[position] = this.field.subtract(received[position], errorMagnitudes[i]);
        }
        return errorLocations.length;
      }
      /**
       *
       * @param ModulusPoly
       * @param a
       * @param ModulusPoly
       * @param b
       * @param int
       * @param R
       * @throws ChecksumException
       */
      runEuclideanAlgorithm(a, b, R2) {
        if (a.getDegree() < b.getDegree()) {
          let temp = a;
          a = b;
          b = temp;
        }
        let rLast = a;
        let r = b;
        let tLast = this.field.getZero();
        let t = this.field.getOne();
        while (r.getDegree() >= Math.round(R2 / 2)) {
          let rLastLast = rLast;
          let tLastLast = tLast;
          rLast = r;
          tLast = t;
          if (rLast.isZero()) {
            throw ChecksumException.getChecksumInstance();
          }
          r = rLastLast;
          let q = this.field.getZero();
          let denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
          let dltInverse = this.field.inverse(denominatorLeadingTerm);
          while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
            let degreeDiff = r.getDegree() - rLast.getDegree();
            let scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
            q = q.add(this.field.buildMonomial(degreeDiff, scale));
            r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));
          }
          t = q.multiply(tLast).subtract(tLastLast).negative();
        }
        let sigmaTildeAtZero = t.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
          throw ChecksumException.getChecksumInstance();
        }
        let inverse = this.field.inverse(sigmaTildeAtZero);
        let sigma = t.multiply(inverse);
        let omega = r.multiply(inverse);
        return [sigma, omega];
      }
      /**
       *
       * @param errorLocator
       * @throws ChecksumException
       */
      findErrorLocations(errorLocator) {
        let numErrors = errorLocator.getDegree();
        let result = new Int32Array(numErrors);
        let e = 0;
        for (let i = 1; i < this.field.getSize() && e < numErrors; i++) {
          if (errorLocator.evaluateAt(i) === 0) {
            result[e] = this.field.inverse(i);
            e++;
          }
        }
        if (e !== numErrors) {
          throw ChecksumException.getChecksumInstance();
        }
        return result;
      }
      findErrorMagnitudes(errorEvaluator, errorLocator, errorLocations) {
        let errorLocatorDegree = errorLocator.getDegree();
        let formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);
        for (let i = 1; i <= errorLocatorDegree; i++) {
          formalDerivativeCoefficients[errorLocatorDegree - i] = this.field.multiply(i, errorLocator.getCoefficient(i));
        }
        let formalDerivative = new ModulusPoly(this.field, formalDerivativeCoefficients);
        let s = errorLocations.length;
        let result = new Int32Array(s);
        for (let i = 0; i < s; i++) {
          let xiInverse = this.field.inverse(errorLocations[i]);
          let numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));
          let denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));
          result[i] = this.field.multiply(numerator, denominator);
        }
        return result;
      }
    }
    class BoundingBox {
      constructor(image, topLeft, bottomLeft, topRight, bottomRight) {
        if (image instanceof BoundingBox) {
          this.constructor_2(image);
        } else {
          this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);
        }
      }
      /**
       *
       * @param image
       * @param topLeft
       * @param bottomLeft
       * @param topRight
       * @param bottomRight
       *
       * @throws NotFoundException
       */
      constructor_1(image, topLeft, bottomLeft, topRight, bottomRight) {
        const leftUnspecified = topLeft == null || bottomLeft == null;
        const rightUnspecified = topRight == null || bottomRight == null;
        if (leftUnspecified && rightUnspecified) {
          throw new NotFoundException();
        }
        if (leftUnspecified) {
          topLeft = new ResultPoint(0, topRight.getY());
          bottomLeft = new ResultPoint(0, bottomRight.getY());
        } else if (rightUnspecified) {
          topRight = new ResultPoint(image.getWidth() - 1, topLeft.getY());
          bottomRight = new ResultPoint(image.getWidth() - 1, bottomLeft.getY());
        }
        this.image = image;
        this.topLeft = topLeft;
        this.bottomLeft = bottomLeft;
        this.topRight = topRight;
        this.bottomRight = bottomRight;
        this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));
        this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));
        this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));
        this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));
      }
      constructor_2(boundingBox) {
        this.image = boundingBox.image;
        this.topLeft = boundingBox.getTopLeft();
        this.bottomLeft = boundingBox.getBottomLeft();
        this.topRight = boundingBox.getTopRight();
        this.bottomRight = boundingBox.getBottomRight();
        this.minX = boundingBox.getMinX();
        this.maxX = boundingBox.getMaxX();
        this.minY = boundingBox.getMinY();
        this.maxY = boundingBox.getMaxY();
      }
      /**
       * @throws NotFoundException
       */
      static merge(leftBox, rightBox) {
        if (leftBox == null) {
          return rightBox;
        }
        if (rightBox == null) {
          return leftBox;
        }
        return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);
      }
      /**
       * @throws NotFoundException
       */
      addMissingRows(missingStartRows, missingEndRows, isLeft) {
        let newTopLeft = this.topLeft;
        let newBottomLeft = this.bottomLeft;
        let newTopRight = this.topRight;
        let newBottomRight = this.bottomRight;
        if (missingStartRows > 0) {
          let top = isLeft ? this.topLeft : this.topRight;
          let newMinY = Math.trunc(top.getY() - missingStartRows);
          if (newMinY < 0) {
            newMinY = 0;
          }
          let newTop = new ResultPoint(top.getX(), newMinY);
          if (isLeft) {
            newTopLeft = newTop;
          } else {
            newTopRight = newTop;
          }
        }
        if (missingEndRows > 0) {
          let bottom = isLeft ? this.bottomLeft : this.bottomRight;
          let newMaxY = Math.trunc(bottom.getY() + missingEndRows);
          if (newMaxY >= this.image.getHeight()) {
            newMaxY = this.image.getHeight() - 1;
          }
          let newBottom = new ResultPoint(bottom.getX(), newMaxY);
          if (isLeft) {
            newBottomLeft = newBottom;
          } else {
            newBottomRight = newBottom;
          }
        }
        return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);
      }
      getMinX() {
        return this.minX;
      }
      getMaxX() {
        return this.maxX;
      }
      getMinY() {
        return this.minY;
      }
      getMaxY() {
        return this.maxY;
      }
      getTopLeft() {
        return this.topLeft;
      }
      getTopRight() {
        return this.topRight;
      }
      getBottomLeft() {
        return this.bottomLeft;
      }
      getBottomRight() {
        return this.bottomRight;
      }
    }
    class BarcodeMetadata {
      constructor(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {
        this.columnCount = columnCount;
        this.errorCorrectionLevel = errorCorrectionLevel;
        this.rowCountUpperPart = rowCountUpperPart;
        this.rowCountLowerPart = rowCountLowerPart;
        this.rowCount = rowCountUpperPart + rowCountLowerPart;
      }
      getColumnCount() {
        return this.columnCount;
      }
      getErrorCorrectionLevel() {
        return this.errorCorrectionLevel;
      }
      getRowCount() {
        return this.rowCount;
      }
      getRowCountUpperPart() {
        return this.rowCountUpperPart;
      }
      getRowCountLowerPart() {
        return this.rowCountLowerPart;
      }
    }
    class Formatter {
      constructor() {
        this.buffer = "";
      }
      /**
       *
       * @see https://stackoverflow.com/a/13439711/4367683
       *
       * @param str
       * @param arr
       */
      static form(str, arr) {
        let i = -1;
        function callback(exp, p0, p1, p2, p3, p4) {
          if (exp === "%%")
            return "%";
          if (arr[++i] === void 0)
            return void 0;
          exp = p2 ? parseInt(p2.substr(1)) : void 0;
          let base2 = p3 ? parseInt(p3.substr(1)) : void 0;
          let val;
          switch (p4) {
            case "s":
              val = arr[i];
              break;
            case "c":
              val = arr[i][0];
              break;
            case "f":
              val = parseFloat(arr[i]).toFixed(exp);
              break;
            case "p":
              val = parseFloat(arr[i]).toPrecision(exp);
              break;
            case "e":
              val = parseFloat(arr[i]).toExponential(exp);
              break;
            case "x":
              val = parseInt(arr[i]).toString(base2 ? base2 : 16);
              break;
            case "d":
              val = parseFloat(parseInt(arr[i], base2 ? base2 : 10).toPrecision(exp)).toFixed(0);
              break;
          }
          val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base2);
          let size = parseInt(p1);
          let ch = p1 && p1[0] + "" === "0" ? "0" : " ";
          while (val.length < size)
            val = p0 !== void 0 ? val + ch : ch + val;
          return val;
        }
        let regex2 = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
        return str.replace(regex2, callback);
      }
      /**
       *
       * @param append The new string to append.
       * @param args Argumets values to be formated.
       */
      format(append, ...args) {
        this.buffer += Formatter.form(append, args);
      }
      /**
       * Returns the Formatter string value.
       */
      toString() {
        return this.buffer;
      }
    }
    class DetectionResultColumn {
      constructor(boundingBox) {
        this.boundingBox = new BoundingBox(boundingBox);
        this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);
      }
      /*final*/
      getCodewordNearby(imageRow) {
        let codeword = this.getCodeword(imageRow);
        if (codeword != null) {
          return codeword;
        }
        for (let i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {
          let nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;
          if (nearImageRow >= 0) {
            codeword = this.codewords[nearImageRow];
            if (codeword != null) {
              return codeword;
            }
          }
          nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;
          if (nearImageRow < this.codewords.length) {
            codeword = this.codewords[nearImageRow];
            if (codeword != null) {
              return codeword;
            }
          }
        }
        return null;
      }
      /*final int*/
      imageRowToCodewordIndex(imageRow) {
        return imageRow - this.boundingBox.getMinY();
      }
      /*final void*/
      setCodeword(imageRow, codeword) {
        this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;
      }
      /*final*/
      getCodeword(imageRow) {
        return this.codewords[this.imageRowToCodewordIndex(imageRow)];
      }
      /*final*/
      getBoundingBox() {
        return this.boundingBox;
      }
      /*final*/
      getCodewords() {
        return this.codewords;
      }
      // @Override
      toString() {
        const formatter = new Formatter();
        let row = 0;
        for (const codeword of this.codewords) {
          if (codeword == null) {
            formatter.format("%3d:    |   %n", row++);
            continue;
          }
          formatter.format("%3d: %3d|%3d%n", row++, codeword.getRowNumber(), codeword.getValue());
        }
        return formatter.toString();
      }
    }
    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;
    class BarcodeValue {
      constructor() {
        this.values = /* @__PURE__ */ new Map();
      }
      /**
       * Add an occurrence of a value
       */
      setValue(value) {
        value = Math.trunc(value);
        let confidence = this.values.get(value);
        if (confidence == null) {
          confidence = 0;
        }
        confidence++;
        this.values.set(value, confidence);
      }
      /**
       * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.
       * @return an array of int, containing the values with the highest occurrence, or null, if no value was set
       */
      getValue() {
        let maxConfidence = -1;
        let result = new Array();
        for (const [key2, value] of this.values.entries()) {
          const entry = {
            getKey: () => key2,
            getValue: () => value
          };
          if (entry.getValue() > maxConfidence) {
            maxConfidence = entry.getValue();
            result = [];
            result.push(entry.getKey());
          } else if (entry.getValue() === maxConfidence) {
            result.push(entry.getKey());
          }
        }
        return PDF417Common.toIntArray(result);
      }
      getConfidence(value) {
        return this.values.get(value);
      }
    }
    class DetectionResultRowIndicatorColumn extends DetectionResultColumn {
      constructor(boundingBox, isLeft) {
        super(boundingBox);
        this._isLeft = isLeft;
      }
      setRowNumbers() {
        for (let codeword of this.getCodewords()) {
          if (codeword != null) {
            codeword.setRowNumberAsRowIndicatorColumn();
          }
        }
      }
      // TODO implement properly
      // TODO maybe we should add missing codewords to store the correct row number to make
      // finding row numbers for other columns easier
      // use row height count to make detection of invalid row numbers more reliable
      adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata) {
        let codewords = this.getCodewords();
        this.setRowNumbers();
        this.removeIncorrectCodewords(codewords, barcodeMetadata);
        let boundingBox = this.getBoundingBox();
        let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
        let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
        let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
        let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
        let barcodeRow = -1;
        let maxRowHeight = 1;
        let currentRowHeight = 0;
        for (let codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let codeword = codewords[codewordsRow];
          let rowDifference = codeword.getRowNumber() - barcodeRow;
          if (rowDifference === 0) {
            currentRowHeight++;
          } else if (rowDifference === 1) {
            maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
            currentRowHeight = 1;
            barcodeRow = codeword.getRowNumber();
          } else if (rowDifference < 0 || codeword.getRowNumber() >= barcodeMetadata.getRowCount() || rowDifference > codewordsRow) {
            codewords[codewordsRow] = null;
          } else {
            let checkedRows;
            if (maxRowHeight > 2) {
              checkedRows = (maxRowHeight - 2) * rowDifference;
            } else {
              checkedRows = rowDifference;
            }
            let closePreviousCodewordFound = checkedRows >= codewordsRow;
            for (let i = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {
              closePreviousCodewordFound = codewords[codewordsRow - i] != null;
            }
            if (closePreviousCodewordFound) {
              codewords[codewordsRow] = null;
            } else {
              barcodeRow = codeword.getRowNumber();
              currentRowHeight = 1;
            }
          }
        }
      }
      getRowHeights() {
        let barcodeMetadata = this.getBarcodeMetadata();
        if (barcodeMetadata == null) {
          return null;
        }
        this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);
        let result = new Int32Array(barcodeMetadata.getRowCount());
        for (let codeword of this.getCodewords()) {
          if (codeword != null) {
            let rowNumber = codeword.getRowNumber();
            if (rowNumber >= result.length) {
              continue;
            }
            result[rowNumber]++;
          }
        }
        return result;
      }
      // TODO maybe we should add missing codewords to store the correct row number to make
      // finding row numbers for other columns easier
      // use row height count to make detection of invalid row numbers more reliable
      adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata) {
        let boundingBox = this.getBoundingBox();
        let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
        let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
        let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
        let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
        let codewords = this.getCodewords();
        let barcodeRow = -1;
        for (let codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let codeword = codewords[codewordsRow];
          codeword.setRowNumberAsRowIndicatorColumn();
          let rowDifference = codeword.getRowNumber() - barcodeRow;
          if (rowDifference === 0) ;
          else if (rowDifference === 1) {
            barcodeRow = codeword.getRowNumber();
          } else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {
            codewords[codewordsRow] = null;
          } else {
            barcodeRow = codeword.getRowNumber();
          }
        }
      }
      getBarcodeMetadata() {
        let codewords = this.getCodewords();
        let barcodeColumnCount = new BarcodeValue();
        let barcodeRowCountUpperPart = new BarcodeValue();
        let barcodeRowCountLowerPart = new BarcodeValue();
        let barcodeECLevel = new BarcodeValue();
        for (let codeword of codewords) {
          if (codeword == null) {
            continue;
          }
          codeword.setRowNumberAsRowIndicatorColumn();
          let rowIndicatorValue = codeword.getValue() % 30;
          let codewordRowNumber = codeword.getRowNumber();
          if (!this._isLeft) {
            codewordRowNumber += 2;
          }
          switch (codewordRowNumber % 3) {
            case 0:
              barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);
              break;
            case 1:
              barcodeECLevel.setValue(rowIndicatorValue / 3);
              barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);
              break;
            case 2:
              barcodeColumnCount.setValue(rowIndicatorValue + 1);
              break;
          }
        }
        if (barcodeColumnCount.getValue().length === 0 || barcodeRowCountUpperPart.getValue().length === 0 || barcodeRowCountLowerPart.getValue().length === 0 || barcodeECLevel.getValue().length === 0 || barcodeColumnCount.getValue()[0] < 1 || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common.MIN_ROWS_IN_BARCODE || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common.MAX_ROWS_IN_BARCODE) {
          return null;
        }
        let barcodeMetadata = new BarcodeMetadata(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);
        this.removeIncorrectCodewords(codewords, barcodeMetadata);
        return barcodeMetadata;
      }
      removeIncorrectCodewords(codewords, barcodeMetadata) {
        for (let codewordRow = 0; codewordRow < codewords.length; codewordRow++) {
          let codeword = codewords[codewordRow];
          if (codewords[codewordRow] == null) {
            continue;
          }
          let rowIndicatorValue = codeword.getValue() % 30;
          let codewordRowNumber = codeword.getRowNumber();
          if (codewordRowNumber > barcodeMetadata.getRowCount()) {
            codewords[codewordRow] = null;
            continue;
          }
          if (!this._isLeft) {
            codewordRowNumber += 2;
          }
          switch (codewordRowNumber % 3) {
            case 0:
              if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {
                codewords[codewordRow] = null;
              }
              break;
            case 1:
              if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() || rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {
                codewords[codewordRow] = null;
              }
              break;
            case 2:
              if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {
                codewords[codewordRow] = null;
              }
              break;
          }
        }
      }
      isLeft() {
        return this._isLeft;
      }
      // @Override
      toString() {
        return "IsLeft: " + this._isLeft + "\n" + super.toString();
      }
    }
    class DetectionResult {
      constructor(barcodeMetadata, boundingBox) {
        this.ADJUST_ROW_NUMBER_SKIP = 2;
        this.barcodeMetadata = barcodeMetadata;
        this.barcodeColumnCount = barcodeMetadata.getColumnCount();
        this.boundingBox = boundingBox;
        this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);
      }
      getDetectionResultColumns() {
        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);
        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);
        let unadjustedCodewordCount = PDF417Common.MAX_CODEWORDS_IN_BARCODE;
        let previousUnadjustedCount;
        do {
          previousUnadjustedCount = unadjustedCodewordCount;
          unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();
        } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);
        return this.detectionResultColumns;
      }
      adjustIndicatorColumnRowNumbers(detectionResultColumn) {
        if (detectionResultColumn != null) {
          detectionResultColumn.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
        }
      }
      // TODO ensure that no detected codewords with unknown row number are left
      // we should be able to estimate the row height and use it as a hint for the row number
      // we should also fill the rows top to bottom and bottom to top
      /**
       * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords
       * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers
       */
      adjustRowNumbersAndGetCount() {
        let unadjustedCount = this.adjustRowNumbersByRow();
        if (unadjustedCount === 0) {
          return 0;
        }
        for (let barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {
          let codewords = this.detectionResultColumns[barcodeColumn].getCodewords();
          for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
              continue;
            }
            if (!codewords[codewordsRow].hasValidRowNumber()) {
              this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);
            }
          }
        }
        return unadjustedCount;
      }
      adjustRowNumbersByRow() {
        this.adjustRowNumbersFromBothRI();
        let unadjustedCount = this.adjustRowNumbersFromLRI();
        return unadjustedCount + this.adjustRowNumbersFromRRI();
      }
      adjustRowNumbersFromBothRI() {
        if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
          return;
        }
        let LRIcodewords = this.detectionResultColumns[0].getCodewords();
        let RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
        for (let codewordsRow = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {
          if (LRIcodewords[codewordsRow] != null && RRIcodewords[codewordsRow] != null && LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {
            for (let barcodeColumn = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {
              let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
              if (codeword == null) {
                continue;
              }
              codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());
              if (!codeword.hasValidRowNumber()) {
                this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;
              }
            }
          }
        }
      }
      adjustRowNumbersFromRRI() {
        if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
          return 0;
        }
        let unadjustedCount = 0;
        let codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
        for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
          let invalidRowCounts = 0;
          for (let barcodeColumn = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {
            let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword != null) {
              invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
              if (!codeword.hasValidRowNumber()) {
                unadjustedCount++;
              }
            }
          }
        }
        return unadjustedCount;
      }
      adjustRowNumbersFromLRI() {
        if (this.detectionResultColumns[0] == null) {
          return 0;
        }
        let unadjustedCount = 0;
        let codewords = this.detectionResultColumns[0].getCodewords();
        for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
          let invalidRowCounts = 0;
          for (let barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {
            let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword != null) {
              invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
              if (!codeword.hasValidRowNumber()) {
                unadjustedCount++;
              }
            }
          }
        }
        return unadjustedCount;
      }
      static adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword) {
        if (codeword == null) {
          return invalidRowCounts;
        }
        if (!codeword.hasValidRowNumber()) {
          if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {
            codeword.setRowNumber(rowIndicatorRowNumber);
            invalidRowCounts = 0;
          } else {
            ++invalidRowCounts;
          }
        }
        return invalidRowCounts;
      }
      adjustRowNumbers(barcodeColumn, codewordsRow, codewords) {
        if (!this.detectionResultColumns[barcodeColumn - 1]) {
          return;
        }
        let codeword = codewords[codewordsRow];
        let previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();
        let nextColumnCodewords = previousColumnCodewords;
        if (this.detectionResultColumns[barcodeColumn + 1] != null) {
          nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();
        }
        let otherCodewords = new Array(14);
        otherCodewords[2] = previousColumnCodewords[codewordsRow];
        otherCodewords[3] = nextColumnCodewords[codewordsRow];
        if (codewordsRow > 0) {
          otherCodewords[0] = codewords[codewordsRow - 1];
          otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];
          otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];
        }
        if (codewordsRow > 1) {
          otherCodewords[8] = codewords[codewordsRow - 2];
          otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];
          otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];
        }
        if (codewordsRow < codewords.length - 1) {
          otherCodewords[1] = codewords[codewordsRow + 1];
          otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];
          otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];
        }
        if (codewordsRow < codewords.length - 2) {
          otherCodewords[9] = codewords[codewordsRow + 2];
          otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];
          otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];
        }
        for (let otherCodeword of otherCodewords) {
          if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {
            return;
          }
        }
      }
      /**
       * @return true, if row number was adjusted, false otherwise
       */
      static adjustRowNumber(codeword, otherCodeword) {
        if (otherCodeword == null) {
          return false;
        }
        if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {
          codeword.setRowNumber(otherCodeword.getRowNumber());
          return true;
        }
        return false;
      }
      getBarcodeColumnCount() {
        return this.barcodeColumnCount;
      }
      getBarcodeRowCount() {
        return this.barcodeMetadata.getRowCount();
      }
      getBarcodeECLevel() {
        return this.barcodeMetadata.getErrorCorrectionLevel();
      }
      setBoundingBox(boundingBox) {
        this.boundingBox = boundingBox;
      }
      getBoundingBox() {
        return this.boundingBox;
      }
      setDetectionResultColumn(barcodeColumn, detectionResultColumn) {
        this.detectionResultColumns[barcodeColumn] = detectionResultColumn;
      }
      getDetectionResultColumn(barcodeColumn) {
        return this.detectionResultColumns[barcodeColumn];
      }
      // @Override
      toString() {
        let rowIndicatorColumn = this.detectionResultColumns[0];
        if (rowIndicatorColumn == null) {
          rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];
        }
        let formatter = new Formatter();
        for (let codewordsRow = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {
          formatter.format("CW %3d:", codewordsRow);
          for (let barcodeColumn = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {
            if (this.detectionResultColumns[barcodeColumn] == null) {
              formatter.format("    |   ");
              continue;
            }
            let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword == null) {
              formatter.format("    |   ");
              continue;
            }
            formatter.format(" %3d|%3d", codeword.getRowNumber(), codeword.getValue());
          }
          formatter.format("%n");
        }
        return formatter.toString();
      }
    }
    class Codeword {
      constructor(startX, endX, bucket, value) {
        this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;
        this.startX = Math.trunc(startX);
        this.endX = Math.trunc(endX);
        this.bucket = Math.trunc(bucket);
        this.value = Math.trunc(value);
      }
      hasValidRowNumber() {
        return this.isValidRowNumber(this.rowNumber);
      }
      isValidRowNumber(rowNumber) {
        return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === rowNumber % 3 * 3;
      }
      setRowNumberAsRowIndicatorColumn() {
        this.rowNumber = Math.trunc(Math.trunc(this.value / 30) * 3 + Math.trunc(this.bucket / 3));
      }
      getWidth() {
        return this.endX - this.startX;
      }
      getStartX() {
        return this.startX;
      }
      getEndX() {
        return this.endX;
      }
      getBucket() {
        return this.bucket;
      }
      getValue() {
        return this.value;
      }
      getRowNumber() {
        return this.rowNumber;
      }
      setRowNumber(rowNumber) {
        this.rowNumber = rowNumber;
      }
      //   @Override
      toString() {
        return this.rowNumber + "|" + this.value;
      }
    }
    Codeword.BARCODE_ROW_UNKNOWN = -1;
    class PDF417CodewordDecoder {
      /* @note
       * this action have to be performed before first use of class
       * - static constructor
       * working with 32bit float (based from Java logic)
      */
      static initialize() {
        for (let i = 0; i < PDF417Common.SYMBOL_TABLE.length; i++) {
          let currentSymbol = PDF417Common.SYMBOL_TABLE[i];
          let currentBit = currentSymbol & 1;
          for (let j = 0; j < PDF417Common.BARS_IN_MODULE; j++) {
            let size = 0;
            while ((currentSymbol & 1) === currentBit) {
              size += 1;
              currentSymbol >>= 1;
            }
            currentBit = currentSymbol & 1;
            if (!PDF417CodewordDecoder.RATIOS_TABLE[i]) {
              PDF417CodewordDecoder.RATIOS_TABLE[i] = new Array(PDF417Common.BARS_IN_MODULE);
            }
            PDF417CodewordDecoder.RATIOS_TABLE[i][PDF417Common.BARS_IN_MODULE - j - 1] = Math.fround(size / PDF417Common.MODULES_IN_CODEWORD);
          }
        }
        this.bSymbolTableReady = true;
      }
      static getDecodedValue(moduleBitCount) {
        let decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));
        if (decodedValue !== -1) {
          return decodedValue;
        }
        return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);
      }
      static sampleBitCounts(moduleBitCount) {
        let bitCountSum = MathUtils.sum(moduleBitCount);
        let result = new Int32Array(PDF417Common.BARS_IN_MODULE);
        let bitCountIndex = 0;
        let sumPreviousBits = 0;
        for (let i = 0; i < PDF417Common.MODULES_IN_CODEWORD; i++) {
          let sampleIndex = bitCountSum / (2 * PDF417Common.MODULES_IN_CODEWORD) + i * bitCountSum / PDF417Common.MODULES_IN_CODEWORD;
          if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {
            sumPreviousBits += moduleBitCount[bitCountIndex];
            bitCountIndex++;
          }
          result[bitCountIndex]++;
        }
        return result;
      }
      static getDecodedCodewordValue(moduleBitCount) {
        let decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);
        return PDF417Common.getCodeword(decodedValue) === -1 ? -1 : decodedValue;
      }
      static getBitValue(moduleBitCount) {
        let result = (
          /*long*/
          0
        );
        for (let i = 0; i < moduleBitCount.length; i++) {
          for (let bit = 0; bit < moduleBitCount[i]; bit++) {
            result = result << 1 | (i % 2 === 0 ? 1 : 0);
          }
        }
        return Math.trunc(result);
      }
      // working with 32bit float (as in Java)
      static getClosestDecodedValue(moduleBitCount) {
        let bitCountSum = MathUtils.sum(moduleBitCount);
        let bitCountRatios = new Array(PDF417Common.BARS_IN_MODULE);
        if (bitCountSum > 1) {
          for (let i = 0; i < bitCountRatios.length; i++) {
            bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);
          }
        }
        let bestMatchError = Float.MAX_VALUE;
        let bestMatch = -1;
        if (!this.bSymbolTableReady) {
          PDF417CodewordDecoder.initialize();
        }
        for (let j = 0; j < PDF417CodewordDecoder.RATIOS_TABLE.length; j++) {
          let error = 0;
          let ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j];
          for (let k = 0; k < PDF417Common.BARS_IN_MODULE; k++) {
            let diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);
            error += Math.fround(diff * diff);
            if (error >= bestMatchError) {
              break;
            }
          }
          if (error < bestMatchError) {
            bestMatchError = error;
            bestMatch = PDF417Common.SYMBOL_TABLE[j];
          }
        }
        return bestMatch;
      }
    }
    PDF417CodewordDecoder.bSymbolTableReady = false;
    PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common.SYMBOL_TABLE.length).map((x) => new Array(PDF417Common.BARS_IN_MODULE));
    class PDF417ResultMetadata {
      constructor() {
        this.segmentCount = -1;
        this.fileSize = -1;
        this.timestamp = -1;
        this.checksum = -1;
      }
      /**
       * The Segment ID represents the segment of the whole file distributed over different symbols.
       *
       * @return File segment index
       */
      getSegmentIndex() {
        return this.segmentIndex;
      }
      setSegmentIndex(segmentIndex) {
        this.segmentIndex = segmentIndex;
      }
      /**
       * Is the same for each related PDF417 symbol
       *
       * @return File ID
       */
      getFileId() {
        return this.fileId;
      }
      setFileId(fileId) {
        this.fileId = fileId;
      }
      /**
       * @return always null
       * @deprecated use dedicated already parsed fields
       */
      //   @Deprecated
      getOptionalData() {
        return this.optionalData;
      }
      /**
       * @param optionalData old optional data format as int array
       * @deprecated parse and use new fields
       */
      //   @Deprecated
      setOptionalData(optionalData) {
        this.optionalData = optionalData;
      }
      /**
       * @return true if it is the last segment
       */
      isLastSegment() {
        return this.lastSegment;
      }
      setLastSegment(lastSegment) {
        this.lastSegment = lastSegment;
      }
      /**
       * @return count of segments, -1 if not set
       */
      getSegmentCount() {
        return this.segmentCount;
      }
      setSegmentCount(segmentCount) {
        this.segmentCount = segmentCount;
      }
      getSender() {
        return this.sender || null;
      }
      setSender(sender) {
        this.sender = sender;
      }
      getAddressee() {
        return this.addressee || null;
      }
      setAddressee(addressee) {
        this.addressee = addressee;
      }
      /**
       * Filename of the encoded file
       *
       * @return filename
       */
      getFileName() {
        return this.fileName;
      }
      setFileName(fileName) {
        this.fileName = fileName;
      }
      /**
       * filesize in bytes of the encoded file
       *
       * @return filesize in bytes, -1 if not set
       */
      getFileSize() {
        return this.fileSize;
      }
      setFileSize(fileSize) {
        this.fileSize = fileSize;
      }
      /**
       * 16-bit CRC checksum using CCITT-16
       *
       * @return crc checksum, -1 if not set
       */
      getChecksum() {
        return this.checksum;
      }
      setChecksum(checksum) {
        this.checksum = checksum;
      }
      /**
       * unix epock timestamp, elapsed seconds since 1970-01-01
       *
       * @return elapsed seconds, -1 if not set
       */
      getTimestamp() {
        return this.timestamp;
      }
      setTimestamp(timestamp) {
        this.timestamp = timestamp;
      }
    }
    class Long {
      /**
       * Parses a string to a number, since JS has no really Int64.
       *
       * @param num Numeric string.
       * @param radix Destination radix.
       */
      static parseLong(num, radix = void 0) {
        return parseInt(num, radix);
      }
    }
    class NullPointerException extends Exception {
    }
    NullPointerException.kind = "NullPointerException";
    class OutputStream {
      /**
       * Writes <code>b.length</code> bytes from the specified byte array
       * to this output stream. The general contract for <code>write(b)</code>
       * is that it should have exactly the same effect as the call
       * <code>write(b, 0, b.length)</code>.
       *
       * @param      b   the data.
       * @exception  IOException  if an I/O error occurs.
       * @see        java.io.OutputStream#write(byte[], int, int)
       */
      writeBytes(b) {
        this.writeBytesOffset(b, 0, b.length);
      }
      /**
       * Writes <code>len</code> bytes from the specified byte array
       * starting at offset <code>off</code> to this output stream.
       * The general contract for <code>write(b, off, len)</code> is that
       * some of the bytes in the array <code>b</code> are written to the
       * output stream in order; element <code>b[off]</code> is the first
       * byte written and <code>b[off+len-1]</code> is the last byte written
       * by this operation.
       * <p>
       * The <code>write</code> method of <code>OutputStream</code> calls
       * the write method of one argument on each of the bytes to be
       * written out. Subclasses are encouraged to override this method and
       * provide a more efficient implementation.
       * <p>
       * If <code>b</code> is <code>null</code>, a
       * <code>NullPointerException</code> is thrown.
       * <p>
       * If <code>off</code> is negative, or <code>len</code> is negative, or
       * <code>off+len</code> is greater than the length of the array
       * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.
       *
       * @param      b     the data.
       * @param      off   the start offset in the data.
       * @param      len   the number of bytes to write.
       * @exception  IOException  if an I/O error occurs. In particular,
       *             an <code>IOException</code> is thrown if the output
       *             stream is closed.
       */
      writeBytesOffset(b, off, len) {
        if (b == null) {
          throw new NullPointerException();
        } else if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
          throw new IndexOutOfBoundsException();
        } else if (len === 0) {
          return;
        }
        for (let i = 0; i < len; i++) {
          this.write(b[off + i]);
        }
      }
      /**
       * Flushes this output stream and forces any buffered output bytes
       * to be written out. The general contract of <code>flush</code> is
       * that calling it is an indication that, if any bytes previously
       * written have been buffered by the implementation of the output
       * stream, such bytes should immediately be written to their
       * intended destination.
       * <p>
       * If the intended destination of this stream is an abstraction provided by
       * the underlying operating system, for example a file, then flushing the
       * stream guarantees only that bytes previously written to the stream are
       * passed to the operating system for writing; it does not guarantee that
       * they are actually written to a physical device such as a disk drive.
       * <p>
       * The <code>flush</code> method of <code>OutputStream</code> does nothing.
       *
       * @exception  IOException  if an I/O error occurs.
       */
      flush() {
      }
      /**
       * Closes this output stream and releases any system resources
       * associated with this stream. The general contract of <code>close</code>
       * is that it closes the output stream. A closed stream cannot perform
       * output operations and cannot be reopened.
       * <p>
       * The <code>close</code> method of <code>OutputStream</code> does nothing.
       *
       * @exception  IOException  if an I/O error occurs.
       */
      close() {
      }
    }
    class OutOfMemoryError extends Exception {
    }
    class ByteArrayOutputStream extends OutputStream {
      /**
       * Creates a new byte array output stream. The buffer capacity is
       * initially 32 bytes, though its size increases if necessary.
       */
      // public constructor() {
      //     this(32);
      // }
      /**
       * Creates a new byte array output stream, with a buffer capacity of
       * the specified size, in bytes.
       *
       * @param   size   the initial size.
       * @exception  IllegalArgumentException if size is negative.
       */
      constructor(size = 32) {
        super();
        this.count = 0;
        if (size < 0) {
          throw new IllegalArgumentException("Negative initial size: " + size);
        }
        this.buf = new Uint8Array(size);
      }
      /**
       * Increases the capacity if necessary to ensure that it can hold
       * at least the number of elements specified by the minimum
       * capacity argument.
       *
       * @param minCapacity the desired minimum capacity
       * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is
       * interpreted as a request for the unsatisfiably large capacity
       * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.
       */
      ensureCapacity(minCapacity) {
        if (minCapacity - this.buf.length > 0)
          this.grow(minCapacity);
      }
      /**
       * Increases the capacity to ensure that it can hold at least the
       * number of elements specified by the minimum capacity argument.
       *
       * @param minCapacity the desired minimum capacity
       */
      grow(minCapacity) {
        let oldCapacity = this.buf.length;
        let newCapacity = oldCapacity << 1;
        if (newCapacity - minCapacity < 0)
          newCapacity = minCapacity;
        if (newCapacity < 0) {
          if (minCapacity < 0)
            throw new OutOfMemoryError();
          newCapacity = Integer.MAX_VALUE;
        }
        this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);
      }
      /**
       * Writes the specified byte to this byte array output stream.
       *
       * @param   b   the byte to be written.
       */
      write(b) {
        this.ensureCapacity(this.count + 1);
        this.buf[this.count] = /*(byte)*/
        b;
        this.count += 1;
      }
      /**
       * Writes <code>len</code> bytes from the specified byte array
       * starting at offset <code>off</code> to this byte array output stream.
       *
       * @param   b     the data.
       * @param   off   the start offset in the data.
       * @param   len   the number of bytes to write.
       */
      writeBytesOffset(b, off, len) {
        if (off < 0 || off > b.length || len < 0 || off + len - b.length > 0) {
          throw new IndexOutOfBoundsException();
        }
        this.ensureCapacity(this.count + len);
        System.arraycopy(b, off, this.buf, this.count, len);
        this.count += len;
      }
      /**
       * Writes the complete contents of this byte array output stream to
       * the specified output stream argument, as if by calling the output
       * stream's write method using <code>out.write(buf, 0, count)</code>.
       *
       * @param      out   the output stream to which to write the data.
       * @exception  IOException  if an I/O error occurs.
       */
      writeTo(out) {
        out.writeBytesOffset(this.buf, 0, this.count);
      }
      /**
       * Resets the <code>count</code> field of this byte array output
       * stream to zero, so that all currently accumulated output in the
       * output stream is discarded. The output stream can be used again,
       * reusing the already allocated buffer space.
       *
       * @see     java.io.ByteArrayInputStream#count
       */
      reset() {
        this.count = 0;
      }
      /**
       * Creates a newly allocated byte array. Its size is the current
       * size of this output stream and the valid contents of the buffer
       * have been copied into it.
       *
       * @return  the current contents of this output stream, as a byte array.
       * @see     java.io.ByteArrayOutputStream#size()
       */
      toByteArray() {
        return Arrays.copyOfUint8Array(this.buf, this.count);
      }
      /**
       * Returns the current size of the buffer.
       *
       * @return  the value of the <code>count</code> field, which is the number
       *          of valid bytes in this output stream.
       * @see     java.io.ByteArrayOutputStream#count
       */
      size() {
        return this.count;
      }
      toString(param) {
        if (!param) {
          return this.toString_void();
        }
        if (typeof param === "string") {
          return this.toString_string(param);
        }
        return this.toString_number(param);
      }
      /**
       * Converts the buffer's contents into a string decoding bytes using the
       * platform's default character set. The length of the new <tt>String</tt>
       * is a function of the character set, and hence may not be equal to the
       * size of the buffer.
       *
       * <p> This method always replaces malformed-input and unmappable-character
       * sequences with the default replacement string for the platform's
       * default character set. The {@linkplain java.nio.charset.CharsetDecoder}
       * class should be used when more control over the decoding process is
       * required.
       *
       * @return String decoded from the buffer's contents.
       * @since  JDK1.1
       */
      toString_void() {
        return new String(
          this.buf
          /*, 0, this.count*/
        ).toString();
      }
      /**
       * Converts the buffer's contents into a string by decoding the bytes using
       * the specified {@link java.nio.charset.Charset charsetName}. The length of
       * the new <tt>String</tt> is a function of the charset, and hence may not be
       * equal to the length of the byte array.
       *
       * <p> This method always replaces malformed-input and unmappable-character
       * sequences with this charset's default replacement string. The {@link
       * java.nio.charset.CharsetDecoder} class should be used when more control
       * over the decoding process is required.
       *
       * @param  charsetName  the name of a supported
       *              {@linkplain java.nio.charset.Charset </code>charset<code>}
       * @return String decoded from the buffer's contents.
       * @exception  UnsupportedEncodingException
       *             If the named charset is not supported
       * @since   JDK1.1
       */
      toString_string(charsetName) {
        return new String(
          this.buf
          /*, 0, this.count, charsetName*/
        ).toString();
      }
      /**
       * Creates a newly allocated string. Its size is the current size of
       * the output stream and the valid contents of the buffer have been
       * copied into it. Each character <i>c</i> in the resulting string is
       * constructed from the corresponding element <i>b</i> in the byte
       * array such that:
       * <blockquote><pre>
       *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
       * </pre></blockquote>
       *
       * @deprecated This method does not properly convert bytes into characters.
       * As of JDK&nbsp;1.1, the preferred way to do this is via the
       * <code>toString(String enc)</code> method, which takes an encoding-name
       * argument, or the <code>toString()</code> method, which uses the
       * platform's default character encoding.
       *
       * @param      hibyte    the high byte of each resulting Unicode character.
       * @return     the current contents of the output stream, as a string.
       * @see        java.io.ByteArrayOutputStream#size()
       * @see        java.io.ByteArrayOutputStream#toString(String)
       * @see        java.io.ByteArrayOutputStream#toString()
       */
      // @Deprecated
      toString_number(hibyte) {
        return new String(
          this.buf
          /*, hibyte, 0, this.count*/
        ).toString();
      }
      /**
       * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
       * this class can be called after the stream has been closed without
       * generating an <tt>IOException</tt>.
       * <p>
       *
       * @throws IOException
       */
      close() {
      }
    }
    var Mode$2;
    (function(Mode2) {
      Mode2[Mode2["ALPHA"] = 0] = "ALPHA";
      Mode2[Mode2["LOWER"] = 1] = "LOWER";
      Mode2[Mode2["MIXED"] = 2] = "MIXED";
      Mode2[Mode2["PUNCT"] = 3] = "PUNCT";
      Mode2[Mode2["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";
      Mode2[Mode2["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";
    })(Mode$2 || (Mode$2 = {}));
    function getBigIntConstructor() {
      if (typeof window !== "undefined") {
        return window["BigInt"] || null;
      }
      if (typeof commonjsGlobal !== "undefined") {
        return commonjsGlobal["BigInt"] || null;
      }
      if (typeof self !== "undefined") {
        return self["BigInt"] || null;
      }
      throw new Error("Can't search globals for BigInt!");
    }
    let BigInteger2;
    function createBigInt(num) {
      if (typeof BigInteger2 === "undefined") {
        BigInteger2 = getBigIntConstructor();
      }
      if (BigInteger2 === null) {
        throw new Error("BigInt is not supported!");
      }
      return BigInteger2(num);
    }
    function getEXP900() {
      let EXP900 = [];
      EXP900[0] = createBigInt(1);
      let nineHundred = createBigInt(900);
      EXP900[1] = nineHundred;
      for (let i = 2; i < 16; i++) {
        EXP900[i] = EXP900[i - 1] * nineHundred;
      }
      return EXP900;
    }
    class DecodedBitStreamParser$2 {
      //   private DecodedBitStreamParser() {
      // }
      /**
       *
       * @param codewords
       * @param ecLevel
       *
       * @throws FormatException
       */
      static decode(codewords, ecLevel) {
        let result = new StringBuilder("");
        let encoding = CharacterSetECI.ISO8859_1;
        result.enableDecoding(encoding);
        let codeIndex = 1;
        let code = codewords[codeIndex++];
        let resultMetadata = new PDF417ResultMetadata();
        while (codeIndex < codewords[0]) {
          switch (code) {
            case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
              codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
              break;
            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
              codeIndex = DecodedBitStreamParser$2.byteCompaction(code, codewords, encoding, codeIndex, result);
              break;
            case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
              result.append(
                /*(char)*/
                codewords[codeIndex++]
              );
              break;
            case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
              codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex, result);
              break;
            case DecodedBitStreamParser$2.ECI_CHARSET:
              CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);
              break;
            case DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE:
              codeIndex += 2;
              break;
            case DecodedBitStreamParser$2.ECI_USER_DEFINED:
              codeIndex++;
              break;
            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              codeIndex = DecodedBitStreamParser$2.decodeMacroBlock(codewords, codeIndex, resultMetadata);
              break;
            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
            case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
              throw new FormatException();
            default:
              codeIndex--;
              codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
              break;
          }
          if (codeIndex < codewords.length) {
            code = codewords[codeIndex++];
          } else {
            throw FormatException.getFormatInstance();
          }
        }
        if (result.length() === 0) {
          throw FormatException.getFormatInstance();
        }
        let decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);
        decoderResult.setOther(resultMetadata);
        return decoderResult;
      }
      /**
       *
       * @param int
       * @param param1
       * @param codewords
       * @param int
       * @param codeIndex
       * @param PDF417ResultMetadata
       * @param resultMetadata
       *
       * @throws FormatException
       */
      // @SuppressWarnings("deprecation")
      static decodeMacroBlock(codewords, codeIndex, resultMetadata) {
        if (codeIndex + DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
          throw FormatException.getFormatInstance();
        }
        let segmentIndexArray = new Int32Array(DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS);
        for (let i = 0; i < DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {
          segmentIndexArray[i] = codewords[codeIndex];
        }
        resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser$2.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS)));
        let fileId = new StringBuilder();
        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, fileId);
        resultMetadata.setFileId(fileId.toString());
        let optionalFieldsStart = -1;
        if (codewords[codeIndex] === DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
          optionalFieldsStart = codeIndex + 1;
        }
        while (codeIndex < codewords[0]) {
          switch (codewords[codeIndex]) {
            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              codeIndex++;
              switch (codewords[codeIndex]) {
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                  let fileName = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, fileName);
                  resultMetadata.setFileName(fileName.toString());
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                  let sender = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, sender);
                  resultMetadata.setSender(sender.toString());
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                  let addressee = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, addressee);
                  resultMetadata.setAddressee(addressee.toString());
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                  let segmentCount = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, segmentCount);
                  resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                  let timestamp = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, timestamp);
                  resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                  let checksum = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, checksum);
                  resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                  let fileSize = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, fileSize);
                  resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));
                  break;
                default:
                  throw FormatException.getFormatInstance();
              }
              break;
            case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
              codeIndex++;
              resultMetadata.setLastSegment(true);
              break;
            default:
              throw FormatException.getFormatInstance();
          }
        }
        if (optionalFieldsStart !== -1) {
          let optionalFieldsLength = codeIndex - optionalFieldsStart;
          if (resultMetadata.isLastSegment()) {
            optionalFieldsLength--;
          }
          resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
        }
        return codeIndex;
      }
      /**
       * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be
       * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as
       * well as selected control characters.
       *
       * @param codewords The array of codewords (data + error)
       * @param codeIndex The current index into the codeword array.
       * @param result    The decoded data is appended to the result.
       * @return The next index into the codeword array.
       */
      static textCompaction(codewords, codeIndex, result) {
        let textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
        let byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
        let index2 = 0;
        let end = false;
        while (codeIndex < codewords[0] && !end) {
          let code = codewords[codeIndex++];
          if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
            textCompactionData[index2] = code / 30;
            textCompactionData[index2 + 1] = code % 30;
            index2 += 2;
          } else {
            switch (code) {
              case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                textCompactionData[index2++] = DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH;
                break;
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
              case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                codeIndex--;
                end = true;
                break;
              case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                textCompactionData[index2] = DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                code = codewords[codeIndex++];
                byteCompactionData[index2] = code;
                index2++;
                break;
            }
          }
        }
        DecodedBitStreamParser$2.decodeTextCompaction(textCompactionData, byteCompactionData, index2, result);
        return codeIndex;
      }
      /**
       * The Text Compaction mode includes all the printable ASCII characters
       * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab
       * (9: e), LF or line feed (10: e), and CR or carriage
       * return (13: e). The Text Compaction mode also includes various latch
       * and shift characters which are used exclusively within the mode. The Text
       * Compaction mode encodes up to 2 characters per codeword. The compaction rules
       * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode
       * switches are defined in 5.4.2.3.
       *
       * @param textCompactionData The text compaction data.
       * @param byteCompactionData The byte compaction data if there
       *                           was a mode shift.
       * @param length             The size of the text compaction and byte compaction data.
       * @param result             The decoded data is appended to the result.
       */
      static decodeTextCompaction(textCompactionData, byteCompactionData, length, result) {
        let subMode = Mode$2.ALPHA;
        let priorToShiftMode = Mode$2.ALPHA;
        let i = 0;
        while (i < length) {
          let subModeCh = textCompactionData[i];
          let ch = (
            /*char*/
            ""
          );
          switch (subMode) {
            case Mode$2.ALPHA:
              if (subModeCh < 26) {
                ch = /*(char)('A' + subModeCh) */
                String.fromCharCode(65 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser$2.LL:
                    subMode = Mode$2.LOWER;
                    break;
                  case DecodedBitStreamParser$2.ML:
                    subMode = Mode$2.MIXED;
                    break;
                  case DecodedBitStreamParser$2.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i]
                    );
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.LOWER:
              if (subModeCh < 26) {
                ch = /*(char)('a' + subModeCh)*/
                String.fromCharCode(97 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser$2.AS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.ALPHA_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.ML:
                    subMode = Mode$2.MIXED;
                    break;
                  case DecodedBitStreamParser$2.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i]
                    );
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.MIXED:
              if (subModeCh < DecodedBitStreamParser$2.PL) {
                ch = DecodedBitStreamParser$2.MIXED_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser$2.PL:
                    subMode = Mode$2.PUNCT;
                    break;
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser$2.LL:
                    subMode = Mode$2.LOWER;
                    break;
                  case DecodedBitStreamParser$2.AL:
                    subMode = Mode$2.ALPHA;
                    break;
                  case DecodedBitStreamParser$2.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i]
                    );
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.PUNCT:
              if (subModeCh < DecodedBitStreamParser$2.PAL) {
                ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser$2.PAL:
                    subMode = Mode$2.ALPHA;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i]
                    );
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.ALPHA_SHIFT:
              subMode = priorToShiftMode;
              if (subModeCh < 26) {
                ch = /*(char)('A' + subModeCh)*/
                String.fromCharCode(65 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.PUNCT_SHIFT:
              subMode = priorToShiftMode;
              if (subModeCh < DecodedBitStreamParser$2.PAL) {
                ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser$2.PAL:
                    subMode = Mode$2.ALPHA;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i]
                    );
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
          }
          if (ch !== "") {
            result.append(ch);
          }
          i++;
        }
      }
      /**
       * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.
       * This includes all ASCII characters value 0 to 127 inclusive and provides for international
       * character set support.
       *
       * @param mode      The byte compaction mode i.e. 901 or 924
       * @param codewords The array of codewords (data + error)
       * @param encoding  Currently active character encoding
       * @param codeIndex The current index into the codeword array.
       * @param result    The decoded data is appended to the result.
       * @return The next index into the codeword array.
       */
      static byteCompaction(mode, codewords, encoding, codeIndex, result) {
        let decodedBytes = new ByteArrayOutputStream();
        let count = 0;
        let value = (
          /*long*/
          0
        );
        let end = false;
        switch (mode) {
          case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
            let byteCompactedCodewords = new Int32Array(6);
            let nextCode = codewords[codeIndex++];
            while (codeIndex < codewords[0] && !end) {
              byteCompactedCodewords[count++] = nextCode;
              value = 900 * value + nextCode;
              nextCode = codewords[codeIndex++];
              switch (nextCode) {
                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                  codeIndex--;
                  end = true;
                  break;
                default:
                  if (count % 5 === 0 && count > 0) {
                    for (let j = 0; j < 6; ++j) {
                      decodedBytes.write(
                        /*(byte)*/
                        Number(createBigInt(value) >> createBigInt(8 * (5 - j)))
                      );
                    }
                    value = 0;
                    count = 0;
                  }
                  break;
              }
            }
            if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
              byteCompactedCodewords[count++] = nextCode;
            }
            for (let i = 0; i < count; i++) {
              decodedBytes.write(
                /*(byte)*/
                byteCompactedCodewords[i]
              );
            }
            break;
          case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
            while (codeIndex < codewords[0] && !end) {
              let code = codewords[codeIndex++];
              if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                count++;
                value = 900 * value + code;
              } else {
                switch (code) {
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                    codeIndex--;
                    end = true;
                    break;
                }
              }
              if (count % 5 === 0 && count > 0) {
                for (let j = 0; j < 6; ++j) {
                  decodedBytes.write(
                    /*(byte)*/
                    Number(createBigInt(value) >> createBigInt(8 * (5 - j)))
                  );
                }
                value = 0;
                count = 0;
              }
            }
            break;
        }
        result.append(StringEncoding.decode(decodedBytes.toByteArray(), encoding));
        return codeIndex;
      }
      /**
       * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.
       *
       * @param codewords The array of codewords (data + error)
       * @param codeIndex The current index into the codeword array.
       * @param result    The decoded data is appended to the result.
       * @return The next index into the codeword array.
       *
       * @throws FormatException
       */
      static numericCompaction(codewords, codeIndex, result) {
        let count = 0;
        let end = false;
        let numericCodewords = new Int32Array(DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS);
        while (codeIndex < codewords[0] && !end) {
          let code = codewords[codeIndex++];
          if (codeIndex === codewords[0]) {
            end = true;
          }
          if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
            numericCodewords[count] = code;
            count++;
          } else {
            switch (code) {
              case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                codeIndex--;
                end = true;
                break;
            }
          }
          if ((count % DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {
            result.append(DecodedBitStreamParser$2.decodeBase900toBase10(numericCodewords, count));
            count = 0;
          }
        }
        return codeIndex;
      }
      /**
       * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.
       *
       * @param codewords The array of codewords
       * @param count     The number of codewords
       * @return The decoded string representing the Numeric data.
       *
       * EXAMPLE
       * Encode the fifteen digit numeric string 000213298174000
       * Prefix the numeric string with a 1 and set the initial value of
       * t = 1 000 213 298 174 000
       * Calculate codeword 0
       * d0 = 1 000 213 298 174 000 mod 900 = 200
       *
       * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082
       * Calculate codeword 1
       * d1 = 1 111 348 109 082 mod 900 = 282
       *
       * t = 1 111 348 109 082 div 900 = 1 234 831 232
       * Calculate codeword 2
       * d2 = 1 234 831 232 mod 900 = 632
       *
       * t = 1 234 831 232 div 900 = 1 372 034
       * Calculate codeword 3
       * d3 = 1 372 034 mod 900 = 434
       *
       * t = 1 372 034 div 900 = 1 524
       * Calculate codeword 4
       * d4 = 1 524 mod 900 = 624
       *
       * t = 1 524 div 900 = 1
       * Calculate codeword 5
       * d5 = 1 mod 900 = 1
       * t = 1 div 900 = 0
       * Codeword sequence is: 1, 624, 434, 632, 282, 200
       *
       * Decode the above codewords involves
       *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +
       * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000
       *
       * Remove leading 1 =>  Result is 000213298174000
       *
       * @throws FormatException
       */
      static decodeBase900toBase10(codewords, count) {
        let result = createBigInt(0);
        for (let i = 0; i < count; i++) {
          result += DecodedBitStreamParser$2.EXP900[count - i - 1] * createBigInt(codewords[i]);
        }
        let resultString = result.toString();
        if (resultString.charAt(0) !== "1") {
          throw new FormatException();
        }
        return resultString.substring(1);
      }
    }
    DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH = 900;
    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH = 901;
    DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH = 902;
    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6 = 924;
    DecodedBitStreamParser$2.ECI_USER_DEFINED = 925;
    DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE = 926;
    DecodedBitStreamParser$2.ECI_CHARSET = 927;
    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
    DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR = 922;
    DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
    DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS = 15;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
    DecodedBitStreamParser$2.PL = 25;
    DecodedBitStreamParser$2.LL = 27;
    DecodedBitStreamParser$2.AS = 27;
    DecodedBitStreamParser$2.ML = 28;
    DecodedBitStreamParser$2.AL = 28;
    DecodedBitStreamParser$2.PS = 29;
    DecodedBitStreamParser$2.PAL = 29;
    DecodedBitStreamParser$2.PUNCT_CHARS = ";<>@[\\]_`~!\r	,:\n-.$/\"|*()?{}'";
    DecodedBitStreamParser$2.MIXED_CHARS = "0123456789&\r	,:#-.$/+%*=^";
    DecodedBitStreamParser$2.EXP900 = getBigIntConstructor() ? getEXP900() : [];
    DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS = 2;
    class PDF417ScanningDecoder {
      constructor() {
      }
      /**
       * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern
       *
       * columns. That way width can be deducted from the pattern column.
       * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider
       * than it should be. This can happen if the scanner used a bad blackpoint.
       *
       * @param BitMatrix
       * @param image
       * @param ResultPoint
       * @param imageTopLeft
       * @param ResultPoint
       * @param imageBottomLeft
       * @param ResultPoint
       * @param imageTopRight
       * @param ResultPoint
       * @param imageBottomRight
       * @param int
       * @param minCodewordWidth
       * @param int
       * @param maxCodewordWidth
       *
       * @throws NotFoundException
       * @throws FormatException
       * @throws ChecksumException
       */
      static decode(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {
        let boundingBox = new BoundingBox(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);
        let leftRowIndicatorColumn = null;
        let rightRowIndicatorColumn = null;
        let detectionResult;
        for (let firstPass = true; ; firstPass = false) {
          if (imageTopLeft != null) {
            leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);
          }
          if (imageTopRight != null) {
            rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);
          }
          detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);
          if (detectionResult == null) {
            throw NotFoundException.getNotFoundInstance();
          }
          let resultBox = detectionResult.getBoundingBox();
          if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {
            boundingBox = resultBox;
          } else {
            break;
          }
        }
        detectionResult.setBoundingBox(boundingBox);
        let maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;
        detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);
        detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);
        let leftToRight = leftRowIndicatorColumn != null;
        for (let barcodeColumnCount = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {
          let barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;
          if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */
          void 0) {
            continue;
          }
          let detectionResultColumn;
          if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {
            detectionResultColumn = new DetectionResultRowIndicatorColumn(boundingBox, barcodeColumn === 0);
          } else {
            detectionResultColumn = new DetectionResultColumn(boundingBox);
          }
          detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);
          let startColumn = -1;
          let previousStartColumn = startColumn;
          for (let imageRow = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {
            startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);
            if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {
              if (previousStartColumn === -1) {
                continue;
              }
              startColumn = previousStartColumn;
            }
            let codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
            if (codeword != null) {
              detectionResultColumn.setCodeword(imageRow, codeword);
              previousStartColumn = startColumn;
              minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());
              maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());
            }
          }
        }
        return PDF417ScanningDecoder.createDecoderResult(detectionResult);
      }
      /**
       *
       * @param leftRowIndicatorColumn
       * @param rightRowIndicatorColumn
       *
       * @throws NotFoundException
       */
      static merge(leftRowIndicatorColumn, rightRowIndicatorColumn) {
        if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {
          return null;
        }
        let barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);
        if (barcodeMetadata == null) {
          return null;
        }
        let boundingBox = BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));
        return new DetectionResult(barcodeMetadata, boundingBox);
      }
      /**
       *
       * @param rowIndicatorColumn
       *
       * @throws NotFoundException
       */
      static adjustBoundingBox(rowIndicatorColumn) {
        if (rowIndicatorColumn == null) {
          return null;
        }
        let rowHeights = rowIndicatorColumn.getRowHeights();
        if (rowHeights == null) {
          return null;
        }
        let maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);
        let missingStartRows = 0;
        for (let rowHeight of rowHeights) {
          missingStartRows += maxRowHeight - rowHeight;
          if (rowHeight > 0) {
            break;
          }
        }
        let codewords = rowIndicatorColumn.getCodewords();
        for (let row = 0; missingStartRows > 0 && codewords[row] == null; row++) {
          missingStartRows--;
        }
        let missingEndRows = 0;
        for (let row = rowHeights.length - 1; row >= 0; row--) {
          missingEndRows += maxRowHeight - rowHeights[row];
          if (rowHeights[row] > 0) {
            break;
          }
        }
        for (let row = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {
          missingEndRows--;
        }
        return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());
      }
      static getMax(values) {
        let maxValue = -1;
        for (let value of values) {
          maxValue = Math.max(maxValue, value);
        }
        return maxValue;
      }
      static getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn) {
        let leftBarcodeMetadata;
        if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {
          return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();
        }
        let rightBarcodeMetadata;
        if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {
          return leftBarcodeMetadata;
        }
        if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {
          return null;
        }
        return leftBarcodeMetadata;
      }
      static getRowIndicatorColumn(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {
        let rowIndicatorColumn = new DetectionResultRowIndicatorColumn(boundingBox, leftToRight);
        for (let i = 0; i < 2; i++) {
          let increment = i === 0 ? 1 : -1;
          let startColumn = Math.trunc(Math.trunc(startPoint.getX()));
          for (let imageRow = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment) {
            let codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
            if (codeword != null) {
              rowIndicatorColumn.setCodeword(imageRow, codeword);
              if (leftToRight) {
                startColumn = codeword.getStartX();
              } else {
                startColumn = codeword.getEndX();
              }
            }
          }
        }
        return rowIndicatorColumn;
      }
      /**
       *
       * @param detectionResult
       * @param BarcodeValue
       * @param param2
       * @param param3
       * @param barcodeMatrix
       *
       * @throws NotFoundException
       */
      static adjustCodewordCount(detectionResult, barcodeMatrix) {
        let barcodeMatrix01 = barcodeMatrix[0][1];
        let numberOfCodewords = barcodeMatrix01.getValue();
        let calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
        if (numberOfCodewords.length === 0) {
          if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common.MAX_CODEWORDS_IN_BARCODE) {
            throw NotFoundException.getNotFoundInstance();
          }
          barcodeMatrix01.setValue(calculatedNumberOfCodewords);
        } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {
          barcodeMatrix01.setValue(calculatedNumberOfCodewords);
        }
      }
      /**
       *
       * @param detectionResult
       *
       * @throws FormatException
       * @throws ChecksumException
       * @throws NotFoundException
       */
      static createDecoderResult(detectionResult) {
        let barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);
        PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);
        let erasures = new Array();
        let codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());
        let ambiguousIndexValuesList = (
          /*List<int[]>*/
          []
        );
        let ambiguousIndexesList = (
          /*Collection<Integer>*/
          new Array()
        );
        for (let row = 0; row < detectionResult.getBarcodeRowCount(); row++) {
          for (let column = 0; column < detectionResult.getBarcodeColumnCount(); column++) {
            let values = barcodeMatrix[row][column + 1].getValue();
            let codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;
            if (values.length === 0) {
              erasures.push(codewordIndex);
            } else if (values.length === 1) {
              codewords[codewordIndex] = values[0];
            } else {
              ambiguousIndexesList.push(codewordIndex);
              ambiguousIndexValuesList.push(values);
            }
          }
        }
        let ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);
        for (let i = 0; i < ambiguousIndexValues.length; i++) {
          ambiguousIndexValues[i] = ambiguousIndexValuesList[i];
        }
        return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common.toIntArray(erasures), PDF417Common.toIntArray(ambiguousIndexesList), ambiguousIndexValues);
      }
      /**
       * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The
       * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value
       * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of
       * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the
       * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,
       * so decoding the normal barcodes is not affected by this.
       *
       * @param erasureArray contains the indexes of erasures
       * @param ambiguousIndexes array with the indexes that have more than one most likely value
       * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must
       * be the same length as the ambiguousIndexes array
       *
       * @throws FormatException
       * @throws ChecksumException
       */
      static createDecoderResultFromAmbiguousValues(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {
        let ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);
        let tries = 100;
        while (tries-- > 0) {
          for (let i = 0; i < ambiguousIndexCount.length; i++) {
            codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];
          }
          try {
            return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);
          } catch (err2) {
            let ignored = err2 instanceof ChecksumException;
            if (!ignored) {
              throw err2;
            }
          }
          if (ambiguousIndexCount.length === 0) {
            throw ChecksumException.getChecksumInstance();
          }
          for (let i = 0; i < ambiguousIndexCount.length; i++) {
            if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {
              ambiguousIndexCount[i]++;
              break;
            } else {
              ambiguousIndexCount[i] = 0;
              if (i === ambiguousIndexCount.length - 1) {
                throw ChecksumException.getChecksumInstance();
              }
            }
          }
        }
        throw ChecksumException.getChecksumInstance();
      }
      static createBarcodeMatrix(detectionResult) {
        let barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, () => new Array(detectionResult.getBarcodeColumnCount() + 2));
        for (let row = 0; row < barcodeMatrix.length; row++) {
          for (let column2 = 0; column2 < barcodeMatrix[row].length; column2++) {
            barcodeMatrix[row][column2] = new BarcodeValue();
          }
        }
        let column = 0;
        for (let detectionResultColumn of detectionResult.getDetectionResultColumns()) {
          if (detectionResultColumn != null) {
            for (let codeword of detectionResultColumn.getCodewords()) {
              if (codeword != null) {
                let rowNumber = codeword.getRowNumber();
                if (rowNumber >= 0) {
                  if (rowNumber >= barcodeMatrix.length) {
                    continue;
                  }
                  barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                }
              }
            }
          }
          column++;
        }
        return barcodeMatrix;
      }
      static isValidBarcodeColumn(detectionResult, barcodeColumn) {
        return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;
      }
      static getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight) {
        let offset = leftToRight ? 1 : -1;
        let codeword = null;
        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
          codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);
        }
        if (codeword != null) {
          return leftToRight ? codeword.getEndX() : codeword.getStartX();
        }
        codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
        if (codeword != null) {
          return leftToRight ? codeword.getStartX() : codeword.getEndX();
        }
        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
          codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);
        }
        if (codeword != null) {
          return leftToRight ? codeword.getEndX() : codeword.getStartX();
        }
        let skippedColumns = 0;
        while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
          barcodeColumn -= offset;
          for (let previousRowCodeword of detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()) {
            if (previousRowCodeword != null) {
              return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());
            }
          }
          skippedColumns++;
        }
        return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();
      }
      static detectCodeword(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {
        startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
        let moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
        if (moduleBitCount == null) {
          return null;
        }
        let endColumn;
        let codewordBitCount = MathUtils.sum(moduleBitCount);
        if (leftToRight) {
          endColumn = startColumn + codewordBitCount;
        } else {
          for (let i = 0; i < moduleBitCount.length / 2; i++) {
            let tmpCount = moduleBitCount[i];
            moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];
            moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;
          }
          endColumn = startColumn;
          startColumn = endColumn - codewordBitCount;
        }
        if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {
          return null;
        }
        let decodedValue = PDF417CodewordDecoder.getDecodedValue(moduleBitCount);
        let codeword = PDF417Common.getCodeword(decodedValue);
        if (codeword === -1) {
          return null;
        }
        return new Codeword(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);
      }
      static getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {
        let imageColumn = startColumn;
        let moduleBitCount = new Int32Array(8);
        let moduleNumber = 0;
        let increment = leftToRight ? 1 : -1;
        let previousPixelValue = leftToRight;
        while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length) {
          if (image.get(imageColumn, imageRow) === previousPixelValue) {
            moduleBitCount[moduleNumber]++;
            imageColumn += increment;
          } else {
            moduleNumber++;
            previousPixelValue = !previousPixelValue;
          }
        }
        if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {
          return moduleBitCount;
        }
        return null;
      }
      static getNumberOfECCodeWords(barcodeECLevel) {
        return 2 << barcodeECLevel;
      }
      static adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {
        let correctedStartColumn = codewordStartColumn;
        let increment = leftToRight ? -1 : 1;
        for (let i = 0; i < 2; i++) {
          while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)) {
            if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {
              return codewordStartColumn;
            }
            correctedStartColumn += increment;
          }
          increment = -increment;
          leftToRight = !leftToRight;
        }
        return correctedStartColumn;
      }
      static checkCodewordSkew(codewordSize, minCodewordWidth, maxCodewordWidth) {
        return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;
      }
      /**
       * @throws FormatException,
       * @throws ChecksumException
       */
      static decodeCodewords(codewords, ecLevel, erasures) {
        if (codewords.length === 0) {
          throw FormatException.getFormatInstance();
        }
        let numECCodewords = 1 << ecLevel + 1;
        let correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);
        PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);
        let decoderResult = DecodedBitStreamParser$2.decode(codewords, "" + ecLevel);
        decoderResult.setErrorsCorrected(correctedErrorsCount);
        decoderResult.setErasures(erasures.length);
        return decoderResult;
      }
      /**
       * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
       * correct the errors in-place.</p>
       *
       * @param codewords   data and error correction codewords
       * @param erasures positions of any known erasures
       * @param numECCodewords number of error correction codewords that are available in codewords
       * @throws ChecksumException if error correction fails
       */
      static correctErrors(codewords, erasures, numECCodewords) {
        if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {
          throw ChecksumException.getChecksumInstance();
        }
        return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);
      }
      /**
       * Verify that all is OK with the codeword array.
       * @throws FormatException
       */
      static verifyCodewordCount(codewords, numECCodewords) {
        if (codewords.length < 4) {
          throw FormatException.getFormatInstance();
        }
        let numberOfCodewords = codewords[0];
        if (numberOfCodewords > codewords.length) {
          throw FormatException.getFormatInstance();
        }
        if (numberOfCodewords === 0) {
          if (numECCodewords < codewords.length) {
            codewords[0] = codewords.length - numECCodewords;
          } else {
            throw FormatException.getFormatInstance();
          }
        }
      }
      static getBitCountForCodeword(codeword) {
        let result = new Int32Array(8);
        let previousValue = 0;
        let i = result.length - 1;
        while (true) {
          if ((codeword & 1) !== previousValue) {
            previousValue = codeword & 1;
            i--;
            if (i < 0) {
              break;
            }
          }
          result[i]++;
          codeword >>= 1;
        }
        return result;
      }
      static getCodewordBucketNumber(codeword) {
        if (codeword instanceof Int32Array) {
          return this.getCodewordBucketNumber_Int32Array(codeword);
        }
        return this.getCodewordBucketNumber_number(codeword);
      }
      static getCodewordBucketNumber_number(codeword) {
        return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));
      }
      static getCodewordBucketNumber_Int32Array(moduleBitCount) {
        return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;
      }
      static toString(barcodeMatrix) {
        let formatter = new Formatter();
        for (let row = 0; row < barcodeMatrix.length; row++) {
          formatter.format("Row %2d: ", row);
          for (let column = 0; column < barcodeMatrix[row].length; column++) {
            let barcodeValue = barcodeMatrix[row][column];
            if (barcodeValue.getValue().length === 0) {
              formatter.format("        ", null);
            } else {
              formatter.format("%4d(%2d)", barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));
            }
          }
          formatter.format("%n");
        }
        return formatter.toString();
      }
    }
    PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;
    PDF417ScanningDecoder.MAX_ERRORS = 3;
    PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;
    PDF417ScanningDecoder.errorCorrection = new ErrorCorrection();
    class PDF417Reader {
      // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);
      /**
       * Locates and decodes a PDF417 code in an image.
       *
       * @return a String representing the content encoded by the PDF417 code
       * @throws NotFoundException if a PDF417 code cannot be found,
       * @throws FormatException if a PDF417 cannot be decoded
       * @throws ChecksumException
       */
      // @Override
      decode(image, hints = null) {
        let result = PDF417Reader.decode(image, hints, false);
        if (result == null || result.length === 0 || result[0] == null) {
          throw NotFoundException.getNotFoundInstance();
        }
        return result[0];
      }
      /**
       *
       * @param BinaryBitmap
       * @param image
       * @throws NotFoundException
       */
      //   @Override
      decodeMultiple(image, hints = null) {
        try {
          return PDF417Reader.decode(image, hints, true);
        } catch (ignored) {
          if (ignored instanceof FormatException || ignored instanceof ChecksumException) {
            throw NotFoundException.getNotFoundInstance();
          }
          throw ignored;
        }
      }
      /**
       *
       * @param image
       * @param hints
       * @param multiple
       *
       * @throws NotFoundException
       * @throws FormatExceptionß
       * @throws ChecksumException
       */
      static decode(image, hints, multiple) {
        const results = new Array();
        const detectorResult = Detector$3.detectMultiple(image, hints, multiple);
        for (const points of detectorResult.getPoints()) {
          const decoderResult = PDF417ScanningDecoder.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));
          const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat$1.PDF_417);
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());
          const pdf417ResultMetadata = decoderResult.getOther();
          if (pdf417ResultMetadata != null) {
            result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA, pdf417ResultMetadata);
          }
          results.push(result);
        }
        return results.map((x) => x);
      }
      static getMaxWidth(p1, p2) {
        if (p1 == null || p2 == null) {
          return 0;
        }
        return Math.trunc(Math.abs(p1.getX() - p2.getX()));
      }
      static getMinWidth(p1, p2) {
        if (p1 == null || p2 == null) {
          return Integer.MAX_VALUE;
        }
        return Math.trunc(Math.abs(p1.getX() - p2.getX()));
      }
      static getMaxCodewordWidth(p) {
        return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0], p[4]), PDF417Reader.getMaxWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p[1], p[5]), PDF417Reader.getMaxWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));
      }
      static getMinCodewordWidth(p) {
        return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0], p[4]), PDF417Reader.getMinWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p[1], p[5]), PDF417Reader.getMinWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));
      }
      // @Override
      reset() {
      }
    }
    class ReaderException extends Exception {
    }
    ReaderException.kind = "ReaderException";
    class MultiFormatReader {
      /**
       * Creates an instance of this class
       * 
       * @param {Boolean} verbose if 'true' logs will be dumped to console, otherwise hidden.
       * @param hints The hints to use, clearing the previous state.
       */
      constructor(verbose, hints) {
        this.verbose = verbose === true;
        if (hints) {
          this.setHints(hints);
        }
      }
      /**
       * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it
       * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.
       * Use setHints() followed by decodeWithState() for continuous scan applications.
       *
       * @param image The pixel data to decode
       * @return The contents of the image
       *
       * @throws NotFoundException Any errors which occurred
       */
      /*@Override*/
      // public decode(image: BinaryBitmap): Result {
      //   setHints(null)
      //   return decodeInternal(image)
      // }
      /**
       * Decode an image using the hints provided. Does not honor existing state.
       *
       * @param image The pixel data to decode
       * @param hints The hints to use, clearing the previous state.
       * @return The contents of the image
       *
       * @throws NotFoundException Any errors which occurred
       */
      /*@Override*/
      decode(image, hints) {
        if (hints) {
          this.setHints(hints);
        }
        return this.decodeInternal(image);
      }
      /**
       * Decode an image using the state set up by calling setHints() previously. Continuous scan
       * clients will get a <b>large</b> speed increase by using this instead of decode().
       *
       * @param image The pixel data to decode
       * @return The contents of the image
       *
       * @throws NotFoundException Any errors which occurred
       */
      decodeWithState(image) {
        if (this.readers === null || this.readers === void 0) {
          this.setHints(null);
        }
        return this.decodeInternal(image);
      }
      /**
       * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls
       * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This
       * is important for performance in continuous scan clients.
       *
       * @param hints The set of hints to use for subsequent calls to decode(image)
       */
      setHints(hints) {
        this.hints = hints;
        const tryHarder = !isNullOrUndefined2(hints) && hints.get(DecodeHintType$1.TRY_HARDER) === true;
        const formats = isNullOrUndefined2(hints) ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
        const readers = new Array();
        if (!isNullOrUndefined2(formats)) {
          const addOneDReader = formats.some((f2) => {
            return f2 === BarcodeFormat$1.UPC_A || f2 === BarcodeFormat$1.UPC_E || f2 === BarcodeFormat$1.EAN_13 || f2 === BarcodeFormat$1.EAN_8 || f2 === BarcodeFormat$1.CODABAR || f2 === BarcodeFormat$1.CODE_39 || f2 === BarcodeFormat$1.CODE_93 || f2 === BarcodeFormat$1.CODE_128 || f2 === BarcodeFormat$1.ITF || f2 === BarcodeFormat$1.RSS_14 || f2 === BarcodeFormat$1.RSS_EXPANDED;
          });
          if (addOneDReader && !tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
          if (formats.includes(BarcodeFormat$1.QR_CODE)) {
            readers.push(new QRCodeReader());
          }
          if (formats.includes(BarcodeFormat$1.DATA_MATRIX)) {
            readers.push(new DataMatrixReader());
          }
          if (formats.includes(BarcodeFormat$1.AZTEC)) {
            readers.push(new AztecReader());
          }
          if (formats.includes(BarcodeFormat$1.PDF_417)) {
            readers.push(new PDF417Reader());
          }
          if (addOneDReader && tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
        }
        if (readers.length === 0) {
          if (!tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
          readers.push(new QRCodeReader());
          readers.push(new DataMatrixReader());
          readers.push(new AztecReader());
          readers.push(new PDF417Reader());
          if (tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
        }
        this.readers = readers;
      }
      /*@Override*/
      reset() {
        if (this.readers !== null) {
          for (const reader of this.readers) {
            reader.reset();
          }
        }
      }
      /**
       * @throws NotFoundException
       */
      decodeInternal(image) {
        if (this.readers === null) {
          throw new ReaderException("No readers where selected, nothing can be read.");
        }
        for (const reader of this.readers) {
          try {
            return reader.decode(image, this.hints);
          } catch (ex) {
            if (ex instanceof ReaderException) {
              continue;
            }
          }
        }
        throw new NotFoundException("No MultiFormat Readers were able to detect the code.");
      }
    }
    class BrowserMultiFormatReader extends BrowserCodeReader {
      constructor(hints = null, timeBetweenScansMillis = 500) {
        const reader = new MultiFormatReader();
        reader.setHints(hints);
        super(reader, timeBetweenScansMillis);
      }
      /**
       * Overwrite decodeBitmap to call decodeWithState, which will pay
       * attention to the hints set in the constructor function
       */
      decodeBitmap(binaryBitmap) {
        return this.reader.decodeWithState(binaryBitmap);
      }
    }
    class BrowserPDF417Reader extends BrowserCodeReader {
      /**
       * Creates an instance of BrowserPDF417Reader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       */
      constructor(timeBetweenScansMillis = 500) {
        super(new PDF417Reader(), timeBetweenScansMillis);
      }
    }
    class BrowserQRCodeReader extends BrowserCodeReader {
      /**
       * Creates an instance of BrowserQRCodeReader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       */
      constructor(timeBetweenScansMillis = 500) {
        super(new QRCodeReader(), timeBetweenScansMillis);
      }
    }
    var EncodeHintType;
    (function(EncodeHintType2) {
      EncodeHintType2[EncodeHintType2["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";
      EncodeHintType2[EncodeHintType2["CHARACTER_SET"] = 1] = "CHARACTER_SET";
      EncodeHintType2[EncodeHintType2["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";
      EncodeHintType2[EncodeHintType2["MIN_SIZE"] = 3] = "MIN_SIZE";
      EncodeHintType2[EncodeHintType2["MAX_SIZE"] = 4] = "MAX_SIZE";
      EncodeHintType2[EncodeHintType2["MARGIN"] = 5] = "MARGIN";
      EncodeHintType2[EncodeHintType2["PDF417_COMPACT"] = 6] = "PDF417_COMPACT";
      EncodeHintType2[EncodeHintType2["PDF417_COMPACTION"] = 7] = "PDF417_COMPACTION";
      EncodeHintType2[EncodeHintType2["PDF417_DIMENSIONS"] = 8] = "PDF417_DIMENSIONS";
      EncodeHintType2[EncodeHintType2["AZTEC_LAYERS"] = 9] = "AZTEC_LAYERS";
      EncodeHintType2[EncodeHintType2["QR_VERSION"] = 10] = "QR_VERSION";
    })(EncodeHintType || (EncodeHintType = {}));
    var EncodeHintType$1 = EncodeHintType;
    class ReedSolomonEncoder {
      /**
       * A reed solomon error-correcting encoding constructor is created by
       * passing as Galois Field with of size equal to the number of code
       * words (symbols) in the alphabet (the number of values in each
       * element of arrays that are encoded/decoded).
       * @param field A galois field with a number of elements equal to the size
       * of the alphabet of symbols to encode.
       */
      constructor(field2) {
        this.field = field2;
        this.cachedGenerators = [];
        this.cachedGenerators.push(new GenericGFPoly(field2, Int32Array.from([1])));
      }
      buildGenerator(degree) {
        const cachedGenerators = this.cachedGenerators;
        if (degree >= cachedGenerators.length) {
          let lastGenerator = cachedGenerators[cachedGenerators.length - 1];
          const field2 = this.field;
          for (let d = cachedGenerators.length; d <= degree; d++) {
            const nextGenerator = lastGenerator.multiply(new GenericGFPoly(field2, Int32Array.from([1, field2.exp(d - 1 + field2.getGeneratorBase())])));
            cachedGenerators.push(nextGenerator);
            lastGenerator = nextGenerator;
          }
        }
        return cachedGenerators[degree];
      }
      /**
       * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders
       * to detect and correct errors that may have been introduced when the resulting
       * data is stored or transmitted.</p>
       *
       * @param toEncode array used for both and output. Caller initializes the array with
       * the code words (symbols) to be encoded followed by empty elements allocated to make
       * space for error-correction code words in the encoded output. The array contains
       * the encdoded output when encode returns. Code words are encoded as numbers from
       * 0 to n-1, where n is the number of possible code words (symbols), as determined
       * by the size of the Galois Field passed in the constructor of this object.
       * @param ecBytes the number of elements reserved in the array (first parameter)
       * to store error-correction code words. Thus, the number of code words (symbols)
       * to encode in the first parameter is thus toEncode.length - ecBytes.
       * Note, the use of "bytes" in the name of this parameter is misleading, as there may
       * be more or fewer than 256 symbols being encoded, as determined by the number of
       * elements in the Galois Field passed as a constructor to this object.
       * @throws IllegalArgumentException thrown in response to validation errros.
       */
      encode(toEncode, ecBytes) {
        if (ecBytes === 0) {
          throw new IllegalArgumentException("No error correction bytes");
        }
        const dataBytes = toEncode.length - ecBytes;
        if (dataBytes <= 0) {
          throw new IllegalArgumentException("No data bytes provided");
        }
        const generator = this.buildGenerator(ecBytes);
        const infoCoefficients = new Int32Array(dataBytes);
        System.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);
        let info = new GenericGFPoly(this.field, infoCoefficients);
        info = info.multiplyByMonomial(ecBytes, 1);
        const remainder = info.divide(generator)[1];
        const coefficients = remainder.getCoefficients();
        const numZeroCoefficients = ecBytes - coefficients.length;
        for (let i = 0; i < numZeroCoefficients; i++) {
          toEncode[dataBytes + i] = 0;
        }
        System.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);
      }
    }
    class MaskUtil {
      constructor() {
      }
      /**
       * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and
       * give penalty to them. Example: 00000 or 11111.
       */
      static applyMaskPenaltyRule1(matrix) {
        return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);
      }
      /**
       * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give
       * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a
       * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.
       */
      static applyMaskPenaltyRule2(matrix) {
        let penalty = 0;
        const array = matrix.getArray();
        const width = matrix.getWidth();
        const height = matrix.getHeight();
        for (let y = 0; y < height - 1; y++) {
          const arrayY = array[y];
          for (let x = 0; x < width - 1; x++) {
            const value = arrayY[x];
            if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {
              penalty++;
            }
          }
        }
        return MaskUtil.N2 * penalty;
      }
      /**
       * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4
       * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we
       * find patterns like 000010111010000, we give penalty once.
       */
      static applyMaskPenaltyRule3(matrix) {
        let numPenalties = 0;
        const array = matrix.getArray();
        const width = matrix.getWidth();
        const height = matrix.getHeight();
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const arrayY = array[y];
            if (x + 6 < width && arrayY[x] === 1 && arrayY[x + 1] === 0 && arrayY[x + 2] === 1 && arrayY[x + 3] === 1 && arrayY[x + 4] === 1 && arrayY[x + 5] === 0 && arrayY[x + 6] === 1 && (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {
              numPenalties++;
            }
            if (y + 6 < height && array[y][x] === 1 && array[y + 1][x] === 0 && array[y + 2][x] === 1 && array[y + 3][x] === 1 && array[y + 4][x] === 1 && array[y + 5][x] === 0 && array[y + 6][x] === 1 && (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {
              numPenalties++;
            }
          }
        }
        return numPenalties * MaskUtil.N3;
      }
      static isWhiteHorizontal(rowArray, from, to) {
        from = Math.max(from, 0);
        to = Math.min(to, rowArray.length);
        for (let i = from; i < to; i++) {
          if (rowArray[i] === 1) {
            return false;
          }
        }
        return true;
      }
      static isWhiteVertical(array, col, from, to) {
        from = Math.max(from, 0);
        to = Math.min(to, array.length);
        for (let i = from; i < to; i++) {
          if (array[i][col] === 1) {
            return false;
          }
        }
        return true;
      }
      /**
       * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give
       * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.
       */
      static applyMaskPenaltyRule4(matrix) {
        let numDarkCells = 0;
        const array = matrix.getArray();
        const width = matrix.getWidth();
        const height = matrix.getHeight();
        for (let y = 0; y < height; y++) {
          const arrayY = array[y];
          for (let x = 0; x < width; x++) {
            if (arrayY[x] === 1) {
              numDarkCells++;
            }
          }
        }
        const numTotalCells = matrix.getHeight() * matrix.getWidth();
        const fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);
        return fivePercentVariances * MaskUtil.N4;
      }
      /**
       * Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask
       * pattern conditions.
       */
      static getDataMaskBit(maskPattern, x, y) {
        let intermediate;
        let temp;
        switch (maskPattern) {
          case 0:
            intermediate = y + x & 1;
            break;
          case 1:
            intermediate = y & 1;
            break;
          case 2:
            intermediate = x % 3;
            break;
          case 3:
            intermediate = (y + x) % 3;
            break;
          case 4:
            intermediate = Math.floor(y / 2) + Math.floor(x / 3) & 1;
            break;
          case 5:
            temp = y * x;
            intermediate = (temp & 1) + temp % 3;
            break;
          case 6:
            temp = y * x;
            intermediate = (temp & 1) + temp % 3 & 1;
            break;
          case 7:
            temp = y * x;
            intermediate = temp % 3 + (y + x & 1) & 1;
            break;
          default:
            throw new IllegalArgumentException("Invalid mask pattern: " + maskPattern);
        }
        return intermediate === 0;
      }
      /**
       * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both
       * vertical and horizontal orders respectively.
       */
      static applyMaskPenaltyRule1Internal(matrix, isHorizontal) {
        let penalty = 0;
        const iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
        const jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
        const array = matrix.getArray();
        for (let i = 0; i < iLimit; i++) {
          let numSameBitCells = 0;
          let prevBit = -1;
          for (let j = 0; j < jLimit; j++) {
            const bit = isHorizontal ? array[i][j] : array[j][i];
            if (bit === prevBit) {
              numSameBitCells++;
            } else {
              if (numSameBitCells >= 5) {
                penalty += MaskUtil.N1 + (numSameBitCells - 5);
              }
              numSameBitCells = 1;
              prevBit = bit;
            }
          }
          if (numSameBitCells >= 5) {
            penalty += MaskUtil.N1 + (numSameBitCells - 5);
          }
        }
        return penalty;
      }
    }
    MaskUtil.N1 = 3;
    MaskUtil.N2 = 3;
    MaskUtil.N3 = 40;
    MaskUtil.N4 = 10;
    class ByteMatrix {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        const bytes2 = new Array(height);
        for (let i = 0; i !== height; i++) {
          bytes2[i] = new Uint8Array(width);
        }
        this.bytes = bytes2;
      }
      getHeight() {
        return this.height;
      }
      getWidth() {
        return this.width;
      }
      get(x, y) {
        return this.bytes[y][x];
      }
      /**
       * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)
       */
      getArray() {
        return this.bytes;
      }
      // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside
      setNumber(x, y, value) {
        this.bytes[y][x] = value;
      }
      // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {
      //   bytes[y][x] = (byte) value
      // }
      setBoolean(x, y, value) {
        this.bytes[y][x] = /*(byte) */
        value ? 1 : 0;
      }
      clear(value) {
        for (const aByte of this.bytes) {
          Arrays.fill(aByte, value);
        }
      }
      equals(o) {
        if (!(o instanceof ByteMatrix)) {
          return false;
        }
        const other = o;
        if (this.width !== other.width) {
          return false;
        }
        if (this.height !== other.height) {
          return false;
        }
        for (let y = 0, height = this.height; y < height; ++y) {
          const bytesY = this.bytes[y];
          const otherBytesY = other.bytes[y];
          for (let x = 0, width = this.width; x < width; ++x) {
            if (bytesY[x] !== otherBytesY[x]) {
              return false;
            }
          }
        }
        return true;
      }
      /*@Override*/
      toString() {
        const result = new StringBuilder();
        for (let y = 0, height = this.height; y < height; ++y) {
          const bytesY = this.bytes[y];
          for (let x = 0, width = this.width; x < width; ++x) {
            switch (bytesY[x]) {
              case 0:
                result.append(" 0");
                break;
              case 1:
                result.append(" 1");
                break;
              default:
                result.append("  ");
                break;
            }
          }
          result.append("\n");
        }
        return result.toString();
      }
    }
    class QRCode {
      constructor() {
        this.maskPattern = -1;
      }
      getMode() {
        return this.mode;
      }
      getECLevel() {
        return this.ecLevel;
      }
      getVersion() {
        return this.version;
      }
      getMaskPattern() {
        return this.maskPattern;
      }
      getMatrix() {
        return this.matrix;
      }
      /*@Override*/
      toString() {
        const result = new StringBuilder();
        result.append("<<\n");
        result.append(" mode: ");
        result.append(this.mode ? this.mode.toString() : "null");
        result.append("\n ecLevel: ");
        result.append(this.ecLevel ? this.ecLevel.toString() : "null");
        result.append("\n version: ");
        result.append(this.version ? this.version.toString() : "null");
        result.append("\n maskPattern: ");
        result.append(this.maskPattern.toString());
        if (this.matrix) {
          result.append("\n matrix:\n");
          result.append(this.matrix.toString());
        } else {
          result.append("\n matrix: null\n");
        }
        result.append(">>\n");
        return result.toString();
      }
      setMode(value) {
        this.mode = value;
      }
      setECLevel(value) {
        this.ecLevel = value;
      }
      setVersion(version2) {
        this.version = version2;
      }
      setMaskPattern(value) {
        this.maskPattern = value;
      }
      setMatrix(value) {
        this.matrix = value;
      }
      // Check if "mask_pattern" is valid.
      static isValidMaskPattern(maskPattern) {
        return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;
      }
    }
    QRCode.NUM_MASK_PATTERNS = 8;
    class WriterException extends Exception {
    }
    WriterException.kind = "WriterException";
    class MatrixUtil {
      constructor() {
      }
      // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).
      //
      // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding
      // with the ByteMatrix initialized all to zero.
      static clearMatrix(matrix) {
        matrix.clear(
          /*(byte) */
          /*-1*/
          255
        );
      }
      // Build 2D matrix of QR Code from "dataBits" with "ecLevel", "version" and "getMaskPattern". On
      // success, store the result in "matrix" and return true.
      static buildMatrix(dataBits, ecLevel, version2, maskPattern, matrix) {
        MatrixUtil.clearMatrix(matrix);
        MatrixUtil.embedBasicPatterns(version2, matrix);
        MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);
        MatrixUtil.maybeEmbedVersionInfo(version2, matrix);
        MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);
      }
      // Embed basic patterns. On success, modify the matrix and return true.
      // The basic patterns are:
      // - Position detection patterns
      // - Timing patterns
      // - Dark dot at the left bottom corner
      // - Position adjustment patterns, if need be
      static embedBasicPatterns(version2, matrix) {
        MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);
        MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);
        MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version2, matrix);
        MatrixUtil.embedTimingPatterns(matrix);
      }
      // Embed type information. On success, modify the matrix.
      static embedTypeInfo(ecLevel, maskPattern, matrix) {
        const typeInfoBits = new BitArray();
        MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
        for (let i = 0, size = typeInfoBits.getSize(); i < size; ++i) {
          const bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);
          const coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i];
          const x1 = coordinates[0];
          const y1 = coordinates[1];
          matrix.setBoolean(x1, y1, bit);
          if (i < 8) {
            const x2 = matrix.getWidth() - i - 1;
            const y2 = 8;
            matrix.setBoolean(x2, y2, bit);
          } else {
            const x2 = 8;
            const y2 = matrix.getHeight() - 7 + (i - 8);
            matrix.setBoolean(x2, y2, bit);
          }
        }
      }
      // Embed version information if need be. On success, modify the matrix and return true.
      // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.
      static maybeEmbedVersionInfo(version2, matrix) {
        if (version2.getVersionNumber() < 7) {
          return;
        }
        const versionInfoBits = new BitArray();
        MatrixUtil.makeVersionInfoBits(version2, versionInfoBits);
        let bitIndex = 6 * 3 - 1;
        for (let i = 0; i < 6; ++i) {
          for (let j = 0; j < 3; ++j) {
            const bit = versionInfoBits.get(bitIndex);
            bitIndex--;
            matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);
            matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);
          }
        }
      }
      // Embed "dataBits" using "getMaskPattern". On success, modify the matrix and return true.
      // For debugging purposes, it skips masking process if "getMaskPattern" is -1(TYPESCRIPTPORT: 255).
      // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.
      static embedDataBits(dataBits, maskPattern, matrix) {
        let bitIndex = 0;
        let direction = -1;
        let x = matrix.getWidth() - 1;
        let y = matrix.getHeight() - 1;
        while (x > 0) {
          if (x === 6) {
            x -= 1;
          }
          while (y >= 0 && y < matrix.getHeight()) {
            for (let i = 0; i < 2; ++i) {
              const xx = x - i;
              if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {
                continue;
              }
              let bit;
              if (bitIndex < dataBits.getSize()) {
                bit = dataBits.get(bitIndex);
                ++bitIndex;
              } else {
                bit = false;
              }
              if (maskPattern !== 255 && MaskUtil.getDataMaskBit(maskPattern, xx, y)) {
                bit = !bit;
              }
              matrix.setBoolean(xx, y, bit);
            }
            y += direction;
          }
          direction = -direction;
          y += direction;
          x -= 2;
        }
        if (bitIndex !== dataBits.getSize()) {
          throw new WriterException("Not all bits consumed: " + bitIndex + "/" + dataBits.getSize());
        }
      }
      // Return the position of the most significant bit set (one: to) in the "value". The most
      // significant bit is position 32. If there is no bit set, return 0. Examples:
      // - findMSBSet(0) => 0
      // - findMSBSet(1) => 1
      // - findMSBSet(255) => 8
      static findMSBSet(value) {
        return 32 - Integer.numberOfLeadingZeros(value);
      }
      // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for "value" using polynomial "poly". The BCH
      // code is used for encoding type information and version information.
      // Example: Calculation of version information of 7.
      // f(x) is created from 7.
      //   - 7 = 000111 in 6 bits
      //   - f(x) = x^2 + x^1 + x^0
      // g(x) is given by the standard (p. 67)
      //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1
      // Multiply f(x) by x^(18 - 6)
      //   - f'(x) = f(x) * x^(18 - 6)
      //   - f'(x) = x^14 + x^13 + x^12
      // Calculate the remainder of f'(x) / g(x)
      //         x^2
      //         __________________________________________________
      //   g(x) )x^14 + x^13 + x^12
      //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2
      //         --------------------------------------------------
      //                              x^11 + x^10 + x^7 + x^4 + x^2
      //
      // The remainder is x^11 + x^10 + x^7 + x^4 + x^2
      // Encode it in binary: 110010010100
      // The return value is 0xc94 (1100 1001 0100)
      //
      // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit
      // operations. We don't care if coefficients are positive or negative.
      static calculateBCHCode(value, poly) {
        if (poly === 0) {
          throw new IllegalArgumentException("0 polynomial");
        }
        const msbSetInPoly = MatrixUtil.findMSBSet(poly);
        value <<= msbSetInPoly - 1;
        while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {
          value ^= poly << MatrixUtil.findMSBSet(value) - msbSetInPoly;
        }
        return value;
      }
      // Make bit vector of type information. On success, store the result in "bits" and return true.
      // Encode error correction level and mask pattern. See 8.9 of
      // JISX0510:2004 (p.45) for details.
      static makeTypeInfoBits(ecLevel, maskPattern, bits) {
        if (!QRCode.isValidMaskPattern(maskPattern)) {
          throw new WriterException("Invalid mask pattern");
        }
        const typeInfo = ecLevel.getBits() << 3 | maskPattern;
        bits.appendBits(typeInfo, 5);
        const bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);
        bits.appendBits(bchCode, 10);
        const maskBits = new BitArray();
        maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);
        bits.xor(maskBits);
        if (bits.getSize() !== 15) {
          throw new WriterException("should not happen but we got: " + bits.getSize());
        }
      }
      // Make bit vector of version information. On success, store the result in "bits" and return true.
      // See 8.10 of JISX0510:2004 (p.45) for details.
      static makeVersionInfoBits(version2, bits) {
        bits.appendBits(version2.getVersionNumber(), 6);
        const bchCode = MatrixUtil.calculateBCHCode(version2.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);
        bits.appendBits(bchCode, 12);
        if (bits.getSize() !== 18) {
          throw new WriterException("should not happen but we got: " + bits.getSize());
        }
      }
      // Check if "value" is empty.
      static isEmpty(value) {
        return value === 255;
      }
      static embedTimingPatterns(matrix) {
        for (let i = 8; i < matrix.getWidth() - 8; ++i) {
          const bit = (i + 1) % 2;
          if (MatrixUtil.isEmpty(matrix.get(i, 6))) {
            matrix.setNumber(i, 6, bit);
          }
          if (MatrixUtil.isEmpty(matrix.get(6, i))) {
            matrix.setNumber(6, i, bit);
          }
        }
      }
      // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)
      static embedDarkDotAtLeftBottomCorner(matrix) {
        if (matrix.get(8, matrix.getHeight() - 8) === 0) {
          throw new WriterException();
        }
        matrix.setNumber(8, matrix.getHeight() - 8, 1);
      }
      static embedHorizontalSeparationPattern(xStart, yStart, matrix) {
        for (let x = 0; x < 8; ++x) {
          if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {
            throw new WriterException();
          }
          matrix.setNumber(xStart + x, yStart, 0);
        }
      }
      static embedVerticalSeparationPattern(xStart, yStart, matrix) {
        for (let y = 0; y < 7; ++y) {
          if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {
            throw new WriterException();
          }
          matrix.setNumber(xStart, yStart + y, 0);
        }
      }
      static embedPositionAdjustmentPattern(xStart, yStart, matrix) {
        for (let y = 0; y < 5; ++y) {
          const patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];
          for (let x = 0; x < 5; ++x) {
            matrix.setNumber(xStart + x, yStart + y, patternY[x]);
          }
        }
      }
      static embedPositionDetectionPattern(xStart, yStart, matrix) {
        for (let y = 0; y < 7; ++y) {
          const patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];
          for (let x = 0; x < 7; ++x) {
            matrix.setNumber(xStart + x, yStart + y, patternY[x]);
          }
        }
      }
      // Embed position detection patterns and surrounding vertical/horizontal separators.
      static embedPositionDetectionPatternsAndSeparators(matrix) {
        const pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;
        MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);
        MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
        MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);
        const hspWidth = 8;
        MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
        MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);
        MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);
        const vspSize = 7;
        MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);
        MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);
        MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);
      }
      // Embed position adjustment patterns if need be.
      static maybeEmbedPositionAdjustmentPatterns(version2, matrix) {
        if (version2.getVersionNumber() < 2) {
          return;
        }
        const index2 = version2.getVersionNumber() - 1;
        const coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index2];
        for (let i = 0, length = coordinates.length; i !== length; i++) {
          const y = coordinates[i];
          if (y >= 0) {
            for (let j = 0; j !== length; j++) {
              const x = coordinates[j];
              if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {
                MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);
              }
            }
          }
        }
      }
    }
    MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([
      Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
      Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
      Int32Array.from([1, 1, 1, 1, 1, 1, 1])
    ]);
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([
      Int32Array.from([1, 1, 1, 1, 1]),
      Int32Array.from([1, 0, 0, 0, 1]),
      Int32Array.from([1, 0, 1, 0, 1]),
      Int32Array.from([1, 0, 0, 0, 1]),
      Int32Array.from([1, 1, 1, 1, 1])
    ]);
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
      Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
      Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
      Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
      Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
      Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
      Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
      Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
      Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
      Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
      Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
      Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
      Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
      Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
      Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
      Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
      Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
      Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
      Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
      Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
      Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
      Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
      Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
      Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
      Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
      Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
      Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
      Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
      Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
      Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
      Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
      Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
      Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
      Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
      Int32Array.from([6, 30, 58, 86, 114, 142, 170])
    ]);
    MatrixUtil.TYPE_INFO_COORDINATES = Array.from([
      Int32Array.from([8, 0]),
      Int32Array.from([8, 1]),
      Int32Array.from([8, 2]),
      Int32Array.from([8, 3]),
      Int32Array.from([8, 4]),
      Int32Array.from([8, 5]),
      Int32Array.from([8, 7]),
      Int32Array.from([8, 8]),
      Int32Array.from([7, 8]),
      Int32Array.from([5, 8]),
      Int32Array.from([4, 8]),
      Int32Array.from([3, 8]),
      Int32Array.from([2, 8]),
      Int32Array.from([1, 8]),
      Int32Array.from([0, 8])
    ]);
    MatrixUtil.VERSION_INFO_POLY = 7973;
    MatrixUtil.TYPE_INFO_POLY = 1335;
    MatrixUtil.TYPE_INFO_MASK_PATTERN = 21522;
    class BlockPair {
      constructor(dataBytes, errorCorrectionBytes) {
        this.dataBytes = dataBytes;
        this.errorCorrectionBytes = errorCorrectionBytes;
      }
      getDataBytes() {
        return this.dataBytes;
      }
      getErrorCorrectionBytes() {
        return this.errorCorrectionBytes;
      }
    }
    class Encoder {
      // TYPESCRIPTPORT: changed to UTF8, the default for js
      constructor() {
      }
      // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.
      // Basically it applies four rules and summate all penalties.
      static calculateMaskPenalty(matrix) {
        return MaskUtil.applyMaskPenaltyRule1(matrix) + MaskUtil.applyMaskPenaltyRule2(matrix) + MaskUtil.applyMaskPenaltyRule3(matrix) + MaskUtil.applyMaskPenaltyRule4(matrix);
      }
      /**
       * @param content text to encode
       * @param ecLevel error correction level to use
       * @return {@link QRCode} representing the encoded QR code
       * @throws WriterException if encoding can't succeed, because of for example invalid content
       *   or configuration
       */
      // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {
      //   return encode(content, ecLevel, null)
      // }
      static encode(content, ecLevel, hints = null) {
        let encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;
        const hasEncodingHint = hints !== null && void 0 !== hints.get(EncodeHintType$1.CHARACTER_SET);
        if (hasEncodingHint) {
          encoding = hints.get(EncodeHintType$1.CHARACTER_SET).toString();
        }
        const mode = this.chooseMode(content, encoding);
        const headerBits = new BitArray();
        if (mode === Mode$1.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {
          const eci = CharacterSetECI.getCharacterSetECIByName(encoding);
          if (eci !== void 0) {
            this.appendECI(eci, headerBits);
          }
        }
        this.appendModeInfo(mode, headerBits);
        const dataBits = new BitArray();
        this.appendBytes(content, mode, dataBits, encoding);
        let version2;
        if (hints !== null && void 0 !== hints.get(EncodeHintType$1.QR_VERSION)) {
          const versionNumber = Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(), 10);
          version2 = Version$1.getVersionForNumber(versionNumber);
          const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version2);
          if (!this.willFit(bitsNeeded, version2, ecLevel)) {
            throw new WriterException("Data too big for requested version");
          }
        } else {
          version2 = this.recommendVersion(ecLevel, mode, headerBits, dataBits);
        }
        const headerAndDataBits = new BitArray();
        headerAndDataBits.appendBitArray(headerBits);
        const numLetters = mode === Mode$1.BYTE ? dataBits.getSizeInBytes() : content.length;
        this.appendLengthInfo(numLetters, version2, mode, headerAndDataBits);
        headerAndDataBits.appendBitArray(dataBits);
        const ecBlocks = version2.getECBlocksForLevel(ecLevel);
        const numDataBytes = version2.getTotalCodewords() - ecBlocks.getTotalECCodewords();
        this.terminateBits(numDataBytes, headerAndDataBits);
        const finalBits = this.interleaveWithECBytes(headerAndDataBits, version2.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());
        const qrCode = new QRCode();
        qrCode.setECLevel(ecLevel);
        qrCode.setMode(mode);
        qrCode.setVersion(version2);
        const dimension = version2.getDimensionForVersion();
        const matrix = new ByteMatrix(dimension, dimension);
        const maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version2, matrix);
        qrCode.setMaskPattern(maskPattern);
        MatrixUtil.buildMatrix(finalBits, ecLevel, version2, maskPattern, matrix);
        qrCode.setMatrix(matrix);
        return qrCode;
      }
      /**
       * Decides the smallest version of QR code that will contain all of the provided data.
       *
       * @throws WriterException if the data cannot fit in any version
       */
      static recommendVersion(ecLevel, mode, headerBits, dataBits) {
        const provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version$1.getVersionForNumber(1));
        const provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);
        const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);
        return this.chooseVersion(bitsNeeded, ecLevel);
      }
      static calculateBitsNeeded(mode, headerBits, dataBits, version2) {
        return headerBits.getSize() + mode.getCharacterCountBits(version2) + dataBits.getSize();
      }
      /**
       * @return the code point of the table used in alphanumeric mode or
       *  -1 if there is no corresponding code in the table.
       */
      static getAlphanumericCode(code) {
        if (code < Encoder.ALPHANUMERIC_TABLE.length) {
          return Encoder.ALPHANUMERIC_TABLE[code];
        }
        return -1;
      }
      // public static chooseMode(content: string): Mode {
      //   return chooseMode(content, null);
      // }
      /**
       * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;
       * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.
       */
      static chooseMode(content, encoding = null) {
        if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {
          return Mode$1.KANJI;
        }
        let hasNumeric = false;
        let hasAlphanumeric = false;
        for (let i = 0, length = content.length; i < length; ++i) {
          const c = content.charAt(i);
          if (Encoder.isDigit(c)) {
            hasNumeric = true;
          } else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {
            hasAlphanumeric = true;
          } else {
            return Mode$1.BYTE;
          }
        }
        if (hasAlphanumeric) {
          return Mode$1.ALPHANUMERIC;
        }
        if (hasNumeric) {
          return Mode$1.NUMERIC;
        }
        return Mode$1.BYTE;
      }
      static isOnlyDoubleByteKanji(content) {
        let bytes2;
        try {
          bytes2 = StringEncoding.encode(content, CharacterSetECI.SJIS);
        } catch (ignored) {
          return false;
        }
        const length = bytes2.length;
        if (length % 2 !== 0) {
          return false;
        }
        for (let i = 0; i < length; i += 2) {
          const byte1 = bytes2[i] & 255;
          if ((byte1 < 129 || byte1 > 159) && (byte1 < 224 || byte1 > 235)) {
            return false;
          }
        }
        return true;
      }
      static chooseMaskPattern(bits, ecLevel, version2, matrix) {
        let minPenalty = Number.MAX_SAFE_INTEGER;
        let bestMaskPattern = -1;
        for (let maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {
          MatrixUtil.buildMatrix(bits, ecLevel, version2, maskPattern, matrix);
          let penalty = this.calculateMaskPenalty(matrix);
          if (penalty < minPenalty) {
            minPenalty = penalty;
            bestMaskPattern = maskPattern;
          }
        }
        return bestMaskPattern;
      }
      static chooseVersion(numInputBits, ecLevel) {
        for (let versionNum = 1; versionNum <= 40; versionNum++) {
          const version2 = Version$1.getVersionForNumber(versionNum);
          if (Encoder.willFit(numInputBits, version2, ecLevel)) {
            return version2;
          }
        }
        throw new WriterException("Data too big");
      }
      /**
       * @return true if the number of input bits will fit in a code with the specified version and
       * error correction level.
       */
      static willFit(numInputBits, version2, ecLevel) {
        const numBytes = version2.getTotalCodewords();
        const ecBlocks = version2.getECBlocksForLevel(ecLevel);
        const numEcBytes = ecBlocks.getTotalECCodewords();
        const numDataBytes = numBytes - numEcBytes;
        const totalInputBytes = (numInputBits + 7) / 8;
        return numDataBytes >= totalInputBytes;
      }
      /**
       * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
       */
      static terminateBits(numDataBytes, bits) {
        const capacity = numDataBytes * 8;
        if (bits.getSize() > capacity) {
          throw new WriterException("data bits cannot fit in the QR Code" + bits.getSize() + " > " + capacity);
        }
        for (let i = 0; i < 4 && bits.getSize() < capacity; ++i) {
          bits.appendBit(false);
        }
        const numBitsInLastByte = bits.getSize() & 7;
        if (numBitsInLastByte > 0) {
          for (let i = numBitsInLastByte; i < 8; i++) {
            bits.appendBit(false);
          }
        }
        const numPaddingBytes = numDataBytes - bits.getSizeInBytes();
        for (let i = 0; i < numPaddingBytes; ++i) {
          bits.appendBits((i & 1) === 0 ? 236 : 17, 8);
        }
        if (bits.getSize() !== capacity) {
          throw new WriterException("Bits size does not equal capacity");
        }
      }
      /**
       * Get number of data bytes and number of error correction bytes for block id "blockID". Store
       * the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of
       * JISX0510:2004 (p.30)
       */
      static getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, blockID, numDataBytesInBlock, numECBytesInBlock) {
        if (blockID >= numRSBlocks) {
          throw new WriterException("Block ID too large");
        }
        const numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
        const numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
        const numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
        const numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
        const numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
        const numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
        const numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
        const numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
        if (numEcBytesInGroup1 !== numEcBytesInGroup2) {
          throw new WriterException("EC bytes mismatch");
        }
        if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {
          throw new WriterException("RS blocks mismatch");
        }
        if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {
          throw new WriterException("Total bytes mismatch");
        }
        if (blockID < numRsBlocksInGroup1) {
          numDataBytesInBlock[0] = numDataBytesInGroup1;
          numECBytesInBlock[0] = numEcBytesInGroup1;
        } else {
          numDataBytesInBlock[0] = numDataBytesInGroup2;
          numECBytesInBlock[0] = numEcBytesInGroup2;
        }
      }
      /**
       * Interleave "bits" with corresponding error correction bytes. On success, store the result in
       * "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.
       */
      static interleaveWithECBytes(bits, numTotalBytes, numDataBytes, numRSBlocks) {
        if (bits.getSizeInBytes() !== numDataBytes) {
          throw new WriterException("Number of bits and data bytes does not match");
        }
        let dataBytesOffset = 0;
        let maxNumDataBytes = 0;
        let maxNumEcBytes = 0;
        const blocks = new Array();
        for (let i = 0; i < numRSBlocks; ++i) {
          const numDataBytesInBlock = new Int32Array(1);
          const numEcBytesInBlock = new Int32Array(1);
          Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);
          const size = numDataBytesInBlock[0];
          const dataBytes = new Uint8Array(size);
          bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);
          const ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);
          blocks.push(new BlockPair(dataBytes, ecBytes));
          maxNumDataBytes = Math.max(maxNumDataBytes, size);
          maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
          dataBytesOffset += numDataBytesInBlock[0];
        }
        if (numDataBytes !== dataBytesOffset) {
          throw new WriterException("Data bytes does not match offset");
        }
        const result = new BitArray();
        for (let i = 0; i < maxNumDataBytes; ++i) {
          for (const block of blocks) {
            const dataBytes = block.getDataBytes();
            if (i < dataBytes.length) {
              result.appendBits(dataBytes[i], 8);
            }
          }
        }
        for (let i = 0; i < maxNumEcBytes; ++i) {
          for (const block of blocks) {
            const ecBytes = block.getErrorCorrectionBytes();
            if (i < ecBytes.length) {
              result.appendBits(ecBytes[i], 8);
            }
          }
        }
        if (numTotalBytes !== result.getSizeInBytes()) {
          throw new WriterException("Interleaving error: " + numTotalBytes + " and " + result.getSizeInBytes() + " differ.");
        }
        return result;
      }
      static generateECBytes(dataBytes, numEcBytesInBlock) {
        const numDataBytes = dataBytes.length;
        const toEncode = new Int32Array(numDataBytes + numEcBytesInBlock);
        for (let i = 0; i < numDataBytes; i++) {
          toEncode[i] = dataBytes[i] & 255;
        }
        new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);
        const ecBytes = new Uint8Array(numEcBytesInBlock);
        for (let i = 0; i < numEcBytesInBlock; i++) {
          ecBytes[i] = /*(byte) */
          toEncode[numDataBytes + i];
        }
        return ecBytes;
      }
      /**
       * Append mode info. On success, store the result in "bits".
       */
      static appendModeInfo(mode, bits) {
        bits.appendBits(mode.getBits(), 4);
      }
      /**
       * Append length info. On success, store the result in "bits".
       */
      static appendLengthInfo(numLetters, version2, mode, bits) {
        const numBits = mode.getCharacterCountBits(version2);
        if (numLetters >= 1 << numBits) {
          throw new WriterException(numLetters + " is bigger than " + ((1 << numBits) - 1));
        }
        bits.appendBits(numLetters, numBits);
      }
      /**
       * Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".
       */
      static appendBytes(content, mode, bits, encoding) {
        switch (mode) {
          case Mode$1.NUMERIC:
            Encoder.appendNumericBytes(content, bits);
            break;
          case Mode$1.ALPHANUMERIC:
            Encoder.appendAlphanumericBytes(content, bits);
            break;
          case Mode$1.BYTE:
            Encoder.append8BitBytes(content, bits, encoding);
            break;
          case Mode$1.KANJI:
            Encoder.appendKanjiBytes(content, bits);
            break;
          default:
            throw new WriterException("Invalid mode: " + mode);
        }
      }
      static getDigit(singleCharacter) {
        return singleCharacter.charCodeAt(0) - 48;
      }
      static isDigit(singleCharacter) {
        const cn = Encoder.getDigit(singleCharacter);
        return cn >= 0 && cn <= 9;
      }
      static appendNumericBytes(content, bits) {
        const length = content.length;
        let i = 0;
        while (i < length) {
          const num1 = Encoder.getDigit(content.charAt(i));
          if (i + 2 < length) {
            const num2 = Encoder.getDigit(content.charAt(i + 1));
            const num3 = Encoder.getDigit(content.charAt(i + 2));
            bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);
            i += 3;
          } else if (i + 1 < length) {
            const num2 = Encoder.getDigit(content.charAt(i + 1));
            bits.appendBits(num1 * 10 + num2, 7);
            i += 2;
          } else {
            bits.appendBits(num1, 4);
            i++;
          }
        }
      }
      static appendAlphanumericBytes(content, bits) {
        const length = content.length;
        let i = 0;
        while (i < length) {
          const code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));
          if (code1 === -1) {
            throw new WriterException();
          }
          if (i + 1 < length) {
            const code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));
            if (code2 === -1) {
              throw new WriterException();
            }
            bits.appendBits(code1 * 45 + code2, 11);
            i += 2;
          } else {
            bits.appendBits(code1, 6);
            i++;
          }
        }
      }
      static append8BitBytes(content, bits, encoding) {
        let bytes2;
        try {
          bytes2 = StringEncoding.encode(content, encoding);
        } catch (uee) {
          throw new WriterException(uee);
        }
        for (let i = 0, length = bytes2.length; i !== length; i++) {
          const b = bytes2[i];
          bits.appendBits(b, 8);
        }
      }
      /**
       * @throws WriterException
       */
      static appendKanjiBytes(content, bits) {
        let bytes2;
        try {
          bytes2 = StringEncoding.encode(content, CharacterSetECI.SJIS);
        } catch (uee) {
          throw new WriterException(uee);
        }
        const length = bytes2.length;
        for (let i = 0; i < length; i += 2) {
          const byte1 = bytes2[i] & 255;
          const byte2 = bytes2[i + 1] & 255;
          const code = byte1 << 8 & 4294967295 | byte2;
          let subtracted = -1;
          if (code >= 33088 && code <= 40956) {
            subtracted = code - 33088;
          } else if (code >= 57408 && code <= 60351) {
            subtracted = code - 49472;
          }
          if (subtracted === -1) {
            throw new WriterException("Invalid byte sequence");
          }
          const encoded = (subtracted >> 8) * 192 + (subtracted & 255);
          bits.appendBits(encoded, 13);
        }
      }
      static appendECI(eci, bits) {
        bits.appendBits(Mode$1.ECI.getBits(), 4);
        bits.appendBits(eci.getValue(), 8);
      }
    }
    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      36,
      -1,
      -1,
      -1,
      37,
      38,
      -1,
      -1,
      -1,
      -1,
      39,
      40,
      -1,
      41,
      42,
      43,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      44,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      -1,
      -1,
      -1,
      -1,
      -1
    ]);
    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName();
    class BrowserQRCodeSvgWriter {
      /**
       * Writes and renders a QRCode SVG element.
       *
       * @param contents
       * @param width
       * @param height
       * @param hints
       */
      write(contents, width, height, hints = null) {
        if (contents.length === 0) {
          throw new IllegalArgumentException("Found empty contents");
        }
        if (width < 0 || height < 0) {
          throw new IllegalArgumentException("Requested dimensions are too small: " + width + "x" + height);
        }
        let errorCorrectionLevel = ErrorCorrectionLevel.L;
        let quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;
        if (hints !== null) {
          if (void 0 !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
            errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
          }
          if (void 0 !== hints.get(EncodeHintType$1.MARGIN)) {
            quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
          }
        }
        const code = Encoder.encode(contents, errorCorrectionLevel, hints);
        return this.renderResult(code, width, height, quietZone);
      }
      /**
       * Renders the result and then appends it to the DOM.
       */
      writeToDom(containerElement, contents, width, height, hints = null) {
        if (typeof containerElement === "string") {
          containerElement = document.querySelector(containerElement);
        }
        const svgElement = this.write(contents, width, height, hints);
        if (containerElement)
          containerElement.appendChild(svgElement);
      }
      /**
       * Note that the input matrix uses 0 == white, 1 == black.
       * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
       */
      renderResult(code, width, height, quietZone) {
        const input = code.getMatrix();
        if (input === null) {
          throw new IllegalStateException();
        }
        const inputWidth = input.getWidth();
        const inputHeight = input.getHeight();
        const qrWidth = inputWidth + quietZone * 2;
        const qrHeight = inputHeight + quietZone * 2;
        const outputWidth = Math.max(width, qrWidth);
        const outputHeight = Math.max(height, qrHeight);
        const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
        const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
        const svgElement = this.createSVGElement(outputWidth, outputHeight);
        for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY) === 1) {
              const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
              svgElement.appendChild(svgRectElement);
            }
          }
        }
        return svgElement;
      }
      /**
       * Creates a SVG element.
       *
       * @param w SVG's width attribute
       * @param h SVG's height attribute
       */
      createSVGElement(w, h) {
        const svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, "svg");
        svgElement.setAttributeNS(null, "height", w.toString());
        svgElement.setAttributeNS(null, "width", h.toString());
        return svgElement;
      }
      /**
       * Creates a SVG rect element.
       *
       * @param x Element's x coordinate
       * @param y Element's y coordinate
       * @param w Element's width attribute
       * @param h Element's height attribute
       */
      createSvgRectElement(x, y, w, h) {
        const rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, "rect");
        rect.setAttributeNS(null, "x", x.toString());
        rect.setAttributeNS(null, "y", y.toString());
        rect.setAttributeNS(null, "height", w.toString());
        rect.setAttributeNS(null, "width", h.toString());
        rect.setAttributeNS(null, "fill", "#000000");
        return rect;
      }
    }
    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;
    BrowserQRCodeSvgWriter.SVG_NS = "http://www.w3.org/2000/svg";
    class QRCodeWriter {
      /*@Override*/
      // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix
      //     /*throws WriterException */ {
      //   return encode(contents, format, width, height, null)
      // }
      /*@Override*/
      encode(contents, format, width, height, hints) {
        if (contents.length === 0) {
          throw new IllegalArgumentException("Found empty contents");
        }
        if (format !== BarcodeFormat$1.QR_CODE) {
          throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format);
        }
        if (width < 0 || height < 0) {
          throw new IllegalArgumentException(`Requested dimensions are too small: ${width}x${height}`);
        }
        let errorCorrectionLevel = ErrorCorrectionLevel.L;
        let quietZone = QRCodeWriter.QUIET_ZONE_SIZE;
        if (hints !== null) {
          if (void 0 !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
            errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
          }
          if (void 0 !== hints.get(EncodeHintType$1.MARGIN)) {
            quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
          }
        }
        const code = Encoder.encode(contents, errorCorrectionLevel, hints);
        return QRCodeWriter.renderResult(code, width, height, quietZone);
      }
      // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses
      // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
      static renderResult(code, width, height, quietZone) {
        const input = code.getMatrix();
        if (input === null) {
          throw new IllegalStateException();
        }
        const inputWidth = input.getWidth();
        const inputHeight = input.getHeight();
        const qrWidth = inputWidth + quietZone * 2;
        const qrHeight = inputHeight + quietZone * 2;
        const outputWidth = Math.max(width, qrWidth);
        const outputHeight = Math.max(height, qrHeight);
        const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
        const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
        const output2 = new BitMatrix(outputWidth, outputHeight);
        for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY) === 1) {
              output2.setRegion(outputX, outputY, multiple, multiple);
            }
          }
        }
        return output2;
      }
    }
    QRCodeWriter.QUIET_ZONE_SIZE = 4;
    class MultiFormatWriter {
      /*@Override*/
      // public encode(contents: string,
      //                         format: BarcodeFormat,
      //                         width: number /*int*/,
      //                         height: number /*int*/): BitMatrix /*throws WriterException */ {
      //   return encode(contents, format, width, height, null)
      // }
      /*@Override*/
      encode(contents, format, width, height, hints) {
        let writer;
        switch (format) {
          case BarcodeFormat$1.QR_CODE:
            writer = new QRCodeWriter();
            break;
          default:
            throw new IllegalArgumentException("No encoder available for format " + format);
        }
        return writer.encode(contents, format, width, height, hints);
      }
    }
    class PlanarYUVLuminanceSource extends LuminanceSource {
      constructor(yuvData, dataWidth, dataHeight, left, top, width, height, reverseHorizontal) {
        super(width, height);
        this.yuvData = yuvData;
        this.dataWidth = dataWidth;
        this.dataHeight = dataHeight;
        this.left = left;
        this.top = top;
        if (left + width > dataWidth || top + height > dataHeight) {
          throw new IllegalArgumentException("Crop rectangle does not fit within image data.");
        }
        if (reverseHorizontal) {
          this.reverseHorizontal(width, height);
        }
      }
      /*@Override*/
      getRow(y, row) {
        if (y < 0 || y >= this.getHeight()) {
          throw new IllegalArgumentException("Requested row is outside the image: " + y);
        }
        const width = this.getWidth();
        if (row === null || row === void 0 || row.length < width) {
          row = new Uint8ClampedArray(width);
        }
        const offset = (y + this.top) * this.dataWidth + this.left;
        System.arraycopy(this.yuvData, offset, row, 0, width);
        return row;
      }
      /*@Override*/
      getMatrix() {
        const width = this.getWidth();
        const height = this.getHeight();
        if (width === this.dataWidth && height === this.dataHeight) {
          return this.yuvData;
        }
        const area = width * height;
        const matrix = new Uint8ClampedArray(area);
        let inputOffset = this.top * this.dataWidth + this.left;
        if (width === this.dataWidth) {
          System.arraycopy(this.yuvData, inputOffset, matrix, 0, area);
          return matrix;
        }
        for (let y = 0; y < height; y++) {
          const outputOffset = y * width;
          System.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);
          inputOffset += this.dataWidth;
        }
        return matrix;
      }
      /*@Override*/
      isCropSupported() {
        return true;
      }
      /*@Override*/
      crop(left, top, width, height) {
        return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);
      }
      renderThumbnail() {
        const width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        const height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        const pixels = new Int32Array(width * height);
        const yuv = this.yuvData;
        let inputOffset = this.top * this.dataWidth + this.left;
        for (let y = 0; y < height; y++) {
          const outputOffset = y * width;
          for (let x = 0; x < width; x++) {
            const grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 255;
            pixels[outputOffset + x] = 4278190080 | grey * 65793;
          }
          inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        }
        return pixels;
      }
      /**
       * @return width of image from {@link #renderThumbnail()}
       */
      getThumbnailWidth() {
        return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
      }
      /**
       * @return height of image from {@link #renderThumbnail()}
       */
      getThumbnailHeight() {
        return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
      }
      reverseHorizontal(width, height) {
        const yuvData = this.yuvData;
        for (let y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {
          const middle = rowStart + width / 2;
          for (let x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {
            const temp = yuvData[x1];
            yuvData[x1] = yuvData[x2];
            yuvData[x2] = temp;
          }
        }
      }
      invert() {
        return new InvertedLuminanceSource(this);
      }
    }
    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;
    class RGBLuminanceSource extends LuminanceSource {
      constructor(luminances, width, height, dataWidth, dataHeight, left, top) {
        super(width, height);
        this.dataWidth = dataWidth;
        this.dataHeight = dataHeight;
        this.left = left;
        this.top = top;
        if (luminances.BYTES_PER_ELEMENT === 4) {
          const size = width * height;
          const luminancesUint8Array = new Uint8ClampedArray(size);
          for (let offset = 0; offset < size; offset++) {
            const pixel = luminances[offset];
            const r = pixel >> 16 & 255;
            const g2 = pixel >> 7 & 510;
            const b = pixel & 255;
            luminancesUint8Array[offset] = /*(byte) */
            (r + g2 + b) / 4 & 255;
          }
          this.luminances = luminancesUint8Array;
        } else {
          this.luminances = luminances;
        }
        if (void 0 === dataWidth) {
          this.dataWidth = width;
        }
        if (void 0 === dataHeight) {
          this.dataHeight = height;
        }
        if (void 0 === left) {
          this.left = 0;
        }
        if (void 0 === top) {
          this.top = 0;
        }
        if (this.left + width > this.dataWidth || this.top + height > this.dataHeight) {
          throw new IllegalArgumentException("Crop rectangle does not fit within image data.");
        }
      }
      /*@Override*/
      getRow(y, row) {
        if (y < 0 || y >= this.getHeight()) {
          throw new IllegalArgumentException("Requested row is outside the image: " + y);
        }
        const width = this.getWidth();
        if (row === null || row === void 0 || row.length < width) {
          row = new Uint8ClampedArray(width);
        }
        const offset = (y + this.top) * this.dataWidth + this.left;
        System.arraycopy(this.luminances, offset, row, 0, width);
        return row;
      }
      /*@Override*/
      getMatrix() {
        const width = this.getWidth();
        const height = this.getHeight();
        if (width === this.dataWidth && height === this.dataHeight) {
          return this.luminances;
        }
        const area = width * height;
        const matrix = new Uint8ClampedArray(area);
        let inputOffset = this.top * this.dataWidth + this.left;
        if (width === this.dataWidth) {
          System.arraycopy(this.luminances, inputOffset, matrix, 0, area);
          return matrix;
        }
        for (let y = 0; y < height; y++) {
          const outputOffset = y * width;
          System.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
          inputOffset += this.dataWidth;
        }
        return matrix;
      }
      /*@Override*/
      isCropSupported() {
        return true;
      }
      /*@Override*/
      crop(left, top, width, height) {
        return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);
      }
      invert() {
        return new InvertedLuminanceSource(this);
      }
    }
    class Charset extends CharacterSetECI {
      static forName(name2) {
        return this.getCharacterSetECIByName(name2);
      }
    }
    class StandardCharsets {
    }
    StandardCharsets.ISO_8859_1 = CharacterSetECI.ISO8859_1;
    class AztecCode {
      /**
       * @return {@code true} if compact instead of full mode
       */
      isCompact() {
        return this.compact;
      }
      setCompact(compact) {
        this.compact = compact;
      }
      /**
       * @return size in pixels (width and height)
       */
      getSize() {
        return this.size;
      }
      setSize(size) {
        this.size = size;
      }
      /**
       * @return number of levels
       */
      getLayers() {
        return this.layers;
      }
      setLayers(layers) {
        this.layers = layers;
      }
      /**
       * @return number of data codewords
       */
      getCodeWords() {
        return this.codeWords;
      }
      setCodeWords(codeWords) {
        this.codeWords = codeWords;
      }
      /**
       * @return the symbol image
       */
      getMatrix() {
        return this.matrix;
      }
      setMatrix(matrix) {
        this.matrix = matrix;
      }
    }
    class Collections {
      /**
       * The singletonList(T) method is used to return an immutable list containing only the specified object.
       */
      static singletonList(item) {
        return [item];
      }
      /**
       * The min(Collection<? extends T>, Comparator<? super T>) method is used to return the minimum element of the given collection, according to the order induced by the specified comparator.
       */
      static min(collection, comparator) {
        return collection.sort(comparator)[0];
      }
    }
    class Token {
      constructor(previous) {
        this.previous = previous;
      }
      getPrevious() {
        return this.previous;
      }
    }
    class SimpleToken extends Token {
      constructor(previous, value, bitCount) {
        super(previous);
        this.value = value;
        this.bitCount = bitCount;
      }
      /**
       * @Override
       */
      appendTo(bitArray, text) {
        bitArray.appendBits(this.value, this.bitCount);
      }
      add(value, bitCount) {
        return new SimpleToken(this, value, bitCount);
      }
      addBinaryShift(start, byteCount) {
        console.warn("addBinaryShift on SimpleToken, this simply returns a copy of this token");
        return new SimpleToken(this, start, byteCount);
      }
      /**
       * @Override
       */
      toString() {
        let value = this.value & (1 << this.bitCount) - 1;
        value |= 1 << this.bitCount;
        return "<" + Integer.toBinaryString(value | 1 << this.bitCount).substring(1) + ">";
      }
    }
    class BinaryShiftToken extends SimpleToken {
      constructor(previous, binaryShiftStart, binaryShiftByteCount) {
        super(previous, 0, 0);
        this.binaryShiftStart = binaryShiftStart;
        this.binaryShiftByteCount = binaryShiftByteCount;
      }
      /**
       * @Override
       */
      appendTo(bitArray, text) {
        for (let i = 0; i < this.binaryShiftByteCount; i++) {
          if (i === 0 || i === 31 && this.binaryShiftByteCount <= 62) {
            bitArray.appendBits(31, 5);
            if (this.binaryShiftByteCount > 62) {
              bitArray.appendBits(this.binaryShiftByteCount - 31, 16);
            } else if (i === 0) {
              bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);
            } else {
              bitArray.appendBits(this.binaryShiftByteCount - 31, 5);
            }
          }
          bitArray.appendBits(text[this.binaryShiftStart + i], 8);
        }
      }
      addBinaryShift(start, byteCount) {
        return new BinaryShiftToken(this, start, byteCount);
      }
      /**
       * @Override
       */
      toString() {
        return "<" + this.binaryShiftStart + "::" + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + ">";
      }
    }
    function addBinaryShift(token2, start, byteCount) {
      return new BinaryShiftToken(token2, start, byteCount);
    }
    function add6(token2, value, bitCount) {
      return new SimpleToken(token2, value, bitCount);
    }
    const MODE_NAMES = [
      "UPPER",
      "LOWER",
      "DIGIT",
      "MIXED",
      "PUNCT"
    ];
    const MODE_UPPER = 0;
    const MODE_LOWER = 1;
    const MODE_DIGIT = 2;
    const MODE_MIXED = 3;
    const MODE_PUNCT = 4;
    const EMPTY_TOKEN = new SimpleToken(null, 0, 0);
    const LATCH_TABLE = [
      Int32Array.from([
        0,
        (5 << 16) + 28,
        (5 << 16) + 30,
        (5 << 16) + 29,
        (10 << 16) + (29 << 5) + 30
        // UPPER -> MIXED -> PUNCT
      ]),
      Int32Array.from([
        (9 << 16) + (30 << 4) + 14,
        0,
        (5 << 16) + 30,
        (5 << 16) + 29,
        (10 << 16) + (29 << 5) + 30
        // LOWER -> MIXED -> PUNCT
      ]),
      Int32Array.from([
        (4 << 16) + 14,
        (9 << 16) + (14 << 5) + 28,
        0,
        (9 << 16) + (14 << 5) + 29,
        (14 << 16) + (14 << 10) + (29 << 5) + 30
        // DIGIT -> UPPER -> MIXED -> PUNCT
      ]),
      Int32Array.from([
        (5 << 16) + 29,
        (5 << 16) + 28,
        (10 << 16) + (29 << 5) + 30,
        0,
        (5 << 16) + 30
        // MIXED -> PUNCT
      ]),
      Int32Array.from([
        (5 << 16) + 31,
        (10 << 16) + (31 << 5) + 28,
        (10 << 16) + (31 << 5) + 30,
        (10 << 16) + (31 << 5) + 29,
        0
      ])
    ];
    function static_SHIFT_TABLE(SHIFT_TABLE2) {
      for (let table of SHIFT_TABLE2) {
        Arrays.fill(table, -1);
      }
      SHIFT_TABLE2[MODE_UPPER][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_LOWER][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_LOWER][MODE_UPPER] = 28;
      SHIFT_TABLE2[MODE_MIXED][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_DIGIT][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_DIGIT][MODE_UPPER] = 15;
      return SHIFT_TABLE2;
    }
    const SHIFT_TABLE = static_SHIFT_TABLE(Arrays.createInt32Array(6, 6));
    class State {
      constructor(token2, mode, binaryBytes, bitCount) {
        this.token = token2;
        this.mode = mode;
        this.binaryShiftByteCount = binaryBytes;
        this.bitCount = bitCount;
      }
      getMode() {
        return this.mode;
      }
      getToken() {
        return this.token;
      }
      getBinaryShiftByteCount() {
        return this.binaryShiftByteCount;
      }
      getBitCount() {
        return this.bitCount;
      }
      // Create a new state representing this state with a latch to a (not
      // necessary different) mode, and then a code.
      latchAndAppend(mode, value) {
        let bitCount = this.bitCount;
        let token2 = this.token;
        if (mode !== this.mode) {
          let latch = LATCH_TABLE[this.mode][mode];
          token2 = add6(token2, latch & 65535, latch >> 16);
          bitCount += latch >> 16;
        }
        let latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;
        token2 = add6(token2, value, latchModeBitCount);
        return new State(token2, mode, 0, bitCount + latchModeBitCount);
      }
      // Create a new state representing this state, with a temporary shift
      // to a different mode to output a single value.
      shiftAndAppend(mode, value) {
        let token2 = this.token;
        let thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;
        token2 = add6(token2, SHIFT_TABLE[this.mode][mode], thisModeBitCount);
        token2 = add6(token2, value, 5);
        return new State(token2, this.mode, 0, this.bitCount + thisModeBitCount + 5);
      }
      // Create a new state representing this state, but an additional character
      // output in Binary Shift mode.
      addBinaryShiftChar(index2) {
        let token2 = this.token;
        let mode = this.mode;
        let bitCount = this.bitCount;
        if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {
          let latch = LATCH_TABLE[mode][MODE_UPPER];
          token2 = add6(token2, latch & 65535, latch >> 16);
          bitCount += latch >> 16;
          mode = MODE_UPPER;
        }
        let deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;
        let result = new State(token2, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);
        if (result.binaryShiftByteCount === 2047 + 31) {
          result = result.endBinaryShift(index2 + 1);
        }
        return result;
      }
      // Create the state identical to this one, but we are no longer in
      // Binary Shift mode.
      endBinaryShift(index2) {
        if (this.binaryShiftByteCount === 0) {
          return this;
        }
        let token2 = this.token;
        token2 = addBinaryShift(token2, index2 - this.binaryShiftByteCount, this.binaryShiftByteCount);
        return new State(token2, this.mode, 0, this.bitCount);
      }
      // Returns true if "this" state is better (equal: or) to be in than "that"
      // state under all possible circumstances.
      isBetterThanOrEqualTo(other) {
        let newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);
        if (this.binaryShiftByteCount < other.binaryShiftByteCount) {
          newModeBitCount += State.calculateBinaryShiftCost(other) - State.calculateBinaryShiftCost(this);
        } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {
          newModeBitCount += 10;
        }
        return newModeBitCount <= other.bitCount;
      }
      toBitArray(text) {
        let symbols = [];
        for (let token2 = this.endBinaryShift(text.length).token; token2 !== null; token2 = token2.getPrevious()) {
          symbols.unshift(token2);
        }
        let bitArray = new BitArray();
        for (const symbol of symbols) {
          symbol.appendTo(bitArray, text);
        }
        return bitArray;
      }
      /**
       * @Override
       */
      toString() {
        return StringUtils.format("%s bits=%d bytes=%d", MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);
      }
      static calculateBinaryShiftCost(state) {
        if (state.binaryShiftByteCount > 62) {
          return 21;
        }
        if (state.binaryShiftByteCount > 31) {
          return 20;
        }
        if (state.binaryShiftByteCount > 0) {
          return 10;
        }
        return 0;
      }
    }
    State.INITIAL_STATE = new State(EMPTY_TOKEN, MODE_UPPER, 0, 0);
    function static_CHAR_MAP(CHAR_MAP2) {
      const spaceCharCode = StringUtils.getCharCode(" ");
      const pointCharCode = StringUtils.getCharCode(".");
      const commaCharCode = StringUtils.getCharCode(",");
      CHAR_MAP2[MODE_UPPER][spaceCharCode] = 1;
      const zUpperCharCode = StringUtils.getCharCode("Z");
      const aUpperCharCode = StringUtils.getCharCode("A");
      for (let c = aUpperCharCode; c <= zUpperCharCode; c++) {
        CHAR_MAP2[MODE_UPPER][c] = c - aUpperCharCode + 2;
      }
      CHAR_MAP2[MODE_LOWER][spaceCharCode] = 1;
      const zLowerCharCode = StringUtils.getCharCode("z");
      const aLowerCharCode = StringUtils.getCharCode("a");
      for (let c = aLowerCharCode; c <= zLowerCharCode; c++) {
        CHAR_MAP2[MODE_LOWER][c] = c - aLowerCharCode + 2;
      }
      CHAR_MAP2[MODE_DIGIT][spaceCharCode] = 1;
      const nineCharCode = StringUtils.getCharCode("9");
      const zeroCharCode = StringUtils.getCharCode("0");
      for (let c = zeroCharCode; c <= nineCharCode; c++) {
        CHAR_MAP2[MODE_DIGIT][c] = c - zeroCharCode + 2;
      }
      CHAR_MAP2[MODE_DIGIT][commaCharCode] = 12;
      CHAR_MAP2[MODE_DIGIT][pointCharCode] = 13;
      const mixedTable = [
        "\0",
        " ",
        "",
        "",
        "",
        "",
        "",
        "",
        "\x07",
        "\b",
        "	",
        "\n",
        "\v",
        "\f",
        "\r",
        "\x1B",
        "",
        "",
        "",
        "",
        "@",
        "\\",
        "^",
        "_",
        "`",
        "|",
        "~",
        ""
      ];
      for (let i = 0; i < mixedTable.length; i++) {
        CHAR_MAP2[MODE_MIXED][StringUtils.getCharCode(mixedTable[i])] = i;
      }
      const punctTable = [
        "\0",
        "\r",
        "\0",
        "\0",
        "\0",
        "\0",
        "!",
        "'",
        "#",
        "$",
        "%",
        "&",
        "'",
        "(",
        ")",
        "*",
        "+",
        ",",
        "-",
        ".",
        "/",
        ":",
        ";",
        "<",
        "=",
        ">",
        "?",
        "[",
        "]",
        "{",
        "}"
      ];
      for (let i = 0; i < punctTable.length; i++) {
        if (StringUtils.getCharCode(punctTable[i]) > 0) {
          CHAR_MAP2[MODE_PUNCT][StringUtils.getCharCode(punctTable[i])] = i;
        }
      }
      return CHAR_MAP2;
    }
    const CHAR_MAP = static_CHAR_MAP(Arrays.createInt32Array(5, 256));
    class HighLevelEncoder {
      constructor(text) {
        this.text = text;
      }
      /**
       * @return text represented by this encoder encoded as a {@link BitArray}
       */
      encode() {
        const spaceCharCode = StringUtils.getCharCode(" ");
        const lineBreakCharCode = StringUtils.getCharCode("\n");
        let states = Collections.singletonList(State.INITIAL_STATE);
        for (let index2 = 0; index2 < this.text.length; index2++) {
          let pairCode;
          let nextChar = index2 + 1 < this.text.length ? this.text[index2 + 1] : 0;
          switch (this.text[index2]) {
            case StringUtils.getCharCode("\r"):
              pairCode = nextChar === lineBreakCharCode ? 2 : 0;
              break;
            case StringUtils.getCharCode("."):
              pairCode = nextChar === spaceCharCode ? 3 : 0;
              break;
            case StringUtils.getCharCode(","):
              pairCode = nextChar === spaceCharCode ? 4 : 0;
              break;
            case StringUtils.getCharCode(":"):
              pairCode = nextChar === spaceCharCode ? 5 : 0;
              break;
            default:
              pairCode = 0;
          }
          if (pairCode > 0) {
            states = HighLevelEncoder.updateStateListForPair(states, index2, pairCode);
            index2++;
          } else {
            states = this.updateStateListForChar(states, index2);
          }
        }
        const minState = Collections.min(states, (a, b) => {
          return a.getBitCount() - b.getBitCount();
        });
        return minState.toBitArray(this.text);
      }
      // We update a set of states for a new character by updating each state
      // for the new character, merging the results, and then removing the
      // non-optimal states.
      updateStateListForChar(states, index2) {
        const result = [];
        for (let state of states) {
          this.updateStateForChar(state, index2, result);
        }
        return HighLevelEncoder.simplifyStates(result);
      }
      // Return a set of states that represent the possible ways of updating this
      // state for the next character.  The resulting set of states are added to
      // the "result" list.
      updateStateForChar(state, index2, result) {
        let ch = this.text[index2] & 255;
        let charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;
        let stateNoBinary = null;
        for (let mode = 0; mode <= MODE_PUNCT; mode++) {
          let charInMode = CHAR_MAP[mode][ch];
          if (charInMode > 0) {
            if (stateNoBinary == null) {
              stateNoBinary = state.endBinaryShift(index2);
            }
            if (!charInCurrentTable || mode === state.getMode() || mode === MODE_DIGIT) {
              const latchState = stateNoBinary.latchAndAppend(mode, charInMode);
              result.push(latchState);
            }
            if (!charInCurrentTable && SHIFT_TABLE[state.getMode()][mode] >= 0) {
              const shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);
              result.push(shiftState);
            }
          }
        }
        if (state.getBinaryShiftByteCount() > 0 || CHAR_MAP[state.getMode()][ch] === 0) {
          let binaryState = state.addBinaryShiftChar(index2);
          result.push(binaryState);
        }
      }
      static updateStateListForPair(states, index2, pairCode) {
        const result = [];
        for (let state of states) {
          this.updateStateForPair(state, index2, pairCode, result);
        }
        return this.simplifyStates(result);
      }
      static updateStateForPair(state, index2, pairCode, result) {
        let stateNoBinary = state.endBinaryShift(index2);
        result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));
        if (state.getMode() !== MODE_PUNCT) {
          result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));
        }
        if (pairCode === 3 || pairCode === 4) {
          let digitState = stateNoBinary.latchAndAppend(MODE_DIGIT, 16 - pairCode).latchAndAppend(MODE_DIGIT, 1);
          result.push(digitState);
        }
        if (state.getBinaryShiftByteCount() > 0) {
          let binaryState = state.addBinaryShiftChar(index2).addBinaryShiftChar(index2 + 1);
          result.push(binaryState);
        }
      }
      static simplifyStates(states) {
        let result = [];
        for (const newState of states) {
          let add7 = true;
          for (const oldState of result) {
            if (oldState.isBetterThanOrEqualTo(newState)) {
              add7 = false;
              break;
            }
            if (newState.isBetterThanOrEqualTo(oldState)) {
              result = result.filter((x) => x !== oldState);
            }
          }
          if (add7) {
            result.push(newState);
          }
        }
        return result;
      }
    }
    class Encoder$1 {
      constructor() {
      }
      /**
       * Encodes the given binary content as an Aztec symbol
       *
       * @param data input data string
       * @return Aztec symbol matrix with metadata
       */
      static encodeBytes(data) {
        return Encoder$1.encode(data, Encoder$1.DEFAULT_EC_PERCENT, Encoder$1.DEFAULT_AZTEC_LAYERS);
      }
      /**
       * Encodes the given binary content as an Aztec symbol
       *
       * @param data input data string
       * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,
       *                      a minimum of 23% + 3 words is recommended)
       * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers
       * @return Aztec symbol matrix with metadata
       */
      static encode(data, minECCPercent, userSpecifiedLayers) {
        let bits = new HighLevelEncoder(data).encode();
        let eccBits = Integer.truncDivision(bits.getSize() * minECCPercent, 100) + 11;
        let totalSizeBits = bits.getSize() + eccBits;
        let compact;
        let layers;
        let totalBitsInLayer;
        let wordSize;
        let stuffedBits;
        if (userSpecifiedLayers !== Encoder$1.DEFAULT_AZTEC_LAYERS) {
          compact = userSpecifiedLayers < 0;
          layers = Math.abs(userSpecifiedLayers);
          if (layers > (compact ? Encoder$1.MAX_NB_BITS_COMPACT : Encoder$1.MAX_NB_BITS)) {
            throw new IllegalArgumentException(StringUtils.format("Illegal value %s for layers", userSpecifiedLayers));
          }
          totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);
          wordSize = Encoder$1.WORD_SIZE[layers];
          let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
          stuffedBits = Encoder$1.stuffBits(bits, wordSize);
          if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {
            throw new IllegalArgumentException("Data to large for user specified layer");
          }
          if (compact && stuffedBits.getSize() > wordSize * 64) {
            throw new IllegalArgumentException("Data to large for user specified layer");
          }
        } else {
          wordSize = 0;
          stuffedBits = null;
          for (let i = 0; ; i++) {
            if (i > Encoder$1.MAX_NB_BITS) {
              throw new IllegalArgumentException("Data too large for an Aztec code");
            }
            compact = i <= 3;
            layers = compact ? i + 1 : i;
            totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);
            if (totalSizeBits > totalBitsInLayer) {
              continue;
            }
            if (stuffedBits == null || wordSize !== Encoder$1.WORD_SIZE[layers]) {
              wordSize = Encoder$1.WORD_SIZE[layers];
              stuffedBits = Encoder$1.stuffBits(bits, wordSize);
            }
            let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
            if (compact && stuffedBits.getSize() > wordSize * 64) {
              continue;
            }
            if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {
              break;
            }
          }
        }
        let messageBits = Encoder$1.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);
        let messageSizeInWords = stuffedBits.getSize() / wordSize;
        let modeMessage = Encoder$1.generateModeMessage(compact, layers, messageSizeInWords);
        let baseMatrixSize = (compact ? 11 : 14) + layers * 4;
        let alignmentMap = new Int32Array(baseMatrixSize);
        let matrixSize;
        if (compact) {
          matrixSize = baseMatrixSize;
          for (let i = 0; i < alignmentMap.length; i++) {
            alignmentMap[i] = i;
          }
        } else {
          matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);
          let origCenter = Integer.truncDivision(baseMatrixSize, 2);
          let center = Integer.truncDivision(matrixSize, 2);
          for (let i = 0; i < origCenter; i++) {
            let newOffset = i + Integer.truncDivision(i, 15);
            alignmentMap[origCenter - i - 1] = center - newOffset - 1;
            alignmentMap[origCenter + i] = center + newOffset + 1;
          }
        }
        let matrix = new BitMatrix(matrixSize);
        for (let i = 0, rowOffset = 0; i < layers; i++) {
          let rowSize = (layers - i) * 4 + (compact ? 9 : 12);
          for (let j = 0; j < rowSize; j++) {
            let columnOffset = j * 2;
            for (let k = 0; k < 2; k++) {
              if (messageBits.get(rowOffset + columnOffset + k)) {
                matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);
              }
              if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {
                matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);
              }
              if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {
                matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);
              }
              if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {
                matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);
              }
            }
          }
          rowOffset += rowSize * 8;
        }
        Encoder$1.drawModeMessage(matrix, compact, matrixSize, modeMessage);
        if (compact) {
          Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);
        } else {
          Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);
          for (let i = 0, j = 0; i < Integer.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {
            for (let k = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {
              matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);
              matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);
              matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);
              matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);
            }
          }
        }
        let aztec = new AztecCode();
        aztec.setCompact(compact);
        aztec.setSize(matrixSize);
        aztec.setLayers(layers);
        aztec.setCodeWords(messageSizeInWords);
        aztec.setMatrix(matrix);
        return aztec;
      }
      static drawBullsEye(matrix, center, size) {
        for (let i = 0; i < size; i += 2) {
          for (let j = center - i; j <= center + i; j++) {
            matrix.set(j, center - i);
            matrix.set(j, center + i);
            matrix.set(center - i, j);
            matrix.set(center + i, j);
          }
        }
        matrix.set(center - size, center - size);
        matrix.set(center - size + 1, center - size);
        matrix.set(center - size, center - size + 1);
        matrix.set(center + size, center - size);
        matrix.set(center + size, center - size + 1);
        matrix.set(center + size, center + size - 1);
      }
      static generateModeMessage(compact, layers, messageSizeInWords) {
        let modeMessage = new BitArray();
        if (compact) {
          modeMessage.appendBits(layers - 1, 2);
          modeMessage.appendBits(messageSizeInWords - 1, 6);
          modeMessage = Encoder$1.generateCheckWords(modeMessage, 28, 4);
        } else {
          modeMessage.appendBits(layers - 1, 5);
          modeMessage.appendBits(messageSizeInWords - 1, 11);
          modeMessage = Encoder$1.generateCheckWords(modeMessage, 40, 4);
        }
        return modeMessage;
      }
      static drawModeMessage(matrix, compact, matrixSize, modeMessage) {
        let center = Integer.truncDivision(matrixSize, 2);
        if (compact) {
          for (let i = 0; i < 7; i++) {
            let offset = center - 3 + i;
            if (modeMessage.get(i)) {
              matrix.set(offset, center - 5);
            }
            if (modeMessage.get(i + 7)) {
              matrix.set(center + 5, offset);
            }
            if (modeMessage.get(20 - i)) {
              matrix.set(offset, center + 5);
            }
            if (modeMessage.get(27 - i)) {
              matrix.set(center - 5, offset);
            }
          }
        } else {
          for (let i = 0; i < 10; i++) {
            let offset = center - 5 + i + Integer.truncDivision(i, 5);
            if (modeMessage.get(i)) {
              matrix.set(offset, center - 7);
            }
            if (modeMessage.get(i + 10)) {
              matrix.set(center + 7, offset);
            }
            if (modeMessage.get(29 - i)) {
              matrix.set(offset, center + 7);
            }
            if (modeMessage.get(39 - i)) {
              matrix.set(center - 7, offset);
            }
          }
        }
      }
      static generateCheckWords(bitArray, totalBits, wordSize) {
        let messageSizeInWords = bitArray.getSize() / wordSize;
        let rs = new ReedSolomonEncoder(Encoder$1.getGF(wordSize));
        let totalWords = Integer.truncDivision(totalBits, wordSize);
        let messageWords = Encoder$1.bitsToWords(bitArray, wordSize, totalWords);
        rs.encode(messageWords, totalWords - messageSizeInWords);
        let startPad = totalBits % wordSize;
        let messageBits = new BitArray();
        messageBits.appendBits(0, startPad);
        for (const messageWord of Array.from(messageWords)) {
          messageBits.appendBits(messageWord, wordSize);
        }
        return messageBits;
      }
      static bitsToWords(stuffedBits, wordSize, totalWords) {
        let message2 = new Int32Array(totalWords);
        let i;
        let n;
        for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {
          let value = 0;
          for (let j = 0; j < wordSize; j++) {
            value |= stuffedBits.get(i * wordSize + j) ? 1 << wordSize - j - 1 : 0;
          }
          message2[i] = value;
        }
        return message2;
      }
      static getGF(wordSize) {
        switch (wordSize) {
          case 4:
            return GenericGF.AZTEC_PARAM;
          case 6:
            return GenericGF.AZTEC_DATA_6;
          case 8:
            return GenericGF.AZTEC_DATA_8;
          case 10:
            return GenericGF.AZTEC_DATA_10;
          case 12:
            return GenericGF.AZTEC_DATA_12;
          default:
            throw new IllegalArgumentException("Unsupported word size " + wordSize);
        }
      }
      static stuffBits(bits, wordSize) {
        let out = new BitArray();
        let n = bits.getSize();
        let mask2 = (1 << wordSize) - 2;
        for (let i = 0; i < n; i += wordSize) {
          let word = 0;
          for (let j = 0; j < wordSize; j++) {
            if (i + j >= n || bits.get(i + j)) {
              word |= 1 << wordSize - 1 - j;
            }
          }
          if ((word & mask2) === mask2) {
            out.appendBits(word & mask2, wordSize);
            i--;
          } else if ((word & mask2) === 0) {
            out.appendBits(word | 1, wordSize);
            i--;
          } else {
            out.appendBits(word, wordSize);
          }
        }
        return out;
      }
      static totalBitsInLayer(layers, compact) {
        return ((compact ? 88 : 112) + 16 * layers) * layers;
      }
    }
    Encoder$1.DEFAULT_EC_PERCENT = 33;
    Encoder$1.DEFAULT_AZTEC_LAYERS = 0;
    Encoder$1.MAX_NB_BITS = 32;
    Encoder$1.MAX_NB_BITS_COMPACT = 4;
    Encoder$1.WORD_SIZE = Int32Array.from([
      4,
      6,
      6,
      8,
      8,
      8,
      8,
      8,
      8,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      12,
      12,
      12,
      12,
      12,
      12,
      12,
      12,
      12,
      12
    ]);
    class AztecWriter {
      // @Override
      encode(contents, format, width, height) {
        return this.encodeWithHints(contents, format, width, height, null);
      }
      // @Override
      encodeWithHints(contents, format, width, height, hints) {
        let charset = StandardCharsets.ISO_8859_1;
        let eccPercent = Encoder$1.DEFAULT_EC_PERCENT;
        let layers = Encoder$1.DEFAULT_AZTEC_LAYERS;
        if (hints != null) {
          if (hints.has(EncodeHintType$1.CHARACTER_SET)) {
            charset = Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());
          }
          if (hints.has(EncodeHintType$1.ERROR_CORRECTION)) {
            eccPercent = Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
          }
          if (hints.has(EncodeHintType$1.AZTEC_LAYERS)) {
            layers = Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());
          }
        }
        return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);
      }
      static encodeLayers(contents, format, width, height, charset, eccPercent, layers) {
        if (format !== BarcodeFormat$1.AZTEC) {
          throw new IllegalArgumentException("Can only encode AZTEC, but got " + format);
        }
        let aztec = Encoder$1.encode(StringUtils.getBytes(contents, charset), eccPercent, layers);
        return AztecWriter.renderResult(aztec, width, height);
      }
      static renderResult(code, width, height) {
        let input = code.getMatrix();
        if (input == null) {
          throw new IllegalStateException();
        }
        let inputWidth = input.getWidth();
        let inputHeight = input.getHeight();
        let outputWidth = Math.max(width, inputWidth);
        let outputHeight = Math.max(height, inputHeight);
        let multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);
        let leftPadding = (outputWidth - inputWidth * multiple) / 2;
        let topPadding = (outputHeight - inputHeight * multiple) / 2;
        let output2 = new BitMatrix(outputWidth, outputHeight);
        for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY)) {
              output2.setRegion(outputX, outputY, multiple, multiple);
            }
          }
        }
        return output2;
      }
    }
    exports2.AbstractExpandedDecoder = AbstractExpandedDecoder;
    exports2.ArgumentException = ArgumentException;
    exports2.ArithmeticException = ArithmeticException;
    exports2.AztecCode = AztecCode;
    exports2.AztecCodeReader = AztecReader;
    exports2.AztecCodeWriter = AztecWriter;
    exports2.AztecDecoder = Decoder2;
    exports2.AztecDetector = Detector;
    exports2.AztecDetectorResult = AztecDetectorResult;
    exports2.AztecEncoder = Encoder$1;
    exports2.AztecHighLevelEncoder = HighLevelEncoder;
    exports2.AztecPoint = Point2;
    exports2.BarcodeFormat = BarcodeFormat$1;
    exports2.Binarizer = Binarizer;
    exports2.BinaryBitmap = BinaryBitmap;
    exports2.BitArray = BitArray;
    exports2.BitMatrix = BitMatrix;
    exports2.BitSource = BitSource;
    exports2.BrowserAztecCodeReader = BrowserAztecCodeReader;
    exports2.BrowserBarcodeReader = BrowserBarcodeReader;
    exports2.BrowserCodeReader = BrowserCodeReader;
    exports2.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;
    exports2.BrowserMultiFormatReader = BrowserMultiFormatReader;
    exports2.BrowserPDF417Reader = BrowserPDF417Reader;
    exports2.BrowserQRCodeReader = BrowserQRCodeReader;
    exports2.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;
    exports2.CharacterSetECI = CharacterSetECI;
    exports2.ChecksumException = ChecksumException;
    exports2.Code128Reader = Code128Reader;
    exports2.Code39Reader = Code39Reader;
    exports2.DataMatrixDecodedBitStreamParser = DecodedBitStreamParser;
    exports2.DataMatrixReader = DataMatrixReader;
    exports2.DecodeHintType = DecodeHintType$1;
    exports2.DecoderResult = DecoderResult;
    exports2.DefaultGridSampler = DefaultGridSampler;
    exports2.DetectorResult = DetectorResult;
    exports2.EAN13Reader = EAN13Reader;
    exports2.EncodeHintType = EncodeHintType$1;
    exports2.Exception = Exception;
    exports2.FormatException = FormatException;
    exports2.GenericGF = GenericGF;
    exports2.GenericGFPoly = GenericGFPoly;
    exports2.GlobalHistogramBinarizer = GlobalHistogramBinarizer;
    exports2.GridSampler = GridSampler;
    exports2.GridSamplerInstance = GridSamplerInstance;
    exports2.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;
    exports2.HybridBinarizer = HybridBinarizer;
    exports2.ITFReader = ITFReader;
    exports2.IllegalArgumentException = IllegalArgumentException;
    exports2.IllegalStateException = IllegalStateException;
    exports2.InvertedLuminanceSource = InvertedLuminanceSource;
    exports2.LuminanceSource = LuminanceSource;
    exports2.MathUtils = MathUtils;
    exports2.MultiFormatOneDReader = MultiFormatOneDReader;
    exports2.MultiFormatReader = MultiFormatReader;
    exports2.MultiFormatWriter = MultiFormatWriter;
    exports2.NotFoundException = NotFoundException;
    exports2.OneDReader = OneDReader;
    exports2.PDF417DecodedBitStreamParser = DecodedBitStreamParser$2;
    exports2.PDF417DecoderErrorCorrection = ErrorCorrection;
    exports2.PDF417Reader = PDF417Reader;
    exports2.PDF417ResultMetadata = PDF417ResultMetadata;
    exports2.PerspectiveTransform = PerspectiveTransform;
    exports2.PlanarYUVLuminanceSource = PlanarYUVLuminanceSource;
    exports2.QRCodeByteMatrix = ByteMatrix;
    exports2.QRCodeDataMask = DataMask;
    exports2.QRCodeDecodedBitStreamParser = DecodedBitStreamParser$1;
    exports2.QRCodeDecoderErrorCorrectionLevel = ErrorCorrectionLevel;
    exports2.QRCodeDecoderFormatInformation = FormatInformation;
    exports2.QRCodeEncoder = Encoder;
    exports2.QRCodeEncoderQRCode = QRCode;
    exports2.QRCodeMaskUtil = MaskUtil;
    exports2.QRCodeMatrixUtil = MatrixUtil;
    exports2.QRCodeMode = Mode$1;
    exports2.QRCodeReader = QRCodeReader;
    exports2.QRCodeVersion = Version$1;
    exports2.QRCodeWriter = QRCodeWriter;
    exports2.RGBLuminanceSource = RGBLuminanceSource;
    exports2.RSS14Reader = RSS14Reader;
    exports2.RSSExpandedReader = RSSExpandedReader;
    exports2.ReaderException = ReaderException;
    exports2.ReedSolomonDecoder = ReedSolomonDecoder;
    exports2.ReedSolomonEncoder = ReedSolomonEncoder;
    exports2.ReedSolomonException = ReedSolomonException;
    exports2.Result = Result;
    exports2.ResultMetadataType = ResultMetadataType$1;
    exports2.ResultPoint = ResultPoint;
    exports2.StringUtils = StringUtils;
    exports2.UnsupportedOperationException = UnsupportedOperationException;
    exports2.VideoInputDevice = VideoInputDevice;
    exports2.WhiteRectangleDetector = WhiteRectangleDetector;
    exports2.WriterException = WriterException;
    exports2.ZXingArrays = Arrays;
    exports2.ZXingCharset = Charset;
    exports2.ZXingInteger = Integer;
    exports2.ZXingStandardCharsets = StandardCharsets;
    exports2.ZXingStringBuilder = StringBuilder;
    exports2.ZXingStringEncoding = StringEncoding;
    exports2.ZXingSystem = System;
    exports2.createAbstractExpandedDecoder = createDecoder;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(zxingJs_umd$1, zxingJs_umd$1.exports);
var zxingJs_umdExports = zxingJs_umd$1.exports;
const zxingJs_umd = /* @__PURE__ */ getDefaultExportFromCjs(zxingJs_umdExports);
const ZXing = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: zxingJs_umd
}, [zxingJs_umdExports]);
var ZXingHtml5QrcodeDecoder = function() {
  function ZXingHtml5QrcodeDecoder2(requestedFormats, verbose, logger) {
    this.formatMap = /* @__PURE__ */ new Map([
      [Html5QrcodeSupportedFormats.QR_CODE, zxingJs_umdExports.BarcodeFormat.QR_CODE],
      [Html5QrcodeSupportedFormats.AZTEC, zxingJs_umdExports.BarcodeFormat.AZTEC],
      [Html5QrcodeSupportedFormats.CODABAR, zxingJs_umdExports.BarcodeFormat.CODABAR],
      [Html5QrcodeSupportedFormats.CODE_39, zxingJs_umdExports.BarcodeFormat.CODE_39],
      [Html5QrcodeSupportedFormats.CODE_93, zxingJs_umdExports.BarcodeFormat.CODE_93],
      [
        Html5QrcodeSupportedFormats.CODE_128,
        zxingJs_umdExports.BarcodeFormat.CODE_128
      ],
      [
        Html5QrcodeSupportedFormats.DATA_MATRIX,
        zxingJs_umdExports.BarcodeFormat.DATA_MATRIX
      ],
      [
        Html5QrcodeSupportedFormats.MAXICODE,
        zxingJs_umdExports.BarcodeFormat.MAXICODE
      ],
      [Html5QrcodeSupportedFormats.ITF, zxingJs_umdExports.BarcodeFormat.ITF],
      [Html5QrcodeSupportedFormats.EAN_13, zxingJs_umdExports.BarcodeFormat.EAN_13],
      [Html5QrcodeSupportedFormats.EAN_8, zxingJs_umdExports.BarcodeFormat.EAN_8],
      [Html5QrcodeSupportedFormats.PDF_417, zxingJs_umdExports.BarcodeFormat.PDF_417],
      [Html5QrcodeSupportedFormats.RSS_14, zxingJs_umdExports.BarcodeFormat.RSS_14],
      [
        Html5QrcodeSupportedFormats.RSS_EXPANDED,
        zxingJs_umdExports.BarcodeFormat.RSS_EXPANDED
      ],
      [Html5QrcodeSupportedFormats.UPC_A, zxingJs_umdExports.BarcodeFormat.UPC_A],
      [Html5QrcodeSupportedFormats.UPC_E, zxingJs_umdExports.BarcodeFormat.UPC_E],
      [
        Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,
        zxingJs_umdExports.BarcodeFormat.UPC_EAN_EXTENSION
      ]
    ]);
    this.reverseFormatMap = this.createReverseFormatMap();
    if (!ZXing) {
      throw "Use html5qrcode.min.js without edit, ZXing not found.";
    }
    this.verbose = verbose;
    this.logger = logger;
    var formats = this.createZXingFormats(requestedFormats);
    var hints = /* @__PURE__ */ new Map();
    hints.set(zxingJs_umdExports.DecodeHintType.POSSIBLE_FORMATS, formats);
    hints.set(zxingJs_umdExports.DecodeHintType.TRY_HARDER, false);
    this.hints = hints;
  }
  ZXingHtml5QrcodeDecoder2.prototype.decodeAsync = function(canvas) {
    var _this = this;
    return new Promise(function(resolve2, reject) {
      try {
        resolve2(_this.decode(canvas));
      } catch (error) {
        reject(error);
      }
    });
  };
  ZXingHtml5QrcodeDecoder2.prototype.decode = function(canvas) {
    var zxingDecoder = new zxingJs_umdExports.MultiFormatReader(this.verbose, this.hints);
    var luminanceSource = new zxingJs_umdExports.HTMLCanvasElementLuminanceSource(canvas);
    var binaryBitmap = new zxingJs_umdExports.BinaryBitmap(new zxingJs_umdExports.HybridBinarizer(luminanceSource));
    var result = zxingDecoder.decode(binaryBitmap);
    return {
      text: result.text,
      format: QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(result.format)),
      debugData: this.createDebugData()
    };
  };
  ZXingHtml5QrcodeDecoder2.prototype.createReverseFormatMap = function() {
    var result = /* @__PURE__ */ new Map();
    this.formatMap.forEach(function(value, key2, _) {
      result.set(value, key2);
    });
    return result;
  };
  ZXingHtml5QrcodeDecoder2.prototype.toHtml5QrcodeSupportedFormats = function(zxingFormat) {
    if (!this.reverseFormatMap.has(zxingFormat)) {
      throw "reverseFormatMap doesn't have ".concat(zxingFormat);
    }
    return this.reverseFormatMap.get(zxingFormat);
  };
  ZXingHtml5QrcodeDecoder2.prototype.createZXingFormats = function(requestedFormats) {
    var zxingFormats = [];
    for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {
      var requestedFormat = requestedFormats_1[_i];
      if (this.formatMap.has(requestedFormat)) {
        zxingFormats.push(this.formatMap.get(requestedFormat));
      } else {
        this.logger.logError("".concat(requestedFormat, " is not supported by") + "ZXingHtml5QrcodeShim");
      }
    }
    return zxingFormats;
  };
  ZXingHtml5QrcodeDecoder2.prototype.createDebugData = function() {
    return { decoderName: "zxing-js" };
  };
  return ZXingHtml5QrcodeDecoder2;
}();
var __awaiter$4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$4 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var BarcodeDetectorDelegate = function() {
  function BarcodeDetectorDelegate2(requestedFormats, verbose, logger) {
    this.formatMap = /* @__PURE__ */ new Map([
      [Html5QrcodeSupportedFormats.QR_CODE, "qr_code"],
      [Html5QrcodeSupportedFormats.AZTEC, "aztec"],
      [Html5QrcodeSupportedFormats.CODABAR, "codabar"],
      [Html5QrcodeSupportedFormats.CODE_39, "code_39"],
      [Html5QrcodeSupportedFormats.CODE_93, "code_93"],
      [Html5QrcodeSupportedFormats.CODE_128, "code_128"],
      [Html5QrcodeSupportedFormats.DATA_MATRIX, "data_matrix"],
      [Html5QrcodeSupportedFormats.ITF, "itf"],
      [Html5QrcodeSupportedFormats.EAN_13, "ean_13"],
      [Html5QrcodeSupportedFormats.EAN_8, "ean_8"],
      [Html5QrcodeSupportedFormats.PDF_417, "pdf417"],
      [Html5QrcodeSupportedFormats.UPC_A, "upc_a"],
      [Html5QrcodeSupportedFormats.UPC_E, "upc_e"]
    ]);
    this.reverseFormatMap = this.createReverseFormatMap();
    if (!BarcodeDetectorDelegate2.isSupported()) {
      throw "Use html5qrcode.min.js without edit, Use BarcodeDetectorDelegate only if it isSupported();";
    }
    this.verbose = verbose;
    this.logger = logger;
    var formats = this.createBarcodeDetectorFormats(requestedFormats);
    this.detector = new BarcodeDetector(formats);
    if (!this.detector) {
      throw "BarcodeDetector detector not supported";
    }
  }
  BarcodeDetectorDelegate2.isSupported = function() {
    if (!("BarcodeDetector" in window)) {
      return false;
    }
    var dummyDetector = new BarcodeDetector({ formats: ["qr_code"] });
    return typeof dummyDetector !== "undefined";
  };
  BarcodeDetectorDelegate2.prototype.decodeAsync = function(canvas) {
    return __awaiter$4(this, void 0, void 0, function() {
      var barcodes, largestBarcode;
      return __generator$4(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.detector.detect(canvas)];
          case 1:
            barcodes = _a.sent();
            if (!barcodes || barcodes.length === 0) {
              throw "No barcode or QR code detected.";
            }
            largestBarcode = this.selectLargestBarcode(barcodes);
            return [2, {
              text: largestBarcode.rawValue,
              format: QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(largestBarcode.format)),
              debugData: this.createDebugData()
            }];
        }
      });
    });
  };
  BarcodeDetectorDelegate2.prototype.selectLargestBarcode = function(barcodes) {
    var largestBarcode = null;
    var maxArea = 0;
    for (var _i = 0, barcodes_1 = barcodes; _i < barcodes_1.length; _i++) {
      var barcode = barcodes_1[_i];
      var area = barcode.boundingBox.width * barcode.boundingBox.height;
      if (area > maxArea) {
        maxArea = area;
        largestBarcode = barcode;
      }
    }
    if (!largestBarcode) {
      throw "No largest barcode found";
    }
    return largestBarcode;
  };
  BarcodeDetectorDelegate2.prototype.createBarcodeDetectorFormats = function(requestedFormats) {
    var formats = [];
    for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {
      var requestedFormat = requestedFormats_1[_i];
      if (this.formatMap.has(requestedFormat)) {
        formats.push(this.formatMap.get(requestedFormat));
      } else {
        this.logger.warn("".concat(requestedFormat, " is not supported by") + "BarcodeDetectorDelegate");
      }
    }
    return { formats };
  };
  BarcodeDetectorDelegate2.prototype.toHtml5QrcodeSupportedFormats = function(barcodeDetectorFormat) {
    if (!this.reverseFormatMap.has(barcodeDetectorFormat)) {
      throw "reverseFormatMap doesn't have ".concat(barcodeDetectorFormat);
    }
    return this.reverseFormatMap.get(barcodeDetectorFormat);
  };
  BarcodeDetectorDelegate2.prototype.createReverseFormatMap = function() {
    var result = /* @__PURE__ */ new Map();
    this.formatMap.forEach(function(value, key2, _) {
      result.set(value, key2);
    });
    return result;
  };
  BarcodeDetectorDelegate2.prototype.createDebugData = function() {
    return { decoderName: "BarcodeDetector" };
  };
  return BarcodeDetectorDelegate2;
}();
var __awaiter$3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$3 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var Html5QrcodeShim = function() {
  function Html5QrcodeShim2(requestedFormats, useBarCodeDetectorIfSupported, verbose, logger) {
    this.EXECUTIONS_TO_REPORT_PERFORMANCE = 100;
    this.executions = 0;
    this.executionResults = [];
    this.wasPrimaryDecoderUsedInLastDecode = false;
    this.verbose = verbose;
    if (useBarCodeDetectorIfSupported && BarcodeDetectorDelegate.isSupported()) {
      this.primaryDecoder = new BarcodeDetectorDelegate(requestedFormats, verbose, logger);
      this.secondaryDecoder = new ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);
    } else {
      this.primaryDecoder = new ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);
    }
  }
  Html5QrcodeShim2.prototype.decodeAsync = function(canvas) {
    return __awaiter$3(this, void 0, void 0, function() {
      var startTime;
      return __generator$3(this, function(_a) {
        switch (_a.label) {
          case 0:
            startTime = performance.now();
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 3, 4]);
            return [4, this.getDecoder().decodeAsync(canvas)];
          case 2:
            return [2, _a.sent()];
          case 3:
            this.possiblyLogPerformance(startTime);
            return [7];
          case 4:
            return [2];
        }
      });
    });
  };
  Html5QrcodeShim2.prototype.decodeRobustlyAsync = function(canvas) {
    return __awaiter$3(this, void 0, void 0, function() {
      var startTime, error_1;
      return __generator$3(this, function(_a) {
        switch (_a.label) {
          case 0:
            startTime = performance.now();
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, 4, 5]);
            return [4, this.primaryDecoder.decodeAsync(canvas)];
          case 2:
            return [2, _a.sent()];
          case 3:
            error_1 = _a.sent();
            if (this.secondaryDecoder) {
              return [2, this.secondaryDecoder.decodeAsync(canvas)];
            }
            throw error_1;
          case 4:
            this.possiblyLogPerformance(startTime);
            return [7];
          case 5:
            return [2];
        }
      });
    });
  };
  Html5QrcodeShim2.prototype.getDecoder = function() {
    if (!this.secondaryDecoder) {
      return this.primaryDecoder;
    }
    if (this.wasPrimaryDecoderUsedInLastDecode === false) {
      this.wasPrimaryDecoderUsedInLastDecode = true;
      return this.primaryDecoder;
    }
    this.wasPrimaryDecoderUsedInLastDecode = false;
    return this.secondaryDecoder;
  };
  Html5QrcodeShim2.prototype.possiblyLogPerformance = function(startTime) {
    if (!this.verbose) {
      return;
    }
    var executionTime = performance.now() - startTime;
    this.executionResults.push(executionTime);
    this.executions++;
    this.possiblyFlushPerformanceReport();
  };
  Html5QrcodeShim2.prototype.possiblyFlushPerformanceReport = function() {
    if (this.executions < this.EXECUTIONS_TO_REPORT_PERFORMANCE) {
      return;
    }
    var sum = 0;
    for (var _i = 0, _a = this.executionResults; _i < _a.length; _i++) {
      var executionTime = _a[_i];
      sum += executionTime;
    }
    var mean = sum / this.executionResults.length;
    console.log("".concat(mean, " ms for ").concat(this.executionResults.length, " last runs."));
    this.executions = 0;
    this.executionResults = [];
  };
  return Html5QrcodeShim2;
}();
var __extends$1 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics2(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$2 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var AbstractCameraCapability = function() {
  function AbstractCameraCapability2(name2, track) {
    this.name = name2;
    this.track = track;
  }
  AbstractCameraCapability2.prototype.isSupported = function() {
    if (!this.track.getCapabilities) {
      return false;
    }
    return this.name in this.track.getCapabilities();
  };
  AbstractCameraCapability2.prototype.apply = function(value) {
    var constraint = {};
    constraint[this.name] = value;
    var constraints = { advanced: [constraint] };
    return this.track.applyConstraints(constraints);
  };
  AbstractCameraCapability2.prototype.value = function() {
    var settings = this.track.getSettings();
    if (this.name in settings) {
      var settingValue = settings[this.name];
      return settingValue;
    }
    return null;
  };
  return AbstractCameraCapability2;
}();
var AbstractRangeCameraCapability = function(_super) {
  __extends$1(AbstractRangeCameraCapability2, _super);
  function AbstractRangeCameraCapability2(name2, track) {
    return _super.call(this, name2, track) || this;
  }
  AbstractRangeCameraCapability2.prototype.min = function() {
    return this.getCapabilities().min;
  };
  AbstractRangeCameraCapability2.prototype.max = function() {
    return this.getCapabilities().max;
  };
  AbstractRangeCameraCapability2.prototype.step = function() {
    return this.getCapabilities().step;
  };
  AbstractRangeCameraCapability2.prototype.apply = function(value) {
    var constraint = {};
    constraint[this.name] = value;
    var constraints = { advanced: [constraint] };
    return this.track.applyConstraints(constraints);
  };
  AbstractRangeCameraCapability2.prototype.getCapabilities = function() {
    this.failIfNotSupported();
    var capabilities = this.track.getCapabilities();
    var capability = capabilities[this.name];
    return {
      min: capability.min,
      max: capability.max,
      step: capability.step
    };
  };
  AbstractRangeCameraCapability2.prototype.failIfNotSupported = function() {
    if (!this.isSupported()) {
      throw new Error("".concat(this.name, " capability not supported"));
    }
  };
  return AbstractRangeCameraCapability2;
}(AbstractCameraCapability);
var ZoomFeatureImpl = function(_super) {
  __extends$1(ZoomFeatureImpl2, _super);
  function ZoomFeatureImpl2(track) {
    return _super.call(this, "zoom", track) || this;
  }
  return ZoomFeatureImpl2;
}(AbstractRangeCameraCapability);
var TorchFeatureImpl = function(_super) {
  __extends$1(TorchFeatureImpl2, _super);
  function TorchFeatureImpl2(track) {
    return _super.call(this, "torch", track) || this;
  }
  return TorchFeatureImpl2;
}(AbstractCameraCapability);
var CameraCapabilitiesImpl = function() {
  function CameraCapabilitiesImpl2(track) {
    this.track = track;
  }
  CameraCapabilitiesImpl2.prototype.zoomFeature = function() {
    return new ZoomFeatureImpl(this.track);
  };
  CameraCapabilitiesImpl2.prototype.torchFeature = function() {
    return new TorchFeatureImpl(this.track);
  };
  return CameraCapabilitiesImpl2;
}();
var RenderedCameraImpl = function() {
  function RenderedCameraImpl2(parentElement, mediaStream, callbacks) {
    this.isClosed = false;
    this.parentElement = parentElement;
    this.mediaStream = mediaStream;
    this.callbacks = callbacks;
    this.surface = this.createVideoElement(this.parentElement.clientWidth);
    parentElement.append(this.surface);
  }
  RenderedCameraImpl2.prototype.createVideoElement = function(width) {
    var videoElement = document.createElement("video");
    videoElement.style.width = "".concat(width, "px");
    videoElement.style.display = "block";
    videoElement.muted = true;
    videoElement.setAttribute("muted", "true");
    videoElement.playsInline = true;
    return videoElement;
  };
  RenderedCameraImpl2.prototype.setupSurface = function() {
    var _this = this;
    this.surface.onabort = function() {
      throw "RenderedCameraImpl video surface onabort() called";
    };
    this.surface.onerror = function() {
      throw "RenderedCameraImpl video surface onerror() called";
    };
    var onVideoStart = function() {
      var videoWidth = _this.surface.clientWidth;
      var videoHeight = _this.surface.clientHeight;
      _this.callbacks.onRenderSurfaceReady(videoWidth, videoHeight);
      _this.surface.removeEventListener("playing", onVideoStart);
    };
    this.surface.addEventListener("playing", onVideoStart);
    this.surface.srcObject = this.mediaStream;
    this.surface.play();
  };
  RenderedCameraImpl2.create = function(parentElement, mediaStream, options, callbacks) {
    return __awaiter$2(this, void 0, void 0, function() {
      var renderedCamera, aspectRatioConstraint;
      return __generator$2(this, function(_a) {
        switch (_a.label) {
          case 0:
            renderedCamera = new RenderedCameraImpl2(parentElement, mediaStream, callbacks);
            if (!options.aspectRatio) return [3, 2];
            aspectRatioConstraint = {
              aspectRatio: options.aspectRatio
            };
            return [4, renderedCamera.getFirstTrackOrFail().applyConstraints(aspectRatioConstraint)];
          case 1:
            _a.sent();
            _a.label = 2;
          case 2:
            renderedCamera.setupSurface();
            return [2, renderedCamera];
        }
      });
    });
  };
  RenderedCameraImpl2.prototype.failIfClosed = function() {
    if (this.isClosed) {
      throw "The RenderedCamera has already been closed.";
    }
  };
  RenderedCameraImpl2.prototype.getFirstTrackOrFail = function() {
    this.failIfClosed();
    if (this.mediaStream.getVideoTracks().length === 0) {
      throw "No video tracks found";
    }
    return this.mediaStream.getVideoTracks()[0];
  };
  RenderedCameraImpl2.prototype.pause = function() {
    this.failIfClosed();
    this.surface.pause();
  };
  RenderedCameraImpl2.prototype.resume = function(onResumeCallback) {
    this.failIfClosed();
    var $this = this;
    var onVideoResume = function() {
      setTimeout(onResumeCallback, 200);
      $this.surface.removeEventListener("playing", onVideoResume);
    };
    this.surface.addEventListener("playing", onVideoResume);
    this.surface.play();
  };
  RenderedCameraImpl2.prototype.isPaused = function() {
    this.failIfClosed();
    return this.surface.paused;
  };
  RenderedCameraImpl2.prototype.getSurface = function() {
    this.failIfClosed();
    return this.surface;
  };
  RenderedCameraImpl2.prototype.getRunningTrackCapabilities = function() {
    return this.getFirstTrackOrFail().getCapabilities();
  };
  RenderedCameraImpl2.prototype.getRunningTrackSettings = function() {
    return this.getFirstTrackOrFail().getSettings();
  };
  RenderedCameraImpl2.prototype.applyVideoConstraints = function(constraints) {
    return __awaiter$2(this, void 0, void 0, function() {
      return __generator$2(this, function(_a) {
        if ("aspectRatio" in constraints) {
          throw "Changing 'aspectRatio' in run-time is not yet supported.";
        }
        return [2, this.getFirstTrackOrFail().applyConstraints(constraints)];
      });
    });
  };
  RenderedCameraImpl2.prototype.close = function() {
    if (this.isClosed) {
      return Promise.resolve();
    }
    var $this = this;
    return new Promise(function(resolve2, _) {
      var tracks = $this.mediaStream.getVideoTracks();
      var tracksToClose = tracks.length;
      var tracksClosed = 0;
      $this.mediaStream.getVideoTracks().forEach(function(videoTrack) {
        $this.mediaStream.removeTrack(videoTrack);
        videoTrack.stop();
        ++tracksClosed;
        if (tracksClosed >= tracksToClose) {
          $this.isClosed = true;
          $this.parentElement.removeChild($this.surface);
          resolve2();
        }
      });
    });
  };
  RenderedCameraImpl2.prototype.getCapabilities = function() {
    return new CameraCapabilitiesImpl(this.getFirstTrackOrFail());
  };
  return RenderedCameraImpl2;
}();
var CameraImpl = function() {
  function CameraImpl2(mediaStream) {
    this.mediaStream = mediaStream;
  }
  CameraImpl2.prototype.render = function(parentElement, options, callbacks) {
    return __awaiter$2(this, void 0, void 0, function() {
      return __generator$2(this, function(_a) {
        return [2, RenderedCameraImpl.create(parentElement, this.mediaStream, options, callbacks)];
      });
    });
  };
  CameraImpl2.create = function(videoConstraints) {
    return __awaiter$2(this, void 0, void 0, function() {
      var constraints, mediaStream;
      return __generator$2(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!navigator.mediaDevices) {
              throw "navigator.mediaDevices not supported";
            }
            constraints = {
              audio: false,
              video: videoConstraints
            };
            return [4, navigator.mediaDevices.getUserMedia(constraints)];
          case 1:
            mediaStream = _a.sent();
            return [2, new CameraImpl2(mediaStream)];
        }
      });
    });
  };
  return CameraImpl2;
}();
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var CameraFactory = function() {
  function CameraFactory2() {
  }
  CameraFactory2.failIfNotSupported = function() {
    return __awaiter$1(this, void 0, void 0, function() {
      return __generator$1(this, function(_a) {
        if (!navigator.mediaDevices) {
          throw "navigator.mediaDevices not supported";
        }
        return [2, new CameraFactory2()];
      });
    });
  };
  CameraFactory2.prototype.create = function(videoConstraints) {
    return __awaiter$1(this, void 0, void 0, function() {
      return __generator$1(this, function(_a) {
        return [2, CameraImpl.create(videoConstraints)];
      });
    });
  };
  return CameraFactory2;
}();
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var CameraRetriever = function() {
  function CameraRetriever2() {
  }
  CameraRetriever2.retrieve = function() {
    if (navigator.mediaDevices) {
      return CameraRetriever2.getCamerasFromMediaDevices();
    }
    var mst = MediaStreamTrack;
    if (MediaStreamTrack && mst.getSources) {
      return CameraRetriever2.getCamerasFromMediaStreamTrack();
    }
    return CameraRetriever2.rejectWithError();
  };
  CameraRetriever2.rejectWithError = function() {
    var errorMessage = Html5QrcodeStrings.unableToQuerySupportedDevices();
    if (!CameraRetriever2.isHttpsOrLocalhost()) {
      errorMessage = Html5QrcodeStrings.insecureContextCameraQueryError();
    }
    return Promise.reject(errorMessage);
  };
  CameraRetriever2.isHttpsOrLocalhost = function() {
    if (location.protocol === "https:") {
      return true;
    }
    var host = location.host.split(":")[0];
    return host === "127.0.0.1" || host === "localhost";
  };
  CameraRetriever2.getCamerasFromMediaDevices = function() {
    return __awaiter(this, void 0, void 0, function() {
      var closeActiveStreams, mediaStream, devices, results, _i, devices_1, device;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            closeActiveStreams = function(stream) {
              var tracks = stream.getVideoTracks();
              for (var _i2 = 0, tracks_1 = tracks; _i2 < tracks_1.length; _i2++) {
                var track = tracks_1[_i2];
                track.enabled = false;
                track.stop();
                stream.removeTrack(track);
              }
            };
            return [4, navigator.mediaDevices.getUserMedia({ audio: false, video: true })];
          case 1:
            mediaStream = _a.sent();
            return [4, navigator.mediaDevices.enumerateDevices()];
          case 2:
            devices = _a.sent();
            results = [];
            for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
              device = devices_1[_i];
              if (device.kind === "videoinput") {
                results.push({
                  id: device.deviceId,
                  label: device.label
                });
              }
            }
            closeActiveStreams(mediaStream);
            return [2, results];
        }
      });
    });
  };
  CameraRetriever2.getCamerasFromMediaStreamTrack = function() {
    return new Promise(function(resolve2, _) {
      var callback = function(sourceInfos) {
        var results = [];
        for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {
          var sourceInfo = sourceInfos_1[_i];
          if (sourceInfo.kind === "video") {
            results.push({
              id: sourceInfo.id,
              label: sourceInfo.label
            });
          }
        }
        resolve2(results);
      };
      var mst = MediaStreamTrack;
      mst.getSources(callback);
    });
  };
  return CameraRetriever2;
}();
var Html5QrcodeScannerState;
(function(Html5QrcodeScannerState2) {
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["UNKNOWN"] = 0] = "UNKNOWN";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["NOT_STARTED"] = 1] = "NOT_STARTED";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["SCANNING"] = 2] = "SCANNING";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["PAUSED"] = 3] = "PAUSED";
})(Html5QrcodeScannerState || (Html5QrcodeScannerState = {}));
var StateManagerImpl = function() {
  function StateManagerImpl2() {
    this.state = Html5QrcodeScannerState.NOT_STARTED;
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
  }
  StateManagerImpl2.prototype.directTransition = function(newState) {
    this.failIfTransitionOngoing();
    this.validateTransition(newState);
    this.state = newState;
  };
  StateManagerImpl2.prototype.startTransition = function(newState) {
    this.failIfTransitionOngoing();
    this.validateTransition(newState);
    this.onGoingTransactionNewState = newState;
    return this;
  };
  StateManagerImpl2.prototype.execute = function() {
    if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {
      throw "Transaction is already cancelled, cannot execute().";
    }
    var tempNewState = this.onGoingTransactionNewState;
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
    this.directTransition(tempNewState);
  };
  StateManagerImpl2.prototype.cancel = function() {
    if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {
      throw "Transaction is already cancelled, cannot cancel().";
    }
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
  };
  StateManagerImpl2.prototype.getState = function() {
    return this.state;
  };
  StateManagerImpl2.prototype.failIfTransitionOngoing = function() {
    if (this.onGoingTransactionNewState !== Html5QrcodeScannerState.UNKNOWN) {
      throw "Cannot transition to a new state, already under transition";
    }
  };
  StateManagerImpl2.prototype.validateTransition = function(newState) {
    switch (this.state) {
      case Html5QrcodeScannerState.UNKNOWN:
        throw "Transition from unknown is not allowed";
      case Html5QrcodeScannerState.NOT_STARTED:
        this.failIfNewStateIs(newState, [Html5QrcodeScannerState.PAUSED]);
        break;
      case Html5QrcodeScannerState.SCANNING:
        break;
      case Html5QrcodeScannerState.PAUSED:
        break;
    }
  };
  StateManagerImpl2.prototype.failIfNewStateIs = function(newState, disallowedStatesToTransition) {
    for (var _i = 0, disallowedStatesToTransition_1 = disallowedStatesToTransition; _i < disallowedStatesToTransition_1.length; _i++) {
      var disallowedState = disallowedStatesToTransition_1[_i];
      if (newState === disallowedState) {
        throw "Cannot transition from ".concat(this.state, " to ").concat(newState);
      }
    }
  };
  return StateManagerImpl2;
}();
var StateManagerProxy = function() {
  function StateManagerProxy2(stateManager) {
    this.stateManager = stateManager;
  }
  StateManagerProxy2.prototype.startTransition = function(newState) {
    return this.stateManager.startTransition(newState);
  };
  StateManagerProxy2.prototype.directTransition = function(newState) {
    this.stateManager.directTransition(newState);
  };
  StateManagerProxy2.prototype.getState = function() {
    return this.stateManager.getState();
  };
  StateManagerProxy2.prototype.canScanFile = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.NOT_STARTED;
  };
  StateManagerProxy2.prototype.isScanning = function() {
    return this.stateManager.getState() !== Html5QrcodeScannerState.NOT_STARTED;
  };
  StateManagerProxy2.prototype.isStrictlyScanning = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.SCANNING;
  };
  StateManagerProxy2.prototype.isPaused = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.PAUSED;
  };
  return StateManagerProxy2;
}();
var StateManagerFactory = function() {
  function StateManagerFactory2() {
  }
  StateManagerFactory2.create = function() {
    return new StateManagerProxy(new StateManagerImpl());
  };
  return StateManagerFactory2;
}();
var __extends = /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics2(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Constants = function(_super) {
  __extends(Constants2, _super);
  function Constants2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Constants2.DEFAULT_WIDTH = 300;
  Constants2.DEFAULT_WIDTH_OFFSET = 2;
  Constants2.FILE_SCAN_MIN_HEIGHT = 300;
  Constants2.FILE_SCAN_HIDDEN_CANVAS_PADDING = 100;
  Constants2.MIN_QR_BOX_SIZE = 50;
  Constants2.SHADED_LEFT = 1;
  Constants2.SHADED_RIGHT = 2;
  Constants2.SHADED_TOP = 3;
  Constants2.SHADED_BOTTOM = 4;
  Constants2.SHADED_REGION_ELEMENT_ID = "qr-shaded-region";
  Constants2.VERBOSE = false;
  Constants2.BORDER_SHADER_DEFAULT_COLOR = "#ffffff";
  Constants2.BORDER_SHADER_MATCH_COLOR = "rgb(90, 193, 56)";
  return Constants2;
}(Html5QrcodeConstants);
var InternalHtml5QrcodeConfig = function() {
  function InternalHtml5QrcodeConfig2(config2, logger) {
    this.logger = logger;
    this.fps = Constants.SCAN_DEFAULT_FPS;
    if (!config2) {
      this.disableFlip = Constants.DEFAULT_DISABLE_FLIP;
    } else {
      if (config2.fps) {
        this.fps = config2.fps;
      }
      this.disableFlip = config2.disableFlip === true;
      this.qrbox = config2.qrbox;
      this.aspectRatio = config2.aspectRatio;
      this.videoConstraints = config2.videoConstraints;
    }
  }
  InternalHtml5QrcodeConfig2.prototype.isMediaStreamConstraintsValid = function() {
    if (!this.videoConstraints) {
      this.logger.logError("Empty videoConstraints", true);
      return false;
    }
    return VideoConstraintsUtil.isMediaStreamConstraintsValid(this.videoConstraints, this.logger);
  };
  InternalHtml5QrcodeConfig2.prototype.isShadedBoxEnabled = function() {
    return !isNullOrUndefined(this.qrbox);
  };
  InternalHtml5QrcodeConfig2.create = function(config2, logger) {
    return new InternalHtml5QrcodeConfig2(config2, logger);
  };
  return InternalHtml5QrcodeConfig2;
}();
var Html5Qrcode = function() {
  function Html5Qrcode2(elementId, configOrVerbosityFlag) {
    this.element = null;
    this.canvasElement = null;
    this.scannerPausedUiElement = null;
    this.hasBorderShaders = null;
    this.borderShaders = null;
    this.qrMatch = null;
    this.renderedCamera = null;
    this.qrRegion = null;
    this.context = null;
    this.lastScanImageFile = null;
    this.isScanning = false;
    if (!document.getElementById(elementId)) {
      throw "HTML Element with id=".concat(elementId, " not found");
    }
    this.elementId = elementId;
    this.verbose = false;
    var configObject;
    if (typeof configOrVerbosityFlag == "boolean") {
      this.verbose = configOrVerbosityFlag === true;
    } else if (configOrVerbosityFlag) {
      configObject = configOrVerbosityFlag;
      this.verbose = configObject.verbose === true;
      configObject.experimentalFeatures;
    }
    this.logger = new BaseLoggger(this.verbose);
    this.qrcode = new Html5QrcodeShim(this.getSupportedFormats(configOrVerbosityFlag), this.getUseBarCodeDetectorIfSupported(configObject), this.verbose, this.logger);
    this.foreverScanTimeout;
    this.shouldScan = true;
    this.stateManagerProxy = StateManagerFactory.create();
  }
  Html5Qrcode2.prototype.start = function(cameraIdOrConfig, configuration, qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (!cameraIdOrConfig) {
      throw "cameraIdOrConfig is required";
    }
    if (!qrCodeSuccessCallback || typeof qrCodeSuccessCallback != "function") {
      throw "qrCodeSuccessCallback is required and should be a function.";
    }
    var qrCodeErrorCallbackInternal;
    if (qrCodeErrorCallback) {
      qrCodeErrorCallbackInternal = qrCodeErrorCallback;
    } else {
      qrCodeErrorCallbackInternal = this.verbose ? this.logger.log : function() {
      };
    }
    var internalConfig = InternalHtml5QrcodeConfig.create(configuration, this.logger);
    this.clearElement();
    var videoConstraintsAvailableAndValid = false;
    if (internalConfig.videoConstraints) {
      if (!internalConfig.isMediaStreamConstraintsValid()) {
        this.logger.logError("'videoConstraints' is not valid 'MediaStreamConstraints, it will be ignored.'", true);
      } else {
        videoConstraintsAvailableAndValid = true;
      }
    }
    var areVideoConstraintsEnabled = videoConstraintsAvailableAndValid;
    var element = document.getElementById(this.elementId);
    element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;
    element.style.position = "relative";
    this.shouldScan = true;
    this.element = element;
    var $this = this;
    var toScanningStateChangeTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.SCANNING);
    return new Promise(function(resolve2, reject) {
      var videoConstraints = areVideoConstraintsEnabled ? internalConfig.videoConstraints : $this.createVideoConstraints(cameraIdOrConfig);
      if (!videoConstraints) {
        toScanningStateChangeTransaction.cancel();
        reject("videoConstraints should be defined");
        return;
      }
      var cameraRenderingOptions = {};
      if (!areVideoConstraintsEnabled || internalConfig.aspectRatio) {
        cameraRenderingOptions.aspectRatio = internalConfig.aspectRatio;
      }
      var renderingCallbacks = {
        onRenderSurfaceReady: function(viewfinderWidth, viewfinderHeight) {
          $this.setupUi(viewfinderWidth, viewfinderHeight, internalConfig);
          $this.isScanning = true;
          $this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallbackInternal);
        }
      };
      CameraFactory.failIfNotSupported().then(function(factory) {
        factory.create(videoConstraints).then(function(camera) {
          return camera.render(_this.element, cameraRenderingOptions, renderingCallbacks).then(function(renderedCamera) {
            $this.renderedCamera = renderedCamera;
            toScanningStateChangeTransaction.execute();
            resolve2(null);
          }).catch(function(error) {
            toScanningStateChangeTransaction.cancel();
            reject(error);
          });
        }).catch(function(error) {
          toScanningStateChangeTransaction.cancel();
          reject(Html5QrcodeStrings.errorGettingUserMedia(error));
        });
      }).catch(function(_) {
        toScanningStateChangeTransaction.cancel();
        reject(Html5QrcodeStrings.cameraStreamingNotSupported());
      });
    });
  };
  Html5Qrcode2.prototype.pause = function(shouldPauseVideo) {
    if (!this.stateManagerProxy.isStrictlyScanning()) {
      throw "Cannot pause, scanner is not scanning.";
    }
    this.stateManagerProxy.directTransition(Html5QrcodeScannerState.PAUSED);
    this.showPausedState();
    if (isNullOrUndefined(shouldPauseVideo) || shouldPauseVideo !== true) {
      shouldPauseVideo = false;
    }
    if (shouldPauseVideo && this.renderedCamera) {
      this.renderedCamera.pause();
    }
  };
  Html5Qrcode2.prototype.resume = function() {
    if (!this.stateManagerProxy.isPaused()) {
      throw "Cannot result, scanner is not paused.";
    }
    if (!this.renderedCamera) {
      throw "renderedCamera doesn't exist while trying resume()";
    }
    var $this = this;
    var transitionToScanning = function() {
      $this.stateManagerProxy.directTransition(Html5QrcodeScannerState.SCANNING);
      $this.hidePausedState();
    };
    if (!this.renderedCamera.isPaused()) {
      transitionToScanning();
      return;
    }
    this.renderedCamera.resume(function() {
      transitionToScanning();
    });
  };
  Html5Qrcode2.prototype.getState = function() {
    return this.stateManagerProxy.getState();
  };
  Html5Qrcode2.prototype.stop = function() {
    var _this = this;
    if (!this.stateManagerProxy.isScanning()) {
      throw "Cannot stop, scanner is not running or paused.";
    }
    var toStoppedStateTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.NOT_STARTED);
    this.shouldScan = false;
    if (this.foreverScanTimeout) {
      clearTimeout(this.foreverScanTimeout);
    }
    var removeQrRegion = function() {
      if (!_this.element) {
        return;
      }
      var childElement = document.getElementById(Constants.SHADED_REGION_ELEMENT_ID);
      if (childElement) {
        _this.element.removeChild(childElement);
      }
    };
    var $this = this;
    return this.renderedCamera.close().then(function() {
      $this.renderedCamera = null;
      if ($this.element) {
        $this.element.removeChild($this.canvasElement);
        $this.canvasElement = null;
      }
      removeQrRegion();
      if ($this.qrRegion) {
        $this.qrRegion = null;
      }
      if ($this.context) {
        $this.context = null;
      }
      toStoppedStateTransaction.execute();
      $this.hidePausedState();
      $this.isScanning = false;
      return Promise.resolve();
    });
  };
  Html5Qrcode2.prototype.scanFile = function(imageFile, showImage) {
    return this.scanFileV2(imageFile, showImage).then(function(html5qrcodeResult) {
      return html5qrcodeResult.decodedText;
    });
  };
  Html5Qrcode2.prototype.scanFileV2 = function(imageFile, showImage) {
    var _this = this;
    if (!imageFile || !(imageFile instanceof File)) {
      throw "imageFile argument is mandatory and should be instance of File. Use 'event.target.files[0]'.";
    }
    if (isNullOrUndefined(showImage)) {
      showImage = true;
    }
    if (!this.stateManagerProxy.canScanFile()) {
      throw "Cannot start file scan - ongoing camera scan";
    }
    return new Promise(function(resolve2, reject) {
      _this.possiblyCloseLastScanImageFile();
      _this.clearElement();
      _this.lastScanImageFile = URL.createObjectURL(imageFile);
      var inputImage = new Image();
      inputImage.onload = function() {
        var imageWidth = inputImage.width;
        var imageHeight = inputImage.height;
        var element = document.getElementById(_this.elementId);
        var containerWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;
        var containerHeight = Math.max(element.clientHeight ? element.clientHeight : imageHeight, Constants.FILE_SCAN_MIN_HEIGHT);
        var config2 = _this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
        if (showImage) {
          var visibleCanvas = _this.createCanvasElement(containerWidth, containerHeight, "qr-canvas-visible");
          visibleCanvas.style.display = "inline-block";
          element.appendChild(visibleCanvas);
          var context_1 = visibleCanvas.getContext("2d");
          if (!context_1) {
            throw "Unable to get 2d context from canvas";
          }
          context_1.canvas.width = containerWidth;
          context_1.canvas.height = containerHeight;
          context_1.drawImage(inputImage, 0, 0, imageWidth, imageHeight, config2.x, config2.y, config2.width, config2.height);
        }
        var padding = Constants.FILE_SCAN_HIDDEN_CANVAS_PADDING;
        var hiddenImageWidth = Math.max(inputImage.width, config2.width);
        var hiddenImageHeight = Math.max(inputImage.height, config2.height);
        var hiddenCanvasWidth = hiddenImageWidth + 2 * padding;
        var hiddenCanvasHeight = hiddenImageHeight + 2 * padding;
        var hiddenCanvas = _this.createCanvasElement(hiddenCanvasWidth, hiddenCanvasHeight);
        element.appendChild(hiddenCanvas);
        var context = hiddenCanvas.getContext("2d");
        if (!context) {
          throw "Unable to get 2d context from canvas";
        }
        context.canvas.width = hiddenCanvasWidth;
        context.canvas.height = hiddenCanvasHeight;
        context.drawImage(inputImage, 0, 0, imageWidth, imageHeight, padding, padding, hiddenImageWidth, hiddenImageHeight);
        try {
          _this.qrcode.decodeRobustlyAsync(hiddenCanvas).then(function(result) {
            resolve2(Html5QrcodeResultFactory.createFromQrcodeResult(result));
          }).catch(reject);
        } catch (exception) {
          reject("QR code parse error, error = ".concat(exception));
        }
      };
      inputImage.onerror = reject;
      inputImage.onabort = reject;
      inputImage.onstalled = reject;
      inputImage.onsuspend = reject;
      inputImage.src = URL.createObjectURL(imageFile);
    });
  };
  Html5Qrcode2.prototype.clear = function() {
    this.clearElement();
  };
  Html5Qrcode2.getCameras = function() {
    return CameraRetriever.retrieve();
  };
  Html5Qrcode2.prototype.getRunningTrackCapabilities = function() {
    return this.getRenderedCameraOrFail().getRunningTrackCapabilities();
  };
  Html5Qrcode2.prototype.getRunningTrackSettings = function() {
    return this.getRenderedCameraOrFail().getRunningTrackSettings();
  };
  Html5Qrcode2.prototype.getRunningTrackCameraCapabilities = function() {
    return this.getRenderedCameraOrFail().getCapabilities();
  };
  Html5Qrcode2.prototype.applyVideoConstraints = function(videoConstaints) {
    if (!videoConstaints) {
      throw "videoConstaints is required argument.";
    } else if (!VideoConstraintsUtil.isMediaStreamConstraintsValid(videoConstaints, this.logger)) {
      throw "invalid videoConstaints passed, check logs for more details";
    }
    return this.getRenderedCameraOrFail().applyVideoConstraints(videoConstaints);
  };
  Html5Qrcode2.prototype.getRenderedCameraOrFail = function() {
    if (this.renderedCamera == null) {
      throw "Scanning is not in running state, call this API only when QR code scanning using camera is in running state.";
    }
    return this.renderedCamera;
  };
  Html5Qrcode2.prototype.getSupportedFormats = function(configOrVerbosityFlag) {
    var allFormats = [
      Html5QrcodeSupportedFormats.QR_CODE,
      Html5QrcodeSupportedFormats.AZTEC,
      Html5QrcodeSupportedFormats.CODABAR,
      Html5QrcodeSupportedFormats.CODE_39,
      Html5QrcodeSupportedFormats.CODE_93,
      Html5QrcodeSupportedFormats.CODE_128,
      Html5QrcodeSupportedFormats.DATA_MATRIX,
      Html5QrcodeSupportedFormats.MAXICODE,
      Html5QrcodeSupportedFormats.ITF,
      Html5QrcodeSupportedFormats.EAN_13,
      Html5QrcodeSupportedFormats.EAN_8,
      Html5QrcodeSupportedFormats.PDF_417,
      Html5QrcodeSupportedFormats.RSS_14,
      Html5QrcodeSupportedFormats.RSS_EXPANDED,
      Html5QrcodeSupportedFormats.UPC_A,
      Html5QrcodeSupportedFormats.UPC_E,
      Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION
    ];
    if (!configOrVerbosityFlag || typeof configOrVerbosityFlag == "boolean") {
      return allFormats;
    }
    if (!configOrVerbosityFlag.formatsToSupport) {
      return allFormats;
    }
    if (!Array.isArray(configOrVerbosityFlag.formatsToSupport)) {
      throw "configOrVerbosityFlag.formatsToSupport should be undefined or an array.";
    }
    if (configOrVerbosityFlag.formatsToSupport.length === 0) {
      throw "Atleast 1 formatsToSupport is needed.";
    }
    var supportedFormats = [];
    for (var _i = 0, _a = configOrVerbosityFlag.formatsToSupport; _i < _a.length; _i++) {
      var format = _a[_i];
      if (isValidHtml5QrcodeSupportedFormats(format)) {
        supportedFormats.push(format);
      } else {
        this.logger.warn("Invalid format: ".concat(format, " passed in config, ignoring."));
      }
    }
    if (supportedFormats.length === 0) {
      throw "None of formatsToSupport match supported values.";
    }
    return supportedFormats;
  };
  Html5Qrcode2.prototype.getUseBarCodeDetectorIfSupported = function(config2) {
    if (isNullOrUndefined(config2)) {
      return true;
    }
    if (!isNullOrUndefined(config2.useBarCodeDetectorIfSupported)) {
      return config2.useBarCodeDetectorIfSupported !== false;
    }
    if (isNullOrUndefined(config2.experimentalFeatures)) {
      return true;
    }
    var experimentalFeatures = config2.experimentalFeatures;
    if (isNullOrUndefined(experimentalFeatures.useBarCodeDetectorIfSupported)) {
      return true;
    }
    return experimentalFeatures.useBarCodeDetectorIfSupported !== false;
  };
  Html5Qrcode2.prototype.validateQrboxSize = function(viewfinderWidth, viewfinderHeight, internalConfig) {
    var _this = this;
    var qrboxSize = internalConfig.qrbox;
    this.validateQrboxConfig(qrboxSize);
    var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);
    var validateMinSize = function(size) {
      if (size < Constants.MIN_QR_BOX_SIZE) {
        throw "minimum size of 'config.qrbox' dimension value is" + " ".concat(Constants.MIN_QR_BOX_SIZE, "px.");
      }
    };
    var correctWidthBasedOnRootElementSize = function(configWidth) {
      if (configWidth > viewfinderWidth) {
        _this.logger.warn("`qrbox.width` or `qrbox` is larger than the width of the root element. The width will be truncated to the width of root element.");
        configWidth = viewfinderWidth;
      }
      return configWidth;
    };
    validateMinSize(qrDimensions.width);
    validateMinSize(qrDimensions.height);
    qrDimensions.width = correctWidthBasedOnRootElementSize(qrDimensions.width);
  };
  Html5Qrcode2.prototype.validateQrboxConfig = function(qrboxSize) {
    if (typeof qrboxSize === "number") {
      return;
    }
    if (typeof qrboxSize === "function") {
      return;
    }
    if (qrboxSize.width === void 0 || qrboxSize.height === void 0) {
      throw "Invalid instance of QrDimensions passed for 'config.qrbox'. Both 'width' and 'height' should be set.";
    }
  };
  Html5Qrcode2.prototype.toQrdimensions = function(viewfinderWidth, viewfinderHeight, qrboxSize) {
    if (typeof qrboxSize === "number") {
      return { width: qrboxSize, height: qrboxSize };
    } else if (typeof qrboxSize === "function") {
      try {
        return qrboxSize(viewfinderWidth, viewfinderHeight);
      } catch (error) {
        throw new Error("qrbox config was passed as a function but it failed with unknown error" + error);
      }
    }
    return qrboxSize;
  };
  Html5Qrcode2.prototype.setupUi = function(viewfinderWidth, viewfinderHeight, internalConfig) {
    if (internalConfig.isShadedBoxEnabled()) {
      this.validateQrboxSize(viewfinderWidth, viewfinderHeight, internalConfig);
    }
    var qrboxSize = isNullOrUndefined(internalConfig.qrbox) ? { width: viewfinderWidth, height: viewfinderHeight } : internalConfig.qrbox;
    this.validateQrboxConfig(qrboxSize);
    var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);
    if (qrDimensions.height > viewfinderHeight) {
      this.logger.warn("[Html5Qrcode] config.qrbox has height that isgreater than the height of the video stream. Shading will be ignored");
    }
    var shouldShadingBeApplied = internalConfig.isShadedBoxEnabled() && qrDimensions.height <= viewfinderHeight;
    var defaultQrRegion = {
      x: 0,
      y: 0,
      width: viewfinderWidth,
      height: viewfinderHeight
    };
    var qrRegion = shouldShadingBeApplied ? this.getShadedRegionBounds(viewfinderWidth, viewfinderHeight, qrDimensions) : defaultQrRegion;
    var canvasElement = this.createCanvasElement(qrRegion.width, qrRegion.height);
    var contextAttributes = { willReadFrequently: true };
    var context = canvasElement.getContext("2d", contextAttributes);
    context.canvas.width = qrRegion.width;
    context.canvas.height = qrRegion.height;
    this.element.append(canvasElement);
    if (shouldShadingBeApplied) {
      this.possiblyInsertShadingElement(this.element, viewfinderWidth, viewfinderHeight, qrDimensions);
    }
    this.createScannerPausedUiElement(this.element);
    this.qrRegion = qrRegion;
    this.context = context;
    this.canvasElement = canvasElement;
  };
  Html5Qrcode2.prototype.createScannerPausedUiElement = function(rootElement) {
    var scannerPausedUiElement = document.createElement("div");
    scannerPausedUiElement.innerText = Html5QrcodeStrings.scannerPaused();
    scannerPausedUiElement.style.display = "none";
    scannerPausedUiElement.style.position = "absolute";
    scannerPausedUiElement.style.top = "0px";
    scannerPausedUiElement.style.zIndex = "1";
    scannerPausedUiElement.style.background = "rgba(9, 9, 9, 0.46)";
    scannerPausedUiElement.style.color = "#FFECEC";
    scannerPausedUiElement.style.textAlign = "center";
    scannerPausedUiElement.style.width = "100%";
    rootElement.appendChild(scannerPausedUiElement);
    this.scannerPausedUiElement = scannerPausedUiElement;
  };
  Html5Qrcode2.prototype.scanContext = function(qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (this.stateManagerProxy.isPaused()) {
      return Promise.resolve(false);
    }
    return this.qrcode.decodeAsync(this.canvasElement).then(function(result) {
      qrCodeSuccessCallback(result.text, Html5QrcodeResultFactory.createFromQrcodeResult(result));
      _this.possiblyUpdateShaders(true);
      return true;
    }).catch(function(error) {
      _this.possiblyUpdateShaders(false);
      var errorMessage = Html5QrcodeStrings.codeParseError(error);
      qrCodeErrorCallback(errorMessage, Html5QrcodeErrorFactory.createFrom(errorMessage));
      return false;
    });
  };
  Html5Qrcode2.prototype.foreverScan = function(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (!this.shouldScan) {
      return;
    }
    if (!this.renderedCamera) {
      return;
    }
    var videoElement = this.renderedCamera.getSurface();
    var widthRatio = videoElement.videoWidth / videoElement.clientWidth;
    var heightRatio = videoElement.videoHeight / videoElement.clientHeight;
    if (!this.qrRegion) {
      throw "qrRegion undefined when localMediaStream is ready.";
    }
    var sWidthOffset = this.qrRegion.width * widthRatio;
    var sHeightOffset = this.qrRegion.height * heightRatio;
    var sxOffset = this.qrRegion.x * widthRatio;
    var syOffset = this.qrRegion.y * heightRatio;
    this.context.drawImage(videoElement, sxOffset, syOffset, sWidthOffset, sHeightOffset, 0, 0, this.qrRegion.width, this.qrRegion.height);
    var triggerNextScan = function() {
      _this.foreverScanTimeout = setTimeout(function() {
        _this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);
      }, _this.getTimeoutFps(internalConfig.fps));
    };
    this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).then(function(isSuccessfull) {
      if (!isSuccessfull && internalConfig.disableFlip !== true) {
        _this.context.translate(_this.context.canvas.width, 0);
        _this.context.scale(-1, 1);
        _this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).finally(function() {
          triggerNextScan();
        });
      } else {
        triggerNextScan();
      }
    }).catch(function(error) {
      _this.logger.logError("Error happend while scanning context", error);
      triggerNextScan();
    });
  };
  Html5Qrcode2.prototype.createVideoConstraints = function(cameraIdOrConfig) {
    if (typeof cameraIdOrConfig == "string") {
      return { deviceId: { exact: cameraIdOrConfig } };
    } else if (typeof cameraIdOrConfig == "object") {
      var facingModeKey = "facingMode";
      var deviceIdKey = "deviceId";
      var allowedFacingModeValues_1 = { "user": true, "environment": true };
      var exactKey = "exact";
      var isValidFacingModeValue = function(value) {
        if (value in allowedFacingModeValues_1) {
          return true;
        } else {
          throw "config has invalid 'facingMode' value = " + "'".concat(value, "'");
        }
      };
      var keys2 = Object.keys(cameraIdOrConfig);
      if (keys2.length !== 1) {
        throw "'cameraIdOrConfig' object should have exactly 1 key," + " if passed as an object, found ".concat(keys2.length, " keys");
      }
      var key2 = Object.keys(cameraIdOrConfig)[0];
      if (key2 !== facingModeKey && key2 !== deviceIdKey) {
        throw "Only '".concat(facingModeKey, "' and '").concat(deviceIdKey, "' ") + " are supported for 'cameraIdOrConfig'";
      }
      if (key2 === facingModeKey) {
        var facingMode = cameraIdOrConfig.facingMode;
        if (typeof facingMode == "string") {
          if (isValidFacingModeValue(facingMode)) {
            return { facingMode };
          }
        } else if (typeof facingMode == "object") {
          if (exactKey in facingMode) {
            if (isValidFacingModeValue(facingMode["".concat(exactKey)])) {
              return {
                facingMode: {
                  exact: facingMode["".concat(exactKey)]
                }
              };
            }
          } else {
            throw "'facingMode' should be string or object with" + " ".concat(exactKey, " as key.");
          }
        } else {
          var type_1 = typeof facingMode;
          throw "Invalid type of 'facingMode' = ".concat(type_1);
        }
      } else {
        var deviceId = cameraIdOrConfig.deviceId;
        if (typeof deviceId == "string") {
          return { deviceId };
        } else if (typeof deviceId == "object") {
          if (exactKey in deviceId) {
            return {
              deviceId: { exact: deviceId["".concat(exactKey)] }
            };
          } else {
            throw "'deviceId' should be string or object with" + " ".concat(exactKey, " as key.");
          }
        } else {
          var type_2 = typeof deviceId;
          throw "Invalid type of 'deviceId' = ".concat(type_2);
        }
      }
    }
    var type = typeof cameraIdOrConfig;
    throw "Invalid type of 'cameraIdOrConfig' = ".concat(type);
  };
  Html5Qrcode2.prototype.computeCanvasDrawConfig = function(imageWidth, imageHeight, containerWidth, containerHeight) {
    if (imageWidth <= containerWidth && imageHeight <= containerHeight) {
      var xoffset = (containerWidth - imageWidth) / 2;
      var yoffset = (containerHeight - imageHeight) / 2;
      return {
        x: xoffset,
        y: yoffset,
        width: imageWidth,
        height: imageHeight
      };
    } else {
      var formerImageWidth = imageWidth;
      var formerImageHeight = imageHeight;
      if (imageWidth > containerWidth) {
        imageHeight = containerWidth / imageWidth * imageHeight;
        imageWidth = containerWidth;
      }
      if (imageHeight > containerHeight) {
        imageWidth = containerHeight / imageHeight * imageWidth;
        imageHeight = containerHeight;
      }
      this.logger.log("Image downsampled from " + "".concat(formerImageWidth, "X").concat(formerImageHeight) + " to ".concat(imageWidth, "X").concat(imageHeight, "."));
      return this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
    }
  };
  Html5Qrcode2.prototype.clearElement = function() {
    if (this.stateManagerProxy.isScanning()) {
      throw "Cannot clear while scan is ongoing, close it first.";
    }
    var element = document.getElementById(this.elementId);
    if (element) {
      element.innerHTML = "";
    }
  };
  Html5Qrcode2.prototype.possiblyUpdateShaders = function(qrMatch) {
    if (this.qrMatch === qrMatch) {
      return;
    }
    if (this.hasBorderShaders && this.borderShaders && this.borderShaders.length) {
      this.borderShaders.forEach(function(shader) {
        shader.style.backgroundColor = qrMatch ? Constants.BORDER_SHADER_MATCH_COLOR : Constants.BORDER_SHADER_DEFAULT_COLOR;
      });
    }
    this.qrMatch = qrMatch;
  };
  Html5Qrcode2.prototype.possiblyCloseLastScanImageFile = function() {
    if (this.lastScanImageFile) {
      URL.revokeObjectURL(this.lastScanImageFile);
      this.lastScanImageFile = null;
    }
  };
  Html5Qrcode2.prototype.createCanvasElement = function(width, height, customId) {
    var canvasWidth = width;
    var canvasHeight = height;
    var canvasElement = document.createElement("canvas");
    canvasElement.style.width = "".concat(canvasWidth, "px");
    canvasElement.style.height = "".concat(canvasHeight, "px");
    canvasElement.style.display = "none";
    canvasElement.id = isNullOrUndefined(customId) ? "qr-canvas" : customId;
    return canvasElement;
  };
  Html5Qrcode2.prototype.getShadedRegionBounds = function(width, height, qrboxSize) {
    if (qrboxSize.width > width || qrboxSize.height > height) {
      throw "'config.qrbox' dimensions should not be greater than the dimensions of the root HTML element.";
    }
    return {
      x: (width - qrboxSize.width) / 2,
      y: (height - qrboxSize.height) / 2,
      width: qrboxSize.width,
      height: qrboxSize.height
    };
  };
  Html5Qrcode2.prototype.possiblyInsertShadingElement = function(element, width, height, qrboxSize) {
    if (width - qrboxSize.width < 1 || height - qrboxSize.height < 1) {
      return;
    }
    var shadingElement = document.createElement("div");
    shadingElement.style.position = "absolute";
    var rightLeftBorderSize = (width - qrboxSize.width) / 2;
    var topBottomBorderSize = (height - qrboxSize.height) / 2;
    shadingElement.style.borderLeft = "".concat(rightLeftBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.borderRight = "".concat(rightLeftBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.borderTop = "".concat(topBottomBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.borderBottom = "".concat(topBottomBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.boxSizing = "border-box";
    shadingElement.style.top = "0px";
    shadingElement.style.bottom = "0px";
    shadingElement.style.left = "0px";
    shadingElement.style.right = "0px";
    shadingElement.id = "".concat(Constants.SHADED_REGION_ELEMENT_ID);
    if (width - qrboxSize.width < 11 || height - qrboxSize.height < 11) {
      this.hasBorderShaders = false;
    } else {
      var smallSize = 5;
      var largeSize = 40;
      this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, true);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, false);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, true);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, false);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, true);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, true);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, false);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, false);
      this.hasBorderShaders = true;
    }
    element.append(shadingElement);
  };
  Html5Qrcode2.prototype.insertShaderBorders = function(shaderElem, width, height, top, bottom, side, isLeft) {
    var elem = document.createElement("div");
    elem.style.position = "absolute";
    elem.style.backgroundColor = Constants.BORDER_SHADER_DEFAULT_COLOR;
    elem.style.width = "".concat(width, "px");
    elem.style.height = "".concat(height, "px");
    if (top !== null) {
      elem.style.top = "".concat(top, "px");
    }
    if (bottom !== null) {
      elem.style.bottom = "".concat(bottom, "px");
    }
    if (isLeft) {
      elem.style.left = "".concat(side, "px");
    } else {
      elem.style.right = "".concat(side, "px");
    }
    if (!this.borderShaders) {
      this.borderShaders = [];
    }
    this.borderShaders.push(elem);
    shaderElem.appendChild(elem);
  };
  Html5Qrcode2.prototype.showPausedState = function() {
    if (!this.scannerPausedUiElement) {
      throw "[internal error] scanner paused UI element not found";
    }
    this.scannerPausedUiElement.style.display = "block";
  };
  Html5Qrcode2.prototype.hidePausedState = function() {
    if (!this.scannerPausedUiElement) {
      throw "[internal error] scanner paused UI element not found";
    }
    this.scannerPausedUiElement.style.display = "none";
  };
  Html5Qrcode2.prototype.getTimeoutFps = function(fps) {
    return 1e3 / fps;
  };
  return Html5Qrcode2;
}();
(function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
});
(function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
});
(function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
});
(function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
});
var Html5QrcodeScannerStatus;
(function(Html5QrcodeScannerStatus2) {
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_DEFAULT"] = 0] = "STATUS_DEFAULT";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_SUCCESS"] = 1] = "STATUS_SUCCESS";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_WARNING"] = 2] = "STATUS_WARNING";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_REQUESTING_PERMISSION"] = 3] = "STATUS_REQUESTING_PERMISSION";
})(Html5QrcodeScannerStatus || (Html5QrcodeScannerStatus = {}));
const _hoisted_1$1 = { class: "grow-0 shrink-0 w-full flex flex-row flex-nowrap items-start justify-between border-b cc-p" };
const _hoisted_2$1 = { class: "flex flex-col flex-nowrap cc-text-sz cc-gap" };
const _hoisted_3$1 = { class: "flex flex-col flex-nowrap cc-p" };
const _hoisted_4$1 = { class: "flex flex-row flex-nowrap items-start" };
const _hoisted_5$1 = { class: "flex flex-row flex-nowrap items-start" };
const _hoisted_6$1 = { class: "relative" };
const _hoisted_7$1 = {
  key: 0,
  class: "absolute z-10 left-2 top-2 flex flex-row flex-nowrap cc-badge-yellow"
};
const _hoisted_8$1 = { class: "ml-1 cc-text-semi-bold" };
const _hoisted_9$1 = {
  key: 1,
  class: "cc-grid p-2 cc-gap"
};
const _hoisted_10 = {
  key: 0,
  class: "flex flex-row items-center p-2 cc-gap-sm"
};
const _hoisted_11 = { key: 0 };
const _hoisted_12 = ["selected", "value"];
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "AnimatedQRScanner",
  props: {
    open: { type: Boolean, required: true, default: false }
  },
  emits: ["decode", "close"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props2 = __props;
    const $q = useQuasar();
    const { it } = useTranslation();
    let urDecoder2 = new dist$j.URDecoder();
    const progress = ref(0);
    const cameraInit = ref(true);
    const cameraError = ref("");
    const html5QrCode = ref(null);
    const cameras = ref([]);
    const lastCamera = getLastCameraId();
    const QRCodeTypeWhitelist = ["crypto-multi-accounts", "cardano-signature", "cardano-sign-data-signature", "cardano-catalyst-voting-registration-signature"];
    const QRConfig = {
      fps: 10,
      qrbox: { width: 250, height: 250 },
      video: {
        width: { min: 640, ideal: 640, max: 640 },
        height: { min: 480, ideal: 480, max: 480 }
      }
    };
    const qrCodeSuccess = async (decodedText, decodedResult) => {
      try {
        urDecoder2.receivePart(decodedText);
        if (!urDecoder2.isComplete()) {
          progress.value = Math.trunc(urDecoder2.estimatedPercentComplete() * 100);
          return;
        }
        if (urDecoder2.isError()) {
          handleError(
            "INVALID_QR_CODE"
            /* INVALID_QR_CODE */
          );
        }
        if (urDecoder2.isSuccess()) {
          const ur2 = urDecoder2.resultUR();
          if (QRCodeTypeWhitelist.includes(ur2.type)) {
            try {
              const res = { type: ur2.type, cbor: ur2.cbor.toString("hex") };
              emit("decode", res);
            } catch (e) {
              handleError("FAILED_TO_HANDLE_QR_CODE");
            }
            await stopCamera();
          } else {
            handleError("UNEXPECTED_QRCODE: " + ur2.type);
          }
          urDecoder2 = new dist$j.URDecoder();
        }
      } catch (e) {
        handleError(
          "INVALID_QR_CODE"
          /* INVALID_QR_CODE */
        );
        urDecoder2 = new dist$j.URDecoder();
      }
    };
    const qrCodeError = (errorMessage, error) => {
    };
    async function initQRScanner(id, cameraUpdate) {
      cameraError.value = "";
      cameraInit.value = true;
      await nextTick(async () => {
        var _a;
        try {
          if (!html5QrCode.value) {
            html5QrCode.value = new Html5Qrcode("qr-code-reader", { formatsToSupport: [Html5QrcodeSupportedFormats.QR_CODE], verbose: void 0 });
          }
          if (cameras.value.length === 0 || cameraUpdate) {
            cameras.value = await Html5Qrcode.getCameras();
            if (cameraUpdate) ;
          }
          if (cameras.value.length === 0) {
            throw it("wallet.qr.error.nocamera");
          }
          let camera = id ?? lastCamera.value;
          if (!cameras.value.some((c) => c.id === camera)) {
            camera = { facingMode: "environment" };
          }
          await stopCamera();
          await ((_a = html5QrCode.value) == null ? void 0 : _a.start(camera, QRConfig, qrCodeSuccess, qrCodeError));
        } catch (err2) {
          cameraError.value = (err2 == null ? void 0 : err2.message) ?? JSON.stringify(err2);
          console.error("html5QrCode:", cameraError.value);
        } finally {
          cameraInit.value = false;
        }
      });
    }
    async function stopCamera() {
      var _a;
      if ((_a = html5QrCode.value) == null ? void 0 : _a.isScanning) {
        try {
          await html5QrCode.value.stop();
        } catch (e) {
        }
      }
      progress.value = 0;
    }
    function onCameraChange(event) {
      const cameraId = event.target.options[event.target.options.selectedIndex].value;
      setLastCameraId(cameraId);
      initQRScanner(cameraId);
    }
    watch(() => props2.open, (isOpen) => {
      if (isOpen) {
        initQRScanner();
      } else {
        stopCamera();
      }
    });
    onMounted(() => {
      if (!props2.open) {
        return;
      }
      cameras.value = [];
      initQRScanner();
    });
    onBeforeUnmount(() => {
      stopCamera();
    });
    function handleError(err2) {
      console.error(err2);
      $q.notify({
        type: "negative",
        message: err2,
        position: "top-left",
        timeout: 3e3
      });
    }
    function onClose() {
      emit("close");
    }
    return (_ctx, _cache) => {
      return __props.open ? (openBlock(), createBlock(Modal, {
        key: 0,
        "modal-container": "#eternl-sign-keystone",
        "full-width-on-mobile": "",
        narrow: "",
        onClose
      }, {
        header: withCtx(() => [
          createBaseVNode("div", _hoisted_1$1, [
            createBaseVNode("div", _hoisted_2$1, [
              createVNode(_sfc_main$3, {
                label: unref(it)("wallet.qr.scan.headline")
              }, null, 8, ["label"])
            ])
          ])
        ]),
        content: withCtx(() => [
          createBaseVNode("div", _hoisted_3$1, [
            createBaseVNode("div", _hoisted_4$1, [
              _cache[1] || (_cache[1] = createBaseVNode("i", { class: "mdi mdi-square-medium mr-1" }, null, -1)),
              createBaseVNode("div", null, toDisplayString(unref(it)("wallet.keystone.eternl.distance")), 1)
            ]),
            createBaseVNode("div", _hoisted_5$1, [
              _cache[2] || (_cache[2] = createBaseVNode("i", { class: "mdi mdi-square-medium mr-1" }, null, -1)),
              createBaseVNode("div", null, toDisplayString(unref(it)("wallet.keystone.eternl.density")), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_6$1, [
            progress.value !== 0 ? (openBlock(), createElementBlock("div", _hoisted_7$1, [
              createBaseVNode("span", null, toDisplayString(unref(it)("wallet.qr.scan.progress")) + ":", 1),
              createBaseVNode("span", _hoisted_8$1, toDisplayString(progress.value), 1),
              _cache[3] || (_cache[3] = createBaseVNode("span", { class: "ml-0.5" }, "%", -1))
            ])) : createCommentVNode("", true),
            cameraError.value.length > 0 || cameraInit.value ? (openBlock(), createElementBlock("div", _hoisted_9$1, [
              createVNode(_sfc_main$4, {
                label: unref(it)("wallet.qr.loading"),
                active: cameraInit.value
              }, null, 8, ["label", "active"]),
              cameraError.value.length > 0 ? (openBlock(), createBlock(_sfc_main$5, {
                key: 0,
                text: cameraError.value,
                icon: "mdi mdi-alert-octagon-outline",
                class: "col-span-12",
                "text-c-s-s": "cc-text-normal text-justify",
                css: "cc-rounded cc-banner-warning items-center"
              }, null, 8, ["text"])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            _cache[4] || (_cache[4] = createBaseVNode("div", { id: "qr-code-reader" }, null, -1))
          ])
        ]),
        footer: withCtx(() => [
          !cameraInit.value ? (openBlock(), createElementBlock("div", _hoisted_10, [
            cameras.value.length > 0 ? (openBlock(), createElementBlock("span", _hoisted_11, toDisplayString(unref(it)("wallet.qr.select")) + ":", 1)) : createCommentVNode("", true),
            cameras.value.length > 0 ? (openBlock(), createElementBlock("select", {
              key: 1,
              class: "cc-rounded-la cc-dropdown cc-text-sm",
              required: true,
              onChange: _cache[0] || (_cache[0] = ($event) => onCameraChange($event))
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(cameras.value, (camera) => {
                return openBlock(), createElementBlock("option", {
                  key: camera.id,
                  selected: camera.id === unref(lastCamera),
                  value: camera.id
                }, toDisplayString(camera.label.replace(/\s\([a-f,0-9]+:[a-f,0-9]+\)$/, "")), 9, _hoisted_12);
              }), 128))
            ], 32)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        _: 1
      })) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1 = { class: "grow-0 shrink-0 w-full flex flex-row flex-nowrap items-start justify-between border-b cc-p" };
const _hoisted_2 = { class: "flex flex-col flex-nowrap cc-text-sz cc-gap" };
const _hoisted_3 = { class: "flex flex-col flex-nowrap cc-p" };
const _hoisted_4 = { class: "flex flex-row flex-nowrap items-start" };
const _hoisted_5 = { class: "flex flex-row flex-nowrap items-start" };
const _hoisted_6 = { class: "flex flex-row flex-nowrap items-start" };
const _hoisted_7 = { class: "flex flex-row flex-nowrap items-start" };
const _hoisted_8 = { class: "flex justify-center" };
const _hoisted_9 = { class: "grid grid-cols-12 cc-gap p-2 w-full" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Keystone",
  props: {
    open: { type: Boolean, required: true, default: false },
    label: { type: String, required: false },
    keystoneUR: { type: Object, required: false }
  },
  emits: ["close", "decode"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { it } = useTranslation();
    const showScanner = ref(false);
    const onClose = () => emit("close");
    const onNext = () => showScanner.value = true;
    const onCloseScanner = () => {
      showScanner.value = false;
      emit("close");
    };
    const onDecode = (args) => {
      showScanner.value = false;
      emit("decode", args);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        __props.open && !showScanner.value ? (openBlock(), createBlock(Modal, {
          key: 0,
          "modal-container": "#eternl-sign-keystone",
          narrow: "",
          "full-width-on-mobile": "",
          onClose
        }, {
          header: withCtx(() => [
            createBaseVNode("div", _hoisted_1, [
              createBaseVNode("div", _hoisted_2, [
                createVNode(_sfc_main$3, {
                  label: !!__props.label ? __props.label : unref(it)("wallet.keystone.label")
                }, null, 8, ["label"])
              ])
            ])
          ]),
          content: withCtx(() => [
            createBaseVNode("div", _hoisted_3, [
              createBaseVNode("div", _hoisted_4, [
                _cache[0] || (_cache[0] = createBaseVNode("i", { class: "mdi mdi-square-medium mr-1" }, null, -1)),
                createBaseVNode("div", null, toDisplayString(unref(it)("wallet.keystone.keystone.unlock")), 1)
              ]),
              createBaseVNode("div", _hoisted_5, [
                _cache[1] || (_cache[1] = createBaseVNode("i", { class: "mdi mdi-square-medium mr-1" }, null, -1)),
                createBaseVNode("div", null, toDisplayString(unref(it)("wallet.keystone.keystone.scan")), 1),
                _cache[2] || (_cache[2] = createBaseVNode("i", { class: "mdi mdi-line-scan ml-1" }, null, -1))
              ]),
              createBaseVNode("div", _hoisted_6, [
                _cache[3] || (_cache[3] = createBaseVNode("i", { class: "mdi mdi-square-medium mr-1" }, null, -1)),
                createBaseVNode("div", null, toDisplayString(unref(it)("wallet.keystone.keystone.qrscan")), 1)
              ]),
              createBaseVNode("div", _hoisted_7, [
                _cache[4] || (_cache[4] = createBaseVNode("i", { class: "mdi mdi-square-medium mr-1" }, null, -1)),
                createBaseVNode("div", null, toDisplayString(unref(it)("wallet.keystone.keystone.next")), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_8, [
              __props.keystoneUR && !showScanner.value ? (openBlock(), createBlock(_sfc_main$2, {
                key: 0,
                ur: __props.keystoneUR
              }, null, 8, ["ur"])) : createCommentVNode("", true)
            ])
          ]),
          footer: withCtx(() => [
            createBaseVNode("div", _hoisted_9, [
              createVNode(GridButtonSecondary, {
                label: unref(it)("common.label.cancel"),
                link: onClose,
                class: "col-span-6"
              }, null, 8, ["label"]),
              createVNode(_sfc_main$6, {
                label: unref(it)("common.label.next"),
                link: onNext,
                class: "col-span-6"
              }, null, 8, ["label"])
            ])
          ]),
          _: 1
        })) : createCommentVNode("", true),
        createVNode(_sfc_main$1, {
          open: showScanner.value,
          onClose: onCloseScanner,
          onDecode
        }, null, 8, ["open"])
      ], 64);
    };
  }
});
export {
  _sfc_main as _,
  __values$1 as a,
  __spreadArray as b,
  __read as c,
  __extends$2 as d,
  __asyncGenerator as e,
  __generator$5 as f,
  __await as g,
  __awaiter$5 as h,
  __asyncValues as i,
  src$1 as j,
  createSignDataBuilder as k,
  createCOSEKeyHex as l,
  require$$0$2 as r,
  signData as s,
  useKeystoneDevice as u,
  verifyData as v
};
