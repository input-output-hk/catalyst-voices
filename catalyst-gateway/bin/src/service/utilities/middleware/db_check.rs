//! Middleware to verify that there is connection the databases.

use poem::{http::StatusCode, Endpoint, Middleware, Request, Result};
use tracing::error;

use crate::service::utilities::health::{event_db_is_live, index_db_is_live};

/// Middleware type that returns a response with 503 status code
/// if any DB stops responding before returning the wrapped endpoint.
pub(crate) struct DatabaseConnectionCheck;

impl<E: Endpoint> Middleware<E> for DatabaseConnectionCheck {
    type Output = DatabaseConnectionImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        DatabaseConnectionImpl { ep }
    }
}

/// The new endpoint type generated by the `DatabaseConnectionCheck`.
pub(crate) struct DatabaseConnectionImpl<E> {
    /// Endpoint wrapped by the middleware.
    ep: E,
}

impl<E: Endpoint> Endpoint for DatabaseConnectionImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Result<Self::Output> {
        let req_path = req.uri().path();

        // TODO: find a better way to filter URI paths
        let is_health_endpoint = req_path.starts_with("/api/v1/health/");

        if !is_health_endpoint {
            if !event_db_is_live() {
                error!(endpoint_path = %req_path, "Event DB is not live");
                return Err(StatusCode::SERVICE_UNAVAILABLE.into());
            }
            if !index_db_is_live() {
                error!(endpoint_path = %req_path, "Index DB is not live");
                return Err(StatusCode::SERVICE_UNAVAILABLE.into());
            }
        }
        self.ep.call(req).await
    }
}
