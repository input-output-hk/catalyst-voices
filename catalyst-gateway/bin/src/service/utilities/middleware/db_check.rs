//! Middleware to verify that there is connection the databases.

use poem::{http::StatusCode, Endpoint, Middleware, Request, Result};
use tracing::error;

use crate::{
    db::{event::EventDB, index::session::CassandraSession},
    service::utilities::health::{set_event_db_liveness, set_index_db_liveness},
};

/// Middleware type that returns a response with 503 status code
/// if any DB stops responding before returning the wrapped endpoint.
pub(crate) struct DatabaseConnectionCheck;

impl<E: Endpoint> Middleware<E> for DatabaseConnectionCheck {
    type Output = DatabaseConnectionImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        DatabaseConnectionImpl { ep }
    }
}

/// The new endpoint type generated by the `DatabaseConnectionCheck`.
pub(crate) struct DatabaseConnectionImpl<E> {
    /// Endpoint wrapped by the middleware.
    ep: E,
}

impl<E: Endpoint> Endpoint for DatabaseConnectionImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Result<Self::Output> {
        // TODO: find a better way to filter URI paths
        if !req.uri().path().starts_with("/health") {
            if !EventDB::connection_is_ok() {
                set_event_db_liveness(false);
                error!("EventDB connection failed");
                return Err(StatusCode::SERVICE_UNAVAILABLE.into());
            }
            if !CassandraSession::is_ready() {
                set_index_db_liveness(false);
                error!("Index DB connection failed");
                return Err(StatusCode::SERVICE_UNAVAILABLE.into());
            }
        }
        self.ep.call(req).await
    }
}
