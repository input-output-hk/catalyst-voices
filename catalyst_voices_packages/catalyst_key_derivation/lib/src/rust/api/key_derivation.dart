// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.5.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `derive_xprv_helper`, `mnemonic_to_xprv_helper`, `sign_data_helper`, `verify_signature_xprv_helper`, `verify_signature_xpub_helper`, `xpublic_key_helper`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `from`, `from`

/// Generate a new extended private key (`XPrv`) from a mnemonic and passphrase.
/// Note that this function only works with BIP-0039 mnemonics.
/// For more information: Cardano Icarus master node derivation
/// <https://github.com/satoshilabs/slips/blob/master/slip-0023.md>
///
/// # Arguments
///
/// - `mnemonic`: A string representing the mnemonic.
/// - `passphrase`: An optional string representing the passphrase (aka. password).
///
/// # Returns
///
/// Returns a bytes of extended private key as a `Result`.
///
/// # Errors
///
/// Returns an error if the mnemonic is invalid.
Future<XPrvBytes> mnemonicToXprv(
        {required String mnemonic, String? passphrase}) =>
    RustLib.instance.api.crateApiKeyDerivationMnemonicToXprv(
        mnemonic: mnemonic, passphrase: passphrase);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SignatureBytes>>
abstract class SignatureBytes implements RustOpaqueInterface {
  /// Get the inner bytes.
  U8Array64 get inner;

  /// Create a new `SignatureBytes` from the given bytes.
  factory SignatureBytes({required U8Array64 sigBytes}) => RustLib.instance.api
      .crateApiKeyDerivationSignatureBytesNew(sigBytes: sigBytes);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XPrvBytes>>
abstract class XPrvBytes implements RustOpaqueInterface {
  /// Derive a new extended private key from the given extended private key.
  /// - V2 derivation scheme is used as it is mention in [SLIP-0023](https://github.com/satoshilabs/slips/blob/master/slip-0023.md).
  /// - More information about child key derivation can be found in [BIP32-Ed25519](https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf).
  ///
  /// # Arguments
  ///
  /// - `xprv_bytes`: An extended private key bytes of type `XPrvBytes`.
  /// - `path`: Derivation path. eg. m/0/2'/3 where ' represents hardened derivation.
  ///
  /// # Returns
  ///
  /// Returns a bytes of extended private key as a `Result`.
  ///
  /// # Errors
  ///
  /// Returns an error if the derivation path is invalid.
  Future<XPrvBytes> deriveXprv({required String path});

  /// Drop the extended private key.
  void drop();

  /// Extract the chain code from the extended private key.
  /// The chain code is the last 32 bytes of the extended private key.
  ///
  /// # Returns
  ///
  /// Returns a 32 length bytes representing the chain code.
  U8Array32 get chainCode;

  /// Extract the extended secret key from the extended private key.
  /// The extended secret key is the first 64 bytes of the extended private key.
  ///
  /// # Returns
  ///
  /// Returns a 64 length bytes representing the extended secret key.
  U8Array64 get extendedSecretKey;

  /// Get the inner bytes.
  U8Array96 get inner;

  /// Create a new `XPrvBytes` from the given bytes.
  factory XPrvBytes({required U8Array96 xprvBytes}) => RustLib.instance.api
      .crateApiKeyDerivationXPrvBytesNew(xprvBytes: xprvBytes);

  /// Sign the given data with the given extended private key.
  ///
  /// # Arguments
  ///
  /// - `data`: The data to sign.
  ///
  /// # Returns
  /// Returns a 64 length bytes `SignatureBytes` representing the signature.
  ///
  /// # Errors
  ///
  /// Returns an error if the extended private key is invalid.
  Future<SignatureBytes> signData({required List<int> data});

  /// Verify the signature on the given data using extended private key.
  ///
  /// # Arguments
  ///
  /// - `data`: The data to sign.
  /// - `signature`: The signature to check.
  ///
  /// # Returns
  /// Returns a boolean value indicating if the signature match the sign data
  /// True if the signature is valid and match the sign data, false otherwise.
  ///
  /// # Errors
  ///
  /// Returns an error if the extended private key or signature is invalid.
  Future<bool> verifySignature(
      {required List<int> data, required SignatureBytes signature});

  /// Get extended public key from the given extended private key.
  ///
  /// # Returns
  ///
  /// Returns a 64 length bytes `XPubBytes` representing the extended public key.
  ///
  /// # Errors
  ///
  /// Returns an error if the extended private key is invalid.
  Future<XPubBytes> xpublicKey();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XPubBytes>>
abstract class XPubBytes implements RustOpaqueInterface {
  /// Extract the chain code from the extended public key.
  /// The chain code is the last 32 bytes of the extended public key.
  ///
  /// # Returns
  ///
  /// Returns a 32 length bytes representing the chain code.
  U8Array32 get chainCode;

  /// Get the inner bytes.
  U8Array64 get inner;

  /// Extract the public key from the extended public key.
  /// The public key is the first 32 bytes of the extended public key.
  ///
  /// # Returns
  ///
  /// Returns a 32 length bytes representing the public key.
  U8Array32 get publicKey;

  /// Create a new `XPubBytes` from the given bytes.
  factory XPubBytes({required U8Array64 xpubBytes}) => RustLib.instance.api
      .crateApiKeyDerivationXPubBytesNew(xpubBytes: xpubBytes);

  /// Verify the signature on the given data using extended public key.
  ///
  /// # Arguments
  ///
  /// - `data`: The data to sign.
  /// - `signature`: The signature to check.
  ///
  /// # Returns
  /// Returns a boolean value indicating if the signature match the sign data
  /// True if the signature is valid and match the sign data, false otherwise.
  ///
  /// # Errors
  ///
  /// Returns an error if the extended public key or signature is invalid.
  Future<bool> verifySignature(
      {required List<int> data, required SignatureBytes signature});
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array32(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array32.init() : this(Uint8List(arraySize));
}

class U8Array64 extends NonGrowableListView<int> {
  static const arraySize = 64;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array64(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array64.init() : this(Uint8List(arraySize));
}

class U8Array96 extends NonGrowableListView<int> {
  static const arraySize = 96;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array96(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array96.init() : this(Uint8List(arraySize));
}
