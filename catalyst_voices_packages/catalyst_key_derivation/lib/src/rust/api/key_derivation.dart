// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.5.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `check_signature_xprv_helper`, `check_signature_xpub_helper`, `derive_xprv_helper`, `mnemonic_to_xprv_helper`, `sign_data_helper`, `xpublic_key_helper`

/// Generate a new extended private key (`XPrv`) from a mnemonic and passphrase.
/// Note that this function only works with BIP-0039 mnemonics.
/// For more information: Cardano Icarus master node derivation
/// <https://github.com/satoshilabs/slips/blob/master/slip-0023.md>
///
/// # Arguments
///
/// - `mnemonic`: A string representing the mnemonic.
/// - `passphrase`: An optional string representing the passphrase (aka. password).
///
/// # Returns
///
/// Returns a bytes of extended private key as a `Result`.
///
/// # Errors
///
/// Returns an error if the mnemonic is invalid.
Future<U8Array96> mnemonicToXprv(
        {required String mnemonic, String? passphrase}) =>
    RustLib.instance.api.crateApiKeyDerivationMnemonicToXprv(
        mnemonic: mnemonic, passphrase: passphrase);

/// Derive a new extended private key from the given extended private key.
/// - V2 derivation scheme is used as it is mention in [SLIP-0023](https://github.com/satoshilabs/slips/blob/master/slip-0023.md).
/// - More information about child key derivation can be found in [BIP32-Ed25519](https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf).
///
/// # Arguments
///
/// - `xprv_bytes`: An extended private key bytes of type `XPrvBytes`.
/// - `path`: Derivation path. eg. m/0/2'/3 where ' represents hardened derivation.
///
/// # Returns
///
/// Returns a bytes of extended private key as a `Result`.
///
/// # Errors
///
/// Returns an error if the derivation path is invalid.
Future<U8Array96> deriveXprv(
        {required U8Array96 xprvBytes, required String path}) =>
    RustLib.instance.api
        .crateApiKeyDerivationDeriveXprv(xprvBytes: xprvBytes, path: path);

/// Get extended public key from the given extended private key.
///
/// # Arguments
///
/// - `xprv_bytes`: An extended private key bytes of type `XPrvBytes`.
///
/// # Returns
///
/// Returns a 64 length bytes `XPubBytes` representing the extended public key.
///
/// # Errors
///
/// Returns an error if the extended private key is invalid.
Future<U8Array64> xpublicKey({required U8Array96 xprvBytes}) =>
    RustLib.instance.api.crateApiKeyDerivationXpublicKey(xprvBytes: xprvBytes);

/// Sign the given data with the given extended private key.
///
/// # Arguments
///
/// - `xprv_bytes`: An extended private key bytes of type `XPrvBytes`.
/// - `data`: The data to sign.
///
/// # Returns
/// Returns a 64 length bytes `SignatureBytes` representing the signature.
///
/// # Errors
///
/// Returns an error if the extended private key is invalid.
Future<U8Array64> signData(
        {required U8Array96 xprvBytes, required List<int> data}) =>
    RustLib.instance.api
        .crateApiKeyDerivationSignData(xprvBytes: xprvBytes, data: data);

/// Check the signature on the given data using extended private key.
///
/// # Arguments
///
/// - `xprv_bytes`: An extended private key bytes of type `XPrvBytes`.
/// - `data`: The data to sign.
/// - `signature`: The signature to check.
///
/// # Returns
/// Returns a boolean value indicating if the signature match the sign data
/// True if the signature is valid and match the sign data, false otherwise.
///
/// # Errors
///
/// Returns an error if the extended private key or signature is invalid.
Future<bool> checkSignatureXprv(
        {required U8Array96 xprvBytes,
        required List<int> data,
        required U8Array64 signature}) =>
    RustLib.instance.api.crateApiKeyDerivationCheckSignatureXprv(
        xprvBytes: xprvBytes, data: data, signature: signature);

/// Check the signature on the given data using extended public key.
///
/// # Arguments
///
/// - `xpub_bytes`: An extended public key bytes of type `XPubBytes`.
/// - `data`: The data to sign.
/// - `signature`: The signature to check.
///
/// # Returns
/// Returns a boolean value indicating if the signature match the sign data
/// True if the signature is valid and match the sign data, false otherwise.
///
/// # Errors
///
/// Returns an error if the extended public key or signature is invalid.
Future<bool> checkSignatureXpub(
        {required U8Array64 xpubBytes,
        required List<int> data,
        required U8Array64 signature}) =>
    RustLib.instance.api.crateApiKeyDerivationCheckSignatureXpub(
        xpubBytes: xpubBytes, data: data, signature: signature);

class U8Array64 extends NonGrowableListView<int> {
  static const arraySize = 64;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array64(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array64.init() : this(Uint8List(arraySize));
}

class U8Array96 extends NonGrowableListView<int> {
  static const arraySize = 96;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array96(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array96.init() : this(Uint8List(arraySize));
}
