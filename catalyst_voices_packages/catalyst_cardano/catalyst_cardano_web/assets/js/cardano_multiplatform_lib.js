
let wasm;

const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachedUint8Memory0 = new Uint8Array();

function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

const heap = new Array(32).fill(undefined);

heap.push(undefined, null, true, false);

let heap_next = heap.length;

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function getObject(idx) { return heap[idx]; }

function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        wasm.__wbindgen_exn_store(addHeapObject(e));
    }
}

let WASM_VECTOR_LEN = 0;

const cachedTextEncoder = new TextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachedInt32Memory0 = new Int32Array();

function getInt32Memory0() {
    if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}
/**
* Encrypt using Emip3: https://github.com/Emurgo/EmIPs/blob/master/specs/emip-003.md
* @param {string} password
* @param {string} salt
* @param {string} nonce
* @param {string} data
* @returns {string}
*/
export function emip3_encrypt_with_password(password, salt, nonce, data) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(salt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(nonce, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len3 = WASM_VECTOR_LEN;
        wasm.emip3_encrypt_with_password(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr4 = r0;
        var len4 = r1;
        if (r3) {
            ptr4 = 0; len4 = 0;
            throw takeObject(r2);
        }
        return getStringFromWasm0(ptr4, len4);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(ptr4, len4);
    }
}

/**
* Decrypt using Emip3: https://github.com/Emurgo/EmIPs/blob/master/specs/emip-003.md
* @param {string} password
* @param {string} data
* @returns {string}
*/
export function emip3_decrypt_with_password(password, data) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        wasm.emip3_decrypt_with_password(retptr, ptr0, len0, ptr1, len1);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(ptr2, len2);
    }
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachedBigInt64Memory0 = new BigInt64Array();

function getBigInt64Memory0() {
    if (cachedBigInt64Memory0.byteLength === 0) {
        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);
    }
    return cachedBigInt64Memory0;
}

let cachedUint32Memory0 = new Uint32Array();

function getUint32Memory0() {
    if (cachedUint32Memory0.byteLength === 0) {
        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32Memory0;
}

function getArrayU32FromWasm0(ptr, len) {
    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);
}

let cachedUint16Memory0 = new Uint16Array();

function getUint16Memory0() {
    if (cachedUint16Memory0.byteLength === 0) {
        cachedUint16Memory0 = new Uint16Array(wasm.memory.buffer);
    }
    return cachedUint16Memory0;
}

function getArrayU16FromWasm0(ptr, len) {
    return getUint16Memory0().subarray(ptr / 2, ptr / 2 + len);
}
/**
* @param {RedeemerList} redeemers
* @returns {ExUnits}
*/
export function compute_total_ex_units(redeemers) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(redeemers, RedeemerList);
        wasm.compute_total_ex_units(retptr, redeemers.ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return ExUnits.__wrap(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
*
* * Min fee for JUST the script
*
* @param {Transaction} tx
* @param {ExUnitPrices} ex_unit_prices
* @returns {bigint}
*/
export function min_script_fee(tx, ex_unit_prices) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(tx, Transaction);
        _assertClass(ex_unit_prices, ExUnitPrices);
        wasm.min_script_fee(retptr, tx.ptr, ex_unit_prices.ptr);
        var r0 = getBigInt64Memory0()[retptr / 8 + 0];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        return BigInt.asUintN(64, r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Transaction} tx
* @param {LinearFee} linear_fee
* @returns {bigint}
*/
export function min_no_script_fee(tx, linear_fee) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(tx, Transaction);
        _assertClass(linear_fee, LinearFee);
        wasm.min_no_script_fee(retptr, tx.ptr, linear_fee.ptr);
        var r0 = getBigInt64Memory0()[retptr / 8 + 0];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        return BigInt.asUintN(64, r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Transaction} tx
* @param {LinearFee} linear_fee
* @param {ExUnitPrices} ex_unit_prices
* @returns {bigint}
*/
export function min_fee(tx, linear_fee, ex_unit_prices) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(tx, Transaction);
        _assertClass(linear_fee, LinearFee);
        _assertClass(ex_unit_prices, ExUnitPrices);
        wasm.min_fee(retptr, tx.ptr, linear_fee.ptr, ex_unit_prices.ptr);
        var r0 = getBigInt64Memory0()[retptr / 8 + 0];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        return BigInt.asUintN(64, r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {TransactionHash} tx_body_hash
* @param {ByronAddress} addr
* @param {LegacyDaedalusPrivateKey} key
* @returns {BootstrapWitness}
*/
export function make_daedalus_bootstrap_witness(tx_body_hash, addr, key) {
    _assertClass(tx_body_hash, TransactionHash);
    _assertClass(addr, ByronAddress);
    _assertClass(key, LegacyDaedalusPrivateKey);
    const ret = wasm.make_daedalus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);
    return BootstrapWitness.__wrap(ret);
}

/**
* @param {TransactionHash} tx_body_hash
* @param {ByronAddress} addr
* @param {Bip32PrivateKey} key
* @returns {BootstrapWitness}
*/
export function make_icarus_bootstrap_witness(tx_body_hash, addr, key) {
    _assertClass(tx_body_hash, TransactionHash);
    var ptr0 = tx_body_hash.ptr;
    tx_body_hash.ptr = 0;
    _assertClass(addr, ByronAddress);
    var ptr1 = addr.ptr;
    addr.ptr = 0;
    _assertClass(key, Bip32PrivateKey);
    const ret = wasm.make_icarus_bootstrap_witness(ptr0, ptr1, key.ptr);
    return BootstrapWitness.__wrap(ret);
}

/**
* @param {TransactionBody} txbody
* @param {bigint} pool_deposit
* @param {bigint} key_deposit
* @returns {Value}
*/
export function get_implicit_input(txbody, pool_deposit, key_deposit) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(txbody, TransactionBody);
        wasm.get_implicit_input(retptr, txbody.ptr, pool_deposit, key_deposit);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return Value.__wrap(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {TransactionBody} txbody
* @param {bigint} pool_deposit
* @param {bigint} key_deposit
* @returns {bigint}
*/
export function get_deposit(txbody, pool_deposit, key_deposit) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(txbody, TransactionBody);
        wasm.get_deposit(retptr, txbody.ptr, pool_deposit, key_deposit);
        var r0 = getBigInt64Memory0()[retptr / 8 + 0];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        return BigInt.asUintN(64, r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {TransactionOutput} output
* @param {bigint} coins_per_utxo_byte
* @returns {bigint}
*/
export function min_ada_required(output, coins_per_utxo_byte) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(output, TransactionOutput);
        wasm.min_ada_required(retptr, output.ptr, coins_per_utxo_byte);
        var r0 = getBigInt64Memory0()[retptr / 8 + 0];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        return BigInt.asUintN(64, r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* encodes arbitrary bytes into chunks of 64 bytes (the limit for bytes) as a list to be valid Metadata
* @param {Uint8Array} bytes
* @returns {TransactionMetadatum}
*/
export function encode_arbitrary_bytes_as_metadatum(bytes) {
    const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.encode_arbitrary_bytes_as_metadatum(ptr0, len0);
    return TransactionMetadatum.__wrap(ret);
}

/**
* decodes from chunks of bytes in a list to a byte vector if that is the metadata format, otherwise returns None
* @param {TransactionMetadatum} metadata
* @returns {Uint8Array | undefined}
*/
export function decode_arbitrary_bytes_from_metadatum(metadata) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(metadata, TransactionMetadatum);
        wasm.decode_arbitrary_bytes_from_metadatum(retptr, metadata.ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        let v0;
        if (r0 !== 0) {
            v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
        }
        return v0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Converts JSON to Metadata according to MetadataJsonSchema
* @param {string} json
* @param {number} schema
* @returns {TransactionMetadatum}
*/
export function encode_json_str_to_metadatum(json, schema) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.encode_json_str_to_metadatum(retptr, ptr0, len0, schema);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return TransactionMetadatum.__wrap(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Converts Metadata to JSON according to MetadataJsonSchema
* @param {TransactionMetadatum} metadatum
* @param {number} schema
* @returns {string}
*/
export function decode_metadatum_to_json_str(metadatum, schema) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(metadatum, TransactionMetadatum);
        wasm.decode_metadatum_to_json_str(retptr, metadatum.ptr, schema);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr0 = r0;
        var len0 = r1;
        if (r3) {
            ptr0 = 0; len0 = 0;
            throw takeObject(r2);
        }
        return getStringFromWasm0(ptr0, len0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(ptr0, len0);
    }
}

/**
* @param {string} json
* @param {number} schema
* @returns {PlutusData}
*/
export function encode_json_str_to_plutus_datum(json, schema) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.encode_json_str_to_plutus_datum(retptr, ptr0, len0, schema);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return PlutusData.__wrap(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {PlutusData} datum
* @param {number} schema
* @returns {string}
*/
export function decode_plutus_datum_to_json_str(datum, schema) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(datum, PlutusData);
        wasm.decode_plutus_datum_to_json_str(retptr, datum.ptr, schema);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr0 = r0;
        var len0 = r1;
        if (r3) {
            ptr0 = 0; len0 = 0;
            throw takeObject(r2);
        }
        return getStringFromWasm0(ptr0, len0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(ptr0, len0);
    }
}

function passArray16ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 2);
    getUint16Memory0().set(arg, ptr / 2);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
* @param {AuxiliaryData} auxiliary_data
* @returns {AuxiliaryDataHash}
*/
export function hash_auxiliary_data(auxiliary_data) {
    _assertClass(auxiliary_data, AuxiliaryData);
    const ret = wasm.hash_auxiliary_data(auxiliary_data.ptr);
    return AuxiliaryDataHash.__wrap(ret);
}

/**
* @param {TransactionBody} tx_body
* @returns {TransactionHash}
*/
export function hash_transaction(tx_body) {
    _assertClass(tx_body, TransactionBody);
    const ret = wasm.hash_transaction(tx_body.ptr);
    return TransactionHash.__wrap(ret);
}

/**
* @param {PlutusData} plutus_data
* @returns {DatumHash}
*/
export function hash_plutus_data(plutus_data) {
    _assertClass(plutus_data, PlutusData);
    const ret = wasm.hash_plutus_data(plutus_data.ptr);
    return DatumHash.__wrap(ret);
}

/**
* Calculates the hash for script data (no plutus scripts) if it is necessary.
* Returns None if it was not necessary (no datums/redeemers) to include.
*
* Most users will not directly need this as when using the builders
* it will be invoked for you.
*
* Note: This WASM binding does not work with non-standard witness set
* encodings. If you created the witness set manually this is not an issue
* but for constructing it from deserializing a transaction/witness then
* please use calc_script_data_hash_from_witness()
* @param {RedeemerList} redeemers
* @param {CostModels} cost_models
* @param {PlutusDataList | undefined} datums
* @returns {ScriptDataHash}
*/
export function hash_script_data(redeemers, cost_models, datums) {
    _assertClass(redeemers, RedeemerList);
    _assertClass(cost_models, CostModels);
    let ptr0 = 0;
    if (!isLikeNone(datums)) {
        _assertClass(datums, PlutusDataList);
        ptr0 = datums.ptr;
        datums.ptr = 0;
    }
    const ret = wasm.hash_script_data(redeemers.ptr, cost_models.ptr, ptr0);
    return ScriptDataHash.__wrap(ret);
}

/**
* Calculates the hash for script data (with plutus scripts) if it is necessary.
* Returns None if it was not necessary (no datums/redeemers) to include.
*
* Most users will not directly need this as when using the builders
* it will be invoked for you.
*
* Note: This WASM binding does not work with non-standard witness set
* encodings. If you created the witness set manually this is not an issue
* but for constructing it from deserializing a transaction/witness then
* please use calc_script_data_hash_from_witness()
* @param {RedeemerList} redeemers
* @param {PlutusDataList} datums
* @param {CostModels} cost_models
* @param {LanguageList} used_langs
* @returns {ScriptDataHash | undefined}
*/
export function calc_script_data_hash(redeemers, datums, cost_models, used_langs) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(redeemers, RedeemerList);
        _assertClass(datums, PlutusDataList);
        _assertClass(cost_models, CostModels);
        _assertClass(used_langs, LanguageList);
        wasm.calc_script_data_hash(retptr, redeemers.ptr, datums.ptr, cost_models.ptr, used_langs.ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 === 0 ? undefined : ScriptDataHash.__wrap(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Calculates the hash for script data from a witness if it is necessary.
* Returns None if it was not necessary (no datums/redeemers) to include.
*
* Most users will not directly need this as when using the builders
* it will be invoked for you.
* @param {TransactionWitnessSet} witnesses
* @param {CostModels} cost_models
* @returns {ScriptDataHash | undefined}
*/
export function calc_script_data_hash_from_witness(witnesses, cost_models) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(witnesses, TransactionWitnessSet);
        _assertClass(cost_models, CostModels);
        wasm.calc_script_data_hash_from_witness(retptr, witnesses.ptr, cost_models.ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 === 0 ? undefined : ScriptDataHash.__wrap(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {TransactionHash} tx_body_hash
* @param {PrivateKey} sk
* @returns {Vkeywitness}
*/
export function make_vkey_witness(tx_body_hash, sk) {
    _assertClass(tx_body_hash, TransactionHash);
    _assertClass(sk, PrivateKey);
    const ret = wasm.make_vkey_witness(tx_body_hash.ptr, sk.ptr);
    return Vkeywitness.__wrap(ret);
}

/**
*/
export const ByronAddrType = Object.freeze({ PublicKey:0,"0":"PublicKey",Script:1,"1":"Script",Redeem:2,"2":"Redeem", });
/**
*/
export const Vote = Object.freeze({ No:0,"0":"No",Yes:1,"1":"Yes",Abstain:2,"2":"Abstain", });
/**
*/
export const CoinSelectionStrategyCIP2 = Object.freeze({
/**
* Performs CIP2's Largest First ada-only selection. Will error if outputs contain non-ADA assets.
*/
LargestFirst:0,"0":"LargestFirst",
/**
* Performs CIP2's Random Improve ada-only selection. Will error if outputs contain non-ADA assets.
*/
RandomImprove:1,"1":"RandomImprove",
/**
* Same as LargestFirst, but before adding ADA, will insert by largest-first for each asset type.
*/
LargestFirstMultiAsset:2,"2":"LargestFirstMultiAsset",
/**
* Same as RandomImprove, but before adding ADA, will insert by random-improve for each asset type.
*/
RandomImproveMultiAsset:3,"3":"RandomImproveMultiAsset", });
/**
*/
export const ChangeSelectionAlgo = Object.freeze({ Default:0,"0":"Default", });
/**
*/
export const MetadataJsonSchema = Object.freeze({ NoConversions:0,"0":"NoConversions",BasicConversions:1,"1":"BasicConversions",DetailedSchema:2,"2":"DetailedSchema", });
/**
* JSON <-> PlutusData conversion schemas.
* Follows ScriptDataJsonSchema in cardano-cli defined at:
* https://github.com/input-output-hk/cardano-node/blob/master/cardano-api/src/Cardano/Api/ScriptData.hs#L254
*
* All methods here have the following restrictions due to limitations on dependencies:
* * JSON numbers above u64::MAX (positive) or below i64::MIN (negative) will throw errors
* * Hex strings for bytes don't accept odd-length (half-byte) strings.
*      cardano-cli seems to support these however but it seems to be different than just 0-padding
*      on either side when tested so proceed with caution
*/
export const CardanoNodePlutusDatumSchema = Object.freeze({
/**
* ScriptDataJsonNoSchema in cardano-node.
*
* This is the format used by --script-data-value in cardano-cli
* This tries to accept most JSON but does not support the full spectrum of Plutus datums.
* From JSON:
* * null/true/false/floats NOT supported
* * strings starting with 0x are treated as hex bytes. All other strings are encoded as their utf8 bytes.
* To JSON:
* * ConstrPlutusData not supported in ANY FORM (neither keys nor values)
* * Lists not supported in keys
* * Maps not supported in keys
*/
BasicConversions:0,"0":"BasicConversions",
/**
* ScriptDataJsonDetailedSchema in cardano-node.
*
* This is the format used by --script-data-file in cardano-cli
* This covers almost all (only minor exceptions) Plutus datums, but the JSON must conform to a strict schema.
* The schema specifies that ALL keys and ALL values must be contained in a JSON map with 2 cases:
* 1. For ConstrPlutusData there must be two fields "constructor" contianing a number and "fields" containing its fields
*    e.g. { "constructor": 2, "fields": [{"int": 2}, {"list": [{"bytes": "CAFEF00D"}]}]}
* 2. For all other cases there must be only one field named "int", "bytes", "list" or "map"
*    BigInteger's value is a JSON number e.g. {"int": 100}
*    Bytes' value is a hex string representing the bytes WITHOUT any prefix e.g. {"bytes": "CAFEF00D"}
*    Lists' value is a JSON list of its elements encoded via the same schema e.g. {"list": [{"bytes": "CAFEF00D"}]}
*    Maps' value is a JSON list of objects, one for each key-value pair in the map, with keys "k" and "v"
*          respectively with their values being the plutus datum encoded via this same schema
*          e.g. {"map": [
*              {"k": {"int": 2}, "v": {"int": 5}},
*              {"k": {"map": [{"k": {"list": [{"int": 1}]}, "v": {"bytes": "FF03"}}]}, "v": {"list": []}}
*          ]}
* From JSON:
* * null/true/false/floats NOT supported
* * the JSON must conform to a very specific schema
* To JSON:
* * all Plutus datums should be fully supported outside of the integer range limitations outlined above.
*/
DetailedSchema:1,"1":"DetailedSchema", });
/**
*/
export const AddressKind = Object.freeze({ Base:0,"0":"Base",Ptr:1,"1":"Ptr",Enterprise:2,"2":"Enterprise",Reward:3,"3":"Reward",Byron:4,"4":"Byron", });
/**
* Careful: this enum doesn't include the network ID part of the header
* ex: base address isn't 0b0000_0000 but instead 0b0000
* Use `header_matches_kind` if you don't want to implement the bitwise operators yourself
*/
export const AddressHeaderKind = Object.freeze({ BasePaymentKeyStakeKey:0,"0":"BasePaymentKeyStakeKey",BasePaymentScriptStakeKey:1,"1":"BasePaymentScriptStakeKey",BasePaymentKeyStakeScript:2,"2":"BasePaymentKeyStakeScript",BasePaymentScriptStakeScript:3,"3":"BasePaymentScriptStakeScript",PointerKey:4,"4":"PointerKey",PointerScript:5,"5":"PointerScript",EnterpriseKey:6,"6":"EnterpriseKey",EnterpriseScript:7,"7":"EnterpriseScript",Byron:8,"8":"Byron",RewardKey:14,"14":"RewardKey",RewardScript:15,"15":"RewardScript", });
/**
*/
export const Language = Object.freeze({ PlutusV1:0,"0":"PlutusV1",PlutusV2:1,"1":"PlutusV2",PlutusV3:2,"2":"PlutusV3", });
/**
*/
export const RedeemerTag = Object.freeze({ Spend:0,"0":"Spend",Mint:1,"1":"Mint",Cert:2,"2":"Cert",Reward:3,"3":"Reward", });
/**
*/
export const CertificateKind = Object.freeze({ StakeRegistration:0,"0":"StakeRegistration",StakeDeregistration:1,"1":"StakeDeregistration",StakeDelegation:2,"2":"StakeDelegation",PoolRegistration:3,"3":"PoolRegistration",PoolRetirement:4,"4":"PoolRetirement",RegCert:5,"5":"RegCert",UnregCert:6,"6":"UnregCert",VoteDelegCert:7,"7":"VoteDelegCert",StakeVoteDelegCert:8,"8":"StakeVoteDelegCert",StakeRegDelegCert:9,"9":"StakeRegDelegCert",VoteRegDelegCert:10,"10":"VoteRegDelegCert",StakeVoteRegDelegCert:11,"11":"StakeVoteRegDelegCert",AuthCommitteeHotCert:12,"12":"AuthCommitteeHotCert",ResignCommitteeColdCert:13,"13":"ResignCommitteeColdCert",RegDrepCert:14,"14":"RegDrepCert",UnregDrepCert:15,"15":"UnregDrepCert",UpdateDrepCert:16,"16":"UpdateDrepCert", });
/**
*/
export const CredentialKind = Object.freeze({ PubKey:0,"0":"PubKey",Script:1,"1":"Script", });
/**
*/
export const DRepKind = Object.freeze({ Key:0,"0":"Key",Script:1,"1":"Script",AlwaysAbstain:2,"2":"AlwaysAbstain",AlwaysNoConfidence:3,"3":"AlwaysNoConfidence", });
/**
*/
export const RelayKind = Object.freeze({ SingleHostAddr:0,"0":"SingleHostAddr",SingleHostName:1,"1":"SingleHostName",MultiHostName:2,"2":"MultiHostName", });
/**
*/
export const PlutusDataKind = Object.freeze({ ConstrPlutusData:0,"0":"ConstrPlutusData",Map:1,"1":"Map",List:2,"2":"List",Integer:3,"3":"Integer",Bytes:4,"4":"Bytes", });
/**
*/
export const ScriptKind = Object.freeze({ Native:0,"0":"Native",PlutusV1:1,"1":"PlutusV1",PlutusV2:2,"2":"PlutusV2",PlutusV3:3,"3":"PlutusV3", });
/**
*/
export const AuxiliaryDataKind = Object.freeze({ Shelley:0,"0":"Shelley",ShelleyMA:1,"1":"ShelleyMA",Conway:2,"2":"Conway", });
/**
*/
export const SpendingDataKind = Object.freeze({ SpendingDataPubKey:0,"0":"SpendingDataPubKey",SpendingDataScript:1,"1":"SpendingDataScript",SpendingDataRedeem:2,"2":"SpendingDataRedeem", });
/**
*/
export const StakeDistributionKind = Object.freeze({ SingleKey:0,"0":"SingleKey",BootstrapEra:1,"1":"BootstrapEra", });
/**
*/
export const DatumOptionKind = Object.freeze({ Hash:0,"0":"Hash",Datum:1,"1":"Datum", });
/**
*/
export const NativeScriptKind = Object.freeze({ ScriptPubkey:0,"0":"ScriptPubkey",ScriptAll:1,"1":"ScriptAll",ScriptAny:2,"2":"ScriptAny",ScriptNOfK:3,"3":"ScriptNOfK",ScriptInvalidBefore:4,"4":"ScriptInvalidBefore",ScriptInvalidHereafter:5,"5":"ScriptInvalidHereafter", });
/**
*/
export const TransactionOutputKind = Object.freeze({ AlonzoFormatTxOut:0,"0":"AlonzoFormatTxOut",ConwayFormatTxOut:1,"1":"ConwayFormatTxOut", });
/**
*/
export const TransactionMetadatumKind = Object.freeze({ Map:0,"0":"Map",List:1,"1":"List",Int:2,"2":"Int",Bytes:3,"3":"Bytes",Text:4,"4":"Text", });
/**
*/
export const NonceKind = Object.freeze({ Identity:0,"0":"Identity",Hash:1,"1":"Hash", });
/**
*/
export const GovActionKind = Object.freeze({ ParameterChangeAction:0,"0":"ParameterChangeAction",HardForkInitiationAction:1,"1":"HardForkInitiationAction",TreasuryWithdrawalsAction:2,"2":"TreasuryWithdrawalsAction",NoConfidence:3,"3":"NoConfidence",NewCommittee:4,"4":"NewCommittee",NewConstitution:5,"5":"NewConstitution",InfoAction:6,"6":"InfoAction", });
/**
*/
export const VoterKind = Object.freeze({ ConstitutionalCommitteeHotKeyHash:0,"0":"ConstitutionalCommitteeHotKeyHash",ConstitutionalCommitteeHotScriptHash:1,"1":"ConstitutionalCommitteeHotScriptHash",DRepKeyHash:2,"2":"DRepKeyHash",DRepScriptHash:3,"3":"DRepScriptHash",StakingPoolKeyHash:4,"4":"StakingPoolKeyHash", });
/**
* Which version of the CIP25 spec to use. See CIP25 for details.
* This will change how things are encoded but for the most part contains
* the same information.
*/
export const CIP25Version = Object.freeze({
/**
* Initial version of CIP25 with only string (utf8) asset names allowed.
*/
V1:0,"0":"V1",
/**
* Second version of CIP25. Supports any type of asset names.
*/
V2:1,"1":"V2", });
/**
*/
export const ChunkableStringKind = Object.freeze({ Single:0,"0":"Single",Chunked:1,"1":"Chunked", });
/**
*/
export const DelegationDistributionKind = Object.freeze({ Weighted:0,"0":"Weighted",Legacy:1,"1":"Legacy", });

const AddrAttributesFinalization = new FinalizationRegistry(ptr => wasm.__wbg_addrattributes_free(ptr));
/**
*/
export class AddrAttributes {

    static __wrap(ptr) {
        const obj = Object.create(AddrAttributes.prototype);
        obj.ptr = ptr;
        AddrAttributesFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AddrAttributesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_addrattributes_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.addrattributes_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {AddrAttributes}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.addrattributes_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AddrAttributes.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.addrattributes_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {AddrAttributes}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.addrattributes_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AddrAttributes.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {StakeDistribution} stake_distribution
    */
    set_stake_distribution(stake_distribution) {
        _assertClass(stake_distribution, StakeDistribution);
        wasm.addrattributes_set_stake_distribution(this.ptr, stake_distribution.ptr);
    }
    /**
    * @returns {StakeDistribution | undefined}
    */
    stake_distribution() {
        const ret = wasm.addrattributes_stake_distribution(this.ptr);
        return ret === 0 ? undefined : StakeDistribution.__wrap(ret);
    }
    /**
    * @param {HDAddressPayload} derivation_path
    */
    set_derivation_path(derivation_path) {
        _assertClass(derivation_path, HDAddressPayload);
        wasm.addrattributes_set_derivation_path(this.ptr, derivation_path.ptr);
    }
    /**
    * @returns {HDAddressPayload | undefined}
    */
    derivation_path() {
        const ret = wasm.addrattributes_derivation_path(this.ptr);
        return ret === 0 ? undefined : HDAddressPayload.__wrap(ret);
    }
    /**
    * @param {ProtocolMagic} protocol_magic
    */
    set_protocol_magic(protocol_magic) {
        _assertClass(protocol_magic, ProtocolMagic);
        wasm.addrattributes_set_protocol_magic(this.ptr, protocol_magic.ptr);
    }
    /**
    * @returns {ProtocolMagic | undefined}
    */
    protocol_magic() {
        const ret = wasm.addrattributes_protocol_magic(this.ptr);
        return ret === 0 ? undefined : ProtocolMagic.__wrap(ret);
    }
    /**
    * @returns {AddrAttributes}
    */
    static new() {
        const ret = wasm.addrattributes_new();
        return AddrAttributes.__wrap(ret);
    }
    /**
    * @param {HDAddressPayload | undefined} hdap
    * @param {ProtocolMagic | undefined} protocol_magic
    * @returns {AddrAttributes}
    */
    static new_bootstrap_era(hdap, protocol_magic) {
        let ptr0 = 0;
        if (!isLikeNone(hdap)) {
            _assertClass(hdap, HDAddressPayload);
            ptr0 = hdap.ptr;
            hdap.ptr = 0;
        }
        let ptr1 = 0;
        if (!isLikeNone(protocol_magic)) {
            _assertClass(protocol_magic, ProtocolMagic);
            ptr1 = protocol_magic.ptr;
            protocol_magic.ptr = 0;
        }
        const ret = wasm.addrattributes_new_bootstrap_era(ptr0, ptr1);
        return AddrAttributes.__wrap(ret);
    }
    /**
    * @param {Bip32PublicKey} pubk
    * @param {HDAddressPayload | undefined} hdap
    * @param {ProtocolMagic} protocol_magic
    * @returns {AddrAttributes}
    */
    static new_single_key(pubk, hdap, protocol_magic) {
        _assertClass(pubk, Bip32PublicKey);
        let ptr0 = 0;
        if (!isLikeNone(hdap)) {
            _assertClass(hdap, HDAddressPayload);
            ptr0 = hdap.ptr;
            hdap.ptr = 0;
        }
        _assertClass(protocol_magic, ProtocolMagic);
        var ptr1 = protocol_magic.ptr;
        protocol_magic.ptr = 0;
        const ret = wasm.addrattributes_new_single_key(pubk.ptr, ptr0, ptr1);
        return AddrAttributes.__wrap(ret);
    }
}

const AddressFinalization = new FinalizationRegistry(ptr => wasm.__wbg_address_free(ptr));
/**
*/
export class Address {

    static __wrap(ptr) {
        const obj = Object.create(Address.prototype);
        obj.ptr = ptr;
        AddressFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_address_free(ptr);
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.address_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.address_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Address}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.address_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Address.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * header has 4 bits addr type discrim then 4 bits network discrim.
    * Copied from shelley.cddl:
    *
    * base address
    * bits 7-6: 00
    * bit 5: stake cred is keyhash/scripthash
    * bit 4: payment cred is keyhash/scripthash
    * bits 3-0: network id
    *
    * pointer address
    * bits 7-5: 010
    * bit 4: payment cred is keyhash/scripthash
    * bits 3-0: network id
    *
    * enterprise address
    * bits 7-5: 010
    * bit 4: payment cred is keyhash/scripthash
    * bits 3-0: network id
    *
    * reward addresses:
    * bits 7-5: 111
    * bit 4: credential is keyhash/scripthash
    * bits 3-0: network id
    *
    * byron addresses:
    * bits 7-4: 1000
    * bits 3-0: unrelated data (recall: no network ID in Byron addresses)
    * @returns {number}
    */
    header() {
        const ret = wasm.address_header(this.ptr);
        return ret;
    }
    /**
    * @param {number} header
    * @param {number} kind
    * @returns {boolean}
    */
    static header_matches_kind(header, kind) {
        const ret = wasm.address_header_matches_kind(header, kind);
        return ret !== 0;
    }
    /**
    * @param {string | undefined} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            var ptr0 = isLikeNone(prefix) ? 0 : passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN;
            wasm.address_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @param {string} bech_str
    * @returns {Address}
    */
    static from_bech32(bech_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.address_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Address.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *     * Note: bech32-encoded Byron addresses will also pass validation here
    *
    * @param {string} bech_str
    * @returns {boolean}
    */
    static is_valid_bech32(bech_str) {
        const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.address_is_valid_bech32(ptr0, len0);
        return ret !== 0;
    }
    /**
    * @param {string} bech_str
    * @returns {boolean}
    */
    static is_valid(bech_str) {
        const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.address_is_valid(ptr0, len0);
        return ret !== 0;
    }
    /**
    * @returns {number}
    */
    network_id() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.address_network_id(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Note: by convention, the key inside reward addresses are considered payment credentials
    * @returns {Credential | undefined}
    */
    payment_cred() {
        const ret = wasm.address_payment_cred(this.ptr);
        return ret === 0 ? undefined : Credential.__wrap(ret);
    }
    /**
    * Note: by convention, the key inside reward addresses are NOT considered staking credentials
    * Note: None is returned pointer addresses as the chain history is required to resolve its associated cred
    * @returns {Credential | undefined}
    */
    staking_cred() {
        const ret = wasm.address_staking_cred(this.ptr);
        return ret === 0 ? undefined : Credential.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.address_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.address_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} data
    * @returns {Address}
    */
    static from_raw_bytes(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.address_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Address.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.address_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} hex
    * @returns {Address}
    */
    static from_hex(hex) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.address_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Address.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const AddressContentFinalization = new FinalizationRegistry(ptr => wasm.__wbg_addresscontent_free(ptr));
/**
*/
export class AddressContent {

    static __wrap(ptr) {
        const obj = Object.create(AddressContent.prototype);
        obj.ptr = ptr;
        AddressContentFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AddressContentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_addresscontent_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.addresscontent_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {AddressContent}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.addresscontent_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AddressContent.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.addresscontent_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {AddressContent}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.addresscontent_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AddressContent.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {AddressId}
    */
    address_id() {
        const ret = wasm.addresscontent_address_id(this.ptr);
        return AddressId.__wrap(ret);
    }
    /**
    * @returns {AddrAttributes}
    */
    addr_attributes() {
        const ret = wasm.addresscontent_addr_attributes(this.ptr);
        return AddrAttributes.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    addr_type() {
        const ret = wasm.addresscontent_addr_type(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {AddressId} address_id
    * @param {AddrAttributes} addr_attributes
    * @param {number} addr_type
    * @returns {AddressContent}
    */
    static new(address_id, addr_attributes, addr_type) {
        _assertClass(address_id, AddressId);
        _assertClass(addr_attributes, AddrAttributes);
        const ret = wasm.addresscontent_new(address_id.ptr, addr_attributes.ptr, addr_type);
        return AddressContent.__wrap(ret);
    }
    /**
    * @param {number} addr_type
    * @param {SpendingData} spending_data
    * @param {AddrAttributes} attributes
    * @returns {AddressContent}
    */
    static hash_and_create(addr_type, spending_data, attributes) {
        _assertClass(spending_data, SpendingData);
        _assertClass(attributes, AddrAttributes);
        const ret = wasm.addresscontent_hash_and_create(addr_type, spending_data.ptr, attributes.ptr);
        return AddressContent.__wrap(ret);
    }
    /**
    * @param {PublicKey} pubkey
    * @param {ProtocolMagic | undefined} protocol_magic
    * @returns {AddressContent}
    */
    static new_redeem(pubkey, protocol_magic) {
        _assertClass(pubkey, PublicKey);
        let ptr0 = 0;
        if (!isLikeNone(protocol_magic)) {
            _assertClass(protocol_magic, ProtocolMagic);
            ptr0 = protocol_magic.ptr;
            protocol_magic.ptr = 0;
        }
        const ret = wasm.addresscontent_new_redeem(pubkey.ptr, ptr0);
        return AddressContent.__wrap(ret);
    }
    /**
    * @param {Bip32PublicKey} xpub
    * @param {ProtocolMagic | undefined} protocol_magic
    * @returns {AddressContent}
    */
    static new_simple(xpub, protocol_magic) {
        _assertClass(xpub, Bip32PublicKey);
        let ptr0 = 0;
        if (!isLikeNone(protocol_magic)) {
            _assertClass(protocol_magic, ProtocolMagic);
            ptr0 = protocol_magic.ptr;
            protocol_magic.ptr = 0;
        }
        const ret = wasm.addresscontent_new_simple(xpub.ptr, ptr0);
        return AddressContent.__wrap(ret);
    }
    /**
    * Do we want to remove this or keep it for people who were using old Byron code?
    * @returns {ByronAddress}
    */
    to_address() {
        const ret = wasm.addresscontent_to_address(this.ptr);
        return ByronAddress.__wrap(ret);
    }
    /**
    * returns the byron protocol magic embedded in the address, or mainnet id if none is present
    * note: for bech32 addresses, you need to use network_id instead
    * @returns {ProtocolMagic}
    */
    byron_protocol_magic() {
        const ret = wasm.addresscontent_byron_protocol_magic(this.ptr);
        return ProtocolMagic.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    network_id() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.addresscontent_network_id(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Bip32PublicKey} key
    * @param {ProtocolMagic} protocol_magic
    * @returns {AddressContent}
    */
    static icarus_from_key(key, protocol_magic) {
        _assertClass(key, Bip32PublicKey);
        _assertClass(protocol_magic, ProtocolMagic);
        const ret = wasm.addresscontent_icarus_from_key(key.ptr, protocol_magic.ptr);
        return AddressContent.__wrap(ret);
    }
    /**
    * Check if the Addr can be reconstructed with a specific xpub
    * @param {Bip32PublicKey} xpub
    * @returns {boolean}
    */
    identical_with_pubkey(xpub) {
        _assertClass(xpub, Bip32PublicKey);
        const ret = wasm.addresscontent_identical_with_pubkey(this.ptr, xpub.ptr);
        return ret !== 0;
    }
}

const AddressIdFinalization = new FinalizationRegistry(ptr => wasm.__wbg_addressid_free(ptr));
/**
*/
export class AddressId {

    static __wrap(ptr) {
        const obj = Object.create(AddressId.prototype);
        obj.ptr = ptr;
        AddressIdFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AddressIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_addressid_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.addressid_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.addressid_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.addressid_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {AddressId}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.addressid_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AddressId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {AddressId}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.addressid_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AddressId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {AddressId}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.addressid_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AddressId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {number} addr_type
    * @param {SpendingData} spending_data
    * @param {AddrAttributes} attrs
    * @returns {AddressId}
    */
    static new(addr_type, spending_data, attrs) {
        _assertClass(spending_data, SpendingData);
        _assertClass(attrs, AddrAttributes);
        const ret = wasm.addressid_new(addr_type, spending_data.ptr, attrs.ptr);
        return AddressId.__wrap(ret);
    }
}

const AlonzoFormatTxOutFinalization = new FinalizationRegistry(ptr => wasm.__wbg_alonzoformattxout_free(ptr));
/**
*/
export class AlonzoFormatTxOut {

    static __wrap(ptr) {
        const obj = Object.create(AlonzoFormatTxOut.prototype);
        obj.ptr = ptr;
        AlonzoFormatTxOutFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AlonzoFormatTxOutFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_alonzoformattxout_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.alonzoformattxout_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {AlonzoFormatTxOut}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.alonzoformattxout_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AlonzoFormatTxOut.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.alonzoformattxout_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {AlonzoFormatTxOut}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.alonzoformattxout_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AlonzoFormatTxOut.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.alonzoformattxout_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.alonzoformattxout_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {AlonzoFormatTxOut}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.alonzoformattxout_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AlonzoFormatTxOut.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Address}
    */
    address() {
        const ret = wasm.alonzoformattxout_address(this.ptr);
        return Address.__wrap(ret);
    }
    /**
    * @returns {Value}
    */
    amount() {
        const ret = wasm.alonzoformattxout_amount(this.ptr);
        return Value.__wrap(ret);
    }
    /**
    * @param {DatumHash} datum_hash
    */
    set_datum_hash(datum_hash) {
        _assertClass(datum_hash, DatumHash);
        wasm.alonzoformattxout_set_datum_hash(this.ptr, datum_hash.ptr);
    }
    /**
    * @returns {DatumHash | undefined}
    */
    datum_hash() {
        const ret = wasm.alonzoformattxout_datum_hash(this.ptr);
        return ret === 0 ? undefined : DatumHash.__wrap(ret);
    }
    /**
    * @param {Address} address
    * @param {Value} amount
    * @returns {AlonzoFormatTxOut}
    */
    static new(address, amount) {
        _assertClass(address, Address);
        _assertClass(amount, Value);
        const ret = wasm.alonzoformattxout_new(address.ptr, amount.ptr);
        return AlonzoFormatTxOut.__wrap(ret);
    }
}

const AnchorFinalization = new FinalizationRegistry(ptr => wasm.__wbg_anchor_free(ptr));
/**
*/
export class Anchor {

    static __wrap(ptr) {
        const obj = Object.create(Anchor.prototype);
        obj.ptr = ptr;
        AnchorFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AnchorFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_anchor_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.anchor_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Anchor}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.anchor_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Anchor.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.anchor_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Anchor}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.anchor_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Anchor.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.anchor_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.anchor_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Anchor}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.anchor_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Anchor.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Url}
    */
    anchor_url() {
        const ret = wasm.anchor_anchor_url(this.ptr);
        return Url.__wrap(ret);
    }
    /**
    * @returns {AnchorDocHash}
    */
    anchor_doc_hash() {
        const ret = wasm.anchor_anchor_doc_hash(this.ptr);
        return AnchorDocHash.__wrap(ret);
    }
    /**
    * @param {Url} anchor_url
    * @param {AnchorDocHash} anchor_doc_hash
    * @returns {Anchor}
    */
    static new(anchor_url, anchor_doc_hash) {
        _assertClass(anchor_url, Url);
        _assertClass(anchor_doc_hash, AnchorDocHash);
        const ret = wasm.anchor_new(anchor_url.ptr, anchor_doc_hash.ptr);
        return Anchor.__wrap(ret);
    }
}

const AnchorDocHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_anchordochash_free(ptr));
/**
*/
export class AnchorDocHash {

    static __wrap(ptr) {
        const obj = Object.create(AnchorDocHash.prototype);
        obj.ptr = ptr;
        AnchorDocHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AnchorDocHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_anchordochash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.anchordochash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.anchordochash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.anchordochash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {AnchorDocHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.anchordochash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AnchorDocHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {AnchorDocHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.anchordochash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AnchorDocHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {AnchorDocHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.anchordochash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AnchorDocHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const AssetNameFinalization = new FinalizationRegistry(ptr => wasm.__wbg_assetname_free(ptr));
/**
*/
export class AssetName {

    static __wrap(ptr) {
        const obj = Object.create(AssetName.prototype);
        obj.ptr = ptr;
        AssetNameFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AssetNameFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_assetname_free(ptr);
    }
    /**
    *
    *     * Create an AssetName from raw bytes. 64 byte maximum.
    *
    * @param {Uint8Array} bytes
    * @returns {AssetName}
    */
    static from_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.assetname_from_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AssetName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *     * Create an AssetName from utf8 string. 64 byte (not char!) maximum.
    *
    * @param {string} utf8_str
    * @returns {AssetName}
    */
    static from_str(utf8_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(utf8_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.assetname_from_str(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AssetName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *     * AssetName as a utf8 string if it's possible. Will error if the asset is not utf8
    *
    * @returns {string}
    */
    to_str() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.assetname_to_str(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.assetname_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {AssetName}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.assetname_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AssetName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.assetname_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {AssetName}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.assetname_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AssetName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.assetname_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.assetname_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {AssetName}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.assetname_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AssetName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.assetname_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const AssetNameListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_assetnamelist_free(ptr));
/**
*/
export class AssetNameList {

    static __wrap(ptr) {
        const obj = Object.create(AssetNameList.prototype);
        obj.ptr = ptr;
        AssetNameListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AssetNameListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_assetnamelist_free(ptr);
    }
    /**
    * @returns {AssetNameList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return AssetNameList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.assetnamelist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {AssetName}
    */
    get(index) {
        const ret = wasm.assetnamelist_get(this.ptr, index);
        return AssetName.__wrap(ret);
    }
    /**
    * @param {AssetName} elem
    */
    add(elem) {
        _assertClass(elem, AssetName);
        wasm.assetnamelist_add(this.ptr, elem.ptr);
    }
}

const AuthCommitteeHotCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_authcommitteehotcert_free(ptr));
/**
*/
export class AuthCommitteeHotCert {

    static __wrap(ptr) {
        const obj = Object.create(AuthCommitteeHotCert.prototype);
        obj.ptr = ptr;
        AuthCommitteeHotCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AuthCommitteeHotCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_authcommitteehotcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.authcommitteehotcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {AuthCommitteeHotCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.authcommitteehotcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AuthCommitteeHotCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.authcommitteehotcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {AuthCommitteeHotCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.authcommitteehotcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AuthCommitteeHotCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.authcommitteehotcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.authcommitteehotcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {AuthCommitteeHotCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.authcommitteehotcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AuthCommitteeHotCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    committee_cold_credential() {
        const ret = wasm.authcommitteehotcert_committee_cold_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {Credential}
    */
    committee_hot_credential() {
        const ret = wasm.authcommitteehotcert_committee_hot_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @param {Credential} committee_cold_credential
    * @param {Credential} committee_hot_credential
    * @returns {AuthCommitteeHotCert}
    */
    static new(committee_cold_credential, committee_hot_credential) {
        _assertClass(committee_cold_credential, Credential);
        _assertClass(committee_hot_credential, Credential);
        const ret = wasm.authcommitteehotcert_new(committee_cold_credential.ptr, committee_hot_credential.ptr);
        return AuthCommitteeHotCert.__wrap(ret);
    }
}

const AuxiliaryDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_auxiliarydata_free(ptr));
/**
*/
export class AuxiliaryData {

    static __wrap(ptr) {
        const obj = Object.create(AuxiliaryData.prototype);
        obj.ptr = ptr;
        AuxiliaryDataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AuxiliaryDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_auxiliarydata_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.auxiliarydata_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {AuxiliaryData}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.auxiliarydata_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AuxiliaryData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.auxiliarydata_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {AuxiliaryData}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.auxiliarydata_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AuxiliaryData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.auxiliarydata_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.auxiliarydata_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {AuxiliaryData}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.auxiliarydata_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AuxiliaryData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Metadata} shelley
    * @returns {AuxiliaryData}
    */
    static new_shelley(shelley) {
        _assertClass(shelley, Metadata);
        const ret = wasm.auxiliarydata_new_shelley(shelley.ptr);
        return AuxiliaryData.__wrap(ret);
    }
    /**
    * @param {ShelleyMaFormatAuxData} shelley_m_a
    * @returns {AuxiliaryData}
    */
    static new_shelley_m_a(shelley_m_a) {
        _assertClass(shelley_m_a, ShelleyMaFormatAuxData);
        const ret = wasm.auxiliarydata_new_shelley_m_a(shelley_m_a.ptr);
        return AuxiliaryData.__wrap(ret);
    }
    /**
    * @param {ConwayFormatAuxData} conway
    * @returns {AuxiliaryData}
    */
    static new_conway(conway) {
        _assertClass(conway, ConwayFormatAuxData);
        const ret = wasm.auxiliarydata_new_conway(conway.ptr);
        return AuxiliaryData.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.auxiliarydata_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {Metadata | undefined}
    */
    as_shelley() {
        const ret = wasm.auxiliarydata_as_shelley(this.ptr);
        return ret === 0 ? undefined : Metadata.__wrap(ret);
    }
    /**
    * @returns {ShelleyMaFormatAuxData | undefined}
    */
    as_shelley_m_a() {
        const ret = wasm.auxiliarydata_as_shelley_m_a(this.ptr);
        return ret === 0 ? undefined : ShelleyMaFormatAuxData.__wrap(ret);
    }
    /**
    * @returns {ConwayFormatAuxData | undefined}
    */
    as_conway() {
        const ret = wasm.auxiliarydata_as_conway(this.ptr);
        return ret === 0 ? undefined : ConwayFormatAuxData.__wrap(ret);
    }
    /**
    * @returns {AuxiliaryData}
    */
    static new() {
        const ret = wasm.auxiliarydata_new();
        return AuxiliaryData.__wrap(ret);
    }
    /**
    * @returns {Metadata | undefined}
    */
    metadata() {
        const ret = wasm.auxiliarydata_metadata(this.ptr);
        return ret === 0 ? undefined : Metadata.__wrap(ret);
    }
    /**
    * @returns {NativeScriptList | undefined}
    */
    native_scripts() {
        const ret = wasm.auxiliarydata_native_scripts(this.ptr);
        return ret === 0 ? undefined : NativeScriptList.__wrap(ret);
    }
    /**
    * @returns {PlutusV1ScriptList | undefined}
    */
    plutus_v1_scripts() {
        const ret = wasm.auxiliarydata_plutus_v1_scripts(this.ptr);
        return ret === 0 ? undefined : PlutusV1ScriptList.__wrap(ret);
    }
    /**
    * @returns {PlutusV2ScriptList | undefined}
    */
    plutus_v2_scripts() {
        const ret = wasm.auxiliarydata_plutus_v2_scripts(this.ptr);
        return ret === 0 ? undefined : PlutusV2ScriptList.__wrap(ret);
    }
    /**
    * Warning: overwrites any conflicting metadatum labels present
    * @param {Metadata} other
    */
    add_metadata(other) {
        _assertClass(other, Metadata);
        wasm.auxiliarydata_add_metadata(this.ptr, other.ptr);
    }
    /**
    * Warning: does not check for duplicates and may migrate eras
    * @param {NativeScriptList} scripts
    */
    add_native_scripts(scripts) {
        _assertClass(scripts, NativeScriptList);
        wasm.auxiliarydata_add_native_scripts(this.ptr, scripts.ptr);
    }
    /**
    * Warning: does not check for duplicates and may migrate eras
    * @param {PlutusV1ScriptList} scripts
    */
    add_plutus_v1_scripts(scripts) {
        _assertClass(scripts, PlutusV1ScriptList);
        wasm.auxiliarydata_add_plutus_v1_scripts(this.ptr, scripts.ptr);
    }
    /**
    * Warning: does not check for duplicates and may migrate eras
    * @param {PlutusV2ScriptList} scripts
    */
    add_plutus_v2_scripts(scripts) {
        _assertClass(scripts, PlutusV2ScriptList);
        wasm.auxiliarydata_add_plutus_v2_scripts(this.ptr, scripts.ptr);
    }
    /**
    * Adds everything present in other to self
    * May change the era the aux data is in if necessary
    * Warning: overwrites any metadatum labels present
    * also does not check for duplicates in scripts
    * @param {AuxiliaryData} other
    */
    add(other) {
        _assertClass(other, AuxiliaryData);
        wasm.auxiliarydata_add(this.ptr, other.ptr);
    }
}

const AuxiliaryDataHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_auxiliarydatahash_free(ptr));
/**
*/
export class AuxiliaryDataHash {

    static __wrap(ptr) {
        const obj = Object.create(AuxiliaryDataHash.prototype);
        obj.ptr = ptr;
        AuxiliaryDataHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AuxiliaryDataHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_auxiliarydatahash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.auxiliarydatahash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.auxiliarydatahash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.auxiliarydatahash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {AuxiliaryDataHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.auxiliarydatahash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AuxiliaryDataHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {AuxiliaryDataHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.auxiliarydatahash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AuxiliaryDataHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {AuxiliaryDataHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.auxiliarydatahash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AuxiliaryDataHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const BaseAddressFinalization = new FinalizationRegistry(ptr => wasm.__wbg_baseaddress_free(ptr));
/**
*/
export class BaseAddress {

    static __wrap(ptr) {
        const obj = Object.create(BaseAddress.prototype);
        obj.ptr = ptr;
        BaseAddressFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        BaseAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_baseaddress_free(ptr);
    }
    /**
    * @param {number} network
    * @param {Credential} payment
    * @param {Credential} stake
    * @returns {BaseAddress}
    */
    static new(network, payment, stake) {
        _assertClass(payment, Credential);
        _assertClass(stake, Credential);
        const ret = wasm.baseaddress_new(network, payment.ptr, stake.ptr);
        return BaseAddress.__wrap(ret);
    }
    /**
    * @returns {Address}
    */
    to_address() {
        const ret = wasm.baseaddress_to_address(this.ptr);
        return Address.__wrap(ret);
    }
    /**
    * @param {Address} address
    * @returns {BaseAddress | undefined}
    */
    static from_address(address) {
        _assertClass(address, Address);
        const ret = wasm.baseaddress_from_address(address.ptr);
        return ret === 0 ? undefined : BaseAddress.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    network_id() {
        const ret = wasm.baseaddress_network_id(this.ptr);
        return ret;
    }
    /**
    * @returns {Credential}
    */
    payment() {
        const ret = wasm.baseaddress_payment(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {Credential}
    */
    stake() {
        const ret = wasm.baseaddress_stake(this.ptr);
        return Credential.__wrap(ret);
    }
}

const BigIntegerFinalization = new FinalizationRegistry(ptr => wasm.__wbg_biginteger_free(ptr));
/**
*/
export class BigInteger {

    static __wrap(ptr) {
        const obj = Object.create(BigInteger.prototype);
        obj.ptr = ptr;
        BigIntegerFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        BigIntegerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_biginteger_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.biginteger_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {BigInteger}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.biginteger_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BigInteger.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.biginteger_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {BigInteger}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.biginteger_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BigInteger.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.biginteger_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.biginteger_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {BigInteger}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.biginteger_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BigInteger.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Int} x
    * @returns {BigInteger}
    */
    static from_int(x) {
        _assertClass(x, Int);
        const ret = wasm.biginteger_from_int(x.ptr);
        return BigInteger.__wrap(ret);
    }
    /**
    * @param {string} s
    * @returns {BigInteger}
    */
    static from_str(s) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.biginteger_from_str(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BigInteger.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_str() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.biginteger_to_str(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Converts to a u64
    * Returns None if the number was negative or too big for a u64
    * @returns {bigint | undefined}
    */
    as_u64() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.biginteger_as_u64(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Converts to an Int
    * Returns None when the number is too big for an Int (outside +/- 64-bit unsigned)
    * Retains encoding info if the original was encoded as an Int
    * @returns {Int | undefined}
    */
    as_int() {
        const ret = wasm.biginteger_as_int(this.ptr);
        return ret === 0 ? undefined : Int.__wrap(ret);
    }
}

const Bip32PrivateKeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_bip32privatekey_free(ptr));
/**
*/
export class Bip32PrivateKey {

    static __wrap(ptr) {
        const obj = Object.create(Bip32PrivateKey.prototype);
        obj.ptr = ptr;
        Bip32PrivateKeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Bip32PrivateKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bip32privatekey_free(ptr);
    }
    /**
    * derive this private key with the given index.
    *
    * # Security considerations
    *
    * * hard derivation index cannot be soft derived with the public key
    *
    * # Hard derivation vs Soft derivation
    *
    * If you pass an index below 0x80000000 then it is a soft derivation.
    * The advantage of soft derivation is that it is possible to derive the
    * public key too. I.e. derivation the private key with a soft derivation
    * index and then retrieving the associated public key is equivalent to
    * deriving the public key associated to the parent private key.
    *
    * Hard derivation index does not allow public key derivation.
    *
    * This is why deriving the private key should not fail while deriving
    * the public key may fail (if the derivation index is invalid).
    * @param {number} index
    * @returns {Bip32PrivateKey}
    */
    derive(index) {
        const ret = wasm.bip32privatekey_derive(this.ptr, index);
        return Bip32PrivateKey.__wrap(ret);
    }
    /**
    * 128-byte xprv a key format in Cardano that some software still uses or requires
    * the traditional 96-byte xprv is simply encoded as
    * prv | chaincode
    * however, because some software may not know how to compute a public key from a private key,
    * the 128-byte inlines the public key in the following format
    * prv | pub | chaincode
    * so be careful if you see the term "xprv" as it could refer to either one
    * our library does not require the pub (instead we compute the pub key when needed)
    * @param {Uint8Array} bytes
    * @returns {Bip32PrivateKey}
    */
    static from_128_xprv(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.bip32privatekey_from_128_xprv(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Bip32PrivateKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * see from_128_xprv
    * @returns {Uint8Array}
    */
    to_128_xprv() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bip32privatekey_to_128_xprv(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Bip32PrivateKey}
    */
    static generate_ed25519_bip32() {
        const ret = wasm.bip32privatekey_generate_ed25519_bip32();
        return Bip32PrivateKey.__wrap(ret);
    }
    /**
    * @returns {PrivateKey}
    */
    to_raw_key() {
        const ret = wasm.bip32privatekey_to_raw_key(this.ptr);
        return PrivateKey.__wrap(ret);
    }
    /**
    * @returns {Bip32PublicKey}
    */
    to_public() {
        const ret = wasm.bip32privatekey_to_public(this.ptr);
        return Bip32PublicKey.__wrap(ret);
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {Bip32PrivateKey}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.bip32privatekey_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Bip32PrivateKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bip32privatekey_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {Bip32PrivateKey}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.bip32privatekey_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Bip32PrivateKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_bech32() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bip32privatekey_to_bech32(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {Uint8Array} entropy
    * @param {Uint8Array} password
    * @returns {Bip32PrivateKey}
    */
    static from_bip39_entropy(entropy, password) {
        const ptr0 = passArray8ToWasm0(entropy, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(password, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.bip32privatekey_from_bip39_entropy(ptr0, len0, ptr1, len1);
        return Bip32PrivateKey.__wrap(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    chaincode() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bip32privatekey_chaincode(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const Bip32PublicKeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_bip32publickey_free(ptr));
/**
*/
export class Bip32PublicKey {

    static __wrap(ptr) {
        const obj = Object.create(Bip32PublicKey.prototype);
        obj.ptr = ptr;
        Bip32PublicKeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Bip32PublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bip32publickey_free(ptr);
    }
    /**
    * derive this public key with the given index.
    *
    * # Errors
    *
    * If the index is not a soft derivation index (< 0x80000000) then
    * calling this method will fail.
    *
    * # Security considerations
    *
    * * hard derivation index cannot be soft derived with the public key
    *
    * # Hard derivation vs Soft derivation
    *
    * If you pass an index below 0x80000000 then it is a soft derivation.
    * The advantage of soft derivation is that it is possible to derive the
    * public key too. I.e. derivation the private key with a soft derivation
    * index and then retrieving the associated public key is equivalent to
    * deriving the public key associated to the parent private key.
    *
    * Hard derivation index does not allow public key derivation.
    *
    * This is why deriving the private key should not fail while deriving
    * the public key may fail (if the derivation index is invalid).
    * @param {number} index
    * @returns {Bip32PublicKey}
    */
    derive(index) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bip32publickey_derive(retptr, this.ptr, index);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Bip32PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {PublicKey}
    */
    to_raw_key() {
        const ret = wasm.bip32publickey_to_raw_key(this.ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {Bip32PublicKey}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.bip32publickey_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Bip32PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bip32publickey_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {Bip32PublicKey}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.bip32publickey_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Bip32PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_bech32() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bip32publickey_to_bech32(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    chaincode() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bip32publickey_chaincode(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const BlockFinalization = new FinalizationRegistry(ptr => wasm.__wbg_block_free(ptr));
/**
*/
export class Block {

    static __wrap(ptr) {
        const obj = Object.create(Block.prototype);
        obj.ptr = ptr;
        BlockFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        BlockFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_block_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.block_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Block}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.block_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Block.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.block_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Block}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.block_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Block.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.block_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.block_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Block}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.block_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Block.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Header}
    */
    header() {
        const ret = wasm.block_header(this.ptr);
        return Header.__wrap(ret);
    }
    /**
    * @returns {TransactionBodyList}
    */
    transaction_bodies() {
        const ret = wasm.block_transaction_bodies(this.ptr);
        return TransactionBodyList.__wrap(ret);
    }
    /**
    * @returns {TransactionWitnessSetList}
    */
    transaction_witness_sets() {
        const ret = wasm.block_transaction_witness_sets(this.ptr);
        return TransactionWitnessSetList.__wrap(ret);
    }
    /**
    * @returns {MapTransactionIndexToAuxiliaryData}
    */
    auxiliary_data_set() {
        const ret = wasm.block_auxiliary_data_set(this.ptr);
        return MapTransactionIndexToAuxiliaryData.__wrap(ret);
    }
    /**
    * @returns {Uint16Array}
    */
    invalid_transactions() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.block_invalid_transactions(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU16FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 2);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Header} header
    * @param {TransactionBodyList} transaction_bodies
    * @param {TransactionWitnessSetList} transaction_witness_sets
    * @param {MapTransactionIndexToAuxiliaryData} auxiliary_data_set
    * @param {Uint16Array} invalid_transactions
    * @returns {Block}
    */
    static new(header, transaction_bodies, transaction_witness_sets, auxiliary_data_set, invalid_transactions) {
        _assertClass(header, Header);
        _assertClass(transaction_bodies, TransactionBodyList);
        _assertClass(transaction_witness_sets, TransactionWitnessSetList);
        _assertClass(auxiliary_data_set, MapTransactionIndexToAuxiliaryData);
        const ptr0 = passArray16ToWasm0(invalid_transactions, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.block_new(header.ptr, transaction_bodies.ptr, transaction_witness_sets.ptr, auxiliary_data_set.ptr, ptr0, len0);
        return Block.__wrap(ret);
    }
}

const BlockBodyHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_blockbodyhash_free(ptr));
/**
*/
export class BlockBodyHash {

    static __wrap(ptr) {
        const obj = Object.create(BlockBodyHash.prototype);
        obj.ptr = ptr;
        BlockBodyHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        BlockBodyHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_blockbodyhash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.blockbodyhash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.blockbodyhash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.blockbodyhash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {BlockBodyHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.blockbodyhash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BlockBodyHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {BlockBodyHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.blockbodyhash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BlockBodyHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {BlockBodyHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.blockbodyhash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BlockBodyHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const BlockHeaderHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_blockheaderhash_free(ptr));
/**
*/
export class BlockHeaderHash {

    static __wrap(ptr) {
        const obj = Object.create(BlockHeaderHash.prototype);
        obj.ptr = ptr;
        BlockHeaderHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        BlockHeaderHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_blockheaderhash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.blockheaderhash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.blockheaderhash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.blockheaderhash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {BlockHeaderHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.blockheaderhash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BlockHeaderHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {BlockHeaderHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.blockheaderhash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BlockHeaderHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {BlockHeaderHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.blockheaderhash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BlockHeaderHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const BootstrapWitnessFinalization = new FinalizationRegistry(ptr => wasm.__wbg_bootstrapwitness_free(ptr));
/**
*/
export class BootstrapWitness {

    static __wrap(ptr) {
        const obj = Object.create(BootstrapWitness.prototype);
        obj.ptr = ptr;
        BootstrapWitnessFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        BootstrapWitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bootstrapwitness_free(ptr);
    }
    /**
    * @returns {AddressContent}
    */
    to_address() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bootstrapwitness_to_address(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AddressContent.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bootstrapwitness_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {BootstrapWitness}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.bootstrapwitness_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BootstrapWitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bootstrapwitness_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {BootstrapWitness}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.bootstrapwitness_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BootstrapWitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bootstrapwitness_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bootstrapwitness_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {BootstrapWitness}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.bootstrapwitness_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BootstrapWitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {PublicKey}
    */
    public_key() {
        const ret = wasm.bootstrapwitness_public_key(this.ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {Ed25519Signature}
    */
    signature() {
        const ret = wasm.bootstrapwitness_signature(this.ptr);
        return Ed25519Signature.__wrap(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    chain_code() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bootstrapwitness_chain_code(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {AddrAttributes}
    */
    attributes() {
        const ret = wasm.bootstrapwitness_attributes(this.ptr);
        return AddrAttributes.__wrap(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {Ed25519Signature} signature
    * @param {Uint8Array} chain_code
    * @param {AddrAttributes} attributes
    * @returns {BootstrapWitness}
    */
    static new(public_key, signature, chain_code, attributes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(public_key, PublicKey);
            _assertClass(signature, Ed25519Signature);
            const ptr0 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(attributes, AddrAttributes);
            wasm.bootstrapwitness_new(retptr, public_key.ptr, signature.ptr, ptr0, len0, attributes.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return BootstrapWitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const BootstrapWitnessListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_bootstrapwitnesslist_free(ptr));
/**
*/
export class BootstrapWitnessList {

    static __wrap(ptr) {
        const obj = Object.create(BootstrapWitnessList.prototype);
        obj.ptr = ptr;
        BootstrapWitnessListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        BootstrapWitnessListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bootstrapwitnesslist_free(ptr);
    }
    /**
    * @returns {BootstrapWitnessList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return BootstrapWitnessList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.bootstrapwitnesslist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {BootstrapWitness}
    */
    get(index) {
        const ret = wasm.bootstrapwitnesslist_get(this.ptr, index);
        return BootstrapWitness.__wrap(ret);
    }
    /**
    * @param {BootstrapWitness} elem
    */
    add(elem) {
        _assertClass(elem, BootstrapWitness);
        wasm.bootstrapwitnesslist_add(this.ptr, elem.ptr);
    }
}

const ByronAddressFinalization = new FinalizationRegistry(ptr => wasm.__wbg_byronaddress_free(ptr));
/**
*/
export class ByronAddress {

    static __wrap(ptr) {
        const obj = Object.create(ByronAddress.prototype);
        obj.ptr = ptr;
        ByronAddressFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ByronAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_byronaddress_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.byronaddress_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ByronAddress}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.byronaddress_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ByronAddress.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.byronaddress_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ByronAddress}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.byronaddress_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ByronAddress.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {AddressContent}
    */
    content() {
        const ret = wasm.byronaddress_content(this.ptr);
        return AddressContent.__wrap(ret);
    }
    /**
    * @returns {Crc32}
    */
    crc() {
        const ret = wasm.byronaddress_crc(this.ptr);
        return Crc32.__wrap(ret);
    }
    /**
    * @param {AddressContent} content
    * @param {Crc32} crc
    * @returns {ByronAddress}
    */
    static new(content, crc) {
        _assertClass(content, AddressContent);
        _assertClass(crc, Crc32);
        const ret = wasm.byronaddress_new(content.ptr, crc.ptr);
        return ByronAddress.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    to_base58() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.byronaddress_to_base58(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} s
    * @returns {ByronAddress}
    */
    static from_base58(s) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.byronaddress_from_base58(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ByronAddress.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} s
    * @returns {boolean}
    */
    static is_valid(s) {
        const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.byronaddress_is_valid(ptr0, len0);
        return ret !== 0;
    }
    /**
    * @returns {Address}
    */
    to_address() {
        const ret = wasm.byronaddress_to_address(this.ptr);
        return Address.__wrap(ret);
    }
    /**
    * @param {Address} addr
    * @returns {ByronAddress | undefined}
    */
    static from_address(addr) {
        _assertClass(addr, Address);
        const ret = wasm.byronaddress_from_address(addr.ptr);
        return ret === 0 ? undefined : ByronAddress.__wrap(ret);
    }
    /**
    * @param {AddressContent} address_content
    * @returns {ByronAddress}
    */
    static from_address_content(address_content) {
        _assertClass(address_content, AddressContent);
        const ret = wasm.byronaddress_from_address_content(address_content.ptr);
        return ByronAddress.__wrap(ret);
    }
}

const ByronScriptFinalization = new FinalizationRegistry(ptr => wasm.__wbg_byronscript_free(ptr));
/**
*/
export class ByronScript {

    static __wrap(ptr) {
        const obj = Object.create(ByronScript.prototype);
        obj.ptr = ptr;
        ByronScriptFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ByronScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_byronscript_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.byronscript_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.byronscript_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.byronscript_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {ByronScript}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.byronscript_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ByronScript.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {ByronScript}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.byronscript_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ByronScript.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {ByronScript}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.byronscript_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ByronScript.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const ByronTxOutFinalization = new FinalizationRegistry(ptr => wasm.__wbg_byrontxout_free(ptr));
/**
*/
export class ByronTxOut {

    static __wrap(ptr) {
        const obj = Object.create(ByronTxOut.prototype);
        obj.ptr = ptr;
        ByronTxOutFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ByronTxOutFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_byrontxout_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.byrontxout_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ByronTxOut}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.byrontxout_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ByronTxOut.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.byrontxout_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ByronTxOut}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.byrontxout_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ByronTxOut.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {ByronAddress}
    */
    address() {
        const ret = wasm.byrontxout_address(this.ptr);
        return ByronAddress.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    amount() {
        const ret = wasm.byrontxout_amount(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {ByronAddress} address
    * @param {bigint} amount
    * @returns {ByronTxOut}
    */
    static new(address, amount) {
        _assertClass(address, ByronAddress);
        const ret = wasm.byrontxout_new(address.ptr, amount);
        return ByronTxOut.__wrap(ret);
    }
}

const CIP25ChunkableStringFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip25chunkablestring_free(ptr));
/**
* A String that may or may not be chunked into 64-byte chunks to be able
* to conform to Cardano TX Metadata limitations.
* Most users should simply use CIP25ChunkableString::from_string() and CIP25ChunkableString::to_string()
* and avoid the explicit single/chunk interface:
* ```javascript
* let chunkableString = CIP25.CIP25ChunkableString.from_string("this can be any length and will automatically be chunked if needed");
* ```
*/
export class CIP25ChunkableString {

    static __wrap(ptr) {
        const obj = Object.create(CIP25ChunkableString.prototype);
        obj.ptr = ptr;
        CIP25ChunkableStringFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP25ChunkableStringFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25chunkablestring_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25chunkablestring_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP25ChunkableString}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25chunkablestring_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25ChunkableString.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25chunkablestring_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP25ChunkableString}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25chunkablestring_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25ChunkableString.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25chunkablestring_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25chunkablestring_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP25ChunkableString}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25chunkablestring_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25ChunkableString.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {CIP25String64} single
    * @returns {CIP25ChunkableString}
    */
    static new_single(single) {
        _assertClass(single, CIP25String64);
        const ret = wasm.cip25chunkablestring_new_single(single.ptr);
        return CIP25ChunkableString.__wrap(ret);
    }
    /**
    * @param {CIP25String64List} chunked
    * @returns {CIP25ChunkableString}
    */
    static new_chunked(chunked) {
        _assertClass(chunked, CIP25String64List);
        const ret = wasm.cip25chunkablestring_new_chunked(chunked.ptr);
        return CIP25ChunkableString.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.cip25chunkablestring_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {CIP25String64 | undefined}
    */
    as_single() {
        const ret = wasm.cip25chunkablestring_as_single(this.ptr);
        return ret === 0 ? undefined : CIP25String64.__wrap(ret);
    }
    /**
    * @returns {CIP25String64List | undefined}
    */
    as_chunked() {
        const ret = wasm.cip25chunkablestring_as_chunked(this.ptr);
        return ret === 0 ? undefined : CIP25String64List.__wrap(ret);
    }
    /**
    * @param {string} str
    * @returns {CIP25ChunkableString}
    */
    static from_string(str) {
        const ptr0 = passStringToWasm0(str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25chunkablestring_from_string(ptr0, len0);
        return CIP25ChunkableString.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    to_string() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25chunkablestring_to_string(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}

const CIP25FilesDetailsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip25filesdetails_free(ptr));
/**
*/
export class CIP25FilesDetails {

    static __wrap(ptr) {
        const obj = Object.create(CIP25FilesDetails.prototype);
        obj.ptr = ptr;
        CIP25FilesDetailsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP25FilesDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25filesdetails_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25filesdetails_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP25FilesDetails}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25filesdetails_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25FilesDetails.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25filesdetails_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP25FilesDetails}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25filesdetails_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25FilesDetails.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25filesdetails_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25filesdetails_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP25FilesDetails}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25filesdetails_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25FilesDetails.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {CIP25String64}
    */
    name() {
        const ret = wasm.cip25filesdetails_name(this.ptr);
        return CIP25String64.__wrap(ret);
    }
    /**
    * @returns {CIP25String64}
    */
    media_type() {
        const ret = wasm.cip25filesdetails_media_type(this.ptr);
        return CIP25String64.__wrap(ret);
    }
    /**
    * @returns {CIP25ChunkableString}
    */
    src() {
        const ret = wasm.cip25filesdetails_src(this.ptr);
        return CIP25ChunkableString.__wrap(ret);
    }
    /**
    * @param {CIP25String64} name
    * @param {CIP25String64} media_type
    * @param {CIP25ChunkableString} src
    * @returns {CIP25FilesDetails}
    */
    static new(name, media_type, src) {
        _assertClass(name, CIP25String64);
        _assertClass(media_type, CIP25String64);
        _assertClass(src, CIP25ChunkableString);
        const ret = wasm.cip25filesdetails_new(name.ptr, media_type.ptr, src.ptr);
        return CIP25FilesDetails.__wrap(ret);
    }
}

const CIP25LabelMetadataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip25labelmetadata_free(ptr));
/**
*/
export class CIP25LabelMetadata {

    static __wrap(ptr) {
        const obj = Object.create(CIP25LabelMetadata.prototype);
        obj.ptr = ptr;
        CIP25LabelMetadataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP25LabelMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25labelmetadata_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25labelmetadata_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP25LabelMetadata}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25labelmetadata_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25LabelMetadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25labelmetadata_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP25LabelMetadata}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25labelmetadata_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25LabelMetadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25labelmetadata_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25labelmetadata_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP25LabelMetadata}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25labelmetadata_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25LabelMetadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Note that Version 1 can only support utf8 string asset names.
    * Version 2 can support any asset name.
    * @param {number} version
    * @returns {CIP25LabelMetadata}
    */
    static new(version) {
        const ret = wasm.cip25labelmetadata_new(version);
        return CIP25LabelMetadata.__wrap(ret);
    }
    /**
    * If this is version 1 and the asset name is not a utf8 asset name
    * then this will return an error.
    * This function will never return an error for version 2.
    * On success, returns the previous details that were overwritten, or None otherwise.
    * @param {ScriptHash} policy_id
    * @param {AssetName} asset_name
    * @param {CIP25MetadataDetails} details
    * @returns {CIP25MetadataDetails | undefined}
    */
    set(policy_id, asset_name, details) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(policy_id, ScriptHash);
            _assertClass(asset_name, AssetName);
            _assertClass(details, CIP25MetadataDetails);
            wasm.cip25labelmetadata_set(retptr, this.ptr, policy_id.ptr, asset_name.ptr, details.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0 === 0 ? undefined : CIP25MetadataDetails.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {ScriptHash} policy_id
    * @param {AssetName} asset_name
    * @returns {CIP25MetadataDetails | undefined}
    */
    get(policy_id, asset_name) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(asset_name, AssetName);
        const ret = wasm.cip25labelmetadata_get(this.ptr, policy_id.ptr, asset_name.ptr);
        return ret === 0 ? undefined : CIP25MetadataDetails.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    version() {
        const ret = wasm.cip25labelmetadata_version(this.ptr);
        return ret >>> 0;
    }
}

const CIP25MetadataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip25metadata_free(ptr));
/**
* This is the entire metadata schema for CIP-25
* It can be parsed by passing in the CBOR bytes of the entire transaction metadata
* or by passing in an existing Metadata struct.
* Parsing from CBOR bytes should be marginally faster.
*/
export class CIP25Metadata {

    static __wrap(ptr) {
        const obj = Object.create(CIP25Metadata.prototype);
        obj.ptr = ptr;
        CIP25MetadataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP25MetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25metadata_free(ptr);
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25metadata_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25metadata_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP25Metadata}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25metadata_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serialize to CBOR bytes compatible with tx metadata
    * Does not guarantee any specific type of CBOR format and should NOT
    * be used with round-tripping. It will ignore all non-CIP25 keys.
    * Use cml_cip25::metadate crate for round-tripping metadata.
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25metadata_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserialize from CBOR bytes compatible with tx metadata
    * Does not guarantee any specific type of CBOR format and should NOT
    * be used with round-tripping. It will ignore all non-CIP25 keys.
    * Use cml_cip25::metadate crate for round-tripping metadata.
    * @param {Uint8Array} data
    * @returns {CIP25Metadata}
    */
    static from_cbor_bytes(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25metadata_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * The core details of the CIP25 spec
    * @returns {CIP25LabelMetadata}
    */
    key_721() {
        const ret = wasm.cip25metadata_key_721(this.ptr);
        return CIP25LabelMetadata.__wrap(ret);
    }
    /**
    * @param {CIP25LabelMetadata} key_721
    * @returns {CIP25Metadata}
    */
    static new(key_721) {
        _assertClass(key_721, CIP25LabelMetadata);
        const ret = wasm.cip25metadata_new(key_721.ptr);
        return CIP25Metadata.__wrap(ret);
    }
    /**
    * Create a Metadata containing only the CIP25 schema
    * @returns {Metadata}
    */
    to_metadata() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25metadata_to_metadata(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Read the CIP25 schema from a Metadata. Ignores all other data besides CIP25
    * Can fail if the Metadata does not conform to CIP25
    * @param {Metadata} metadata
    * @returns {CIP25Metadata}
    */
    static from_metadata(metadata) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(metadata, Metadata);
            wasm.cip25metadata_from_metadata(retptr, metadata.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Add to an existing metadata (could be empty) the full CIP25 metadata
    * @param {Metadata} metadata
    */
    add_to_metadata(metadata) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(metadata, Metadata);
            wasm.cip25metadata_add_to_metadata(retptr, this.ptr, metadata.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const CIP25MetadataDetailsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip25metadatadetails_free(ptr));
/**
*/
export class CIP25MetadataDetails {

    static __wrap(ptr) {
        const obj = Object.create(CIP25MetadataDetails.prototype);
        obj.ptr = ptr;
        CIP25MetadataDetailsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP25MetadataDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25metadatadetails_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25metadatadetails_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP25MetadataDetails}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25metadatadetails_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25MetadataDetails.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25metadatadetails_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP25MetadataDetails}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25metadatadetails_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25MetadataDetails.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25metadatadetails_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25metadatadetails_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP25MetadataDetails}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25metadatadetails_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25MetadataDetails.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {CIP25String64}
    */
    name() {
        const ret = wasm.cip25metadatadetails_name(this.ptr);
        return CIP25String64.__wrap(ret);
    }
    /**
    * @returns {CIP25ChunkableString}
    */
    image() {
        const ret = wasm.cip25metadatadetails_image(this.ptr);
        return CIP25ChunkableString.__wrap(ret);
    }
    /**
    * @param {CIP25String64} media_type
    */
    set_media_type(media_type) {
        _assertClass(media_type, CIP25String64);
        wasm.cip25metadatadetails_set_media_type(this.ptr, media_type.ptr);
    }
    /**
    * @returns {CIP25String64 | undefined}
    */
    media_type() {
        const ret = wasm.cip25metadatadetails_media_type(this.ptr);
        return ret === 0 ? undefined : CIP25String64.__wrap(ret);
    }
    /**
    * @param {CIP25ChunkableString} description
    */
    set_description(description) {
        _assertClass(description, CIP25ChunkableString);
        wasm.cip25metadatadetails_set_description(this.ptr, description.ptr);
    }
    /**
    * @returns {CIP25ChunkableString | undefined}
    */
    description() {
        const ret = wasm.cip25metadatadetails_description(this.ptr);
        return ret === 0 ? undefined : CIP25ChunkableString.__wrap(ret);
    }
    /**
    * @param {FilesDetailsList} files
    */
    set_files(files) {
        _assertClass(files, FilesDetailsList);
        wasm.cip25metadatadetails_set_files(this.ptr, files.ptr);
    }
    /**
    * @returns {FilesDetailsList | undefined}
    */
    files() {
        const ret = wasm.cip25metadatadetails_files(this.ptr);
        return ret === 0 ? undefined : FilesDetailsList.__wrap(ret);
    }
    /**
    * @param {CIP25String64} name
    * @param {CIP25ChunkableString} image
    * @returns {CIP25MetadataDetails}
    */
    static new(name, image) {
        _assertClass(name, CIP25String64);
        _assertClass(image, CIP25ChunkableString);
        const ret = wasm.cip25metadatadetails_new(name.ptr, image.ptr);
        return CIP25MetadataDetails.__wrap(ret);
    }
}

const CIP25MiniMetadataDetailsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip25minimetadatadetails_free(ptr));
/**
*/
export class CIP25MiniMetadataDetails {

    static __wrap(ptr) {
        const obj = Object.create(CIP25MiniMetadataDetails.prototype);
        obj.ptr = ptr;
        CIP25MiniMetadataDetailsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP25MiniMetadataDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25minimetadatadetails_free(ptr);
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25minimetadatadetails_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25minimetadatadetails_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP25MiniMetadataDetails}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25minimetadatadetails_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25MiniMetadataDetails.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {CIP25MiniMetadataDetails}
    */
    static new() {
        const ret = wasm.cip25minimetadatadetails_new();
        return CIP25MiniMetadataDetails.__wrap(ret);
    }
    /**
    * @param {CIP25String64} name
    */
    set_name(name) {
        _assertClass(name, CIP25String64);
        wasm.cip25minimetadatadetails_set_name(this.ptr, name.ptr);
    }
    /**
    * @returns {CIP25String64 | undefined}
    */
    name() {
        const ret = wasm.cip25minimetadatadetails_name(this.ptr);
        return ret === 0 ? undefined : CIP25String64.__wrap(ret);
    }
    /**
    * @param {CIP25ChunkableString} image
    */
    set_image(image) {
        _assertClass(image, CIP25ChunkableString);
        wasm.cip25minimetadatadetails_set_image(this.ptr, image.ptr);
    }
    /**
    * @returns {CIP25ChunkableString | undefined}
    */
    image() {
        const ret = wasm.cip25minimetadatadetails_image(this.ptr);
        return ret === 0 ? undefined : CIP25ChunkableString.__wrap(ret);
    }
    /**
    * loose parsing of CIP25 metadata to allow for common exceptions to the format
    * `metadatum` should represent the data where the `CIP25MetadataDetails` is in the cip25 structure
    * @param {TransactionMetadatum} metadatum
    * @returns {CIP25MiniMetadataDetails}
    */
    static loose_parse(metadatum) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(metadatum, TransactionMetadatum);
            wasm.cip25minimetadatadetails_loose_parse(retptr, metadatum.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25MiniMetadataDetails.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const CIP25String64Finalization = new FinalizationRegistry(ptr => wasm.__wbg_cip25string64_free(ptr));
/**
* A String of at most 64 bytes.
* This is to conform with Cardano metadata restrictions.
*/
export class CIP25String64 {

    static __wrap(ptr) {
        const obj = Object.create(CIP25String64.prototype);
        obj.ptr = ptr;
        CIP25String64Finalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP25String64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25string64_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25string64_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP25String64}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25string64_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25String64.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25string64_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP25String64}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25string64_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25String64.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25string64_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25string64_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP25String64}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25string64_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25String64.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25string64_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} s
    * @returns {CIP25String64}
    */
    static new(s) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip25string64_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP25String64.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_str() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25string64_to_str(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @returns {string}
    */
    get_str() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip25string64_get_str(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}

const CIP25String64ListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip25string64list_free(ptr));
/**
*/
export class CIP25String64List {

    static __wrap(ptr) {
        const obj = Object.create(CIP25String64List.prototype);
        obj.ptr = ptr;
        CIP25String64ListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP25String64ListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25string64list_free(ptr);
    }
    /**
    * @returns {CIP25String64List}
    */
    static new() {
        const ret = wasm.cip25string64list_new();
        return CIP25String64List.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.cip25string64list_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {CIP25String64}
    */
    get(index) {
        const ret = wasm.cip25string64list_get(this.ptr, index);
        return CIP25String64.__wrap(ret);
    }
    /**
    * @param {CIP25String64} elem
    */
    add(elem) {
        _assertClass(elem, CIP25String64);
        wasm.cip25string64list_add(this.ptr, elem.ptr);
    }
}

const CIP36DelegationFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip36delegation_free(ptr));
/**
*/
export class CIP36Delegation {

    static __wrap(ptr) {
        const obj = Object.create(CIP36Delegation.prototype);
        obj.ptr = ptr;
        CIP36DelegationFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP36DelegationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36delegation_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36delegation_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP36Delegation}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36delegation_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36Delegation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36delegation_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP36Delegation}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36delegation_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36Delegation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36delegation_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36delegation_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP36Delegation}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36delegation_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36Delegation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {PublicKey}
    */
    voting_pub_key() {
        const ret = wasm.cip36delegation_voting_pub_key(this.ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    weight() {
        const ret = wasm.cip36delegation_weight(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {PublicKey} voting_pub_key
    * @param {number} weight
    * @returns {CIP36Delegation}
    */
    static new(voting_pub_key, weight) {
        _assertClass(voting_pub_key, PublicKey);
        const ret = wasm.cip36delegation_new(voting_pub_key.ptr, weight);
        return CIP36Delegation.__wrap(ret);
    }
}

const CIP36DelegationDistributionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip36delegationdistribution_free(ptr));
/**
*/
export class CIP36DelegationDistribution {

    static __wrap(ptr) {
        const obj = Object.create(CIP36DelegationDistribution.prototype);
        obj.ptr = ptr;
        CIP36DelegationDistributionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP36DelegationDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36delegationdistribution_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36delegationdistribution_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP36DelegationDistribution}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36delegationdistribution_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36DelegationDistribution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36delegationdistribution_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP36DelegationDistribution}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36delegationdistribution_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36DelegationDistribution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36delegationdistribution_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36delegationdistribution_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP36DelegationDistribution}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36delegationdistribution_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36DelegationDistribution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {CIP36DelegationList} delegations
    * @returns {CIP36DelegationDistribution}
    */
    static new_weighted(delegations) {
        _assertClass(delegations, CIP36DelegationList);
        const ret = wasm.cip36delegationdistribution_new_weighted(delegations.ptr);
        return CIP36DelegationDistribution.__wrap(ret);
    }
    /**
    * @param {PublicKey} legacy
    * @returns {CIP36DelegationDistribution}
    */
    static new_legacy(legacy) {
        _assertClass(legacy, PublicKey);
        const ret = wasm.cip36delegationdistribution_new_legacy(legacy.ptr);
        return CIP36DelegationDistribution.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.cip36delegationdistribution_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {CIP36DelegationList | undefined}
    */
    as_weighted() {
        const ret = wasm.cip36delegationdistribution_as_weighted(this.ptr);
        return ret === 0 ? undefined : CIP36DelegationList.__wrap(ret);
    }
    /**
    * @returns {PublicKey | undefined}
    */
    as_legacy() {
        const ret = wasm.cip36delegationdistribution_as_legacy(this.ptr);
        return ret === 0 ? undefined : PublicKey.__wrap(ret);
    }
}

const CIP36DelegationListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip36delegationlist_free(ptr));
/**
*/
export class CIP36DelegationList {

    static __wrap(ptr) {
        const obj = Object.create(CIP36DelegationList.prototype);
        obj.ptr = ptr;
        CIP36DelegationListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP36DelegationListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36delegationlist_free(ptr);
    }
    /**
    * @returns {CIP36DelegationList}
    */
    static new() {
        const ret = wasm.cip36delegationlist_new();
        return CIP36DelegationList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.cip36delegationlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {CIP36Delegation}
    */
    get(index) {
        const ret = wasm.cip36delegationlist_get(this.ptr, index);
        return CIP36Delegation.__wrap(ret);
    }
    /**
    * @param {CIP36Delegation} elem
    */
    add(elem) {
        _assertClass(elem, CIP36Delegation);
        wasm.cip36delegationlist_add(this.ptr, elem.ptr);
    }
}

const CIP36DeregistrationCborFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip36deregistrationcbor_free(ptr));
/**
*/
export class CIP36DeregistrationCbor {

    static __wrap(ptr) {
        const obj = Object.create(CIP36DeregistrationCbor.prototype);
        obj.ptr = ptr;
        CIP36DeregistrationCborFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP36DeregistrationCborFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36deregistrationcbor_free(ptr);
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36deregistrationcbor_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36deregistrationcbor_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP36DeregistrationCbor}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36deregistrationcbor_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36DeregistrationCbor.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {CIP36KeyDeregistration}
    */
    key_deregistration() {
        const ret = wasm.cip36deregistrationcbor_key_deregistration(this.ptr);
        return CIP36KeyDeregistration.__wrap(ret);
    }
    /**
    * @returns {CIP36DeregistrationWitness}
    */
    deregistration_witness() {
        const ret = wasm.cip36deregistrationcbor_deregistration_witness(this.ptr);
        return CIP36DeregistrationWitness.__wrap(ret);
    }
    /**
    * @param {CIP36KeyDeregistration} key_deregistration
    * @param {CIP36DeregistrationWitness} deregistration_witness
    * @returns {CIP36DeregistrationCbor}
    */
    static new(key_deregistration, deregistration_witness) {
        _assertClass(key_deregistration, CIP36KeyDeregistration);
        _assertClass(deregistration_witness, CIP36DeregistrationWitness);
        const ret = wasm.cip36deregistrationcbor_new(key_deregistration.ptr, deregistration_witness.ptr);
        return CIP36DeregistrationCbor.__wrap(ret);
    }
}

const CIP36DeregistrationWitnessFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip36deregistrationwitness_free(ptr));
/**
*/
export class CIP36DeregistrationWitness {

    static __wrap(ptr) {
        const obj = Object.create(CIP36DeregistrationWitness.prototype);
        obj.ptr = ptr;
        CIP36DeregistrationWitnessFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP36DeregistrationWitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36deregistrationwitness_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36deregistrationwitness_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP36DeregistrationWitness}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36deregistrationwitness_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36DeregistrationWitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36deregistrationwitness_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP36DeregistrationWitness}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36deregistrationwitness_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36DeregistrationWitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36deregistrationwitness_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36deregistrationwitness_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP36DeregistrationWitness}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36deregistrationwitness_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36DeregistrationWitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Ed25519Signature}
    */
    stake_witness() {
        const ret = wasm.cip36deregistrationwitness_stake_witness(this.ptr);
        return Ed25519Signature.__wrap(ret);
    }
    /**
    * @param {Ed25519Signature} stake_witness
    * @returns {CIP36DeregistrationWitness}
    */
    static new(stake_witness) {
        _assertClass(stake_witness, Ed25519Signature);
        const ret = wasm.cip36deregistrationwitness_new(stake_witness.ptr);
        return CIP36DeregistrationWitness.__wrap(ret);
    }
}

const CIP36KeyDeregistrationFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip36keyderegistration_free(ptr));
/**
*/
export class CIP36KeyDeregistration {

    static __wrap(ptr) {
        const obj = Object.create(CIP36KeyDeregistration.prototype);
        obj.ptr = ptr;
        CIP36KeyDeregistrationFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP36KeyDeregistrationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36keyderegistration_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36keyderegistration_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP36KeyDeregistration}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36keyderegistration_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36KeyDeregistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36keyderegistration_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP36KeyDeregistration}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36keyderegistration_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36KeyDeregistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36keyderegistration_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36keyderegistration_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP36KeyDeregistration}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36keyderegistration_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36KeyDeregistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {PublicKey}
    */
    stake_credential() {
        const ret = wasm.cip36keyderegistration_stake_credential(this.ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    nonce() {
        const ret = wasm.cip36keyderegistration_nonce(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} voting_purpose
    */
    set_voting_purpose(voting_purpose) {
        wasm.cip36keyderegistration_set_voting_purpose(this.ptr, voting_purpose);
    }
    /**
    * @returns {bigint}
    */
    voting_purpose() {
        const ret = wasm.cip36keyderegistration_voting_purpose(this.ptr);
        return BigInt.asUintN(64, ret);
    }
}

const CIP36KeyRegistrationFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip36keyregistration_free(ptr));
/**
*/
export class CIP36KeyRegistration {

    static __wrap(ptr) {
        const obj = Object.create(CIP36KeyRegistration.prototype);
        obj.ptr = ptr;
        CIP36KeyRegistrationFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP36KeyRegistrationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36keyregistration_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36keyregistration_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP36KeyRegistration}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36keyregistration_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36KeyRegistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36keyregistration_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP36KeyRegistration}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36keyregistration_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36KeyRegistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36keyregistration_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36keyregistration_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP36KeyRegistration}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36keyregistration_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36KeyRegistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {CIP36DelegationDistribution}
    */
    delegation() {
        const ret = wasm.cip36keyregistration_delegation(this.ptr);
        return CIP36DelegationDistribution.__wrap(ret);
    }
    /**
    * @returns {PublicKey}
    */
    stake_credential() {
        const ret = wasm.cip36keyregistration_stake_credential(this.ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {Address}
    */
    payment_address() {
        const ret = wasm.cip36keyregistration_payment_address(this.ptr);
        return Address.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    nonce() {
        const ret = wasm.cip36keyregistration_nonce(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} voting_purpose
    */
    set_voting_purpose(voting_purpose) {
        wasm.cip36keyregistration_set_voting_purpose(this.ptr, voting_purpose);
    }
    /**
    * @returns {bigint}
    */
    voting_purpose() {
        const ret = wasm.cip36keyregistration_voting_purpose(this.ptr);
        return BigInt.asUintN(64, ret);
    }
}

const CIP36RegistrationCborFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip36registrationcbor_free(ptr));
/**
*/
export class CIP36RegistrationCbor {

    static __wrap(ptr) {
        const obj = Object.create(CIP36RegistrationCbor.prototype);
        obj.ptr = ptr;
        CIP36RegistrationCborFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP36RegistrationCborFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36registrationcbor_free(ptr);
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36registrationcbor_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36registrationcbor_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP36RegistrationCbor}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36registrationcbor_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36RegistrationCbor.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {CIP36KeyRegistration}
    */
    key_registration() {
        const ret = wasm.cip36registrationcbor_key_registration(this.ptr);
        return CIP36KeyRegistration.__wrap(ret);
    }
    /**
    * @returns {CIP36RegistrationWitness}
    */
    registration_witness() {
        const ret = wasm.cip36registrationcbor_registration_witness(this.ptr);
        return CIP36RegistrationWitness.__wrap(ret);
    }
    /**
    * @param {CIP36KeyRegistration} key_registration
    * @param {CIP36RegistrationWitness} registration_witness
    * @returns {CIP36RegistrationCbor}
    */
    static new(key_registration, registration_witness) {
        _assertClass(key_registration, CIP36KeyRegistration);
        _assertClass(registration_witness, CIP36RegistrationWitness);
        const ret = wasm.cip36registrationcbor_new(key_registration.ptr, registration_witness.ptr);
        return CIP36RegistrationCbor.__wrap(ret);
    }
}

const CIP36RegistrationWitnessFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cip36registrationwitness_free(ptr));
/**
*/
export class CIP36RegistrationWitness {

    static __wrap(ptr) {
        const obj = Object.create(CIP36RegistrationWitness.prototype);
        obj.ptr = ptr;
        CIP36RegistrationWitnessFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CIP36RegistrationWitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36registrationwitness_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36registrationwitness_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CIP36RegistrationWitness}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36registrationwitness_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36RegistrationWitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36registrationwitness_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CIP36RegistrationWitness}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36registrationwitness_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36RegistrationWitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36registrationwitness_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cip36registrationwitness_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CIP36RegistrationWitness}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.cip36registrationwitness_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CIP36RegistrationWitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Ed25519Signature}
    */
    stake_witness() {
        const ret = wasm.cip36registrationwitness_stake_witness(this.ptr);
        return Ed25519Signature.__wrap(ret);
    }
    /**
    * @param {Ed25519Signature} stake_witness
    * @returns {CIP36RegistrationWitness}
    */
    static new(stake_witness) {
        _assertClass(stake_witness, Ed25519Signature);
        const ret = wasm.cip36deregistrationwitness_new(stake_witness.ptr);
        return CIP36RegistrationWitness.__wrap(ret);
    }
}

const CertificateFinalization = new FinalizationRegistry(ptr => wasm.__wbg_certificate_free(ptr));
/**
*/
export class Certificate {

    static __wrap(ptr) {
        const obj = Object.create(Certificate.prototype);
        obj.ptr = ptr;
        CertificateFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CertificateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_certificate_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.certificate_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Certificate}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.certificate_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Certificate.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.certificate_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Certificate}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.certificate_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Certificate.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.certificate_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.certificate_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Certificate}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.certificate_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Certificate.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Credential} stake_credential
    * @returns {Certificate}
    */
    static new_stake_registration(stake_credential) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.certificate_new_stake_registration(stake_credential.ptr);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @returns {Certificate}
    */
    static new_stake_deregistration(stake_credential) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.certificate_new_stake_deregistration(stake_credential.ptr);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {Ed25519KeyHash} pool
    * @returns {Certificate}
    */
    static new_stake_delegation(stake_credential, pool) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.certificate_new_stake_delegation(stake_credential.ptr, pool.ptr);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {PoolParams} pool_params
    * @returns {Certificate}
    */
    static new_pool_registration(pool_params) {
        _assertClass(pool_params, PoolParams);
        const ret = wasm.certificate_new_pool_registration(pool_params.ptr);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Ed25519KeyHash} pool
    * @param {bigint} epoch
    * @returns {Certificate}
    */
    static new_pool_retirement(pool, epoch) {
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.certificate_new_pool_retirement(pool.ptr, epoch);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {bigint} coin
    * @returns {Certificate}
    */
    static new_reg_cert(stake_credential, coin) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.certificate_new_reg_cert(stake_credential.ptr, coin);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {bigint} coin
    * @returns {Certificate}
    */
    static new_unreg_cert(stake_credential, coin) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.certificate_new_unreg_cert(stake_credential.ptr, coin);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {DRep} d_rep
    * @returns {Certificate}
    */
    static new_vote_deleg_cert(stake_credential, d_rep) {
        _assertClass(stake_credential, Credential);
        _assertClass(d_rep, DRep);
        const ret = wasm.certificate_new_vote_deleg_cert(stake_credential.ptr, d_rep.ptr);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {Ed25519KeyHash} pool
    * @param {DRep} d_rep
    * @returns {Certificate}
    */
    static new_stake_vote_deleg_cert(stake_credential, pool, d_rep) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        _assertClass(d_rep, DRep);
        const ret = wasm.certificate_new_stake_vote_deleg_cert(stake_credential.ptr, pool.ptr, d_rep.ptr);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {Ed25519KeyHash} pool
    * @param {bigint} coin
    * @returns {Certificate}
    */
    static new_stake_reg_deleg_cert(stake_credential, pool, coin) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.certificate_new_stake_reg_deleg_cert(stake_credential.ptr, pool.ptr, coin);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {DRep} d_rep
    * @param {bigint} coin
    * @returns {Certificate}
    */
    static new_vote_reg_deleg_cert(stake_credential, d_rep, coin) {
        _assertClass(stake_credential, Credential);
        _assertClass(d_rep, DRep);
        const ret = wasm.certificate_new_vote_reg_deleg_cert(stake_credential.ptr, d_rep.ptr, coin);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {Ed25519KeyHash} pool
    * @param {DRep} d_rep
    * @param {bigint} coin
    * @returns {Certificate}
    */
    static new_stake_vote_reg_deleg_cert(stake_credential, pool, d_rep, coin) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        _assertClass(d_rep, DRep);
        const ret = wasm.certificate_new_stake_vote_reg_deleg_cert(stake_credential.ptr, pool.ptr, d_rep.ptr, coin);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} committee_cold_credential
    * @param {Credential} committee_hot_credential
    * @returns {Certificate}
    */
    static new_auth_committee_hot_cert(committee_cold_credential, committee_hot_credential) {
        _assertClass(committee_cold_credential, Credential);
        _assertClass(committee_hot_credential, Credential);
        const ret = wasm.certificate_new_auth_committee_hot_cert(committee_cold_credential.ptr, committee_hot_credential.ptr);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} committee_cold_credential
    * @returns {Certificate}
    */
    static new_resign_committee_cold_cert(committee_cold_credential) {
        _assertClass(committee_cold_credential, Credential);
        const ret = wasm.certificate_new_resign_committee_cold_cert(committee_cold_credential.ptr);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} drep_credential
    * @param {bigint} coin
    * @param {Anchor | undefined} anchor
    * @returns {Certificate}
    */
    static new_reg_drep_cert(drep_credential, coin, anchor) {
        _assertClass(drep_credential, Credential);
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.ptr;
            anchor.ptr = 0;
        }
        const ret = wasm.certificate_new_reg_drep_cert(drep_credential.ptr, coin, ptr0);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} drep_credential
    * @param {bigint} coin
    * @returns {Certificate}
    */
    static new_unreg_drep_cert(drep_credential, coin) {
        _assertClass(drep_credential, Credential);
        const ret = wasm.certificate_new_unreg_drep_cert(drep_credential.ptr, coin);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Credential} drep_credential
    * @param {Anchor | undefined} anchor
    * @returns {Certificate}
    */
    static new_update_drep_cert(drep_credential, anchor) {
        _assertClass(drep_credential, Credential);
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.ptr;
            anchor.ptr = 0;
        }
        const ret = wasm.certificate_new_update_drep_cert(drep_credential.ptr, ptr0);
        return Certificate.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.certificate_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {StakeRegistration | undefined}
    */
    as_stake_registration() {
        const ret = wasm.certificate_as_stake_registration(this.ptr);
        return ret === 0 ? undefined : StakeRegistration.__wrap(ret);
    }
    /**
    * @returns {StakeDeregistration | undefined}
    */
    as_stake_deregistration() {
        const ret = wasm.certificate_as_stake_deregistration(this.ptr);
        return ret === 0 ? undefined : StakeDeregistration.__wrap(ret);
    }
    /**
    * @returns {StakeDelegation | undefined}
    */
    as_stake_delegation() {
        const ret = wasm.certificate_as_stake_delegation(this.ptr);
        return ret === 0 ? undefined : StakeDelegation.__wrap(ret);
    }
    /**
    * @returns {PoolRegistration | undefined}
    */
    as_pool_registration() {
        const ret = wasm.certificate_as_pool_registration(this.ptr);
        return ret === 0 ? undefined : PoolRegistration.__wrap(ret);
    }
    /**
    * @returns {PoolRetirement | undefined}
    */
    as_pool_retirement() {
        const ret = wasm.certificate_as_pool_retirement(this.ptr);
        return ret === 0 ? undefined : PoolRetirement.__wrap(ret);
    }
    /**
    * @returns {RegCert | undefined}
    */
    as_reg_cert() {
        const ret = wasm.certificate_as_reg_cert(this.ptr);
        return ret === 0 ? undefined : RegCert.__wrap(ret);
    }
    /**
    * @returns {UnregCert | undefined}
    */
    as_unreg_cert() {
        const ret = wasm.certificate_as_unreg_cert(this.ptr);
        return ret === 0 ? undefined : UnregCert.__wrap(ret);
    }
    /**
    * @returns {VoteDelegCert | undefined}
    */
    as_vote_deleg_cert() {
        const ret = wasm.certificate_as_vote_deleg_cert(this.ptr);
        return ret === 0 ? undefined : VoteDelegCert.__wrap(ret);
    }
    /**
    * @returns {StakeVoteDelegCert | undefined}
    */
    as_stake_vote_deleg_cert() {
        const ret = wasm.certificate_as_stake_vote_deleg_cert(this.ptr);
        return ret === 0 ? undefined : StakeVoteDelegCert.__wrap(ret);
    }
    /**
    * @returns {StakeRegDelegCert | undefined}
    */
    as_stake_reg_deleg_cert() {
        const ret = wasm.certificate_as_stake_reg_deleg_cert(this.ptr);
        return ret === 0 ? undefined : StakeRegDelegCert.__wrap(ret);
    }
    /**
    * @returns {VoteRegDelegCert | undefined}
    */
    as_vote_reg_deleg_cert() {
        const ret = wasm.certificate_as_vote_reg_deleg_cert(this.ptr);
        return ret === 0 ? undefined : VoteRegDelegCert.__wrap(ret);
    }
    /**
    * @returns {StakeVoteRegDelegCert | undefined}
    */
    as_stake_vote_reg_deleg_cert() {
        const ret = wasm.certificate_as_stake_vote_reg_deleg_cert(this.ptr);
        return ret === 0 ? undefined : StakeVoteRegDelegCert.__wrap(ret);
    }
    /**
    * @returns {AuthCommitteeHotCert | undefined}
    */
    as_auth_committee_hot_cert() {
        const ret = wasm.certificate_as_auth_committee_hot_cert(this.ptr);
        return ret === 0 ? undefined : AuthCommitteeHotCert.__wrap(ret);
    }
    /**
    * @returns {ResignCommitteeColdCert | undefined}
    */
    as_resign_committee_cold_cert() {
        const ret = wasm.certificate_as_resign_committee_cold_cert(this.ptr);
        return ret === 0 ? undefined : ResignCommitteeColdCert.__wrap(ret);
    }
    /**
    * @returns {RegDrepCert | undefined}
    */
    as_reg_drep_cert() {
        const ret = wasm.certificate_as_reg_drep_cert(this.ptr);
        return ret === 0 ? undefined : RegDrepCert.__wrap(ret);
    }
    /**
    * @returns {UnregDrepCert | undefined}
    */
    as_unreg_drep_cert() {
        const ret = wasm.certificate_as_unreg_drep_cert(this.ptr);
        return ret === 0 ? undefined : UnregDrepCert.__wrap(ret);
    }
    /**
    * @returns {UpdateDrepCert | undefined}
    */
    as_update_drep_cert() {
        const ret = wasm.certificate_as_update_drep_cert(this.ptr);
        return ret === 0 ? undefined : UpdateDrepCert.__wrap(ret);
    }
}

const CertificateBuilderResultFinalization = new FinalizationRegistry(ptr => wasm.__wbg_certificatebuilderresult_free(ptr));
/**
*/
export class CertificateBuilderResult {

    static __wrap(ptr) {
        const obj = Object.create(CertificateBuilderResult.prototype);
        obj.ptr = ptr;
        CertificateBuilderResultFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CertificateBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_certificatebuilderresult_free(ptr);
    }
}

const CertificateListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_certificatelist_free(ptr));
/**
*/
export class CertificateList {

    static __wrap(ptr) {
        const obj = Object.create(CertificateList.prototype);
        obj.ptr = ptr;
        CertificateListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CertificateListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_certificatelist_free(ptr);
    }
    /**
    * @returns {CertificateList}
    */
    static new() {
        const ret = wasm.certificatelist_new();
        return CertificateList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.certificatelist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Certificate}
    */
    get(index) {
        const ret = wasm.certificatelist_get(this.ptr, index);
        return Certificate.__wrap(ret);
    }
    /**
    * @param {Certificate} elem
    */
    add(elem) {
        _assertClass(elem, Certificate);
        wasm.certificatelist_add(this.ptr, elem.ptr);
    }
}

const CommitteeFinalization = new FinalizationRegistry(ptr => wasm.__wbg_committee_free(ptr));
/**
*/
export class Committee {

    static __wrap(ptr) {
        const obj = Object.create(Committee.prototype);
        obj.ptr = ptr;
        CommitteeFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CommitteeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_committee_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.committee_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Committee}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.committee_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Committee.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.committee_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Committee}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.committee_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Committee.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.committee_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.committee_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Committee}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.committee_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Committee.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {MapCommitteeColdCredentialToEpoch}
    */
    credentials() {
        const ret = wasm.committee_credentials(this.ptr);
        return MapCommitteeColdCredentialToEpoch.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    unit_interval() {
        const ret = wasm.committee_unit_interval(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @param {MapCommitteeColdCredentialToEpoch} credentials
    * @param {UnitInterval} unit_interval
    * @returns {Committee}
    */
    static new(credentials, unit_interval) {
        _assertClass(credentials, MapCommitteeColdCredentialToEpoch);
        _assertClass(unit_interval, UnitInterval);
        const ret = wasm.committee_new(credentials.ptr, unit_interval.ptr);
        return Committee.__wrap(ret);
    }
}

const CommitteeColdCredentialListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_committeecoldcredentiallist_free(ptr));
/**
*/
export class CommitteeColdCredentialList {

    static __wrap(ptr) {
        const obj = Object.create(CommitteeColdCredentialList.prototype);
        obj.ptr = ptr;
        CommitteeColdCredentialListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CommitteeColdCredentialListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_committeecoldcredentiallist_free(ptr);
    }
    /**
    * @returns {CommitteeColdCredentialList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return CommitteeColdCredentialList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.committeecoldcredentiallist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Credential}
    */
    get(index) {
        const ret = wasm.committeecoldcredentiallist_get(this.ptr, index);
        return Credential.__wrap(ret);
    }
    /**
    * @param {Credential} elem
    */
    add(elem) {
        _assertClass(elem, Credential);
        wasm.committeecoldcredentiallist_add(this.ptr, elem.ptr);
    }
}

const ConstitutionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_constitution_free(ptr));
/**
*/
export class Constitution {

    static __wrap(ptr) {
        const obj = Object.create(Constitution.prototype);
        obj.ptr = ptr;
        ConstitutionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ConstitutionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_constitution_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.constitution_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Constitution}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.constitution_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Constitution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.constitution_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Constitution}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.constitution_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Constitution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.constitution_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.constitution_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Constitution}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.constitution_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Constitution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Anchor}
    */
    anchor() {
        const ret = wasm.constitution_anchor(this.ptr);
        return Anchor.__wrap(ret);
    }
    /**
    * @returns {ScriptHash | undefined}
    */
    script_hash() {
        const ret = wasm.constitution_script_hash(this.ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
    /**
    * @param {Anchor} anchor
    * @param {ScriptHash | undefined} script_hash
    * @returns {Constitution}
    */
    static new(anchor, script_hash) {
        _assertClass(anchor, Anchor);
        let ptr0 = 0;
        if (!isLikeNone(script_hash)) {
            _assertClass(script_hash, ScriptHash);
            ptr0 = script_hash.ptr;
            script_hash.ptr = 0;
        }
        const ret = wasm.constitution_new(anchor.ptr, ptr0);
        return Constitution.__wrap(ret);
    }
}

const ConstrPlutusDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_constrplutusdata_free(ptr));
/**
*/
export class ConstrPlutusData {

    static __wrap(ptr) {
        const obj = Object.create(ConstrPlutusData.prototype);
        obj.ptr = ptr;
        ConstrPlutusDataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ConstrPlutusDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_constrplutusdata_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.constrplutusdata_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ConstrPlutusData}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.constrplutusdata_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ConstrPlutusData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.constrplutusdata_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ConstrPlutusData}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.constrplutusdata_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ConstrPlutusData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.constrplutusdata_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.constrplutusdata_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ConstrPlutusData}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.constrplutusdata_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ConstrPlutusData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    alternative() {
        const ret = wasm.constrplutusdata_alternative(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {PlutusDataList}
    */
    fields() {
        const ret = wasm.constrplutusdata_fields(this.ptr);
        return PlutusDataList.__wrap(ret);
    }
    /**
    * @param {bigint} alternative
    * @param {PlutusDataList} fields
    * @returns {ConstrPlutusData}
    */
    static new(alternative, fields) {
        _assertClass(fields, PlutusDataList);
        const ret = wasm.constrplutusdata_new(alternative, fields.ptr);
        return ConstrPlutusData.__wrap(ret);
    }
}

const ConwayFormatAuxDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_conwayformatauxdata_free(ptr));
/**
*/
export class ConwayFormatAuxData {

    static __wrap(ptr) {
        const obj = Object.create(ConwayFormatAuxData.prototype);
        obj.ptr = ptr;
        ConwayFormatAuxDataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ConwayFormatAuxDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_conwayformatauxdata_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.conwayformatauxdata_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ConwayFormatAuxData}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.conwayformatauxdata_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ConwayFormatAuxData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.conwayformatauxdata_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ConwayFormatAuxData}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.conwayformatauxdata_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ConwayFormatAuxData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.conwayformatauxdata_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.conwayformatauxdata_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ConwayFormatAuxData}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.conwayformatauxdata_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ConwayFormatAuxData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Metadata} metadata
    */
    set_metadata(metadata) {
        _assertClass(metadata, Metadata);
        wasm.conwayformatauxdata_set_metadata(this.ptr, metadata.ptr);
    }
    /**
    * @returns {Metadata | undefined}
    */
    metadata() {
        const ret = wasm.conwayformatauxdata_metadata(this.ptr);
        return ret === 0 ? undefined : Metadata.__wrap(ret);
    }
    /**
    * @param {NativeScriptList} native_scripts
    */
    set_native_scripts(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        wasm.conwayformatauxdata_set_native_scripts(this.ptr, native_scripts.ptr);
    }
    /**
    * @returns {NativeScriptList | undefined}
    */
    native_scripts() {
        const ret = wasm.conwayformatauxdata_native_scripts(this.ptr);
        return ret === 0 ? undefined : NativeScriptList.__wrap(ret);
    }
    /**
    * @param {PlutusV1ScriptList} plutus_v1_scripts
    */
    set_plutus_v1_scripts(plutus_v1_scripts) {
        _assertClass(plutus_v1_scripts, PlutusV1ScriptList);
        wasm.conwayformatauxdata_set_plutus_v1_scripts(this.ptr, plutus_v1_scripts.ptr);
    }
    /**
    * @returns {PlutusV1ScriptList | undefined}
    */
    plutus_v1_scripts() {
        const ret = wasm.conwayformatauxdata_plutus_v1_scripts(this.ptr);
        return ret === 0 ? undefined : PlutusV1ScriptList.__wrap(ret);
    }
    /**
    * @param {PlutusV2ScriptList} plutus_v2_scripts
    */
    set_plutus_v2_scripts(plutus_v2_scripts) {
        _assertClass(plutus_v2_scripts, PlutusV2ScriptList);
        wasm.conwayformatauxdata_set_plutus_v2_scripts(this.ptr, plutus_v2_scripts.ptr);
    }
    /**
    * @returns {PlutusV2ScriptList | undefined}
    */
    plutus_v2_scripts() {
        const ret = wasm.conwayformatauxdata_plutus_v2_scripts(this.ptr);
        return ret === 0 ? undefined : PlutusV2ScriptList.__wrap(ret);
    }
    /**
    * @param {PlutusV3ScriptList} plutus_v3_scripts
    */
    set_plutus_v3_scripts(plutus_v3_scripts) {
        _assertClass(plutus_v3_scripts, PlutusV3ScriptList);
        wasm.conwayformatauxdata_set_plutus_v3_scripts(this.ptr, plutus_v3_scripts.ptr);
    }
    /**
    * @returns {PlutusV3ScriptList | undefined}
    */
    plutus_v3_scripts() {
        const ret = wasm.conwayformatauxdata_plutus_v3_scripts(this.ptr);
        return ret === 0 ? undefined : PlutusV3ScriptList.__wrap(ret);
    }
    /**
    * @returns {ConwayFormatAuxData}
    */
    static new() {
        const ret = wasm.conwayformatauxdata_new();
        return ConwayFormatAuxData.__wrap(ret);
    }
}

const ConwayFormatTxOutFinalization = new FinalizationRegistry(ptr => wasm.__wbg_conwayformattxout_free(ptr));
/**
*/
export class ConwayFormatTxOut {

    static __wrap(ptr) {
        const obj = Object.create(ConwayFormatTxOut.prototype);
        obj.ptr = ptr;
        ConwayFormatTxOutFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ConwayFormatTxOutFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_conwayformattxout_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.conwayformattxout_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ConwayFormatTxOut}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.conwayformattxout_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ConwayFormatTxOut.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.conwayformattxout_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ConwayFormatTxOut}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.conwayformattxout_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ConwayFormatTxOut.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.conwayformattxout_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.conwayformattxout_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ConwayFormatTxOut}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.conwayformattxout_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ConwayFormatTxOut.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Address}
    */
    address() {
        const ret = wasm.conwayformattxout_address(this.ptr);
        return Address.__wrap(ret);
    }
    /**
    * @returns {Value}
    */
    amount() {
        const ret = wasm.conwayformattxout_amount(this.ptr);
        return Value.__wrap(ret);
    }
    /**
    * @param {DatumOption} datum_option
    */
    set_datum_option(datum_option) {
        _assertClass(datum_option, DatumOption);
        wasm.conwayformattxout_set_datum_option(this.ptr, datum_option.ptr);
    }
    /**
    * @returns {DatumOption | undefined}
    */
    datum_option() {
        const ret = wasm.conwayformattxout_datum_option(this.ptr);
        return ret === 0 ? undefined : DatumOption.__wrap(ret);
    }
    /**
    * @param {Script} script_reference
    */
    set_script_reference(script_reference) {
        _assertClass(script_reference, Script);
        wasm.conwayformattxout_set_script_reference(this.ptr, script_reference.ptr);
    }
    /**
    * @returns {Script | undefined}
    */
    script_reference() {
        const ret = wasm.conwayformattxout_script_reference(this.ptr);
        return ret === 0 ? undefined : Script.__wrap(ret);
    }
    /**
    * @param {Address} address
    * @param {Value} amount
    * @returns {ConwayFormatTxOut}
    */
    static new(address, amount) {
        _assertClass(address, Address);
        _assertClass(amount, Value);
        const ret = wasm.conwayformattxout_new(address.ptr, amount.ptr);
        return ConwayFormatTxOut.__wrap(ret);
    }
}

const CostModelsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_costmodels_free(ptr));
/**
*/
export class CostModels {

    static __wrap(ptr) {
        const obj = Object.create(CostModels.prototype);
        obj.ptr = ptr;
        CostModelsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CostModelsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_costmodels_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.costmodels_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {CostModels}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.costmodels_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CostModels.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.costmodels_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {CostModels}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.costmodels_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CostModels.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.costmodels_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.costmodels_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {CostModels}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.costmodels_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CostModels.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {IntList} plutus_v1
    */
    set_plutus_v1(plutus_v1) {
        _assertClass(plutus_v1, IntList);
        wasm.costmodels_set_plutus_v1(this.ptr, plutus_v1.ptr);
    }
    /**
    * @returns {IntList | undefined}
    */
    plutus_v1() {
        const ret = wasm.costmodels_plutus_v1(this.ptr);
        return ret === 0 ? undefined : IntList.__wrap(ret);
    }
    /**
    * @param {IntList} plutus_v2
    */
    set_plutus_v2(plutus_v2) {
        _assertClass(plutus_v2, IntList);
        wasm.costmodels_set_plutus_v2(this.ptr, plutus_v2.ptr);
    }
    /**
    * @returns {IntList | undefined}
    */
    plutus_v2() {
        const ret = wasm.costmodels_plutus_v2(this.ptr);
        return ret === 0 ? undefined : IntList.__wrap(ret);
    }
    /**
    * @param {IntList} plutus_v3
    */
    set_plutus_v3(plutus_v3) {
        _assertClass(plutus_v3, IntList);
        wasm.costmodels_set_plutus_v3(this.ptr, plutus_v3.ptr);
    }
    /**
    * @returns {IntList | undefined}
    */
    plutus_v3() {
        const ret = wasm.costmodels_plutus_v3(this.ptr);
        return ret === 0 ? undefined : IntList.__wrap(ret);
    }
    /**
    * @returns {CostModels}
    */
    static new() {
        const ret = wasm.costmodels_new();
        return CostModels.__wrap(ret);
    }
}

const Crc32Finalization = new FinalizationRegistry(ptr => wasm.__wbg_crc32_free(ptr));
/**
*/
export class Crc32 {

    static __wrap(ptr) {
        const obj = Object.create(Crc32.prototype);
        obj.ptr = ptr;
        Crc32Finalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Crc32Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_crc32_free(ptr);
    }
    /**
    * initialise a new CRC32 state
    * @returns {Crc32}
    */
    static new() {
        const ret = wasm.crc32_new();
        return Crc32.__wrap(ret);
    }
    /**
    * update the CRC32 with the given bytes.
    *
    * beware that the order in which you update the Crc32
    * matter
    * @param {Uint8Array} bytes
    */
    update(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.crc32_update(this.ptr, ptr0, len0);
    }
    /**
    * finalize the CRC32, recovering the computed value
    * @returns {number}
    */
    finalize() {
        const ret = wasm.crc32_finalize(this.ptr);
        return ret >>> 0;
    }
}

const CredentialFinalization = new FinalizationRegistry(ptr => wasm.__wbg_credential_free(ptr));
/**
*/
export class Credential {

    static __wrap(ptr) {
        const obj = Object.create(Credential.prototype);
        obj.ptr = ptr;
        CredentialFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CredentialFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_credential_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Credential}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.credential_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Credential.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Credential}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.credential_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Credential.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Credential}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.credential_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Credential.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Ed25519KeyHash} hash
    * @returns {Credential}
    */
    static new_pub_key(hash) {
        _assertClass(hash, Ed25519KeyHash);
        const ret = wasm.credential_new_pub_key(hash.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @param {ScriptHash} hash
    * @returns {Credential}
    */
    static new_script(hash) {
        _assertClass(hash, ScriptHash);
        const ret = wasm.credential_new_script(hash.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.credential_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {Ed25519KeyHash | undefined}
    */
    as_pub_key() {
        const ret = wasm.credential_as_pub_key(this.ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @returns {ScriptHash | undefined}
    */
    as_script() {
        const ret = wasm.credential_as_script(this.ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
}

const DRepFinalization = new FinalizationRegistry(ptr => wasm.__wbg_drep_free(ptr));
/**
*/
export class DRep {

    static __wrap(ptr) {
        const obj = Object.create(DRep.prototype);
        obj.ptr = ptr;
        DRepFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DRepFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_drep_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.drep_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {DRep}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.drep_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DRep.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.drep_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {DRep}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.drep_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DRep.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.drep_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.drep_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {DRep}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.drep_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DRep.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Ed25519KeyHash} pool
    * @returns {DRep}
    */
    static new_key(pool) {
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.drep_new_key(pool.ptr);
        return DRep.__wrap(ret);
    }
    /**
    * @param {ScriptHash} script_hash
    * @returns {DRep}
    */
    static new_script(script_hash) {
        _assertClass(script_hash, ScriptHash);
        const ret = wasm.drep_new_script(script_hash.ptr);
        return DRep.__wrap(ret);
    }
    /**
    * @returns {DRep}
    */
    static new_always_abstain() {
        const ret = wasm.drep_new_always_abstain();
        return DRep.__wrap(ret);
    }
    /**
    * @returns {DRep}
    */
    static new_always_no_confidence() {
        const ret = wasm.drep_new_always_no_confidence();
        return DRep.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.drep_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {Ed25519KeyHash | undefined}
    */
    as_key() {
        const ret = wasm.drep_as_key(this.ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @returns {ScriptHash | undefined}
    */
    as_script() {
        const ret = wasm.drep_as_script(this.ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
}

const DRepVotingThresholdsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_drepvotingthresholds_free(ptr));
/**
*/
export class DRepVotingThresholds {

    static __wrap(ptr) {
        const obj = Object.create(DRepVotingThresholds.prototype);
        obj.ptr = ptr;
        DRepVotingThresholdsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DRepVotingThresholdsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_drepvotingthresholds_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.drepvotingthresholds_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {DRepVotingThresholds}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.drepvotingthresholds_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DRepVotingThresholds.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.drepvotingthresholds_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {DRepVotingThresholds}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.drepvotingthresholds_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DRepVotingThresholds.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.drepvotingthresholds_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.drepvotingthresholds_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {DRepVotingThresholds}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.drepvotingthresholds_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DRepVotingThresholds.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {UnitInterval}
    */
    motion_no_confidence() {
        const ret = wasm.drepvotingthresholds_motion_no_confidence(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    committee_normal() {
        const ret = wasm.drepvotingthresholds_committee_normal(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    committee_no_confidence() {
        const ret = wasm.drepvotingthresholds_committee_no_confidence(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    update_constitution() {
        const ret = wasm.drepvotingthresholds_update_constitution(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    hard_fork_initiation() {
        const ret = wasm.drepvotingthresholds_hard_fork_initiation(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    pp_network_group() {
        const ret = wasm.drepvotingthresholds_pp_network_group(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    pp_economic_group() {
        const ret = wasm.drepvotingthresholds_pp_economic_group(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    pp_technical_group() {
        const ret = wasm.drepvotingthresholds_pp_technical_group(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    pp_governance_group() {
        const ret = wasm.drepvotingthresholds_pp_governance_group(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    treasury_withdrawal() {
        const ret = wasm.drepvotingthresholds_treasury_withdrawal(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @param {UnitInterval} motion_no_confidence
    * @param {UnitInterval} committee_normal
    * @param {UnitInterval} committee_no_confidence
    * @param {UnitInterval} update_constitution
    * @param {UnitInterval} hard_fork_initiation
    * @param {UnitInterval} pp_network_group
    * @param {UnitInterval} pp_economic_group
    * @param {UnitInterval} pp_technical_group
    * @param {UnitInterval} pp_governance_group
    * @param {UnitInterval} treasury_withdrawal
    * @returns {DRepVotingThresholds}
    */
    static new(motion_no_confidence, committee_normal, committee_no_confidence, update_constitution, hard_fork_initiation, pp_network_group, pp_economic_group, pp_technical_group, pp_governance_group, treasury_withdrawal) {
        _assertClass(motion_no_confidence, UnitInterval);
        _assertClass(committee_normal, UnitInterval);
        _assertClass(committee_no_confidence, UnitInterval);
        _assertClass(update_constitution, UnitInterval);
        _assertClass(hard_fork_initiation, UnitInterval);
        _assertClass(pp_network_group, UnitInterval);
        _assertClass(pp_economic_group, UnitInterval);
        _assertClass(pp_technical_group, UnitInterval);
        _assertClass(pp_governance_group, UnitInterval);
        _assertClass(treasury_withdrawal, UnitInterval);
        const ret = wasm.drepvotingthresholds_new(motion_no_confidence.ptr, committee_normal.ptr, committee_no_confidence.ptr, update_constitution.ptr, hard_fork_initiation.ptr, pp_network_group.ptr, pp_economic_group.ptr, pp_technical_group.ptr, pp_governance_group.ptr, treasury_withdrawal.ptr);
        return DRepVotingThresholds.__wrap(ret);
    }
}

const DatumHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_datumhash_free(ptr));
/**
*/
export class DatumHash {

    static __wrap(ptr) {
        const obj = Object.create(DatumHash.prototype);
        obj.ptr = ptr;
        DatumHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DatumHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_datumhash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.datumhash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.datumhash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.datumhash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {DatumHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.datumhash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DatumHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {DatumHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.datumhash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DatumHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {DatumHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.datumhash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DatumHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const DatumOptionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_datumoption_free(ptr));
/**
*/
export class DatumOption {

    static __wrap(ptr) {
        const obj = Object.create(DatumOption.prototype);
        obj.ptr = ptr;
        DatumOptionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DatumOptionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_datumoption_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.datumoption_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {DatumOption}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.datumoption_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DatumOption.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.datumoption_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {DatumOption}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.datumoption_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DatumOption.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.datumoption_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.datumoption_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {DatumOption}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.datumoption_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DatumOption.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {DatumHash} datum_hash
    * @returns {DatumOption}
    */
    static new_hash(datum_hash) {
        _assertClass(datum_hash, DatumHash);
        const ret = wasm.datumoption_new_hash(datum_hash.ptr);
        return DatumOption.__wrap(ret);
    }
    /**
    * @param {PlutusData} datum
    * @returns {DatumOption}
    */
    static new_datum(datum) {
        _assertClass(datum, PlutusData);
        const ret = wasm.datumoption_new_datum(datum.ptr);
        return DatumOption.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.datumoption_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {DatumHash | undefined}
    */
    as_hash() {
        const ret = wasm.datumoption_as_hash(this.ptr);
        return ret === 0 ? undefined : DatumHash.__wrap(ret);
    }
    /**
    * @returns {PlutusData | undefined}
    */
    as_datum() {
        const ret = wasm.datumoption_as_datum(this.ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
}

const DnsNameFinalization = new FinalizationRegistry(ptr => wasm.__wbg_dnsname_free(ptr));
/**
*/
export class DnsName {

    static __wrap(ptr) {
        const obj = Object.create(DnsName.prototype);
        obj.ptr = ptr;
        DnsNameFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DnsNameFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_dnsname_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.dnsname_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {DnsName}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.dnsname_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DnsName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.dnsname_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {DnsName}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.dnsname_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DnsName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.dnsname_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.dnsname_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {DnsName}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.dnsname_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DnsName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.dnsname_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}

const Ed25519KeyHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_ed25519keyhash_free(ptr));
/**
*/
export class Ed25519KeyHash {

    static __wrap(ptr) {
        const obj = Object.create(Ed25519KeyHash.prototype);
        obj.ptr = ptr;
        Ed25519KeyHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Ed25519KeyHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ed25519keyhash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ed25519keyhash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ed25519keyhash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ed25519keyhash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {Ed25519KeyHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ed25519keyhash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ed25519KeyHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {Ed25519KeyHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ed25519keyhash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ed25519KeyHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {Ed25519KeyHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ed25519keyhash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ed25519KeyHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const Ed25519KeyHashListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_ed25519keyhashlist_free(ptr));
/**
*/
export class Ed25519KeyHashList {

    static __wrap(ptr) {
        const obj = Object.create(Ed25519KeyHashList.prototype);
        obj.ptr = ptr;
        Ed25519KeyHashListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Ed25519KeyHashListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ed25519keyhashlist_free(ptr);
    }
    /**
    * @returns {Ed25519KeyHashList}
    */
    static new() {
        const ret = wasm.ed25519keyhashlist_new();
        return Ed25519KeyHashList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.ed25519keyhashlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Ed25519KeyHash}
    */
    get(index) {
        const ret = wasm.ed25519keyhashlist_get(this.ptr, index);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @param {Ed25519KeyHash} elem
    */
    add(elem) {
        _assertClass(elem, Ed25519KeyHash);
        wasm.ed25519keyhashlist_add(this.ptr, elem.ptr);
    }
}

const Ed25519SignatureFinalization = new FinalizationRegistry(ptr => wasm.__wbg_ed25519signature_free(ptr));
/**
*/
export class Ed25519Signature {

    static __wrap(ptr) {
        const obj = Object.create(Ed25519Signature.prototype);
        obj.ptr = ptr;
        Ed25519SignatureFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Ed25519SignatureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ed25519signature_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ed25519signature_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_bech32() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ed25519signature_to_bech32(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ed25519signature_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {Ed25519Signature}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ed25519signature_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ed25519Signature.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {Ed25519Signature}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ed25519signature_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ed25519Signature.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {Ed25519Signature}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ed25519signature_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ed25519Signature.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const EnterpriseAddressFinalization = new FinalizationRegistry(ptr => wasm.__wbg_enterpriseaddress_free(ptr));
/**
*/
export class EnterpriseAddress {

    static __wrap(ptr) {
        const obj = Object.create(EnterpriseAddress.prototype);
        obj.ptr = ptr;
        EnterpriseAddressFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        EnterpriseAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_enterpriseaddress_free(ptr);
    }
    /**
    * @param {number} network
    * @param {Credential} payment
    * @returns {EnterpriseAddress}
    */
    static new(network, payment) {
        _assertClass(payment, Credential);
        const ret = wasm.enterpriseaddress_new(network, payment.ptr);
        return EnterpriseAddress.__wrap(ret);
    }
    /**
    * @returns {Address}
    */
    to_address() {
        const ret = wasm.enterpriseaddress_to_address(this.ptr);
        return Address.__wrap(ret);
    }
    /**
    * @param {Address} address
    * @returns {EnterpriseAddress | undefined}
    */
    static from_address(address) {
        _assertClass(address, Address);
        const ret = wasm.enterpriseaddress_from_address(address.ptr);
        return ret === 0 ? undefined : EnterpriseAddress.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    network_id() {
        const ret = wasm.enterpriseaddress_network_id(this.ptr);
        return ret;
    }
    /**
    * @returns {Credential}
    */
    payment() {
        const ret = wasm.enterpriseaddress_payment(this.ptr);
        return Credential.__wrap(ret);
    }
}

const ExUnitPricesFinalization = new FinalizationRegistry(ptr => wasm.__wbg_exunitprices_free(ptr));
/**
*/
export class ExUnitPrices {

    static __wrap(ptr) {
        const obj = Object.create(ExUnitPrices.prototype);
        obj.ptr = ptr;
        ExUnitPricesFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ExUnitPricesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_exunitprices_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.exunitprices_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ExUnitPrices}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.exunitprices_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ExUnitPrices.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.exunitprices_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ExUnitPrices}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.exunitprices_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ExUnitPrices.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.exunitprices_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.exunitprices_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ExUnitPrices}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.exunitprices_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ExUnitPrices.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Rational}
    */
    mem_price() {
        const ret = wasm.exunitprices_mem_price(this.ptr);
        return Rational.__wrap(ret);
    }
    /**
    * @returns {Rational}
    */
    step_price() {
        const ret = wasm.exunitprices_step_price(this.ptr);
        return Rational.__wrap(ret);
    }
    /**
    * @param {Rational} mem_price
    * @param {Rational} step_price
    * @returns {ExUnitPrices}
    */
    static new(mem_price, step_price) {
        _assertClass(mem_price, Rational);
        _assertClass(step_price, Rational);
        const ret = wasm.exunitprices_new(mem_price.ptr, step_price.ptr);
        return ExUnitPrices.__wrap(ret);
    }
}

const ExUnitsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_exunits_free(ptr));
/**
*/
export class ExUnits {

    static __wrap(ptr) {
        const obj = Object.create(ExUnits.prototype);
        obj.ptr = ptr;
        ExUnitsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ExUnitsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_exunits_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.exunits_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ExUnits}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.exunits_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ExUnits.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.exunits_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ExUnits}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.exunits_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ExUnits.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.exunits_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.exunits_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ExUnits}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.exunits_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ExUnits.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    mem() {
        const ret = wasm.exunits_mem(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {bigint}
    */
    steps() {
        const ret = wasm.exunits_steps(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} mem
    * @param {bigint} steps
    * @returns {ExUnits}
    */
    static new(mem, steps) {
        const ret = wasm.exunits_new(mem, steps);
        return ExUnits.__wrap(ret);
    }
    /**
    * @param {ExUnits} other
    * @returns {ExUnits}
    */
    checked_add(other) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(other, ExUnits);
            wasm.exunits_checked_add(retptr, this.ptr, other.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ExUnits.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const FilesDetailsListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_filesdetailslist_free(ptr));
/**
*/
export class FilesDetailsList {

    static __wrap(ptr) {
        const obj = Object.create(FilesDetailsList.prototype);
        obj.ptr = ptr;
        FilesDetailsListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        FilesDetailsListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_filesdetailslist_free(ptr);
    }
    /**
    * @returns {FilesDetailsList}
    */
    static new() {
        const ret = wasm.cip25string64list_new();
        return FilesDetailsList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.filesdetailslist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {CIP25FilesDetails}
    */
    get(index) {
        const ret = wasm.filesdetailslist_get(this.ptr, index);
        return CIP25FilesDetails.__wrap(ret);
    }
    /**
    * @param {CIP25FilesDetails} elem
    */
    add(elem) {
        _assertClass(elem, CIP25FilesDetails);
        wasm.filesdetailslist_add(this.ptr, elem.ptr);
    }
}

const GenesisDelegateHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_genesisdelegatehash_free(ptr));
/**
*/
export class GenesisDelegateHash {

    static __wrap(ptr) {
        const obj = Object.create(GenesisDelegateHash.prototype);
        obj.ptr = ptr;
        GenesisDelegateHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        GenesisDelegateHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_genesisdelegatehash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.genesisdelegatehash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.genesisdelegatehash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.genesisdelegatehash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {GenesisDelegateHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.genesisdelegatehash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GenesisDelegateHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {GenesisDelegateHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.genesisdelegatehash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GenesisDelegateHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {GenesisDelegateHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.genesisdelegatehash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GenesisDelegateHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const GenesisHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_genesishash_free(ptr));
/**
*/
export class GenesisHash {

    static __wrap(ptr) {
        const obj = Object.create(GenesisHash.prototype);
        obj.ptr = ptr;
        GenesisHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        GenesisHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_genesishash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.genesishash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.genesishash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.genesishash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {GenesisHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.genesishash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GenesisHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {GenesisHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.genesishash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GenesisHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {GenesisHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.genesishash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GenesisHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const GovActionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_govaction_free(ptr));
/**
*/
export class GovAction {

    static __wrap(ptr) {
        const obj = Object.create(GovAction.prototype);
        obj.ptr = ptr;
        GovActionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        GovActionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_govaction_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.govaction_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {GovAction}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.govaction_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GovAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.govaction_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {GovAction}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.govaction_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GovAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.govaction_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.govaction_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {GovAction}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.govaction_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GovAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {GovActionId | undefined} gov_action_id
    * @param {ProtocolParamUpdate} protocol_param_update
    * @returns {GovAction}
    */
    static new_parameter_change_action(gov_action_id, protocol_param_update) {
        let ptr0 = 0;
        if (!isLikeNone(gov_action_id)) {
            _assertClass(gov_action_id, GovActionId);
            ptr0 = gov_action_id.ptr;
            gov_action_id.ptr = 0;
        }
        _assertClass(protocol_param_update, ProtocolParamUpdate);
        const ret = wasm.govaction_new_parameter_change_action(ptr0, protocol_param_update.ptr);
        return GovAction.__wrap(ret);
    }
    /**
    * @param {GovActionId | undefined} action_id
    * @param {ProtocolVersion} version
    * @returns {GovAction}
    */
    static new_hard_fork_initiation_action(action_id, version) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.ptr;
            action_id.ptr = 0;
        }
        _assertClass(version, ProtocolVersion);
        const ret = wasm.govaction_new_hard_fork_initiation_action(ptr0, version.ptr);
        return GovAction.__wrap(ret);
    }
    /**
    * @param {MapRewardAccountToCoin} withdrawal
    * @returns {GovAction}
    */
    static new_treasury_withdrawals_action(withdrawal) {
        _assertClass(withdrawal, MapRewardAccountToCoin);
        const ret = wasm.govaction_new_treasury_withdrawals_action(withdrawal.ptr);
        return GovAction.__wrap(ret);
    }
    /**
    * @param {GovActionId | undefined} action_id
    * @returns {GovAction}
    */
    static new_no_confidence(action_id) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.ptr;
            action_id.ptr = 0;
        }
        const ret = wasm.govaction_new_no_confidence(ptr0);
        return GovAction.__wrap(ret);
    }
    /**
    * @param {GovActionId | undefined} action_id
    * @param {CommitteeColdCredentialList} cold_credentials
    * @param {Committee} committee
    * @returns {GovAction}
    */
    static new_new_committee(action_id, cold_credentials, committee) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.ptr;
            action_id.ptr = 0;
        }
        _assertClass(cold_credentials, CommitteeColdCredentialList);
        _assertClass(committee, Committee);
        const ret = wasm.govaction_new_new_committee(ptr0, cold_credentials.ptr, committee.ptr);
        return GovAction.__wrap(ret);
    }
    /**
    * @param {GovActionId | undefined} action_id
    * @param {Constitution} constitution
    * @returns {GovAction}
    */
    static new_new_constitution(action_id, constitution) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.ptr;
            action_id.ptr = 0;
        }
        _assertClass(constitution, Constitution);
        const ret = wasm.govaction_new_new_constitution(ptr0, constitution.ptr);
        return GovAction.__wrap(ret);
    }
    /**
    * @returns {GovAction}
    */
    static new_info_action() {
        const ret = wasm.govaction_new_info_action();
        return GovAction.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.govaction_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {ParameterChangeAction | undefined}
    */
    as_parameter_change_action() {
        const ret = wasm.govaction_as_parameter_change_action(this.ptr);
        return ret === 0 ? undefined : ParameterChangeAction.__wrap(ret);
    }
    /**
    * @returns {HardForkInitiationAction | undefined}
    */
    as_hard_fork_initiation_action() {
        const ret = wasm.govaction_as_hard_fork_initiation_action(this.ptr);
        return ret === 0 ? undefined : HardForkInitiationAction.__wrap(ret);
    }
    /**
    * @returns {TreasuryWithdrawalsAction | undefined}
    */
    as_treasury_withdrawals_action() {
        const ret = wasm.govaction_as_treasury_withdrawals_action(this.ptr);
        return ret === 0 ? undefined : TreasuryWithdrawalsAction.__wrap(ret);
    }
    /**
    * @returns {NoConfidence | undefined}
    */
    as_no_confidence() {
        const ret = wasm.govaction_as_no_confidence(this.ptr);
        return ret === 0 ? undefined : NoConfidence.__wrap(ret);
    }
    /**
    * @returns {NewCommittee | undefined}
    */
    as_new_committee() {
        const ret = wasm.govaction_as_new_committee(this.ptr);
        return ret === 0 ? undefined : NewCommittee.__wrap(ret);
    }
    /**
    * @returns {NewConstitution | undefined}
    */
    as_new_constitution() {
        const ret = wasm.govaction_as_new_constitution(this.ptr);
        return ret === 0 ? undefined : NewConstitution.__wrap(ret);
    }
}

const GovActionIdFinalization = new FinalizationRegistry(ptr => wasm.__wbg_govactionid_free(ptr));
/**
*/
export class GovActionId {

    static __wrap(ptr) {
        const obj = Object.create(GovActionId.prototype);
        obj.ptr = ptr;
        GovActionIdFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        GovActionIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_govactionid_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.govactionid_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {GovActionId}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.govactionid_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GovActionId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.govactionid_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {GovActionId}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.govactionid_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GovActionId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.govactionid_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.govactionid_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {GovActionId}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.govactionid_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return GovActionId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {TransactionHash}
    */
    transaction_id() {
        const ret = wasm.govactionid_transaction_id(this.ptr);
        return TransactionHash.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    gov_action_index() {
        const ret = wasm.govactionid_gov_action_index(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {TransactionHash} transaction_id
    * @param {bigint} gov_action_index
    * @returns {GovActionId}
    */
    static new(transaction_id, gov_action_index) {
        _assertClass(transaction_id, TransactionHash);
        const ret = wasm.govactionid_new(transaction_id.ptr, gov_action_index);
        return GovActionId.__wrap(ret);
    }
}

const GovActionIdListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_govactionidlist_free(ptr));
/**
*/
export class GovActionIdList {

    static __wrap(ptr) {
        const obj = Object.create(GovActionIdList.prototype);
        obj.ptr = ptr;
        GovActionIdListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        GovActionIdListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_govactionidlist_free(ptr);
    }
    /**
    * @returns {GovActionIdList}
    */
    static new() {
        const ret = wasm.certificatelist_new();
        return GovActionIdList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.govactionidlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {GovActionId}
    */
    get(index) {
        const ret = wasm.govactionidlist_get(this.ptr, index);
        return GovActionId.__wrap(ret);
    }
    /**
    * @param {GovActionId} elem
    */
    add(elem) {
        _assertClass(elem, GovActionId);
        wasm.govactionidlist_add(this.ptr, elem.ptr);
    }
}

const HDAddressPayloadFinalization = new FinalizationRegistry(ptr => wasm.__wbg_hdaddresspayload_free(ptr));
/**
*/
export class HDAddressPayload {

    static __wrap(ptr) {
        const obj = Object.create(HDAddressPayload.prototype);
        obj.ptr = ptr;
        HDAddressPayloadFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        HDAddressPayloadFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_hdaddresspayload_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.hdaddresspayload_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {HDAddressPayload}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.hdaddresspayload_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return HDAddressPayload.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.hdaddresspayload_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {HDAddressPayload}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.hdaddresspayload_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return HDAddressPayload.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.hdaddresspayload_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const HardForkInitiationActionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_hardforkinitiationaction_free(ptr));
/**
*/
export class HardForkInitiationAction {

    static __wrap(ptr) {
        const obj = Object.create(HardForkInitiationAction.prototype);
        obj.ptr = ptr;
        HardForkInitiationActionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        HardForkInitiationActionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_hardforkinitiationaction_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.hardforkinitiationaction_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {HardForkInitiationAction}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.hardforkinitiationaction_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return HardForkInitiationAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.hardforkinitiationaction_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {HardForkInitiationAction}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.hardforkinitiationaction_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return HardForkInitiationAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.hardforkinitiationaction_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.hardforkinitiationaction_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {HardForkInitiationAction}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.hardforkinitiationaction_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return HardForkInitiationAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {GovActionId | undefined}
    */
    action_id() {
        const ret = wasm.hardforkinitiationaction_action_id(this.ptr);
        return ret === 0 ? undefined : GovActionId.__wrap(ret);
    }
    /**
    * @returns {ProtocolVersion}
    */
    version() {
        const ret = wasm.hardforkinitiationaction_version(this.ptr);
        return ProtocolVersion.__wrap(ret);
    }
    /**
    * @param {GovActionId | undefined} action_id
    * @param {ProtocolVersion} version
    * @returns {HardForkInitiationAction}
    */
    static new(action_id, version) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.ptr;
            action_id.ptr = 0;
        }
        _assertClass(version, ProtocolVersion);
        const ret = wasm.hardforkinitiationaction_new(ptr0, version.ptr);
        return HardForkInitiationAction.__wrap(ret);
    }
}

const HeaderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_header_free(ptr));
/**
*/
export class Header {

    static __wrap(ptr) {
        const obj = Object.create(Header.prototype);
        obj.ptr = ptr;
        HeaderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        HeaderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_header_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.header_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Header}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.header_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Header.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.header_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Header}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.header_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Header.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.header_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.header_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Header}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.header_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Header.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {HeaderBody}
    */
    header_body() {
        const ret = wasm.header_header_body(this.ptr);
        return HeaderBody.__wrap(ret);
    }
    /**
    * @returns {KESSignature}
    */
    body_signature() {
        const ret = wasm.header_body_signature(this.ptr);
        return KESSignature.__wrap(ret);
    }
    /**
    * @param {HeaderBody} header_body
    * @param {KESSignature} body_signature
    * @returns {Header}
    */
    static new(header_body, body_signature) {
        _assertClass(header_body, HeaderBody);
        _assertClass(body_signature, KESSignature);
        const ret = wasm.header_new(header_body.ptr, body_signature.ptr);
        return Header.__wrap(ret);
    }
}

const HeaderBodyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_headerbody_free(ptr));
/**
*/
export class HeaderBody {

    static __wrap(ptr) {
        const obj = Object.create(HeaderBody.prototype);
        obj.ptr = ptr;
        HeaderBodyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        HeaderBodyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_headerbody_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.headerbody_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {HeaderBody}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.headerbody_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return HeaderBody.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.headerbody_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {HeaderBody}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.headerbody_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return HeaderBody.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.headerbody_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.headerbody_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {HeaderBody}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.headerbody_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return HeaderBody.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    block_number() {
        const ret = wasm.headerbody_block_number(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {bigint}
    */
    slot() {
        const ret = wasm.headerbody_slot(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {BlockHeaderHash | undefined}
    */
    prev_hash() {
        const ret = wasm.headerbody_prev_hash(this.ptr);
        return ret === 0 ? undefined : BlockHeaderHash.__wrap(ret);
    }
    /**
    * @returns {PublicKey}
    */
    issuer_vkey() {
        const ret = wasm.headerbody_issuer_vkey(this.ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {VRFVkey}
    */
    vrf_vkey() {
        const ret = wasm.headerbody_vrf_vkey(this.ptr);
        return VRFVkey.__wrap(ret);
    }
    /**
    * @returns {VRFCert}
    */
    vrf_result() {
        const ret = wasm.headerbody_vrf_result(this.ptr);
        return VRFCert.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    block_body_size() {
        const ret = wasm.headerbody_block_body_size(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {BlockBodyHash}
    */
    block_body_hash() {
        const ret = wasm.headerbody_block_body_hash(this.ptr);
        return BlockBodyHash.__wrap(ret);
    }
    /**
    * @returns {OperationalCert}
    */
    operational_cert() {
        const ret = wasm.headerbody_operational_cert(this.ptr);
        return OperationalCert.__wrap(ret);
    }
    /**
    * @returns {ProtocolVersion}
    */
    protocol_version() {
        const ret = wasm.headerbody_protocol_version(this.ptr);
        return ProtocolVersion.__wrap(ret);
    }
    /**
    * @param {bigint} block_number
    * @param {bigint} slot
    * @param {BlockHeaderHash | undefined} prev_hash
    * @param {PublicKey} issuer_vkey
    * @param {VRFVkey} vrf_vkey
    * @param {VRFCert} vrf_result
    * @param {bigint} block_body_size
    * @param {BlockBodyHash} block_body_hash
    * @param {OperationalCert} operational_cert
    * @param {ProtocolVersion} protocol_version
    * @returns {HeaderBody}
    */
    static new(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, vrf_result, block_body_size, block_body_hash, operational_cert, protocol_version) {
        let ptr0 = 0;
        if (!isLikeNone(prev_hash)) {
            _assertClass(prev_hash, BlockHeaderHash);
            ptr0 = prev_hash.ptr;
            prev_hash.ptr = 0;
        }
        _assertClass(issuer_vkey, PublicKey);
        _assertClass(vrf_vkey, VRFVkey);
        _assertClass(vrf_result, VRFCert);
        _assertClass(block_body_hash, BlockBodyHash);
        _assertClass(operational_cert, OperationalCert);
        _assertClass(protocol_version, ProtocolVersion);
        const ret = wasm.headerbody_new(block_number, slot, ptr0, issuer_vkey.ptr, vrf_vkey.ptr, vrf_result.ptr, block_body_size, block_body_hash.ptr, operational_cert.ptr, protocol_version.ptr);
        return HeaderBody.__wrap(ret);
    }
}

const InputAggregateWitnessDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_inputaggregatewitnessdata_free(ptr));
/**
*/
export class InputAggregateWitnessData {

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        InputAggregateWitnessDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_inputaggregatewitnessdata_free(ptr);
    }
    /**
    * @returns {PlutusData | undefined}
    */
    plutus_data() {
        const ret = wasm.inputaggregatewitnessdata_plutus_data(this.ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
}

const InputBuilderResultFinalization = new FinalizationRegistry(ptr => wasm.__wbg_inputbuilderresult_free(ptr));
/**
*/
export class InputBuilderResult {

    static __wrap(ptr) {
        const obj = Object.create(InputBuilderResult.prototype);
        obj.ptr = ptr;
        InputBuilderResultFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        InputBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_inputbuilderresult_free(ptr);
    }
}

const IntFinalization = new FinalizationRegistry(ptr => wasm.__wbg_int_free(ptr));
/**
*/
export class Int {

    static __wrap(ptr) {
        const obj = Object.create(Int.prototype);
        obj.ptr = ptr;
        IntFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        IntFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_int_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.int_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} cbor_bytes
    * @returns {Int}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.int_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Int.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.int_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_json_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.int_to_json_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Int}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.int_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Int.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} x
    * @returns {Int}
    */
    static new(x) {
        const ret = wasm.int_new(x);
        return Int.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    to_str() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.int_to_str(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} string
    * @returns {Int}
    */
    static from_str(string) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.int_from_str(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Int.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const IntListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_intlist_free(ptr));
/**
*/
export class IntList {

    static __wrap(ptr) {
        const obj = Object.create(IntList.prototype);
        obj.ptr = ptr;
        IntListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        IntListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_intlist_free(ptr);
    }
    /**
    * @returns {IntList}
    */
    static new() {
        const ret = wasm.certificatelist_new();
        return IntList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.intlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Int}
    */
    get(index) {
        const ret = wasm.intlist_get(this.ptr, index);
        return Int.__wrap(ret);
    }
    /**
    * @param {Int} elem
    */
    add(elem) {
        _assertClass(elem, Int);
        wasm.intlist_add(this.ptr, elem.ptr);
    }
}

const Ipv4Finalization = new FinalizationRegistry(ptr => wasm.__wbg_ipv4_free(ptr));
/**
*/
export class Ipv4 {

    static __wrap(ptr) {
        const obj = Object.create(Ipv4.prototype);
        obj.ptr = ptr;
        Ipv4Finalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Ipv4Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ipv4_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ipv4_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Ipv4}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ipv4_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ipv4.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ipv4_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Ipv4}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ipv4_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ipv4.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ipv4_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ipv4_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Ipv4}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ipv4_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ipv4.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ipv4_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const Ipv6Finalization = new FinalizationRegistry(ptr => wasm.__wbg_ipv6_free(ptr));
/**
*/
export class Ipv6 {

    static __wrap(ptr) {
        const obj = Object.create(Ipv6.prototype);
        obj.ptr = ptr;
        Ipv6Finalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Ipv6Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ipv6_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ipv6_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Ipv6}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ipv6_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ipv6.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ipv6_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Ipv6}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ipv6_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ipv6.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ipv6_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ipv6_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Ipv6}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ipv6_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ipv6.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ipv6_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const KESSignatureFinalization = new FinalizationRegistry(ptr => wasm.__wbg_kessignature_free(ptr));
/**
*/
export class KESSignature {

    static __wrap(ptr) {
        const obj = Object.create(KESSignature.prototype);
        obj.ptr = ptr;
        KESSignatureFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        KESSignatureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_kessignature_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.kessignature_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {KESSignature}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.kessignature_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KESSignature.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.kessignature_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {KESSignature}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.kessignature_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KESSignature.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.kessignature_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.kessignature_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {KESSignature}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.kessignature_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KESSignature.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.kessignature_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const KESVkeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_kesvkey_free(ptr));
/**
*/
export class KESVkey {

    static __wrap(ptr) {
        const obj = Object.create(KESVkey.prototype);
        obj.ptr = ptr;
        KESVkeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        KESVkeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_kesvkey_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.kesvkey_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.kesvkey_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.kesvkey_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {KESVkey}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.kesvkey_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KESVkey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {KESVkey}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.kesvkey_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KESVkey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {KESVkey}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.kesvkey_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KESVkey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const LanguageListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_languagelist_free(ptr));
/**
*/
export class LanguageList {

    static __wrap(ptr) {
        const obj = Object.create(LanguageList.prototype);
        obj.ptr = ptr;
        LanguageListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        LanguageListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_languagelist_free(ptr);
    }
    /**
    * @returns {LanguageList}
    */
    static new() {
        const ret = wasm.languagelist_new();
        return LanguageList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.languagelist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {number}
    */
    get(index) {
        const ret = wasm.languagelist_get(this.ptr, index);
        return ret >>> 0;
    }
    /**
    * @param {number} elem
    */
    add(elem) {
        wasm.languagelist_add(this.ptr, elem);
    }
}

const LegacyDaedalusPrivateKeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_legacydaedalusprivatekey_free(ptr));
/**
*/
export class LegacyDaedalusPrivateKey {

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        LegacyDaedalusPrivateKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_legacydaedalusprivatekey_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    chaincode() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.legacydaedalusprivatekey_chaincode(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const LinearFeeFinalization = new FinalizationRegistry(ptr => wasm.__wbg_linearfee_free(ptr));
/**
* Careful: although the linear fee is the same for Byron & Shelley
* The value of the parameters and how fees are computed is not the same
*/
export class LinearFee {

    static __wrap(ptr) {
        const obj = Object.create(LinearFee.prototype);
        obj.ptr = ptr;
        LinearFeeFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        LinearFeeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_linearfee_free(ptr);
    }
    /**
    * @param {bigint} coefficient
    * @param {bigint} constant
    * @returns {LinearFee}
    */
    static new(coefficient, constant) {
        const ret = wasm.linearfee_new(coefficient, constant);
        return LinearFee.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    constant() {
        const ret = wasm.linearfee_constant(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {bigint}
    */
    coefficient() {
        const ret = wasm.linearfee_coefficient(this.ptr);
        return BigInt.asUintN(64, ret);
    }
}

const MapAssetNameToCoinFinalization = new FinalizationRegistry(ptr => wasm.__wbg_mapassetnametocoin_free(ptr));
/**
*/
export class MapAssetNameToCoin {

    static __wrap(ptr) {
        const obj = Object.create(MapAssetNameToCoin.prototype);
        obj.ptr = ptr;
        MapAssetNameToCoinFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MapAssetNameToCoinFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapassetnametocoin_free(ptr);
    }
    /**
    * @param {AssetName} key
    * @returns {bigint | undefined}
    */
    get(key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key, AssetName);
            wasm.mapassetnametocoin_get(retptr, this.ptr, key.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {AssetName} key
    * @param {bigint} value
    * @returns {bigint | undefined}
    */
    insert(key, value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key, AssetName);
            wasm.mapassetnametocoin_insert(retptr, this.ptr, key.ptr, value);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {MapAssetNameToCoin}
    */
    static new() {
        const ret = wasm.mapassetnametocoin_new();
        return MapAssetNameToCoin.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.mapassetnametocoin_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {boolean}
    */
    is_empty() {
        const ret = wasm.mapassetnametocoin_is_empty(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {AssetNameList}
    */
    keys() {
        const ret = wasm.mapassetnametocoin_keys(this.ptr);
        return AssetNameList.__wrap(ret);
    }
}

const MapAssetNameToNonZeroInt64Finalization = new FinalizationRegistry(ptr => wasm.__wbg_mapassetnametononzeroint64_free(ptr));
/**
*/
export class MapAssetNameToNonZeroInt64 {

    static __wrap(ptr) {
        const obj = Object.create(MapAssetNameToNonZeroInt64.prototype);
        obj.ptr = ptr;
        MapAssetNameToNonZeroInt64Finalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MapAssetNameToNonZeroInt64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapassetnametononzeroint64_free(ptr);
    }
    /**
    * @returns {MapAssetNameToNonZeroInt64}
    */
    static new() {
        const ret = wasm.mapassetnametononzeroint64_new();
        return MapAssetNameToNonZeroInt64.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.mapassetnametononzeroint64_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {AssetName} key
    * @param {bigint} value
    * @returns {bigint | undefined}
    */
    insert(key, value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key, AssetName);
            wasm.mapassetnametononzeroint64_insert(retptr, this.ptr, key.ptr, value);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {AssetName} key
    * @returns {bigint | undefined}
    */
    get(key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key, AssetName);
            wasm.mapassetnametononzeroint64_get(retptr, this.ptr, key.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {AssetNameList}
    */
    keys() {
        const ret = wasm.mapassetnametononzeroint64_keys(this.ptr);
        return AssetNameList.__wrap(ret);
    }
}

const MapAssetNameToU64Finalization = new FinalizationRegistry(ptr => wasm.__wbg_mapassetnametou64_free(ptr));
/**
*/
export class MapAssetNameToU64 {

    static __wrap(ptr) {
        const obj = Object.create(MapAssetNameToU64.prototype);
        obj.ptr = ptr;
        MapAssetNameToU64Finalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MapAssetNameToU64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapassetnametou64_free(ptr);
    }
    /**
    * @returns {MapAssetNameToU64}
    */
    static new() {
        const ret = wasm.mapassetnametou64_new();
        return MapAssetNameToU64.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.mapassetnametou64_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {AssetName} key
    * @param {bigint} value
    * @returns {bigint | undefined}
    */
    insert(key, value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key, AssetName);
            wasm.mapassetnametou64_insert(retptr, this.ptr, key.ptr, value);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {AssetName} key
    * @returns {bigint | undefined}
    */
    get(key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key, AssetName);
            wasm.mapassetnametou64_get(retptr, this.ptr, key.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {AssetNameList}
    */
    keys() {
        const ret = wasm.mapassetnametou64_keys(this.ptr);
        return AssetNameList.__wrap(ret);
    }
}

const MapCommitteeColdCredentialToEpochFinalization = new FinalizationRegistry(ptr => wasm.__wbg_mapcommitteecoldcredentialtoepoch_free(ptr));
/**
*/
export class MapCommitteeColdCredentialToEpoch {

    static __wrap(ptr) {
        const obj = Object.create(MapCommitteeColdCredentialToEpoch.prototype);
        obj.ptr = ptr;
        MapCommitteeColdCredentialToEpochFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MapCommitteeColdCredentialToEpochFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapcommitteecoldcredentialtoepoch_free(ptr);
    }
    /**
    * @returns {MapCommitteeColdCredentialToEpoch}
    */
    static new() {
        const ret = wasm.mapcommitteecoldcredentialtoepoch_new();
        return MapCommitteeColdCredentialToEpoch.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.mapcommitteecoldcredentialtoepoch_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {Credential} key
    * @param {bigint} value
    * @returns {bigint | undefined}
    */
    insert(key, value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key, Credential);
            wasm.mapcommitteecoldcredentialtoepoch_insert(retptr, this.ptr, key.ptr, value);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Credential} key
    * @returns {bigint | undefined}
    */
    get(key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key, Credential);
            wasm.mapcommitteecoldcredentialtoepoch_get(retptr, this.ptr, key.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {CommitteeColdCredentialList}
    */
    keys() {
        const ret = wasm.mapcommitteecoldcredentialtoepoch_keys(this.ptr);
        return CommitteeColdCredentialList.__wrap(ret);
    }
}

const MapGovActionIdToVotingProcedureFinalization = new FinalizationRegistry(ptr => wasm.__wbg_mapgovactionidtovotingprocedure_free(ptr));
/**
*/
export class MapGovActionIdToVotingProcedure {

    static __wrap(ptr) {
        const obj = Object.create(MapGovActionIdToVotingProcedure.prototype);
        obj.ptr = ptr;
        MapGovActionIdToVotingProcedureFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MapGovActionIdToVotingProcedureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapgovactionidtovotingprocedure_free(ptr);
    }
    /**
    * @returns {MapGovActionIdToVotingProcedure}
    */
    static new() {
        const ret = wasm.mapgovactionidtovotingprocedure_new();
        return MapGovActionIdToVotingProcedure.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.mapgovactionidtovotingprocedure_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {GovActionId} key
    * @param {VotingProcedure} value
    * @returns {VotingProcedure | undefined}
    */
    insert(key, value) {
        _assertClass(key, GovActionId);
        _assertClass(value, VotingProcedure);
        const ret = wasm.mapgovactionidtovotingprocedure_insert(this.ptr, key.ptr, value.ptr);
        return ret === 0 ? undefined : VotingProcedure.__wrap(ret);
    }
    /**
    * @param {GovActionId} key
    * @returns {VotingProcedure | undefined}
    */
    get(key) {
        _assertClass(key, GovActionId);
        const ret = wasm.mapgovactionidtovotingprocedure_get(this.ptr, key.ptr);
        return ret === 0 ? undefined : VotingProcedure.__wrap(ret);
    }
    /**
    * @returns {GovActionIdList}
    */
    keys() {
        const ret = wasm.mapgovactionidtovotingprocedure_keys(this.ptr);
        return GovActionIdList.__wrap(ret);
    }
}

const MapPlutusDataToPlutusDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_mapplutusdatatoplutusdata_free(ptr));
/**
*/
export class MapPlutusDataToPlutusData {

    static __wrap(ptr) {
        const obj = Object.create(MapPlutusDataToPlutusData.prototype);
        obj.ptr = ptr;
        MapPlutusDataToPlutusDataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MapPlutusDataToPlutusDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapplutusdatatoplutusdata_free(ptr);
    }
    /**
    * @returns {MapPlutusDataToPlutusData}
    */
    static new() {
        const ret = wasm.mapplutusdatatoplutusdata_new();
        return MapPlutusDataToPlutusData.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.mapplutusdatatoplutusdata_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {PlutusData} key
    * @param {PlutusData} value
    * @returns {PlutusData | undefined}
    */
    insert(key, value) {
        _assertClass(key, PlutusData);
        _assertClass(value, PlutusData);
        const ret = wasm.mapplutusdatatoplutusdata_insert(this.ptr, key.ptr, value.ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
    /**
    * @param {PlutusData} key
    * @returns {PlutusData | undefined}
    */
    get(key) {
        _assertClass(key, PlutusData);
        const ret = wasm.mapplutusdatatoplutusdata_get(this.ptr, key.ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
    /**
    * @returns {PlutusDataList}
    */
    keys() {
        const ret = wasm.mapplutusdatatoplutusdata_keys(this.ptr);
        return PlutusDataList.__wrap(ret);
    }
}

const MapRewardAccountToCoinFinalization = new FinalizationRegistry(ptr => wasm.__wbg_maprewardaccounttocoin_free(ptr));
/**
*/
export class MapRewardAccountToCoin {

    static __wrap(ptr) {
        const obj = Object.create(MapRewardAccountToCoin.prototype);
        obj.ptr = ptr;
        MapRewardAccountToCoinFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MapRewardAccountToCoinFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_maprewardaccounttocoin_free(ptr);
    }
    /**
    * @returns {MapRewardAccountToCoin}
    */
    static new() {
        const ret = wasm.maprewardaccounttocoin_new();
        return MapRewardAccountToCoin.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.maprewardaccounttocoin_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {RewardAddress} key
    * @param {bigint} value
    * @returns {bigint | undefined}
    */
    insert(key, value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key, RewardAddress);
            wasm.maprewardaccounttocoin_insert(retptr, this.ptr, key.ptr, value);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {RewardAddress} key
    * @returns {bigint | undefined}
    */
    get(key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key, RewardAddress);
            wasm.maprewardaccounttocoin_get(retptr, this.ptr, key.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {RewardAccountList}
    */
    keys() {
        const ret = wasm.maprewardaccounttocoin_keys(this.ptr);
        return RewardAccountList.__wrap(ret);
    }
}

const MapStakeCredentialToDeltaCoinFinalization = new FinalizationRegistry(ptr => wasm.__wbg_mapstakecredentialtodeltacoin_free(ptr));
/**
*/
export class MapStakeCredentialToDeltaCoin {

    static __wrap(ptr) {
        const obj = Object.create(MapStakeCredentialToDeltaCoin.prototype);
        obj.ptr = ptr;
        MapStakeCredentialToDeltaCoinFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MapStakeCredentialToDeltaCoinFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapstakecredentialtodeltacoin_free(ptr);
    }
    /**
    * @returns {MapStakeCredentialToDeltaCoin}
    */
    static new() {
        const ret = wasm.mapstakecredentialtodeltacoin_new();
        return MapStakeCredentialToDeltaCoin.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.mapstakecredentialtodeltacoin_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {Credential} key
    * @param {Int} value
    * @returns {Int | undefined}
    */
    insert(key, value) {
        _assertClass(key, Credential);
        _assertClass(value, Int);
        const ret = wasm.mapstakecredentialtodeltacoin_insert(this.ptr, key.ptr, value.ptr);
        return ret === 0 ? undefined : Int.__wrap(ret);
    }
    /**
    * @param {Credential} key
    * @returns {Int | undefined}
    */
    get(key) {
        _assertClass(key, Credential);
        const ret = wasm.mapstakecredentialtodeltacoin_get(this.ptr, key.ptr);
        return ret === 0 ? undefined : Int.__wrap(ret);
    }
    /**
    * @returns {StakeCredentialList}
    */
    keys() {
        const ret = wasm.mapstakecredentialtodeltacoin_keys(this.ptr);
        return StakeCredentialList.__wrap(ret);
    }
}

const MapTransactionIndexToAuxiliaryDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_maptransactionindextoauxiliarydata_free(ptr));
/**
*/
export class MapTransactionIndexToAuxiliaryData {

    static __wrap(ptr) {
        const obj = Object.create(MapTransactionIndexToAuxiliaryData.prototype);
        obj.ptr = ptr;
        MapTransactionIndexToAuxiliaryDataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MapTransactionIndexToAuxiliaryDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_maptransactionindextoauxiliarydata_free(ptr);
    }
    /**
    * @returns {MapTransactionIndexToAuxiliaryData}
    */
    static new() {
        const ret = wasm.maptransactionindextoauxiliarydata_new();
        return MapTransactionIndexToAuxiliaryData.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.maptransactionindextoauxiliarydata_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} key
    * @param {AuxiliaryData} value
    * @returns {AuxiliaryData | undefined}
    */
    insert(key, value) {
        _assertClass(value, AuxiliaryData);
        const ret = wasm.maptransactionindextoauxiliarydata_insert(this.ptr, key, value.ptr);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
    /**
    * @param {number} key
    * @returns {AuxiliaryData | undefined}
    */
    get(key) {
        const ret = wasm.maptransactionindextoauxiliarydata_get(this.ptr, key);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
    /**
    * @returns {Uint16Array}
    */
    keys() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.maptransactionindextoauxiliarydata_keys(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU16FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 2);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const MapTransactionMetadatumToTransactionMetadatumFinalization = new FinalizationRegistry(ptr => wasm.__wbg_maptransactionmetadatumtotransactionmetadatum_free(ptr));
/**
*/
export class MapTransactionMetadatumToTransactionMetadatum {

    static __wrap(ptr) {
        const obj = Object.create(MapTransactionMetadatumToTransactionMetadatum.prototype);
        obj.ptr = ptr;
        MapTransactionMetadatumToTransactionMetadatumFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MapTransactionMetadatumToTransactionMetadatumFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_maptransactionmetadatumtotransactionmetadatum_free(ptr);
    }
    /**
    * @returns {MapTransactionMetadatumToTransactionMetadatum}
    */
    static new() {
        const ret = wasm.maptransactionmetadatumtotransactionmetadatum_new();
        return MapTransactionMetadatumToTransactionMetadatum.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.maptransactionmetadatumtotransactionmetadatum_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {TransactionMetadatum} key
    * @param {TransactionMetadatum} value
    * @returns {TransactionMetadatum | undefined}
    */
    insert(key, value) {
        _assertClass(key, TransactionMetadatum);
        _assertClass(value, TransactionMetadatum);
        const ret = wasm.maptransactionmetadatumtotransactionmetadatum_insert(this.ptr, key.ptr, value.ptr);
        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
    }
    /**
    * @param {TransactionMetadatum} key
    * @returns {TransactionMetadatum | undefined}
    */
    get(key) {
        _assertClass(key, TransactionMetadatum);
        const ret = wasm.maptransactionmetadatumtotransactionmetadatum_get(this.ptr, key.ptr);
        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
    }
    /**
    * @returns {TransactionMetadatumList}
    */
    keys() {
        const ret = wasm.maptransactionmetadatumtotransactionmetadatum_keys(this.ptr);
        return TransactionMetadatumList.__wrap(ret);
    }
}

const MetadataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_metadata_free(ptr));
/**
*/
export class Metadata {

    static __wrap(ptr) {
        const obj = Object.create(Metadata.prototype);
        obj.ptr = ptr;
        MetadataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_metadata_free(ptr);
    }
    /**
    * @returns {Metadata}
    */
    static new() {
        const ret = wasm.metadata_new();
        return Metadata.__wrap(ret);
    }
    /**
    * How many metadatum labels there are.
    * @returns {number}
    */
    len() {
        const ret = wasm.metadata_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * Replaces all metadatums of a given label, if any exist.
    * @param {bigint} key
    * @param {TransactionMetadatum} value
    */
    set(key, value) {
        _assertClass(value, TransactionMetadatum);
        wasm.metadata_set(this.ptr, key, value.ptr);
    }
    /**
    * Gets the Metadatum corresponding to a given label, if it exists.
    * Note: In the case of duplicate labels this only returns the first metadatum.
    * This is an extremely rare occurence on-chain but can happen.
    * @param {bigint} label
    * @returns {TransactionMetadatum | undefined}
    */
    get(label) {
        const ret = wasm.metadata_get(this.ptr, label);
        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
    }
    /**
    * In the extremely unlikely situation there are duplicate labels, this gets all of a single label
    * @param {bigint} label
    * @returns {TransactionMetadatumList | undefined}
    */
    get_all(label) {
        const ret = wasm.metadata_get_all(this.ptr, label);
        return ret === 0 ? undefined : TransactionMetadatumList.__wrap(ret);
    }
    /**
    * @returns {TransactionMetadatumLabels}
    */
    labels() {
        const ret = wasm.metadata_labels(this.ptr);
        return TransactionMetadatumLabels.__wrap(ret);
    }
}

const MetadatumListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_metadatumlist_free(ptr));
/**
*/
export class MetadatumList {

    static __wrap(ptr) {
        const obj = Object.create(MetadatumList.prototype);
        obj.ptr = ptr;
        MetadatumListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MetadatumListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_metadatumlist_free(ptr);
    }
    /**
    * @returns {MetadatumList}
    */
    static new() {
        const ret = wasm.metadatumlist_new();
        return MetadatumList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.metadatumlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {TransactionMetadatum}
    */
    get(index) {
        const ret = wasm.metadatumlist_get(this.ptr, index);
        return TransactionMetadatum.__wrap(ret);
    }
    /**
    * @param {TransactionMetadatum} elem
    */
    add(elem) {
        _assertClass(elem, TransactionMetadatum);
        wasm.metadatumlist_add(this.ptr, elem.ptr);
    }
}

const MetadatumMapFinalization = new FinalizationRegistry(ptr => wasm.__wbg_metadatummap_free(ptr));
/**
*/
export class MetadatumMap {

    static __wrap(ptr) {
        const obj = Object.create(MetadatumMap.prototype);
        obj.ptr = ptr;
        MetadatumMapFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MetadatumMapFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_metadatummap_free(ptr);
    }
    /**
    * @returns {MetadatumMap}
    */
    static new() {
        const ret = wasm.metadatummap_new();
        return MetadatumMap.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.metadatummap_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * Replaces all metadatums of a given key, if any exist.
    * @param {TransactionMetadatum} key
    * @param {TransactionMetadatum} value
    */
    set(key, value) {
        _assertClass(key, TransactionMetadatum);
        _assertClass(value, TransactionMetadatum);
        wasm.metadatummap_set(this.ptr, key.ptr, value.ptr);
    }
    /**
    * Gets the Metadatum corresponding to a given key, if it exists.
    * Note: In the case of duplicate keys this only returns the first metadatum.
    * This is an extremely rare occurence (2 total on mainnet) on-chain but can happen.
    * @param {TransactionMetadatum} key
    * @returns {TransactionMetadatum | undefined}
    */
    get(key) {
        _assertClass(key, TransactionMetadatum);
        const ret = wasm.metadatummap_get(this.ptr, key.ptr);
        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
    }
    /**
    * In the extremely unlikely situation there are duplicate keys, this gets all of a single key
    * @param {TransactionMetadatum} key
    * @returns {TransactionMetadatumList | undefined}
    */
    get_all(key) {
        _assertClass(key, TransactionMetadatum);
        const ret = wasm.metadatummap_get_all(this.ptr, key.ptr);
        return ret === 0 ? undefined : TransactionMetadatumList.__wrap(ret);
    }
    /**
    * @returns {MetadatumList}
    */
    keys() {
        const ret = wasm.metadatummap_keys(this.ptr);
        return MetadatumList.__wrap(ret);
    }
}

const MintFinalization = new FinalizationRegistry(ptr => wasm.__wbg_mint_free(ptr));
/**
*/
export class Mint {

    static __wrap(ptr) {
        const obj = Object.create(Mint.prototype);
        obj.ptr = ptr;
        MintFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MintFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mint_free(ptr);
    }
    /**
    * @returns {Mint}
    */
    static new() {
        const ret = wasm.mint_new();
        return Mint.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    policy_count() {
        const ret = wasm.mint_policy_count(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {ScriptHash} policy_id
    * @param {MapAssetNameToNonZeroInt64} assets
    * @returns {MapAssetNameToNonZeroInt64 | undefined}
    */
    insert_assets(policy_id, assets) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(assets, MapAssetNameToNonZeroInt64);
        const ret = wasm.mint_insert_assets(this.ptr, policy_id.ptr, assets.ptr);
        return ret === 0 ? undefined : MapAssetNameToNonZeroInt64.__wrap(ret);
    }
    /**
    * @param {ScriptHash} key
    * @returns {MapAssetNameToNonZeroInt64 | undefined}
    */
    get_assets(key) {
        _assertClass(key, ScriptHash);
        const ret = wasm.mint_get_assets(this.ptr, key.ptr);
        return ret === 0 ? undefined : MapAssetNameToNonZeroInt64.__wrap(ret);
    }
    /**
    * Get the value of policy_id:asset_name if it exists.
    * @param {ScriptHash} policy_id
    * @param {AssetName} asset
    * @returns {bigint | undefined}
    */
    get(policy_id, asset) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(policy_id, ScriptHash);
            _assertClass(asset, AssetName);
            wasm.mint_get(retptr, this.ptr, policy_id.ptr, asset.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Set the value of policy_id:asset_name to value.
    * Returns the previous value, or None if it didn't exist
    * @param {ScriptHash} policy_id
    * @param {AssetName} asset
    * @param {bigint} value
    * @returns {bigint | undefined}
    */
    set(policy_id, asset, value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(policy_id, ScriptHash);
            _assertClass(asset, AssetName);
            wasm.mint_set(retptr, this.ptr, policy_id.ptr, asset.ptr, value);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {PolicyIdList}
    */
    keys() {
        const ret = wasm.mint_keys(this.ptr);
        return PolicyIdList.__wrap(ret);
    }
    /**
    * Adds two mints together, checking value bounds.
    * Does not modify self, and instead returns the result.
    * @param {Mint} rhs
    * @returns {Mint}
    */
    checked_add(rhs) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(rhs, Mint);
            wasm.mint_checked_add(retptr, this.ptr, rhs.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Mint.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Subtracts rhs from this mint.
    * This does not modify self, and instead returns the result.
    * @param {Mint} rhs
    * @returns {Mint}
    */
    checked_sub(rhs) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(rhs, Mint);
            wasm.mint_checked_sub(retptr, this.ptr, rhs.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Mint.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the multiasset where only positive (minting) entries are present
    * @returns {MultiAsset}
    */
    as_positive_multiasset() {
        const ret = wasm.mint_as_positive_multiasset(this.ptr);
        return MultiAsset.__wrap(ret);
    }
    /**
    * Returns the multiasset where only negative (burning) entries are present
    * @returns {MultiAsset}
    */
    as_negative_multiasset() {
        const ret = wasm.mint_as_negative_multiasset(this.ptr);
        return MultiAsset.__wrap(ret);
    }
}

const MintBuilderResultFinalization = new FinalizationRegistry(ptr => wasm.__wbg_mintbuilderresult_free(ptr));
/**
*/
export class MintBuilderResult {

    static __wrap(ptr) {
        const obj = Object.create(MintBuilderResult.prototype);
        obj.ptr = ptr;
        MintBuilderResultFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MintBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mintbuilderresult_free(ptr);
    }
}

const MultiAssetFinalization = new FinalizationRegistry(ptr => wasm.__wbg_multiasset_free(ptr));
/**
*/
export class MultiAsset {

    static __wrap(ptr) {
        const obj = Object.create(MultiAsset.prototype);
        obj.ptr = ptr;
        MultiAssetFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MultiAssetFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_multiasset_free(ptr);
    }
    /**
    * @returns {MultiAsset}
    */
    static new() {
        const ret = wasm.multiasset_new();
        return MultiAsset.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    policy_count() {
        const ret = wasm.multiasset_policy_count(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {ScriptHash} policy_id
    * @param {MapAssetNameToCoin} assets
    * @returns {MapAssetNameToCoin | undefined}
    */
    insert_assets(policy_id, assets) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(assets, MapAssetNameToCoin);
        const ret = wasm.multiasset_insert_assets(this.ptr, policy_id.ptr, assets.ptr);
        return ret === 0 ? undefined : MapAssetNameToCoin.__wrap(ret);
    }
    /**
    * @param {ScriptHash} key
    * @returns {MapAssetNameToCoin | undefined}
    */
    get_assets(key) {
        _assertClass(key, ScriptHash);
        const ret = wasm.multiasset_get_assets(this.ptr, key.ptr);
        return ret === 0 ? undefined : MapAssetNameToCoin.__wrap(ret);
    }
    /**
    * Get the value of policy_id:asset_name if it exists.
    * @param {ScriptHash} policy_id
    * @param {AssetName} asset
    * @returns {bigint | undefined}
    */
    get(policy_id, asset) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(policy_id, ScriptHash);
            _assertClass(asset, AssetName);
            wasm.multiasset_get(retptr, this.ptr, policy_id.ptr, asset.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Set the value of policy_id:asset_name to value.
    * Returns the previous value, or None if it didn't exist
    * @param {ScriptHash} policy_id
    * @param {AssetName} asset
    * @param {bigint} value
    * @returns {bigint | undefined}
    */
    set(policy_id, asset, value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(policy_id, ScriptHash);
            _assertClass(asset, AssetName);
            wasm.multiasset_set(retptr, this.ptr, policy_id.ptr, asset.ptr, value);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {PolicyIdList}
    */
    keys() {
        const ret = wasm.multiasset_keys(this.ptr);
        return PolicyIdList.__wrap(ret);
    }
    /**
    * Adds to multiassets together, checking value bounds.
    * Does not modify self, and instead returns the result.
    * @param {MultiAsset} rhs
    * @returns {MultiAsset}
    */
    checked_add(rhs) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(rhs, MultiAsset);
            wasm.multiasset_checked_add(retptr, this.ptr, rhs.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return MultiAsset.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Subtracts rhs from this multiasset.
    * This does not modify self, and instead returns the result.
    * If this would cause there to be fewer than 0 of a given asset
    * an error will be returned.
    * Use clamped_sub if you need to only try to remove assets when they exist
    * and ignore them when they don't.
    * @param {MultiAsset} rhs
    * @returns {MultiAsset}
    */
    checked_sub(rhs) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(rhs, MultiAsset);
            wasm.multiasset_checked_sub(retptr, this.ptr, rhs.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return MultiAsset.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Sybtracts rhs from this multiasset.
    * If this would cause there to be 0 or fewer of a given asset
    * it will simply be removed entirely from the result.
    * @param {MultiAsset} rhs
    * @returns {MultiAsset}
    */
    clamped_sub(rhs) {
        _assertClass(rhs, MultiAsset);
        const ret = wasm.multiasset_clamped_sub(this.ptr, rhs.ptr);
        return MultiAsset.__wrap(ret);
    }
}

const MultiHostNameFinalization = new FinalizationRegistry(ptr => wasm.__wbg_multihostname_free(ptr));
/**
*/
export class MultiHostName {

    static __wrap(ptr) {
        const obj = Object.create(MultiHostName.prototype);
        obj.ptr = ptr;
        MultiHostNameFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MultiHostNameFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_multihostname_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.multihostname_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {MultiHostName}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.multihostname_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return MultiHostName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.multihostname_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {MultiHostName}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.multihostname_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return MultiHostName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.multihostname_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.multihostname_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {MultiHostName}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.multihostname_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return MultiHostName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {DnsName}
    */
    dns_name() {
        const ret = wasm.multihostname_dns_name(this.ptr);
        return DnsName.__wrap(ret);
    }
    /**
    * @param {DnsName} dns_name
    * @returns {MultiHostName}
    */
    static new(dns_name) {
        _assertClass(dns_name, DnsName);
        const ret = wasm.multihostname_new(dns_name.ptr);
        return MultiHostName.__wrap(ret);
    }
}

const NativeScriptFinalization = new FinalizationRegistry(ptr => wasm.__wbg_nativescript_free(ptr));
/**
*/
export class NativeScript {

    static __wrap(ptr) {
        const obj = Object.create(NativeScript.prototype);
        obj.ptr = ptr;
        NativeScriptFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NativeScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nativescript_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nativescript_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {NativeScript}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.nativescript_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NativeScript.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nativescript_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {NativeScript}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.nativescript_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NativeScript.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nativescript_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nativescript_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {NativeScript}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.nativescript_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NativeScript.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Ed25519KeyHash} ed25519_key_hash
    * @returns {NativeScript}
    */
    static new_script_pubkey(ed25519_key_hash) {
        _assertClass(ed25519_key_hash, Ed25519KeyHash);
        const ret = wasm.nativescript_new_script_pubkey(ed25519_key_hash.ptr);
        return NativeScript.__wrap(ret);
    }
    /**
    * @param {NativeScriptList} native_scripts
    * @returns {NativeScript}
    */
    static new_script_all(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.nativescript_new_script_all(native_scripts.ptr);
        return NativeScript.__wrap(ret);
    }
    /**
    * @param {NativeScriptList} native_scripts
    * @returns {NativeScript}
    */
    static new_script_any(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.nativescript_new_script_any(native_scripts.ptr);
        return NativeScript.__wrap(ret);
    }
    /**
    * @param {bigint} n
    * @param {NativeScriptList} native_scripts
    * @returns {NativeScript}
    */
    static new_script_n_of_k(n, native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.nativescript_new_script_n_of_k(n, native_scripts.ptr);
        return NativeScript.__wrap(ret);
    }
    /**
    * @param {bigint} before
    * @returns {NativeScript}
    */
    static new_script_invalid_before(before) {
        const ret = wasm.nativescript_new_script_invalid_before(before);
        return NativeScript.__wrap(ret);
    }
    /**
    * @param {bigint} after
    * @returns {NativeScript}
    */
    static new_script_invalid_hereafter(after) {
        const ret = wasm.nativescript_new_script_invalid_hereafter(after);
        return NativeScript.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.nativescript_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {ScriptPubkey | undefined}
    */
    as_script_pubkey() {
        const ret = wasm.nativescript_as_script_pubkey(this.ptr);
        return ret === 0 ? undefined : ScriptPubkey.__wrap(ret);
    }
    /**
    * @returns {ScriptAll | undefined}
    */
    as_script_all() {
        const ret = wasm.nativescript_as_script_all(this.ptr);
        return ret === 0 ? undefined : ScriptAll.__wrap(ret);
    }
    /**
    * @returns {ScriptAny | undefined}
    */
    as_script_any() {
        const ret = wasm.nativescript_as_script_any(this.ptr);
        return ret === 0 ? undefined : ScriptAny.__wrap(ret);
    }
    /**
    * @returns {ScriptNOfK | undefined}
    */
    as_script_n_of_k() {
        const ret = wasm.nativescript_as_script_n_of_k(this.ptr);
        return ret === 0 ? undefined : ScriptNOfK.__wrap(ret);
    }
    /**
    * @returns {ScriptInvalidBefore | undefined}
    */
    as_script_invalid_before() {
        const ret = wasm.nativescript_as_script_invalid_before(this.ptr);
        return ret === 0 ? undefined : ScriptInvalidBefore.__wrap(ret);
    }
    /**
    * @returns {ScriptInvalidHereafter | undefined}
    */
    as_script_invalid_hereafter() {
        const ret = wasm.nativescript_as_script_invalid_hereafter(this.ptr);
        return ret === 0 ? undefined : ScriptInvalidHereafter.__wrap(ret);
    }
    /**
    * Returns an array of unique Ed25519KeyHashes
    * contained within this script recursively on any depth level.
    * The order of the keys in the result is not determined in any way.
    * @returns {Ed25519KeyHashList}
    */
    get_required_signers() {
        const ret = wasm.nativescript_get_required_signers(this.ptr);
        return Ed25519KeyHashList.__wrap(ret);
    }
    /**
    * @returns {ScriptHash}
    */
    hash() {
        const ret = wasm.nativescript_hash(this.ptr);
        return ScriptHash.__wrap(ret);
    }
}

const NativeScriptListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_nativescriptlist_free(ptr));
/**
*/
export class NativeScriptList {

    static __wrap(ptr) {
        const obj = Object.create(NativeScriptList.prototype);
        obj.ptr = ptr;
        NativeScriptListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NativeScriptListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nativescriptlist_free(ptr);
    }
    /**
    * @returns {NativeScriptList}
    */
    static new() {
        const ret = wasm.certificatelist_new();
        return NativeScriptList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.nativescriptlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {NativeScript}
    */
    get(index) {
        const ret = wasm.nativescriptlist_get(this.ptr, index);
        return NativeScript.__wrap(ret);
    }
    /**
    * @param {NativeScript} elem
    */
    add(elem) {
        _assertClass(elem, NativeScript);
        wasm.nativescriptlist_add(this.ptr, elem.ptr);
    }
}

const NativeScriptWitnessInfoFinalization = new FinalizationRegistry(ptr => wasm.__wbg_nativescriptwitnessinfo_free(ptr));
/**
*/
export class NativeScriptWitnessInfo {

    static __wrap(ptr) {
        const obj = Object.create(NativeScriptWitnessInfo.prototype);
        obj.ptr = ptr;
        NativeScriptWitnessInfoFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NativeScriptWitnessInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nativescriptwitnessinfo_free(ptr);
    }
    /**
    * Unsure which keys will sign, but you know the exact number to save on tx fee
    * @param {number} num
    * @returns {NativeScriptWitnessInfo}
    */
    static num_signatures(num) {
        const ret = wasm.nativescriptwitnessinfo_num_signatures(num);
        return NativeScriptWitnessInfo.__wrap(ret);
    }
    /**
    * This native script will be witnessed by exactly these keys
    * @param {Ed25519KeyHashList} vkeys
    * @returns {NativeScriptWitnessInfo}
    */
    static vkeys(vkeys) {
        _assertClass(vkeys, Ed25519KeyHashList);
        const ret = wasm.nativescriptwitnessinfo_vkeys(vkeys.ptr);
        return NativeScriptWitnessInfo.__wrap(ret);
    }
    /**
    * You don't know how many keys will sign, so the maximum possible case will be assumed
    * @returns {NativeScriptWitnessInfo}
    */
    static assume_signature_count() {
        const ret = wasm.nativescriptwitnessinfo_assume_signature_count();
        return NativeScriptWitnessInfo.__wrap(ret);
    }
}

const NetworkIdFinalization = new FinalizationRegistry(ptr => wasm.__wbg_networkid_free(ptr));
/**
*/
export class NetworkId {

    static __wrap(ptr) {
        const obj = Object.create(NetworkId.prototype);
        obj.ptr = ptr;
        NetworkIdFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NetworkIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_networkid_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.networkid_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {NetworkId}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.networkid_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NetworkId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.networkid_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {NetworkId}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.networkid_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NetworkId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.networkid_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.networkid_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {NetworkId}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.networkid_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NetworkId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} network
    * @returns {NetworkId}
    */
    static new(network) {
        const ret = wasm.networkid_new(network);
        return NetworkId.__wrap(ret);
    }
    /**
    * @returns {NetworkId}
    */
    static mainnet() {
        const ret = wasm.networkid_mainnet();
        return NetworkId.__wrap(ret);
    }
    /**
    * @returns {NetworkId}
    */
    static testnet() {
        const ret = wasm.networkid_testnet();
        return NetworkId.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    network() {
        const ret = wasm.networkid_network(this.ptr);
        return BigInt.asUintN(64, ret);
    }
}

const NetworkInfoFinalization = new FinalizationRegistry(ptr => wasm.__wbg_networkinfo_free(ptr));
/**
*/
export class NetworkInfo {

    static __wrap(ptr) {
        const obj = Object.create(NetworkInfo.prototype);
        obj.ptr = ptr;
        NetworkInfoFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NetworkInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_networkinfo_free(ptr);
    }
    /**
    * @param {number} network_id
    * @param {ProtocolMagic} protocol_magic
    * @returns {NetworkInfo}
    */
    static new(network_id, protocol_magic) {
        _assertClass(protocol_magic, ProtocolMagic);
        const ret = wasm.networkinfo_new(network_id, protocol_magic.ptr);
        return NetworkInfo.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    network_id() {
        const ret = wasm.networkinfo_network_id(this.ptr);
        return ret;
    }
    /**
    * @returns {ProtocolMagic}
    */
    protocol_magic() {
        const ret = wasm.networkinfo_protocol_magic(this.ptr);
        return ProtocolMagic.__wrap(ret);
    }
    /**
    * This is the old testnet - most likely you want to use preview()/preprod()
    * @returns {NetworkInfo}
    */
    static testnet() {
        const ret = wasm.networkinfo_testnet();
        return NetworkInfo.__wrap(ret);
    }
    /**
    * @returns {NetworkInfo}
    */
    static mainnet() {
        const ret = wasm.networkinfo_mainnet();
        return NetworkInfo.__wrap(ret);
    }
    /**
    * @returns {NetworkInfo}
    */
    static preview() {
        const ret = wasm.networkinfo_preview();
        return NetworkInfo.__wrap(ret);
    }
    /**
    * @returns {NetworkInfo}
    */
    static preprod() {
        const ret = wasm.networkinfo_preprod();
        return NetworkInfo.__wrap(ret);
    }
    /**
    * @returns {NetworkInfo}
    */
    static sancho_testnet() {
        const ret = wasm.networkinfo_sancho_testnet();
        return NetworkInfo.__wrap(ret);
    }
}

const NewCommitteeFinalization = new FinalizationRegistry(ptr => wasm.__wbg_newcommittee_free(ptr));
/**
*/
export class NewCommittee {

    static __wrap(ptr) {
        const obj = Object.create(NewCommittee.prototype);
        obj.ptr = ptr;
        NewCommitteeFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NewCommitteeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_newcommittee_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.newcommittee_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {NewCommittee}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.newcommittee_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NewCommittee.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.newcommittee_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {NewCommittee}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.newcommittee_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NewCommittee.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.newcommittee_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.newcommittee_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {NewCommittee}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.newcommittee_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NewCommittee.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {GovActionId | undefined}
    */
    action_id() {
        const ret = wasm.newcommittee_action_id(this.ptr);
        return ret === 0 ? undefined : GovActionId.__wrap(ret);
    }
    /**
    * @returns {CommitteeColdCredentialList}
    */
    cold_credentials() {
        const ret = wasm.newcommittee_cold_credentials(this.ptr);
        return CommitteeColdCredentialList.__wrap(ret);
    }
    /**
    * @returns {Committee}
    */
    committee() {
        const ret = wasm.newcommittee_committee(this.ptr);
        return Committee.__wrap(ret);
    }
    /**
    * @param {GovActionId | undefined} action_id
    * @param {CommitteeColdCredentialList} cold_credentials
    * @param {Committee} committee
    * @returns {NewCommittee}
    */
    static new(action_id, cold_credentials, committee) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.ptr;
            action_id.ptr = 0;
        }
        _assertClass(cold_credentials, CommitteeColdCredentialList);
        _assertClass(committee, Committee);
        const ret = wasm.newcommittee_new(ptr0, cold_credentials.ptr, committee.ptr);
        return NewCommittee.__wrap(ret);
    }
}

const NewConstitutionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_newconstitution_free(ptr));
/**
*/
export class NewConstitution {

    static __wrap(ptr) {
        const obj = Object.create(NewConstitution.prototype);
        obj.ptr = ptr;
        NewConstitutionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NewConstitutionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_newconstitution_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.newconstitution_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {NewConstitution}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.newconstitution_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NewConstitution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.newconstitution_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {NewConstitution}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.newconstitution_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NewConstitution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.newconstitution_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.newconstitution_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {NewConstitution}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.newconstitution_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NewConstitution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {GovActionId | undefined}
    */
    action_id() {
        const ret = wasm.newconstitution_action_id(this.ptr);
        return ret === 0 ? undefined : GovActionId.__wrap(ret);
    }
    /**
    * @returns {Constitution}
    */
    constitution() {
        const ret = wasm.newconstitution_constitution(this.ptr);
        return Constitution.__wrap(ret);
    }
    /**
    * @param {GovActionId | undefined} action_id
    * @param {Constitution} constitution
    * @returns {NewConstitution}
    */
    static new(action_id, constitution) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.ptr;
            action_id.ptr = 0;
        }
        _assertClass(constitution, Constitution);
        const ret = wasm.newconstitution_new(ptr0, constitution.ptr);
        return NewConstitution.__wrap(ret);
    }
}

const NoConfidenceFinalization = new FinalizationRegistry(ptr => wasm.__wbg_noconfidence_free(ptr));
/**
*/
export class NoConfidence {

    static __wrap(ptr) {
        const obj = Object.create(NoConfidence.prototype);
        obj.ptr = ptr;
        NoConfidenceFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NoConfidenceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_noconfidence_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.noconfidence_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {NoConfidence}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.noconfidence_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NoConfidence.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.noconfidence_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {NoConfidence}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.noconfidence_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NoConfidence.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.noconfidence_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.noconfidence_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {NoConfidence}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.noconfidence_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NoConfidence.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {GovActionId | undefined}
    */
    action_id() {
        const ret = wasm.noconfidence_action_id(this.ptr);
        return ret === 0 ? undefined : GovActionId.__wrap(ret);
    }
    /**
    * @param {GovActionId | undefined} action_id
    * @returns {NoConfidence}
    */
    static new(action_id) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.ptr;
            action_id.ptr = 0;
        }
        const ret = wasm.noconfidence_new(ptr0);
        return NoConfidence.__wrap(ret);
    }
}

const NonceFinalization = new FinalizationRegistry(ptr => wasm.__wbg_nonce_free(ptr));
/**
*/
export class Nonce {

    static __wrap(ptr) {
        const obj = Object.create(Nonce.prototype);
        obj.ptr = ptr;
        NonceFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NonceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nonce_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nonce_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Nonce}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.nonce_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nonce.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nonce_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Nonce}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.nonce_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nonce.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nonce_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nonce_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Nonce}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.nonce_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nonce.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Nonce}
    */
    static new_identity() {
        const ret = wasm.nonce_new_identity();
        return Nonce.__wrap(ret);
    }
    /**
    * @param {NonceHash} hash
    * @returns {Nonce}
    */
    static new_hash(hash) {
        _assertClass(hash, NonceHash);
        const ret = wasm.nonce_new_hash(hash.ptr);
        return Nonce.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.nonce_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {NonceHash | undefined}
    */
    as_hash() {
        const ret = wasm.nonce_as_hash(this.ptr);
        return ret === 0 ? undefined : NonceHash.__wrap(ret);
    }
}

const NonceHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_noncehash_free(ptr));
/**
*/
export class NonceHash {

    static __wrap(ptr) {
        const obj = Object.create(NonceHash.prototype);
        obj.ptr = ptr;
        NonceHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NonceHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_noncehash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.noncehash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.noncehash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.noncehash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {NonceHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.noncehash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NonceHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {NonceHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.noncehash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NonceHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {NonceHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.noncehash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NonceHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const OperationalCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_operationalcert_free(ptr));
/**
*/
export class OperationalCert {

    static __wrap(ptr) {
        const obj = Object.create(OperationalCert.prototype);
        obj.ptr = ptr;
        OperationalCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        OperationalCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_operationalcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.operationalcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {OperationalCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.operationalcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return OperationalCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.operationalcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {OperationalCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.operationalcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return OperationalCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.operationalcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.operationalcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {OperationalCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.operationalcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return OperationalCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {KESVkey}
    */
    hot_vkey() {
        const ret = wasm.operationalcert_hot_vkey(this.ptr);
        return KESVkey.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    sequence_number() {
        const ret = wasm.operationalcert_sequence_number(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {bigint}
    */
    kes_period() {
        const ret = wasm.operationalcert_kes_period(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {Ed25519Signature}
    */
    sigma() {
        const ret = wasm.operationalcert_sigma(this.ptr);
        return Ed25519Signature.__wrap(ret);
    }
    /**
    * @param {KESVkey} hot_vkey
    * @param {bigint} sequence_number
    * @param {bigint} kes_period
    * @param {Ed25519Signature} sigma
    * @returns {OperationalCert}
    */
    static new(hot_vkey, sequence_number, kes_period, sigma) {
        _assertClass(hot_vkey, KESVkey);
        _assertClass(sigma, Ed25519Signature);
        const ret = wasm.operationalcert_new(hot_vkey.ptr, sequence_number, kes_period, sigma.ptr);
        return OperationalCert.__wrap(ret);
    }
}

const ParameterChangeActionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_parameterchangeaction_free(ptr));
/**
*/
export class ParameterChangeAction {

    static __wrap(ptr) {
        const obj = Object.create(ParameterChangeAction.prototype);
        obj.ptr = ptr;
        ParameterChangeActionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ParameterChangeActionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_parameterchangeaction_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.parameterchangeaction_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ParameterChangeAction}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.parameterchangeaction_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ParameterChangeAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.parameterchangeaction_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ParameterChangeAction}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.parameterchangeaction_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ParameterChangeAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.parameterchangeaction_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.parameterchangeaction_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ParameterChangeAction}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.parameterchangeaction_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ParameterChangeAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {GovActionId | undefined}
    */
    gov_action_id() {
        const ret = wasm.parameterchangeaction_gov_action_id(this.ptr);
        return ret === 0 ? undefined : GovActionId.__wrap(ret);
    }
    /**
    * @returns {ProtocolParamUpdate}
    */
    protocol_param_update() {
        const ret = wasm.parameterchangeaction_protocol_param_update(this.ptr);
        return ProtocolParamUpdate.__wrap(ret);
    }
    /**
    * @param {GovActionId | undefined} gov_action_id
    * @param {ProtocolParamUpdate} protocol_param_update
    * @returns {ParameterChangeAction}
    */
    static new(gov_action_id, protocol_param_update) {
        let ptr0 = 0;
        if (!isLikeNone(gov_action_id)) {
            _assertClass(gov_action_id, GovActionId);
            ptr0 = gov_action_id.ptr;
            gov_action_id.ptr = 0;
        }
        _assertClass(protocol_param_update, ProtocolParamUpdate);
        const ret = wasm.parameterchangeaction_new(ptr0, protocol_param_update.ptr);
        return ParameterChangeAction.__wrap(ret);
    }
}

const PartialPlutusWitnessFinalization = new FinalizationRegistry(ptr => wasm.__wbg_partialplutuswitness_free(ptr));
/**
* A partial Plutus witness
* It contains all the information needed to witness the Plutus script execution
* except for the redeemer tag and index
* Note: no datum is attached because only input script types have datums
*/
export class PartialPlutusWitness {

    static __wrap(ptr) {
        const obj = Object.create(PartialPlutusWitness.prototype);
        obj.ptr = ptr;
        PartialPlutusWitnessFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PartialPlutusWitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_partialplutuswitness_free(ptr);
    }
    /**
    * @param {PlutusScriptWitness} script
    * @param {PlutusData} data
    * @returns {PartialPlutusWitness}
    */
    static new(script, data) {
        _assertClass(script, PlutusScriptWitness);
        _assertClass(data, PlutusData);
        const ret = wasm.partialplutuswitness_new(script.ptr, data.ptr);
        return PartialPlutusWitness.__wrap(ret);
    }
    /**
    * @returns {PlutusScriptWitness}
    */
    script() {
        const ret = wasm.partialplutuswitness_script(this.ptr);
        return PlutusScriptWitness.__wrap(ret);
    }
    /**
    * @returns {PlutusData}
    */
    data() {
        const ret = wasm.partialplutuswitness_data(this.ptr);
        return PlutusData.__wrap(ret);
    }
}

const PlutusDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusdata_free(ptr));
/**
*/
export class PlutusData {

    static __wrap(ptr) {
        const obj = Object.create(PlutusData.prototype);
        obj.ptr = ptr;
        PlutusDataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusdata_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusdata_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {PlutusData}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusdata_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusdata_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {PlutusData}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusdata_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusdata_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusdata_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {PlutusData}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusdata_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {ConstrPlutusData} constr_plutus_data
    * @returns {PlutusData}
    */
    static new_constr_plutus_data(constr_plutus_data) {
        _assertClass(constr_plutus_data, ConstrPlutusData);
        const ret = wasm.plutusdata_new_constr_plutus_data(constr_plutus_data.ptr);
        return PlutusData.__wrap(ret);
    }
    /**
    * @param {PlutusMap} map
    * @returns {PlutusData}
    */
    static new_map(map) {
        _assertClass(map, PlutusMap);
        const ret = wasm.plutusdata_new_map(map.ptr);
        return PlutusData.__wrap(ret);
    }
    /**
    * @param {PlutusDataList} list
    * @returns {PlutusData}
    */
    static new_list(list) {
        _assertClass(list, PlutusDataList);
        const ret = wasm.plutusdata_new_list(list.ptr);
        return PlutusData.__wrap(ret);
    }
    /**
    * @param {BigInteger} big_int
    * @returns {PlutusData}
    */
    static new_integer(big_int) {
        _assertClass(big_int, BigInteger);
        const ret = wasm.plutusdata_new_integer(big_int.ptr);
        return PlutusData.__wrap(ret);
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {PlutusData}
    */
    static new_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusdata_new_bytes(ptr0, len0);
        return PlutusData.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.plutusdata_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {ConstrPlutusData | undefined}
    */
    as_constr_plutus_data() {
        const ret = wasm.plutusdata_as_constr_plutus_data(this.ptr);
        return ret === 0 ? undefined : ConstrPlutusData.__wrap(ret);
    }
    /**
    * @returns {PlutusMap | undefined}
    */
    as_map() {
        const ret = wasm.plutusdata_as_map(this.ptr);
        return ret === 0 ? undefined : PlutusMap.__wrap(ret);
    }
    /**
    * @returns {PlutusDataList | undefined}
    */
    as_list() {
        const ret = wasm.plutusdata_as_list(this.ptr);
        return ret === 0 ? undefined : PlutusDataList.__wrap(ret);
    }
    /**
    * @returns {BigInteger | undefined}
    */
    as_integer() {
        const ret = wasm.plutusdata_as_integer(this.ptr);
        return ret === 0 ? undefined : BigInteger.__wrap(ret);
    }
    /**
    * @returns {Uint8Array | undefined}
    */
    as_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusdata_as_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const PlutusDataListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusdatalist_free(ptr));
/**
*/
export class PlutusDataList {

    static __wrap(ptr) {
        const obj = Object.create(PlutusDataList.prototype);
        obj.ptr = ptr;
        PlutusDataListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusDataListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusdatalist_free(ptr);
    }
    /**
    * @returns {PlutusDataList}
    */
    static new() {
        const ret = wasm.certificatelist_new();
        return PlutusDataList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.plutusdatalist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {PlutusData}
    */
    get(index) {
        const ret = wasm.plutusdatalist_get(this.ptr, index);
        return PlutusData.__wrap(ret);
    }
    /**
    * @param {PlutusData} elem
    */
    add(elem) {
        _assertClass(elem, PlutusData);
        wasm.plutusdatalist_add(this.ptr, elem.ptr);
    }
}

const PlutusMapFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusmap_free(ptr));
/**
*/
export class PlutusMap {

    static __wrap(ptr) {
        const obj = Object.create(PlutusMap.prototype);
        obj.ptr = ptr;
        PlutusMapFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusMapFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusmap_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusmap_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {PlutusMap}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusmap_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusMap.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusmap_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {PlutusMap}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusmap_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusMap.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {PlutusMap}
    */
    static new() {
        const ret = wasm.plutusmap_new();
        return PlutusMap.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.plutusmap_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {boolean}
    */
    is_empty() {
        const ret = wasm.plutusmap_is_empty(this.ptr);
        return ret !== 0;
    }
    /**
    * Replaces all datums of a given key, if any exist.
    * @param {PlutusData} key
    * @param {PlutusData} value
    */
    set(key, value) {
        _assertClass(key, PlutusData);
        _assertClass(value, PlutusData);
        wasm.plutusmap_set(this.ptr, key.ptr, value.ptr);
    }
    /**
    * Gets the plutus datum corresponding to a given key, if it exists.
    * Note: In the case of duplicate keys this only returns the first datum.
    * This is an extremely rare occurence on-chain but can happen.
    * @param {PlutusData} key
    * @returns {PlutusData | undefined}
    */
    get(key) {
        _assertClass(key, PlutusData);
        const ret = wasm.plutusmap_get(this.ptr, key.ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
    /**
    * In the extremely unlikely situation there are duplicate keys, this gets all of a single key
    * @param {PlutusData} key
    * @returns {PlutusDataList | undefined}
    */
    get_all(key) {
        _assertClass(key, PlutusData);
        const ret = wasm.plutusmap_get_all(this.ptr, key.ptr);
        return ret === 0 ? undefined : PlutusDataList.__wrap(ret);
    }
    /**
    * @returns {PlutusDataList}
    */
    keys() {
        const ret = wasm.plutusmap_keys(this.ptr);
        return PlutusDataList.__wrap(ret);
    }
}

const PlutusScriptFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusscript_free(ptr));
/**
* Version-agnostic Plutus script
*/
export class PlutusScript {

    static __wrap(ptr) {
        const obj = Object.create(PlutusScript.prototype);
        obj.ptr = ptr;
        PlutusScriptFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusscript_free(ptr);
    }
    /**
    * @param {PlutusV1Script} script
    * @returns {PlutusScript}
    */
    static from_v1(script) {
        _assertClass(script, PlutusV1Script);
        const ret = wasm.plutusscript_from_v1(script.ptr);
        return PlutusScript.__wrap(ret);
    }
    /**
    * @param {PlutusV2Script} script
    * @returns {PlutusScript}
    */
    static from_v2(script) {
        _assertClass(script, PlutusV2Script);
        const ret = wasm.plutusscript_from_v2(script.ptr);
        return PlutusScript.__wrap(ret);
    }
    /**
    * @param {PlutusV3Script} script
    * @returns {PlutusScript}
    */
    static from_v3(script) {
        _assertClass(script, PlutusV3Script);
        const ret = wasm.plutusscript_from_v3(script.ptr);
        return PlutusScript.__wrap(ret);
    }
    /**
    * @returns {ScriptHash}
    */
    hash() {
        const ret = wasm.plutusscript_hash(this.ptr);
        return ScriptHash.__wrap(ret);
    }
    /**
    * @returns {PlutusV1Script | undefined}
    */
    as_v1() {
        const ret = wasm.plutusscript_as_v1(this.ptr);
        return ret === 0 ? undefined : PlutusV1Script.__wrap(ret);
    }
    /**
    * @returns {PlutusV2Script | undefined}
    */
    as_v2() {
        const ret = wasm.plutusscript_as_v2(this.ptr);
        return ret === 0 ? undefined : PlutusV2Script.__wrap(ret);
    }
    /**
    * @returns {PlutusV3Script | undefined}
    */
    as_v3() {
        const ret = wasm.plutusscript_as_v3(this.ptr);
        return ret === 0 ? undefined : PlutusV3Script.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    version() {
        const ret = wasm.plutusscript_version(this.ptr);
        return ret >>> 0;
    }
}

const PlutusScriptWitnessFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusscriptwitness_free(ptr));
/**
*/
export class PlutusScriptWitness {

    static __wrap(ptr) {
        const obj = Object.create(PlutusScriptWitness.prototype);
        obj.ptr = ptr;
        PlutusScriptWitnessFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusScriptWitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusscriptwitness_free(ptr);
    }
    /**
    * @param {PlutusScript} script
    * @returns {PlutusScriptWitness}
    */
    static new_script(script) {
        _assertClass(script, PlutusScript);
        const ret = wasm.plutusscriptwitness_new_script(script.ptr);
        return PlutusScriptWitness.__wrap(ret);
    }
    /**
    * @param {ScriptHash} hash
    * @returns {PlutusScriptWitness}
    */
    static new_ref(hash) {
        _assertClass(hash, ScriptHash);
        const ret = wasm.plutusscriptwitness_new_ref(hash.ptr);
        return PlutusScriptWitness.__wrap(ret);
    }
    /**
    * @returns {ScriptHash}
    */
    hash() {
        const ret = wasm.plutusscriptwitness_hash(this.ptr);
        return ScriptHash.__wrap(ret);
    }
}

const PlutusV1ScriptFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusv1script_free(ptr));
/**
*/
export class PlutusV1Script {

    static __wrap(ptr) {
        const obj = Object.create(PlutusV1Script.prototype);
        obj.ptr = ptr;
        PlutusV1ScriptFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusV1ScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv1script_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv1script_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {PlutusV1Script}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusv1script_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusV1Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv1script_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {PlutusV1Script}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusv1script_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusV1Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv1script_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv1script_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {PlutusV1Script}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusv1script_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusV1Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv1script_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {ScriptHash}
    */
    hash() {
        const ret = wasm.plutusv1script_hash(this.ptr);
        return ScriptHash.__wrap(ret);
    }
}

const PlutusV1ScriptListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusv1scriptlist_free(ptr));
/**
*/
export class PlutusV1ScriptList {

    static __wrap(ptr) {
        const obj = Object.create(PlutusV1ScriptList.prototype);
        obj.ptr = ptr;
        PlutusV1ScriptListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusV1ScriptListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv1scriptlist_free(ptr);
    }
    /**
    * @returns {PlutusV1ScriptList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return PlutusV1ScriptList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.plutusv1scriptlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {PlutusV1Script}
    */
    get(index) {
        const ret = wasm.plutusv1scriptlist_get(this.ptr, index);
        return PlutusV1Script.__wrap(ret);
    }
    /**
    * @param {PlutusV1Script} elem
    */
    add(elem) {
        _assertClass(elem, PlutusV1Script);
        wasm.plutusv1scriptlist_add(this.ptr, elem.ptr);
    }
}

const PlutusV2ScriptFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusv2script_free(ptr));
/**
*/
export class PlutusV2Script {

    static __wrap(ptr) {
        const obj = Object.create(PlutusV2Script.prototype);
        obj.ptr = ptr;
        PlutusV2ScriptFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusV2ScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv2script_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv2script_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {PlutusV2Script}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusv2script_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusV2Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv2script_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {PlutusV2Script}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusv2script_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusV2Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv2script_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv2script_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {PlutusV2Script}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusv2script_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusV2Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv2script_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {ScriptHash}
    */
    hash() {
        const ret = wasm.plutusv2script_hash(this.ptr);
        return ScriptHash.__wrap(ret);
    }
}

const PlutusV2ScriptListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusv2scriptlist_free(ptr));
/**
*/
export class PlutusV2ScriptList {

    static __wrap(ptr) {
        const obj = Object.create(PlutusV2ScriptList.prototype);
        obj.ptr = ptr;
        PlutusV2ScriptListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusV2ScriptListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv2scriptlist_free(ptr);
    }
    /**
    * @returns {PlutusV2ScriptList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return PlutusV2ScriptList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.plutusv2scriptlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {PlutusV2Script}
    */
    get(index) {
        const ret = wasm.plutusv2scriptlist_get(this.ptr, index);
        return PlutusV2Script.__wrap(ret);
    }
    /**
    * @param {PlutusV2Script} elem
    */
    add(elem) {
        _assertClass(elem, PlutusV2Script);
        wasm.plutusv2scriptlist_add(this.ptr, elem.ptr);
    }
}

const PlutusV3ScriptFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusv3script_free(ptr));
/**
*/
export class PlutusV3Script {

    static __wrap(ptr) {
        const obj = Object.create(PlutusV3Script.prototype);
        obj.ptr = ptr;
        PlutusV3ScriptFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusV3ScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv3script_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv3script_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {PlutusV3Script}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusv3script_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusV3Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv3script_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {PlutusV3Script}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusv3script_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusV3Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv3script_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv3script_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {PlutusV3Script}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.plutusv3script_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PlutusV3Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.plutusv3script_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const PlutusV3ScriptListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_plutusv3scriptlist_free(ptr));
/**
*/
export class PlutusV3ScriptList {

    static __wrap(ptr) {
        const obj = Object.create(PlutusV3ScriptList.prototype);
        obj.ptr = ptr;
        PlutusV3ScriptListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PlutusV3ScriptListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv3scriptlist_free(ptr);
    }
    /**
    * @returns {PlutusV3ScriptList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return PlutusV3ScriptList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.plutusv3scriptlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {PlutusV3Script}
    */
    get(index) {
        const ret = wasm.plutusv3scriptlist_get(this.ptr, index);
        return PlutusV3Script.__wrap(ret);
    }
    /**
    * @param {PlutusV3Script} elem
    */
    add(elem) {
        _assertClass(elem, PlutusV3Script);
        wasm.plutusv3scriptlist_add(this.ptr, elem.ptr);
    }
}

const PointerFinalization = new FinalizationRegistry(ptr => wasm.__wbg_pointer_free(ptr));
/**
*/
export class Pointer {

    static __wrap(ptr) {
        const obj = Object.create(Pointer.prototype);
        obj.ptr = ptr;
        PointerFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PointerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pointer_free(ptr);
    }
}

const PointerAddressFinalization = new FinalizationRegistry(ptr => wasm.__wbg_pointeraddress_free(ptr));
/**
*/
export class PointerAddress {

    static __wrap(ptr) {
        const obj = Object.create(PointerAddress.prototype);
        obj.ptr = ptr;
        PointerAddressFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PointerAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pointeraddress_free(ptr);
    }
    /**
    * @param {number} network
    * @param {Credential} payment
    * @param {Pointer} stake
    * @returns {PointerAddress}
    */
    static new(network, payment, stake) {
        _assertClass(payment, Credential);
        _assertClass(stake, Pointer);
        const ret = wasm.pointeraddress_new(network, payment.ptr, stake.ptr);
        return PointerAddress.__wrap(ret);
    }
    /**
    * @returns {Address}
    */
    to_address() {
        const ret = wasm.pointeraddress_to_address(this.ptr);
        return Address.__wrap(ret);
    }
    /**
    * @param {Address} address
    * @returns {PointerAddress | undefined}
    */
    static from_address(address) {
        _assertClass(address, Address);
        const ret = wasm.pointeraddress_from_address(address.ptr);
        return ret === 0 ? undefined : PointerAddress.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    network_id() {
        const ret = wasm.pointeraddress_network_id(this.ptr);
        return ret;
    }
    /**
    * @returns {Credential}
    */
    payment() {
        const ret = wasm.pointeraddress_payment(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {Pointer}
    */
    stake() {
        const ret = wasm.pointeraddress_stake(this.ptr);
        return Pointer.__wrap(ret);
    }
}

const PolicyIdListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_policyidlist_free(ptr));
/**
*/
export class PolicyIdList {

    static __wrap(ptr) {
        const obj = Object.create(PolicyIdList.prototype);
        obj.ptr = ptr;
        PolicyIdListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PolicyIdListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_policyidlist_free(ptr);
    }
    /**
    * @returns {PolicyIdList}
    */
    static new() {
        const ret = wasm.ed25519keyhashlist_new();
        return PolicyIdList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.policyidlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {ScriptHash}
    */
    get(index) {
        const ret = wasm.policyidlist_get(this.ptr, index);
        return ScriptHash.__wrap(ret);
    }
    /**
    * @param {ScriptHash} elem
    */
    add(elem) {
        _assertClass(elem, ScriptHash);
        wasm.policyidlist_add(this.ptr, elem.ptr);
    }
}

const PoolMetadataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_poolmetadata_free(ptr));
/**
*/
export class PoolMetadata {

    static __wrap(ptr) {
        const obj = Object.create(PoolMetadata.prototype);
        obj.ptr = ptr;
        PoolMetadataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PoolMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolmetadata_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolmetadata_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {PoolMetadata}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolmetadata_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolMetadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolmetadata_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {PoolMetadata}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolmetadata_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolMetadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolmetadata_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolmetadata_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {PoolMetadata}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolmetadata_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolMetadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Url}
    */
    url() {
        const ret = wasm.poolmetadata_url(this.ptr);
        return Url.__wrap(ret);
    }
    /**
    * @returns {PoolMetadataHash}
    */
    pool_metadata_hash() {
        const ret = wasm.poolmetadata_pool_metadata_hash(this.ptr);
        return PoolMetadataHash.__wrap(ret);
    }
    /**
    * @param {Url} url
    * @param {PoolMetadataHash} pool_metadata_hash
    * @returns {PoolMetadata}
    */
    static new(url, pool_metadata_hash) {
        _assertClass(url, Url);
        _assertClass(pool_metadata_hash, PoolMetadataHash);
        const ret = wasm.poolmetadata_new(url.ptr, pool_metadata_hash.ptr);
        return PoolMetadata.__wrap(ret);
    }
}

const PoolMetadataHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_poolmetadatahash_free(ptr));
/**
*/
export class PoolMetadataHash {

    static __wrap(ptr) {
        const obj = Object.create(PoolMetadataHash.prototype);
        obj.ptr = ptr;
        PoolMetadataHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PoolMetadataHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolmetadatahash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolmetadatahash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolmetadatahash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolmetadatahash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {PoolMetadataHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolmetadatahash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolMetadataHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {PoolMetadataHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolmetadatahash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolMetadataHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {PoolMetadataHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolmetadatahash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolMetadataHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const PoolParamsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_poolparams_free(ptr));
/**
*/
export class PoolParams {

    static __wrap(ptr) {
        const obj = Object.create(PoolParams.prototype);
        obj.ptr = ptr;
        PoolParamsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PoolParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolparams_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolparams_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {PoolParams}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolparams_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolParams.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolparams_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {PoolParams}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolparams_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolParams.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolparams_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolparams_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {PoolParams}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolparams_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolParams.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Ed25519KeyHash}
    */
    operator() {
        const ret = wasm.poolparams_operator(this.ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @returns {VRFKeyHash}
    */
    vrf_keyhash() {
        const ret = wasm.poolparams_vrf_keyhash(this.ptr);
        return VRFKeyHash.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    pledge() {
        const ret = wasm.poolparams_pledge(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {bigint}
    */
    cost() {
        const ret = wasm.poolparams_cost(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {UnitInterval}
    */
    margin() {
        const ret = wasm.poolparams_margin(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {RewardAddress}
    */
    reward_account() {
        const ret = wasm.poolparams_reward_account(this.ptr);
        return RewardAddress.__wrap(ret);
    }
    /**
    * @returns {Ed25519KeyHashList}
    */
    pool_owners() {
        const ret = wasm.poolparams_pool_owners(this.ptr);
        return Ed25519KeyHashList.__wrap(ret);
    }
    /**
    * @returns {RelayList}
    */
    relays() {
        const ret = wasm.poolparams_relays(this.ptr);
        return RelayList.__wrap(ret);
    }
    /**
    * @returns {PoolMetadata | undefined}
    */
    pool_metadata() {
        const ret = wasm.poolparams_pool_metadata(this.ptr);
        return ret === 0 ? undefined : PoolMetadata.__wrap(ret);
    }
    /**
    * @param {Ed25519KeyHash} operator
    * @param {VRFKeyHash} vrf_keyhash
    * @param {bigint} pledge
    * @param {bigint} cost
    * @param {UnitInterval} margin
    * @param {RewardAddress} reward_account
    * @param {Ed25519KeyHashList} pool_owners
    * @param {RelayList} relays
    * @param {PoolMetadata | undefined} pool_metadata
    * @returns {PoolParams}
    */
    static new(operator, vrf_keyhash, pledge, cost, margin, reward_account, pool_owners, relays, pool_metadata) {
        _assertClass(operator, Ed25519KeyHash);
        _assertClass(vrf_keyhash, VRFKeyHash);
        _assertClass(margin, UnitInterval);
        _assertClass(reward_account, RewardAddress);
        _assertClass(pool_owners, Ed25519KeyHashList);
        _assertClass(relays, RelayList);
        let ptr0 = 0;
        if (!isLikeNone(pool_metadata)) {
            _assertClass(pool_metadata, PoolMetadata);
            ptr0 = pool_metadata.ptr;
            pool_metadata.ptr = 0;
        }
        const ret = wasm.poolparams_new(operator.ptr, vrf_keyhash.ptr, pledge, cost, margin.ptr, reward_account.ptr, pool_owners.ptr, relays.ptr, ptr0);
        return PoolParams.__wrap(ret);
    }
}

const PoolRegistrationFinalization = new FinalizationRegistry(ptr => wasm.__wbg_poolregistration_free(ptr));
/**
*/
export class PoolRegistration {

    static __wrap(ptr) {
        const obj = Object.create(PoolRegistration.prototype);
        obj.ptr = ptr;
        PoolRegistrationFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PoolRegistrationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolregistration_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolregistration_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {PoolRegistration}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolregistration_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolRegistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolregistration_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {PoolRegistration}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolregistration_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolRegistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolregistration_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolregistration_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {PoolRegistration}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolregistration_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolRegistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {PoolParams}
    */
    pool_params() {
        const ret = wasm.poolregistration_pool_params(this.ptr);
        return PoolParams.__wrap(ret);
    }
    /**
    * @param {PoolParams} pool_params
    * @returns {PoolRegistration}
    */
    static new(pool_params) {
        _assertClass(pool_params, PoolParams);
        const ret = wasm.poolregistration_new(pool_params.ptr);
        return PoolRegistration.__wrap(ret);
    }
}

const PoolRetirementFinalization = new FinalizationRegistry(ptr => wasm.__wbg_poolretirement_free(ptr));
/**
*/
export class PoolRetirement {

    static __wrap(ptr) {
        const obj = Object.create(PoolRetirement.prototype);
        obj.ptr = ptr;
        PoolRetirementFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PoolRetirementFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolretirement_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolretirement_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {PoolRetirement}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolretirement_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolRetirement.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolretirement_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {PoolRetirement}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolretirement_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolRetirement.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolretirement_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolretirement_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {PoolRetirement}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolretirement_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolRetirement.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Ed25519KeyHash}
    */
    pool() {
        const ret = wasm.poolretirement_pool(this.ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    epoch() {
        const ret = wasm.poolretirement_epoch(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {Ed25519KeyHash} pool
    * @param {bigint} epoch
    * @returns {PoolRetirement}
    */
    static new(pool, epoch) {
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.poolretirement_new(pool.ptr, epoch);
        return PoolRetirement.__wrap(ret);
    }
}

const PoolVotingThresholdsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_poolvotingthresholds_free(ptr));
/**
*/
export class PoolVotingThresholds {

    static __wrap(ptr) {
        const obj = Object.create(PoolVotingThresholds.prototype);
        obj.ptr = ptr;
        PoolVotingThresholdsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PoolVotingThresholdsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolvotingthresholds_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolvotingthresholds_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {PoolVotingThresholds}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolvotingthresholds_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolVotingThresholds.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolvotingthresholds_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {PoolVotingThresholds}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolvotingthresholds_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolVotingThresholds.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolvotingthresholds_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.poolvotingthresholds_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {PoolVotingThresholds}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.poolvotingthresholds_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PoolVotingThresholds.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {UnitInterval}
    */
    motion_no_confidence() {
        const ret = wasm.poolvotingthresholds_motion_no_confidence(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    committee_normal() {
        const ret = wasm.poolvotingthresholds_committee_normal(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    committee_no_confidence() {
        const ret = wasm.poolvotingthresholds_committee_no_confidence(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @returns {UnitInterval}
    */
    hard_fork_initiation() {
        const ret = wasm.poolvotingthresholds_hard_fork_initiation(this.ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
    * @param {UnitInterval} motion_no_confidence
    * @param {UnitInterval} committee_normal
    * @param {UnitInterval} committee_no_confidence
    * @param {UnitInterval} hard_fork_initiation
    * @returns {PoolVotingThresholds}
    */
    static new(motion_no_confidence, committee_normal, committee_no_confidence, hard_fork_initiation) {
        _assertClass(motion_no_confidence, UnitInterval);
        _assertClass(committee_normal, UnitInterval);
        _assertClass(committee_no_confidence, UnitInterval);
        _assertClass(hard_fork_initiation, UnitInterval);
        const ret = wasm.poolvotingthresholds_new(motion_no_confidence.ptr, committee_normal.ptr, committee_no_confidence.ptr, hard_fork_initiation.ptr);
        return PoolVotingThresholds.__wrap(ret);
    }
}

const PrivateKeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_privatekey_free(ptr));
/**
*/
export class PrivateKey {

    static __wrap(ptr) {
        const obj = Object.create(PrivateKey.prototype);
        obj.ptr = ptr;
        PrivateKeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PrivateKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_privatekey_free(ptr);
    }
    /**
    * @returns {PublicKey}
    */
    to_public() {
        const ret = wasm.privatekey_to_public(this.ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {PrivateKey}
    */
    static generate_ed25519() {
        const ret = wasm.privatekey_generate_ed25519();
        return PrivateKey.__wrap(ret);
    }
    /**
    * @returns {PrivateKey}
    */
    static generate_ed25519extended() {
        const ret = wasm.privatekey_generate_ed25519extended();
        return PrivateKey.__wrap(ret);
    }
    /**
    * Get private key from its bech32 representation
    * ```javascript
    * PrivateKey.from_bech32(&#39;ed25519_sk1ahfetf02qwwg4dkq7mgp4a25lx5vh9920cr5wnxmpzz9906qvm8qwvlts0&#39;);
    * ```
    * For an extended 25519 key
    * ```javascript
    * PrivateKey.from_bech32(&#39;ed25519e_sk1gqwl4szuwwh6d0yk3nsqcc6xxc3fpvjlevgwvt60df59v8zd8f8prazt8ln3lmz096ux3xvhhvm3ca9wj2yctdh3pnw0szrma07rt5gl748fp&#39;);
    * ```
    * @param {string} bech32_str
    * @returns {PrivateKey}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.privatekey_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PrivateKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_bech32() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.privatekey_to_bech32(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.privatekey_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {PrivateKey}
    */
    static from_extended_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.privatekey_from_extended_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PrivateKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {PrivateKey}
    */
    static from_normal_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.privatekey_from_normal_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PrivateKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} message
    * @returns {Ed25519Signature}
    */
    sign(message) {
        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.privatekey_sign(this.ptr, ptr0, len0);
        return Ed25519Signature.__wrap(ret);
    }
}

const ProposalProcedureFinalization = new FinalizationRegistry(ptr => wasm.__wbg_proposalprocedure_free(ptr));
/**
*/
export class ProposalProcedure {

    static __wrap(ptr) {
        const obj = Object.create(ProposalProcedure.prototype);
        obj.ptr = ptr;
        ProposalProcedureFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ProposalProcedureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proposalprocedure_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proposalprocedure_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ProposalProcedure}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.proposalprocedure_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProposalProcedure.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proposalprocedure_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ProposalProcedure}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.proposalprocedure_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProposalProcedure.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proposalprocedure_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proposalprocedure_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ProposalProcedure}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.proposalprocedure_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProposalProcedure.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    deposit() {
        const ret = wasm.proposalprocedure_deposit(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {RewardAddress}
    */
    reward_account() {
        const ret = wasm.proposalprocedure_reward_account(this.ptr);
        return RewardAddress.__wrap(ret);
    }
    /**
    * @returns {GovAction}
    */
    gov_action() {
        const ret = wasm.proposalprocedure_gov_action(this.ptr);
        return GovAction.__wrap(ret);
    }
    /**
    * @returns {Anchor}
    */
    anchor() {
        const ret = wasm.proposalprocedure_anchor(this.ptr);
        return Anchor.__wrap(ret);
    }
    /**
    * @param {bigint} deposit
    * @param {RewardAddress} reward_account
    * @param {GovAction} gov_action
    * @param {Anchor} anchor
    * @returns {ProposalProcedure}
    */
    static new(deposit, reward_account, gov_action, anchor) {
        _assertClass(reward_account, RewardAddress);
        _assertClass(gov_action, GovAction);
        _assertClass(anchor, Anchor);
        const ret = wasm.proposalprocedure_new(deposit, reward_account.ptr, gov_action.ptr, anchor.ptr);
        return ProposalProcedure.__wrap(ret);
    }
}

const ProposalProcedureListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_proposalprocedurelist_free(ptr));
/**
*/
export class ProposalProcedureList {

    static __wrap(ptr) {
        const obj = Object.create(ProposalProcedureList.prototype);
        obj.ptr = ptr;
        ProposalProcedureListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ProposalProcedureListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proposalprocedurelist_free(ptr);
    }
    /**
    * @returns {ProposalProcedureList}
    */
    static new() {
        const ret = wasm.certificatelist_new();
        return ProposalProcedureList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.proposalprocedurelist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {ProposalProcedure}
    */
    get(index) {
        const ret = wasm.proposalprocedurelist_get(this.ptr, index);
        return ProposalProcedure.__wrap(ret);
    }
    /**
    * @param {ProposalProcedure} elem
    */
    add(elem) {
        _assertClass(elem, ProposalProcedure);
        wasm.proposalprocedurelist_add(this.ptr, elem.ptr);
    }
}

const ProtocolMagicFinalization = new FinalizationRegistry(ptr => wasm.__wbg_protocolmagic_free(ptr));
/**
*/
export class ProtocolMagic {

    static __wrap(ptr) {
        const obj = Object.create(ProtocolMagic.prototype);
        obj.ptr = ptr;
        ProtocolMagicFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ProtocolMagicFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_protocolmagic_free(ptr);
    }
    /**
    * @param {number} pm
    * @returns {ProtocolMagic}
    */
    static new(pm) {
        const ret = wasm.protocolmagic_new(pm);
        return ProtocolMagic.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    to_int() {
        const ret = wasm.protocolmagic_to_int(this.ptr);
        return ret >>> 0;
    }
}

const ProtocolParamUpdateFinalization = new FinalizationRegistry(ptr => wasm.__wbg_protocolparamupdate_free(ptr));
/**
*/
export class ProtocolParamUpdate {

    static __wrap(ptr) {
        const obj = Object.create(ProtocolParamUpdate.prototype);
        obj.ptr = ptr;
        ProtocolParamUpdateFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ProtocolParamUpdateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_protocolparamupdate_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ProtocolParamUpdate}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.protocolparamupdate_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProtocolParamUpdate.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ProtocolParamUpdate}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.protocolparamupdate_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProtocolParamUpdate.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ProtocolParamUpdate}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.protocolparamupdate_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProtocolParamUpdate.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} minfee_a
    */
    set_minfee_a(minfee_a) {
        wasm.protocolparamupdate_set_minfee_a(this.ptr, minfee_a);
    }
    /**
    * @returns {bigint | undefined}
    */
    minfee_a() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_minfee_a(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} minfee_b
    */
    set_minfee_b(minfee_b) {
        wasm.protocolparamupdate_set_minfee_b(this.ptr, minfee_b);
    }
    /**
    * @returns {bigint | undefined}
    */
    minfee_b() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_minfee_b(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} max_block_body_size
    */
    set_max_block_body_size(max_block_body_size) {
        wasm.protocolparamupdate_set_max_block_body_size(this.ptr, max_block_body_size);
    }
    /**
    * @returns {bigint | undefined}
    */
    max_block_body_size() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_max_block_body_size(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} max_transaction_size
    */
    set_max_transaction_size(max_transaction_size) {
        wasm.protocolparamupdate_set_max_transaction_size(this.ptr, max_transaction_size);
    }
    /**
    * @returns {bigint | undefined}
    */
    max_transaction_size() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_max_transaction_size(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} max_block_header_size
    */
    set_max_block_header_size(max_block_header_size) {
        wasm.protocolparamupdate_set_max_block_header_size(this.ptr, max_block_header_size);
    }
    /**
    * @returns {bigint | undefined}
    */
    max_block_header_size() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_max_block_header_size(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} key_deposit
    */
    set_key_deposit(key_deposit) {
        wasm.protocolparamupdate_set_key_deposit(this.ptr, key_deposit);
    }
    /**
    * @returns {bigint | undefined}
    */
    key_deposit() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_key_deposit(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} pool_deposit
    */
    set_pool_deposit(pool_deposit) {
        wasm.protocolparamupdate_set_pool_deposit(this.ptr, pool_deposit);
    }
    /**
    * @returns {bigint | undefined}
    */
    pool_deposit() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_pool_deposit(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} maximum_epoch
    */
    set_maximum_epoch(maximum_epoch) {
        wasm.protocolparamupdate_set_maximum_epoch(this.ptr, maximum_epoch);
    }
    /**
    * @returns {bigint | undefined}
    */
    maximum_epoch() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_maximum_epoch(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} n_opt
    */
    set_n_opt(n_opt) {
        wasm.protocolparamupdate_set_n_opt(this.ptr, n_opt);
    }
    /**
    * @returns {bigint | undefined}
    */
    n_opt() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_n_opt(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Rational} pool_pledge_influence
    */
    set_pool_pledge_influence(pool_pledge_influence) {
        _assertClass(pool_pledge_influence, Rational);
        wasm.protocolparamupdate_set_pool_pledge_influence(this.ptr, pool_pledge_influence.ptr);
    }
    /**
    * @returns {Rational | undefined}
    */
    pool_pledge_influence() {
        const ret = wasm.protocolparamupdate_pool_pledge_influence(this.ptr);
        return ret === 0 ? undefined : Rational.__wrap(ret);
    }
    /**
    * @param {UnitInterval} expansion_rate
    */
    set_expansion_rate(expansion_rate) {
        _assertClass(expansion_rate, UnitInterval);
        wasm.protocolparamupdate_set_expansion_rate(this.ptr, expansion_rate.ptr);
    }
    /**
    * @returns {UnitInterval | undefined}
    */
    expansion_rate() {
        const ret = wasm.protocolparamupdate_expansion_rate(this.ptr);
        return ret === 0 ? undefined : UnitInterval.__wrap(ret);
    }
    /**
    * @param {UnitInterval} treasury_growth_rate
    */
    set_treasury_growth_rate(treasury_growth_rate) {
        _assertClass(treasury_growth_rate, UnitInterval);
        wasm.protocolparamupdate_set_treasury_growth_rate(this.ptr, treasury_growth_rate.ptr);
    }
    /**
    * @returns {UnitInterval | undefined}
    */
    treasury_growth_rate() {
        const ret = wasm.protocolparamupdate_treasury_growth_rate(this.ptr);
        return ret === 0 ? undefined : UnitInterval.__wrap(ret);
    }
    /**
    * @param {bigint} min_pool_cost
    */
    set_min_pool_cost(min_pool_cost) {
        wasm.protocolparamupdate_set_min_pool_cost(this.ptr, min_pool_cost);
    }
    /**
    * @returns {bigint | undefined}
    */
    min_pool_cost() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_min_pool_cost(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} ada_per_utxo_byte
    */
    set_ada_per_utxo_byte(ada_per_utxo_byte) {
        wasm.protocolparamupdate_set_ada_per_utxo_byte(this.ptr, ada_per_utxo_byte);
    }
    /**
    * @returns {bigint | undefined}
    */
    ada_per_utxo_byte() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_ada_per_utxo_byte(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {CostModels} cost_models_for_script_languages
    */
    set_cost_models_for_script_languages(cost_models_for_script_languages) {
        _assertClass(cost_models_for_script_languages, CostModels);
        wasm.protocolparamupdate_set_cost_models_for_script_languages(this.ptr, cost_models_for_script_languages.ptr);
    }
    /**
    * @returns {CostModels | undefined}
    */
    cost_models_for_script_languages() {
        const ret = wasm.protocolparamupdate_cost_models_for_script_languages(this.ptr);
        return ret === 0 ? undefined : CostModels.__wrap(ret);
    }
    /**
    * @param {ExUnitPrices} execution_costs
    */
    set_execution_costs(execution_costs) {
        _assertClass(execution_costs, ExUnitPrices);
        wasm.protocolparamupdate_set_execution_costs(this.ptr, execution_costs.ptr);
    }
    /**
    * @returns {ExUnitPrices | undefined}
    */
    execution_costs() {
        const ret = wasm.protocolparamupdate_execution_costs(this.ptr);
        return ret === 0 ? undefined : ExUnitPrices.__wrap(ret);
    }
    /**
    * @param {ExUnits} max_tx_ex_units
    */
    set_max_tx_ex_units(max_tx_ex_units) {
        _assertClass(max_tx_ex_units, ExUnits);
        wasm.protocolparamupdate_set_max_tx_ex_units(this.ptr, max_tx_ex_units.ptr);
    }
    /**
    * @returns {ExUnits | undefined}
    */
    max_tx_ex_units() {
        const ret = wasm.protocolparamupdate_max_tx_ex_units(this.ptr);
        return ret === 0 ? undefined : ExUnits.__wrap(ret);
    }
    /**
    * @param {ExUnits} max_block_ex_units
    */
    set_max_block_ex_units(max_block_ex_units) {
        _assertClass(max_block_ex_units, ExUnits);
        wasm.protocolparamupdate_set_max_block_ex_units(this.ptr, max_block_ex_units.ptr);
    }
    /**
    * @returns {ExUnits | undefined}
    */
    max_block_ex_units() {
        const ret = wasm.protocolparamupdate_max_block_ex_units(this.ptr);
        return ret === 0 ? undefined : ExUnits.__wrap(ret);
    }
    /**
    * @param {bigint} max_value_size
    */
    set_max_value_size(max_value_size) {
        wasm.protocolparamupdate_set_max_value_size(this.ptr, max_value_size);
    }
    /**
    * @returns {bigint | undefined}
    */
    max_value_size() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_max_value_size(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} collateral_percentage
    */
    set_collateral_percentage(collateral_percentage) {
        wasm.protocolparamupdate_set_collateral_percentage(this.ptr, collateral_percentage);
    }
    /**
    * @returns {bigint | undefined}
    */
    collateral_percentage() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_collateral_percentage(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} max_collateral_inputs
    */
    set_max_collateral_inputs(max_collateral_inputs) {
        wasm.protocolparamupdate_set_max_collateral_inputs(this.ptr, max_collateral_inputs);
    }
    /**
    * @returns {bigint | undefined}
    */
    max_collateral_inputs() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_max_collateral_inputs(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {PoolVotingThresholds} pool_voting_thresholds
    */
    set_pool_voting_thresholds(pool_voting_thresholds) {
        _assertClass(pool_voting_thresholds, PoolVotingThresholds);
        wasm.protocolparamupdate_set_pool_voting_thresholds(this.ptr, pool_voting_thresholds.ptr);
    }
    /**
    * @returns {PoolVotingThresholds | undefined}
    */
    pool_voting_thresholds() {
        const ret = wasm.protocolparamupdate_pool_voting_thresholds(this.ptr);
        return ret === 0 ? undefined : PoolVotingThresholds.__wrap(ret);
    }
    /**
    * @param {DRepVotingThresholds} d_rep_voting_thresholds
    */
    set_d_rep_voting_thresholds(d_rep_voting_thresholds) {
        _assertClass(d_rep_voting_thresholds, DRepVotingThresholds);
        wasm.protocolparamupdate_set_d_rep_voting_thresholds(this.ptr, d_rep_voting_thresholds.ptr);
    }
    /**
    * @returns {DRepVotingThresholds | undefined}
    */
    d_rep_voting_thresholds() {
        const ret = wasm.protocolparamupdate_d_rep_voting_thresholds(this.ptr);
        return ret === 0 ? undefined : DRepVotingThresholds.__wrap(ret);
    }
    /**
    * @param {bigint} min_committee_size
    */
    set_min_committee_size(min_committee_size) {
        wasm.protocolparamupdate_set_min_committee_size(this.ptr, min_committee_size);
    }
    /**
    * @returns {bigint | undefined}
    */
    min_committee_size() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_min_committee_size(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} committee_term_limit
    */
    set_committee_term_limit(committee_term_limit) {
        wasm.protocolparamupdate_set_committee_term_limit(this.ptr, committee_term_limit);
    }
    /**
    * @returns {bigint | undefined}
    */
    committee_term_limit() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_committee_term_limit(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} governance_action_validity_period
    */
    set_governance_action_validity_period(governance_action_validity_period) {
        wasm.protocolparamupdate_set_governance_action_validity_period(this.ptr, governance_action_validity_period);
    }
    /**
    * @returns {bigint | undefined}
    */
    governance_action_validity_period() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_governance_action_validity_period(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} governance_action_deposit
    */
    set_governance_action_deposit(governance_action_deposit) {
        wasm.protocolparamupdate_set_governance_action_deposit(this.ptr, governance_action_deposit);
    }
    /**
    * @returns {bigint | undefined}
    */
    governance_action_deposit() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_governance_action_deposit(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} d_rep_deposit
    */
    set_d_rep_deposit(d_rep_deposit) {
        wasm.protocolparamupdate_set_d_rep_deposit(this.ptr, d_rep_deposit);
    }
    /**
    * @returns {bigint | undefined}
    */
    d_rep_deposit() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_d_rep_deposit(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} d_rep_inactivity_period
    */
    set_d_rep_inactivity_period(d_rep_inactivity_period) {
        wasm.protocolparamupdate_set_d_rep_inactivity_period(this.ptr, d_rep_inactivity_period);
    }
    /**
    * @returns {bigint | undefined}
    */
    d_rep_inactivity_period() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolparamupdate_d_rep_inactivity_period(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {ProtocolParamUpdate}
    */
    static new() {
        const ret = wasm.protocolparamupdate_new();
        return ProtocolParamUpdate.__wrap(ret);
    }
}

const ProtocolVersionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_protocolversion_free(ptr));
/**
*/
export class ProtocolVersion {

    static __wrap(ptr) {
        const obj = Object.create(ProtocolVersion.prototype);
        obj.ptr = ptr;
        ProtocolVersionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ProtocolVersionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_protocolversion_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolversion_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ProtocolVersion}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.protocolversion_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProtocolVersion.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolversion_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ProtocolVersion}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.protocolversion_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProtocolVersion.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolversion_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protocolversion_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ProtocolVersion}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.protocolversion_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProtocolVersion.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    major() {
        const ret = wasm.protocolversion_major(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {bigint}
    */
    minor() {
        const ret = wasm.protocolversion_minor(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} major
    * @param {bigint} minor
    * @returns {ProtocolVersion}
    */
    static new(major, minor) {
        const ret = wasm.protocolversion_new(major, minor);
        return ProtocolVersion.__wrap(ret);
    }
}

const PublicKeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_publickey_free(ptr));
/**
* ED25519 key used as public key
*/
export class PublicKey {

    static __wrap(ptr) {
        const obj = Object.create(PublicKey.prototype);
        obj.ptr = ptr;
        PublicKeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_publickey_free(ptr);
    }
    /**
    * Get public key from its bech32 representation
    * Example:
    * ```javascript
    * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);
    * ```
    * @param {string} bech32_str
    * @returns {PublicKey}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.publickey_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_bech32() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.publickey_to_bech32(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.publickey_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {PublicKey}
    */
    static from_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.publickey_from_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} data
    * @param {Ed25519Signature} signature
    * @returns {boolean}
    */
    verify(data, signature) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(signature, Ed25519Signature);
        const ret = wasm.publickey_verify(this.ptr, ptr0, len0, signature.ptr);
        return ret !== 0;
    }
    /**
    * @returns {Ed25519KeyHash}
    */
    hash() {
        const ret = wasm.publickey_hash(this.ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
}

const RationalFinalization = new FinalizationRegistry(ptr => wasm.__wbg_rational_free(ptr));
/**
*/
export class Rational {

    static __wrap(ptr) {
        const obj = Object.create(Rational.prototype);
        obj.ptr = ptr;
        RationalFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RationalFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rational_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.rational_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Rational}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.rational_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Rational.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.rational_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Rational}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.rational_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Rational.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.rational_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.rational_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Rational}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.rational_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Rational.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    numerator() {
        const ret = wasm.rational_numerator(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {bigint}
    */
    denominator() {
        const ret = wasm.rational_denominator(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} numerator
    * @param {bigint} denominator
    * @returns {Rational}
    */
    static new(numerator, denominator) {
        const ret = wasm.rational_new(numerator, denominator);
        return Rational.__wrap(ret);
    }
}

const RedeemerFinalization = new FinalizationRegistry(ptr => wasm.__wbg_redeemer_free(ptr));
/**
*/
export class Redeemer {

    static __wrap(ptr) {
        const obj = Object.create(Redeemer.prototype);
        obj.ptr = ptr;
        RedeemerFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RedeemerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_redeemer_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.redeemer_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Redeemer}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.redeemer_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Redeemer.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.redeemer_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Redeemer}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.redeemer_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Redeemer.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.redeemer_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.redeemer_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Redeemer}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.redeemer_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Redeemer.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number}
    */
    tag() {
        const ret = wasm.redeemer_tag(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {bigint}
    */
    index() {
        const ret = wasm.redeemer_index(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {PlutusData}
    */
    data() {
        const ret = wasm.redeemer_data(this.ptr);
        return PlutusData.__wrap(ret);
    }
    /**
    * @returns {ExUnits}
    */
    ex_units() {
        const ret = wasm.redeemer_ex_units(this.ptr);
        return ExUnits.__wrap(ret);
    }
    /**
    * @param {number} tag
    * @param {bigint} index
    * @param {PlutusData} data
    * @param {ExUnits} ex_units
    * @returns {Redeemer}
    */
    static new(tag, index, data, ex_units) {
        _assertClass(data, PlutusData);
        _assertClass(ex_units, ExUnits);
        const ret = wasm.redeemer_new(tag, index, data.ptr, ex_units.ptr);
        return Redeemer.__wrap(ret);
    }
}

const RedeemerListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_redeemerlist_free(ptr));
/**
*/
export class RedeemerList {

    static __wrap(ptr) {
        const obj = Object.create(RedeemerList.prototype);
        obj.ptr = ptr;
        RedeemerListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RedeemerListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_redeemerlist_free(ptr);
    }
    /**
    * @returns {RedeemerList}
    */
    static new() {
        const ret = wasm.certificatelist_new();
        return RedeemerList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.redeemerlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Redeemer}
    */
    get(index) {
        const ret = wasm.redeemerlist_get(this.ptr, index);
        return Redeemer.__wrap(ret);
    }
    /**
    * @param {Redeemer} elem
    */
    add(elem) {
        _assertClass(elem, Redeemer);
        wasm.redeemerlist_add(this.ptr, elem.ptr);
    }
}

const RedeemerSetBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_redeemersetbuilder_free(ptr));
/**
* In order to calculate the index from the sorted set, "add_*" methods in this builder
* must be called along with the "add_*" methods in transaction builder.
*/
export class RedeemerSetBuilder {

    static __wrap(ptr) {
        const obj = Object.create(RedeemerSetBuilder.prototype);
        obj.ptr = ptr;
        RedeemerSetBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RedeemerSetBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_redeemersetbuilder_free(ptr);
    }
    /**
    * @returns {RedeemerSetBuilder}
    */
    static new() {
        const ret = wasm.redeemersetbuilder_new();
        return RedeemerSetBuilder.__wrap(ret);
    }
    /**
    * @returns {boolean}
    */
    is_empty() {
        const ret = wasm.redeemersetbuilder_is_empty(this.ptr);
        return ret !== 0;
    }
    /**
    * note: will override existing value if called twice with the same key
    * @param {RedeemerWitnessKey} key
    * @param {ExUnits} ex_units
    */
    update_ex_units(key, ex_units) {
        _assertClass(key, RedeemerWitnessKey);
        _assertClass(ex_units, ExUnits);
        wasm.redeemersetbuilder_update_ex_units(this.ptr, key.ptr, ex_units.ptr);
    }
    /**
    * @param {InputBuilderResult} result
    */
    add_spend(result) {
        _assertClass(result, InputBuilderResult);
        wasm.redeemersetbuilder_add_spend(this.ptr, result.ptr);
    }
    /**
    * @param {MintBuilderResult} result
    */
    add_mint(result) {
        _assertClass(result, MintBuilderResult);
        wasm.redeemersetbuilder_add_mint(this.ptr, result.ptr);
    }
    /**
    * @param {WithdrawalBuilderResult} result
    */
    add_reward(result) {
        _assertClass(result, WithdrawalBuilderResult);
        wasm.redeemersetbuilder_add_reward(this.ptr, result.ptr);
    }
    /**
    * @param {CertificateBuilderResult} result
    */
    add_cert(result) {
        _assertClass(result, CertificateBuilderResult);
        wasm.redeemersetbuilder_add_cert(this.ptr, result.ptr);
    }
    /**
    * @param {boolean} default_to_dummy_exunits
    * @returns {RedeemerList}
    */
    build(default_to_dummy_exunits) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.redeemersetbuilder_build(retptr, this.ptr, default_to_dummy_exunits);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RedeemerList.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const RedeemerWitnessKeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_redeemerwitnesskey_free(ptr));
/**
*/
export class RedeemerWitnessKey {

    static __wrap(ptr) {
        const obj = Object.create(RedeemerWitnessKey.prototype);
        obj.ptr = ptr;
        RedeemerWitnessKeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RedeemerWitnessKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_redeemerwitnesskey_free(ptr);
    }
    /**
    * @param {number} tag
    * @param {bigint} index
    * @returns {RedeemerWitnessKey}
    */
    static new(tag, index) {
        const ret = wasm.redeemerwitnesskey_new(tag, index);
        return RedeemerWitnessKey.__wrap(ret);
    }
    /**
    * @param {Redeemer} redeemer
    * @returns {RedeemerWitnessKey}
    */
    static from_redeemer(redeemer) {
        _assertClass(redeemer, Redeemer);
        const ret = wasm.redeemerwitnesskey_from_redeemer(redeemer.ptr);
        return RedeemerWitnessKey.__wrap(ret);
    }
}

const RegCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_regcert_free(ptr));
/**
*/
export class RegCert {

    static __wrap(ptr) {
        const obj = Object.create(RegCert.prototype);
        obj.ptr = ptr;
        RegCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_regcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.regcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {RegCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.regcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.regcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {RegCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.regcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.regcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.regcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {RegCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.regcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    stake_credential() {
        const ret = wasm.regcert_stake_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    coin() {
        const ret = wasm.regcert_coin(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {bigint} coin
    * @returns {RegCert}
    */
    static new(stake_credential, coin) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.regcert_new(stake_credential.ptr, coin);
        return RegCert.__wrap(ret);
    }
}

const RegDrepCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_regdrepcert_free(ptr));
/**
*/
export class RegDrepCert {

    static __wrap(ptr) {
        const obj = Object.create(RegDrepCert.prototype);
        obj.ptr = ptr;
        RegDrepCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RegDrepCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_regdrepcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.regdrepcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {RegDrepCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.regdrepcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RegDrepCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.regdrepcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {RegDrepCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.regdrepcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RegDrepCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.regdrepcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.regdrepcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {RegDrepCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.regdrepcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RegDrepCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    drep_credential() {
        const ret = wasm.regdrepcert_drep_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    coin() {
        const ret = wasm.regdrepcert_coin(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {Anchor | undefined}
    */
    anchor() {
        const ret = wasm.regdrepcert_anchor(this.ptr);
        return ret === 0 ? undefined : Anchor.__wrap(ret);
    }
    /**
    * @param {Credential} drep_credential
    * @param {bigint} coin
    * @param {Anchor | undefined} anchor
    * @returns {RegDrepCert}
    */
    static new(drep_credential, coin, anchor) {
        _assertClass(drep_credential, Credential);
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.ptr;
            anchor.ptr = 0;
        }
        const ret = wasm.regdrepcert_new(drep_credential.ptr, coin, ptr0);
        return RegDrepCert.__wrap(ret);
    }
}

const RelayFinalization = new FinalizationRegistry(ptr => wasm.__wbg_relay_free(ptr));
/**
*/
export class Relay {

    static __wrap(ptr) {
        const obj = Object.create(Relay.prototype);
        obj.ptr = ptr;
        RelayFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RelayFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relay_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relay_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Relay}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.relay_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Relay.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relay_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Relay}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.relay_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Relay.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relay_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relay_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Relay}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.relay_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Relay.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {number | undefined} port
    * @param {Ipv4 | undefined} ipv4
    * @param {Ipv6 | undefined} ipv6
    * @returns {Relay}
    */
    static new_single_host_addr(port, ipv4, ipv6) {
        let ptr0 = 0;
        if (!isLikeNone(ipv4)) {
            _assertClass(ipv4, Ipv4);
            ptr0 = ipv4.ptr;
            ipv4.ptr = 0;
        }
        let ptr1 = 0;
        if (!isLikeNone(ipv6)) {
            _assertClass(ipv6, Ipv6);
            ptr1 = ipv6.ptr;
            ipv6.ptr = 0;
        }
        const ret = wasm.relay_new_single_host_addr(isLikeNone(port) ? 0xFFFFFF : port, ptr0, ptr1);
        return Relay.__wrap(ret);
    }
    /**
    * @param {number | undefined} port
    * @param {DnsName} dns_name
    * @returns {Relay}
    */
    static new_single_host_name(port, dns_name) {
        _assertClass(dns_name, DnsName);
        const ret = wasm.relay_new_single_host_name(isLikeNone(port) ? 0xFFFFFF : port, dns_name.ptr);
        return Relay.__wrap(ret);
    }
    /**
    * @param {DnsName} dns_name
    * @returns {Relay}
    */
    static new_multi_host_name(dns_name) {
        _assertClass(dns_name, DnsName);
        const ret = wasm.relay_new_multi_host_name(dns_name.ptr);
        return Relay.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.relay_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {SingleHostAddr | undefined}
    */
    as_single_host_addr() {
        const ret = wasm.relay_as_single_host_addr(this.ptr);
        return ret === 0 ? undefined : SingleHostAddr.__wrap(ret);
    }
    /**
    * @returns {SingleHostName | undefined}
    */
    as_single_host_name() {
        const ret = wasm.relay_as_single_host_name(this.ptr);
        return ret === 0 ? undefined : SingleHostName.__wrap(ret);
    }
    /**
    * @returns {MultiHostName | undefined}
    */
    as_multi_host_name() {
        const ret = wasm.relay_as_multi_host_name(this.ptr);
        return ret === 0 ? undefined : MultiHostName.__wrap(ret);
    }
}

const RelayListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_relaylist_free(ptr));
/**
*/
export class RelayList {

    static __wrap(ptr) {
        const obj = Object.create(RelayList.prototype);
        obj.ptr = ptr;
        RelayListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RelayListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relaylist_free(ptr);
    }
    /**
    * @returns {RelayList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return RelayList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.relaylist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Relay}
    */
    get(index) {
        const ret = wasm.relaylist_get(this.ptr, index);
        return Relay.__wrap(ret);
    }
    /**
    * @param {Relay} elem
    */
    add(elem) {
        _assertClass(elem, Relay);
        wasm.relaylist_add(this.ptr, elem.ptr);
    }
}

const RequiredSignersFinalization = new FinalizationRegistry(ptr => wasm.__wbg_requiredsigners_free(ptr));
/**
*/
export class RequiredSigners {

    static __wrap(ptr) {
        const obj = Object.create(RequiredSigners.prototype);
        obj.ptr = ptr;
        RequiredSignersFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RequiredSignersFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_requiredsigners_free(ptr);
    }
    /**
    * @returns {RequiredSigners}
    */
    static new() {
        const ret = wasm.requiredsigners_new();
        return RequiredSigners.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.requiredsigners_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Ed25519KeyHash}
    */
    get(index) {
        const ret = wasm.requiredsigners_get(this.ptr, index);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @param {Ed25519KeyHash} elem
    */
    add(elem) {
        _assertClass(elem, Ed25519KeyHash);
        wasm.requiredsigners_add(this.ptr, elem.ptr);
    }
}

const RequiredWitnessSetFinalization = new FinalizationRegistry(ptr => wasm.__wbg_requiredwitnessset_free(ptr));
/**
*/
export class RequiredWitnessSet {

    static __wrap(ptr) {
        const obj = Object.create(RequiredWitnessSet.prototype);
        obj.ptr = ptr;
        RequiredWitnessSetFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RequiredWitnessSetFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_requiredwitnessset_free(ptr);
    }
    /**
    * @param {Ed25519KeyHash} hash
    */
    add_vkey_key_hash(hash) {
        _assertClass(hash, Ed25519KeyHash);
        wasm.requiredwitnessset_add_vkey_key_hash(this.ptr, hash.ptr);
    }
    /**
    * @param {ByronAddress} address
    */
    add_bootstrap(address) {
        _assertClass(address, ByronAddress);
        wasm.requiredwitnessset_add_bootstrap(this.ptr, address.ptr);
    }
    /**
    * @param {ScriptHash} script_hash
    */
    add_script_ref(script_hash) {
        _assertClass(script_hash, ScriptHash);
        wasm.requiredwitnessset_add_script_ref(this.ptr, script_hash.ptr);
    }
    /**
    * @param {ScriptHash} script_hash
    */
    add_script_hash(script_hash) {
        _assertClass(script_hash, ScriptHash);
        wasm.requiredwitnessset_add_script_hash(this.ptr, script_hash.ptr);
    }
    /**
    * @param {DatumHash} plutus_datum
    */
    add_plutus_datum_hash(plutus_datum) {
        _assertClass(plutus_datum, DatumHash);
        wasm.requiredwitnessset_add_plutus_datum_hash(this.ptr, plutus_datum.ptr);
    }
    /**
    * @param {RedeemerWitnessKey} redeemer
    */
    add_redeemer_tag(redeemer) {
        _assertClass(redeemer, RedeemerWitnessKey);
        wasm.requiredwitnessset_add_redeemer_tag(this.ptr, redeemer.ptr);
    }
    /**
    * @param {RequiredWitnessSet} requirements
    */
    add_all(requirements) {
        _assertClass(requirements, RequiredWitnessSet);
        wasm.requiredwitnessset_add_all(this.ptr, requirements.ptr);
    }
    /**
    * @returns {RequiredWitnessSet}
    */
    static new() {
        const ret = wasm.requiredwitnessset_new();
        return RequiredWitnessSet.__wrap(ret);
    }
    /**
    * @param {RewardAddress} address
    */
    withdrawal_required_wits(address) {
        _assertClass(address, RewardAddress);
        wasm.requiredwitnessset_withdrawal_required_wits(this.ptr, address.ptr);
    }
}

const ResignCommitteeColdCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_resigncommitteecoldcert_free(ptr));
/**
*/
export class ResignCommitteeColdCert {

    static __wrap(ptr) {
        const obj = Object.create(ResignCommitteeColdCert.prototype);
        obj.ptr = ptr;
        ResignCommitteeColdCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ResignCommitteeColdCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_resigncommitteecoldcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resigncommitteecoldcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ResignCommitteeColdCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.resigncommitteecoldcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ResignCommitteeColdCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resigncommitteecoldcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ResignCommitteeColdCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.resigncommitteecoldcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ResignCommitteeColdCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resigncommitteecoldcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resigncommitteecoldcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ResignCommitteeColdCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.resigncommitteecoldcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ResignCommitteeColdCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    committee_cold_credential() {
        const ret = wasm.resigncommitteecoldcert_committee_cold_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @param {Credential} committee_cold_credential
    * @returns {ResignCommitteeColdCert}
    */
    static new(committee_cold_credential) {
        _assertClass(committee_cold_credential, Credential);
        const ret = wasm.resigncommitteecoldcert_new(committee_cold_credential.ptr);
        return ResignCommitteeColdCert.__wrap(ret);
    }
}

const RewardAccountListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_rewardaccountlist_free(ptr));
/**
*/
export class RewardAccountList {

    static __wrap(ptr) {
        const obj = Object.create(RewardAccountList.prototype);
        obj.ptr = ptr;
        RewardAccountListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RewardAccountListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rewardaccountlist_free(ptr);
    }
    /**
    * @returns {RewardAccountList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return RewardAccountList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.rewardaccountlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {RewardAddress}
    */
    get(index) {
        const ret = wasm.rewardaccountlist_get(this.ptr, index);
        return RewardAddress.__wrap(ret);
    }
    /**
    * @param {RewardAddress} elem
    */
    add(elem) {
        _assertClass(elem, RewardAddress);
        wasm.rewardaccountlist_add(this.ptr, elem.ptr);
    }
}

const RewardAddressFinalization = new FinalizationRegistry(ptr => wasm.__wbg_rewardaddress_free(ptr));
/**
*/
export class RewardAddress {

    static __wrap(ptr) {
        const obj = Object.create(RewardAddress.prototype);
        obj.ptr = ptr;
        RewardAddressFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RewardAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rewardaddress_free(ptr);
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.rewardaddress_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.rewardaddress_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {RewardAddress}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.rewardaddress_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RewardAddress.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {number} network
    * @param {Credential} payment
    * @returns {RewardAddress}
    */
    static new(network, payment) {
        _assertClass(payment, Credential);
        const ret = wasm.enterpriseaddress_new(network, payment.ptr);
        return RewardAddress.__wrap(ret);
    }
    /**
    * @returns {Address}
    */
    to_address() {
        const ret = wasm.rewardaddress_to_address(this.ptr);
        return Address.__wrap(ret);
    }
    /**
    * @param {Address} address
    * @returns {RewardAddress | undefined}
    */
    static from_address(address) {
        _assertClass(address, Address);
        const ret = wasm.rewardaddress_from_address(address.ptr);
        return ret === 0 ? undefined : RewardAddress.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    network_id() {
        const ret = wasm.rewardaddress_network_id(this.ptr);
        return ret;
    }
    /**
    * @returns {Credential}
    */
    payment() {
        const ret = wasm.rewardaddress_payment(this.ptr);
        return Credential.__wrap(ret);
    }
}

const ScriptFinalization = new FinalizationRegistry(ptr => wasm.__wbg_script_free(ptr));
/**
*/
export class Script {

    static __wrap(ptr) {
        const obj = Object.create(Script.prototype);
        obj.ptr = ptr;
        ScriptFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_script_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.script_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Script}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.script_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.script_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Script}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.script_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.script_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.script_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Script}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.script_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Script.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {NativeScript} script
    * @returns {Script}
    */
    static new_native(script) {
        _assertClass(script, NativeScript);
        const ret = wasm.script_new_native(script.ptr);
        return Script.__wrap(ret);
    }
    /**
    * @param {PlutusV1Script} script
    * @returns {Script}
    */
    static new_plutus_v1(script) {
        _assertClass(script, PlutusV1Script);
        const ret = wasm.script_new_plutus_v1(script.ptr);
        return Script.__wrap(ret);
    }
    /**
    * @param {PlutusV2Script} script
    * @returns {Script}
    */
    static new_plutus_v2(script) {
        _assertClass(script, PlutusV2Script);
        const ret = wasm.script_new_plutus_v2(script.ptr);
        return Script.__wrap(ret);
    }
    /**
    * @param {PlutusV3Script} script
    * @returns {Script}
    */
    static new_plutus_v3(script) {
        _assertClass(script, PlutusV3Script);
        const ret = wasm.script_new_plutus_v3(script.ptr);
        return Script.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.script_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {NativeScript | undefined}
    */
    as_native() {
        const ret = wasm.script_as_native(this.ptr);
        return ret === 0 ? undefined : NativeScript.__wrap(ret);
    }
    /**
    * @returns {PlutusV1Script | undefined}
    */
    as_plutus_v1() {
        const ret = wasm.script_as_plutus_v1(this.ptr);
        return ret === 0 ? undefined : PlutusV1Script.__wrap(ret);
    }
    /**
    * @returns {PlutusV2Script | undefined}
    */
    as_plutus_v2() {
        const ret = wasm.script_as_plutus_v2(this.ptr);
        return ret === 0 ? undefined : PlutusV2Script.__wrap(ret);
    }
    /**
    * @returns {PlutusV3Script | undefined}
    */
    as_plutus_v3() {
        const ret = wasm.script_as_plutus_v3(this.ptr);
        return ret === 0 ? undefined : PlutusV3Script.__wrap(ret);
    }
    /**
    * @returns {ScriptHash}
    */
    hash() {
        const ret = wasm.script_hash(this.ptr);
        return ScriptHash.__wrap(ret);
    }
    /**
    * @returns {number | undefined}
    */
    language() {
        const ret = wasm.script_language(this.ptr);
        return ret === 3 ? undefined : ret;
    }
}

const ScriptAllFinalization = new FinalizationRegistry(ptr => wasm.__wbg_scriptall_free(ptr));
/**
*/
export class ScriptAll {

    static __wrap(ptr) {
        const obj = Object.create(ScriptAll.prototype);
        obj.ptr = ptr;
        ScriptAllFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ScriptAllFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptall_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptall_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ScriptAll}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptall_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptAll.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptall_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ScriptAll}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptall_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptAll.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptall_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptall_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ScriptAll}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptall_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptAll.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {NativeScriptList}
    */
    native_scripts() {
        const ret = wasm.scriptall_native_scripts(this.ptr);
        return NativeScriptList.__wrap(ret);
    }
    /**
    * @param {NativeScriptList} native_scripts
    * @returns {ScriptAll}
    */
    static new(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.scriptall_new(native_scripts.ptr);
        return ScriptAll.__wrap(ret);
    }
}

const ScriptAnyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_scriptany_free(ptr));
/**
*/
export class ScriptAny {

    static __wrap(ptr) {
        const obj = Object.create(ScriptAny.prototype);
        obj.ptr = ptr;
        ScriptAnyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ScriptAnyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptany_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptany_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ScriptAny}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptany_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptAny.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptany_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ScriptAny}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptany_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptAny.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptany_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptany_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ScriptAny}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptany_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptAny.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {NativeScriptList}
    */
    native_scripts() {
        const ret = wasm.scriptany_native_scripts(this.ptr);
        return NativeScriptList.__wrap(ret);
    }
    /**
    * @param {NativeScriptList} native_scripts
    * @returns {ScriptAny}
    */
    static new(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.scriptall_new(native_scripts.ptr);
        return ScriptAny.__wrap(ret);
    }
}

const ScriptDataHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_scriptdatahash_free(ptr));
/**
*/
export class ScriptDataHash {

    static __wrap(ptr) {
        const obj = Object.create(ScriptDataHash.prototype);
        obj.ptr = ptr;
        ScriptDataHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ScriptDataHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptdatahash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptdatahash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptdatahash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptdatahash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {ScriptDataHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptdatahash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptDataHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {ScriptDataHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptdatahash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptDataHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {ScriptDataHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptdatahash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptDataHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const ScriptHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_scripthash_free(ptr));
/**
*/
export class ScriptHash {

    static __wrap(ptr) {
        const obj = Object.create(ScriptHash.prototype);
        obj.ptr = ptr;
        ScriptHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ScriptHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scripthash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scripthash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scripthash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scripthash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {ScriptHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scripthash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {ScriptHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scripthash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {ScriptHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scripthash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const ScriptInvalidBeforeFinalization = new FinalizationRegistry(ptr => wasm.__wbg_scriptinvalidbefore_free(ptr));
/**
*/
export class ScriptInvalidBefore {

    static __wrap(ptr) {
        const obj = Object.create(ScriptInvalidBefore.prototype);
        obj.ptr = ptr;
        ScriptInvalidBeforeFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ScriptInvalidBeforeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptinvalidbefore_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptinvalidbefore_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ScriptInvalidBefore}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptinvalidbefore_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptInvalidBefore.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptinvalidbefore_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ScriptInvalidBefore}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptinvalidbefore_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptInvalidBefore.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptinvalidbefore_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptinvalidbefore_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ScriptInvalidBefore}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptinvalidbefore_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptInvalidBefore.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    before() {
        const ret = wasm.scriptinvalidbefore_before(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} before
    * @returns {ScriptInvalidBefore}
    */
    static new(before) {
        const ret = wasm.scriptinvalidbefore_new(before);
        return ScriptInvalidBefore.__wrap(ret);
    }
}

const ScriptInvalidHereafterFinalization = new FinalizationRegistry(ptr => wasm.__wbg_scriptinvalidhereafter_free(ptr));
/**
*/
export class ScriptInvalidHereafter {

    static __wrap(ptr) {
        const obj = Object.create(ScriptInvalidHereafter.prototype);
        obj.ptr = ptr;
        ScriptInvalidHereafterFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ScriptInvalidHereafterFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptinvalidhereafter_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptinvalidhereafter_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ScriptInvalidHereafter}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptinvalidhereafter_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptInvalidHereafter.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptinvalidhereafter_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ScriptInvalidHereafter}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptinvalidhereafter_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptInvalidHereafter.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptinvalidhereafter_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptinvalidhereafter_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ScriptInvalidHereafter}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptinvalidhereafter_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptInvalidHereafter.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    after() {
        const ret = wasm.scriptinvalidhereafter_after(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} after
    * @returns {ScriptInvalidHereafter}
    */
    static new(after) {
        const ret = wasm.scriptinvalidbefore_new(after);
        return ScriptInvalidHereafter.__wrap(ret);
    }
}

const ScriptNOfKFinalization = new FinalizationRegistry(ptr => wasm.__wbg_scriptnofk_free(ptr));
/**
*/
export class ScriptNOfK {

    static __wrap(ptr) {
        const obj = Object.create(ScriptNOfK.prototype);
        obj.ptr = ptr;
        ScriptNOfKFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ScriptNOfKFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptnofk_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptnofk_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ScriptNOfK}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptnofk_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptNOfK.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptnofk_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ScriptNOfK}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptnofk_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptNOfK.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptnofk_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptnofk_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ScriptNOfK}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptnofk_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptNOfK.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    n() {
        const ret = wasm.scriptnofk_n(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {NativeScriptList}
    */
    native_scripts() {
        const ret = wasm.scriptnofk_native_scripts(this.ptr);
        return NativeScriptList.__wrap(ret);
    }
    /**
    * @param {bigint} n
    * @param {NativeScriptList} native_scripts
    * @returns {ScriptNOfK}
    */
    static new(n, native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.scriptnofk_new(n, native_scripts.ptr);
        return ScriptNOfK.__wrap(ret);
    }
}

const ScriptPubkeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_scriptpubkey_free(ptr));
/**
*/
export class ScriptPubkey {

    static __wrap(ptr) {
        const obj = Object.create(ScriptPubkey.prototype);
        obj.ptr = ptr;
        ScriptPubkeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ScriptPubkeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptpubkey_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptpubkey_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ScriptPubkey}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptpubkey_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptPubkey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptpubkey_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ScriptPubkey}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptpubkey_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptPubkey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptpubkey_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.scriptpubkey_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ScriptPubkey}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.scriptpubkey_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ScriptPubkey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Ed25519KeyHash}
    */
    ed25519_key_hash() {
        const ret = wasm.scriptpubkey_ed25519_key_hash(this.ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @param {Ed25519KeyHash} ed25519_key_hash
    * @returns {ScriptPubkey}
    */
    static new(ed25519_key_hash) {
        _assertClass(ed25519_key_hash, Ed25519KeyHash);
        const ret = wasm.scriptpubkey_new(ed25519_key_hash.ptr);
        return ScriptPubkey.__wrap(ret);
    }
}

const ShelleyMaFormatAuxDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_shelleymaformatauxdata_free(ptr));
/**
*/
export class ShelleyMaFormatAuxData {

    static __wrap(ptr) {
        const obj = Object.create(ShelleyMaFormatAuxData.prototype);
        obj.ptr = ptr;
        ShelleyMaFormatAuxDataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ShelleyMaFormatAuxDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_shelleymaformatauxdata_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shelleymaformatauxdata_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {ShelleyMaFormatAuxData}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.shelleymaformatauxdata_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ShelleyMaFormatAuxData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shelleymaformatauxdata_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {ShelleyMaFormatAuxData}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.shelleymaformatauxdata_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ShelleyMaFormatAuxData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shelleymaformatauxdata_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shelleymaformatauxdata_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {ShelleyMaFormatAuxData}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.shelleymaformatauxdata_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ShelleyMaFormatAuxData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Metadata}
    */
    transaction_metadata() {
        const ret = wasm.shelleymaformatauxdata_transaction_metadata(this.ptr);
        return Metadata.__wrap(ret);
    }
    /**
    * @returns {NativeScriptList}
    */
    auxiliary_scripts() {
        const ret = wasm.shelleymaformatauxdata_auxiliary_scripts(this.ptr);
        return NativeScriptList.__wrap(ret);
    }
    /**
    * @param {Metadata} transaction_metadata
    * @param {NativeScriptList} auxiliary_scripts
    * @returns {ShelleyMaFormatAuxData}
    */
    static new(transaction_metadata, auxiliary_scripts) {
        _assertClass(transaction_metadata, Metadata);
        _assertClass(auxiliary_scripts, NativeScriptList);
        const ret = wasm.shelleymaformatauxdata_new(transaction_metadata.ptr, auxiliary_scripts.ptr);
        return ShelleyMaFormatAuxData.__wrap(ret);
    }
}

const SignedTxBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_signedtxbuilder_free(ptr));
/**
*/
export class SignedTxBuilder {

    static __wrap(ptr) {
        const obj = Object.create(SignedTxBuilder.prototype);
        obj.ptr = ptr;
        SignedTxBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SignedTxBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_signedtxbuilder_free(ptr);
    }
    /**
    * @param {TransactionBody} body
    * @param {TransactionWitnessSetBuilder} witness_set
    * @param {boolean} is_valid
    * @param {AuxiliaryData} auxiliary_data
    * @returns {SignedTxBuilder}
    */
    static new_with_data(body, witness_set, is_valid, auxiliary_data) {
        _assertClass(body, TransactionBody);
        _assertClass(witness_set, TransactionWitnessSetBuilder);
        _assertClass(auxiliary_data, AuxiliaryData);
        const ret = wasm.signedtxbuilder_new_with_data(body.ptr, witness_set.ptr, is_valid, auxiliary_data.ptr);
        return SignedTxBuilder.__wrap(ret);
    }
    /**
    * @param {TransactionBody} body
    * @param {TransactionWitnessSetBuilder} witness_set
    * @param {boolean} is_valid
    * @returns {SignedTxBuilder}
    */
    static new_without_data(body, witness_set, is_valid) {
        _assertClass(body, TransactionBody);
        _assertClass(witness_set, TransactionWitnessSetBuilder);
        const ret = wasm.signedtxbuilder_new_without_data(body.ptr, witness_set.ptr, is_valid);
        return SignedTxBuilder.__wrap(ret);
    }
    /**
    *
    *     * Builds the final transaction and checks that all witnesses are there
    *
    * @returns {Transaction}
    */
    build_checked() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.signedtxbuilder_build_checked(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Transaction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *     * Builds the transaction without doing any witness checks.
    *     *
    *     * This can be useful if other witnesses will be added later.
    *     * e.g. CIP30 signing takes a Transaction with possible witnesses
    *     * to send to the wallet to fill in the missing ones.
    *
    * @returns {Transaction}
    */
    build_unchecked() {
        const ret = wasm.signedtxbuilder_build_unchecked(this.ptr);
        return Transaction.__wrap(ret);
    }
    /**
    * @param {Vkeywitness} vkey
    */
    add_vkey(vkey) {
        _assertClass(vkey, Vkeywitness);
        wasm.signedtxbuilder_add_vkey(this.ptr, vkey.ptr);
    }
    /**
    * @param {BootstrapWitness} bootstrap
    */
    add_bootstrap(bootstrap) {
        _assertClass(bootstrap, BootstrapWitness);
        wasm.signedtxbuilder_add_bootstrap(this.ptr, bootstrap.ptr);
    }
    /**
    * @returns {TransactionBody}
    */
    body() {
        const ret = wasm.signedtxbuilder_body(this.ptr);
        return TransactionBody.__wrap(ret);
    }
    /**
    * @returns {TransactionWitnessSetBuilder}
    */
    witness_set() {
        const ret = wasm.signedtxbuilder_witness_set(this.ptr);
        return TransactionWitnessSetBuilder.__wrap(ret);
    }
    /**
    * @returns {boolean}
    */
    is_valid() {
        const ret = wasm.signedtxbuilder_is_valid(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {AuxiliaryData | undefined}
    */
    auxiliary_data() {
        const ret = wasm.signedtxbuilder_auxiliary_data(this.ptr);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
}

const SingleCertificateBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_singlecertificatebuilder_free(ptr));
/**
*/
export class SingleCertificateBuilder {

    static __wrap(ptr) {
        const obj = Object.create(SingleCertificateBuilder.prototype);
        obj.ptr = ptr;
        SingleCertificateBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SingleCertificateBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlecertificatebuilder_free(ptr);
    }
    /**
    * @param {Certificate} cert
    * @returns {SingleCertificateBuilder}
    */
    static new(cert) {
        _assertClass(cert, Certificate);
        const ret = wasm.singlecertificatebuilder_new(cert.ptr);
        return SingleCertificateBuilder.__wrap(ret);
    }
    /**
    * note: particularly useful for StakeRegistration which doesn't require witnessing
    * @returns {CertificateBuilderResult}
    */
    skip_witness() {
        const ret = wasm.singlecertificatebuilder_skip_witness(this.ptr);
        return CertificateBuilderResult.__wrap(ret);
    }
    /**
    * @returns {CertificateBuilderResult}
    */
    payment_key() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singlecertificatebuilder_payment_key(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CertificateBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Signer keys don't have to be set. You can leave it empty and then add the required witnesses later
    * @param {NativeScript} native_script
    * @param {NativeScriptWitnessInfo} witness_info
    * @returns {CertificateBuilderResult}
    */
    native_script(native_script, witness_info) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(native_script, NativeScript);
            _assertClass(witness_info, NativeScriptWitnessInfo);
            wasm.singlecertificatebuilder_native_script(retptr, this.ptr, native_script.ptr, witness_info.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CertificateBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {PartialPlutusWitness} partial_witness
    * @param {RequiredSigners} required_signers
    * @returns {CertificateBuilderResult}
    */
    plutus_script(partial_witness, required_signers) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(partial_witness, PartialPlutusWitness);
            _assertClass(required_signers, RequiredSigners);
            wasm.singlecertificatebuilder_plutus_script(retptr, ptr, partial_witness.ptr, required_signers.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CertificateBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const SingleHostAddrFinalization = new FinalizationRegistry(ptr => wasm.__wbg_singlehostaddr_free(ptr));
/**
*/
export class SingleHostAddr {

    static __wrap(ptr) {
        const obj = Object.create(SingleHostAddr.prototype);
        obj.ptr = ptr;
        SingleHostAddrFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SingleHostAddrFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlehostaddr_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singlehostaddr_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {SingleHostAddr}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.singlehostaddr_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SingleHostAddr.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singlehostaddr_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {SingleHostAddr}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.singlehostaddr_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SingleHostAddr.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singlehostaddr_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singlehostaddr_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {SingleHostAddr}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.singlehostaddr_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SingleHostAddr.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number | undefined}
    */
    port() {
        const ret = wasm.singlehostaddr_port(this.ptr);
        return ret === 0xFFFFFF ? undefined : ret;
    }
    /**
    * @returns {Ipv4 | undefined}
    */
    ipv4() {
        const ret = wasm.singlehostaddr_ipv4(this.ptr);
        return ret === 0 ? undefined : Ipv4.__wrap(ret);
    }
    /**
    * @returns {Ipv6 | undefined}
    */
    ipv6() {
        const ret = wasm.singlehostaddr_ipv6(this.ptr);
        return ret === 0 ? undefined : Ipv6.__wrap(ret);
    }
    /**
    * @param {number | undefined} port
    * @param {Ipv4 | undefined} ipv4
    * @param {Ipv6 | undefined} ipv6
    * @returns {SingleHostAddr}
    */
    static new(port, ipv4, ipv6) {
        let ptr0 = 0;
        if (!isLikeNone(ipv4)) {
            _assertClass(ipv4, Ipv4);
            ptr0 = ipv4.ptr;
            ipv4.ptr = 0;
        }
        let ptr1 = 0;
        if (!isLikeNone(ipv6)) {
            _assertClass(ipv6, Ipv6);
            ptr1 = ipv6.ptr;
            ipv6.ptr = 0;
        }
        const ret = wasm.singlehostaddr_new(isLikeNone(port) ? 0xFFFFFF : port, ptr0, ptr1);
        return SingleHostAddr.__wrap(ret);
    }
}

const SingleHostNameFinalization = new FinalizationRegistry(ptr => wasm.__wbg_singlehostname_free(ptr));
/**
*/
export class SingleHostName {

    static __wrap(ptr) {
        const obj = Object.create(SingleHostName.prototype);
        obj.ptr = ptr;
        SingleHostNameFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SingleHostNameFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlehostname_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singlehostname_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {SingleHostName}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.singlehostname_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SingleHostName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singlehostname_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {SingleHostName}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.singlehostname_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SingleHostName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singlehostname_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singlehostname_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {SingleHostName}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.singlehostname_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SingleHostName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number | undefined}
    */
    port() {
        const ret = wasm.singlehostname_port(this.ptr);
        return ret === 0xFFFFFF ? undefined : ret;
    }
    /**
    * @returns {DnsName}
    */
    dns_name() {
        const ret = wasm.singlehostname_dns_name(this.ptr);
        return DnsName.__wrap(ret);
    }
    /**
    * @param {number | undefined} port
    * @param {DnsName} dns_name
    * @returns {SingleHostName}
    */
    static new(port, dns_name) {
        _assertClass(dns_name, DnsName);
        const ret = wasm.singlehostname_new(isLikeNone(port) ? 0xFFFFFF : port, dns_name.ptr);
        return SingleHostName.__wrap(ret);
    }
}

const SingleInputBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_singleinputbuilder_free(ptr));
/**
*/
export class SingleInputBuilder {

    static __wrap(ptr) {
        const obj = Object.create(SingleInputBuilder.prototype);
        obj.ptr = ptr;
        SingleInputBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SingleInputBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singleinputbuilder_free(ptr);
    }
    /**
    * @param {TransactionInput} input
    * @param {TransactionOutput} utxo_info
    * @returns {SingleInputBuilder}
    */
    static new(input, utxo_info) {
        _assertClass(input, TransactionInput);
        _assertClass(utxo_info, TransactionOutput);
        const ret = wasm.singleinputbuilder_new(input.ptr, utxo_info.ptr);
        return SingleInputBuilder.__wrap(ret);
    }
    /**
    * @param {TransactionUnspentOutput} utxo
    * @returns {SingleInputBuilder}
    */
    static from_transaction_unspent_output(utxo) {
        _assertClass(utxo, TransactionUnspentOutput);
        const ret = wasm.singleinputbuilder_from_transaction_unspent_output(utxo.ptr);
        return SingleInputBuilder.__wrap(ret);
    }
    /**
    * @returns {InputBuilderResult}
    */
    payment_key() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singleinputbuilder_payment_key(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return InputBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {NativeScript} native_script
    * @param {NativeScriptWitnessInfo} witness_info
    * @returns {InputBuilderResult}
    */
    native_script(native_script, witness_info) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(native_script, NativeScript);
            _assertClass(witness_info, NativeScriptWitnessInfo);
            wasm.singleinputbuilder_native_script(retptr, this.ptr, native_script.ptr, witness_info.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return InputBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {PartialPlutusWitness} partial_witness
    * @param {RequiredSigners} required_signers
    * @param {PlutusData} datum
    * @returns {InputBuilderResult}
    */
    plutus_script(partial_witness, required_signers, datum) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(partial_witness, PartialPlutusWitness);
            _assertClass(required_signers, RequiredSigners);
            _assertClass(datum, PlutusData);
            wasm.singleinputbuilder_plutus_script(retptr, this.ptr, partial_witness.ptr, required_signers.ptr, datum.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return InputBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {PartialPlutusWitness} partial_witness
    * @param {RequiredSigners} required_signers
    * @returns {InputBuilderResult}
    */
    plutus_script_inline_datum(partial_witness, required_signers) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(partial_witness, PartialPlutusWitness);
            _assertClass(required_signers, RequiredSigners);
            wasm.singleinputbuilder_plutus_script_inline_datum(retptr, this.ptr, partial_witness.ptr, required_signers.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return InputBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const SingleMintBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_singlemintbuilder_free(ptr));
/**
*/
export class SingleMintBuilder {

    static __wrap(ptr) {
        const obj = Object.create(SingleMintBuilder.prototype);
        obj.ptr = ptr;
        SingleMintBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SingleMintBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlemintbuilder_free(ptr);
    }
    /**
    * @param {MapAssetNameToNonZeroInt64} assets
    * @returns {SingleMintBuilder}
    */
    static new(assets) {
        _assertClass(assets, MapAssetNameToNonZeroInt64);
        const ret = wasm.singlemintbuilder_new(assets.ptr);
        return SingleMintBuilder.__wrap(ret);
    }
    /**
    * @param {AssetName} asset
    * @param {bigint} amount
    * @returns {SingleMintBuilder}
    */
    static new_single_asset(asset, amount) {
        _assertClass(asset, AssetName);
        const ret = wasm.singlemintbuilder_new_single_asset(asset.ptr, amount);
        return SingleMintBuilder.__wrap(ret);
    }
    /**
    * @param {NativeScript} native_script
    * @param {NativeScriptWitnessInfo} witness_info
    * @returns {MintBuilderResult}
    */
    native_script(native_script, witness_info) {
        const ptr = this.__destroy_into_raw();
        _assertClass(native_script, NativeScript);
        _assertClass(witness_info, NativeScriptWitnessInfo);
        const ret = wasm.singlemintbuilder_native_script(ptr, native_script.ptr, witness_info.ptr);
        return MintBuilderResult.__wrap(ret);
    }
    /**
    * @param {PartialPlutusWitness} partial_witness
    * @param {RequiredSigners} required_signers
    * @returns {MintBuilderResult}
    */
    plutus_script(partial_witness, required_signers) {
        const ptr = this.__destroy_into_raw();
        _assertClass(partial_witness, PartialPlutusWitness);
        _assertClass(required_signers, RequiredSigners);
        const ret = wasm.singlemintbuilder_plutus_script(ptr, partial_witness.ptr, required_signers.ptr);
        return MintBuilderResult.__wrap(ret);
    }
}

const SingleOutputBuilderResultFinalization = new FinalizationRegistry(ptr => wasm.__wbg_singleoutputbuilderresult_free(ptr));
/**
*/
export class SingleOutputBuilderResult {

    static __wrap(ptr) {
        const obj = Object.create(SingleOutputBuilderResult.prototype);
        obj.ptr = ptr;
        SingleOutputBuilderResultFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SingleOutputBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singleoutputbuilderresult_free(ptr);
    }
    /**
    * @param {TransactionOutput} output
    * @returns {SingleOutputBuilderResult}
    */
    static new(output) {
        _assertClass(output, TransactionOutput);
        const ret = wasm.singleoutputbuilderresult_new(output.ptr);
        return SingleOutputBuilderResult.__wrap(ret);
    }
    /**
    * @returns {TransactionOutput}
    */
    output() {
        const ret = wasm.singleoutputbuilderresult_output(this.ptr);
        return TransactionOutput.__wrap(ret);
    }
    /**
    * @returns {PlutusData | undefined}
    */
    communication_datum() {
        const ret = wasm.singleoutputbuilderresult_communication_datum(this.ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
}

const SingleWithdrawalBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_singlewithdrawalbuilder_free(ptr));
/**
*/
export class SingleWithdrawalBuilder {

    static __wrap(ptr) {
        const obj = Object.create(SingleWithdrawalBuilder.prototype);
        obj.ptr = ptr;
        SingleWithdrawalBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SingleWithdrawalBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlewithdrawalbuilder_free(ptr);
    }
    /**
    * @param {RewardAddress} address
    * @param {bigint} amount
    * @returns {SingleWithdrawalBuilder}
    */
    static new(address, amount) {
        _assertClass(address, RewardAddress);
        const ret = wasm.singlewithdrawalbuilder_new(address.ptr, amount);
        return SingleWithdrawalBuilder.__wrap(ret);
    }
    /**
    * @returns {WithdrawalBuilderResult}
    */
    payment_key() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.singlewithdrawalbuilder_payment_key(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return WithdrawalBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {NativeScript} native_script
    * @param {NativeScriptWitnessInfo} witness_info
    * @returns {WithdrawalBuilderResult}
    */
    native_script(native_script, witness_info) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(native_script, NativeScript);
            _assertClass(witness_info, NativeScriptWitnessInfo);
            wasm.singlewithdrawalbuilder_native_script(retptr, ptr, native_script.ptr, witness_info.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return WithdrawalBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {PartialPlutusWitness} partial_witness
    * @param {RequiredSigners} required_signers
    * @returns {WithdrawalBuilderResult}
    */
    plutus_script(partial_witness, required_signers) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(partial_witness, PartialPlutusWitness);
            var ptr0 = partial_witness.ptr;
            partial_witness.ptr = 0;
            _assertClass(required_signers, RequiredSigners);
            var ptr1 = required_signers.ptr;
            required_signers.ptr = 0;
            wasm.singlewithdrawalbuilder_plutus_script(retptr, ptr, ptr0, ptr1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return WithdrawalBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const SpendingDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_spendingdata_free(ptr));
/**
*/
export class SpendingData {

    static __wrap(ptr) {
        const obj = Object.create(SpendingData.prototype);
        obj.ptr = ptr;
        SpendingDataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SpendingDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_spendingdata_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.spendingdata_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {SpendingData}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.spendingdata_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SpendingData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.spendingdata_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {SpendingData}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.spendingdata_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SpendingData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Bip32PublicKey} pubkey
    * @returns {SpendingData}
    */
    static new_spending_data_pub_key(pubkey) {
        _assertClass(pubkey, Bip32PublicKey);
        const ret = wasm.spendingdata_new_spending_data_pub_key(pubkey.ptr);
        return SpendingData.__wrap(ret);
    }
    /**
    * @param {ByronScript} script
    * @returns {SpendingData}
    */
    static new_spending_data_script(script) {
        _assertClass(script, ByronScript);
        const ret = wasm.spendingdata_new_spending_data_script(script.ptr);
        return SpendingData.__wrap(ret);
    }
    /**
    * @param {PublicKey} redeem
    * @returns {SpendingData}
    */
    static new_spending_data_redeem(redeem) {
        _assertClass(redeem, PublicKey);
        const ret = wasm.spendingdata_new_spending_data_redeem(redeem.ptr);
        return SpendingData.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.spendingdata_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {Bip32PublicKey | undefined}
    */
    as_spending_data_pub_key() {
        const ret = wasm.spendingdata_as_spending_data_pub_key(this.ptr);
        return ret === 0 ? undefined : Bip32PublicKey.__wrap(ret);
    }
    /**
    * @returns {ByronScript | undefined}
    */
    as_spending_data_script() {
        const ret = wasm.spendingdata_as_spending_data_script(this.ptr);
        return ret === 0 ? undefined : ByronScript.__wrap(ret);
    }
    /**
    * @returns {PublicKey | undefined}
    */
    as_spending_data_redeem() {
        const ret = wasm.spendingdata_as_spending_data_redeem(this.ptr);
        return ret === 0 ? undefined : PublicKey.__wrap(ret);
    }
}

const StakeCredentialListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_stakecredentiallist_free(ptr));
/**
*/
export class StakeCredentialList {

    static __wrap(ptr) {
        const obj = Object.create(StakeCredentialList.prototype);
        obj.ptr = ptr;
        StakeCredentialListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        StakeCredentialListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakecredentiallist_free(ptr);
    }
    /**
    * @returns {StakeCredentialList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return StakeCredentialList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.stakecredentiallist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Credential}
    */
    get(index) {
        const ret = wasm.stakecredentiallist_get(this.ptr, index);
        return Credential.__wrap(ret);
    }
    /**
    * @param {Credential} elem
    */
    add(elem) {
        _assertClass(elem, Credential);
        wasm.stakecredentiallist_add(this.ptr, elem.ptr);
    }
}

const StakeDelegationFinalization = new FinalizationRegistry(ptr => wasm.__wbg_stakedelegation_free(ptr));
/**
*/
export class StakeDelegation {

    static __wrap(ptr) {
        const obj = Object.create(StakeDelegation.prototype);
        obj.ptr = ptr;
        StakeDelegationFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        StakeDelegationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakedelegation_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakedelegation_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {StakeDelegation}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakedelegation_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeDelegation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakedelegation_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {StakeDelegation}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakedelegation_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeDelegation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakedelegation_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakedelegation_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {StakeDelegation}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakedelegation_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeDelegation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    stake_credential() {
        const ret = wasm.stakedelegation_stake_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {Ed25519KeyHash}
    */
    pool() {
        const ret = wasm.stakedelegation_pool(this.ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {Ed25519KeyHash} pool
    * @returns {StakeDelegation}
    */
    static new(stake_credential, pool) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.stakedelegation_new(stake_credential.ptr, pool.ptr);
        return StakeDelegation.__wrap(ret);
    }
}

const StakeDeregistrationFinalization = new FinalizationRegistry(ptr => wasm.__wbg_stakederegistration_free(ptr));
/**
*/
export class StakeDeregistration {

    static __wrap(ptr) {
        const obj = Object.create(StakeDeregistration.prototype);
        obj.ptr = ptr;
        StakeDeregistrationFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        StakeDeregistrationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakederegistration_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakederegistration_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {StakeDeregistration}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakederegistration_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeDeregistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakederegistration_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {StakeDeregistration}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakederegistration_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeDeregistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakederegistration_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakederegistration_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {StakeDeregistration}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakederegistration_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeDeregistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    stake_credential() {
        const ret = wasm.stakederegistration_stake_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @returns {StakeDeregistration}
    */
    static new(stake_credential) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.resigncommitteecoldcert_new(stake_credential.ptr);
        return StakeDeregistration.__wrap(ret);
    }
}

const StakeDistributionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_stakedistribution_free(ptr));
/**
*/
export class StakeDistribution {

    static __wrap(ptr) {
        const obj = Object.create(StakeDistribution.prototype);
        obj.ptr = ptr;
        StakeDistributionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        StakeDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakedistribution_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakedistribution_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {StakeDistribution}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakedistribution_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeDistribution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakedistribution_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {StakeDistribution}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakedistribution_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeDistribution.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {StakeholderId} stakeholder_id
    * @returns {StakeDistribution}
    */
    static new_single_key(stakeholder_id) {
        _assertClass(stakeholder_id, StakeholderId);
        const ret = wasm.stakedistribution_new_single_key(stakeholder_id.ptr);
        return StakeDistribution.__wrap(ret);
    }
    /**
    * @returns {StakeDistribution}
    */
    static new_bootstrap_era() {
        const ret = wasm.stakedistribution_new_bootstrap_era();
        return StakeDistribution.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.stakedistribution_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {StakeholderId | undefined}
    */
    as_single_key() {
        const ret = wasm.stakedistribution_as_single_key(this.ptr);
        return ret === 0 ? undefined : StakeholderId.__wrap(ret);
    }
}

const StakeRegDelegCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_stakeregdelegcert_free(ptr));
/**
*/
export class StakeRegDelegCert {

    static __wrap(ptr) {
        const obj = Object.create(StakeRegDelegCert.prototype);
        obj.ptr = ptr;
        StakeRegDelegCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        StakeRegDelegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakeregdelegcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakeregdelegcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {StakeRegDelegCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakeregdelegcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeRegDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakeregdelegcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {StakeRegDelegCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakeregdelegcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeRegDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakeregdelegcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakeregdelegcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {StakeRegDelegCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakeregdelegcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeRegDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    stake_credential() {
        const ret = wasm.stakeregdelegcert_stake_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {Ed25519KeyHash}
    */
    pool() {
        const ret = wasm.stakeregdelegcert_pool(this.ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    coin() {
        const ret = wasm.stakeregdelegcert_coin(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {Ed25519KeyHash} pool
    * @param {bigint} coin
    * @returns {StakeRegDelegCert}
    */
    static new(stake_credential, pool, coin) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.stakeregdelegcert_new(stake_credential.ptr, pool.ptr, coin);
        return StakeRegDelegCert.__wrap(ret);
    }
}

const StakeRegistrationFinalization = new FinalizationRegistry(ptr => wasm.__wbg_stakeregistration_free(ptr));
/**
*/
export class StakeRegistration {

    static __wrap(ptr) {
        const obj = Object.create(StakeRegistration.prototype);
        obj.ptr = ptr;
        StakeRegistrationFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        StakeRegistrationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakeregistration_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakeregistration_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {StakeRegistration}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakeregistration_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeRegistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakeregistration_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {StakeRegistration}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakeregistration_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeRegistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakeregistration_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakeregistration_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {StakeRegistration}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakeregistration_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeRegistration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    stake_credential() {
        const ret = wasm.stakeregistration_stake_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @returns {StakeRegistration}
    */
    static new(stake_credential) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.resigncommitteecoldcert_new(stake_credential.ptr);
        return StakeRegistration.__wrap(ret);
    }
}

const StakeVoteDelegCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_stakevotedelegcert_free(ptr));
/**
*/
export class StakeVoteDelegCert {

    static __wrap(ptr) {
        const obj = Object.create(StakeVoteDelegCert.prototype);
        obj.ptr = ptr;
        StakeVoteDelegCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        StakeVoteDelegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakevotedelegcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakevotedelegcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {StakeVoteDelegCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakevotedelegcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeVoteDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakevotedelegcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {StakeVoteDelegCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakevotedelegcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeVoteDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakevotedelegcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakevotedelegcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {StakeVoteDelegCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakevotedelegcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeVoteDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    stake_credential() {
        const ret = wasm.stakevotedelegcert_stake_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {Ed25519KeyHash}
    */
    pool() {
        const ret = wasm.stakevotedelegcert_pool(this.ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @returns {DRep}
    */
    d_rep() {
        const ret = wasm.stakevotedelegcert_d_rep(this.ptr);
        return DRep.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {Ed25519KeyHash} pool
    * @param {DRep} d_rep
    * @returns {StakeVoteDelegCert}
    */
    static new(stake_credential, pool, d_rep) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        _assertClass(d_rep, DRep);
        const ret = wasm.stakevotedelegcert_new(stake_credential.ptr, pool.ptr, d_rep.ptr);
        return StakeVoteDelegCert.__wrap(ret);
    }
}

const StakeVoteRegDelegCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_stakevoteregdelegcert_free(ptr));
/**
*/
export class StakeVoteRegDelegCert {

    static __wrap(ptr) {
        const obj = Object.create(StakeVoteRegDelegCert.prototype);
        obj.ptr = ptr;
        StakeVoteRegDelegCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        StakeVoteRegDelegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakevoteregdelegcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakevoteregdelegcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {StakeVoteRegDelegCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakevoteregdelegcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeVoteRegDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakevoteregdelegcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {StakeVoteRegDelegCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakevoteregdelegcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeVoteRegDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakevoteregdelegcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakevoteregdelegcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {StakeVoteRegDelegCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakevoteregdelegcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeVoteRegDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    stake_credential() {
        const ret = wasm.stakevoteregdelegcert_stake_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {Ed25519KeyHash}
    */
    pool() {
        const ret = wasm.stakevoteregdelegcert_pool(this.ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @returns {DRep}
    */
    d_rep() {
        const ret = wasm.stakevoteregdelegcert_d_rep(this.ptr);
        return DRep.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    coin() {
        const ret = wasm.stakevoteregdelegcert_coin(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {Ed25519KeyHash} pool
    * @param {DRep} d_rep
    * @param {bigint} coin
    * @returns {StakeVoteRegDelegCert}
    */
    static new(stake_credential, pool, d_rep, coin) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        _assertClass(d_rep, DRep);
        const ret = wasm.stakevoteregdelegcert_new(stake_credential.ptr, pool.ptr, d_rep.ptr, coin);
        return StakeVoteRegDelegCert.__wrap(ret);
    }
}

const StakeholderIdFinalization = new FinalizationRegistry(ptr => wasm.__wbg_stakeholderid_free(ptr));
/**
*/
export class StakeholderId {

    static __wrap(ptr) {
        const obj = Object.create(StakeholderId.prototype);
        obj.ptr = ptr;
        StakeholderIdFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        StakeholderIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakeholderid_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakeholderid_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakeholderid_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stakeholderid_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {StakeholderId}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakeholderid_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeholderId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {StakeholderId}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakeholderid_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeholderId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {StakeholderId}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.stakeholderid_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return StakeholderId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Bip32PublicKey} pubk
    * @returns {StakeholderId}
    */
    static new(pubk) {
        _assertClass(pubk, Bip32PublicKey);
        const ret = wasm.stakeholderid_new(pubk.ptr);
        return StakeholderId.__wrap(ret);
    }
}

const TransactionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transaction_free(ptr));
/**
*/
export class Transaction {

    static __wrap(ptr) {
        const obj = Object.create(Transaction.prototype);
        obj.ptr = ptr;
        TransactionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transaction_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transaction_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Transaction}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transaction_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Transaction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transaction_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Transaction}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transaction_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Transaction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transaction_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transaction_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Transaction}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transaction_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Transaction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {TransactionBody}
    */
    body() {
        const ret = wasm.transaction_body(this.ptr);
        return TransactionBody.__wrap(ret);
    }
    /**
    * @returns {TransactionWitnessSet}
    */
    witness_set() {
        const ret = wasm.transaction_witness_set(this.ptr);
        return TransactionWitnessSet.__wrap(ret);
    }
    /**
    * @returns {boolean}
    */
    is_valid() {
        const ret = wasm.transaction_is_valid(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {AuxiliaryData | undefined}
    */
    auxiliary_data() {
        const ret = wasm.transaction_auxiliary_data(this.ptr);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
    /**
    * @param {TransactionBody} body
    * @param {TransactionWitnessSet} witness_set
    * @param {boolean} is_valid
    * @param {AuxiliaryData | undefined} auxiliary_data
    * @returns {Transaction}
    */
    static new(body, witness_set, is_valid, auxiliary_data) {
        _assertClass(body, TransactionBody);
        _assertClass(witness_set, TransactionWitnessSet);
        let ptr0 = 0;
        if (!isLikeNone(auxiliary_data)) {
            _assertClass(auxiliary_data, AuxiliaryData);
            ptr0 = auxiliary_data.ptr;
            auxiliary_data.ptr = 0;
        }
        const ret = wasm.transaction_new(body.ptr, witness_set.ptr, is_valid, ptr0);
        return Transaction.__wrap(ret);
    }
}

const TransactionBodyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionbody_free(ptr));
/**
*/
export class TransactionBody {

    static __wrap(ptr) {
        const obj = Object.create(TransactionBody.prototype);
        obj.ptr = ptr;
        TransactionBodyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionBodyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionbody_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbody_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {TransactionBody}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionbody_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionBody.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbody_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {TransactionBody}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionbody_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionBody.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbody_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbody_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {TransactionBody}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionbody_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionBody.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {TransactionInputList}
    */
    inputs() {
        const ret = wasm.transactionbody_inputs(this.ptr);
        return TransactionInputList.__wrap(ret);
    }
    /**
    * @returns {TransactionOutputList}
    */
    outputs() {
        const ret = wasm.transactionbody_outputs(this.ptr);
        return TransactionOutputList.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    fee() {
        const ret = wasm.transactionbody_fee(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} ttl
    */
    set_ttl(ttl) {
        wasm.transactionbody_set_ttl(this.ptr, ttl);
    }
    /**
    * @returns {bigint | undefined}
    */
    ttl() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbody_ttl(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {CertificateList} certs
    */
    set_certs(certs) {
        _assertClass(certs, CertificateList);
        wasm.transactionbody_set_certs(this.ptr, certs.ptr);
    }
    /**
    * @returns {CertificateList | undefined}
    */
    certs() {
        const ret = wasm.transactionbody_certs(this.ptr);
        return ret === 0 ? undefined : CertificateList.__wrap(ret);
    }
    /**
    * @param {MapRewardAccountToCoin} withdrawals
    */
    set_withdrawals(withdrawals) {
        _assertClass(withdrawals, MapRewardAccountToCoin);
        wasm.transactionbody_set_withdrawals(this.ptr, withdrawals.ptr);
    }
    /**
    * @returns {MapRewardAccountToCoin | undefined}
    */
    withdrawals() {
        const ret = wasm.transactionbody_withdrawals(this.ptr);
        return ret === 0 ? undefined : MapRewardAccountToCoin.__wrap(ret);
    }
    /**
    * @param {AuxiliaryDataHash} auxiliary_data_hash
    */
    set_auxiliary_data_hash(auxiliary_data_hash) {
        _assertClass(auxiliary_data_hash, AuxiliaryDataHash);
        wasm.transactionbody_set_auxiliary_data_hash(this.ptr, auxiliary_data_hash.ptr);
    }
    /**
    * @returns {AuxiliaryDataHash | undefined}
    */
    auxiliary_data_hash() {
        const ret = wasm.transactionbody_auxiliary_data_hash(this.ptr);
        return ret === 0 ? undefined : AuxiliaryDataHash.__wrap(ret);
    }
    /**
    * @param {bigint} validity_interval_start
    */
    set_validity_interval_start(validity_interval_start) {
        wasm.transactionbody_set_validity_interval_start(this.ptr, validity_interval_start);
    }
    /**
    * @returns {bigint | undefined}
    */
    validity_interval_start() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbody_validity_interval_start(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Mint} mint
    */
    set_mint(mint) {
        _assertClass(mint, Mint);
        wasm.transactionbody_set_mint(this.ptr, mint.ptr);
    }
    /**
    * @returns {Mint | undefined}
    */
    mint() {
        const ret = wasm.transactionbody_mint(this.ptr);
        return ret === 0 ? undefined : Mint.__wrap(ret);
    }
    /**
    * @param {ScriptDataHash} script_data_hash
    */
    set_script_data_hash(script_data_hash) {
        _assertClass(script_data_hash, ScriptDataHash);
        wasm.transactionbody_set_script_data_hash(this.ptr, script_data_hash.ptr);
    }
    /**
    * @returns {ScriptDataHash | undefined}
    */
    script_data_hash() {
        const ret = wasm.transactionbody_script_data_hash(this.ptr);
        return ret === 0 ? undefined : ScriptDataHash.__wrap(ret);
    }
    /**
    * @param {TransactionInputList} collateral_inputs
    */
    set_collateral_inputs(collateral_inputs) {
        _assertClass(collateral_inputs, TransactionInputList);
        wasm.transactionbody_set_collateral_inputs(this.ptr, collateral_inputs.ptr);
    }
    /**
    * @returns {TransactionInputList | undefined}
    */
    collateral_inputs() {
        const ret = wasm.transactionbody_collateral_inputs(this.ptr);
        return ret === 0 ? undefined : TransactionInputList.__wrap(ret);
    }
    /**
    * @param {RequiredSigners} required_signers
    */
    set_required_signers(required_signers) {
        _assertClass(required_signers, RequiredSigners);
        wasm.transactionbody_set_required_signers(this.ptr, required_signers.ptr);
    }
    /**
    * @returns {RequiredSigners | undefined}
    */
    required_signers() {
        const ret = wasm.transactionbody_required_signers(this.ptr);
        return ret === 0 ? undefined : RequiredSigners.__wrap(ret);
    }
    /**
    * @param {NetworkId} network_id
    */
    set_network_id(network_id) {
        _assertClass(network_id, NetworkId);
        wasm.transactionbody_set_network_id(this.ptr, network_id.ptr);
    }
    /**
    * @returns {NetworkId | undefined}
    */
    network_id() {
        const ret = wasm.transactionbody_network_id(this.ptr);
        return ret === 0 ? undefined : NetworkId.__wrap(ret);
    }
    /**
    * @param {TransactionOutput} collateral_return
    */
    set_collateral_return(collateral_return) {
        _assertClass(collateral_return, TransactionOutput);
        wasm.transactionbody_set_collateral_return(this.ptr, collateral_return.ptr);
    }
    /**
    * @returns {TransactionOutput | undefined}
    */
    collateral_return() {
        const ret = wasm.transactionbody_collateral_return(this.ptr);
        return ret === 0 ? undefined : TransactionOutput.__wrap(ret);
    }
    /**
    * @param {bigint} total_collateral
    */
    set_total_collateral(total_collateral) {
        wasm.transactionbody_set_total_collateral(this.ptr, total_collateral);
    }
    /**
    * @returns {bigint | undefined}
    */
    total_collateral() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbody_total_collateral(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {TransactionInputList} reference_inputs
    */
    set_reference_inputs(reference_inputs) {
        _assertClass(reference_inputs, TransactionInputList);
        wasm.transactionbody_set_reference_inputs(this.ptr, reference_inputs.ptr);
    }
    /**
    * @returns {TransactionInputList | undefined}
    */
    reference_inputs() {
        const ret = wasm.transactionbody_reference_inputs(this.ptr);
        return ret === 0 ? undefined : TransactionInputList.__wrap(ret);
    }
    /**
    * @param {VotingProcedures} voting_procedures
    */
    set_voting_procedures(voting_procedures) {
        _assertClass(voting_procedures, VotingProcedures);
        wasm.transactionbody_set_voting_procedures(this.ptr, voting_procedures.ptr);
    }
    /**
    * @returns {VotingProcedures | undefined}
    */
    voting_procedures() {
        const ret = wasm.transactionbody_voting_procedures(this.ptr);
        return ret === 0 ? undefined : VotingProcedures.__wrap(ret);
    }
    /**
    * @param {ProposalProcedureList} proposal_procedures
    */
    set_proposal_procedures(proposal_procedures) {
        _assertClass(proposal_procedures, ProposalProcedureList);
        wasm.transactionbody_set_proposal_procedures(this.ptr, proposal_procedures.ptr);
    }
    /**
    * @returns {ProposalProcedureList | undefined}
    */
    proposal_procedures() {
        const ret = wasm.transactionbody_proposal_procedures(this.ptr);
        return ret === 0 ? undefined : ProposalProcedureList.__wrap(ret);
    }
    /**
    * @param {bigint} current_treasury_value
    */
    set_current_treasury_value(current_treasury_value) {
        wasm.transactionbody_set_current_treasury_value(this.ptr, current_treasury_value);
    }
    /**
    * @returns {bigint | undefined}
    */
    current_treasury_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbody_current_treasury_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} donation
    */
    set_donation(donation) {
        wasm.transactionbody_set_donation(this.ptr, donation);
    }
    /**
    * @returns {bigint | undefined}
    */
    donation() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbody_donation(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {TransactionInputList} inputs
    * @param {TransactionOutputList} outputs
    * @param {bigint} fee
    * @returns {TransactionBody}
    */
    static new(inputs, outputs, fee) {
        _assertClass(inputs, TransactionInputList);
        _assertClass(outputs, TransactionOutputList);
        const ret = wasm.transactionbody_new(inputs.ptr, outputs.ptr, fee);
        return TransactionBody.__wrap(ret);
    }
}

const TransactionBodyListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionbodylist_free(ptr));
/**
*/
export class TransactionBodyList {

    static __wrap(ptr) {
        const obj = Object.create(TransactionBodyList.prototype);
        obj.ptr = ptr;
        TransactionBodyListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionBodyListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionbodylist_free(ptr);
    }
    /**
    * @returns {TransactionBodyList}
    */
    static new() {
        const ret = wasm.certificatelist_new();
        return TransactionBodyList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.transactionbodylist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {TransactionBody}
    */
    get(index) {
        const ret = wasm.transactionbodylist_get(this.ptr, index);
        return TransactionBody.__wrap(ret);
    }
    /**
    * @param {TransactionBody} elem
    */
    add(elem) {
        _assertClass(elem, TransactionBody);
        wasm.transactionbodylist_add(this.ptr, elem.ptr);
    }
}

const TransactionBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionbuilder_free(ptr));
/**
*/
export class TransactionBuilder {

    static __wrap(ptr) {
        const obj = Object.create(TransactionBuilder.prototype);
        obj.ptr = ptr;
        TransactionBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionbuilder_free(ptr);
    }
    /**
    * This automatically selects and adds inputs from {inputs} consisting of just enough to cover
    * the outputs that have already been added.
    * This should be called after adding all certs/outputs/etc and will be an error otherwise.
    * Uses CIP2: https://github.com/cardano-foundation/CIPs/blob/master/CIP-0002/CIP-0002.md
    * Adding a change output must be called after via TransactionBuilder::add_change_if_needed()
    * This function, diverging from CIP2, takes into account fees and will attempt to add additional
    * inputs to cover the minimum fees. This does not, however, set the txbuilder's fee.
    * @param {number} strategy
    */
    select_utxos(strategy) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_select_utxos(retptr, this.ptr, strategy);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {InputBuilderResult} result
    */
    add_input(result) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(result, InputBuilderResult);
            wasm.transactionbuilder_add_input(retptr, this.ptr, result.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {InputBuilderResult} result
    */
    add_utxo(result) {
        _assertClass(result, InputBuilderResult);
        wasm.transactionbuilder_add_utxo(this.ptr, result.ptr);
    }
    /**
    * calculates how much the fee would increase if you added a given output
    * @param {InputBuilderResult} result
    * @returns {bigint}
    */
    fee_for_input(result) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(result, InputBuilderResult);
            wasm.transactionbuilder_fee_for_input(retptr, this.ptr, result.ptr);
            var r0 = getBigInt64Memory0()[retptr / 8 + 0];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            return BigInt.asUintN(64, r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {TransactionUnspentOutput} utxo
    */
    add_reference_input(utxo) {
        _assertClass(utxo, TransactionUnspentOutput);
        wasm.transactionbuilder_add_reference_input(this.ptr, utxo.ptr);
    }
    /**
    * Add explicit output via a TransactionOutput object
    * @param {SingleOutputBuilderResult} builder_result
    */
    add_output(builder_result) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(builder_result, SingleOutputBuilderResult);
            wasm.transactionbuilder_add_output(retptr, this.ptr, builder_result.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * calculates how much the fee would increase if you added a given output
    * @param {SingleOutputBuilderResult} builder
    * @returns {bigint}
    */
    fee_for_output(builder) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(builder, SingleOutputBuilderResult);
            wasm.transactionbuilder_fee_for_output(retptr, this.ptr, builder.ptr);
            var r0 = getBigInt64Memory0()[retptr / 8 + 0];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            return BigInt.asUintN(64, r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} fee
    */
    set_fee(fee) {
        wasm.transactionbuilder_set_fee(this.ptr, fee);
    }
    /**
    * @param {bigint} ttl
    */
    set_ttl(ttl) {
        wasm.transactionbuilder_set_ttl(this.ptr, ttl);
    }
    /**
    * @param {bigint} validity_start_interval
    */
    set_validity_start_interval(validity_start_interval) {
        wasm.transactionbuilder_set_validity_start_interval(this.ptr, validity_start_interval);
    }
    /**
    * @param {CertificateBuilderResult} result
    */
    add_cert(result) {
        _assertClass(result, CertificateBuilderResult);
        wasm.transactionbuilder_add_cert(this.ptr, result.ptr);
    }
    /**
    * @returns {MapRewardAccountToCoin | undefined}
    */
    get_withdrawals() {
        const ret = wasm.transactionbuilder_get_withdrawals(this.ptr);
        return ret === 0 ? undefined : MapRewardAccountToCoin.__wrap(ret);
    }
    /**
    * @param {WithdrawalBuilderResult} result
    */
    add_withdrawal(result) {
        _assertClass(result, WithdrawalBuilderResult);
        wasm.transactionbuilder_add_withdrawal(this.ptr, result.ptr);
    }
    /**
    * @returns {AuxiliaryData | undefined}
    */
    get_auxiliary_data() {
        const ret = wasm.transactionbuilder_get_auxiliary_data(this.ptr);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
    /**
    * @param {AuxiliaryData} new_aux_data
    */
    set_auxiliary_data(new_aux_data) {
        _assertClass(new_aux_data, AuxiliaryData);
        wasm.transactionbuilder_set_auxiliary_data(this.ptr, new_aux_data.ptr);
    }
    /**
    * @param {AuxiliaryData} new_aux_data
    */
    add_auxiliary_data(new_aux_data) {
        _assertClass(new_aux_data, AuxiliaryData);
        wasm.transactionbuilder_add_auxiliary_data(this.ptr, new_aux_data.ptr);
    }
    /**
    * @param {MintBuilderResult} result
    */
    add_mint(result) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(result, MintBuilderResult);
            wasm.transactionbuilder_add_mint(retptr, this.ptr, result.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the current mint state in the builder
    * @returns {Mint | undefined}
    */
    get_mint() {
        const ret = wasm.transactionbuilder_get_mint(this.ptr);
        return ret === 0 ? undefined : Mint.__wrap(ret);
    }
    /**
    * @param {TransactionBuilderConfig} cfg
    * @returns {TransactionBuilder}
    */
    static new(cfg) {
        _assertClass(cfg, TransactionBuilderConfig);
        const ret = wasm.transactionbuilder_new(cfg.ptr);
        return TransactionBuilder.__wrap(ret);
    }
    /**
    * @param {InputBuilderResult} result
    */
    add_collateral(result) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(result, InputBuilderResult);
            wasm.transactionbuilder_add_collateral(retptr, this.ptr, result.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Ed25519KeyHash} hash
    */
    add_required_signer(hash) {
        _assertClass(hash, Ed25519KeyHash);
        wasm.transactionbuilder_add_required_signer(this.ptr, hash.ptr);
    }
    /**
    * @param {NetworkId} network_id
    */
    set_network_id(network_id) {
        _assertClass(network_id, NetworkId);
        wasm.transactionbuilder_set_network_id(this.ptr, network_id.ptr);
    }
    /**
    * @returns {NetworkId | undefined}
    */
    network_id() {
        const ret = wasm.transactionbuilder_network_id(this.ptr);
        return ret === 0 ? undefined : NetworkId.__wrap(ret);
    }
    /**
    * does not include refunds or withdrawals
    * @returns {Value}
    */
    get_explicit_input() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_get_explicit_input(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Value.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * withdrawals and refunds
    * @returns {Value}
    */
    get_implicit_input() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_get_implicit_input(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Value.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Return explicit input plus implicit input plus mint
    * @returns {Value}
    */
    get_total_input() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_get_total_input(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Value.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Return explicit output plus implicit output plus burn (does not consider fee directly)
    * @returns {Value}
    */
    get_total_output() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_get_total_output(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Value.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * does not include fee
    * @returns {Value}
    */
    get_explicit_output() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_get_explicit_output(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Value.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    get_deposit() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_get_deposit(retptr, this.ptr);
            var r0 = getBigInt64Memory0()[retptr / 8 + 0];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            return BigInt.asUintN(64, r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint | undefined}
    */
    get_fee_if_set() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_get_fee_if_set(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {TransactionOutput} output
    */
    set_collateral_return(output) {
        _assertClass(output, TransactionOutput);
        wasm.transactionbuilder_set_collateral_return(this.ptr, output.ptr);
    }
    /**
    * @returns {number}
    */
    full_size() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_full_size(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0 >>> 0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint32Array}
    */
    output_sizes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_output_sizes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU32FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 4);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Builds the transaction and moves to the next step redeemer units can be added and a draft tx can
    * be evaluated
    * NOTE: is_valid set to true
    * @param {number} algo
    * @param {Address} change_address
    * @returns {TxRedeemerBuilder}
    */
    build_for_evaluation(algo, change_address) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(change_address, Address);
            wasm.transactionbuilder_build_for_evaluation(retptr, this.ptr, algo, change_address.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TxRedeemerBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Builds the transaction and moves to the next step where any real witness can be added
    * NOTE: is_valid set to true
    * @param {number} algo
    * @param {Address} change_address
    * @returns {SignedTxBuilder}
    */
    build(algo, change_address) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(change_address, Address);
            wasm.transactionbuilder_build(retptr, this.ptr, algo, change_address.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SignedTxBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * used to override the exunit values initially provided when adding inputs
    * @param {RedeemerWitnessKey} redeemer
    * @param {ExUnits} ex_units
    */
    set_exunits(redeemer, ex_units) {
        _assertClass(redeemer, RedeemerWitnessKey);
        _assertClass(ex_units, ExUnits);
        wasm.transactionbuilder_set_exunits(this.ptr, redeemer.ptr, ex_units.ptr);
    }
    /**
    * warning: sum of all parts of a transaction must equal 0. You cannot just set the fee to the min value and forget about it
    * warning: min_fee may be slightly larger than the actual minimum fee (ex: a few lovelaces)
    * this is done to simplify the library code, but can be fixed later
    * @param {boolean} script_calulation
    * @returns {bigint}
    */
    min_fee(script_calulation) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilder_min_fee(retptr, this.ptr, script_calulation);
            var r0 = getBigInt64Memory0()[retptr / 8 + 0];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            return BigInt.asUintN(64, r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Warning: this function will mutate the /fee/ field
    * Make sure to call this function last after setting all other tx-body properties
    * Editing inputs, outputs, mint, etc. after change been calculated
    * might cause a mismatch in calculated fee versus the required fee
    * @param {Address} address
    * @param {boolean} include_exunits
    * @returns {boolean}
    */
    add_change_if_needed(address, include_exunits) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(address, Address);
            wasm.transactionbuilder_add_change_if_needed(retptr, this.ptr, address.ptr, include_exunits);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0 !== 0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const TransactionBuilderConfigFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionbuilderconfig_free(ptr));
/**
*/
export class TransactionBuilderConfig {

    static __wrap(ptr) {
        const obj = Object.create(TransactionBuilderConfig.prototype);
        obj.ptr = ptr;
        TransactionBuilderConfigFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionBuilderConfigFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionbuilderconfig_free(ptr);
    }
}

const TransactionBuilderConfigBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionbuilderconfigbuilder_free(ptr));
/**
*/
export class TransactionBuilderConfigBuilder {

    static __wrap(ptr) {
        const obj = Object.create(TransactionBuilderConfigBuilder.prototype);
        obj.ptr = ptr;
        TransactionBuilderConfigBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionBuilderConfigBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionbuilderconfigbuilder_free(ptr);
    }
    /**
    * @returns {TransactionBuilderConfigBuilder}
    */
    static new() {
        const ret = wasm.transactionbuilderconfigbuilder_new();
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {LinearFee} fee_algo
    * @returns {TransactionBuilderConfigBuilder}
    */
    fee_algo(fee_algo) {
        _assertClass(fee_algo, LinearFee);
        const ret = wasm.transactionbuilderconfigbuilder_fee_algo(this.ptr, fee_algo.ptr);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {bigint} coins_per_utxo_byte
    * @returns {TransactionBuilderConfigBuilder}
    */
    coins_per_utxo_byte(coins_per_utxo_byte) {
        const ret = wasm.transactionbuilderconfigbuilder_coins_per_utxo_byte(this.ptr, coins_per_utxo_byte);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {bigint} pool_deposit
    * @returns {TransactionBuilderConfigBuilder}
    */
    pool_deposit(pool_deposit) {
        const ret = wasm.transactionbuilderconfigbuilder_pool_deposit(this.ptr, pool_deposit);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {bigint} key_deposit
    * @returns {TransactionBuilderConfigBuilder}
    */
    key_deposit(key_deposit) {
        const ret = wasm.transactionbuilderconfigbuilder_key_deposit(this.ptr, key_deposit);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {number} max_value_size
    * @returns {TransactionBuilderConfigBuilder}
    */
    max_value_size(max_value_size) {
        const ret = wasm.transactionbuilderconfigbuilder_max_value_size(this.ptr, max_value_size);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {number} max_tx_size
    * @returns {TransactionBuilderConfigBuilder}
    */
    max_tx_size(max_tx_size) {
        const ret = wasm.transactionbuilderconfigbuilder_max_tx_size(this.ptr, max_tx_size);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {boolean} prefer_pure_change
    * @returns {TransactionBuilderConfigBuilder}
    */
    prefer_pure_change(prefer_pure_change) {
        const ret = wasm.transactionbuilderconfigbuilder_prefer_pure_change(this.ptr, prefer_pure_change);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {ExUnitPrices} ex_unit_prices
    * @returns {TransactionBuilderConfigBuilder}
    */
    ex_unit_prices(ex_unit_prices) {
        _assertClass(ex_unit_prices, ExUnitPrices);
        const ret = wasm.transactionbuilderconfigbuilder_ex_unit_prices(this.ptr, ex_unit_prices.ptr);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {CostModels} cost_models
    * @returns {TransactionBuilderConfigBuilder}
    */
    cost_models(cost_models) {
        _assertClass(cost_models, CostModels);
        const ret = wasm.transactionbuilderconfigbuilder_cost_models(this.ptr, cost_models.ptr);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {number} collateral_percentage
    * @returns {TransactionBuilderConfigBuilder}
    */
    collateral_percentage(collateral_percentage) {
        const ret = wasm.transactionbuilderconfigbuilder_collateral_percentage(this.ptr, collateral_percentage);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @param {number} max_collateral_inputs
    * @returns {TransactionBuilderConfigBuilder}
    */
    max_collateral_inputs(max_collateral_inputs) {
        const ret = wasm.transactionbuilderconfigbuilder_max_collateral_inputs(this.ptr, max_collateral_inputs);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
    * @returns {TransactionBuilderConfig}
    */
    build() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionbuilderconfigbuilder_build(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionBuilderConfig.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const TransactionHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionhash_free(ptr));
/**
*/
export class TransactionHash {

    static __wrap(ptr) {
        const obj = Object.create(TransactionHash.prototype);
        obj.ptr = ptr;
        TransactionHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionhash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionhash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionhash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionhash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {TransactionHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionhash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {TransactionHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionhash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {TransactionHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionhash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const TransactionInputFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactioninput_free(ptr));
/**
*/
export class TransactionInput {

    static __wrap(ptr) {
        const obj = Object.create(TransactionInput.prototype);
        obj.ptr = ptr;
        TransactionInputFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionInputFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactioninput_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactioninput_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {TransactionInput}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactioninput_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionInput.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactioninput_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {TransactionInput}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactioninput_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionInput.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactioninput_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactioninput_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {TransactionInput}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactioninput_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionInput.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {TransactionHash}
    */
    transaction_id() {
        const ret = wasm.transactioninput_transaction_id(this.ptr);
        return TransactionHash.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    index() {
        const ret = wasm.transactioninput_index(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {TransactionHash} transaction_id
    * @param {bigint} index
    * @returns {TransactionInput}
    */
    static new(transaction_id, index) {
        _assertClass(transaction_id, TransactionHash);
        const ret = wasm.transactioninput_new(transaction_id.ptr, index);
        return TransactionInput.__wrap(ret);
    }
}

const TransactionInputListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactioninputlist_free(ptr));
/**
*/
export class TransactionInputList {

    static __wrap(ptr) {
        const obj = Object.create(TransactionInputList.prototype);
        obj.ptr = ptr;
        TransactionInputListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionInputListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactioninputlist_free(ptr);
    }
    /**
    * @returns {TransactionInputList}
    */
    static new() {
        const ret = wasm.certificatelist_new();
        return TransactionInputList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.transactioninputlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {TransactionInput}
    */
    get(index) {
        const ret = wasm.transactioninputlist_get(this.ptr, index);
        return TransactionInput.__wrap(ret);
    }
    /**
    * @param {TransactionInput} elem
    */
    add(elem) {
        _assertClass(elem, TransactionInput);
        wasm.transactioninputlist_add(this.ptr, elem.ptr);
    }
}

const TransactionMetadatumFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionmetadatum_free(ptr));
/**
*/
export class TransactionMetadatum {

    static __wrap(ptr) {
        const obj = Object.create(TransactionMetadatum.prototype);
        obj.ptr = ptr;
        TransactionMetadatumFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionMetadatumFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionmetadatum_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionmetadatum_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} cbor_bytes
    * @returns {TransactionMetadatum}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionmetadatum_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionMetadatum.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionmetadatum_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_json_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionmetadatum_to_json_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {TransactionMetadatum}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionmetadatum_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionMetadatum.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {MetadatumMap} map
    * @returns {TransactionMetadatum}
    */
    static new_map(map) {
        _assertClass(map, MetadatumMap);
        const ret = wasm.transactionmetadatum_new_map(map.ptr);
        return TransactionMetadatum.__wrap(ret);
    }
    /**
    * @param {MetadatumList} elements
    * @returns {TransactionMetadatum}
    */
    static new_list(elements) {
        _assertClass(elements, MetadatumList);
        const ret = wasm.transactionmetadatum_new_list(elements.ptr);
        return TransactionMetadatum.__wrap(ret);
    }
    /**
    * @param {Int} int
    * @returns {TransactionMetadatum}
    */
    static new_int(int) {
        _assertClass(int, Int);
        const ret = wasm.transactionmetadatum_new_int(int.ptr);
        return TransactionMetadatum.__wrap(ret);
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {TransactionMetadatum}
    */
    static new_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionmetadatum_new_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionMetadatum.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} text
    * @returns {TransactionMetadatum}
    */
    static new_text(text) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionmetadatum_new_text(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionMetadatum.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.transactionmetadatum_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {MetadatumMap | undefined}
    */
    as_map() {
        const ret = wasm.transactionmetadatum_as_map(this.ptr);
        return ret === 0 ? undefined : MetadatumMap.__wrap(ret);
    }
    /**
    * @returns {MetadatumList | undefined}
    */
    as_list() {
        const ret = wasm.transactionmetadatum_as_list(this.ptr);
        return ret === 0 ? undefined : MetadatumList.__wrap(ret);
    }
    /**
    * @returns {Int | undefined}
    */
    as_int() {
        const ret = wasm.transactionmetadatum_as_int(this.ptr);
        return ret === 0 ? undefined : Int.__wrap(ret);
    }
    /**
    * @returns {Uint8Array | undefined}
    */
    as_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionmetadatum_as_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    as_text() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionmetadatum_as_text(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const TransactionMetadatumLabelsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionmetadatumlabels_free(ptr));
/**
*/
export class TransactionMetadatumLabels {

    static __wrap(ptr) {
        const obj = Object.create(TransactionMetadatumLabels.prototype);
        obj.ptr = ptr;
        TransactionMetadatumLabelsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionMetadatumLabelsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionmetadatumlabels_free(ptr);
    }
    /**
    * @returns {TransactionMetadatumLabels}
    */
    static new() {
        const ret = wasm.metadatumlist_new();
        return TransactionMetadatumLabels.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.transactionmetadatumlabels_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {bigint}
    */
    get(index) {
        const ret = wasm.transactionmetadatumlabels_get(this.ptr, index);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} elem
    */
    add(elem) {
        wasm.transactionmetadatumlabels_add(this.ptr, elem);
    }
}

const TransactionMetadatumListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionmetadatumlist_free(ptr));
/**
*/
export class TransactionMetadatumList {

    static __wrap(ptr) {
        const obj = Object.create(TransactionMetadatumList.prototype);
        obj.ptr = ptr;
        TransactionMetadatumListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionMetadatumListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionmetadatumlist_free(ptr);
    }
    /**
    * @returns {TransactionMetadatumList}
    */
    static new() {
        const ret = wasm.metadatumlist_new();
        return TransactionMetadatumList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.transactionmetadatumlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {TransactionMetadatum}
    */
    get(index) {
        const ret = wasm.transactionmetadatumlist_get(this.ptr, index);
        return TransactionMetadatum.__wrap(ret);
    }
    /**
    * @param {TransactionMetadatum} elem
    */
    add(elem) {
        _assertClass(elem, TransactionMetadatum);
        wasm.transactionmetadatumlist_add(this.ptr, elem.ptr);
    }
}

const TransactionOutputFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionoutput_free(ptr));
/**
*/
export class TransactionOutput {

    static __wrap(ptr) {
        const obj = Object.create(TransactionOutput.prototype);
        obj.ptr = ptr;
        TransactionOutputFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionOutputFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionoutput_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionoutput_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {TransactionOutput}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionoutput_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionOutput.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionoutput_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {TransactionOutput}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionoutput_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionOutput.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionoutput_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionoutput_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {TransactionOutput}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionoutput_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionOutput.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {AlonzoFormatTxOut} alonzo_format_tx_out
    * @returns {TransactionOutput}
    */
    static new_alonzo_format_tx_out(alonzo_format_tx_out) {
        _assertClass(alonzo_format_tx_out, AlonzoFormatTxOut);
        const ret = wasm.transactionoutput_new_alonzo_format_tx_out(alonzo_format_tx_out.ptr);
        return TransactionOutput.__wrap(ret);
    }
    /**
    * @param {ConwayFormatTxOut} conway_format_tx_out
    * @returns {TransactionOutput}
    */
    static new_conway_format_tx_out(conway_format_tx_out) {
        _assertClass(conway_format_tx_out, ConwayFormatTxOut);
        const ret = wasm.transactionoutput_new_conway_format_tx_out(conway_format_tx_out.ptr);
        return TransactionOutput.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.transactionoutput_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {AlonzoFormatTxOut | undefined}
    */
    as_alonzo_format_tx_out() {
        const ret = wasm.transactionoutput_as_alonzo_format_tx_out(this.ptr);
        return ret === 0 ? undefined : AlonzoFormatTxOut.__wrap(ret);
    }
    /**
    * @returns {ConwayFormatTxOut | undefined}
    */
    as_conway_format_tx_out() {
        const ret = wasm.transactionoutput_as_conway_format_tx_out(this.ptr);
        return ret === 0 ? undefined : ConwayFormatTxOut.__wrap(ret);
    }
    /**
    * @param {Address} address
    * @param {Value} amount
    * @param {DatumOption | undefined} datum_option
    * @param {Script | undefined} script_reference
    * @returns {TransactionOutput}
    */
    static new(address, amount, datum_option, script_reference) {
        _assertClass(address, Address);
        _assertClass(amount, Value);
        let ptr0 = 0;
        if (!isLikeNone(datum_option)) {
            _assertClass(datum_option, DatumOption);
            ptr0 = datum_option.ptr;
            datum_option.ptr = 0;
        }
        let ptr1 = 0;
        if (!isLikeNone(script_reference)) {
            _assertClass(script_reference, Script);
            ptr1 = script_reference.ptr;
            script_reference.ptr = 0;
        }
        const ret = wasm.transactionoutput_new(address.ptr, amount.ptr, ptr0, ptr1);
        return TransactionOutput.__wrap(ret);
    }
    /**
    * @returns {Address}
    */
    address() {
        const ret = wasm.transactionoutput_address(this.ptr);
        return Address.__wrap(ret);
    }
    /**
    * @returns {Value}
    */
    amount() {
        const ret = wasm.transactionoutput_amount(this.ptr);
        return Value.__wrap(ret);
    }
    /**
    * @param {Value} amount
    */
    set_amount(amount) {
        _assertClass(amount, Value);
        wasm.transactionoutput_set_amount(this.ptr, amount.ptr);
    }
    /**
    * @returns {DatumOption | undefined}
    */
    datum() {
        const ret = wasm.transactionoutput_datum(this.ptr);
        return ret === 0 ? undefined : DatumOption.__wrap(ret);
    }
    /**
    * Get the datum hash from a tx output if present as a hash.
    * Returns None if there is no datum, or the datum is inlined.
    * Use TransactionOutput::datum() for inlined datums.
    * @returns {DatumHash | undefined}
    */
    datum_hash() {
        const ret = wasm.transactionoutput_datum_hash(this.ptr);
        return ret === 0 ? undefined : DatumHash.__wrap(ret);
    }
    /**
    * @returns {Script | undefined}
    */
    script_ref() {
        const ret = wasm.transactionoutput_script_ref(this.ptr);
        return ret === 0 ? undefined : Script.__wrap(ret);
    }
}

const TransactionOutputAmountBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionoutputamountbuilder_free(ptr));
/**
*/
export class TransactionOutputAmountBuilder {

    static __wrap(ptr) {
        const obj = Object.create(TransactionOutputAmountBuilder.prototype);
        obj.ptr = ptr;
        TransactionOutputAmountBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionOutputAmountBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionoutputamountbuilder_free(ptr);
    }
    /**
    * @param {Value} amount
    * @returns {TransactionOutputAmountBuilder}
    */
    with_value(amount) {
        _assertClass(amount, Value);
        const ret = wasm.transactionoutputamountbuilder_with_value(this.ptr, amount.ptr);
        return TransactionOutputAmountBuilder.__wrap(ret);
    }
    /**
    * @param {MultiAsset} multiasset
    * @param {bigint} coins_per_utxo_byte
    * @returns {TransactionOutputAmountBuilder}
    */
    with_asset_and_min_required_coin(multiasset, coins_per_utxo_byte) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(multiasset, MultiAsset);
            wasm.transactionoutputamountbuilder_with_asset_and_min_required_coin(retptr, this.ptr, multiasset.ptr, coins_per_utxo_byte);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionOutputAmountBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {SingleOutputBuilderResult}
    */
    build() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionoutputamountbuilder_build(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SingleOutputBuilderResult.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const TransactionOutputBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionoutputbuilder_free(ptr));
/**
* We introduce a builder-pattern format for creating transaction outputs
* This is because:
* 1. Some fields (i.e. data hash) are optional, and we can't easily expose Option<> in WASM
* 2. Some fields like amounts have many ways it could be set (some depending on other field values being known)
* 3. Easier to adapt as the output format gets more complicated in future Cardano releases
*/
export class TransactionOutputBuilder {

    static __wrap(ptr) {
        const obj = Object.create(TransactionOutputBuilder.prototype);
        obj.ptr = ptr;
        TransactionOutputBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionOutputBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionoutputbuilder_free(ptr);
    }
    /**
    * @returns {TransactionOutputBuilder}
    */
    static new() {
        const ret = wasm.transactionoutputbuilder_new();
        return TransactionOutputBuilder.__wrap(ret);
    }
    /**
    * @param {Address} address
    * @returns {TransactionOutputBuilder}
    */
    with_address(address) {
        _assertClass(address, Address);
        const ret = wasm.transactionoutputbuilder_with_address(this.ptr, address.ptr);
        return TransactionOutputBuilder.__wrap(ret);
    }
    /**
    * A communication datum is one where the data hash is used in the tx output
    * Yet the full datum is included in the witness of the same transaction
    * @param {PlutusData} datum
    * @returns {TransactionOutputBuilder}
    */
    with_communication_data(datum) {
        _assertClass(datum, PlutusData);
        const ret = wasm.transactionoutputbuilder_with_communication_data(this.ptr, datum.ptr);
        return TransactionOutputBuilder.__wrap(ret);
    }
    /**
    * @param {DatumOption} datum
    * @returns {TransactionOutputBuilder}
    */
    with_data(datum) {
        _assertClass(datum, DatumOption);
        const ret = wasm.transactionoutputbuilder_with_data(this.ptr, datum.ptr);
        return TransactionOutputBuilder.__wrap(ret);
    }
    /**
    * @param {Script} script_ref
    * @returns {TransactionOutputBuilder}
    */
    with_reference_script(script_ref) {
        _assertClass(script_ref, Script);
        const ret = wasm.transactionoutputbuilder_with_reference_script(this.ptr, script_ref.ptr);
        return TransactionOutputBuilder.__wrap(ret);
    }
    /**
    * @returns {TransactionOutputAmountBuilder}
    */
    next() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionoutputbuilder_next(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionOutputAmountBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const TransactionOutputListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionoutputlist_free(ptr));
/**
*/
export class TransactionOutputList {

    static __wrap(ptr) {
        const obj = Object.create(TransactionOutputList.prototype);
        obj.ptr = ptr;
        TransactionOutputListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionOutputListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionoutputlist_free(ptr);
    }
    /**
    * @returns {TransactionOutputList}
    */
    static new() {
        const ret = wasm.certificatelist_new();
        return TransactionOutputList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.transactionoutputlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {TransactionOutput}
    */
    get(index) {
        const ret = wasm.transactionoutputlist_get(this.ptr, index);
        return TransactionOutput.__wrap(ret);
    }
    /**
    * @param {TransactionOutput} elem
    */
    add(elem) {
        _assertClass(elem, TransactionOutput);
        wasm.transactionoutputlist_add(this.ptr, elem.ptr);
    }
}

const TransactionUnspentOutputFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionunspentoutput_free(ptr));
/**
*/
export class TransactionUnspentOutput {

    static __wrap(ptr) {
        const obj = Object.create(TransactionUnspentOutput.prototype);
        obj.ptr = ptr;
        TransactionUnspentOutputFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionUnspentOutputFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionunspentoutput_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes.
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionunspentoutput_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {TransactionUnspentOutput}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionunspentoutput_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionUnspentOutput.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type does NOT support fine-tuned encoding options so this may or may not be
    *             * canonical CBOR and may or may not preserve round-trip encodings.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionunspentoutput_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {TransactionUnspentOutput}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionunspentoutput_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionUnspentOutput.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {TransactionInput} input
    * @param {TransactionOutput} output
    * @returns {TransactionUnspentOutput}
    */
    static new(input, output) {
        _assertClass(input, TransactionInput);
        _assertClass(output, TransactionOutput);
        const ret = wasm.transactionunspentoutput_new(input.ptr, output.ptr);
        return TransactionUnspentOutput.__wrap(ret);
    }
}

const TransactionWitnessSetFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionwitnessset_free(ptr));
/**
*/
export class TransactionWitnessSet {

    static __wrap(ptr) {
        const obj = Object.create(TransactionWitnessSet.prototype);
        obj.ptr = ptr;
        TransactionWitnessSetFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionWitnessSetFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionwitnessset_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionwitnessset_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {TransactionWitnessSet}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionwitnessset_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionWitnessSet.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionwitnessset_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {TransactionWitnessSet}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionwitnessset_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionWitnessSet.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionwitnessset_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionwitnessset_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {TransactionWitnessSet}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.transactionwitnessset_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionWitnessSet.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {VkeywitnessList} vkeywitnesses
    */
    set_vkeywitnesses(vkeywitnesses) {
        _assertClass(vkeywitnesses, VkeywitnessList);
        wasm.transactionwitnessset_set_vkeywitnesses(this.ptr, vkeywitnesses.ptr);
    }
    /**
    * @returns {VkeywitnessList | undefined}
    */
    vkeywitnesses() {
        const ret = wasm.transactionwitnessset_vkeywitnesses(this.ptr);
        return ret === 0 ? undefined : VkeywitnessList.__wrap(ret);
    }
    /**
    * @param {NativeScriptList} native_scripts
    */
    set_native_scripts(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        wasm.transactionwitnessset_set_native_scripts(this.ptr, native_scripts.ptr);
    }
    /**
    * @returns {NativeScriptList | undefined}
    */
    native_scripts() {
        const ret = wasm.transactionwitnessset_native_scripts(this.ptr);
        return ret === 0 ? undefined : NativeScriptList.__wrap(ret);
    }
    /**
    * @param {BootstrapWitnessList} bootstrap_witnesses
    */
    set_bootstrap_witnesses(bootstrap_witnesses) {
        _assertClass(bootstrap_witnesses, BootstrapWitnessList);
        wasm.transactionwitnessset_set_bootstrap_witnesses(this.ptr, bootstrap_witnesses.ptr);
    }
    /**
    * @returns {BootstrapWitnessList | undefined}
    */
    bootstrap_witnesses() {
        const ret = wasm.transactionwitnessset_bootstrap_witnesses(this.ptr);
        return ret === 0 ? undefined : BootstrapWitnessList.__wrap(ret);
    }
    /**
    * @param {PlutusV1ScriptList} plutus_v1_scripts
    */
    set_plutus_v1_scripts(plutus_v1_scripts) {
        _assertClass(plutus_v1_scripts, PlutusV1ScriptList);
        wasm.transactionwitnessset_set_plutus_v1_scripts(this.ptr, plutus_v1_scripts.ptr);
    }
    /**
    * @returns {PlutusV1ScriptList | undefined}
    */
    plutus_v1_scripts() {
        const ret = wasm.transactionwitnessset_plutus_v1_scripts(this.ptr);
        return ret === 0 ? undefined : PlutusV1ScriptList.__wrap(ret);
    }
    /**
    * @param {PlutusDataList} plutus_datums
    */
    set_plutus_datums(plutus_datums) {
        _assertClass(plutus_datums, PlutusDataList);
        wasm.transactionwitnessset_set_plutus_datums(this.ptr, plutus_datums.ptr);
    }
    /**
    * @returns {PlutusDataList | undefined}
    */
    plutus_datums() {
        const ret = wasm.transactionwitnessset_plutus_datums(this.ptr);
        return ret === 0 ? undefined : PlutusDataList.__wrap(ret);
    }
    /**
    * @param {RedeemerList} redeemers
    */
    set_redeemers(redeemers) {
        _assertClass(redeemers, RedeemerList);
        wasm.transactionwitnessset_set_redeemers(this.ptr, redeemers.ptr);
    }
    /**
    * @returns {RedeemerList | undefined}
    */
    redeemers() {
        const ret = wasm.transactionwitnessset_redeemers(this.ptr);
        return ret === 0 ? undefined : RedeemerList.__wrap(ret);
    }
    /**
    * @param {PlutusV2ScriptList} plutus_v2_scripts
    */
    set_plutus_v2_scripts(plutus_v2_scripts) {
        _assertClass(plutus_v2_scripts, PlutusV2ScriptList);
        wasm.transactionwitnessset_set_plutus_v2_scripts(this.ptr, plutus_v2_scripts.ptr);
    }
    /**
    * @returns {PlutusV2ScriptList | undefined}
    */
    plutus_v2_scripts() {
        const ret = wasm.transactionwitnessset_plutus_v2_scripts(this.ptr);
        return ret === 0 ? undefined : PlutusV2ScriptList.__wrap(ret);
    }
    /**
    * @param {PlutusV3ScriptList} plutus_v3_scripts
    */
    set_plutus_v3_scripts(plutus_v3_scripts) {
        _assertClass(plutus_v3_scripts, PlutusV3ScriptList);
        wasm.transactionwitnessset_set_plutus_v3_scripts(this.ptr, plutus_v3_scripts.ptr);
    }
    /**
    * @returns {PlutusV3ScriptList | undefined}
    */
    plutus_v3_scripts() {
        const ret = wasm.transactionwitnessset_plutus_v3_scripts(this.ptr);
        return ret === 0 ? undefined : PlutusV3ScriptList.__wrap(ret);
    }
    /**
    * @returns {TransactionWitnessSet}
    */
    static new() {
        const ret = wasm.transactionwitnessset_new();
        return TransactionWitnessSet.__wrap(ret);
    }
    /**
    * @param {TransactionWitnessSet} other
    */
    add_all_witnesses(other) {
        _assertClass(other, TransactionWitnessSet);
        wasm.transactionwitnessset_add_all_witnesses(this.ptr, other.ptr);
    }
    /**
    * @returns {LanguageList}
    */
    languages() {
        const ret = wasm.transactionwitnessset_languages(this.ptr);
        return LanguageList.__wrap(ret);
    }
}

const TransactionWitnessSetBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionwitnesssetbuilder_free(ptr));
/**
* Builder de-duplicates witnesses as they are added
*/
export class TransactionWitnessSetBuilder {

    static __wrap(ptr) {
        const obj = Object.create(TransactionWitnessSetBuilder.prototype);
        obj.ptr = ptr;
        TransactionWitnessSetBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionWitnessSetBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionwitnesssetbuilder_free(ptr);
    }
    /**
    * @param {Vkeywitness} vkey_witness
    */
    add_vkey(vkey_witness) {
        _assertClass(vkey_witness, Vkeywitness);
        wasm.transactionwitnesssetbuilder_add_vkey(this.ptr, vkey_witness.ptr);
    }
    /**
    * @param {BootstrapWitness} bootstrap
    */
    add_bootstrap(bootstrap) {
        _assertClass(bootstrap, BootstrapWitness);
        wasm.transactionwitnesssetbuilder_add_bootstrap(this.ptr, bootstrap.ptr);
    }
    /**
    * @param {Script} script
    */
    add_script(script) {
        _assertClass(script, Script);
        wasm.transactionwitnesssetbuilder_add_script(this.ptr, script.ptr);
    }
    /**
    * @returns {NativeScriptList}
    */
    get_native_script() {
        const ret = wasm.transactionwitnesssetbuilder_get_native_script(this.ptr);
        return NativeScriptList.__wrap(ret);
    }
    /**
    * @returns {PlutusV1ScriptList}
    */
    get_plutus_v1_script() {
        const ret = wasm.transactionwitnesssetbuilder_get_plutus_v1_script(this.ptr);
        return PlutusV1ScriptList.__wrap(ret);
    }
    /**
    * @returns {PlutusV2ScriptList}
    */
    get_plutus_v2_script() {
        const ret = wasm.transactionwitnesssetbuilder_get_plutus_v2_script(this.ptr);
        return PlutusV2ScriptList.__wrap(ret);
    }
    /**
    * @param {PlutusData} plutus_datum
    */
    add_plutus_datum(plutus_datum) {
        _assertClass(plutus_datum, PlutusData);
        var ptr0 = plutus_datum.ptr;
        plutus_datum.ptr = 0;
        wasm.transactionwitnesssetbuilder_add_plutus_datum(this.ptr, ptr0);
    }
    /**
    * @returns {PlutusDataList}
    */
    get_plutus_datum() {
        const ret = wasm.transactionwitnesssetbuilder_get_plutus_datum(this.ptr);
        return PlutusDataList.__wrap(ret);
    }
    /**
    * @param {Redeemer} redeemer
    */
    add_redeemer(redeemer) {
        _assertClass(redeemer, Redeemer);
        wasm.transactionwitnesssetbuilder_add_redeemer(this.ptr, redeemer.ptr);
    }
    /**
    * @returns {RedeemerList}
    */
    get_redeemer() {
        const ret = wasm.transactionwitnesssetbuilder_get_redeemer(this.ptr);
        return RedeemerList.__wrap(ret);
    }
    /**
    * @param {RequiredWitnessSet} required_wits
    */
    add_required_wits(required_wits) {
        _assertClass(required_wits, RequiredWitnessSet);
        wasm.transactionwitnesssetbuilder_add_required_wits(this.ptr, required_wits.ptr);
    }
    /**
    * @returns {TransactionWitnessSetBuilder}
    */
    static new() {
        const ret = wasm.transactionwitnesssetbuilder_new();
        return TransactionWitnessSetBuilder.__wrap(ret);
    }
    /**
    * @param {TransactionWitnessSet} wit_set
    */
    add_existing(wit_set) {
        _assertClass(wit_set, TransactionWitnessSet);
        wasm.transactionwitnesssetbuilder_add_existing(this.ptr, wit_set.ptr);
    }
    /**
    * @returns {TransactionWitnessSet}
    */
    build() {
        const ret = wasm.transactionwitnesssetbuilder_build(this.ptr);
        return TransactionWitnessSet.__wrap(ret);
    }
    /**
    * @returns {RequiredWitnessSet}
    */
    remaining_wits() {
        const ret = wasm.transactionwitnesssetbuilder_remaining_wits(this.ptr);
        return RequiredWitnessSet.__wrap(ret);
    }
    /**
    * @returns {TransactionWitnessSet}
    */
    try_build() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.transactionwitnesssetbuilder_try_build(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TransactionWitnessSet.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {RequiredWitnessSet} required_wits
    */
    merge_fake_witness(required_wits) {
        _assertClass(required_wits, RequiredWitnessSet);
        wasm.transactionwitnesssetbuilder_merge_fake_witness(this.ptr, required_wits.ptr);
    }
}

const TransactionWitnessSetListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_transactionwitnesssetlist_free(ptr));
/**
*/
export class TransactionWitnessSetList {

    static __wrap(ptr) {
        const obj = Object.create(TransactionWitnessSetList.prototype);
        obj.ptr = ptr;
        TransactionWitnessSetListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TransactionWitnessSetListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionwitnesssetlist_free(ptr);
    }
    /**
    * @returns {TransactionWitnessSetList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return TransactionWitnessSetList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.transactionwitnesssetlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {TransactionWitnessSet}
    */
    get(index) {
        const ret = wasm.transactionwitnesssetlist_get(this.ptr, index);
        return TransactionWitnessSet.__wrap(ret);
    }
    /**
    * @param {TransactionWitnessSet} elem
    */
    add(elem) {
        _assertClass(elem, TransactionWitnessSet);
        wasm.transactionwitnesssetlist_add(this.ptr, elem.ptr);
    }
}

const TreasuryWithdrawalsActionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_treasurywithdrawalsaction_free(ptr));
/**
*/
export class TreasuryWithdrawalsAction {

    static __wrap(ptr) {
        const obj = Object.create(TreasuryWithdrawalsAction.prototype);
        obj.ptr = ptr;
        TreasuryWithdrawalsActionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TreasuryWithdrawalsActionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_treasurywithdrawalsaction_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.treasurywithdrawalsaction_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {TreasuryWithdrawalsAction}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.treasurywithdrawalsaction_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TreasuryWithdrawalsAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.treasurywithdrawalsaction_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {TreasuryWithdrawalsAction}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.treasurywithdrawalsaction_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TreasuryWithdrawalsAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.treasurywithdrawalsaction_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.treasurywithdrawalsaction_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {TreasuryWithdrawalsAction}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.treasurywithdrawalsaction_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return TreasuryWithdrawalsAction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {MapRewardAccountToCoin}
    */
    withdrawal() {
        const ret = wasm.treasurywithdrawalsaction_withdrawal(this.ptr);
        return MapRewardAccountToCoin.__wrap(ret);
    }
    /**
    * @param {MapRewardAccountToCoin} withdrawal
    * @returns {TreasuryWithdrawalsAction}
    */
    static new(withdrawal) {
        _assertClass(withdrawal, MapRewardAccountToCoin);
        const ret = wasm.treasurywithdrawalsaction_new(withdrawal.ptr);
        return TreasuryWithdrawalsAction.__wrap(ret);
    }
}

const TxRedeemerBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_txredeemerbuilder_free(ptr));
/**
*/
export class TxRedeemerBuilder {

    static __wrap(ptr) {
        const obj = Object.create(TxRedeemerBuilder.prototype);
        obj.ptr = ptr;
        TxRedeemerBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TxRedeemerBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_txredeemerbuilder_free(ptr);
    }
    /**
    * Builds the transaction and moves to the next step where any real witness can be added
    * NOTE: is_valid set to true
    * Will NOT require you to have set required signers & witnesses
    * @returns {RedeemerList}
    */
    build() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.txredeemerbuilder_build(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RedeemerList.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * used to override the exunit values initially provided when adding inputs
    * @param {RedeemerWitnessKey} redeemer
    * @param {ExUnits} ex_units
    */
    set_exunits(redeemer, ex_units) {
        _assertClass(redeemer, RedeemerWitnessKey);
        _assertClass(ex_units, ExUnits);
        wasm.txredeemerbuilder_set_exunits(this.ptr, redeemer.ptr, ex_units.ptr);
    }
    /**
    * Transaction body with a dummy values for redeemers & script_data_hash
    * Used for calculating exunits or required signers
    * @returns {TransactionBody}
    */
    draft_body() {
        const ret = wasm.txredeemerbuilder_draft_body(this.ptr);
        return TransactionBody.__wrap(ret);
    }
    /**
    * @returns {AuxiliaryData | undefined}
    */
    auxiliary_data() {
        const ret = wasm.txredeemerbuilder_auxiliary_data(this.ptr);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
    /**
    * Transaction body with a dummy values for redeemers & script_data_hash and padded with dummy witnesses
    * Used for calculating exunits
    * note: is_valid set to true
    * @returns {Transaction}
    */
    draft_tx() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.txredeemerbuilder_draft_tx(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Transaction.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const UnitIntervalFinalization = new FinalizationRegistry(ptr => wasm.__wbg_unitinterval_free(ptr));
/**
*/
export class UnitInterval {

    static __wrap(ptr) {
        const obj = Object.create(UnitInterval.prototype);
        obj.ptr = ptr;
        UnitIntervalFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        UnitIntervalFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_unitinterval_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unitinterval_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {UnitInterval}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.unitinterval_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnitInterval.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unitinterval_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {UnitInterval}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.unitinterval_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnitInterval.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unitinterval_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unitinterval_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {UnitInterval}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.unitinterval_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnitInterval.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {bigint}
    */
    start() {
        const ret = wasm.unitinterval_start(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {bigint}
    */
    end() {
        const ret = wasm.unitinterval_end(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} start
    * @param {bigint} end
    * @returns {UnitInterval}
    */
    static new(start, end) {
        const ret = wasm.rational_new(start, end);
        return UnitInterval.__wrap(ret);
    }
}

const UnregCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_unregcert_free(ptr));
/**
*/
export class UnregCert {

    static __wrap(ptr) {
        const obj = Object.create(UnregCert.prototype);
        obj.ptr = ptr;
        UnregCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        UnregCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_unregcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unregcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {UnregCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.unregcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnregCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unregcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {UnregCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.unregcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnregCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unregcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unregcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {UnregCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.unregcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnregCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    stake_credential() {
        const ret = wasm.unregcert_stake_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    coin() {
        const ret = wasm.unregcert_coin(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {bigint} coin
    * @returns {UnregCert}
    */
    static new(stake_credential, coin) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.regcert_new(stake_credential.ptr, coin);
        return UnregCert.__wrap(ret);
    }
}

const UnregDrepCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_unregdrepcert_free(ptr));
/**
*/
export class UnregDrepCert {

    static __wrap(ptr) {
        const obj = Object.create(UnregDrepCert.prototype);
        obj.ptr = ptr;
        UnregDrepCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        UnregDrepCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_unregdrepcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unregdrepcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {UnregDrepCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.unregdrepcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnregDrepCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unregdrepcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {UnregDrepCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.unregdrepcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnregDrepCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unregdrepcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unregdrepcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {UnregDrepCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.unregdrepcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnregDrepCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    drep_credential() {
        const ret = wasm.unregdrepcert_drep_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    coin() {
        const ret = wasm.unregdrepcert_coin(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {Credential} drep_credential
    * @param {bigint} coin
    * @returns {UnregDrepCert}
    */
    static new(drep_credential, coin) {
        _assertClass(drep_credential, Credential);
        const ret = wasm.regcert_new(drep_credential.ptr, coin);
        return UnregDrepCert.__wrap(ret);
    }
}

const UntaggedRedeemerFinalization = new FinalizationRegistry(ptr => wasm.__wbg_untaggedredeemer_free(ptr));
/**
* Redeemer without the tag of index
* This allows builder code to return partial redeemers
* and then later have them placed in the right context
*/
export class UntaggedRedeemer {

    static __wrap(ptr) {
        const obj = Object.create(UntaggedRedeemer.prototype);
        obj.ptr = ptr;
        UntaggedRedeemerFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        UntaggedRedeemerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_untaggedredeemer_free(ptr);
    }
    /**
    * @param {PlutusData} data
    * @param {ExUnits} ex_units
    * @returns {UntaggedRedeemer}
    */
    static new(data, ex_units) {
        _assertClass(data, PlutusData);
        _assertClass(ex_units, ExUnits);
        const ret = wasm.untaggedredeemer_new(data.ptr, ex_units.ptr);
        return UntaggedRedeemer.__wrap(ret);
    }
}

const UpdateDrepCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_updatedrepcert_free(ptr));
/**
*/
export class UpdateDrepCert {

    static __wrap(ptr) {
        const obj = Object.create(UpdateDrepCert.prototype);
        obj.ptr = ptr;
        UpdateDrepCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        UpdateDrepCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_updatedrepcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.updatedrepcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {UpdateDrepCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.updatedrepcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UpdateDrepCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.updatedrepcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {UpdateDrepCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.updatedrepcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UpdateDrepCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.updatedrepcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.updatedrepcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {UpdateDrepCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.updatedrepcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UpdateDrepCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    drep_credential() {
        const ret = wasm.updatedrepcert_drep_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {Anchor | undefined}
    */
    anchor() {
        const ret = wasm.updatedrepcert_anchor(this.ptr);
        return ret === 0 ? undefined : Anchor.__wrap(ret);
    }
    /**
    * @param {Credential} drep_credential
    * @param {Anchor | undefined} anchor
    * @returns {UpdateDrepCert}
    */
    static new(drep_credential, anchor) {
        _assertClass(drep_credential, Credential);
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.ptr;
            anchor.ptr = 0;
        }
        const ret = wasm.updatedrepcert_new(drep_credential.ptr, ptr0);
        return UpdateDrepCert.__wrap(ret);
    }
}

const UrlFinalization = new FinalizationRegistry(ptr => wasm.__wbg_url_free(ptr));
/**
*/
export class Url {

    static __wrap(ptr) {
        const obj = Object.create(Url.prototype);
        obj.ptr = ptr;
        UrlFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        UrlFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_url_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.url_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Url}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.url_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Url.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.url_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Url}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.url_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Url.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.url_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.url_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Url}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.url_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Url.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.url_get(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}

const VRFCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_vrfcert_free(ptr));
/**
*/
export class VRFCert {

    static __wrap(ptr) {
        const obj = Object.create(VRFCert.prototype);
        obj.ptr = ptr;
        VRFCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VRFCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vrfcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vrfcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {VRFCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VRFCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vrfcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {VRFCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VRFCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vrfcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vrfcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {VRFCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VRFCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    output() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vrfcert_output(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    proof() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vrfcert_proof(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} output
    * @param {Uint8Array} proof
    * @returns {VRFCert}
    */
    static new(output, proof) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(output, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passArray8ToWasm0(proof, wasm.__wbindgen_malloc);
            const len1 = WASM_VECTOR_LEN;
            wasm.vrfcert_new(retptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VRFCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const VRFKeyHashFinalization = new FinalizationRegistry(ptr => wasm.__wbg_vrfkeyhash_free(ptr));
/**
*/
export class VRFKeyHash {

    static __wrap(ptr) {
        const obj = Object.create(VRFKeyHash.prototype);
        obj.ptr = ptr;
        VRFKeyHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VRFKeyHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vrfkeyhash_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vrfkeyhash_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfkeyhash_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vrfkeyhash_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {VRFKeyHash}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfkeyhash_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VRFKeyHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {VRFKeyHash}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfkeyhash_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VRFKeyHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {VRFKeyHash}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfkeyhash_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VRFKeyHash.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const VRFVkeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_vrfvkey_free(ptr));
/**
*/
export class VRFVkey {

    static __wrap(ptr) {
        const obj = Object.create(VRFVkey.prototype);
        obj.ptr = ptr;
        VRFVkeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VRFVkeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vrfvkey_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_raw_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vrfvkey_to_raw_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} prefix
    * @returns {string}
    */
    to_bech32(prefix) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfvkey_to_bech32(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * @returns {string}
    */
    to_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vrfvkey_to_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {string} bech32_str
    * @returns {VRFVkey}
    */
    static from_bech32(bech32_str) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfvkey_from_bech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VRFVkey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} input
    * @returns {VRFVkey}
    */
    static from_hex(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfvkey_from_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VRFVkey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {VRFVkey}
    */
    static from_raw_bytes(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vrfvkey_from_raw_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VRFVkey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

const ValueFinalization = new FinalizationRegistry(ptr => wasm.__wbg_value_free(ptr));
/**
*/
export class Value {

    static __wrap(ptr) {
        const obj = Object.create(Value.prototype);
        obj.ptr = ptr;
        ValueFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ValueFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_value_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.value_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Value}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.value_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Value.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.value_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Value}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.value_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Value.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.value_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.value_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Value}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.value_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Value.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} coin
    * @returns {Value}
    */
    static from_coin(coin) {
        const ret = wasm.value_from_coin(coin);
        return Value.__wrap(ret);
    }
    /**
    * @param {bigint} coin
    * @param {MultiAsset} multiasset
    * @returns {Value}
    */
    static new(coin, multiasset) {
        _assertClass(multiasset, MultiAsset);
        const ret = wasm.value_new(coin, multiasset.ptr);
        return Value.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    coin() {
        const ret = wasm.value_coin(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @returns {MultiAsset}
    */
    multi_asset() {
        const ret = wasm.value_multi_asset(this.ptr);
        return MultiAsset.__wrap(ret);
    }
    /**
    * @returns {Value}
    */
    static zero() {
        const ret = wasm.value_zero();
        return Value.__wrap(ret);
    }
    /**
    * @returns {boolean}
    */
    is_zero() {
        const ret = wasm.value_is_zero(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    has_multiassets() {
        const ret = wasm.value_has_multiassets(this.ptr);
        return ret !== 0;
    }
    /**
    * @param {Value} rhs
    * @returns {Value}
    */
    checked_add(rhs) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(rhs, Value);
            wasm.value_checked_add(retptr, this.ptr, rhs.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Value.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Subtract ADA and/or assets
    * Removes an asset from the list if the result is 0 or less
    * Does not modify this object, instead the result is returned
    * None is returned if there would be integer underflow
    * @param {Value} rhs
    * @returns {Value}
    */
    checked_sub(rhs) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(rhs, Value);
            wasm.value_checked_sub(retptr, this.ptr, rhs.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Value.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Value} rhs
    * @returns {Value}
    */
    clamped_sub(rhs) {
        _assertClass(rhs, Value);
        const ret = wasm.value_clamped_sub(this.ptr, rhs.ptr);
        return Value.__wrap(ret);
    }
}

const VkeywitnessFinalization = new FinalizationRegistry(ptr => wasm.__wbg_vkeywitness_free(ptr));
/**
*/
export class Vkeywitness {

    static __wrap(ptr) {
        const obj = Object.create(Vkeywitness.prototype);
        obj.ptr = ptr;
        VkeywitnessFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VkeywitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vkeywitness_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vkeywitness_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Vkeywitness}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vkeywitness_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Vkeywitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vkeywitness_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Vkeywitness}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vkeywitness_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Vkeywitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vkeywitness_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vkeywitness_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Vkeywitness}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.vkeywitness_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Vkeywitness.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {PublicKey}
    */
    vkey() {
        const ret = wasm.vkeywitness_vkey(this.ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {Ed25519Signature}
    */
    ed25519_signature() {
        const ret = wasm.vkeywitness_ed25519_signature(this.ptr);
        return Ed25519Signature.__wrap(ret);
    }
    /**
    * @param {PublicKey} vkey
    * @param {Ed25519Signature} ed25519_signature
    * @returns {Vkeywitness}
    */
    static new(vkey, ed25519_signature) {
        _assertClass(vkey, PublicKey);
        _assertClass(ed25519_signature, Ed25519Signature);
        const ret = wasm.vkeywitness_new(vkey.ptr, ed25519_signature.ptr);
        return Vkeywitness.__wrap(ret);
    }
}

const VkeywitnessListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_vkeywitnesslist_free(ptr));
/**
*/
export class VkeywitnessList {

    static __wrap(ptr) {
        const obj = Object.create(VkeywitnessList.prototype);
        obj.ptr = ptr;
        VkeywitnessListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VkeywitnessListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vkeywitnesslist_free(ptr);
    }
    /**
    * @returns {VkeywitnessList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return VkeywitnessList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.vkeywitnesslist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Vkeywitness}
    */
    get(index) {
        const ret = wasm.vkeywitnesslist_get(this.ptr, index);
        return Vkeywitness.__wrap(ret);
    }
    /**
    * @param {Vkeywitness} elem
    */
    add(elem) {
        _assertClass(elem, Vkeywitness);
        wasm.vkeywitnesslist_add(this.ptr, elem.ptr);
    }
}

const VoteDelegCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_votedelegcert_free(ptr));
/**
*/
export class VoteDelegCert {

    static __wrap(ptr) {
        const obj = Object.create(VoteDelegCert.prototype);
        obj.ptr = ptr;
        VoteDelegCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VoteDelegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_votedelegcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.votedelegcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {VoteDelegCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.votedelegcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VoteDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.votedelegcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {VoteDelegCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.votedelegcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VoteDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.votedelegcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.votedelegcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {VoteDelegCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.votedelegcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VoteDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    stake_credential() {
        const ret = wasm.votedelegcert_stake_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {DRep}
    */
    d_rep() {
        const ret = wasm.votedelegcert_d_rep(this.ptr);
        return DRep.__wrap(ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {DRep} d_rep
    * @returns {VoteDelegCert}
    */
    static new(stake_credential, d_rep) {
        _assertClass(stake_credential, Credential);
        _assertClass(d_rep, DRep);
        const ret = wasm.votedelegcert_new(stake_credential.ptr, d_rep.ptr);
        return VoteDelegCert.__wrap(ret);
    }
}

const VoteRegDelegCertFinalization = new FinalizationRegistry(ptr => wasm.__wbg_voteregdelegcert_free(ptr));
/**
*/
export class VoteRegDelegCert {

    static __wrap(ptr) {
        const obj = Object.create(VoteRegDelegCert.prototype);
        obj.ptr = ptr;
        VoteRegDelegCertFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VoteRegDelegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_voteregdelegcert_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.voteregdelegcert_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {VoteRegDelegCert}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.voteregdelegcert_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VoteRegDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.voteregdelegcert_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {VoteRegDelegCert}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.voteregdelegcert_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VoteRegDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.voteregdelegcert_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.voteregdelegcert_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {VoteRegDelegCert}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.voteregdelegcert_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VoteRegDelegCert.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Credential}
    */
    stake_credential() {
        const ret = wasm.voteregdelegcert_stake_credential(this.ptr);
        return Credential.__wrap(ret);
    }
    /**
    * @returns {DRep}
    */
    d_rep() {
        const ret = wasm.voteregdelegcert_d_rep(this.ptr);
        return DRep.__wrap(ret);
    }
    /**
    * @returns {bigint}
    */
    coin() {
        const ret = wasm.voteregdelegcert_coin(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {Credential} stake_credential
    * @param {DRep} d_rep
    * @param {bigint} coin
    * @returns {VoteRegDelegCert}
    */
    static new(stake_credential, d_rep, coin) {
        _assertClass(stake_credential, Credential);
        _assertClass(d_rep, DRep);
        const ret = wasm.voteregdelegcert_new(stake_credential.ptr, d_rep.ptr, coin);
        return VoteRegDelegCert.__wrap(ret);
    }
}

const VoterFinalization = new FinalizationRegistry(ptr => wasm.__wbg_voter_free(ptr));
/**
*/
export class Voter {

    static __wrap(ptr) {
        const obj = Object.create(Voter.prototype);
        obj.ptr = ptr;
        VoterFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VoterFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_voter_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.voter_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {Voter}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.voter_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Voter.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.voter_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {Voter}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.voter_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Voter.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.voter_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.voter_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {Voter}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.voter_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Voter.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Ed25519KeyHash} ed25519_key_hash
    * @returns {Voter}
    */
    static new_constitutional_committee_hot_key_hash(ed25519_key_hash) {
        _assertClass(ed25519_key_hash, Ed25519KeyHash);
        const ret = wasm.voter_new_constitutional_committee_hot_key_hash(ed25519_key_hash.ptr);
        return Voter.__wrap(ret);
    }
    /**
    * @param {ScriptHash} script_hash
    * @returns {Voter}
    */
    static new_constitutional_committee_hot_script_hash(script_hash) {
        _assertClass(script_hash, ScriptHash);
        const ret = wasm.voter_new_constitutional_committee_hot_script_hash(script_hash.ptr);
        return Voter.__wrap(ret);
    }
    /**
    * @param {Ed25519KeyHash} ed25519_key_hash
    * @returns {Voter}
    */
    static new_d_rep_key_hash(ed25519_key_hash) {
        _assertClass(ed25519_key_hash, Ed25519KeyHash);
        const ret = wasm.voter_new_d_rep_key_hash(ed25519_key_hash.ptr);
        return Voter.__wrap(ret);
    }
    /**
    * @param {ScriptHash} script_hash
    * @returns {Voter}
    */
    static new_d_rep_script_hash(script_hash) {
        _assertClass(script_hash, ScriptHash);
        const ret = wasm.voter_new_d_rep_script_hash(script_hash.ptr);
        return Voter.__wrap(ret);
    }
    /**
    * @param {Ed25519KeyHash} ed25519_key_hash
    * @returns {Voter}
    */
    static new_staking_pool_key_hash(ed25519_key_hash) {
        _assertClass(ed25519_key_hash, Ed25519KeyHash);
        const ret = wasm.voter_new_staking_pool_key_hash(ed25519_key_hash.ptr);
        return Voter.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        const ret = wasm.voter_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {Ed25519KeyHash | undefined}
    */
    as_constitutional_committee_hot_key_hash() {
        const ret = wasm.voter_as_constitutional_committee_hot_key_hash(this.ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @returns {ScriptHash | undefined}
    */
    as_constitutional_committee_hot_script_hash() {
        const ret = wasm.voter_as_constitutional_committee_hot_script_hash(this.ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
    /**
    * @returns {Ed25519KeyHash | undefined}
    */
    as_d_rep_key_hash() {
        const ret = wasm.voter_as_d_rep_key_hash(this.ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
    /**
    * @returns {ScriptHash | undefined}
    */
    as_d_rep_script_hash() {
        const ret = wasm.voter_as_d_rep_script_hash(this.ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
    /**
    * @returns {Ed25519KeyHash | undefined}
    */
    as_staking_pool_key_hash() {
        const ret = wasm.voter_as_staking_pool_key_hash(this.ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
}

const VoterListFinalization = new FinalizationRegistry(ptr => wasm.__wbg_voterlist_free(ptr));
/**
*/
export class VoterList {

    static __wrap(ptr) {
        const obj = Object.create(VoterList.prototype);
        obj.ptr = ptr;
        VoterListFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VoterListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_voterlist_free(ptr);
    }
    /**
    * @returns {VoterList}
    */
    static new() {
        const ret = wasm.assetnamelist_new();
        return VoterList.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.voterlist_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Voter}
    */
    get(index) {
        const ret = wasm.voterlist_get(this.ptr, index);
        return Voter.__wrap(ret);
    }
    /**
    * @param {Voter} elem
    */
    add(elem) {
        _assertClass(elem, Voter);
        wasm.voterlist_add(this.ptr, elem.ptr);
    }
}

const VotingProcedureFinalization = new FinalizationRegistry(ptr => wasm.__wbg_votingprocedure_free(ptr));
/**
*/
export class VotingProcedure {

    static __wrap(ptr) {
        const obj = Object.create(VotingProcedure.prototype);
        obj.ptr = ptr;
        VotingProcedureFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VotingProcedureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_votingprocedure_free(ptr);
    }
    /**
    *
    *             * Serialize this type to CBOR bytes
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {Uint8Array}
    */
    to_cbor_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.votingprocedure_to_cbor_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Create this type from CBOR bytes
    *
    * @param {Uint8Array} cbor_bytes
    * @returns {VotingProcedure}
    */
    static from_cbor_bytes(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.votingprocedure_from_cbor_bytes(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VotingProcedure.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    *
    *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
    *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
    *             * If created from scratch the CBOR will be canonical.
    *
    * @returns {string}
    */
    to_cbor_hex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.votingprocedure_to_cbor_hex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    *
    *             * Create this type from the CBOR bytes encoded as a hex string.
    *             * This is useful for interfacing with CIP30
    *
    * @param {string} cbor_bytes
    * @returns {VotingProcedure}
    */
    static from_cbor_hex(cbor_bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.votingprocedure_from_cbor_hex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VotingProcedure.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    to_json() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.votingprocedure_to_json(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {any}
    */
    to_js_value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.votingprocedure_to_js_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} json
    * @returns {VotingProcedure}
    */
    static from_json(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.votingprocedure_from_json(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VotingProcedure.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number}
    */
    vote() {
        const ret = wasm.votingprocedure_vote(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {Anchor | undefined}
    */
    anchor() {
        const ret = wasm.votingprocedure_anchor(this.ptr);
        return ret === 0 ? undefined : Anchor.__wrap(ret);
    }
    /**
    * @param {number} vote
    * @param {Anchor | undefined} anchor
    * @returns {VotingProcedure}
    */
    static new(vote, anchor) {
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.ptr;
            anchor.ptr = 0;
        }
        const ret = wasm.votingprocedure_new(vote, ptr0);
        return VotingProcedure.__wrap(ret);
    }
}

const VotingProceduresFinalization = new FinalizationRegistry(ptr => wasm.__wbg_votingprocedures_free(ptr));
/**
*/
export class VotingProcedures {

    static __wrap(ptr) {
        const obj = Object.create(VotingProcedures.prototype);
        obj.ptr = ptr;
        VotingProceduresFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VotingProceduresFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_votingprocedures_free(ptr);
    }
    /**
    * @returns {VotingProcedures}
    */
    static new() {
        const ret = wasm.votingprocedures_new();
        return VotingProcedures.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        const ret = wasm.votingprocedures_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {Voter} key
    * @param {MapGovActionIdToVotingProcedure} value
    * @returns {MapGovActionIdToVotingProcedure | undefined}
    */
    insert(key, value) {
        _assertClass(key, Voter);
        _assertClass(value, MapGovActionIdToVotingProcedure);
        const ret = wasm.votingprocedures_insert(this.ptr, key.ptr, value.ptr);
        return ret === 0 ? undefined : MapGovActionIdToVotingProcedure.__wrap(ret);
    }
    /**
    * @param {Voter} key
    * @returns {MapGovActionIdToVotingProcedure | undefined}
    */
    get(key) {
        _assertClass(key, Voter);
        const ret = wasm.votingprocedures_get(this.ptr, key.ptr);
        return ret === 0 ? undefined : MapGovActionIdToVotingProcedure.__wrap(ret);
    }
    /**
    * @returns {VoterList}
    */
    keys() {
        const ret = wasm.votingprocedures_keys(this.ptr);
        return VoterList.__wrap(ret);
    }
}

const WithdrawalBuilderResultFinalization = new FinalizationRegistry(ptr => wasm.__wbg_withdrawalbuilderresult_free(ptr));
/**
*/
export class WithdrawalBuilderResult {

    static __wrap(ptr) {
        const obj = Object.create(WithdrawalBuilderResult.prototype);
        obj.ptr = ptr;
        WithdrawalBuilderResultFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        WithdrawalBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_withdrawalbuilderresult_free(ptr);
    }
}

async function load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function getImports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbindgen_memory = function() {
        const ret = wasm.memory;
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_is_object = function(arg0) {
        const val = getObject(arg0);
        const ret = typeof(val) === 'object' && val !== null;
        return ret;
    };
    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
        takeObject(arg0);
    };
    imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() {
        const ret = new Array();
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_number_new = function(arg0) {
        const ret = arg0;
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_is_string = function(arg0) {
        const ret = typeof(getObject(arg0)) === 'string';
        return ret;
    };
    imports.wbg.__wbindgen_is_function = function(arg0) {
        const ret = typeof(getObject(arg0)) === 'function';
        return ret;
    };
    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
        const ret = getObject(arg0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_newnoargs_b5b063fc6c2f0376 = function(arg0, arg1) {
        const ret = new Function(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_268f7b7dd3430798 = function() {
        const ret = new Map();
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) {
        const ret = getObject(arg0).buffer;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_0b9bfdd97583284e = function() {
        const ret = new Object();
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        const ret = getStringFromWasm0(arg0, arg1);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_self_6d479506f72c6a71 = function() { return handleError(function () {
        const ret = self.self;
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_window_f2557cc78490aceb = function() { return handleError(function () {
        const ret = window.window;
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_globalThis_7f206bda628d5286 = function() { return handleError(function () {
        const ret = globalThis.globalThis;
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_global_ba75c50d1cf384f4 = function() { return handleError(function () {
        const ret = global.global;
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbindgen_is_undefined = function(arg0) {
        const ret = getObject(arg0) === undefined;
        return ret;
    };
    imports.wbg.__wbg_set_a68214f35c417fa9 = function(arg0, arg1, arg2) {
        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
    };
    imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) {
        const ret = getObject(arg0).call(getObject(arg1));
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_call_168da88779e35f61 = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_set_933729cf5b66ac11 = function(arg0, arg1, arg2) {
        const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_d9aa266703cb98be = function(arg0, arg1, arg2) {
        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) {
        const ret = new Uint8Array(getObject(arg0));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) {
        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {
        getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    };
    imports.wbg.__wbg_crypto_566d7465cdbb6b7a = function(arg0) {
        const ret = getObject(arg0).crypto;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_process_dc09a8c7d59982f6 = function(arg0) {
        const ret = getObject(arg0).process;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_versions_d98c6400c6ca2bd8 = function(arg0) {
        const ret = getObject(arg0).versions;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_node_caaf83d002149bd5 = function(arg0) {
        const ret = getObject(arg0).node;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_require_94a9da52636aacbf = function() { return handleError(function () {
        const ret = module.require;
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_msCrypto_0b84745e9245cdf6 = function(arg0) {
        const ret = getObject(arg0).msCrypto;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_randomFillSync_290977693942bf03 = function() { return handleError(function (arg0, arg1) {
        getObject(arg0).randomFillSync(takeObject(arg1));
    }, arguments) };
    imports.wbg.__wbg_getRandomValues_260cc23a41afad9a = function() { return handleError(function (arg0, arg1) {
        getObject(arg0).getRandomValues(getObject(arg1));
    }, arguments) };
    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
        const ret = new Error(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_String_91fba7ded13ba54c = function(arg0, arg1) {
        const ret = String(getObject(arg1));
        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
    };
    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {
        const ret = arg0;
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {
        const ret = BigInt.asUintN(64, arg0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_set_20cbc34131e76824 = function(arg0, arg1, arg2) {
        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
    };

    return imports;
}

function initMemory(imports, maybe_memory) {

}

function finalizeInit(instance, module) {
    wasm = instance.exports;
    init.__wbindgen_wasm_module = module;
    cachedBigInt64Memory0 = new BigInt64Array();
    cachedInt32Memory0 = new Int32Array();
    cachedUint16Memory0 = new Uint16Array();
    cachedUint32Memory0 = new Uint32Array();
    cachedUint8Memory0 = new Uint8Array();


    return wasm;
}

function initSync(module) {
    const imports = getImports();

    initMemory(imports);

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return finalizeInit(instance, module);
}

async function init(input) {
    if (typeof input === 'undefined') {
        input = new URL('cardano_multiplatform_lib_bg.wasm', import.meta.url);
    }
    const imports = getImports();

    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {
        input = fetch(input);
    }

    initMemory(imports);

    const { instance, module } = await load(await input, imports);

    return finalizeInit(instance, module);
}

export { initSync }
export default init;
